{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:d4f32934-313e-47f8-875c-834c1bfb213b",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T13:06:45-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "03e9fe7b540f347d",
      "type": "file",
      "name": "flatcc-0.6.1/"
    }
  },
  "upgrade": {
    "file_changes": {
      "old_version": "/home/flatcc-0.5.3",
      "New file": [
        "/home/flatcc-0.6.1/include/flatcc/flatcc_assert.h",
        "/home/flatcc-0.6.1/include/flatcc/portable/pattributes.h",
        "/home/flatcc-0.6.1/include/flatcc/portable/pcrt.h",
        "/home/flatcc-0.6.1/src/compiler/codegen_c_sorter.c",
        "/home/flatcc-0.6.1/test/optional_scalars_test/optional_scalars_test.c"
      ],
      "Deleted file": [],
      "Modified file": [
        {
          "file": "/home/flatcc-0.6.1/config/config.h",
          "change": [
            "--- /home/flatcc-0.5.3/config/config.h",
            "+++ /home/flatcc-0.6.1/config/config.h",
            "@@ -7,20 +7,20 @@",
            "  * This is an alternative implementation to googles `flatc` compiler.",
            "  * This configuration enables or disable features which can be used",
            "  * to closer match the flatc behavior. The current flatc version",
            "  * may evolve over time, so the comments on flatc behavior should",
            "  * be seen as how things were when this file was last updated.",
            "  *",
            "  * One notable, but convenient, difference is that structs and enums are",
            "- * not required to be defined in a specific order here. The schema can be",
            "- * rearranged by the user to support the flatc compiler without changing",
            "- * the underlying. This does put an extra restraint on struct depth as",
            "+ * not required to be defined in a specific order here (as of June 2020",
            "+ * flatc supports out of order enums). The schema can be rearranged by",
            "+ * the user to support the flatc compiler without changing the",
            "+ * underlying. This does put an extra restraint on struct depth as",
            "  * recursion must have set maximum level, but this also applies to",
            "- * target C compilers, e.g. clang has a limit of about 100-200",
            "- * nestings.",
            "+ * target C compilers, e.g. clang has a limit of about 100-200 nestings.",
            "  *",
            "  * Another more significant difference is that structs are allowed as",
            "  * root objects. This is important if a query should return a partial",
            "  * result from a stored buffer but it isn't currently supported by",
            "  * flatc, although the documentation hints that it might be possible.",
            "  *",
            "  * Value overflows and conversions of enums and default values are",
            "@@ -90,14 +90,35 @@",
            " ",
            " /* Used when truncating some error messages. */",
            " #ifndef FLATCC_MAX_IDENT_SHOW",
            " #define FLATCC_MAX_IDENT_SHOW 50",
            " #endif",
            " ",
            " /*",
            "+ * Allow FlatBuffer schema reserved keywords",
            "+ * to be used as field identifiers. This can",
            "+ * be confusing, but also important for use with",
            "+ * JSON where the field names are visible",
            "+ * externally.",
            "+ */",
            "+#ifndef FLATCC_ALLOW_KW_FIELDS",
            "+#define FLATCC_ALLOW_KW_FIELDS 1",
            "+#endif",
            "+",
            "+/*",
            "+ * Applies to the members of an enum. These",
            "+ * names a visible in JSON. Using reserved",
            "+ * names prevent them from being used in",
            "+ * field default values.",
            "+ */",
            "+#ifndef FLATCC_ALLOW_KW_ENUMS",
            "+#define FLATCC_ALLOW_KW_ENUMS 1",
            "+#endif",
            "+",
            "+/*",
            "  * Artificial limit on grammar attributes to prevent abuse.",
            "  */",
            " #ifndef FLATCC_ATTR_MAX",
            " #define FLATCC_ATTR_MAX 100",
            " #endif",
            " ",
            " #ifndef FLATCC_FORCE_ALIGN_MAX",
            "@@ -174,17 +195,18 @@",
            " #define FLATCC_STRICT_ENUM_INIT 1",
            " #endif",
            " ",
            " /*",
            "  * flatc requires ascending enums, and it does simplify code generation",
            "  * to multiple languages, and name mapping of enums, so we require this",
            "  * by default, but C code generator handles both cases fine.",
            "+ * As of June 2020 flatc supports out of order enums.",
            "  */",
            " #ifndef FLATCC_ASCENDING_ENUM",
            "-#define FLATCC_ASCENDING_ENUM 1",
            "+#define FLATCC_ASCENDING_ENUM 0",
            " #endif",
            " ",
            " /*",
            "  * flatc tool accepts any integer as bool because it",
            "  * doesn't do range check. By enabling this flag we get more compatible,",
            "  * but still only accepts 1 or 0 as bool, and also allow assignment of",
            "  * bool to other types (useful in enums that are not bool because",
            "@@ -246,14 +268,27 @@",
            "  * coordinates at different levels.",
            "  */",
            " #ifndef FLATCC_ALLOW_MULTIPLE_KEY_FIELDS",
            " #define FLATCC_ALLOW_MULTIPLE_KEY_FIELDS 1",
            " #endif",
            " ",
            " /*",
            "+ * flatc does not have a primary_key field attribute but it is useful",
            "+ * when having multiple keys. Without a primary_key the field with the",
            "+ * lowest id becomes the default, or primary, key. This key has a",
            "+ * simpler find syntax and is also used by default when sorting.",
            "+ * When there is only one keyed field on a table it is better to use",
            "+ * the key attribute for compatibility reasons. It will automatically",
            "+ * become primary.",
            "+ */",
            "+#ifndef FLATCC_ALLOW_PRIMARY_KEY",
            "+#define FLATCC_ALLOW_PRIMARY_KEY 1",
            "+#endif",
            "+",
            "+/*",
            "  * flatcc has scan functions which are equivalent to find except they",
            "  * don't require arrays to be sorted by field and have O(N) complexity.",
            "  * It makes sense to generate these functions by default for all fields,",
            "  * not just ones marked as key.",
            "  */",
            " ",
            " #ifndef FLATCC_ALLOW_SCAN_FOR_ALL_FIELDS",
            "@@ -298,16 +333,17 @@",
            " #define FLATCC_DEFAULT_SCHEMA_EXT \".fbs\"",
            " #endif",
            " ",
            " #ifndef FLATCC_DEFAULT_BIN_SCHEMA_EXT",
            " #define FLATCC_DEFAULT_BIN_SCHEMA_EXT \".bfbs\"",
            " #endif",
            " ",
            "+/* Schema file extensions do not carry a dot by convention, do the same here. */",
            " #ifndef FLATCC_DEFAULT_BIN_EXT",
            "-#define FLATCC_DEFAULT_BIN_EXT \".bin\"",
            "+#define FLATCC_DEFAULT_BIN_EXT \"bin\"",
            " #endif",
            " ",
            " #ifndef FLATCC_DEFAULT_DEP_EXT",
            " #define FLATCC_DEFAULT_DEP_EXT \".fbs.d\"",
            " #endif",
            " ",
            " /*"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/grisu3/grisu3_math.h",
          "change": [
            "--- /home/flatcc-0.5.3/external/grisu3/grisu3_math.h",
            "+++ /home/flatcc-0.6.1/external/grisu3/grisu3_math.h",
            "@@ -59,15 +59,24 @@",
            " extern \"C\" {",
            " #endif",
            " ",
            " /* Guarded to allow inclusion of pstdint.h first, if stdint.h is not supported. */",
            " #ifndef UINT8_MAX",
            " #include <stdint.h> /* uint64_t etc. */",
            " #endif",
            "+",
            "+#ifdef GRISU3_NO_ASSERT",
            "+#undef GRISU3_ASSERT",
            "+#define GRISU3_ASSERT(x) ((void)0)",
            "+#endif",
            "+",
            "+#ifndef GRISU3_ASSERT",
            " #include <assert.h> /* assert */",
            "+#define GRISU3_ASSERT(x) assert(x)",
            "+#endif",
            " ",
            " #ifdef _MSC_VER",
            " #pragma warning(disable : 4204) /* nonstandard extension used : non-constant aggregate initializer */",
            " #endif",
            " ",
            " #define GRISU3_D64_SIGN             0x8000000000000000ULL",
            " #define GRISU3_D64_EXP_MASK         0x7FF0000000000000ULL",
            "@@ -232,15 +241,15 @@",
            "     p->e = grisu3_diy_fp_pow_cache[i].b_exp;",
            "     return grisu3_diy_fp_pow_cache[i].d_exp;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_diy_fp_minus(grisu3_diy_fp_t x, grisu3_diy_fp_t y)",
            " {",
            "     grisu3_diy_fp_t d; d.f = x.f - y.f; d.e = x.e;",
            "-    assert(x.e == y.e && x.f >= y.f);",
            "+    GRISU3_ASSERT(x.e == y.e && x.f >= y.f);",
            "     return d;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_diy_fp_multiply(grisu3_diy_fp_t x, grisu3_diy_fp_t y)",
            " {",
            "     uint64_t a, b, c, d, ac, bc, ad, bd, tmp;",
            "     grisu3_diy_fp_t r;",
            "@@ -253,15 +262,15 @@",
            "     r.f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);",
            "     r.e = x.e + y.e + 64;",
            "     return r;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_diy_fp_normalize(grisu3_diy_fp_t n)",
            " {",
            "-    assert(n.f != 0);",
            "+    GRISU3_ASSERT(n.f != 0);",
            "     while(!(n.f & 0xFFC0000000000000ULL)) { n.f <<= 10; n.e -= 10; }",
            "     while(!(n.f & GRISU3_D64_SIGN)) { n.f <<= 1; --n.e; }",
            "     return n;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_cast_diy_fp_from_double(double d)",
            " {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/grisu3/grisu3_parse.h",
          "change": [
            "--- /home/flatcc-0.5.3/external/grisu3/grisu3_parse.h",
            "+++ /home/flatcc-0.6.1/external/grisu3/grisu3_parse.h",
            "@@ -31,15 +31,14 @@",
            " #endif",
            " ",
            " #ifndef UINT8_MAX",
            " #include <stdint.h>",
            " #endif",
            " ",
            " #include <stdlib.h>",
            "-#include <assert.h>",
            " #include <limits.h>",
            " ",
            " #include \"grisu3_math.h\"",
            " ",
            " ",
            " /*",
            "  * The maximum number characters a valid number may contain.  The parse",
            "@@ -73,24 +72,24 @@",
            "  */",
            " static int grisu3_diy_fp_cached_dec_pow(int d_exp, grisu3_diy_fp_t *p)",
            " {",
            "     const int cached_offset = -GRISU3_MIN_CACHED_EXP;",
            "     const int d_exp_dist = GRISU3_CACHED_EXP_STEP;",
            "     int i, a_exp;",
            " ",
            "-    assert(GRISU3_MIN_CACHED_EXP <= d_exp);",
            "-    assert(d_exp <  GRISU3_MAX_CACHED_EXP + d_exp_dist);",
            "+    GRISU3_ASSERT(GRISU3_MIN_CACHED_EXP <= d_exp);",
            "+    GRISU3_ASSERT(d_exp <  GRISU3_MAX_CACHED_EXP + d_exp_dist);",
            " ",
            "     i = (d_exp + cached_offset) / d_exp_dist;",
            "     a_exp = grisu3_diy_fp_pow_cache[i].d_exp;",
            "     p->f = grisu3_diy_fp_pow_cache[i].fract;",
            "     p->e = grisu3_diy_fp_pow_cache[i].b_exp;",
            " ",
            "-    assert(a_exp <= d_exp);",
            "-    assert(d_exp < a_exp + d_exp_dist);",
            "+    GRISU3_ASSERT(a_exp <= d_exp);",
            "+    GRISU3_ASSERT(d_exp < a_exp + d_exp_dist);",
            " ",
            "     return a_exp;",
            " }",
            " ",
            " /*",
            "  * Ported from google double conversion strtod using",
            "  * MathGeoLibs diy_fp functions for grisu3 in C.",
            "@@ -132,15 +131,15 @@",
            "  * min double: 4.9406564584124654 * 10^-324",
            "  *",
            "  * Values just below or above min/max representable number",
            "  * may round towards large/small non-Inf/non-neg values.",
            "  *",
            "  * but `strtod` seems to return +/-HUGE_VAL on overflow?",
            "  */",
            "-int grisu3_diy_fp_encode_double(uint64_t fraction, int exponent, int fraction_exp, int ulp_half_error, double *result)",
            "+static int grisu3_diy_fp_encode_double(uint64_t fraction, int exponent, int fraction_exp, int ulp_half_error, double *result)",
            " {",
            "     /*",
            "      * Error is measures in fractions of integers, so we scale up to get",
            "      * some resolution to represent error expressions.",
            "      */",
            "     const int log2_error_one = 3;",
            "     const int error_one = 1 << log2_error_one;",
            "@@ -178,15 +177,15 @@",
            "             { 0xc800000000000000ULL, -57 },",
            "             { 0xfa00000000000000ULL, -54 },",
            "             { 0x9c40000000000000ULL, -50 },",
            "             { 0xc350000000000000ULL, -47 },",
            "             { 0xf424000000000000ULL, -44 },",
            "             { 0x9896800000000000ULL, -40 },",
            "         };",
            "-        assert(adj_exp >= 0 && adj_exp < 7);",
            "+        GRISU3_ASSERT(adj_exp >= 0 && adj_exp < 7);",
            "         v = grisu3_diy_fp_multiply(v, cp_10_lut[adj_exp]);",
            " ",
            "         /* 20 decimal digits won't always fit in 64 bit.",
            "          * (`fraction_exp` is one less than significant decimal",
            "          * digits in fraction, e.g. 1 * 10e0).",
            "          * If we cannot fit, introduce 1/2 ulp error",
            "          * (says double conversion reference impl.) */",
            "@@ -235,16 +234,16 @@",
            "         v.f >>= e_scale;",
            "         v.e += e_scale;",
            "         error = (error >> e_scale) + 1 + error_one;",
            "         prec -= e_scale;",
            "     }",
            "     rounded.f = v.f >> prec;",
            "     rounded.e = v.e + prec;",
            "-    prec_bits = (v.f & ((uint64_t)1 << (prec - 1))) * error_one;",
            "-    half_way = ((uint64_t)1 << (prec - 1)) * error_one;",
            "+    prec_bits = (int)(v.f & ((uint64_t)1 << (prec - 1))) * error_one;",
            "+    half_way = (int)((uint64_t)1 << (prec - 1)) * error_one;",
            "     if (prec >= half_way + error) {",
            "         rounded.f++;",
            "         /* Prevent overflow. */",
            "         if (rounded.f & (hidden_bit << 1)) {",
            "             rounded.f >>= 1;",
            "             rounded.e += 1;",
            "         }",
            "@@ -393,15 +392,15 @@",
            "  * an encoding symbol may or may not be interpreted as a non-decimal",
            "  * encoding prefix, e.g. 0x, but a leading zero followed by a digit is",
            "  * NOT interpreted as octal.",
            "  * A single leading negative sign may appear before digits, but positive",
            "  * sign is not allowed and space after the sign is not allowed.",
            "  * At most the first 1000 characters of the input is considered.",
            "  */",
            "-static const char *grisu3_parse_double(const char *buf, int len, double *result)",
            "+static const char *grisu3_parse_double(const char *buf, size_t len, double *result)",
            " {",
            "     const char *mark, *k, *end;",
            "     int sign = 0, esign = 0;",
            "     uint64_t fraction = 0;",
            "     int exponent = 0;",
            "     int ee = 0;",
            "     int fraction_exp = 0;",
            "@@ -445,30 +444,30 @@",
            "         if (*buf < '1' || *buf > '9') {",
            "             /*",
            "              * If we didn't see a sign, just don't recognize it as",
            "              * number, otherwise make it an error.",
            "              */",
            "             return sign ? 0 : mark;",
            "         }",
            "-        fraction = *buf++ - '0';",
            "+        fraction = (uint64_t)(*buf++ - '0');",
            "     }",
            "     k = buf;",
            "     /*",
            "      * We do not catch trailing zeroes when there is no decimal point.",
            "      * This misses an opportunity for moving the exponent down into the",
            "      * fast case. But it is unlikely to be worthwhile as it complicates",
            "      * parsing.",
            "      */",
            "     while (buf != end && *buf >= '0' && *buf <= '9') {",
            "         if (fraction >= UINT64_MAX / 10) {",
            "             fraction += *buf >= '5';",
            "             ulp_half_error = 1;",
            "             break;",
            "         }",
            "-        fraction = fraction * 10 + *buf++ - '0';",
            "+        fraction = fraction * 10 + (uint64_t)(*buf++ - '0');",
            "     }",
            "     fraction_exp = (int)(buf - k);",
            "     /* Skip surplus digits. Trailing zero does not introduce error. */",
            "     while (buf != end && *buf == '0') {",
            "         ++exponent;",
            "         ++buf;",
            "     }",
            "@@ -492,15 +491,15 @@",
            "             if (fraction >= UINT64_MAX / 10) {",
            "                 if (!ulp_half_error) {",
            "                     fraction += *buf >= '5';",
            "                     ulp_half_error = 1;",
            "                 }",
            "                 break;",
            "             }",
            "-            fraction = fraction * 10 + *buf++ - '0';",
            "+            fraction = fraction * 10 + (uint64_t)(*buf++ - '0');",
            "             --exponent;",
            "         }",
            "         fraction_exp += (int)(buf - k);",
            "         while (buf != end && *buf == '0') {",
            "             ++exponent;",
            "             ++buf;",
            "         }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/grisu3/grisu3_print.h",
          "change": [
            "--- /home/flatcc-0.5.3/external/grisu3/grisu3_print.h",
            "+++ /home/flatcc-0.6.1/external/grisu3/grisu3_print.h",
            "@@ -93,458 +93,480 @@",
            " 000005c0: 2369 666e 6465 6620 4752 4953 5533 5f50  #ifndef GRISU3_P",
            " 000005d0: 5249 4e54 5f48 0a23 6465 6669 6e65 2047  RINT_H.#define G",
            " 000005e0: 5249 5355 335f 5052 494e 545f 480a 0a23  RISU3_PRINT_H..#",
            " 000005f0: 6966 6465 6620 5f5f 6370 6c75 7370 6c75  ifdef __cplusplu",
            " 00000600: 730a 6578 7465 726e 2022 4322 207b 0a23  s.extern \"C\" {.#",
            " 00000610: 656e 6469 660a 0a23 696e 636c 7564 6520  endif..#include ",
            " 00000620: 3c73 7464 696f 2e68 3e20 2f2a 2073 7072  <stdio.h> /* spr",
            "-00000630: 696e 7466 202a 2f0a 2369 6e63 6c75 6465  intf */.#include",
            "-00000640: 203c 6173 7365 7274 2e68 3e20 2f2a 2061   <assert.h> /* a",
            "-00000650: 7373 6572 7420 2a2f 0a0a 2369 6e63 6c75  ssert */..#inclu",
            "-00000660: 6465 2022 6772 6973 7533 5f6d 6174 682e  de \"grisu3_math.",
            "-00000670: 6822 0a0a 2f2a 0a20 2a20 5468 6520 6c69  h\"../*. * The li",
            "-00000680: 6768 7477 6569 6768 7420 2270 6f72 7461  ghtweight \"porta",
            "-00000690: 626c 6522 2043 206c 6962 7261 7279 2072  ble\" C library r",
            "-000006a0: 6563 6f67 6e69 7a65 7320 6772 6973 7533  ecognizes grisu3",
            "-000006b0: 2073 7570 706f 7274 2069 660a 202a 2069   support if. * i",
            "-000006c0: 6e63 6c75 6465 6420 6669 7273 742e 0a20  ncluded first.. ",
            "-000006d0: 2a2f 0a23 6465 6669 6e65 2067 7269 7375  */.#define grisu",
            "-000006e0: 335f 7072 696e 745f 646f 7562 6c65 5f69  3_print_double_i",
            "-000006f0: 735f 6465 6669 6e65 6420 310a 0a2f 2a0a  s_defined 1../*.",
            "-00000700: 202a 204e 6f74 2073 7572 6520 7765 2068   * Not sure we h",
            "-00000710: 6176 6520 616e 2065 7861 6374 2064 6566  ave an exact def",
            "-00000720: 696e 6974 696f 6e2c 2062 7574 2077 6520  inition, but we ",
            "-00000730: 6765 7420 7570 2074 6f20 3233 0a20 2a20  get up to 23. * ",
            "-00000740: 656d 7065 7269 6361 6c6c 792e 2054 6865  emperically. The",
            "-00000750: 7265 2069 7320 736f 6d65 206d 6174 6820  re is some math ",
            "-00000760: 656e 7375 7269 6e67 2069 7420 646f 6573  ensuring it does",
            "-00000770: 206e 6f74 2067 6f20 6177 6f6c 2074 686f   not go awol tho",
            "-00000780: 7567 682c 0a20 2a20 6c69 6b65 2031 3820  ugh,. * like 18 ",
            "-00000790: 6469 6769 7473 202b 2065 7870 6f6e 656e  digits + exponen",
            "-000007a0: 7420 6f72 2073 6f2e 0a20 2a20 5468 6973  t or so.. * This",
            "-000007b0: 206d 6178 2073 686f 756c 6420 6265 2073   max should be s",
            "-000007c0: 6166 6520 7369 7a65 2062 7566 6665 7220  afe size buffer ",
            "-000007d0: 666f 7220 7072 696e 7469 6e67 2c20 696e  for printing, in",
            "-000007e0: 636c 7564 696e 6720 7a65 726f 2074 6572  cluding zero ter",
            "-000007f0: 6d2e 0a20 2a2f 0a23 6465 6669 6e65 2047  m.. */.#define G",
            "-00000800: 5249 5355 335f 5052 494e 545f 4d41 5820  RISU3_PRINT_MAX ",
            "-00000810: 3330 0a0a 7374 6174 6963 2069 6e74 2067  30..static int g",
            "-00000820: 7269 7375 335f 726f 756e 645f 7765 6564  risu3_round_weed",
            "-00000830: 2863 6861 7220 2a62 7566 6665 722c 2069  (char *buffer, i",
            "-00000840: 6e74 206c 656e 2c20 7569 6e74 3634 5f74  nt len, uint64_t",
            "-00000850: 2077 705f 572c 2075 696e 7436 345f 7420   wp_W, uint64_t ",
            "-00000860: 6465 6c74 612c 2075 696e 7436 345f 7420  delta, uint64_t ",
            "-00000870: 7265 7374 2c20 7569 6e74 3634 5f74 2074  rest, uint64_t t",
            "-00000880: 656e 5f6b 6170 7061 2c20 7569 6e74 3634  en_kappa, uint64",
            "-00000890: 5f74 2075 6c70 290a 7b0a 2020 2020 7569  _t ulp).{.    ui",
            "-000008a0: 6e74 3634 5f74 2077 705f 5775 7020 3d20  nt64_t wp_Wup = ",
            "-000008b0: 7770 5f57 202d 2075 6c70 3b0a 2020 2020  wp_W - ulp;.    ",
            "-000008c0: 7569 6e74 3634 5f74 2077 705f 5764 6f77  uint64_t wp_Wdow",
            "-000008d0: 6e20 3d20 7770 5f57 202b 2075 6c70 3b0a  n = wp_W + ulp;.",
            "-000008e0: 2020 2020 7768 696c 6528 7265 7374 203c      while(rest <",
            "-000008f0: 2077 705f 5775 7020 2626 2064 656c 7461   wp_Wup && delta",
            "-00000900: 202d 2072 6573 7420 3e3d 2074 656e 5f6b   - rest >= ten_k",
            "-00000910: 6170 7061 0a20 2020 2020 2020 2026 2620  appa.        && ",
            "-00000920: 2872 6573 7420 2b20 7465 6e5f 6b61 7070  (rest + ten_kapp",
            "-00000930: 6120 3c20 7770 5f57 7570 207c 7c20 7770  a < wp_Wup || wp",
            "-00000940: 5f57 7570 202d 2072 6573 7420 3e3d 2072  _Wup - rest >= r",
            "-00000950: 6573 7420 2b20 7465 6e5f 6b61 7070 6120  est + ten_kappa ",
            "-00000960: 2d20 7770 5f57 7570 2929 0a20 2020 207b  - wp_Wup)).    {",
            "-00000970: 0a20 2020 2020 2020 202d 2d62 7566 6665  .        --buffe",
            "-00000980: 725b 6c65 6e2d 315d 3b0a 2020 2020 2020  r[len-1];.      ",
            "-00000990: 2020 7265 7374 202b 3d20 7465 6e5f 6b61    rest += ten_ka",
            "-000009a0: 7070 613b 0a20 2020 207d 0a20 2020 2069  ppa;.    }.    i",
            "-000009b0: 6620 2872 6573 7420 3c20 7770 5f57 646f  f (rest < wp_Wdo",
            "-000009c0: 776e 2026 2620 6465 6c74 6120 2d20 7265  wn && delta - re",
            "-000009d0: 7374 203e 3d20 7465 6e5f 6b61 7070 610a  st >= ten_kappa.",
            "-000009e0: 2020 2020 2020 2020 2626 2028 7265 7374          && (rest",
            "-000009f0: 202b 2074 656e 5f6b 6170 7061 203c 2077   + ten_kappa < w",
            "-00000a00: 705f 5764 6f77 6e20 7c7c 2077 705f 5764  p_Wdown || wp_Wd",
            "-00000a10: 6f77 6e20 2d20 7265 7374 203e 2072 6573  own - rest > res",
            "-00000a20: 7420 2b20 7465 6e5f 6b61 7070 6120 2d20  t + ten_kappa - ",
            "-00000a30: 7770 5f57 646f 776e 2929 0a20 2020 2020  wp_Wdown)).     ",
            "-00000a40: 2020 2072 6574 7572 6e20 303b 0a0a 2020     return 0;..  ",
            "-00000a50: 2020 7265 7475 726e 2032 2a75 6c70 203c    return 2*ulp <",
            "-00000a60: 3d20 7265 7374 2026 2620 7265 7374 203c  = rest && rest <",
            "-00000a70: 3d20 6465 6c74 6120 2d20 342a 756c 703b  = delta - 4*ulp;",
            "-00000a80: 0a7d 0a0a 7374 6174 6963 2069 6e74 2067  .}..static int g",
            "-00000a90: 7269 7375 335f 6469 6769 745f 6765 6e28  risu3_digit_gen(",
            "-00000aa0: 6772 6973 7533 5f64 6979 5f66 705f 7420  grisu3_diy_fp_t ",
            "-00000ab0: 6c6f 772c 2067 7269 7375 335f 6469 795f  low, grisu3_diy_",
            "-00000ac0: 6670 5f74 2077 2c20 6772 6973 7533 5f64  fp_t w, grisu3_d",
            "-00000ad0: 6979 5f66 705f 7420 6869 6768 2c20 6368  iy_fp_t high, ch",
            "-00000ae0: 6172 202a 6275 6666 6572 2c20 696e 7420  ar *buffer, int ",
            "-00000af0: 2a6c 656e 6774 682c 2069 6e74 202a 6b61  *length, int *ka",
            "-00000b00: 7070 6129 0a7b 0a20 2020 2075 696e 7436  ppa).{.    uint6",
            "-00000b10: 345f 7420 756e 6974 203d 2031 3b0a 2020  4_t unit = 1;.  ",
            "-00000b20: 2020 6772 6973 7533 5f64 6979 5f66 705f    grisu3_diy_fp_",
            "-00000b30: 7420 746f 6f5f 6c6f 7720 3d20 7b20 6c6f  t too_low = { lo",
            "-00000b40: 772e 6620 2d20 756e 6974 2c20 6c6f 772e  w.f - unit, low.",
            "-00000b50: 6520 7d3b 0a20 2020 2067 7269 7375 335f  e };.    grisu3_",
            "-00000b60: 6469 795f 6670 5f74 2074 6f6f 5f68 6967  diy_fp_t too_hig",
            "-00000b70: 6820 3d20 7b20 6869 6768 2e66 202b 2075  h = { high.f + u",
            "-00000b80: 6e69 742c 2068 6967 682e 6520 7d3b 0a20  nit, high.e };. ",
            "-00000b90: 2020 2067 7269 7375 335f 6469 795f 6670     grisu3_diy_fp",
            "-00000ba0: 5f74 2075 6e73 6166 655f 696e 7465 7276  _t unsafe_interv",
            "-00000bb0: 616c 203d 2020 6772 6973 7533 5f64 6979  al =  grisu3_diy",
            "-00000bc0: 5f66 705f 6d69 6e75 7328 746f 6f5f 6869  _fp_minus(too_hi",
            "-00000bd0: 6768 2c20 746f 6f5f 6c6f 7729 3b0a 2020  gh, too_low);.  ",
            "-00000be0: 2020 6772 6973 7533 5f64 6979 5f66 705f    grisu3_diy_fp_",
            "-00000bf0: 7420 6f6e 6520 3d20 7b20 3155 4c4c 203c  t one = { 1ULL <",
            "-00000c00: 3c20 2d77 2e65 2c20 772e 6520 7d3b 0a20  < -w.e, w.e };. ",
            "-00000c10: 2020 2075 696e 7433 325f 7420 7031 203d     uint32_t p1 =",
            "-00000c20: 2028 7569 6e74 3332 5f74 2928 746f 6f5f   (uint32_t)(too_",
            "-00000c30: 6869 6768 2e66 203e 3e20 2d6f 6e65 2e65  high.f >> -one.e",
            "-00000c40: 293b 0a20 2020 2075 696e 7436 345f 7420  );.    uint64_t ",
            "-00000c50: 7032 203d 2074 6f6f 5f68 6967 682e 6620  p2 = too_high.f ",
            "-00000c60: 2620 286f 6e65 2e66 202d 2031 293b 0a20  & (one.f - 1);. ",
            "-00000c70: 2020 2075 696e 7433 325f 7420 6469 763b     uint32_t div;",
            "-00000c80: 0a20 2020 202a 6b61 7070 6120 3d20 6772  .    *kappa = gr",
            "-00000c90: 6973 7533 5f6c 6172 6765 7374 5f70 6f77  isu3_largest_pow",
            "-00000ca0: 3130 2870 312c 2047 5249 5355 335f 4449  10(p1, GRISU3_DI",
            "-00000cb0: 595f 4650 5f46 5241 4354 5f53 495a 4520  Y_FP_FRACT_SIZE ",
            "-00000cc0: 2b20 6f6e 652e 652c 2026 6469 7629 3b0a  + one.e, &div);.",
            "-00000cd0: 2020 2020 2a6c 656e 6774 6820 3d20 303b      *length = 0;",
            "-00000ce0: 0a0a 2020 2020 7768 696c 6528 2a6b 6170  ..    while(*kap",
            "-00000cf0: 7061 203e 2030 290a 2020 2020 7b0a 2020  pa > 0).    {.  ",
            "-00000d00: 2020 2020 2020 7569 6e74 3634 5f74 2072        uint64_t r",
            "-00000d10: 6573 743b 0a20 2020 2020 2020 2069 6e74  est;.        int",
            "-00000d20: 2064 6967 6974 203d 2070 3120 2f20 6469   digit = p1 / di",
            "-00000d30: 763b 0a20 2020 2020 2020 2062 7566 6665  v;.        buffe",
            "-00000d40: 725b 2a6c 656e 6774 685d 203d 2028 6368  r[*length] = (ch",
            "-00000d50: 6172 2928 2730 2720 2b20 6469 6769 7429  ar)('0' + digit)",
            "-00000d60: 3b0a 2020 2020 2020 2020 2b2b 2a6c 656e  ;.        ++*len",
            "-00000d70: 6774 683b 0a20 2020 2020 2020 2070 3120  gth;.        p1 ",
            "-00000d80: 253d 2064 6976 3b0a 2020 2020 2020 2020  %= div;.        ",
            "-00000d90: 2d2d 2a6b 6170 7061 3b0a 2020 2020 2020  --*kappa;.      ",
            "-00000da0: 2020 7265 7374 203d 2028 2875 696e 7436    rest = ((uint6",
            "-00000db0: 345f 7429 7031 203c 3c20 2d6f 6e65 2e65  4_t)p1 << -one.e",
            "-00000dc0: 2920 2b20 7032 3b0a 2020 2020 2020 2020  ) + p2;.        ",
            "-00000dd0: 6966 2028 7265 7374 203c 2075 6e73 6166  if (rest < unsaf",
            "-00000de0: 655f 696e 7465 7276 616c 2e66 2920 7265  e_interval.f) re",
            "-00000df0: 7475 726e 2067 7269 7375 335f 726f 756e  turn grisu3_roun",
            "-00000e00: 645f 7765 6564 2862 7566 6665 722c 202a  d_weed(buffer, *",
            "-00000e10: 6c65 6e67 7468 2c20 6772 6973 7533 5f64  length, grisu3_d",
            "-00000e20: 6979 5f66 705f 6d69 6e75 7328 746f 6f5f  iy_fp_minus(too_",
            "-00000e30: 6869 6768 2c20 7729 2e66 2c20 756e 7361  high, w).f, unsa",
            "-00000e40: 6665 5f69 6e74 6572 7661 6c2e 662c 2072  fe_interval.f, r",
            "-00000e50: 6573 742c 2028 7569 6e74 3634 5f74 2964  est, (uint64_t)d",
            "-00000e60: 6976 203c 3c20 2d6f 6e65 2e65 2c20 756e  iv << -one.e, un",
            "-00000e70: 6974 293b 0a20 2020 2020 2020 2064 6976  it);.        div",
            "-00000e80: 202f 3d20 3130 3b0a 2020 2020 7d0a 0a20   /= 10;.    }.. ",
            "-00000e90: 2020 2066 6f72 283b 3b29 0a20 2020 207b     for(;;).    {",
            "-00000ea0: 0a20 2020 2020 2020 2069 6e74 2064 6967  .        int dig",
            "-00000eb0: 6974 3b0a 2020 2020 2020 2020 7032 202a  it;.        p2 *",
            "-00000ec0: 3d20 3130 3b0a 2020 2020 2020 2020 756e  = 10;.        un",
            "-00000ed0: 6974 202a 3d20 3130 3b0a 2020 2020 2020  it *= 10;.      ",
            "-00000ee0: 2020 756e 7361 6665 5f69 6e74 6572 7661    unsafe_interva",
            "-00000ef0: 6c2e 6620 2a3d 2031 303b 0a20 2020 2020  l.f *= 10;.     ",
            "-00000f00: 2020 202f 2a20 496e 7465 6765 7220 6469     /* Integer di",
            "-00000f10: 7669 7369 6f6e 2062 7920 6f6e 652e 202a  vision by one. *",
            "-00000f20: 2f0a 2020 2020 2020 2020 6469 6769 7420  /.        digit ",
            "-00000f30: 3d20 2869 6e74 2928 7032 203e 3e20 2d6f  = (int)(p2 >> -o",
            "-00000f40: 6e65 2e65 293b 0a20 2020 2020 2020 2062  ne.e);.        b",
            "-00000f50: 7566 6665 725b 2a6c 656e 6774 685d 203d  uffer[*length] =",
            "-00000f60: 2028 6368 6172 2928 2730 2720 2b20 6469   (char)('0' + di",
            "-00000f70: 6769 7429 3b0a 2020 2020 2020 2020 2b2b  git);.        ++",
            "-00000f80: 2a6c 656e 6774 683b 0a20 2020 2020 2020  *length;.       ",
            "-00000f90: 2070 3220 263d 206f 6e65 2e66 202d 2031   p2 &= one.f - 1",
            "-00000fa0: 3b20 2f2a 204d 6f64 756c 6f20 6279 206f  ; /* Modulo by o",
            "-00000fb0: 6e65 2e20 2a2f 0a20 2020 2020 2020 202d  ne. */.        -",
            "-00000fc0: 2d2a 6b61 7070 613b 0a20 2020 2020 2020  -*kappa;.       ",
            "-00000fd0: 2069 6620 2870 3220 3c20 756e 7361 6665   if (p2 < unsafe",
            "-00000fe0: 5f69 6e74 6572 7661 6c2e 6629 2072 6574  _interval.f) ret",
            "-00000ff0: 7572 6e20 6772 6973 7533 5f72 6f75 6e64  urn grisu3_round",
            "-00001000: 5f77 6565 6428 6275 6666 6572 2c20 2a6c  _weed(buffer, *l",
            "-00001010: 656e 6774 682c 2067 7269 7375 335f 6469  ength, grisu3_di",
            "-00001020: 795f 6670 5f6d 696e 7573 2874 6f6f 5f68  y_fp_minus(too_h",
            "-00001030: 6967 682c 2077 292e 6620 2a20 756e 6974  igh, w).f * unit",
            "-00001040: 2c20 756e 7361 6665 5f69 6e74 6572 7661  , unsafe_interva",
            "-00001050: 6c2e 662c 2070 322c 206f 6e65 2e66 2c20  l.f, p2, one.f, ",
            "-00001060: 756e 6974 293b 0a20 2020 207d 0a7d 0a0a  unit);.    }.}..",
            "-00001070: 7374 6174 6963 2069 6e74 2067 7269 7375  static int grisu",
            "-00001080: 3328 646f 7562 6c65 2076 2c20 6368 6172  3(double v, char",
            "-00001090: 202a 6275 6666 6572 2c20 696e 7420 2a6c   *buffer, int *l",
            "-000010a0: 656e 6774 682c 2069 6e74 202a 645f 6578  ength, int *d_ex",
            "-000010b0: 7029 0a7b 0a20 2020 2069 6e74 206d 6b2c  p).{.    int mk,",
            "-000010c0: 206b 6170 7061 2c20 7375 6363 6573 733b   kappa, success;",
            "-000010d0: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "-000010e0: 6670 5f74 2064 6670 203d 2067 7269 7375  fp_t dfp = grisu",
            "-000010f0: 335f 6361 7374 5f64 6979 5f66 705f 6672  3_cast_diy_fp_fr",
            "-00001100: 6f6d 5f64 6f75 626c 6528 7629 3b0a 2020  om_double(v);.  ",
            "-00001110: 2020 6772 6973 7533 5f64 6979 5f66 705f    grisu3_diy_fp_",
            "-00001120: 7420 7720 3d20 6772 6973 7533 5f64 6979  t w = grisu3_diy",
            "-00001130: 5f66 705f 6e6f 726d 616c 697a 6528 6466  _fp_normalize(df",
            "-00001140: 7029 3b0a 0a20 2020 202f 2a20 6e6f 726d  p);..    /* norm",
            "-00001150: 616c 697a 6520 626f 756e 6461 7269 6573  alize boundaries",
            "-00001160: 202a 2f0a 2020 2020 6772 6973 7533 5f64   */.    grisu3_d",
            "-00001170: 6979 5f66 705f 7420 7420 3d20 7b20 2864  iy_fp_t t = { (d",
            "-00001180: 6670 2e66 203c 3c20 3129 202b 2031 2c20  fp.f << 1) + 1, ",
            "-00001190: 6466 702e 6520 2d20 3120 7d3b 0a20 2020  dfp.e - 1 };.   ",
            "-000011a0: 2067 7269 7375 335f 6469 795f 6670 5f74   grisu3_diy_fp_t",
            "-000011b0: 2062 5f70 6c75 7320 3d20 6772 6973 7533   b_plus = grisu3",
            "-000011c0: 5f64 6979 5f66 705f 6e6f 726d 616c 697a  _diy_fp_normaliz",
            "-000011d0: 6528 7429 3b0a 2020 2020 6772 6973 7533  e(t);.    grisu3",
            "-000011e0: 5f64 6979 5f66 705f 7420 625f 6d69 6e75  _diy_fp_t b_minu",
            "-000011f0: 733b 0a20 2020 2067 7269 7375 335f 6469  s;.    grisu3_di",
            "-00001200: 795f 6670 5f74 2063 5f6d 6b3b 202f 2a20  y_fp_t c_mk; /* ",
            "-00001210: 4361 6368 6564 2070 6f77 6572 206f 6620  Cached power of ",
            "-00001220: 7465 6e3a 2031 305e 2d6b 202a 2f0a 2020  ten: 10^-k */.  ",
            "-00001230: 2020 7569 6e74 3634 5f74 2075 3634 203d    uint64_t u64 =",
            "-00001240: 2067 7269 7375 335f 6361 7374 5f75 696e   grisu3_cast_uin",
            "-00001250: 7436 345f 6672 6f6d 5f64 6f75 626c 6528  t64_from_double(",
            "-00001260: 7629 3b0a 2020 2020 6173 7365 7274 2876  v);.    assert(v",
            "-00001270: 203e 2030 2026 2620 7620 3c3d 2031 2e37   > 0 && v <= 1.7",
            "-00001280: 3937 3639 3331 3334 3836 3233 3135 3765  976931348623157e",
            "-00001290: 3330 3829 3b20 2f2a 2047 7269 7375 206f  308); /* Grisu o",
            "-000012a0: 6e6c 7920 6861 6e64 6c65 7320 7374 7269  nly handles stri",
            "-000012b0: 6374 6c79 2070 6f73 6974 6976 6520 6669  ctly positive fi",
            "-000012c0: 6e69 7465 206e 756d 6265 7273 2e20 2a2f  nite numbers. */",
            "-000012d0: 0a20 2020 2069 6620 2821 2875 3634 2026  .    if (!(u64 &",
            "-000012e0: 2047 5249 5355 335f 4436 345f 4652 4143   GRISU3_D64_FRAC",
            "-000012f0: 545f 4d41 534b 2920 2626 2028 7536 3420  T_MASK) && (u64 ",
            "-00001300: 2620 4752 4953 5533 5f44 3634 5f45 5850  & GRISU3_D64_EXP",
            "-00001310: 5f4d 4153 4b29 2021 3d20 3029 207b 2062  _MASK) != 0) { b",
            "-00001320: 5f6d 696e 7573 2e66 203d 2028 6466 702e  _minus.f = (dfp.",
            "-00001330: 6620 3c3c 2032 2920 2d20 313b 2062 5f6d  f << 2) - 1; b_m",
            "-00001340: 696e 7573 2e65 203d 2020 6466 702e 6520  inus.e =  dfp.e ",
            "-00001350: 2d20 323b 7d20 2f2a 206c 6f77 6572 2062  - 2;} /* lower b",
            "-00001360: 6f75 6e64 6172 7920 6973 2063 6c6f 7365  oundary is close",
            "-00001370: 723f 202a 2f0a 2020 2020 656c 7365 207b  r? */.    else {",
            "-00001380: 2062 5f6d 696e 7573 2e66 203d 2028 6466   b_minus.f = (df",
            "-00001390: 702e 6620 3c3c 2031 2920 2d20 313b 2062  p.f << 1) - 1; b",
            "-000013a0: 5f6d 696e 7573 2e65 203d 2064 6670 2e65  _minus.e = dfp.e",
            "-000013b0: 202d 2031 3b20 7d0a 2020 2020 625f 6d69   - 1; }.    b_mi",
            "-000013c0: 6e75 732e 6620 3d20 625f 6d69 6e75 732e  nus.f = b_minus.",
            "-000013d0: 6620 3c3c 2028 625f 6d69 6e75 732e 6520  f << (b_minus.e ",
            "-000013e0: 2d20 625f 706c 7573 2e65 293b 0a20 2020  - b_plus.e);.   ",
            "-000013f0: 2062 5f6d 696e 7573 2e65 203d 2062 5f70   b_minus.e = b_p",
            "-00001400: 6c75 732e 653b 0a0a 2020 2020 6d6b 203d  lus.e;..    mk =",
            "-00001410: 2067 7269 7375 335f 6469 795f 6670 5f63   grisu3_diy_fp_c",
            "-00001420: 6163 6865 645f 706f 7728 4752 4953 5533  ached_pow(GRISU3",
            "-00001430: 5f4d 494e 5f54 4152 4745 545f 4558 5020  _MIN_TARGET_EXP ",
            "-00001440: 2d20 4752 4953 5533 5f44 4959 5f46 505f  - GRISU3_DIY_FP_",
            "-00001450: 4652 4143 545f 5349 5a45 202d 2077 2e65  FRACT_SIZE - w.e",
            "-00001460: 2c20 2663 5f6d 6b29 3b0a 0a20 2020 2077  , &c_mk);..    w",
            "-00001470: 203d 2067 7269 7375 335f 6469 795f 6670   = grisu3_diy_fp",
            "-00001480: 5f6d 756c 7469 706c 7928 772c 2063 5f6d  _multiply(w, c_m",
            "-00001490: 6b29 3b0a 2020 2020 625f 6d69 6e75 7320  k);.    b_minus ",
            "-000014a0: 3d20 6772 6973 7533 5f64 6979 5f66 705f  = grisu3_diy_fp_",
            "-000014b0: 6d75 6c74 6970 6c79 2862 5f6d 696e 7573  multiply(b_minus",
            "-000014c0: 2c20 635f 6d6b 293b 0a20 2020 2062 5f70  , c_mk);.    b_p",
            "-000014d0: 6c75 7320 203d 2067 7269 7375 335f 6469  lus  = grisu3_di",
            "-000014e0: 795f 6670 5f6d 756c 7469 706c 7928 625f  y_fp_multiply(b_",
            "-000014f0: 706c 7573 2c20 2063 5f6d 6b29 3b0a 0a20  plus,  c_mk);.. ",
            "-00001500: 2020 2073 7563 6365 7373 203d 2067 7269     success = gri",
            "-00001510: 7375 335f 6469 6769 745f 6765 6e28 625f  su3_digit_gen(b_",
            "-00001520: 6d69 6e75 732c 2077 2c20 625f 706c 7573  minus, w, b_plus",
            "-00001530: 2c20 6275 6666 6572 2c20 6c65 6e67 7468  , buffer, length",
            "-00001540: 2c20 266b 6170 7061 293b 0a20 2020 202a  , &kappa);.    *",
            "-00001550: 645f 6578 7020 3d20 6b61 7070 6120 2d20  d_exp = kappa - ",
            "-00001560: 6d6b 3b0a 2020 2020 7265 7475 726e 2073  mk;.    return s",
            "-00001570: 7563 6365 7373 3b0a 7d0a 0a73 7461 7469  uccess;.}..stati",
            "-00001580: 6320 696e 7420 6772 6973 7533 5f69 5f74  c int grisu3_i_t",
            "-00001590: 6f5f 7374 7228 696e 7420 7661 6c2c 2063  o_str(int val, c",
            "-000015a0: 6861 7220 2a73 7472 290a 7b0a 2020 2020  har *str).{.    ",
            "-000015b0: 696e 7420 6c65 6e2c 2069 3b0a 2020 2020  int len, i;.    ",
            "-000015c0: 6368 6172 202a 733b 0a20 2020 2063 6861  char *s;.    cha",
            "-000015d0: 7220 2a62 6567 696e 203d 2073 7472 3b0a  r *begin = str;.",
            "-000015e0: 2020 2020 6966 2028 7661 6c20 3c20 3029      if (val < 0)",
            "-000015f0: 207b 202a 7374 722b 2b20 3d20 272d 273b   { *str++ = '-';",
            "-00001600: 2076 616c 203d 202d 7661 6c3b 207d 0a20   val = -val; }. ",
            "-00001610: 2020 2073 203d 2073 7472 3b0a 0a20 2020     s = str;..   ",
            "-00001620: 2066 6f72 283b 3b29 0a20 2020 207b 0a20   for(;;).    {. ",
            "-00001630: 2020 2020 2020 2069 6e74 206e 6920 3d20         int ni = ",
            "-00001640: 7661 6c20 2f20 3130 3b0a 2020 2020 2020  val / 10;.      ",
            "-00001650: 2020 696e 7420 6469 6769 7420 3d20 7661    int digit = va",
            "-00001660: 6c20 2d20 6e69 2a31 303b 0a20 2020 2020  l - ni*10;.     ",
            "-00001670: 2020 202a 732b 2b20 3d20 2863 6861 7229     *s++ = (char)",
            "-00001680: 2827 3027 202b 2064 6967 6974 293b 0a20  ('0' + digit);. ",
            "-00001690: 2020 2020 2020 2069 6620 286e 6920 3d3d         if (ni ==",
            "-000016a0: 2030 290a 2020 2020 2020 2020 2020 2020   0).            ",
            "-000016b0: 6272 6561 6b3b 0a20 2020 2020 2020 2076  break;.        v",
            "-000016c0: 616c 203d 206e 693b 0a20 2020 207d 0a20  al = ni;.    }. ",
            "-000016d0: 2020 202a 7320 3d20 275c 3027 3b0a 2020     *s = '\\0';.  ",
            "-000016e0: 2020 6c65 6e20 3d20 2869 6e74 2928 7320    len = (int)(s ",
            "-000016f0: 2d20 7374 7229 3b0a 2020 2020 666f 7228  - str);.    for(",
            "-00001700: 6920 3d20 303b 2069 203c 206c 656e 2f32  i = 0; i < len/2",
            "-00001710: 3b20 2b2b 6929 0a20 2020 207b 0a20 2020  ; ++i).    {.   ",
            "-00001720: 2020 2020 2063 6861 7220 6368 203d 2073       char ch = s",
            "-00001730: 7472 5b69 5d3b 0a20 2020 2020 2020 2073  tr[i];.        s",
            "-00001740: 7472 5b69 5d20 3d20 7374 725b 6c65 6e2d  tr[i] = str[len-",
            "-00001750: 312d 695d 3b0a 2020 2020 2020 2020 7374  1-i];.        st",
            "-00001760: 725b 6c65 6e2d 312d 695d 203d 2063 683b  r[len-1-i] = ch;",
            "-00001770: 0a20 2020 207d 0a0a 2020 2020 7265 7475  .    }..    retu",
            "-00001780: 726e 2028 696e 7429 2873 202d 2062 6567  rn (int)(s - beg",
            "-00001790: 696e 293b 0a7d 0a0a 7374 6174 6963 2069  in);.}..static i",
            "-000017a0: 6e74 2067 7269 7375 335f 7072 696e 745f  nt grisu3_print_",
            "-000017b0: 646f 7562 6c65 2864 6f75 626c 6520 762c  double(double v,",
            "-000017c0: 2063 6861 7220 2a64 7374 290a 7b0a 2020   char *dst).{.  ",
            "-000017d0: 2020 696e 7420 645f 6578 702c 206c 656e    int d_exp, len",
            "-000017e0: 2c20 7375 6363 6573 732c 2064 6563 696d  , success, decim",
            "-000017f0: 616c 732c 2069 3b0a 2020 2020 7569 6e74  als, i;.    uint",
            "-00001800: 3634 5f74 2075 3634 203d 2067 7269 7375  64_t u64 = grisu",
            "-00001810: 335f 6361 7374 5f75 696e 7436 345f 6672  3_cast_uint64_fr",
            "-00001820: 6f6d 5f64 6f75 626c 6528 7629 3b0a 2020  om_double(v);.  ",
            "-00001830: 2020 6368 6172 202a 7332 203d 2064 7374    char *s2 = dst",
            "-00001840: 3b0a 2020 2020 6173 7365 7274 2864 7374  ;.    assert(dst",
            "-00001850: 293b 0a0a 2020 2020 2f2a 2050 7265 6861  );..    /* Preha",
            "-00001860: 6e64 6c65 204e 614e 7320 2a2f 0a20 2020  ndle NaNs */.   ",
            "-00001870: 2069 6620 2828 7536 3420 3c3c 2031 2920   if ((u64 << 1) ",
            "-00001880: 3e20 3078 4646 4530 3030 3030 3030 3030  > 0xFFE000000000",
            "-00001890: 3030 3030 554c 4c29 2072 6574 7572 6e20  0000ULL) return ",
            "-000018a0: 7370 7269 6e74 6628 6473 742c 2022 4e61  sprintf(dst, \"Na",
            "-000018b0: 4e28 2530 3858 2530 3858 2922 2c20 2875  N(%08X%08X)\", (u",
            "-000018c0: 696e 7433 325f 7429 2875 3634 203e 3e20  int32_t)(u64 >> ",
            "-000018d0: 3332 292c 2028 7569 6e74 3332 5f74 2975  32), (uint32_t)u",
            "-000018e0: 3634 293b 0a20 2020 202f 2a20 5072 6568  64);.    /* Preh",
            "-000018f0: 616e 646c 6520 6e65 6761 7469 7665 2076  andle negative v",
            "-00001900: 616c 7565 732e 202a 2f0a 2020 2020 6966  alues. */.    if",
            "-00001910: 2028 2875 3634 2026 2047 5249 5355 335f   ((u64 & GRISU3_",
            "-00001920: 4436 345f 5349 474e 2920 213d 2030 2920  D64_SIGN) != 0) ",
            "-00001930: 7b20 2a73 322b 2b20 3d20 272d 273b 2076  { *s2++ = '-'; v",
            "-00001940: 203d 202d 763b 2075 3634 205e 3d20 4752   = -v; u64 ^= GR",
            "-00001950: 4953 5533 5f44 3634 5f53 4947 4e3b 207d  ISU3_D64_SIGN; }",
            "-00001960: 0a20 2020 202f 2a20 5072 6568 616e 646c  .    /* Prehandl",
            "-00001970: 6520 7a65 726f 2e20 2a2f 0a20 2020 2069  e zero. */.    i",
            "-00001980: 6620 2821 7536 3429 207b 202a 7332 2b2b  f (!u64) { *s2++",
            "-00001990: 203d 2027 3027 3b20 2a73 3220 3d20 275c   = '0'; *s2 = '\\",
            "-000019a0: 3027 3b20 7265 7475 726e 2028 696e 7429  0'; return (int)",
            "-000019b0: 2873 3220 2d20 6473 7429 3b20 7d0a 2020  (s2 - dst); }.  ",
            "-000019c0: 2020 2f2a 2050 7265 6861 6e64 6c65 2069    /* Prehandle i",
            "-000019d0: 6e66 696e 6974 792e 202a 2f0a 2020 2020  nfinity. */.    ",
            "-000019e0: 6966 2028 7536 3420 3d3d 2047 5249 5355  if (u64 == GRISU",
            "-000019f0: 335f 4436 345f 4558 505f 4d41 534b 2920  3_D64_EXP_MASK) ",
            "-00001a00: 7b20 2a73 322b 2b20 3d20 2769 273b 202a  { *s2++ = 'i'; *",
            "-00001a10: 7332 2b2b 203d 2027 6e27 3b20 2a73 322b  s2++ = 'n'; *s2+",
            "-00001a20: 2b20 3d20 2766 273b 202a 7332 203d 2027  + = 'f'; *s2 = '",
            "-00001a30: 5c30 273b 2072 6574 7572 6e20 2869 6e74  \\0'; return (int",
            "-00001a40: 2928 7332 202d 2064 7374 293b 207d 0a0a  )(s2 - dst); }..",
            "-00001a50: 2020 2020 7375 6363 6573 7320 3d20 6772      success = gr",
            "-00001a60: 6973 7533 2876 2c20 7332 2c20 266c 656e  isu3(v, s2, &len",
            "-00001a70: 2c20 2664 5f65 7870 293b 0a20 2020 202f  , &d_exp);.    /",
            "-00001a80: 2a20 4966 2067 7269 7375 3320 7761 7320  * If grisu3 was ",
            "-00001a90: 6e6f 7420 6162 6c65 2074 6f20 636f 6e76  not able to conv",
            "-00001aa0: 6572 7420 7468 6520 6e75 6d62 6572 2074  ert the number t",
            "-00001ab0: 6f20 6120 7374 7269 6e67 2c20 7468 656e  o a string, then",
            "-00001ac0: 2075 7365 206f 6c64 2073 7072 696e 7466   use old sprintf",
            "-00001ad0: 2028 7375 626f 7074 696d 616c 292e 202a   (suboptimal). *",
            "-00001ae0: 2f0a 2020 2020 6966 2028 2173 7563 6365  /.    if (!succe",
            "-00001af0: 7373 2920 7265 7475 726e 2073 7072 696e  ss) return sprin",
            "-00001b00: 7466 2873 322c 2022 252e 3137 6722 2c20  tf(s2, \"%.17g\", ",
            "-00001b10: 7629 202b 2028 696e 7429 2873 3220 2d20  v) + (int)(s2 - ",
            "-00001b20: 6473 7429 3b0a 0a20 2020 202f 2a20 5765  dst);..    /* We",
            "-00001b30: 206e 6f77 2068 6176 6520 616e 2069 6e74   now have an int",
            "-00001b40: 6567 6572 2073 7472 696e 6720 6f66 2066  eger string of f",
            "-00001b50: 6f72 6d20 2231 3531 3332 3431 3335 2220  orm \"151324135\" ",
            "-00001b60: 616e 6420 6120 6261 7365 2d31 3020 6578  and a base-10 ex",
            "-00001b70: 706f 6e65 6e74 2066 6f72 2074 6861 7420  ponent for that ",
            "-00001b80: 6e75 6d62 6572 2e20 2a2f 0a20 2020 202f  number. */.    /",
            "-00001b90: 2a20 4e65 7874 2c20 6465 6369 6465 2074  * Next, decide t",
            "-00001ba0: 6865 2062 6573 7420 7072 6573 656e 7461  he best presenta",
            "-00001bb0: 7469 6f6e 2066 6f72 2074 6861 7420 7374  tion for that st",
            "-00001bc0: 7269 6e67 2062 7920 7768 6574 6865 7220  ring by whether ",
            "-00001bd0: 746f 2075 7365 2061 2064 6563 696d 616c  to use a decimal",
            "-00001be0: 2070 6f69 6e74 2c20 6f72 2074 6865 2073   point, or the s",
            "-00001bf0: 6369 656e 7469 6669 6320 6578 706f 6e65  cientific expone",
            "-00001c00: 6e74 1020 6e6f 7461 7469 6f6e 2027 6527  nt. notation 'e'",
            "-00001c10: 2e20 2a2f 0a20 2020 202f 2a20 5765 2064  . */.    /* We d",
            "-00001c20: 6f6e 2774 2070 6963 6b20 7468 6520 6162  on't pick the ab",
            "-00001c30: 736f 6c75 7465 2073 686f 7274 6573 7420  solute shortest ",
            "-00001c40: 7265 7072 6573 656e 7461 7469 6f6e 2c20  representation, ",
            "-00001c50: 6275 7420 7069 636b 2061 2062 616c 616e  but pick a balan",
            "-00001c60: 6365 2062 6574 7765 656e 2072 6561 6461  ce between reada",
            "-00001c70: 6269 6c69 7479 2061 6e64 2073 686f 7274  bility and short",
            "-00001c80: 6e65 7373 2c20 652e 672e 202a 2f0a 2020  ness, e.g. */.  ",
            "-00001c90: 2020 2f2a 2031 2e35 3435 3035 3631 3839    /* 1.545056189",
            "-00001ca0: 3535 3736 3737 652d 3330 3820 636f 756c  557677e-308 coul",
            "-00001cb0: 6420 6265 2072 6570 7265 7365 6e74 6564  d be represented",
            "-00001cc0: 2069 6e20 6120 7368 6f72 7465 7220 666f   in a shorter fo",
            "-00001cd0: 726d 202a 2f0a 2020 2020 2f2a 2031 3534  rm */.    /* 154",
            "-00001ce0: 3530 3536 3138 3935 3537 3637 3765 2d33  5056189557677e-3",
            "-00001cf0: 3233 2062 7574 2074 6861 7420 776f 756c  23 but that woul",
            "-00001d00: 6420 6265 2073 6f6d 6577 6861 7420 756e  d be somewhat un",
            "-00001d10: 7265 6164 6162 6c65 2e20 2a2f 0a20 2020  readable. */.   ",
            "-00001d20: 2064 6563 696d 616c 7320 3d20 4752 4953   decimals = GRIS",
            "-00001d30: 5533 5f4d 494e 282d 645f 6578 702c 2047  U3_MIN(-d_exp, G",
            "-00001d40: 5249 5355 335f 4d41 5828 312c 206c 656e  RISU3_MAX(1, len",
            "-00001d50: 2d31 2929 3b0a 0a20 2020 202f 2a20 6d69  -1));..    /* mi",
            "-00001d60: 6b6b 656c 666a 3a0a 2020 2020 202a 2066  kkelfj:.     * f",
            "-00001d70: 6978 207a 6572 6f20 7072 6566 6978 202e  ix zero prefix .",
            "-00001d80: 3120 3d3e 2030 2e31 2c20 696d 706f 7274  1 => 0.1, import",
            "-00001d90: 616e 7420 666f 7220 4a53 4f4e 2065 7870  ant for JSON exp",
            "-00001da0: 6f72 742e 0a20 2020 2020 2a20 7072 6566  ort..     * pref",
            "-00001db0: 6572 2075 6e73 6369 656e 7469 6669 6320  er unscientific ",
            "-00001dc0: 6e6f 7461 7469 6f6e 2061 7420 7361 6d65  notation at same",
            "-00001dd0: 206c 656e 6774 683a 0a20 2020 2020 2a20   length:.     * ",
            "-00001de0: 2d31 2e32 3334 3565 2d34 206f 7665 7220  -1.2345e-4 over ",
            "-00001df0: 2d31 2e30 3030 3132 3334 352c 0a20 2020  -1.00012345,.   ",
            "-00001e00: 2020 2a20 2d31 2e30 3031 3233 3435 206f    * -1.0012345 o",
            "-00001e10: 7665 7220 2d31 2e32 3334 3565 2d33 0a20  ver -1.2345e-3. ",
            "-00001e20: 2020 2020 2a2f 0a20 2020 2069 6620 2864      */.    if (d",
            "-00001e30: 5f65 7870 203c 2030 2026 2620 286c 656e  _exp < 0 && (len",
            "-00001e40: 202b 2064 5f65 7870 2920 3e20 2d33 2026   + d_exp) > -3 &",
            "-00001e50: 2620 6c65 6e20 3c3d 202d 645f 6578 7029  & len <= -d_exp)",
            "-00001e60: 0a20 2020 207b 0a20 2020 2020 2020 202f  .    {.        /",
            "-00001e70: 2a20 6d69 6b6b 656c 666a 3a20 6669 7820  * mikkelfj: fix ",
            "-00001e80: 7a65 726f 2070 7265 6669 7820 2e31 203d  zero prefix .1 =",
            "-00001e90: 3e20 302e 312c 2061 6e64 2073 686f 7274  > 0.1, and short",
            "-00001ea0: 2065 7870 6f6e 656e 7473 2031 2e33 652d   exponents 1.3e-",
            "-00001eb0: 3220 3d3e 2030 2e30 3133 2e20 2a2f 0a20  2 => 0.013. */. ",
            "-00001ec0: 2020 2020 2020 206d 656d 6d6f 7665 2873         memmove(s",
            "-00001ed0: 3220 2b20 3220 2d20 645f 6578 7020 2d20  2 + 2 - d_exp - ",
            "-00001ee0: 6c65 6e2c 2073 322c 206c 656e 293b 0a20  len, s2, len);. ",
            "-00001ef0: 2020 2020 2020 2073 325b 305d 203d 2027         s2[0] = '",
            "-00001f00: 3027 3b0a 2020 2020 2020 2020 7332 5b31  0';.        s2[1",
            "-00001f10: 5d20 3d20 272e 273b 0a20 2020 2020 2020  ] = '.';.       ",
            "-00001f20: 2066 6f72 2028 6920 3d20 323b 2069 203c   for (i = 2; i <",
            "-00001f30: 2032 2d64 5f65 7870 2d6c 656e 3b20 2b2b   2-d_exp-len; ++",
            "-00001f40: 6929 2073 325b 695d 203d 2027 3027 3b0a  i) s2[i] = '0';.",
            "-00001f50: 2020 2020 2020 2020 6c65 6e20 2b3d 2069          len += i",
            "-00001f60: 3b0a 2020 2020 7d0a 2020 2020 656c 7365  ;.    }.    else",
            "-00001f70: 2069 6620 2864 5f65 7870 203c 2030 2026   if (d_exp < 0 &",
            "-00001f80: 2620 6c65 6e20 3e20 3129 202f 2a20 4164  & len > 1) /* Ad",
            "-00001f90: 6420 6465 6369 6d61 6c20 706f 696e 743f  d decimal point?",
            "-00001fa0: 202a 2f0a 2020 2020 7b0a 2020 2020 2020   */.    {.      ",
            "-00001fb0: 2020 666f 7228 6920 3d20 303b 2069 203c    for(i = 0; i <",
            "-00001fc0: 2064 6563 696d 616c 733b 202b 2b69 2920   decimals; ++i) ",
            "-00001fd0: 7332 5b6c 656e 2d69 5d20 3d20 7332 5b6c  s2[len-i] = s2[l",
            "-00001fe0: 656e 2d69 2d31 5d3b 0a20 2020 2020 2020  en-i-1];.       ",
            "-00001ff0: 2073 325b 6c65 6e2b 2b20 2d20 6465 6369   s2[len++ - deci",
            "-00002000: 6d61 6c73 5d20 3d20 272e 273b 0a20 2020  mals] = '.';.   ",
            "-00002010: 2020 2020 2064 5f65 7870 202b 3d20 6465       d_exp += de",
            "-00002020: 6369 6d61 6c73 3b0a 2020 2020 2020 2020  cimals;.        ",
            "-00002030: 2f2a 204e 6565 6420 7363 6965 6e74 6966  /* Need scientif",
            "-00002040: 6963 206e 6f74 6174 696f 6e20 6173 2077  ic notation as w",
            "-00002050: 656c 6c3f 202a 2f0a 2020 2020 2020 2020  ell? */.        ",
            "-00002060: 6966 2028 645f 6578 7020 213d 2030 2920  if (d_exp != 0) ",
            "-00002070: 7b20 7332 5b6c 656e 2b2b 5d20 3d20 2765  { s2[len++] = 'e",
            "-00002080: 273b 206c 656e 202b 3d20 6772 6973 7533  '; len += grisu3",
            "-00002090: 5f69 5f74 6f5f 7374 7228 645f 6578 702c  _i_to_str(d_exp,",
            "-000020a0: 2073 322b 6c65 6e29 3b20 7d0a 2020 2020   s2+len); }.    ",
            "-000020b0: 7d0a 2020 2020 2f2a 2041 6464 2073 6369  }.    /* Add sci",
            "-000020c0: 656e 7469 6669 6320 6e6f 7461 7469 6f6e  entific notation",
            "-000020d0: 3f20 2a2f 0a20 2020 2065 6c73 6520 6966  ? */.    else if",
            "-000020e0: 2028 645f 6578 7020 3c20 3020 7c7c 2064   (d_exp < 0 || d",
            "-000020f0: 5f65 7870 203e 2032 2920 7b20 7332 5b6c  _exp > 2) { s2[l",
            "-00002100: 656e 2b2b 5d20 3d20 2765 273b 206c 656e  en++] = 'e'; len",
            "-00002110: 202b 3d20 6772 6973 7533 5f69 5f74 6f5f   += grisu3_i_to_",
            "-00002120: 7374 7228 645f 6578 702c 2073 322b 6c65  str(d_exp, s2+le",
            "-00002130: 6e29 3b20 7d0a 2020 2020 2f2a 2041 6464  n); }.    /* Add",
            "-00002140: 207a 6572 6f65 7320 696e 7374 6561 6420   zeroes instead ",
            "-00002150: 6f66 2073 6369 656e 7469 6669 6320 6e6f  of scientific no",
            "-00002160: 7461 7469 6f6e 3f20 2a2f 0a20 2020 2065  tation? */.    e",
            "-00002170: 6c73 6520 6966 2028 645f 6578 7020 3e20  lse if (d_exp > ",
            "-00002180: 3029 207b 2077 6869 6c65 2864 5f65 7870  0) { while(d_exp",
            "-00002190: 2d2d 203e 2030 2920 7332 5b6c 656e 2b2b  -- > 0) s2[len++",
            "-000021a0: 5d20 3d20 2730 273b 207d 0a20 2020 2073  ] = '0'; }.    s",
            "-000021b0: 325b 6c65 6e5d 203d 2027 5c30 273b 202f  2[len] = '\\0'; /",
            "-000021c0: 2a20 6772 6973 7533 2064 6f65 736e 2774  * grisu3 doesn't",
            "-000021d0: 206e 756c 6c20 7465 726d 696e 6174 652c   null terminate,",
            "-000021e0: 2073 6f20 656e 7375 7265 2074 6572 6d69   so ensure termi",
            "-000021f0: 6e61 7469 6f6e 2e20 2a2f 0a20 2020 2072  nation. */.    r",
            "-00002200: 6574 7572 6e20 2869 6e74 2928 7332 2b6c  eturn (int)(s2+l",
            "-00002210: 656e 2d64 7374 293b 0a7d 0a0a 2369 6664  en-dst);.}..#ifd",
            "-00002220: 6566 205f 5f63 706c 7573 706c 7573 0a7d  ef __cplusplus.}",
            "-00002230: 0a23 656e 6469 660a 0a23 656e 6469 6620  .#endif..#endif ",
            "-00002240: 2f2a 2047 5249 5355 335f 5052 494e 545f  /* GRISU3_PRINT_",
            "-00002250: 4820 2a2f 0a                             H */.",
            "+00000630: 696e 7466 2c20 6f6e 6c79 206e 6565 6465  intf, only neede",
            "+00000640: 6420 666f 7220 6661 6c6c 6261 636b 2070  d for fallback p",
            "+00000650: 7269 6e74 696e 6720 2a2f 0a23 696e 636c  rinting */.#incl",
            "+00000660: 7564 6520 3c61 7373 6572 742e 683e 202f  ude <assert.h> /",
            "+00000670: 2a20 6173 7365 7274 202a 2f0a 0a23 696e  * assert */..#in",
            "+00000680: 636c 7564 6520 2267 7269 7375 335f 6d61  clude \"grisu3_ma",
            "+00000690: 7468 2e68 220a 0a2f 2a0a 202a 2054 6865  th.h\"../*. * The",
            "+000006a0: 206c 6967 6874 7765 6967 6874 2022 706f   lightweight \"po",
            "+000006b0: 7274 6162 6c65 2220 4320 6c69 6272 6172  rtable\" C librar",
            "+000006c0: 7920 7265 636f 676e 697a 6573 2067 7269  y recognizes gri",
            "+000006d0: 7375 3320 7375 7070 6f72 7420 6966 0a20  su3 support if. ",
            "+000006e0: 2a20 696e 636c 7564 6564 2066 6972 7374  * included first",
            "+000006f0: 2e0a 202a 2f0a 2364 6566 696e 6520 6772  .. */.#define gr",
            "+00000700: 6973 7533 5f70 7269 6e74 5f64 6f75 626c  isu3_print_doubl",
            "+00000710: 655f 6973 5f64 6566 696e 6564 2031 0a0a  e_is_defined 1..",
            "+00000720: 2f2a 0a20 2a20 4e6f 7420 7375 7265 2077  /*. * Not sure w",
            "+00000730: 6520 6861 7665 2061 6e20 6578 6163 7420  e have an exact ",
            "+00000740: 6465 6669 6e69 7469 6f6e 2c20 6275 7420  definition, but ",
            "+00000750: 7765 2067 6574 2075 7020 746f 2032 330a  we get up to 23.",
            "+00000760: 202a 2065 6d70 6572 6963 616c 6c79 2e20   * emperically. ",
            "+00000770: 5468 6572 6520 6973 2073 6f6d 6520 6d61  There is some ma",
            "+00000780: 7468 2065 6e73 7572 696e 6720 6974 2064  th ensuring it d",
            "+00000790: 6f65 7320 6e6f 7420 676f 2061 776f 6c20  oes not go awol ",
            "+000007a0: 7468 6f75 6768 2c0a 202a 206c 696b 6520  though,. * like ",
            "+000007b0: 3138 2064 6967 6974 7320 2b20 6578 706f  18 digits + expo",
            "+000007c0: 6e65 6e74 206f 7220 736f 2e0a 202a 2054  nent or so.. * T",
            "+000007d0: 6869 7320 6d61 7820 7368 6f75 6c64 2062  his max should b",
            "+000007e0: 6520 7361 6665 2073 697a 6520 6275 6666  e safe size buff",
            "+000007f0: 6572 2066 6f72 2070 7269 6e74 696e 672c  er for printing,",
            "+00000800: 2069 6e63 6c75 6469 6e67 207a 6572 6f20   including zero ",
            "+00000810: 7465 726d 2e0a 202a 2f0a 2364 6566 696e  term.. */.#defin",
            "+00000820: 6520 4752 4953 5533 5f50 5249 4e54 5f4d  e GRISU3_PRINT_M",
            "+00000830: 4158 2033 300a 0a73 7461 7469 6320 696e  AX 30..static in",
            "+00000840: 7420 6772 6973 7533 5f72 6f75 6e64 5f77  t grisu3_round_w",
            "+00000850: 6565 6428 6368 6172 202a 6275 6666 6572  eed(char *buffer",
            "+00000860: 2c20 696e 7420 6c65 6e2c 2075 696e 7436  , int len, uint6",
            "+00000870: 345f 7420 7770 5f57 2c20 7569 6e74 3634  4_t wp_W, uint64",
            "+00000880: 5f74 2064 656c 7461 2c20 7569 6e74 3634  _t delta, uint64",
            "+00000890: 5f74 2072 6573 742c 2075 696e 7436 345f  _t rest, uint64_",
            "+000008a0: 7420 7465 6e5f 6b61 7070 612c 2075 696e  t ten_kappa, uin",
            "+000008b0: 7436 345f 7420 756c 7029 0a7b 0a20 2020  t64_t ulp).{.   ",
            "+000008c0: 2075 696e 7436 345f 7420 7770 5f57 7570   uint64_t wp_Wup",
            "+000008d0: 203d 2077 705f 5720 2d20 756c 703b 0a20   = wp_W - ulp;. ",
            "+000008e0: 2020 2075 696e 7436 345f 7420 7770 5f57     uint64_t wp_W",
            "+000008f0: 646f 776e 203d 2077 705f 5720 2b20 756c  down = wp_W + ul",
            "+00000900: 703b 0a20 2020 2077 6869 6c65 2872 6573  p;.    while(res",
            "+00000910: 7420 3c20 7770 5f57 7570 2026 2620 6465  t < wp_Wup && de",
            "+00000920: 6c74 6120 2d20 7265 7374 203e 3d20 7465  lta - rest >= te",
            "+00000930: 6e5f 6b61 7070 610a 2020 2020 2020 2020  n_kappa.        ",
            "+00000940: 2626 2028 7265 7374 202b 2074 656e 5f6b  && (rest + ten_k",
            "+00000950: 6170 7061 203c 2077 705f 5775 7020 7c7c  appa < wp_Wup ||",
            "+00000960: 2077 705f 5775 7020 2d20 7265 7374 203e   wp_Wup - rest >",
            "+00000970: 3d20 7265 7374 202b 2074 656e 5f6b 6170  = rest + ten_kap",
            "+00000980: 7061 202d 2077 705f 5775 7029 290a 2020  pa - wp_Wup)).  ",
            "+00000990: 2020 7b0a 2020 2020 2020 2020 2d2d 6275    {.        --bu",
            "+000009a0: 6666 6572 5b6c 656e 2d31 5d3b 0a20 2020  ffer[len-1];.   ",
            "+000009b0: 2020 2020 2072 6573 7420 2b3d 2074 656e       rest += ten",
            "+000009c0: 5f6b 6170 7061 3b0a 2020 2020 7d0a 2020  _kappa;.    }.  ",
            "+000009d0: 2020 6966 2028 7265 7374 203c 2077 705f    if (rest < wp_",
            "+000009e0: 5764 6f77 6e20 2626 2064 656c 7461 202d  Wdown && delta -",
            "+000009f0: 2072 6573 7420 3e3d 2074 656e 5f6b 6170   rest >= ten_kap",
            "+00000a00: 7061 0a20 2020 2020 2020 2026 2620 2872  pa.        && (r",
            "+00000a10: 6573 7420 2b20 7465 6e5f 6b61 7070 6120  est + ten_kappa ",
            "+00000a20: 3c20 7770 5f57 646f 776e 207c 7c20 7770  < wp_Wdown || wp",
            "+00000a30: 5f57 646f 776e 202d 2072 6573 7420 3e20  _Wdown - rest > ",
            "+00000a40: 7265 7374 202b 2074 656e 5f6b 6170 7061  rest + ten_kappa",
            "+00000a50: 202d 2077 705f 5764 6f77 6e29 290a 2020   - wp_Wdown)).  ",
            "+00000a60: 2020 2020 2020 7265 7475 726e 2030 3b0a        return 0;.",
            "+00000a70: 0a20 2020 2072 6574 7572 6e20 322a 756c  .    return 2*ul",
            "+00000a80: 7020 3c3d 2072 6573 7420 2626 2072 6573  p <= rest && res",
            "+00000a90: 7420 3c3d 2064 656c 7461 202d 2034 2a75  t <= delta - 4*u",
            "+00000aa0: 6c70 3b0a 7d0a 0a73 7461 7469 6320 696e  lp;.}..static in",
            "+00000ab0: 7420 6772 6973 7533 5f64 6967 6974 5f67  t grisu3_digit_g",
            "+00000ac0: 656e 2867 7269 7375 335f 6469 795f 6670  en(grisu3_diy_fp",
            "+00000ad0: 5f74 206c 6f77 2c20 6772 6973 7533 5f64  _t low, grisu3_d",
            "+00000ae0: 6979 5f66 705f 7420 772c 2067 7269 7375  iy_fp_t w, grisu",
            "+00000af0: 335f 6469 795f 6670 5f74 2068 6967 682c  3_diy_fp_t high,",
            "+00000b00: 2063 6861 7220 2a62 7566 6665 722c 2069   char *buffer, i",
            "+00000b10: 6e74 202a 6c65 6e67 7468 2c20 696e 7420  nt *length, int ",
            "+00000b20: 2a6b 6170 7061 290a 7b0a 2020 2020 7569  *kappa).{.    ui",
            "+00000b30: 6e74 3634 5f74 2075 6e69 7420 3d20 313b  nt64_t unit = 1;",
            "+00000b40: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "+00000b50: 6670 5f74 2074 6f6f 5f6c 6f77 203d 207b  fp_t too_low = {",
            "+00000b60: 206c 6f77 2e66 202d 2075 6e69 742c 206c   low.f - unit, l",
            "+00000b70: 6f77 2e65 207d 3b0a 2020 2020 6772 6973  ow.e };.    gris",
            "+00000b80: 7533 5f64 6979 5f66 705f 7420 746f 6f5f  u3_diy_fp_t too_",
            "+00000b90: 6869 6768 203d 207b 2068 6967 682e 6620  high = { high.f ",
            "+00000ba0: 2b20 756e 6974 2c20 6869 6768 2e65 207d  + unit, high.e }",
            "+00000bb0: 3b0a 2020 2020 6772 6973 7533 5f64 6979  ;.    grisu3_diy",
            "+00000bc0: 5f66 705f 7420 756e 7361 6665 5f69 6e74  _fp_t unsafe_int",
            "+00000bd0: 6572 7661 6c20 3d20 2067 7269 7375 335f  erval =  grisu3_",
            "+00000be0: 6469 795f 6670 5f6d 696e 7573 2874 6f6f  diy_fp_minus(too",
            "+00000bf0: 5f68 6967 682c 2074 6f6f 5f6c 6f77 293b  _high, too_low);",
            "+00000c00: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "+00000c10: 6670 5f74 206f 6e65 203d 207b 2031 554c  fp_t one = { 1UL",
            "+00000c20: 4c20 3c3c 202d 772e 652c 2077 2e65 207d  L << -w.e, w.e }",
            "+00000c30: 3b0a 2020 2020 7569 6e74 3332 5f74 2070  ;.    uint32_t p",
            "+00000c40: 3120 3d20 2875 696e 7433 325f 7429 2874  1 = (uint32_t)(t",
            "+00000c50: 6f6f 5f68 6967 682e 6620 3e3e 202d 6f6e  oo_high.f >> -on",
            "+00000c60: 652e 6529 3b0a 2020 2020 7569 6e74 3634  e.e);.    uint64",
            "+00000c70: 5f74 2070 3220 3d20 746f 6f5f 6869 6768  _t p2 = too_high",
            "+00000c80: 2e66 2026 2028 6f6e 652e 6620 2d20 3129  .f & (one.f - 1)",
            "+00000c90: 3b0a 2020 2020 7569 6e74 3332 5f74 2064  ;.    uint32_t d",
            "+00000ca0: 6976 3b0a 2020 2020 2a6b 6170 7061 203d  iv;.    *kappa =",
            "+00000cb0: 2067 7269 7375 335f 6c61 7267 6573 745f   grisu3_largest_",
            "+00000cc0: 706f 7731 3028 7031 2c20 4752 4953 5533  pow10(p1, GRISU3",
            "+00000cd0: 5f44 4959 5f46 505f 4652 4143 545f 5349  _DIY_FP_FRACT_SI",
            "+00000ce0: 5a45 202b 206f 6e65 2e65 2c20 2664 6976  ZE + one.e, &div",
            "+00000cf0: 293b 0a20 2020 202a 6c65 6e67 7468 203d  );.    *length =",
            "+00000d00: 2030 3b0a 0a20 2020 2077 6869 6c65 282a   0;..    while(*",
            "+00000d10: 6b61 7070 6120 3e20 3029 0a20 2020 207b  kappa > 0).    {",
            "+00000d20: 0a20 2020 2020 2020 2075 696e 7436 345f  .        uint64_",
            "+00000d30: 7420 7265 7374 3b0a 2020 2020 2020 2020  t rest;.        ",
            "+00000d40: 6368 6172 2064 6967 6974 203d 2028 6368  char digit = (ch",
            "+00000d50: 6172 2928 7031 202f 2064 6976 293b 0a20  ar)(p1 / div);. ",
            "+00000d60: 2020 2020 2020 2062 7566 6665 725b 2a6c         buffer[*l",
            "+00000d70: 656e 6774 685d 203d 2027 3027 202b 2064  ength] = '0' + d",
            "+00000d80: 6967 6974 3b0a 2020 2020 2020 2020 2b2b  igit;.        ++",
            "+00000d90: 2a6c 656e 6774 683b 0a20 2020 2020 2020  *length;.       ",
            "+00000da0: 2070 3120 253d 2064 6976 3b0a 2020 2020   p1 %= div;.    ",
            "+00000db0: 2020 2020 2d2d 2a6b 6170 7061 3b0a 2020      --*kappa;.  ",
            "+00000dc0: 2020 2020 2020 7265 7374 203d 2028 2875        rest = ((u",
            "+00000dd0: 696e 7436 345f 7429 7031 203c 3c20 2d6f  int64_t)p1 << -o",
            "+00000de0: 6e65 2e65 2920 2b20 7032 3b0a 2020 2020  ne.e) + p2;.    ",
            "+00000df0: 2020 2020 6966 2028 7265 7374 203c 2075      if (rest < u",
            "+00000e00: 6e73 6166 655f 696e 7465 7276 616c 2e66  nsafe_interval.f",
            "+00000e10: 2920 7265 7475 726e 2067 7269 7375 335f  ) return grisu3_",
            "+00000e20: 726f 756e 645f 7765 6564 2862 7566 6665  round_weed(buffe",
            "+00000e30: 722c 202a 6c65 6e67 7468 2c20 6772 6973  r, *length, gris",
            "+00000e40: 7533 5f64 6979 5f66 705f 6d69 6e75 7328  u3_diy_fp_minus(",
            "+00000e50: 746f 6f5f 6869 6768 2c20 7729 2e66 2c20  too_high, w).f, ",
            "+00000e60: 756e 7361 6665 5f69 6e74 6572 7661 6c2e  unsafe_interval.",
            "+00000e70: 662c 2072 6573 742c 2028 7569 6e74 3634  f, rest, (uint64",
            "+00000e80: 5f74 2964 6976 203c 3c20 2d6f 6e65 2e65  _t)div << -one.e",
            "+00000e90: 2c20 756e 6974 293b 0a20 2020 2020 2020  , unit);.       ",
            "+00000ea0: 2064 6976 202f 3d20 3130 3b0a 2020 2020   div /= 10;.    ",
            "+00000eb0: 7d0a 0a20 2020 2066 6f72 283b 3b29 0a20  }..    for(;;). ",
            "+00000ec0: 2020 207b 0a20 2020 2020 2020 2063 6861     {.        cha",
            "+00000ed0: 7220 6469 6769 743b 0a20 2020 2020 2020  r digit;.       ",
            "+00000ee0: 2070 3220 2a3d 2031 303b 0a20 2020 2020   p2 *= 10;.     ",
            "+00000ef0: 2020 2075 6e69 7420 2a3d 2031 303b 0a20     unit *= 10;. ",
            "+00000f00: 2020 2020 2020 2075 6e73 6166 655f 696e         unsafe_in",
            "+00000f10: 7465 7276 616c 2e66 202a 3d20 3130 3b0a  terval.f *= 10;.",
            "+00000f20: 2020 2020 2020 2020 2f2a 2049 6e74 6567          /* Integ",
            "+00000f30: 6572 2064 6976 6973 696f 6e20 6279 206f  er division by o",
            "+00000f40: 6e65 2e20 2a2f 0a20 2020 2020 2020 2064  ne. */.        d",
            "+00000f50: 6967 6974 203d 2028 6368 6172 2928 7032  igit = (char)(p2",
            "+00000f60: 203e 3e20 2d6f 6e65 2e65 293b 0a20 2020   >> -one.e);.   ",
            "+00000f70: 2020 2020 2062 7566 6665 725b 2a6c 656e       buffer[*len",
            "+00000f80: 6774 685d 203d 2027 3027 202b 2064 6967  gth] = '0' + dig",
            "+00000f90: 6974 3b0a 2020 2020 2020 2020 2b2b 2a6c  it;.        ++*l",
            "+00000fa0: 656e 6774 683b 0a20 2020 2020 2020 2070  ength;.        p",
            "+00000fb0: 3220 263d 206f 6e65 2e66 202d 2031 3b20  2 &= one.f - 1; ",
            "+00000fc0: 2f2a 204d 6f64 756c 6f20 6279 206f 6e65  /* Modulo by one",
            "+00000fd0: 2e20 2a2f 0a20 2020 2020 2020 202d 2d2a  . */.        --*",
            "+00000fe0: 6b61 7070 613b 0a20 2020 2020 2020 2069  kappa;.        i",
            "+00000ff0: 6620 2870 3220 3c20 756e 7361 6665 5f69  f (p2 < unsafe_i",
            "+00001000: 6e74 6572 7661 6c2e 6629 2072 6574 7572  nterval.f) retur",
            "+00001010: 6e20 6772 6973 7533 5f72 6f75 6e64 5f77  n grisu3_round_w",
            "+00001020: 6565 6428 6275 6666 6572 2c20 2a6c 656e  eed(buffer, *len",
            "+00001030: 6774 682c 2067 7269 7375 335f 6469 795f  gth, grisu3_diy_",
            "+00001040: 6670 5f6d 696e 7573 2874 6f6f 5f68 6967  fp_minus(too_hig",
            "+00001050: 682c 2077 292e 6620 2a20 756e 6974 2c20  h, w).f * unit, ",
            "+00001060: 756e 7361 6665 5f69 6e74 6572 7661 6c2e  unsafe_interval.",
            "+00001070: 662c 2070 322c 206f 6e65 2e66 2c20 756e  f, p2, one.f, un",
            "+00001080: 6974 293b 0a20 2020 207d 0a7d 0a0a 7374  it);.    }.}..st",
            "+00001090: 6174 6963 2069 6e74 2067 7269 7375 3328  atic int grisu3(",
            "+000010a0: 646f 7562 6c65 2076 2c20 6368 6172 202a  double v, char *",
            "+000010b0: 6275 6666 6572 2c20 696e 7420 2a6c 656e  buffer, int *len",
            "+000010c0: 6774 682c 2069 6e74 202a 645f 6578 7029  gth, int *d_exp)",
            "+000010d0: 0a7b 0a20 2020 2069 6e74 206d 6b2c 206b  .{.    int mk, k",
            "+000010e0: 6170 7061 2c20 7375 6363 6573 733b 0a20  appa, success;. ",
            "+000010f0: 2020 2067 7269 7375 335f 6469 795f 6670     grisu3_diy_fp",
            "+00001100: 5f74 2064 6670 203d 2067 7269 7375 335f  _t dfp = grisu3_",
            "+00001110: 6361 7374 5f64 6979 5f66 705f 6672 6f6d  cast_diy_fp_from",
            "+00001120: 5f64 6f75 626c 6528 7629 3b0a 2020 2020  _double(v);.    ",
            "+00001130: 6772 6973 7533 5f64 6979 5f66 705f 7420  grisu3_diy_fp_t ",
            "+00001140: 7720 3d20 6772 6973 7533 5f64 6979 5f66  w = grisu3_diy_f",
            "+00001150: 705f 6e6f 726d 616c 697a 6528 6466 7029  p_normalize(dfp)",
            "+00001160: 3b0a 0a20 2020 202f 2a20 6e6f 726d 616c  ;..    /* normal",
            "+00001170: 697a 6520 626f 756e 6461 7269 6573 202a  ize boundaries *",
            "+00001180: 2f0a 2020 2020 6772 6973 7533 5f64 6979  /.    grisu3_diy",
            "+00001190: 5f66 705f 7420 7420 3d20 7b20 2864 6670  _fp_t t = { (dfp",
            "+000011a0: 2e66 203c 3c20 3129 202b 2031 2c20 6466  .f << 1) + 1, df",
            "+000011b0: 702e 6520 2d20 3120 7d3b 0a20 2020 2067  p.e - 1 };.    g",
            "+000011c0: 7269 7375 335f 6469 795f 6670 5f74 2062  risu3_diy_fp_t b",
            "+000011d0: 5f70 6c75 7320 3d20 6772 6973 7533 5f64  _plus = grisu3_d",
            "+000011e0: 6979 5f66 705f 6e6f 726d 616c 697a 6528  iy_fp_normalize(",
            "+000011f0: 7429 3b0a 2020 2020 6772 6973 7533 5f64  t);.    grisu3_d",
            "+00001200: 6979 5f66 705f 7420 625f 6d69 6e75 733b  iy_fp_t b_minus;",
            "+00001210: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "+00001220: 6670 5f74 2063 5f6d 6b3b 202f 2a20 4361  fp_t c_mk; /* Ca",
            "+00001230: 6368 6564 2070 6f77 6572 206f 6620 7465  ched power of te",
            "+00001240: 6e3a 2031 305e 2d6b 202a 2f0a 2020 2020  n: 10^-k */.    ",
            "+00001250: 7569 6e74 3634 5f74 2075 3634 203d 2067  uint64_t u64 = g",
            "+00001260: 7269 7375 335f 6361 7374 5f75 696e 7436  risu3_cast_uint6",
            "+00001270: 345f 6672 6f6d 5f64 6f75 626c 6528 7629  4_from_double(v)",
            "+00001280: 3b0a 2020 2020 6173 7365 7274 2876 203e  ;.    assert(v >",
            "+00001290: 2030 2026 2620 7620 3c3d 2031 2e37 3937   0 && v <= 1.797",
            "+000012a0: 3639 3331 3334 3836 3233 3135 3765 3330  6931348623157e30",
            "+000012b0: 3829 3b20 2f2a 2047 7269 7375 206f 6e6c  8); /* Grisu onl",
            "+000012c0: 7920 6861 6e64 6c65 7320 7374 7269 6374  y handles strict",
            "+000012d0: 6c79 2070 6f73 6974 6976 6520 6669 6e69  ly positive fini",
            "+000012e0: 7465 206e 756d 6265 7273 2e20 2a2f 0a20  te numbers. */. ",
            "+000012f0: 2020 2069 6620 2821 2875 3634 2026 2047     if (!(u64 & G",
            "+00001300: 5249 5355 335f 4436 345f 4652 4143 545f  RISU3_D64_FRACT_",
            "+00001310: 4d41 534b 2920 2626 2028 7536 3420 2620  MASK) && (u64 & ",
            "+00001320: 4752 4953 5533 5f44 3634 5f45 5850 5f4d  GRISU3_D64_EXP_M",
            "+00001330: 4153 4b29 2021 3d20 3029 207b 2062 5f6d  ASK) != 0) { b_m",
            "+00001340: 696e 7573 2e66 203d 2028 6466 702e 6620  inus.f = (dfp.f ",
            "+00001350: 3c3c 2032 2920 2d20 313b 2062 5f6d 696e  << 2) - 1; b_min",
            "+00001360: 7573 2e65 203d 2020 6466 702e 6520 2d20  us.e =  dfp.e - ",
            "+00001370: 323b 7d20 2f2a 206c 6f77 6572 2062 6f75  2;} /* lower bou",
            "+00001380: 6e64 6172 7920 6973 2063 6c6f 7365 723f  ndary is closer?",
            "+00001390: 202a 2f0a 2020 2020 656c 7365 207b 2062   */.    else { b",
            "+000013a0: 5f6d 696e 7573 2e66 203d 2028 6466 702e  _minus.f = (dfp.",
            "+000013b0: 6620 3c3c 2031 2920 2d20 313b 2062 5f6d  f << 1) - 1; b_m",
            "+000013c0: 696e 7573 2e65 203d 2064 6670 2e65 202d  inus.e = dfp.e -",
            "+000013d0: 2031 3b20 7d0a 2020 2020 625f 6d69 6e75   1; }.    b_minu",
            "+000013e0: 732e 6620 3d20 625f 6d69 6e75 732e 6620  s.f = b_minus.f ",
            "+000013f0: 3c3c 2028 625f 6d69 6e75 732e 6520 2d20  << (b_minus.e - ",
            "+00001400: 625f 706c 7573 2e65 293b 0a20 2020 2062  b_plus.e);.    b",
            "+00001410: 5f6d 696e 7573 2e65 203d 2062 5f70 6c75  _minus.e = b_plu",
            "+00001420: 732e 653b 0a0a 2020 2020 6d6b 203d 2067  s.e;..    mk = g",
            "+00001430: 7269 7375 335f 6469 795f 6670 5f63 6163  risu3_diy_fp_cac",
            "+00001440: 6865 645f 706f 7728 4752 4953 5533 5f4d  hed_pow(GRISU3_M",
            "+00001450: 494e 5f54 4152 4745 545f 4558 5020 2d20  IN_TARGET_EXP - ",
            "+00001460: 4752 4953 5533 5f44 4959 5f46 505f 4652  GRISU3_DIY_FP_FR",
            "+00001470: 4143 545f 5349 5a45 202d 2077 2e65 2c20  ACT_SIZE - w.e, ",
            "+00001480: 2663 5f6d 6b29 3b0a 0a20 2020 2077 203d  &c_mk);..    w =",
            "+00001490: 2067 7269 7375 335f 6469 795f 6670 5f6d   grisu3_diy_fp_m",
            "+000014a0: 756c 7469 706c 7928 772c 2063 5f6d 6b29  ultiply(w, c_mk)",
            "+000014b0: 3b0a 2020 2020 625f 6d69 6e75 7320 3d20  ;.    b_minus = ",
            "+000014c0: 6772 6973 7533 5f64 6979 5f66 705f 6d75  grisu3_diy_fp_mu",
            "+000014d0: 6c74 6970 6c79 2862 5f6d 696e 7573 2c20  ltiply(b_minus, ",
            "+000014e0: 635f 6d6b 293b 0a20 2020 2062 5f70 6c75  c_mk);.    b_plu",
            "+000014f0: 7320 203d 2067 7269 7375 335f 6469 795f  s  = grisu3_diy_",
            "+00001500: 6670 5f6d 756c 7469 706c 7928 625f 706c  fp_multiply(b_pl",
            "+00001510: 7573 2c20 2063 5f6d 6b29 3b0a 0a20 2020  us,  c_mk);..   ",
            "+00001520: 2073 7563 6365 7373 203d 2067 7269 7375   success = grisu",
            "+00001530: 335f 6469 6769 745f 6765 6e28 625f 6d69  3_digit_gen(b_mi",
            "+00001540: 6e75 732c 2077 2c20 625f 706c 7573 2c20  nus, w, b_plus, ",
            "+00001550: 6275 6666 6572 2c20 6c65 6e67 7468 2c20  buffer, length, ",
            "+00001560: 266b 6170 7061 293b 0a20 2020 202a 645f  &kappa);.    *d_",
            "+00001570: 6578 7020 3d20 6b61 7070 6120 2d20 6d6b  exp = kappa - mk",
            "+00001580: 3b0a 2020 2020 7265 7475 726e 2073 7563  ;.    return suc",
            "+00001590: 6365 7373 3b0a 7d0a 0a73 7461 7469 6320  cess;.}..static ",
            "+000015a0: 696e 7420 6772 6973 7533 5f69 5f74 6f5f  int grisu3_i_to_",
            "+000015b0: 7374 7228 696e 7420 7661 6c2c 2063 6861  str(int val, cha",
            "+000015c0: 7220 2a73 7472 290a 7b0a 2020 2020 696e  r *str).{.    in",
            "+000015d0: 7420 6c65 6e2c 2069 3b0a 2020 2020 6368  t len, i;.    ch",
            "+000015e0: 6172 202a 733b 0a20 2020 2063 6861 7220  ar *s;.    char ",
            "+000015f0: 2a62 6567 696e 203d 2073 7472 3b0a 2020  *begin = str;.  ",
            "+00001600: 2020 6966 2028 7661 6c20 3c20 3029 207b    if (val < 0) {",
            "+00001610: 202a 7374 722b 2b20 3d20 272d 273b 2076   *str++ = '-'; v",
            "+00001620: 616c 203d 202d 7661 6c3b 207d 0a20 2020  al = -val; }.   ",
            "+00001630: 2073 203d 2073 7472 3b0a 0a20 2020 2066   s = str;..    f",
            "+00001640: 6f72 283b 3b29 0a20 2020 207b 0a20 2020  or(;;).    {.   ",
            "+00001650: 2020 2020 2069 6e74 206e 6920 3d20 7661       int ni = va",
            "+00001660: 6c20 2f20 3130 3b0a 2020 2020 2020 2020  l / 10;.        ",
            "+00001670: 696e 7420 6469 6769 7420 3d20 7661 6c20  int digit = val ",
            "+00001680: 2d20 6e69 2a31 303b 0a20 2020 2020 2020  - ni*10;.       ",
            "+00001690: 202a 732b 2b20 3d20 2863 6861 7229 2827   *s++ = (char)('",
            "+000016a0: 3027 202b 2064 6967 6974 293b 0a20 2020  0' + digit);.   ",
            "+000016b0: 2020 2020 2069 6620 286e 6920 3d3d 2030       if (ni == 0",
            "+000016c0: 290a 2020 2020 2020 2020 2020 2020 6272  ).            br",
            "+000016d0: 6561 6b3b 0a20 2020 2020 2020 2076 616c  eak;.        val",
            "+000016e0: 203d 206e 693b 0a20 2020 207d 0a20 2020   = ni;.    }.   ",
            "+000016f0: 202a 7320 3d20 275c 3027 3b0a 2020 2020   *s = '\\0';.    ",
            "+00001700: 6c65 6e20 3d20 2869 6e74 2928 7320 2d20  len = (int)(s - ",
            "+00001710: 7374 7229 3b0a 2020 2020 666f 7228 6920  str);.    for(i ",
            "+00001720: 3d20 303b 2069 203c 206c 656e 2f32 3b20  = 0; i < len/2; ",
            "+00001730: 2b2b 6929 0a20 2020 207b 0a20 2020 2020  ++i).    {.     ",
            "+00001740: 2020 2063 6861 7220 6368 203d 2073 7472     char ch = str",
            "+00001750: 5b69 5d3b 0a20 2020 2020 2020 2073 7472  [i];.        str",
            "+00001760: 5b69 5d20 3d20 7374 725b 6c65 6e2d 312d  [i] = str[len-1-",
            "+00001770: 695d 3b0a 2020 2020 2020 2020 7374 725b  i];.        str[",
            "+00001780: 6c65 6e2d 312d 695d 203d 2063 683b 0a20  len-1-i] = ch;. ",
            "+00001790: 2020 207d 0a0a 2020 2020 7265 7475 726e     }..    return",
            "+000017a0: 2028 696e 7429 2873 202d 2062 6567 696e   (int)(s - begin",
            "+000017b0: 293b 0a7d 0a0a 7374 6174 6963 2069 6e74  );.}..static int",
            "+000017c0: 2067 7269 7375 335f 7072 696e 745f 6e61   grisu3_print_na",
            "+000017d0: 6e28 7569 6e74 3634 5f74 2076 2c20 6368  n(uint64_t v, ch",
            "+000017e0: 6172 202a 6473 7429 0a7b 0a20 2020 2073  ar *dst).{.    s",
            "+000017f0: 7461 7469 6320 6368 6172 2068 6578 6469  tatic char hexdi",
            "+00001800: 6769 7473 5b31 365d 203d 2022 3031 3233  gits[16] = \"0123",
            "+00001810: 3435 3637 3839 4142 4344 4546 223b 0a20  456789ABCDEF\";. ",
            "+00001820: 2020 2069 6e74 2069 203d 2030 3b0a 0a20     int i = 0;.. ",
            "+00001830: 2020 2064 7374 5b30 5d20 3d20 274e 273b     dst[0] = 'N';",
            "+00001840: 0a20 2020 2064 7374 5b31 5d20 3d20 2761  .    dst[1] = 'a",
            "+00001850: 273b 0a20 2020 2064 7374 5b32 5d20 3d20  ';.    dst[2] = ",
            "+00001860: 274e 273b 0a20 2020 2064 7374 5b33 5d20  'N';.    dst[3] ",
            "+00001870: 3d20 2728 273b 0a20 2020 2064 7374 5b32  = '(';.    dst[2",
            "+00001880: 305d 203d 2027 2927 3b0a 2020 2020 6473  0] = ')';.    ds",
            "+00001890: 745b 3231 5d20 3d20 275c 3027 3b0a 2020  t[21] = '\\0';.  ",
            "+000018a0: 2020 6473 7420 2b3d 2034 3b0a 2020 2020    dst += 4;.    ",
            "+000018b0: 666f 7220 2869 203d 2031 353b 2069 203e  for (i = 15; i >",
            "+000018c0: 3d20 303b 202d 2d69 2920 7b0a 2020 2020  = 0; --i) {.    ",
            "+000018d0: 2020 2020 6473 745b 695d 203d 2068 6578      dst[i] = hex",
            "+000018e0: 6469 6769 7473 5b76 2026 2030 7830 465d  digits[v & 0x0F]",
            "+000018f0: 3b0a 2020 2020 2020 2020 7620 3e3e 3d20  ;.        v >>= ",
            "+00001900: 343b 0a20 2020 207d 0a20 2020 2072 6574  4;.    }.    ret",
            "+00001910: 7572 6e20 3231 3b0a 7d0a 0a73 7461 7469  urn 21;.}..stati",
            "+00001920: 6320 696e 7420 6772 6973 7533 5f70 7269  c int grisu3_pri",
            "+00001930: 6e74 5f64 6f75 626c 6528 646f 7562 6c65  nt_double(double",
            "+00001940: 2076 2c20 6368 6172 202a 6473 7429 0a7b   v, char *dst).{",
            "+00001950: 0a20 2020 2069 6e74 2064 5f65 7870 2c20  .    int d_exp, ",
            "+00001960: 6c65 6e2c 2073 7563 6365 7373 2c20 6465  len, success, de",
            "+00001970: 6369 6d61 6c73 2c20 693b 0a20 2020 2075  cimals, i;.    u",
            "+00001980: 696e 7436 345f 7420 7536 3420 3d20 6772  int64_t u64 = gr",
            "+00001990: 6973 7533 5f63 6173 745f 7569 6e74 3634  isu3_cast_uint64",
            "+000019a0: 5f66 726f 6d5f 646f 7562 6c65 2876 293b  _from_double(v);",
            "+000019b0: 0a20 2020 2063 6861 7220 2a73 3220 3d20  .    char *s2 = ",
            "+000019c0: 6473 743b 0a20 2020 2061 7373 6572 7428  dst;.    assert(",
            "+000019d0: 6473 7429 3b0a 0a20 2020 202f 2a20 5072  dst);..    /* Pr",
            "+000019e0: 6568 616e 646c 6520 4e61 4e73 202a 2f0a  ehandle NaNs */.",
            "+000019f0: 2020 2020 6966 2028 2875 3634 203c 3c20      if ((u64 << ",
            "+00001a00: 3129 203e 2030 7846 4645 3030 3030 3030  1) > 0xFFE000000",
            "+00001a10: 3030 3030 3030 3055 4c4c 2920 7265 7475  0000000ULL) retu",
            "+00001a20: 726e 2067 7269 7375 335f 7072 696e 745f  rn grisu3_print_",
            "+00001a30: 6e61 6e28 7536 342c 2064 7374 293b 0a20  nan(u64, dst);. ",
            "+00001a40: 2020 202f 2a20 5072 6568 616e 646c 6520     /* Prehandle ",
            "+00001a50: 6e65 6761 7469 7665 2076 616c 7565 732e  negative values.",
            "+00001a60: 202a 2f0a 2020 2020 6966 2028 2875 3634   */.    if ((u64",
            "+00001a70: 2026 2047 5249 5355 335f 4436 345f 5349   & GRISU3_D64_SI",
            "+00001a80: 474e 2920 213d 2030 2920 7b20 2a73 322b  GN) != 0) { *s2+",
            "+00001a90: 2b20 3d20 272d 273b 2076 203d 202d 763b  + = '-'; v = -v;",
            "+00001aa0: 2075 3634 205e 3d20 4752 4953 5533 5f44   u64 ^= GRISU3_D",
            "+00001ab0: 3634 5f53 4947 4e3b 207d 0a20 2020 202f  64_SIGN; }.    /",
            "+00001ac0: 2a20 5072 6568 616e 646c 6520 7a65 726f  * Prehandle zero",
            "+00001ad0: 2e20 2a2f 0a20 2020 2069 6620 2821 7536  . */.    if (!u6",
            "+00001ae0: 3429 207b 202a 7332 2b2b 203d 2027 3027  4) { *s2++ = '0'",
            "+00001af0: 3b20 2a73 3220 3d20 275c 3027 3b20 7265  ; *s2 = '\\0'; re",
            "+00001b00: 7475 726e 2028 696e 7429 2873 3220 2d20  turn (int)(s2 - ",
            "+00001b10: 6473 7429 3b20 7d0a 2020 2020 2f2a 2050  dst); }.    /* P",
            "+00001b20: 7265 6861 6e64 6c65 2069 6e66 696e 6974  rehandle infinit",
            "+00001b30: 792e 202a 2f0a 2020 2020 6966 2028 7536  y. */.    if (u6",
            "+00001b40: 3420 3d3d 2047 5249 5355 335f 4436 345f  4 == GRISU3_D64_",
            "+00001b50: 4558 505f 4d41 534b 2920 7b20 2a73 322b  EXP_MASK) { *s2+",
            "+00001b60: 2b20 3d20 2769 273b 202a 7332 2b2b 203d  + = 'i'; *s2++ =",
            "+00001b70: 2027 6e27 3b20 2a73 322b 2b20 3d20 2766   'n'; *s2++ = 'f",
            "+00001b80: 273b 202a 7332 203d 2027 5c30 273b 2072  '; *s2 = '\\0'; r",
            "+00001b90: 6574 7572 6e20 2869 6e74 2928 7332 202d  eturn (int)(s2 -",
            "+00001ba0: 2064 7374 293b 207d 0a0a 2020 2020 7375   dst); }..    su",
            "+00001bb0: 6363 6573 7320 3d20 6772 6973 7533 2876  ccess = grisu3(v",
            "+00001bc0: 2c20 7332 2c20 266c 656e 2c20 2664 5f65  , s2, &len, &d_e",
            "+00001bd0: 7870 293b 0a20 2020 202f 2a20 4966 2067  xp);.    /* If g",
            "+00001be0: 7269 7375 3320 7761 7320 6e6f 7420 6162  risu3 was not ab",
            "+00001bf0: 6c65 2074 6f20 636f 6e76 6572 7420 7468  le to convert th",
            "+00001c00: 6520 6e75 6d62 6572 2074 6f20 6120 7374  e number to a st",
            "+00001c10: 7269 6e67 2c20 7468 656e 2075 7365 206f  ring, then use o",
            "+00001c20: 6c64 2073 7072 696e 7466 2028 7375 626f  ld sprintf (subo",
            "+00001c30: 7074 696d 616c 292e 202a 2f0a 2020 2020  ptimal). */.    ",
            "+00001c40: 6966 2028 2173 7563 6365 7373 2920 7265  if (!success) re",
            "+00001c50: 7475 726e 2073 7072 696e 7466 2873 322c  turn sprintf(s2,",
            "+00001c60: 2022 252e 3137 6722 2c20 7629 202b 2028   \"%.17g\", v) + (",
            "+00001c70: 696e 7429 2873 3220 2d20 6473 7429 3b0a  int)(s2 - dst);.",
            "+00001c80: 0a20 2020 202f 2a20 5765 206e 6f77 2068  .    /* We now h",
            "+00001c90: 6176 6520 616e 2069 6e74 6567 6572 2073  ave an integer s",
            "+00001ca0: 7472 696e 6720 6f66 2066 6f72 6d20 2231  tring of form \"1",
            "+00001cb0: 3531 3332 3431 3335 2220 616e 6420 6120  51324135\" and a ",
            "+00001cc0: 6261 7365 2d31 3020 6578 706f 6e65 6e74  base-10 exponent",
            "+00001cd0: 2066 6f72 2074 6861 7420 6e75 6d62 6572   for that number",
            "+00001ce0: 2e20 2a2f 0a20 2020 202f 2a20 4e65 7874  . */.    /* Next",
            "+00001cf0: 2c20 6465 6369 6465 2074 6865 2062 6573  , decide the bes",
            "+00001d00: 7420 7072 6573 656e 7461 7469 6f6e 2066  t presentation f",
            "+00001d10: 6f72 2074 6861 7420 7374 7269 6e67 2062  or that string b",
            "+00001d20: 7920 7768 6574 6865 7220 746f 2075 7365  y whether to use",
            "+00001d30: 2061 2064 6563 696d 616c 2070 6f69 6e74   a decimal point",
            "+00001d40: 2c20 6f72 2074 6865 2073 6369 656e 7469  , or the scienti",
            "+00001d50: 6669 6320 6578 706f 6e65 6e74 1020 6e6f  fic exponent. no",
            "+00001d60: 7461 7469 6f6e 2027 6527 2e20 2a2f 0a20  tation 'e'. */. ",
            "+00001d70: 2020 202f 2a20 5765 2064 6f6e 2774 2070     /* We don't p",
            "+00001d80: 6963 6b20 7468 6520 6162 736f 6c75 7465  ick the absolute",
            "+00001d90: 2073 686f 7274 6573 7420 7265 7072 6573   shortest repres",
            "+00001da0: 656e 7461 7469 6f6e 2c20 6275 7420 7069  entation, but pi",
            "+00001db0: 636b 2061 2062 616c 616e 6365 2062 6574  ck a balance bet",
            "+00001dc0: 7765 656e 2072 6561 6461 6269 6c69 7479  ween readability",
            "+00001dd0: 2061 6e64 2073 686f 7274 6e65 7373 2c20   and shortness, ",
            "+00001de0: 652e 672e 202a 2f0a 2020 2020 2f2a 2031  e.g. */.    /* 1",
            "+00001df0: 2e35 3435 3035 3631 3839 3535 3736 3737  .545056189557677",
            "+00001e00: 652d 3330 3820 636f 756c 6420 6265 2072  e-308 could be r",
            "+00001e10: 6570 7265 7365 6e74 6564 2069 6e20 6120  epresented in a ",
            "+00001e20: 7368 6f72 7465 7220 666f 726d 202a 2f0a  shorter form */.",
            "+00001e30: 2020 2020 2f2a 2031 3534 3530 3536 3138      /* 154505618",
            "+00001e40: 3935 3537 3637 3765 2d33 3233 2062 7574  9557677e-323 but",
            "+00001e50: 2074 6861 7420 776f 756c 6420 6265 2073   that would be s",
            "+00001e60: 6f6d 6577 6861 7420 756e 7265 6164 6162  omewhat unreadab",
            "+00001e70: 6c65 2e20 2a2f 0a20 2020 2064 6563 696d  le. */.    decim",
            "+00001e80: 616c 7320 3d20 4752 4953 5533 5f4d 494e  als = GRISU3_MIN",
            "+00001e90: 282d 645f 6578 702c 2047 5249 5355 335f  (-d_exp, GRISU3_",
            "+00001ea0: 4d41 5828 312c 206c 656e 2d31 2929 3b0a  MAX(1, len-1));.",
            "+00001eb0: 0a20 2020 202f 2a20 6d69 6b6b 656c 666a  .    /* mikkelfj",
            "+00001ec0: 3a0a 2020 2020 202a 2066 6978 207a 6572  :.     * fix zer",
            "+00001ed0: 6f20 7072 6566 6978 202e 3120 3d3e 2030  o prefix .1 => 0",
            "+00001ee0: 2e31 2c20 696d 706f 7274 616e 7420 666f  .1, important fo",
            "+00001ef0: 7220 4a53 4f4e 2065 7870 6f72 742e 0a20  r JSON export.. ",
            "+00001f00: 2020 2020 2a20 7072 6566 6572 2075 6e73      * prefer uns",
            "+00001f10: 6369 656e 7469 6669 6320 6e6f 7461 7469  cientific notati",
            "+00001f20: 6f6e 2061 7420 7361 6d65 206c 656e 6774  on at same lengt",
            "+00001f30: 683a 0a20 2020 2020 2a20 2d31 2e32 3334  h:.     * -1.234",
            "+00001f40: 3565 2d34 206f 7665 7220 2d31 2e30 3030  5e-4 over -1.000",
            "+00001f50: 3132 3334 352c 0a20 2020 2020 2a20 2d31  12345,.     * -1",
            "+00001f60: 2e30 3031 3233 3435 206f 7665 7220 2d31  .0012345 over -1",
            "+00001f70: 2e32 3334 3565 2d33 0a20 2020 2020 2a2f  .2345e-3.     */",
            "+00001f80: 0a20 2020 2069 6620 2864 5f65 7870 203c  .    if (d_exp <",
            "+00001f90: 2030 2026 2620 286c 656e 202b 2064 5f65   0 && (len + d_e",
            "+00001fa0: 7870 2920 3e20 2d33 2026 2620 6c65 6e20  xp) > -3 && len ",
            "+00001fb0: 3c3d 202d 645f 6578 7029 0a20 2020 207b  <= -d_exp).    {",
            "+00001fc0: 0a20 2020 2020 2020 202f 2a20 6d69 6b6b  .        /* mikk",
            "+00001fd0: 656c 666a 3a20 6669 7820 7a65 726f 2070  elfj: fix zero p",
            "+00001fe0: 7265 6669 7820 2e31 203d 3e20 302e 312c  refix .1 => 0.1,",
            "+00001ff0: 2061 6e64 2073 686f 7274 2065 7870 6f6e   and short expon",
            "+00002000: 656e 7473 2031 2e33 652d 3220 3d3e 2030  ents 1.3e-2 => 0",
            "+00002010: 2e30 3133 2e20 2a2f 0a20 2020 2020 2020  .013. */.       ",
            "+00002020: 206d 656d 6d6f 7665 2873 3220 2b20 3220   memmove(s2 + 2 ",
            "+00002030: 2d20 645f 6578 7020 2d20 6c65 6e2c 2073  - d_exp - len, s",
            "+00002040: 322c 2028 7369 7a65 5f74 296c 656e 293b  2, (size_t)len);",
            "+00002050: 0a20 2020 2020 2020 2073 325b 305d 203d  .        s2[0] =",
            "+00002060: 2027 3027 3b0a 2020 2020 2020 2020 7332   '0';.        s2",
            "+00002070: 5b31 5d20 3d20 272e 273b 0a20 2020 2020  [1] = '.';.     ",
            "+00002080: 2020 2066 6f72 2028 6920 3d20 323b 2069     for (i = 2; i",
            "+00002090: 203c 2032 2d64 5f65 7870 2d6c 656e 3b20   < 2-d_exp-len; ",
            "+000020a0: 2b2b 6929 2073 325b 695d 203d 2027 3027  ++i) s2[i] = '0'",
            "+000020b0: 3b0a 2020 2020 2020 2020 6c65 6e20 2b3d  ;.        len +=",
            "+000020c0: 2069 3b0a 2020 2020 7d0a 2020 2020 656c   i;.    }.    el",
            "+000020d0: 7365 2069 6620 2864 5f65 7870 203c 2030  se if (d_exp < 0",
            "+000020e0: 2026 2620 6c65 6e20 3e20 3129 202f 2a20   && len > 1) /* ",
            "+000020f0: 4164 6420 6465 6369 6d61 6c20 706f 696e  Add decimal poin",
            "+00002100: 743f 202a 2f0a 2020 2020 7b0a 2020 2020  t? */.    {.    ",
            "+00002110: 2020 2020 666f 7228 6920 3d20 303b 2069      for(i = 0; i",
            "+00002120: 203c 2064 6563 696d 616c 733b 202b 2b69   < decimals; ++i",
            "+00002130: 2920 7332 5b6c 656e 2d69 5d20 3d20 7332  ) s2[len-i] = s2",
            "+00002140: 5b6c 656e 2d69 2d31 5d3b 0a20 2020 2020  [len-i-1];.     ",
            "+00002150: 2020 2073 325b 6c65 6e2b 2b20 2d20 6465     s2[len++ - de",
            "+00002160: 6369 6d61 6c73 5d20 3d20 272e 273b 0a20  cimals] = '.';. ",
            "+00002170: 2020 2020 2020 2064 5f65 7870 202b 3d20         d_exp += ",
            "+00002180: 6465 6369 6d61 6c73 3b0a 2020 2020 2020  decimals;.      ",
            "+00002190: 2020 2f2a 204e 6565 6420 7363 6965 6e74    /* Need scient",
            "+000021a0: 6966 6963 206e 6f74 6174 696f 6e20 6173  ific notation as",
            "+000021b0: 2077 656c 6c3f 202a 2f0a 2020 2020 2020   well? */.      ",
            "+000021c0: 2020 6966 2028 645f 6578 7020 213d 2030    if (d_exp != 0",
            "+000021d0: 2920 7b20 7332 5b6c 656e 2b2b 5d20 3d20  ) { s2[len++] = ",
            "+000021e0: 2765 273b 206c 656e 202b 3d20 6772 6973  'e'; len += gris",
            "+000021f0: 7533 5f69 5f74 6f5f 7374 7228 645f 6578  u3_i_to_str(d_ex",
            "+00002200: 702c 2073 322b 6c65 6e29 3b20 7d0a 2020  p, s2+len); }.  ",
            "+00002210: 2020 7d0a 2020 2020 2f2a 2041 6464 2073    }.    /* Add s",
            "+00002220: 6369 656e 7469 6669 6320 6e6f 7461 7469  cientific notati",
            "+00002230: 6f6e 3f20 2a2f 0a20 2020 2065 6c73 6520  on? */.    else ",
            "+00002240: 6966 2028 645f 6578 7020 3c20 3020 7c7c  if (d_exp < 0 ||",
            "+00002250: 2064 5f65 7870 203e 2032 2920 7b20 7332   d_exp > 2) { s2",
            "+00002260: 5b6c 656e 2b2b 5d20 3d20 2765 273b 206c  [len++] = 'e'; l",
            "+00002270: 656e 202b 3d20 6772 6973 7533 5f69 5f74  en += grisu3_i_t",
            "+00002280: 6f5f 7374 7228 645f 6578 702c 2073 322b  o_str(d_exp, s2+",
            "+00002290: 6c65 6e29 3b20 7d0a 2020 2020 2f2a 2041  len); }.    /* A",
            "+000022a0: 6464 207a 6572 6f65 7320 696e 7374 6561  dd zeroes instea",
            "+000022b0: 6420 6f66 2073 6369 656e 7469 6669 6320  d of scientific ",
            "+000022c0: 6e6f 7461 7469 6f6e 3f20 2a2f 0a20 2020  notation? */.   ",
            "+000022d0: 2065 6c73 6520 6966 2028 645f 6578 7020   else if (d_exp ",
            "+000022e0: 3e20 3029 207b 2077 6869 6c65 2864 5f65  > 0) { while(d_e",
            "+000022f0: 7870 2d2d 203e 2030 2920 7332 5b6c 656e  xp-- > 0) s2[len",
            "+00002300: 2b2b 5d20 3d20 2730 273b 207d 0a20 2020  ++] = '0'; }.   ",
            "+00002310: 2073 325b 6c65 6e5d 203d 2027 5c30 273b   s2[len] = '\\0';",
            "+00002320: 202f 2a20 6772 6973 7533 2064 6f65 736e   /* grisu3 doesn",
            "+00002330: 2774 206e 756c 6c20 7465 726d 696e 6174  't null terminat",
            "+00002340: 652c 2073 6f20 656e 7375 7265 2074 6572  e, so ensure ter",
            "+00002350: 6d69 6e61 7469 6f6e 2e20 2a2f 0a20 2020  mination. */.   ",
            "+00002360: 2072 6574 7572 6e20 2869 6e74 2928 7332   return (int)(s2",
            "+00002370: 2b6c 656e 2d64 7374 293b 0a7d 0a0a 2369  +len-dst);.}..#i",
            "+00002380: 6664 6566 205f 5f63 706c 7573 706c 7573  fdef __cplusplus",
            "+00002390: 0a7d 0a23 656e 6469 660a 0a23 656e 6469  .}.#endif..#endi",
            "+000023a0: 6620 2f2a 2047 5249 5355 335f 5052 494e  f /* GRISU3_PRIN",
            "+000023b0: 545f 4820 2a2f 0a                        T_H */."
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/hash/hash_table_def.h",
          "change": [
            "--- /home/flatcc-0.5.3/external/hash/hash_table_def.h",
            "+++ /home/flatcc-0.6.1/external/hash/hash_table_def.h",
            "@@ -34,15 +34,15 @@",
            " #define HT_HASH_FUNCTION ht_default_hash_function",
            " #endif",
            " ",
            " #ifndef HT_LOAD_FACTOR",
            " #define HT_LOAD_FACTOR 0.7",
            " #endif",
            " ",
            "-#define HT_LOAD_FACTOR_FRAC ((int)((float)(HT_LOAD_FACTOR)*256))",
            "+#define HT_LOAD_FACTOR_FRAC ((size_t)((float)(HT_LOAD_FACTOR)*256))",
            " ",
            " #ifndef HT_PANIC",
            " #include <stdio.h>",
            " #define HT_PANIC(s) { fprintf(stderr, \"aborting on panic: %s\\n\", s); exit(1); }",
            " #endif",
            " ",
            " #ifndef HT_MISSING"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/hash/ht_hash_function.h",
          "change": [
            "--- /home/flatcc-0.5.3/external/hash/ht_hash_function.h",
            "+++ /home/flatcc-0.6.1/external/hash/ht_hash_function.h",
            "@@ -141,32 +141,32 @@",
            " }",
            " ",
            " /* Bernsteins hash function, assumes string is zero terminated, len is ignored. */",
            " static inline size_t ht_str_hash_function(const void *key, size_t len)",
            " {",
            "     const unsigned char *str = key;",
            "     size_t hash = 5381 ^ (HT_HASH_SEED);",
            "-    int c;",
            "+    size_t c;",
            " ",
            "     (void)len;",
            " ",
            "-    while ((c = *str++))",
            "+    while ((c = (size_t)*str++))",
            "         hash = ((hash << 5) + hash) ^ c; /* (hash * 33) xor c */",
            " ",
            "     return hash;",
            " }",
            " ",
            " /* Hashes at most len characters or until zero termination. */",
            " static inline size_t ht_strn_hash_function(const void *key, size_t len)",
            " {",
            "     const unsigned char *str = key;",
            "     size_t hash = 5381 ^ (HT_HASH_SEED);",
            "-    int c;",
            "+    size_t c;",
            " ",
            "-    while (--len && (c = *str++))",
            "+    while (--len && (c = (size_t)*str++))",
            "         hash = ((hash << 5) + hash) ^ c; /* (hash * 33) xor c */",
            " ",
            "     return hash;",
            " }",
            " ",
            " static inline uint32_t ht_fnv1a32_hash_function(const void *key, size_t len)",
            " {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/lex/luthor.c",
          "change": [
            "--- /home/flatcc-0.5.3/external/lex/luthor.c",
            "+++ /home/flatcc-0.6.1/external/lex/luthor.c",
            "@@ -1363,16 +1363,17 @@",
            "                  * or as an octal. For strict C behavior, this can be",
            "                  * flagged in, but is disabled by default. It only",
            "                  * applies to single digit 0. Thus, with C octal",
            "                  * enabled, leading zeroes always go octal.",
            "                  */",
            "             } /* If condition around switch under '0' case. */",
            "             --p;",
            "-            /* Fall through. */",
            "+            goto lex_fallthrough_1; /* silence warning */",
            " ",
            "+        lex_fallthrough_1:",
            "             /* Leading integer digit in C integers. */",
            "         case '1': case '2': case '3': case '4': case '5':",
            "         case '6': case '7': case '8': case '9':",
            "             while (++p && lex_isdigit(*p)) {",
            "             }",
            "             d = p;",
            "             if (*p == '.') {",
            "@@ -1452,15 +1453,15 @@",
            "                     tag = (unsigned long)*p << 8;",
            "                     if (++p != q && lex_isalnum(*p)) {",
            "                         tag |= (unsigned long)*p << 16;",
            "                         while (++p != q && lex_isalnum(*p)) {",
            "                         }",
            "                     }",
            "                     tag |= (unsigned long)p[-1] << 24;",
            "-                    tag |= (unsigned char)(p - s) + '0';",
            "+                    tag |= (unsigned char)(p - s) + (unsigned long)'0';",
            "                     lex_emit_id(s, p, tag);",
            "                     continue;",
            "                 }",
            " ",
            "             default:",
            " ",
            " #ifdef LEX_ID_WITH_UTF8"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/external/lex/luthor.h",
          "change": [
            "--- /home/flatcc-0.5.3/external/lex/luthor.h",
            "+++ /home/flatcc-0.6.1/external/lex/luthor.h",
            "@@ -251,29 +251,30 @@",
            "         case                                                            \\",
            "             ((unsigned long)(x0) |                                      \\",
            "             ((unsigned long)(x1) << 8) |                                \\",
            "             ((unsigned long)(x2) << 16) |                               \\",
            "             ((unsigned long)(x3) << 24)) :",
            " ",
            " #define lex_kw_match(kw)                                                \\",
            "-        if (memcmp(#kw, lexeme, sizeof(#kw) - 1) == 0) return tok_kw_##kw;",
            "+        if (memcmp(#kw, lexeme, sizeof(#kw) - 1) == 0)                  \\",
            "+                return tok_kw_##kw;",
            " ",
            " #define lex_kw_end()                                                    \\",
            "         break;",
            " ",
            " #define lex_kw(kw, x0, x1, x2, x3)                                      \\",
            "         lex_kw_begin(x0, x1, x2, x3)                                    \\",
            "             lex_kw_match(kw)                                            \\",
            "         lex_kw_end()",
            " ",
            "-static unsigned long lex_match_kw(unsigned long tag, const char *lexeme);",
            "+static long lex_match_kw(unsigned long tag, const char *lexeme);",
            " ",
            " /* Static so multiple grammers are possible in a single program. */",
            " #define LEX_KW_TABLE_BEGIN                                              \\",
            "-static unsigned long lex_match_kw(unsigned long tag, const char *lexeme)\\",
            "+static long lex_match_kw(unsigned long tag, const char *lexeme)         \\",
            " {                                                                       \\",
            "     switch (tag) {                                                      \\",
            " ",
            " #define LEX_KW_TABLE_END                                                \\",
            "     default:                                                            \\",
            "         break;                                                          \\",
            "     }                                                                   \\"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc.h",
            "@@ -12,35 +12,38 @@",
            "  * interfaces except \"config.h\" used to set default options for this",
            "  * interface.",
            "  *",
            "  * This interface is unrelated to the standalone flatbuilder library",
            "  * which has a life of its own.",
            "  */",
            " ",
            "+#include <stddef.h>",
            "+",
            " #ifndef UINT8_MAX",
            " #include <stdint.h>",
            " #endif",
            " ",
            " #ifdef _MSC_VER",
            " #pragma warning(push)",
            " #pragma warning(disable: 4820) /* x bytes padding added in struct */",
            " #endif",
            " ",
            " typedef struct flatcc_options flatcc_options_t;",
            "-typedef void (*flatcc_error_fun) (void *err_ctx, const char *buf, int len);",
            "+typedef void (*flatcc_error_fun) (void *err_ctx, const char *buf, size_t len);",
            " ",
            " struct flatcc_options {",
            "     size_t max_schema_size;",
            "     int max_include_depth;",
            "     int max_include_count;",
            "     int disable_includes;",
            "     int allow_boolean_conversion;",
            "     int allow_enum_key;",
            "     int allow_enum_struct_field;",
            "     int allow_multiple_key_fields;",
            "+    int allow_primary_key;",
            "     int allow_scan_for_all_fields;",
            "     int allow_string_key;",
            "     int allow_struct_field_deprecate;",
            "     int allow_struct_field_key;",
            "     int allow_struct_root;",
            "     int ascending_enum;",
            "     int hide_later_enum;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_accessors.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_accessors.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_accessors.h",
            "@@ -6,15 +6,15 @@",
            " #endif",
            " ",
            " #ifndef UINT8_MAX",
            " #include <stdint.h>",
            " #endif",
            " ",
            " #define __flatcc_basic_scalar_accessors_impl(N, T, W, E)                    \\",
            "-static inline size_t N ## __size()                                          \\",
            "+static inline size_t N ## __size(void)                                      \\",
            " { return sizeof(T); }                                                       \\",
            " static inline T *N ## __ptr_add(T *p, size_t i)                             \\",
            " { return p + i; }                                                           \\",
            " static inline const T *N ## __const_ptr_add(const T *p, size_t i)           \\",
            " { return p + i; }                                                           \\",
            " static inline T N ## _read_from_pe(const void *p)                           \\",
            " { return N ## _cast_from_pe(*(T *)p); }                                     \\",
            "@@ -23,15 +23,18 @@",
            " static inline T N ## _read(const void *p)                                   \\",
            " { return *(T *)p; }                                                         \\",
            " static inline void N ## _write_from_pe(void *p, T v)                        \\",
            " { *(T *)p = N ## _cast_from_pe(v); }                                        \\",
            " static inline void N ## _write_to_pe(void *p, T v)                          \\",
            " { *(T *)p = N ## _cast_to_pe(v); }                                          \\",
            " static inline void N ## _write(void *p, T v)                                \\",
            "-{ *(T *)p = v; }",
            "+{ *(T *)p = v; }                                                            \\",
            "+static inline T N ## _read_from_le(const void *p)                           \\",
            "+{ return N ## _cast_from_le(*(T *)p); }                                     \\",
            "+typedef struct { int is_null; T value; } N ## _option_t;",
            " ",
            " #define __flatcc_define_integer_accessors_impl(N, T, W, E)                  \\",
            " static inline T N ## _cast_from_pe(T v)                                     \\",
            " { return (T) E ## W ## toh((uint ## W ## _t)v); }                           \\",
            " static inline T N ## _cast_to_pe(T v)                                       \\",
            " { return (T) hto ## E ## W((uint ## W ## _t)v); }                           \\",
            " static inline T N ## _cast_from_le(T v)                                     \\",
            "@@ -75,14 +78,15 @@",
            " #define __flatcc_define_basic_integer_accessors(NS, TN, T, W, E)            \\",
            " __flatcc_define_integer_accessors(NS ## TN, T, W, E)",
            " ",
            " #define __flatcc_define_basic_real_accessors(NS, TN, T, W, E)               \\",
            " __flatcc_define_real_accessors(NS ## TN, T, W, E)",
            " ",
            " #define __flatcc_define_basic_scalar_accessors(NS, E)                       \\",
            "+__flatcc_define_basic_integer_accessors(NS, char, char, 8, E)               \\",
            " __flatcc_define_basic_integer_accessors(NS, uint8, uint8_t, 8, E)           \\",
            " __flatcc_define_basic_integer_accessors(NS, uint16, uint16_t, 16, E)        \\",
            " __flatcc_define_basic_integer_accessors(NS, uint32, uint32_t, 32, E)        \\",
            " __flatcc_define_basic_integer_accessors(NS, uint64, uint64_t, 64, E)        \\",
            " __flatcc_define_basic_integer_accessors(NS, int8, int8_t, 8, E)             \\",
            " __flatcc_define_basic_integer_accessors(NS, int16, int16_t, 16, E)          \\",
            " __flatcc_define_basic_integer_accessors(NS, int32, int32_t, 32, E)          \\"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_alloc.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_alloc.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_alloc.h",
            "@@ -96,19 +96,22 @@",
            " }",
            " #define FLATCC_ALIGNED_ALLOC(alignment, size) __flatcc_aligned_alloc(alignment, size)",
            " #endif /* FLATCC_USE_GENERIC_ALIGNED_ALLOC */",
            " ",
            " #ifndef FLATCC_ALIGNED_FREE",
            " static inline void __flatcc_aligned_free(void *p)",
            " {",
            "-    char *raw = ((void **)p)[-1];",
            "+    char *raw;",
            "+",
            "+    if (!p) return;",
            "+    raw = ((void **)p)[-1];",
            " ",
            "     FLATCC_FREE(raw);",
            " }",
            "-#define FLATCC_ALIGNED(p) __flatcc_aligned_free(p)",
            "+#define FLATCC_ALIGNED_FREE(p) __flatcc_aligned_free(p)",
            " #endif",
            " ",
            " #endif /* FLATCC_USE_GENERIC_ALIGNED_ALLOC */",
            " ",
            " #ifndef FLATCC_ALIGNED_ALLOC",
            " #define FLATCC_ALIGNED_ALLOC(a, n) aligned_alloc(a, n)",
            " #endif"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_builder.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_builder.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_builder.h",
            "@@ -8,15 +8,15 @@",
            " /**",
            "  * Library for building untyped FlatBuffers. Intended as a support",
            "  * library for generated C code to produce typed builders, but might",
            "  * also be useful in runtime environments and as support for scripting",
            "  * languages.",
            "  *",
            "  * The builder has two API layers: a stack based `start/end` approach,",
            "- * and a direct `create`, and they may be fixed freely. The direct",
            "+ * and a direct `create`, and they may be mixed freely. The direct",
            "  * approach may be used as part of more specialized optimizations such",
            "  * as rewriting buffers while the stack approach is convenient for state",
            "  * machine driven parsers without a stack, or with a very simple stack",
            "  * without extra allocations.",
            "  *",
            "  * The builder emits partial buffer sequences to a user provided emitter",
            "  * function and does not require a full buffer reprensenation in memory.",
            "@@ -37,15 +37,15 @@",
            "  *",
            "  * Because an offset cannot be known before its reference location is",
            "  * defined, every completed table, vector, etc. returns a reference into",
            "  * the virtual address range. If the final buffer keeps the 0 offset,",
            "  * these references remain stable an may be used for external references",
            "  * into the buffer.",
            "  *",
            "- * The maximum buffer than can be constructed is in praxis limited to",
            "+ * The maximum buffer that can be constructed is in praxis limited to",
            "  * half the UOFFSET_MAX size, typically 2^31 bytes, not counting",
            "  * clustered vtables that may consume and additional 2^31 bytes",
            "  * (positive address range), but in praxis cannot because vtable",
            "  * references are signed and thus limited to 2^31 bytes (or equivalent",
            "  * depending on the flatbuffer types chosen).",
            "  *",
            "  * CORRECTION: in various places rules are mentioned about nesting and using",
            "@@ -67,15 +67,15 @@",
            " ",
            " #include \"flatcc_flatbuffers.h\"",
            " #include \"flatcc_emitter.h\"",
            " #include \"flatcc_refmap.h\"",
            " ",
            " /* It is possible to enable logging here. */",
            " #ifndef FLATCC_BUILDER_ASSERT",
            "-#define FLATCC_BUILDER_ASSERT(cond, reason) assert(cond)",
            "+#define FLATCC_BUILDER_ASSERT(cond, reason) FLATCC_ASSERT(cond)",
            " #endif",
            " ",
            " /*",
            "  * Eror handling is not convenient and correct use should not cause",
            "  * errors beyond possibly memory allocation, but assertions are a",
            "  * good way to trace problems.",
            "  *",
            "@@ -349,15 +349,15 @@",
            "     flatbuffers_uoffset_t ds_offset;",
            "     uint16_t align;",
            "     uint16_t type;",
            "     union {",
            "         __flatcc_builder_table_frame_t table;",
            "         __flatcc_builder_vector_frame_t vector;",
            "         __flatcc_builder_buffer_frame_t buffer;",
            "-    };",
            "+    } container;",
            " };",
            " ",
            " /**",
            "  * The main flatcc_builder structure. Can be stack allocated and must",
            "  * be initialized with `flatcc_builder_init` and cleared with",
            "  * `flatcc_builder_clear` to reclaim memory. Between buffer builds,",
            "  * `flatcc_builder_reset` may be used.",
            "@@ -1869,14 +1869,28 @@",
            " /*",
            "  * A stable implementation of `aligned_free` that is not sensitive",
            "  * to the applications compile time flags.",
            "  */",
            " void flatcc_builder_aligned_free(void *p);",
            " ",
            " /*",
            "+ * Same allocation as `flatcc_builder_finalize_buffer` returnes. Usually",
            "+ * same as `malloc` but can redefined via macros.",
            "+ */",
            "+void *flatcc_builder_alloc(size_t size);",
            "+",
            "+/*",
            "+ * A stable implementation of `free` when the default allocation",
            "+ * methods have been redefined.",
            "+ *",
            "+ * Deallocates memory returned from `flatcc_builder_finalize_buffer`.",
            "+ */",
            "+void flatcc_builder_free(void *p);",
            "+",
            "+/*",
            "  * Only for use with the default emitter.",
            "  *",
            "  * Convenience method to copy buffer from default emitter. Forwards",
            "  * call to default emitter and returns input pointer, or null if",
            "  * the emitter is not default or of the given size is smaller than",
            "  * the buffer size.",
            "  *"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_emitter.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_emitter.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_emitter.h",
            "@@ -43,15 +43,15 @@",
            "  * implemention - it might be used for network transmission.  The buffer",
            "  * is not explicitly designed for multithreaded access but any page",
            "  * strictly between front and back is not touched unless recycled and in",
            "  * this case aligned allocation is useful to prevent cache line sharing.",
            "  */",
            " ",
            " /*",
            "- * Memory is allocated in fixed size page units - the first page is",
            "+ * Memory is allocated in fixed length page units - the first page is",
            "  * split between front and back so each get half the page size. If the",
            "  * size is a multiple of 128 then each page offset will be a multiple of",
            "  * 64, which may be useful for sequencing etc.",
            "  */",
            " #ifndef FLATCC_EMITTER_PAGE_SIZE",
            " #define FLATCC_EMITTER_MAX_PAGE_SIZE 3000",
            " #define FLATCC_EMITTER_PAGE_MULTIPLE 64",
            "@@ -128,15 +128,15 @@",
            "  */",
            " void flatcc_emitter_reset(flatcc_emitter_t *E);",
            " ",
            " /*",
            "  * Helper function that allows a page between front and back to be",
            "  * recycled while the buffer is still being constructed - most likely as part",
            "  * of partial copy or transmission. Attempting to recycle front or back",
            "- * pages will result will result in an error. Recycling pages outside the",
            "+ * pages will result in an error. Recycling pages outside the",
            "  * front and back will be valid but pointless. After recycling and copy",
            "  * operations are no longer well-defined and should be replaced with",
            "  * whatever logic is recycling the pages.  The reset operation",
            "  * automatically recycles all (remaining) pages when emission is",
            "  * complete. After recycling, the `flatcc_emitter_size` function will",
            "  * return as if recycle was not called, but will only represent the",
            "  * logical size, not the size of the active buffer. Because a recycled"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_flatbuffers.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_flatbuffers.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_flatbuffers.h",
            "@@ -19,15 +19,19 @@",
            " #ifdef FLATCC_PORTABLE",
            " #include \"flatcc/flatcc_portable.h\"",
            " #endif",
            " #include \"flatcc/portable/pwarnings.h\"",
            " /* Needed by C99 compilers without FLATCC_PORTABLE. */",
            " #include \"flatcc/portable/pstdalign.h\"",
            " ",
            "+/* Handle fallthrough attribute in switch statements. */",
            "+#include \"flatcc/portable/pattributes.h\"",
            "+",
            " #include \"flatcc/flatcc_alloc.h\"",
            "+#include \"flatcc/flatcc_assert.h\"",
            " ",
            " #define __FLATBUFFERS_PASTE2(a, b) a ## b",
            " #define __FLATBUFFERS_PASTE3(a, b, c) a ## b ## c",
            " #define __FLATBUFFERS_CONCAT(a, b) __FLATBUFFERS_PASTE2(a, b)",
            " ",
            " /*",
            "  * \"flatcc_endian.h\" requires the preceeding include files,"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_identifier.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_identifier.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_identifier.h",
            "@@ -5,14 +5,18 @@",
            " extern \"C\" {",
            " #endif",
            " ",
            " #ifndef FLATCC_FLATBUFFERS_H",
            " #error \"include via flatcc/flatcc_flatbuffers.h\"",
            " #endif",
            " ",
            "+#ifndef UINT8_MAX",
            "+#include <stdint.h>",
            "+#endif",
            "+",
            " /*",
            "  * FlatBuffers identifiers are normally specified by \"file_identifer\" in",
            "  * the schema, but a standard hash of the fully qualified type name can",
            "  * also be used. This file implements such a mapping, but the generated",
            "  * headers also contain the necessary information for known types.",
            "  */",
            " ",
            "@@ -36,40 +40,40 @@",
            "  * This assumes 32 bit hash type. For other sizes, other FNV-1a",
            "  * constants would be required.",
            "  *",
            "  * Note that we reserve hash value 0 for missing or ignored value.",
            "  */",
            " static inline flatbuffers_thash_t flatbuffers_type_hash_from_name(const char *name)",
            " {",
            "-    uint32_t hash = 2166136261UL;",
            "+    uint32_t hash = UINT32_C(2166136261);",
            "     while (*name) {",
            "-        hash ^= (uint32_t)*name;",
            "-        hash = hash * 16777619UL;",
            "+        hash ^= (unsigned char)*name;",
            "+        hash = hash * UINT32_C(16777619);",
            "         ++name;",
            "     }",
            "     if (hash == 0) {",
            "-        hash = 2166136261UL;",
            "+        hash = UINT32_C(2166136261);",
            "     }",
            "     return hash;",
            " }",
            " ",
            " /*",
            "  * Type hash encoded as little endian file identifier string.",
            "  * Note: if type hash is 0, the identifier should be null which",
            "  * we cannot return in this interface.",
            "  */",
            " static inline void flatbuffers_identifier_from_type_hash(flatbuffers_thash_t type_hash, flatbuffers_fid_t out_identifier)",
            " {",
            "-    out_identifier[0] = type_hash & 0xff;",
            "+    out_identifier[0] = (char)(type_hash & 0xff);",
            "     type_hash >>= 8;",
            "-    out_identifier[1] = type_hash & 0xff;",
            "+    out_identifier[1] = (char)(type_hash & 0xff);",
            "     type_hash >>= 8;",
            "-    out_identifier[2] = type_hash & 0xff;",
            "+    out_identifier[2] = (char)(type_hash & 0xff);",
            "     type_hash >>= 8;",
            "-    out_identifier[3] = type_hash & 0xff;",
            "+    out_identifier[3] = (char)(type_hash & 0xff);",
            " }",
            " ",
            " /* Native integer encoding of file identifier. */",
            " static inline flatbuffers_thash_t flatbuffers_type_hash_from_identifier(const flatbuffers_fid_t identifier)",
            " {",
            "     uint8_t *p = (uint8_t *)identifier;",
            " ",
            "@@ -122,16 +126,16 @@",
            "  * unmodified type hash has the benefit that it can seed a child namespace.",
            "  */",
            " static inline uint32_t flatbuffers_disperse_type_hash(flatbuffers_thash_t type_hash)",
            " {",
            "     /* http://stackoverflow.com/a/12996028 */",
            "     uint32_t x = type_hash;",
            " ",
            "-    x = ((x >> 16) ^ x) * 0x45d9f3bUL;",
            "-    x = ((x >> 16) ^ x) * 0x45d9f3bUL;",
            "+    x = ((x >> 16) ^ x) * UINT32_C(0x45d9f3b);",
            "+    x = ((x >> 16) ^ x) * UINT32_C(0x45d9f3b);",
            "     x = ((x >> 16) ^ x);",
            "     return x;",
            " }",
            " ",
            " ",
            " /* We have hardcoded assumptions about identifier size. */",
            " static_assert(sizeof(flatbuffers_fid_t) == 4, \"unexpected file identifier size\");"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_json_parser.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_json_parser.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_json_parser.h",
            "@@ -10,27 +10,28 @@",
            "  * http://www.ietf.org/rfc/rfc4627.txt?number=4627",
            "  *",
            "  * With several flatbuffers specific extensions.",
            "  */",
            " ",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include <assert.h>",
            " ",
            " #include \"flatcc/flatcc_rtconfig.h\"",
            " #include \"flatcc/flatcc_builder.h\"",
            " #include \"flatcc/flatcc_unaligned.h\"",
            " ",
            " #define PDIAGNOSTIC_IGNORE_UNUSED",
            " #include \"flatcc/portable/pdiagnostic_push.h\"",
            " ",
            " enum flatcc_json_parser_flags {",
            "     flatcc_json_parser_f_skip_unknown = 1,",
            "     flatcc_json_parser_f_force_add = 2,",
            "     flatcc_json_parser_f_with_size = 4,",
            "+    flatcc_json_parser_f_skip_array_overflow = 8,",
            "+    flatcc_json_parser_f_reject_array_underflow = 16",
            " };",
            " ",
            " #define FLATCC_JSON_PARSE_ERROR_MAP(XX)                                     \\",
            "     XX(ok,                      \"ok\")                                       \\",
            "     XX(eof,                     \"eof\")                                      \\",
            "     XX(deep_nesting,            \"deep nesting\")                             \\",
            "     XX(trailing_comma,          \"trailing comma\")                           \\",
            "@@ -59,14 +60,16 @@",
            "     XX(union_none_not_null,     \"union of type NONE is not null\")           \\",
            "     XX(union_incomplete,        \"table has incomplete union\")               \\",
            "     XX(duplicate,               \"table has duplicate field\")                \\",
            "     XX(required,                \"required field missing\")                   \\",
            "     XX(union_vector_length,     \"union vector length mismatch\")             \\",
            "     XX(base64,                  \"invalid base64 content\")                   \\",
            "     XX(base64url,               \"invalid base64url content\")                \\",
            "+    XX(array_underflow,         \"fixed length array underflow\")               \\",
            "+    XX(array_overflow,          \"fixed length array overflow\")                \\",
            "     XX(runtime,                 \"runtime error\")                            \\",
            "     XX(not_supported,           \"not supported\")",
            " ",
            " enum flatcc_json_parser_error_no {",
            " #define XX(no, str) flatcc_json_parser_error_##no,",
            "     FLATCC_JSON_PARSE_ERROR_MAP(XX)",
            " #undef XX",
            "@@ -157,31 +160,43 @@",
            "     if (buf == end || *buf != '\\\"') {",
            "         return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_unterminated_string);",
            "     }",
            "     return ++buf;",
            " }",
            " ",
            " /*",
            "+ * Parse a string as a fixed length char array as `s` with length `n`.",
            "+ * and raise errors according to overflow/underflow runtime flags. Zero",
            "+ * and truncate as needed. A trailing zero is not inserted if the input",
            "+ * is at least the same length as the char array.",
            "+ * ",
            "+ * Runtime flags: `skip_array_overflow`, `pad_array_underflow`.",
            "+ */",
            "+const char *flatcc_json_parser_char_array(flatcc_json_parser_t *ctx,",
            "+        const char *buf, const char *end, char *s, size_t n);",
            "+",
            "+/*",
            "  * Creates a string. Returns *ref == 0 on unrecoverable error or",
            "  * sets *ref to a valid new string reference.",
            "  */",
            " const char *flatcc_json_parser_build_string(flatcc_json_parser_t *ctx,",
            "         const char *buf, const char *end, flatcc_builder_ref_t *ref);",
            " ",
            "-typedef char flatcc_json_parser_escape_buffer_t[4];",
            "+typedef char flatcc_json_parser_escape_buffer_t[5];",
            " /*",
            "  * If the buffer does not hold a valid escape sequence, an error is",
            "  * returned with code[0] = 0/",
            "  *",
            "- * Otherwise code[0] the length (1-3) of the remaining",
            "- * characters in the code, transcoded from the escape sequence.",
            "+ * Otherwise code[0] the length (1-4) of the remaining",
            "+ * characters in the code, transcoded from the escape sequence",
            "+ * where a length of 4 only happens with escapaped surrogate pairs.",
            "  *",
            "  * The JSON extension `\\xXX` is supported and may produced invalid UTF-8",
            "  * characters such as 0xff. The standard JSON escape `\\uXXXX` is not",
            "- * checked for invalid code points and may produce invlalid UTF-8.",
            "+ * checked for invalid code points and may produce invalid UTF-8.",
            "  *",
            "  * Regular characters are expected to valid UTF-8 but they are not checked",
            "  * and may therefore produce invalid UTF-8.",
            "  *",
            "  * Control characters within a string are rejected except in the",
            "  * standard JSON escpaped form for `\\n \\r \\t \\b \\f`.",
            "  *",
            "@@ -217,39 +232,39 @@",
            "     }",
            "     return buf;",
            " }",
            " ",
            " static inline uint64_t flatcc_json_parser_symbol_part_ext(const char *buf, const char *end)",
            " {",
            "     uint64_t w = 0;",
            "-    size_t n = end - buf;",
            "+    size_t n = (size_t)(end - buf);",
            " ",
            "     if (n > 8) {",
            "         n = 8;",
            "     }",
            "     /* This can bloat inlining for a rarely executed case. */",
            " #if 1",
            "     /* Fall through comments needed to silence gcc 7 warnings. */",
            "     switch (n) {",
            "     case 8: w |= ((uint64_t)buf[7]) << (0 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 7: w |= ((uint64_t)buf[6]) << (1 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 6: w |= ((uint64_t)buf[5]) << (2 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 5: w |= ((uint64_t)buf[4]) << (3 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 4: w |= ((uint64_t)buf[3]) << (4 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 3: w |= ((uint64_t)buf[2]) << (5 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 2: w |= ((uint64_t)buf[1]) << (6 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 1: w |= ((uint64_t)buf[0]) << (7 * 8);",
            "-        /* Fall through */",
            "+        fallthrough;",
            "     case 0:",
            "         break;",
            "     }",
            " #else",
            "     /* But this is hardly much of an improvement. */",
            "     {",
            "         size_t i;",
            "@@ -273,15 +288,15 @@",
            "  * was called - i.e. the returned buffer is tentative for use only if we",
            "  * accept the part returned here.",
            "  *",
            "  * Used for both symbols and symbolic constants.",
            "  */",
            " static inline uint64_t flatcc_json_parser_symbol_part(const char *buf, const char *end)",
            " {",
            "-    size_t n = end - buf;",
            "+    size_t n = (size_t)(end - buf);",
            " ",
            " #if FLATCC_ALLOW_UNALIGNED_ACCESS",
            "     if (n >= 8) {",
            "         return be64toh(*(uint64_t *)buf);",
            "     }",
            " #endif",
            "     return flatcc_json_parser_symbol_part_ext(buf, end);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_json_printer.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_json_printer.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_json_printer.h",
            "@@ -45,15 +45,15 @@",
            "     /*                                                                      \\",
            "      * When the flatbuffer is null, has too small a header, or has          \\",
            "      * mismatching identifier when a match was requested.                   \\",
            "      */                                                                     \\",
            "     XX(bad_input,               \"bad input\")                                \\",
            "     XX(deep_recursion,          \"deep recursion\")                           \\",
            "     /*                                                                      \\",
            "-     * When the output was larger than the available fixed size buffer,     \\",
            "+     * When the output was larger than the available fixed length buffer,     \\",
            "      * or dynamic allocation could not grow the buffer sufficiently.        \\",
            "      */                                                                     \\",
            "     XX(overflow,                \"overflow\")",
            " ",
            " enum flatcc_json_printer_error_no {",
            " #define XX(no, str) flatcc_json_printer_error_##no,",
            "     FLATCC_JSON_PRINT_ERROR_MAP(XX)",
            "@@ -115,15 +115,15 @@",
            "     ctx->total = 0;",
            "     ctx->error = 0;",
            " }",
            " ",
            " /*",
            "  * A custom init function can be implemented with a custom flush",
            "  * function can be custom implemented. A few have been provided:",
            "- * init with external fixed size buffer, and init with dynamically",
            "+ * init with external fixed length buffer, and init with dynamically",
            "  * growing buffer.",
            "  *",
            "  * Because there are a lot of small print functions, it is essentially",
            "  * always faster to print to local buffer than moving to io directly",
            "  * such as using fprintf or fwrite. The flush callback is used to",
            "  * move data when enough has been collected.",
            "  *",
            "@@ -161,15 +161,15 @@",
            "  */",
            " int flatcc_json_printer_init_buffer(flatcc_json_printer_t *ctx, char *buffer, size_t buffer_size);",
            " ",
            " /*",
            "  * Returns the current buffer pointer and also the content size in",
            "  * `buffer_size` if it is null. The operation is not very useful for",
            "  * file oriented printers (created with `init`) and will then only",
            "- * return the unflushed buffer content. For fixed size buffers",
            "+ * return the unflushed buffer content. For fixed length buffers",
            "  * (`init_buffer`), only the last content is available if the buffer",
            "  * overflowed. Works well with (`init_buffer`) when the dynamic buffer",
            "  * is be reused, otherwise `finalize_dynamic_buffer` could be more",
            "  * appropriate.",
            "  *",
            "  * The returned buffer is zero terminated.",
            "  *",
            "@@ -320,15 +320,15 @@",
            "         ctx->flush(ctx, 0);",
            "     }",
            " }",
            " ",
            " /* Returns the total printed size but flushed and in buffer. */",
            " static inline size_t flatcc_json_printer_total(flatcc_json_printer_t *ctx)",
            " {",
            "-    return (size_t)(ctx->total + (ctx->p - ctx->buf));",
            "+    return ctx->total + (size_t)(ctx->p - ctx->buf);",
            " }",
            " ",
            " /*",
            "  * Flush the remaining data not flushed by partial flush. It is valid to",
            "  * call at any point if it is acceptable to have unaligned flush units,",
            "  * but this is not desireable if, for example, compression or encryption",
            "  * is added to the flush pipeline.",
            "@@ -356,17 +356,17 @@",
            "  *",
            "  * When pretty printing (indent > 0), level 0 has special significance -",
            "  * so if wrapping printed json in a manually printed container json",
            "  * object, these functions can help manage this.",
            "  */",
            " ",
            " /* Escaped and quoted string. */",
            "-void flatcc_json_printer_string(flatcc_json_printer_t *ctx, const char *s, int n);",
            "+void flatcc_json_printer_string(flatcc_json_printer_t *ctx, const char *s, size_t n);",
            " /* Unescaped and unquoted string. */",
            "-void flatcc_json_printer_write(flatcc_json_printer_t *ctx, const char *s, int n);",
            "+void flatcc_json_printer_write(flatcc_json_printer_t *ctx, const char *s, size_t n);",
            " /* Print a newline and issues a partial flush. */",
            " void flatcc_json_printer_nl(flatcc_json_printer_t *ctx);",
            " /* Like numbers, a partial flush is not issued. */",
            " void flatcc_json_printer_char(flatcc_json_printer_t *ctx, char c);",
            " /* Indents and issues a partial flush. */",
            " void flatcc_json_printer_indent(flatcc_json_printer_t *ctx);",
            " /* Adjust identation level, usually +/-1. */",
            "@@ -387,15 +387,15 @@",
            " void flatcc_json_printer_int32(flatcc_json_printer_t *ctx, int32_t v);",
            " void flatcc_json_printer_int64(flatcc_json_printer_t *ctx, int64_t v);",
            " void flatcc_json_printer_bool(flatcc_json_printer_t *ctx, int v);",
            " void flatcc_json_printer_float(flatcc_json_printer_t *ctx, float v);",
            " void flatcc_json_printer_double(flatcc_json_printer_t *ctx, double v);",
            " ",
            " void flatcc_json_printer_enum(flatcc_json_printer_t *ctx,",
            "-        const char *symbol, int len);",
            "+        const char *symbol, size_t len);",
            " ",
            " /*",
            "  * Convenience function to add a trailing newline, flush the buffer,",
            "  * test for error and reset the context for reuse.",
            "  *",
            "  * Returns total size printed or < 0 on error.",
            "  *",
            "@@ -489,44 +489,70 @@",
            " typedef void flatcc_json_printer_int32_enum_f(flatcc_json_printer_t *ctx, int32_t v);",
            " typedef void flatcc_json_printer_int64_enum_f(flatcc_json_printer_t *ctx, int64_t v);",
            " typedef void flatcc_json_printer_bool_enum_f(flatcc_json_printer_t *ctx, flatbuffers_bool_t v);",
            " ",
            " #define __define_print_scalar_field_proto(TN, T)                            \\",
            " void flatcc_json_printer_ ## TN ## _field(flatcc_json_printer_t *ctx,       \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len, T v);",
            "+        int id, const char *name, size_t len, T v);",
            "+",
            "+#define __define_print_scalar_optional_field_proto(TN, T)                   \\",
            "+void flatcc_json_printer_ ## TN ## _optional_field(                         \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        flatcc_json_printer_table_descriptor_t *td,                         \\",
            "+        int id, const char *name, size_t len);",
            " ",
            " #define __define_print_scalar_struct_field_proto(TN, T)                     \\",
            " void flatcc_json_printer_ ## TN ## _struct_field(flatcc_json_printer_t *ctx,\\",
            "         int index, const void *p, size_t offset,                            \\",
            "-        const char *name, int len);",
            "+        const char *name, size_t len);",
            "+",
            "+#define __define_print_scalar_array_struct_field_proto(TN, T)               \\",
            "+void flatcc_json_printer_ ## TN ## _array_struct_field(                     \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        int index, const void *p, size_t offset,                            \\",
            "+        const char *name, size_t len, size_t count);",
            "+",
            "+#define __define_print_enum_array_struct_field_proto(TN, T)                 \\",
            "+void flatcc_json_printer_ ## TN ## _enum_array_struct_field(                \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        int index, const void *p, size_t offset,                            \\",
            "+        const char *name, size_t len, size_t count,                         \\",
            "+        flatcc_json_printer_ ## TN ##_enum_f *pf);",
            " ",
            " #define __define_print_enum_struct_field_proto(TN, T)                       \\",
            " void flatcc_json_printer_ ## TN ## _enum_struct_field(                      \\",
            "         flatcc_json_printer_t *ctx,                                         \\",
            "         int index, const void *p, size_t offset,                            \\",
            "-        const char *name, int len,                                          \\",
            "+        const char *name, size_t len,                                       \\",
            "         flatcc_json_printer_ ## TN ##_enum_f *pf);",
            " ",
            " #define __define_print_enum_field_proto(TN, T)                              \\",
            " void flatcc_json_printer_ ## TN ## _enum_field(flatcc_json_printer_t *ctx,  \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len, T v,                             \\",
            "+        int id, const char *name, size_t len, T v,                          \\",
            "+        flatcc_json_printer_ ## TN ##_enum_f *pf);",
            "+",
            "+#define __define_print_enum_optional_field_proto(TN, T)                     \\",
            "+void flatcc_json_printer_ ## TN ## _enum_optional_field(                    \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        flatcc_json_printer_table_descriptor_t *td,                         \\",
            "+        int id, const char *name, size_t len,                               \\",
            "         flatcc_json_printer_ ## TN ##_enum_f *pf);",
            " ",
            " #define __define_print_scalar_vector_field_proto(TN, T)                     \\",
            " void flatcc_json_printer_ ## TN ## _vector_field(flatcc_json_printer_t *ctx,\\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len);",
            "+        int id, const char *name, size_t len);",
            " ",
            " #define __define_print_enum_vector_field_proto(TN, T)                       \\",
            " void flatcc_json_printer_ ## TN ## _enum_vector_field(                      \\",
            "         flatcc_json_printer_t *ctx,                                         \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len,                                  \\",
            "+        int id, const char *name, size_t len,                               \\",
            "         flatcc_json_printer_ ## TN ##_enum_f *pf);",
            " ",
            " __define_print_scalar_field_proto(uint8, uint8_t)",
            " __define_print_scalar_field_proto(uint16, uint16_t)",
            " __define_print_scalar_field_proto(uint32, uint32_t)",
            " __define_print_scalar_field_proto(uint64, uint64_t)",
            " __define_print_scalar_field_proto(int8, int8_t)",
            "@@ -543,26 +569,76 @@",
            " __define_print_enum_field_proto(uint64, uint64_t)",
            " __define_print_enum_field_proto(int8, int8_t)",
            " __define_print_enum_field_proto(int16, int16_t)",
            " __define_print_enum_field_proto(int32, int32_t)",
            " __define_print_enum_field_proto(int64, int64_t)",
            " __define_print_enum_field_proto(bool, flatbuffers_bool_t)",
            " ",
            "+__define_print_scalar_optional_field_proto(uint8, uint8_t)",
            "+__define_print_scalar_optional_field_proto(uint16, uint16_t)",
            "+__define_print_scalar_optional_field_proto(uint32, uint32_t)",
            "+__define_print_scalar_optional_field_proto(uint64, uint64_t)",
            "+__define_print_scalar_optional_field_proto(int8, int8_t)",
            "+__define_print_scalar_optional_field_proto(int16, int16_t)",
            "+__define_print_scalar_optional_field_proto(int32, int32_t)",
            "+__define_print_scalar_optional_field_proto(int64, int64_t)",
            "+__define_print_scalar_optional_field_proto(bool, flatbuffers_bool_t)",
            "+__define_print_scalar_optional_field_proto(float, float)",
            "+__define_print_scalar_optional_field_proto(double, double)",
            "+",
            "+__define_print_enum_optional_field_proto(uint8, uint8_t)",
            "+__define_print_enum_optional_field_proto(uint16, uint16_t)",
            "+__define_print_enum_optional_field_proto(uint32, uint32_t)",
            "+__define_print_enum_optional_field_proto(uint64, uint64_t)",
            "+__define_print_enum_optional_field_proto(int8, int8_t)",
            "+__define_print_enum_optional_field_proto(int16, int16_t)",
            "+__define_print_enum_optional_field_proto(int32, int32_t)",
            "+__define_print_enum_optional_field_proto(int64, int64_t)",
            "+__define_print_enum_optional_field_proto(bool, flatbuffers_bool_t)",
            "+",
            " __define_print_scalar_struct_field_proto(uint8, uint8_t)",
            " __define_print_scalar_struct_field_proto(uint16, uint16_t)",
            " __define_print_scalar_struct_field_proto(uint32, uint32_t)",
            " __define_print_scalar_struct_field_proto(uint64, uint64_t)",
            " __define_print_scalar_struct_field_proto(int8, int8_t)",
            " __define_print_scalar_struct_field_proto(int16, int16_t)",
            " __define_print_scalar_struct_field_proto(int32, int32_t)",
            " __define_print_scalar_struct_field_proto(int64, int64_t)",
            " __define_print_scalar_struct_field_proto(bool, flatbuffers_bool_t)",
            " __define_print_scalar_struct_field_proto(float, float)",
            " __define_print_scalar_struct_field_proto(double, double)",
            " ",
            "+/*",
            "+ * char arrays are special as there are no char fields",
            "+ * without arrays and because they are printed as strings.",
            "+ */",
            "+__define_print_scalar_array_struct_field_proto(char, char)",
            "+",
            "+__define_print_scalar_array_struct_field_proto(uint8, uint8_t)",
            "+__define_print_scalar_array_struct_field_proto(uint16, uint16_t)",
            "+__define_print_scalar_array_struct_field_proto(uint32, uint32_t)",
            "+__define_print_scalar_array_struct_field_proto(uint64, uint64_t)",
            "+__define_print_scalar_array_struct_field_proto(int8, int8_t)",
            "+__define_print_scalar_array_struct_field_proto(int16, int16_t)",
            "+__define_print_scalar_array_struct_field_proto(int32, int32_t)",
            "+__define_print_scalar_array_struct_field_proto(int64, int64_t)",
            "+__define_print_scalar_array_struct_field_proto(bool, flatbuffers_bool_t)",
            "+__define_print_scalar_array_struct_field_proto(float, float)",
            "+__define_print_scalar_array_struct_field_proto(double, double)",
            "+",
            "+__define_print_enum_array_struct_field_proto(uint8, uint8_t)",
            "+__define_print_enum_array_struct_field_proto(uint16, uint16_t)",
            "+__define_print_enum_array_struct_field_proto(uint32, uint32_t)",
            "+__define_print_enum_array_struct_field_proto(uint64, uint64_t)",
            "+__define_print_enum_array_struct_field_proto(int8, int8_t)",
            "+__define_print_enum_array_struct_field_proto(int16, int16_t)",
            "+__define_print_enum_array_struct_field_proto(int32, int32_t)",
            "+__define_print_enum_array_struct_field_proto(int64, int64_t)",
            "+__define_print_enum_array_struct_field_proto(bool, flatbuffers_bool_t)",
            "+",
            " __define_print_enum_struct_field_proto(uint8, uint8_t)",
            " __define_print_enum_struct_field_proto(uint16, uint16_t)",
            " __define_print_enum_struct_field_proto(uint32, uint32_t)",
            " __define_print_enum_struct_field_proto(uint64, uint64_t)",
            " __define_print_enum_struct_field_proto(int8, int8_t)",
            " __define_print_enum_struct_field_proto(int16, int16_t)",
            " __define_print_enum_struct_field_proto(int32, int32_t)",
            "@@ -589,15 +665,15 @@",
            " __define_print_enum_vector_field_proto(int16, int16_t)",
            " __define_print_enum_vector_field_proto(int32, int32_t)",
            " __define_print_enum_vector_field_proto(int64, int64_t)",
            " __define_print_enum_vector_field_proto(bool, flatbuffers_bool_t)",
            " ",
            " void flatcc_json_printer_uint8_vector_base64_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len, int urlsafe);",
            "+        int id, const char *name, size_t len, int urlsafe);",
            " ",
            " /*",
            "  * If `fid` is null, the identifier is not checked and is allowed to be",
            "  * entirely absent.",
            "  *",
            "  * The buffer must at least be aligned to uoffset_t on systems that",
            "  * require aligned memory addresses (as always for flatbuffers).",
            "@@ -624,72 +700,78 @@",
            "  * This bit twiddling hack may be useful:",
            "  *",
            "  *     `multiple = 0 != (v & (v - 1);`",
            "  */",
            " void flatcc_json_printer_delimit_enum_flags(flatcc_json_printer_t *ctx, int multiple);",
            " ",
            " /* The index increments from 0 to handle space. It is not the flag bit position. */",
            "-void flatcc_json_printer_enum_flag(flatcc_json_printer_t *ctx, int index, const char *symbol, int len);",
            "+void flatcc_json_printer_enum_flag(flatcc_json_printer_t *ctx, int index, const char *symbol, size_t len);",
            " ",
            " /* A struct inside another struct, as opposed to inside a table or a root. */",
            " void flatcc_json_printer_embedded_struct_field(flatcc_json_printer_t *ctx,",
            "         int index, const void *p, size_t offset,",
            "-        const char *name, int len,",
            "+        const char *name, size_t len,",
            "+        flatcc_json_printer_struct_f pf);",
            "+",
            "+void flatcc_json_printer_embedded_struct_array_field(flatcc_json_printer_t *ctx,",
            "+        int index, const void *p, size_t offset,",
            "+        const char *name, size_t len,",
            "+        size_t size, size_t count,",
            "         flatcc_json_printer_struct_f pf);",
            " ",
            " void flatcc_json_printer_struct_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_struct_f *pf);",
            " ",
            " void flatcc_json_printer_string_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len);",
            "+        int id, const char *name, size_t len);",
            " ",
            " void flatcc_json_printer_string_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len);",
            "+        int id, const char *name, size_t len);",
            " ",
            " void flatcc_json_printer_table_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_table_f pf);",
            " ",
            " void flatcc_json_printer_struct_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         size_t size,",
            "         flatcc_json_printer_struct_f pf);",
            " ",
            " void flatcc_json_printer_table_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_table_f pf);",
            " ",
            " void flatcc_json_printer_union_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_union_type_f ptf,",
            "         flatcc_json_printer_union_f pf);",
            " ",
            " void flatcc_json_printer_struct_as_nested_root(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         const char *fid,",
            "         flatcc_json_printer_struct_f *pf);",
            " ",
            " void flatcc_json_printer_table_as_nested_root(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         const char *fid,",
            "         flatcc_json_printer_table_f pf);",
            " ",
            " void flatcc_json_printer_union_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_union_type_f ptf,",
            "         flatcc_json_printer_union_f pf);",
            " ",
            " void flatcc_json_printer_union_table(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_union_descriptor_t *ud,",
            "         flatcc_json_printer_table_f pf);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/flatcc_version.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/flatcc_version.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/flatcc_version.h",
            "@@ -1,14 +1,14 @@",
            " #ifdef __cplusplus",
            " extern \"C\" {",
            " #endif",
            " ",
            "-#define FLATCC_VERSION_TEXT \"0.5.3\"",
            "+#define FLATCC_VERSION_TEXT \"0.6.1\"",
            " #define FLATCC_VERSION_MAJOR 0",
            "-#define FLATCC_VERSION_MINOR 5",
            "-#define FLATCC_VERSION_PATCH 3",
            "+#define FLATCC_VERSION_MINOR 6",
            "+#define FLATCC_VERSION_PATCH 1",
            " /* 1 or 0 */",
            " #define FLATCC_VERSION_RELEASED 1",
            " ",
            " #ifdef __cplusplus",
            " }",
            " #endif"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/grisu3_math.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/grisu3_math.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/grisu3_math.h",
            "@@ -59,15 +59,24 @@",
            " extern \"C\" {",
            " #endif",
            " ",
            " /* Guarded to allow inclusion of pstdint.h first, if stdint.h is not supported. */",
            " #ifndef UINT8_MAX",
            " #include <stdint.h> /* uint64_t etc. */",
            " #endif",
            "+",
            "+#ifdef GRISU3_NO_ASSERT",
            "+#undef GRISU3_ASSERT",
            "+#define GRISU3_ASSERT(x) ((void)0)",
            "+#endif",
            "+",
            "+#ifndef GRISU3_ASSERT",
            " #include <assert.h> /* assert */",
            "+#define GRISU3_ASSERT(x) assert(x)",
            "+#endif",
            " ",
            " #ifdef _MSC_VER",
            " #pragma warning(disable : 4204) /* nonstandard extension used : non-constant aggregate initializer */",
            " #endif",
            " ",
            " #define GRISU3_D64_SIGN             0x8000000000000000ULL",
            " #define GRISU3_D64_EXP_MASK         0x7FF0000000000000ULL",
            "@@ -232,15 +241,15 @@",
            "     p->e = grisu3_diy_fp_pow_cache[i].b_exp;",
            "     return grisu3_diy_fp_pow_cache[i].d_exp;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_diy_fp_minus(grisu3_diy_fp_t x, grisu3_diy_fp_t y)",
            " {",
            "     grisu3_diy_fp_t d; d.f = x.f - y.f; d.e = x.e;",
            "-    assert(x.e == y.e && x.f >= y.f);",
            "+    GRISU3_ASSERT(x.e == y.e && x.f >= y.f);",
            "     return d;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_diy_fp_multiply(grisu3_diy_fp_t x, grisu3_diy_fp_t y)",
            " {",
            "     uint64_t a, b, c, d, ac, bc, ad, bd, tmp;",
            "     grisu3_diy_fp_t r;",
            "@@ -253,15 +262,15 @@",
            "     r.f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);",
            "     r.e = x.e + y.e + 64;",
            "     return r;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_diy_fp_normalize(grisu3_diy_fp_t n)",
            " {",
            "-    assert(n.f != 0);",
            "+    GRISU3_ASSERT(n.f != 0);",
            "     while(!(n.f & 0xFFC0000000000000ULL)) { n.f <<= 10; n.e -= 10; }",
            "     while(!(n.f & GRISU3_D64_SIGN)) { n.f <<= 1; --n.e; }",
            "     return n;",
            " }",
            " ",
            " static grisu3_diy_fp_t grisu3_cast_diy_fp_from_double(double d)",
            " {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/grisu3_parse.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/grisu3_parse.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/grisu3_parse.h",
            "@@ -31,15 +31,14 @@",
            " #endif",
            " ",
            " #ifndef UINT8_MAX",
            " #include <stdint.h>",
            " #endif",
            " ",
            " #include <stdlib.h>",
            "-#include <assert.h>",
            " #include <limits.h>",
            " ",
            " #include \"grisu3_math.h\"",
            " ",
            " ",
            " /*",
            "  * The maximum number characters a valid number may contain.  The parse",
            "@@ -73,24 +72,24 @@",
            "  */",
            " static int grisu3_diy_fp_cached_dec_pow(int d_exp, grisu3_diy_fp_t *p)",
            " {",
            "     const int cached_offset = -GRISU3_MIN_CACHED_EXP;",
            "     const int d_exp_dist = GRISU3_CACHED_EXP_STEP;",
            "     int i, a_exp;",
            " ",
            "-    assert(GRISU3_MIN_CACHED_EXP <= d_exp);",
            "-    assert(d_exp <  GRISU3_MAX_CACHED_EXP + d_exp_dist);",
            "+    GRISU3_ASSERT(GRISU3_MIN_CACHED_EXP <= d_exp);",
            "+    GRISU3_ASSERT(d_exp <  GRISU3_MAX_CACHED_EXP + d_exp_dist);",
            " ",
            "     i = (d_exp + cached_offset) / d_exp_dist;",
            "     a_exp = grisu3_diy_fp_pow_cache[i].d_exp;",
            "     p->f = grisu3_diy_fp_pow_cache[i].fract;",
            "     p->e = grisu3_diy_fp_pow_cache[i].b_exp;",
            " ",
            "-    assert(a_exp <= d_exp);",
            "-    assert(d_exp < a_exp + d_exp_dist);",
            "+    GRISU3_ASSERT(a_exp <= d_exp);",
            "+    GRISU3_ASSERT(d_exp < a_exp + d_exp_dist);",
            " ",
            "     return a_exp;",
            " }",
            " ",
            " /*",
            "  * Ported from google double conversion strtod using",
            "  * MathGeoLibs diy_fp functions for grisu3 in C.",
            "@@ -178,15 +177,15 @@",
            "             { 0xc800000000000000ULL, -57 },",
            "             { 0xfa00000000000000ULL, -54 },",
            "             { 0x9c40000000000000ULL, -50 },",
            "             { 0xc350000000000000ULL, -47 },",
            "             { 0xf424000000000000ULL, -44 },",
            "             { 0x9896800000000000ULL, -40 },",
            "         };",
            "-        assert(adj_exp >= 0 && adj_exp < 7);",
            "+        GRISU3_ASSERT(adj_exp >= 0 && adj_exp < 7);",
            "         v = grisu3_diy_fp_multiply(v, cp_10_lut[adj_exp]);",
            " ",
            "         /* 20 decimal digits won't always fit in 64 bit.",
            "          * (`fraction_exp` is one less than significant decimal",
            "          * digits in fraction, e.g. 1 * 10e0).",
            "          * If we cannot fit, introduce 1/2 ulp error",
            "          * (says double conversion reference impl.) */",
            "@@ -235,16 +234,16 @@",
            "         v.f >>= e_scale;",
            "         v.e += e_scale;",
            "         error = (error >> e_scale) + 1 + error_one;",
            "         prec -= e_scale;",
            "     }",
            "     rounded.f = v.f >> prec;",
            "     rounded.e = v.e + prec;",
            "-    prec_bits = (v.f & ((uint64_t)1 << (prec - 1))) * error_one;",
            "-    half_way = ((uint64_t)1 << (prec - 1)) * error_one;",
            "+    prec_bits = (int)(v.f & ((uint64_t)1 << (prec - 1))) * error_one;",
            "+    half_way = (int)((uint64_t)1 << (prec - 1)) * error_one;",
            "     if (prec >= half_way + error) {",
            "         rounded.f++;",
            "         /* Prevent overflow. */",
            "         if (rounded.f & (hidden_bit << 1)) {",
            "             rounded.f >>= 1;",
            "             rounded.e += 1;",
            "         }",
            "@@ -393,15 +392,15 @@",
            "  * an encoding symbol may or may not be interpreted as a non-decimal",
            "  * encoding prefix, e.g. 0x, but a leading zero followed by a digit is",
            "  * NOT interpreted as octal.",
            "  * A single leading negative sign may appear before digits, but positive",
            "  * sign is not allowed and space after the sign is not allowed.",
            "  * At most the first 1000 characters of the input is considered.",
            "  */",
            "-static const char *grisu3_parse_double(const char *buf, int len, double *result)",
            "+static const char *grisu3_parse_double(const char *buf, size_t len, double *result)",
            " {",
            "     const char *mark, *k, *end;",
            "     int sign = 0, esign = 0;",
            "     uint64_t fraction = 0;",
            "     int exponent = 0;",
            "     int ee = 0;",
            "     int fraction_exp = 0;",
            "@@ -445,30 +444,30 @@",
            "         if (*buf < '1' || *buf > '9') {",
            "             /*",
            "              * If we didn't see a sign, just don't recognize it as",
            "              * number, otherwise make it an error.",
            "              */",
            "             return sign ? 0 : mark;",
            "         }",
            "-        fraction = *buf++ - '0';",
            "+        fraction = (uint64_t)(*buf++ - '0');",
            "     }",
            "     k = buf;",
            "     /*",
            "      * We do not catch trailing zeroes when there is no decimal point.",
            "      * This misses an opportunity for moving the exponent down into the",
            "      * fast case. But it is unlikely to be worthwhile as it complicates",
            "      * parsing.",
            "      */",
            "     while (buf != end && *buf >= '0' && *buf <= '9') {",
            "         if (fraction >= UINT64_MAX / 10) {",
            "             fraction += *buf >= '5';",
            "             ulp_half_error = 1;",
            "             break;",
            "         }",
            "-        fraction = fraction * 10 + *buf++ - '0';",
            "+        fraction = fraction * 10 + (uint64_t)(*buf++ - '0');",
            "     }",
            "     fraction_exp = (int)(buf - k);",
            "     /* Skip surplus digits. Trailing zero does not introduce error. */",
            "     while (buf != end && *buf == '0') {",
            "         ++exponent;",
            "         ++buf;",
            "     }",
            "@@ -492,15 +491,15 @@",
            "             if (fraction >= UINT64_MAX / 10) {",
            "                 if (!ulp_half_error) {",
            "                     fraction += *buf >= '5';",
            "                     ulp_half_error = 1;",
            "                 }",
            "                 break;",
            "             }",
            "-            fraction = fraction * 10 + *buf++ - '0';",
            "+            fraction = fraction * 10 + (uint64_t)(*buf++ - '0');",
            "             --exponent;",
            "         }",
            "         fraction_exp += (int)(buf - k);",
            "         while (buf != end && *buf == '0') {",
            "             ++exponent;",
            "             ++buf;",
            "         }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/grisu3_print.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/grisu3_print.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/grisu3_print.h",
            "@@ -93,458 +93,480 @@",
            " 000005c0: 2369 666e 6465 6620 4752 4953 5533 5f50  #ifndef GRISU3_P",
            " 000005d0: 5249 4e54 5f48 0a23 6465 6669 6e65 2047  RINT_H.#define G",
            " 000005e0: 5249 5355 335f 5052 494e 545f 480a 0a23  RISU3_PRINT_H..#",
            " 000005f0: 6966 6465 6620 5f5f 6370 6c75 7370 6c75  ifdef __cplusplu",
            " 00000600: 730a 6578 7465 726e 2022 4322 207b 0a23  s.extern \"C\" {.#",
            " 00000610: 656e 6469 660a 0a23 696e 636c 7564 6520  endif..#include ",
            " 00000620: 3c73 7464 696f 2e68 3e20 2f2a 2073 7072  <stdio.h> /* spr",
            "-00000630: 696e 7466 202a 2f0a 2369 6e63 6c75 6465  intf */.#include",
            "-00000640: 203c 6173 7365 7274 2e68 3e20 2f2a 2061   <assert.h> /* a",
            "-00000650: 7373 6572 7420 2a2f 0a0a 2369 6e63 6c75  ssert */..#inclu",
            "-00000660: 6465 2022 6772 6973 7533 5f6d 6174 682e  de \"grisu3_math.",
            "-00000670: 6822 0a0a 2f2a 0a20 2a20 5468 6520 6c69  h\"../*. * The li",
            "-00000680: 6768 7477 6569 6768 7420 2270 6f72 7461  ghtweight \"porta",
            "-00000690: 626c 6522 2043 206c 6962 7261 7279 2072  ble\" C library r",
            "-000006a0: 6563 6f67 6e69 7a65 7320 6772 6973 7533  ecognizes grisu3",
            "-000006b0: 2073 7570 706f 7274 2069 660a 202a 2069   support if. * i",
            "-000006c0: 6e63 6c75 6465 6420 6669 7273 742e 0a20  ncluded first.. ",
            "-000006d0: 2a2f 0a23 6465 6669 6e65 2067 7269 7375  */.#define grisu",
            "-000006e0: 335f 7072 696e 745f 646f 7562 6c65 5f69  3_print_double_i",
            "-000006f0: 735f 6465 6669 6e65 6420 310a 0a2f 2a0a  s_defined 1../*.",
            "-00000700: 202a 204e 6f74 2073 7572 6520 7765 2068   * Not sure we h",
            "-00000710: 6176 6520 616e 2065 7861 6374 2064 6566  ave an exact def",
            "-00000720: 696e 6974 696f 6e2c 2062 7574 2077 6520  inition, but we ",
            "-00000730: 6765 7420 7570 2074 6f20 3233 0a20 2a20  get up to 23. * ",
            "-00000740: 656d 7065 7269 6361 6c6c 792e 2054 6865  emperically. The",
            "-00000750: 7265 2069 7320 736f 6d65 206d 6174 6820  re is some math ",
            "-00000760: 656e 7375 7269 6e67 2069 7420 646f 6573  ensuring it does",
            "-00000770: 206e 6f74 2067 6f20 6177 6f6c 2074 686f   not go awol tho",
            "-00000780: 7567 682c 0a20 2a20 6c69 6b65 2031 3820  ugh,. * like 18 ",
            "-00000790: 6469 6769 7473 202b 2065 7870 6f6e 656e  digits + exponen",
            "-000007a0: 7420 6f72 2073 6f2e 0a20 2a20 5468 6973  t or so.. * This",
            "-000007b0: 206d 6178 2073 686f 756c 6420 6265 2073   max should be s",
            "-000007c0: 6166 6520 7369 7a65 2062 7566 6665 7220  afe size buffer ",
            "-000007d0: 666f 7220 7072 696e 7469 6e67 2c20 696e  for printing, in",
            "-000007e0: 636c 7564 696e 6720 7a65 726f 2074 6572  cluding zero ter",
            "-000007f0: 6d2e 0a20 2a2f 0a23 6465 6669 6e65 2047  m.. */.#define G",
            "-00000800: 5249 5355 335f 5052 494e 545f 4d41 5820  RISU3_PRINT_MAX ",
            "-00000810: 3330 0a0a 7374 6174 6963 2069 6e74 2067  30..static int g",
            "-00000820: 7269 7375 335f 726f 756e 645f 7765 6564  risu3_round_weed",
            "-00000830: 2863 6861 7220 2a62 7566 6665 722c 2069  (char *buffer, i",
            "-00000840: 6e74 206c 656e 2c20 7569 6e74 3634 5f74  nt len, uint64_t",
            "-00000850: 2077 705f 572c 2075 696e 7436 345f 7420   wp_W, uint64_t ",
            "-00000860: 6465 6c74 612c 2075 696e 7436 345f 7420  delta, uint64_t ",
            "-00000870: 7265 7374 2c20 7569 6e74 3634 5f74 2074  rest, uint64_t t",
            "-00000880: 656e 5f6b 6170 7061 2c20 7569 6e74 3634  en_kappa, uint64",
            "-00000890: 5f74 2075 6c70 290a 7b0a 2020 2020 7569  _t ulp).{.    ui",
            "-000008a0: 6e74 3634 5f74 2077 705f 5775 7020 3d20  nt64_t wp_Wup = ",
            "-000008b0: 7770 5f57 202d 2075 6c70 3b0a 2020 2020  wp_W - ulp;.    ",
            "-000008c0: 7569 6e74 3634 5f74 2077 705f 5764 6f77  uint64_t wp_Wdow",
            "-000008d0: 6e20 3d20 7770 5f57 202b 2075 6c70 3b0a  n = wp_W + ulp;.",
            "-000008e0: 2020 2020 7768 696c 6528 7265 7374 203c      while(rest <",
            "-000008f0: 2077 705f 5775 7020 2626 2064 656c 7461   wp_Wup && delta",
            "-00000900: 202d 2072 6573 7420 3e3d 2074 656e 5f6b   - rest >= ten_k",
            "-00000910: 6170 7061 0a20 2020 2020 2020 2026 2620  appa.        && ",
            "-00000920: 2872 6573 7420 2b20 7465 6e5f 6b61 7070  (rest + ten_kapp",
            "-00000930: 6120 3c20 7770 5f57 7570 207c 7c20 7770  a < wp_Wup || wp",
            "-00000940: 5f57 7570 202d 2072 6573 7420 3e3d 2072  _Wup - rest >= r",
            "-00000950: 6573 7420 2b20 7465 6e5f 6b61 7070 6120  est + ten_kappa ",
            "-00000960: 2d20 7770 5f57 7570 2929 0a20 2020 207b  - wp_Wup)).    {",
            "-00000970: 0a20 2020 2020 2020 202d 2d62 7566 6665  .        --buffe",
            "-00000980: 725b 6c65 6e2d 315d 3b0a 2020 2020 2020  r[len-1];.      ",
            "-00000990: 2020 7265 7374 202b 3d20 7465 6e5f 6b61    rest += ten_ka",
            "-000009a0: 7070 613b 0a20 2020 207d 0a20 2020 2069  ppa;.    }.    i",
            "-000009b0: 6620 2872 6573 7420 3c20 7770 5f57 646f  f (rest < wp_Wdo",
            "-000009c0: 776e 2026 2620 6465 6c74 6120 2d20 7265  wn && delta - re",
            "-000009d0: 7374 203e 3d20 7465 6e5f 6b61 7070 610a  st >= ten_kappa.",
            "-000009e0: 2020 2020 2020 2020 2626 2028 7265 7374          && (rest",
            "-000009f0: 202b 2074 656e 5f6b 6170 7061 203c 2077   + ten_kappa < w",
            "-00000a00: 705f 5764 6f77 6e20 7c7c 2077 705f 5764  p_Wdown || wp_Wd",
            "-00000a10: 6f77 6e20 2d20 7265 7374 203e 2072 6573  own - rest > res",
            "-00000a20: 7420 2b20 7465 6e5f 6b61 7070 6120 2d20  t + ten_kappa - ",
            "-00000a30: 7770 5f57 646f 776e 2929 0a20 2020 2020  wp_Wdown)).     ",
            "-00000a40: 2020 2072 6574 7572 6e20 303b 0a0a 2020     return 0;..  ",
            "-00000a50: 2020 7265 7475 726e 2032 2a75 6c70 203c    return 2*ulp <",
            "-00000a60: 3d20 7265 7374 2026 2620 7265 7374 203c  = rest && rest <",
            "-00000a70: 3d20 6465 6c74 6120 2d20 342a 756c 703b  = delta - 4*ulp;",
            "-00000a80: 0a7d 0a0a 7374 6174 6963 2069 6e74 2067  .}..static int g",
            "-00000a90: 7269 7375 335f 6469 6769 745f 6765 6e28  risu3_digit_gen(",
            "-00000aa0: 6772 6973 7533 5f64 6979 5f66 705f 7420  grisu3_diy_fp_t ",
            "-00000ab0: 6c6f 772c 2067 7269 7375 335f 6469 795f  low, grisu3_diy_",
            "-00000ac0: 6670 5f74 2077 2c20 6772 6973 7533 5f64  fp_t w, grisu3_d",
            "-00000ad0: 6979 5f66 705f 7420 6869 6768 2c20 6368  iy_fp_t high, ch",
            "-00000ae0: 6172 202a 6275 6666 6572 2c20 696e 7420  ar *buffer, int ",
            "-00000af0: 2a6c 656e 6774 682c 2069 6e74 202a 6b61  *length, int *ka",
            "-00000b00: 7070 6129 0a7b 0a20 2020 2075 696e 7436  ppa).{.    uint6",
            "-00000b10: 345f 7420 756e 6974 203d 2031 3b0a 2020  4_t unit = 1;.  ",
            "-00000b20: 2020 6772 6973 7533 5f64 6979 5f66 705f    grisu3_diy_fp_",
            "-00000b30: 7420 746f 6f5f 6c6f 7720 3d20 7b20 6c6f  t too_low = { lo",
            "-00000b40: 772e 6620 2d20 756e 6974 2c20 6c6f 772e  w.f - unit, low.",
            "-00000b50: 6520 7d3b 0a20 2020 2067 7269 7375 335f  e };.    grisu3_",
            "-00000b60: 6469 795f 6670 5f74 2074 6f6f 5f68 6967  diy_fp_t too_hig",
            "-00000b70: 6820 3d20 7b20 6869 6768 2e66 202b 2075  h = { high.f + u",
            "-00000b80: 6e69 742c 2068 6967 682e 6520 7d3b 0a20  nit, high.e };. ",
            "-00000b90: 2020 2067 7269 7375 335f 6469 795f 6670     grisu3_diy_fp",
            "-00000ba0: 5f74 2075 6e73 6166 655f 696e 7465 7276  _t unsafe_interv",
            "-00000bb0: 616c 203d 2020 6772 6973 7533 5f64 6979  al =  grisu3_diy",
            "-00000bc0: 5f66 705f 6d69 6e75 7328 746f 6f5f 6869  _fp_minus(too_hi",
            "-00000bd0: 6768 2c20 746f 6f5f 6c6f 7729 3b0a 2020  gh, too_low);.  ",
            "-00000be0: 2020 6772 6973 7533 5f64 6979 5f66 705f    grisu3_diy_fp_",
            "-00000bf0: 7420 6f6e 6520 3d20 7b20 3155 4c4c 203c  t one = { 1ULL <",
            "-00000c00: 3c20 2d77 2e65 2c20 772e 6520 7d3b 0a20  < -w.e, w.e };. ",
            "-00000c10: 2020 2075 696e 7433 325f 7420 7031 203d     uint32_t p1 =",
            "-00000c20: 2028 7569 6e74 3332 5f74 2928 746f 6f5f   (uint32_t)(too_",
            "-00000c30: 6869 6768 2e66 203e 3e20 2d6f 6e65 2e65  high.f >> -one.e",
            "-00000c40: 293b 0a20 2020 2075 696e 7436 345f 7420  );.    uint64_t ",
            "-00000c50: 7032 203d 2074 6f6f 5f68 6967 682e 6620  p2 = too_high.f ",
            "-00000c60: 2620 286f 6e65 2e66 202d 2031 293b 0a20  & (one.f - 1);. ",
            "-00000c70: 2020 2075 696e 7433 325f 7420 6469 763b     uint32_t div;",
            "-00000c80: 0a20 2020 202a 6b61 7070 6120 3d20 6772  .    *kappa = gr",
            "-00000c90: 6973 7533 5f6c 6172 6765 7374 5f70 6f77  isu3_largest_pow",
            "-00000ca0: 3130 2870 312c 2047 5249 5355 335f 4449  10(p1, GRISU3_DI",
            "-00000cb0: 595f 4650 5f46 5241 4354 5f53 495a 4520  Y_FP_FRACT_SIZE ",
            "-00000cc0: 2b20 6f6e 652e 652c 2026 6469 7629 3b0a  + one.e, &div);.",
            "-00000cd0: 2020 2020 2a6c 656e 6774 6820 3d20 303b      *length = 0;",
            "-00000ce0: 0a0a 2020 2020 7768 696c 6528 2a6b 6170  ..    while(*kap",
            "-00000cf0: 7061 203e 2030 290a 2020 2020 7b0a 2020  pa > 0).    {.  ",
            "-00000d00: 2020 2020 2020 7569 6e74 3634 5f74 2072        uint64_t r",
            "-00000d10: 6573 743b 0a20 2020 2020 2020 2069 6e74  est;.        int",
            "-00000d20: 2064 6967 6974 203d 2070 3120 2f20 6469   digit = p1 / di",
            "-00000d30: 763b 0a20 2020 2020 2020 2062 7566 6665  v;.        buffe",
            "-00000d40: 725b 2a6c 656e 6774 685d 203d 2028 6368  r[*length] = (ch",
            "-00000d50: 6172 2928 2730 2720 2b20 6469 6769 7429  ar)('0' + digit)",
            "-00000d60: 3b0a 2020 2020 2020 2020 2b2b 2a6c 656e  ;.        ++*len",
            "-00000d70: 6774 683b 0a20 2020 2020 2020 2070 3120  gth;.        p1 ",
            "-00000d80: 253d 2064 6976 3b0a 2020 2020 2020 2020  %= div;.        ",
            "-00000d90: 2d2d 2a6b 6170 7061 3b0a 2020 2020 2020  --*kappa;.      ",
            "-00000da0: 2020 7265 7374 203d 2028 2875 696e 7436    rest = ((uint6",
            "-00000db0: 345f 7429 7031 203c 3c20 2d6f 6e65 2e65  4_t)p1 << -one.e",
            "-00000dc0: 2920 2b20 7032 3b0a 2020 2020 2020 2020  ) + p2;.        ",
            "-00000dd0: 6966 2028 7265 7374 203c 2075 6e73 6166  if (rest < unsaf",
            "-00000de0: 655f 696e 7465 7276 616c 2e66 2920 7265  e_interval.f) re",
            "-00000df0: 7475 726e 2067 7269 7375 335f 726f 756e  turn grisu3_roun",
            "-00000e00: 645f 7765 6564 2862 7566 6665 722c 202a  d_weed(buffer, *",
            "-00000e10: 6c65 6e67 7468 2c20 6772 6973 7533 5f64  length, grisu3_d",
            "-00000e20: 6979 5f66 705f 6d69 6e75 7328 746f 6f5f  iy_fp_minus(too_",
            "-00000e30: 6869 6768 2c20 7729 2e66 2c20 756e 7361  high, w).f, unsa",
            "-00000e40: 6665 5f69 6e74 6572 7661 6c2e 662c 2072  fe_interval.f, r",
            "-00000e50: 6573 742c 2028 7569 6e74 3634 5f74 2964  est, (uint64_t)d",
            "-00000e60: 6976 203c 3c20 2d6f 6e65 2e65 2c20 756e  iv << -one.e, un",
            "-00000e70: 6974 293b 0a20 2020 2020 2020 2064 6976  it);.        div",
            "-00000e80: 202f 3d20 3130 3b0a 2020 2020 7d0a 0a20   /= 10;.    }.. ",
            "-00000e90: 2020 2066 6f72 283b 3b29 0a20 2020 207b     for(;;).    {",
            "-00000ea0: 0a20 2020 2020 2020 2069 6e74 2064 6967  .        int dig",
            "-00000eb0: 6974 3b0a 2020 2020 2020 2020 7032 202a  it;.        p2 *",
            "-00000ec0: 3d20 3130 3b0a 2020 2020 2020 2020 756e  = 10;.        un",
            "-00000ed0: 6974 202a 3d20 3130 3b0a 2020 2020 2020  it *= 10;.      ",
            "-00000ee0: 2020 756e 7361 6665 5f69 6e74 6572 7661    unsafe_interva",
            "-00000ef0: 6c2e 6620 2a3d 2031 303b 0a20 2020 2020  l.f *= 10;.     ",
            "-00000f00: 2020 202f 2a20 496e 7465 6765 7220 6469     /* Integer di",
            "-00000f10: 7669 7369 6f6e 2062 7920 6f6e 652e 202a  vision by one. *",
            "-00000f20: 2f0a 2020 2020 2020 2020 6469 6769 7420  /.        digit ",
            "-00000f30: 3d20 2869 6e74 2928 7032 203e 3e20 2d6f  = (int)(p2 >> -o",
            "-00000f40: 6e65 2e65 293b 0a20 2020 2020 2020 2062  ne.e);.        b",
            "-00000f50: 7566 6665 725b 2a6c 656e 6774 685d 203d  uffer[*length] =",
            "-00000f60: 2028 6368 6172 2928 2730 2720 2b20 6469   (char)('0' + di",
            "-00000f70: 6769 7429 3b0a 2020 2020 2020 2020 2b2b  git);.        ++",
            "-00000f80: 2a6c 656e 6774 683b 0a20 2020 2020 2020  *length;.       ",
            "-00000f90: 2070 3220 263d 206f 6e65 2e66 202d 2031   p2 &= one.f - 1",
            "-00000fa0: 3b20 2f2a 204d 6f64 756c 6f20 6279 206f  ; /* Modulo by o",
            "-00000fb0: 6e65 2e20 2a2f 0a20 2020 2020 2020 202d  ne. */.        -",
            "-00000fc0: 2d2a 6b61 7070 613b 0a20 2020 2020 2020  -*kappa;.       ",
            "-00000fd0: 2069 6620 2870 3220 3c20 756e 7361 6665   if (p2 < unsafe",
            "-00000fe0: 5f69 6e74 6572 7661 6c2e 6629 2072 6574  _interval.f) ret",
            "-00000ff0: 7572 6e20 6772 6973 7533 5f72 6f75 6e64  urn grisu3_round",
            "-00001000: 5f77 6565 6428 6275 6666 6572 2c20 2a6c  _weed(buffer, *l",
            "-00001010: 656e 6774 682c 2067 7269 7375 335f 6469  ength, grisu3_di",
            "-00001020: 795f 6670 5f6d 696e 7573 2874 6f6f 5f68  y_fp_minus(too_h",
            "-00001030: 6967 682c 2077 292e 6620 2a20 756e 6974  igh, w).f * unit",
            "-00001040: 2c20 756e 7361 6665 5f69 6e74 6572 7661  , unsafe_interva",
            "-00001050: 6c2e 662c 2070 322c 206f 6e65 2e66 2c20  l.f, p2, one.f, ",
            "-00001060: 756e 6974 293b 0a20 2020 207d 0a7d 0a0a  unit);.    }.}..",
            "-00001070: 7374 6174 6963 2069 6e74 2067 7269 7375  static int grisu",
            "-00001080: 3328 646f 7562 6c65 2076 2c20 6368 6172  3(double v, char",
            "-00001090: 202a 6275 6666 6572 2c20 696e 7420 2a6c   *buffer, int *l",
            "-000010a0: 656e 6774 682c 2069 6e74 202a 645f 6578  ength, int *d_ex",
            "-000010b0: 7029 0a7b 0a20 2020 2069 6e74 206d 6b2c  p).{.    int mk,",
            "-000010c0: 206b 6170 7061 2c20 7375 6363 6573 733b   kappa, success;",
            "-000010d0: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "-000010e0: 6670 5f74 2064 6670 203d 2067 7269 7375  fp_t dfp = grisu",
            "-000010f0: 335f 6361 7374 5f64 6979 5f66 705f 6672  3_cast_diy_fp_fr",
            "-00001100: 6f6d 5f64 6f75 626c 6528 7629 3b0a 2020  om_double(v);.  ",
            "-00001110: 2020 6772 6973 7533 5f64 6979 5f66 705f    grisu3_diy_fp_",
            "-00001120: 7420 7720 3d20 6772 6973 7533 5f64 6979  t w = grisu3_diy",
            "-00001130: 5f66 705f 6e6f 726d 616c 697a 6528 6466  _fp_normalize(df",
            "-00001140: 7029 3b0a 0a20 2020 202f 2a20 6e6f 726d  p);..    /* norm",
            "-00001150: 616c 697a 6520 626f 756e 6461 7269 6573  alize boundaries",
            "-00001160: 202a 2f0a 2020 2020 6772 6973 7533 5f64   */.    grisu3_d",
            "-00001170: 6979 5f66 705f 7420 7420 3d20 7b20 2864  iy_fp_t t = { (d",
            "-00001180: 6670 2e66 203c 3c20 3129 202b 2031 2c20  fp.f << 1) + 1, ",
            "-00001190: 6466 702e 6520 2d20 3120 7d3b 0a20 2020  dfp.e - 1 };.   ",
            "-000011a0: 2067 7269 7375 335f 6469 795f 6670 5f74   grisu3_diy_fp_t",
            "-000011b0: 2062 5f70 6c75 7320 3d20 6772 6973 7533   b_plus = grisu3",
            "-000011c0: 5f64 6979 5f66 705f 6e6f 726d 616c 697a  _diy_fp_normaliz",
            "-000011d0: 6528 7429 3b0a 2020 2020 6772 6973 7533  e(t);.    grisu3",
            "-000011e0: 5f64 6979 5f66 705f 7420 625f 6d69 6e75  _diy_fp_t b_minu",
            "-000011f0: 733b 0a20 2020 2067 7269 7375 335f 6469  s;.    grisu3_di",
            "-00001200: 795f 6670 5f74 2063 5f6d 6b3b 202f 2a20  y_fp_t c_mk; /* ",
            "-00001210: 4361 6368 6564 2070 6f77 6572 206f 6620  Cached power of ",
            "-00001220: 7465 6e3a 2031 305e 2d6b 202a 2f0a 2020  ten: 10^-k */.  ",
            "-00001230: 2020 7569 6e74 3634 5f74 2075 3634 203d    uint64_t u64 =",
            "-00001240: 2067 7269 7375 335f 6361 7374 5f75 696e   grisu3_cast_uin",
            "-00001250: 7436 345f 6672 6f6d 5f64 6f75 626c 6528  t64_from_double(",
            "-00001260: 7629 3b0a 2020 2020 6173 7365 7274 2876  v);.    assert(v",
            "-00001270: 203e 2030 2026 2620 7620 3c3d 2031 2e37   > 0 && v <= 1.7",
            "-00001280: 3937 3639 3331 3334 3836 3233 3135 3765  976931348623157e",
            "-00001290: 3330 3829 3b20 2f2a 2047 7269 7375 206f  308); /* Grisu o",
            "-000012a0: 6e6c 7920 6861 6e64 6c65 7320 7374 7269  nly handles stri",
            "-000012b0: 6374 6c79 2070 6f73 6974 6976 6520 6669  ctly positive fi",
            "-000012c0: 6e69 7465 206e 756d 6265 7273 2e20 2a2f  nite numbers. */",
            "-000012d0: 0a20 2020 2069 6620 2821 2875 3634 2026  .    if (!(u64 &",
            "-000012e0: 2047 5249 5355 335f 4436 345f 4652 4143   GRISU3_D64_FRAC",
            "-000012f0: 545f 4d41 534b 2920 2626 2028 7536 3420  T_MASK) && (u64 ",
            "-00001300: 2620 4752 4953 5533 5f44 3634 5f45 5850  & GRISU3_D64_EXP",
            "-00001310: 5f4d 4153 4b29 2021 3d20 3029 207b 2062  _MASK) != 0) { b",
            "-00001320: 5f6d 696e 7573 2e66 203d 2028 6466 702e  _minus.f = (dfp.",
            "-00001330: 6620 3c3c 2032 2920 2d20 313b 2062 5f6d  f << 2) - 1; b_m",
            "-00001340: 696e 7573 2e65 203d 2020 6466 702e 6520  inus.e =  dfp.e ",
            "-00001350: 2d20 323b 7d20 2f2a 206c 6f77 6572 2062  - 2;} /* lower b",
            "-00001360: 6f75 6e64 6172 7920 6973 2063 6c6f 7365  oundary is close",
            "-00001370: 723f 202a 2f0a 2020 2020 656c 7365 207b  r? */.    else {",
            "-00001380: 2062 5f6d 696e 7573 2e66 203d 2028 6466   b_minus.f = (df",
            "-00001390: 702e 6620 3c3c 2031 2920 2d20 313b 2062  p.f << 1) - 1; b",
            "-000013a0: 5f6d 696e 7573 2e65 203d 2064 6670 2e65  _minus.e = dfp.e",
            "-000013b0: 202d 2031 3b20 7d0a 2020 2020 625f 6d69   - 1; }.    b_mi",
            "-000013c0: 6e75 732e 6620 3d20 625f 6d69 6e75 732e  nus.f = b_minus.",
            "-000013d0: 6620 3c3c 2028 625f 6d69 6e75 732e 6520  f << (b_minus.e ",
            "-000013e0: 2d20 625f 706c 7573 2e65 293b 0a20 2020  - b_plus.e);.   ",
            "-000013f0: 2062 5f6d 696e 7573 2e65 203d 2062 5f70   b_minus.e = b_p",
            "-00001400: 6c75 732e 653b 0a0a 2020 2020 6d6b 203d  lus.e;..    mk =",
            "-00001410: 2067 7269 7375 335f 6469 795f 6670 5f63   grisu3_diy_fp_c",
            "-00001420: 6163 6865 645f 706f 7728 4752 4953 5533  ached_pow(GRISU3",
            "-00001430: 5f4d 494e 5f54 4152 4745 545f 4558 5020  _MIN_TARGET_EXP ",
            "-00001440: 2d20 4752 4953 5533 5f44 4959 5f46 505f  - GRISU3_DIY_FP_",
            "-00001450: 4652 4143 545f 5349 5a45 202d 2077 2e65  FRACT_SIZE - w.e",
            "-00001460: 2c20 2663 5f6d 6b29 3b0a 0a20 2020 2077  , &c_mk);..    w",
            "-00001470: 203d 2067 7269 7375 335f 6469 795f 6670   = grisu3_diy_fp",
            "-00001480: 5f6d 756c 7469 706c 7928 772c 2063 5f6d  _multiply(w, c_m",
            "-00001490: 6b29 3b0a 2020 2020 625f 6d69 6e75 7320  k);.    b_minus ",
            "-000014a0: 3d20 6772 6973 7533 5f64 6979 5f66 705f  = grisu3_diy_fp_",
            "-000014b0: 6d75 6c74 6970 6c79 2862 5f6d 696e 7573  multiply(b_minus",
            "-000014c0: 2c20 635f 6d6b 293b 0a20 2020 2062 5f70  , c_mk);.    b_p",
            "-000014d0: 6c75 7320 203d 2067 7269 7375 335f 6469  lus  = grisu3_di",
            "-000014e0: 795f 6670 5f6d 756c 7469 706c 7928 625f  y_fp_multiply(b_",
            "-000014f0: 706c 7573 2c20 2063 5f6d 6b29 3b0a 0a20  plus,  c_mk);.. ",
            "-00001500: 2020 2073 7563 6365 7373 203d 2067 7269     success = gri",
            "-00001510: 7375 335f 6469 6769 745f 6765 6e28 625f  su3_digit_gen(b_",
            "-00001520: 6d69 6e75 732c 2077 2c20 625f 706c 7573  minus, w, b_plus",
            "-00001530: 2c20 6275 6666 6572 2c20 6c65 6e67 7468  , buffer, length",
            "-00001540: 2c20 266b 6170 7061 293b 0a20 2020 202a  , &kappa);.    *",
            "-00001550: 645f 6578 7020 3d20 6b61 7070 6120 2d20  d_exp = kappa - ",
            "-00001560: 6d6b 3b0a 2020 2020 7265 7475 726e 2073  mk;.    return s",
            "-00001570: 7563 6365 7373 3b0a 7d0a 0a73 7461 7469  uccess;.}..stati",
            "-00001580: 6320 696e 7420 6772 6973 7533 5f69 5f74  c int grisu3_i_t",
            "-00001590: 6f5f 7374 7228 696e 7420 7661 6c2c 2063  o_str(int val, c",
            "-000015a0: 6861 7220 2a73 7472 290a 7b0a 2020 2020  har *str).{.    ",
            "-000015b0: 696e 7420 6c65 6e2c 2069 3b0a 2020 2020  int len, i;.    ",
            "-000015c0: 6368 6172 202a 733b 0a20 2020 2063 6861  char *s;.    cha",
            "-000015d0: 7220 2a62 6567 696e 203d 2073 7472 3b0a  r *begin = str;.",
            "-000015e0: 2020 2020 6966 2028 7661 6c20 3c20 3029      if (val < 0)",
            "-000015f0: 207b 202a 7374 722b 2b20 3d20 272d 273b   { *str++ = '-';",
            "-00001600: 2076 616c 203d 202d 7661 6c3b 207d 0a20   val = -val; }. ",
            "-00001610: 2020 2073 203d 2073 7472 3b0a 0a20 2020     s = str;..   ",
            "-00001620: 2066 6f72 283b 3b29 0a20 2020 207b 0a20   for(;;).    {. ",
            "-00001630: 2020 2020 2020 2069 6e74 206e 6920 3d20         int ni = ",
            "-00001640: 7661 6c20 2f20 3130 3b0a 2020 2020 2020  val / 10;.      ",
            "-00001650: 2020 696e 7420 6469 6769 7420 3d20 7661    int digit = va",
            "-00001660: 6c20 2d20 6e69 2a31 303b 0a20 2020 2020  l - ni*10;.     ",
            "-00001670: 2020 202a 732b 2b20 3d20 2863 6861 7229     *s++ = (char)",
            "-00001680: 2827 3027 202b 2064 6967 6974 293b 0a20  ('0' + digit);. ",
            "-00001690: 2020 2020 2020 2069 6620 286e 6920 3d3d         if (ni ==",
            "-000016a0: 2030 290a 2020 2020 2020 2020 2020 2020   0).            ",
            "-000016b0: 6272 6561 6b3b 0a20 2020 2020 2020 2076  break;.        v",
            "-000016c0: 616c 203d 206e 693b 0a20 2020 207d 0a20  al = ni;.    }. ",
            "-000016d0: 2020 202a 7320 3d20 275c 3027 3b0a 2020     *s = '\\0';.  ",
            "-000016e0: 2020 6c65 6e20 3d20 2869 6e74 2928 7320    len = (int)(s ",
            "-000016f0: 2d20 7374 7229 3b0a 2020 2020 666f 7228  - str);.    for(",
            "-00001700: 6920 3d20 303b 2069 203c 206c 656e 2f32  i = 0; i < len/2",
            "-00001710: 3b20 2b2b 6929 0a20 2020 207b 0a20 2020  ; ++i).    {.   ",
            "-00001720: 2020 2020 2063 6861 7220 6368 203d 2073       char ch = s",
            "-00001730: 7472 5b69 5d3b 0a20 2020 2020 2020 2073  tr[i];.        s",
            "-00001740: 7472 5b69 5d20 3d20 7374 725b 6c65 6e2d  tr[i] = str[len-",
            "-00001750: 312d 695d 3b0a 2020 2020 2020 2020 7374  1-i];.        st",
            "-00001760: 725b 6c65 6e2d 312d 695d 203d 2063 683b  r[len-1-i] = ch;",
            "-00001770: 0a20 2020 207d 0a0a 2020 2020 7265 7475  .    }..    retu",
            "-00001780: 726e 2028 696e 7429 2873 202d 2062 6567  rn (int)(s - beg",
            "-00001790: 696e 293b 0a7d 0a0a 7374 6174 6963 2069  in);.}..static i",
            "-000017a0: 6e74 2067 7269 7375 335f 7072 696e 745f  nt grisu3_print_",
            "-000017b0: 646f 7562 6c65 2864 6f75 626c 6520 762c  double(double v,",
            "-000017c0: 2063 6861 7220 2a64 7374 290a 7b0a 2020   char *dst).{.  ",
            "-000017d0: 2020 696e 7420 645f 6578 702c 206c 656e    int d_exp, len",
            "-000017e0: 2c20 7375 6363 6573 732c 2064 6563 696d  , success, decim",
            "-000017f0: 616c 732c 2069 3b0a 2020 2020 7569 6e74  als, i;.    uint",
            "-00001800: 3634 5f74 2075 3634 203d 2067 7269 7375  64_t u64 = grisu",
            "-00001810: 335f 6361 7374 5f75 696e 7436 345f 6672  3_cast_uint64_fr",
            "-00001820: 6f6d 5f64 6f75 626c 6528 7629 3b0a 2020  om_double(v);.  ",
            "-00001830: 2020 6368 6172 202a 7332 203d 2064 7374    char *s2 = dst",
            "-00001840: 3b0a 2020 2020 6173 7365 7274 2864 7374  ;.    assert(dst",
            "-00001850: 293b 0a0a 2020 2020 2f2a 2050 7265 6861  );..    /* Preha",
            "-00001860: 6e64 6c65 204e 614e 7320 2a2f 0a20 2020  ndle NaNs */.   ",
            "-00001870: 2069 6620 2828 7536 3420 3c3c 2031 2920   if ((u64 << 1) ",
            "-00001880: 3e20 3078 4646 4530 3030 3030 3030 3030  > 0xFFE000000000",
            "-00001890: 3030 3030 554c 4c29 2072 6574 7572 6e20  0000ULL) return ",
            "-000018a0: 7370 7269 6e74 6628 6473 742c 2022 4e61  sprintf(dst, \"Na",
            "-000018b0: 4e28 2530 3858 2530 3858 2922 2c20 2875  N(%08X%08X)\", (u",
            "-000018c0: 696e 7433 325f 7429 2875 3634 203e 3e20  int32_t)(u64 >> ",
            "-000018d0: 3332 292c 2028 7569 6e74 3332 5f74 2975  32), (uint32_t)u",
            "-000018e0: 3634 293b 0a20 2020 202f 2a20 5072 6568  64);.    /* Preh",
            "-000018f0: 616e 646c 6520 6e65 6761 7469 7665 2076  andle negative v",
            "-00001900: 616c 7565 732e 202a 2f0a 2020 2020 6966  alues. */.    if",
            "-00001910: 2028 2875 3634 2026 2047 5249 5355 335f   ((u64 & GRISU3_",
            "-00001920: 4436 345f 5349 474e 2920 213d 2030 2920  D64_SIGN) != 0) ",
            "-00001930: 7b20 2a73 322b 2b20 3d20 272d 273b 2076  { *s2++ = '-'; v",
            "-00001940: 203d 202d 763b 2075 3634 205e 3d20 4752   = -v; u64 ^= GR",
            "-00001950: 4953 5533 5f44 3634 5f53 4947 4e3b 207d  ISU3_D64_SIGN; }",
            "-00001960: 0a20 2020 202f 2a20 5072 6568 616e 646c  .    /* Prehandl",
            "-00001970: 6520 7a65 726f 2e20 2a2f 0a20 2020 2069  e zero. */.    i",
            "-00001980: 6620 2821 7536 3429 207b 202a 7332 2b2b  f (!u64) { *s2++",
            "-00001990: 203d 2027 3027 3b20 2a73 3220 3d20 275c   = '0'; *s2 = '\\",
            "-000019a0: 3027 3b20 7265 7475 726e 2028 696e 7429  0'; return (int)",
            "-000019b0: 2873 3220 2d20 6473 7429 3b20 7d0a 2020  (s2 - dst); }.  ",
            "-000019c0: 2020 2f2a 2050 7265 6861 6e64 6c65 2069    /* Prehandle i",
            "-000019d0: 6e66 696e 6974 792e 202a 2f0a 2020 2020  nfinity. */.    ",
            "-000019e0: 6966 2028 7536 3420 3d3d 2047 5249 5355  if (u64 == GRISU",
            "-000019f0: 335f 4436 345f 4558 505f 4d41 534b 2920  3_D64_EXP_MASK) ",
            "-00001a00: 7b20 2a73 322b 2b20 3d20 2769 273b 202a  { *s2++ = 'i'; *",
            "-00001a10: 7332 2b2b 203d 2027 6e27 3b20 2a73 322b  s2++ = 'n'; *s2+",
            "-00001a20: 2b20 3d20 2766 273b 202a 7332 203d 2027  + = 'f'; *s2 = '",
            "-00001a30: 5c30 273b 2072 6574 7572 6e20 2869 6e74  \\0'; return (int",
            "-00001a40: 2928 7332 202d 2064 7374 293b 207d 0a0a  )(s2 - dst); }..",
            "-00001a50: 2020 2020 7375 6363 6573 7320 3d20 6772      success = gr",
            "-00001a60: 6973 7533 2876 2c20 7332 2c20 266c 656e  isu3(v, s2, &len",
            "-00001a70: 2c20 2664 5f65 7870 293b 0a20 2020 202f  , &d_exp);.    /",
            "-00001a80: 2a20 4966 2067 7269 7375 3320 7761 7320  * If grisu3 was ",
            "-00001a90: 6e6f 7420 6162 6c65 2074 6f20 636f 6e76  not able to conv",
            "-00001aa0: 6572 7420 7468 6520 6e75 6d62 6572 2074  ert the number t",
            "-00001ab0: 6f20 6120 7374 7269 6e67 2c20 7468 656e  o a string, then",
            "-00001ac0: 2075 7365 206f 6c64 2073 7072 696e 7466   use old sprintf",
            "-00001ad0: 2028 7375 626f 7074 696d 616c 292e 202a   (suboptimal). *",
            "-00001ae0: 2f0a 2020 2020 6966 2028 2173 7563 6365  /.    if (!succe",
            "-00001af0: 7373 2920 7265 7475 726e 2073 7072 696e  ss) return sprin",
            "-00001b00: 7466 2873 322c 2022 252e 3137 6722 2c20  tf(s2, \"%.17g\", ",
            "-00001b10: 7629 202b 2028 696e 7429 2873 3220 2d20  v) + (int)(s2 - ",
            "-00001b20: 6473 7429 3b0a 0a20 2020 202f 2a20 5765  dst);..    /* We",
            "-00001b30: 206e 6f77 2068 6176 6520 616e 2069 6e74   now have an int",
            "-00001b40: 6567 6572 2073 7472 696e 6720 6f66 2066  eger string of f",
            "-00001b50: 6f72 6d20 2231 3531 3332 3431 3335 2220  orm \"151324135\" ",
            "-00001b60: 616e 6420 6120 6261 7365 2d31 3020 6578  and a base-10 ex",
            "-00001b70: 706f 6e65 6e74 2066 6f72 2074 6861 7420  ponent for that ",
            "-00001b80: 6e75 6d62 6572 2e20 2a2f 0a20 2020 202f  number. */.    /",
            "-00001b90: 2a20 4e65 7874 2c20 6465 6369 6465 2074  * Next, decide t",
            "-00001ba0: 6865 2062 6573 7420 7072 6573 656e 7461  he best presenta",
            "-00001bb0: 7469 6f6e 2066 6f72 2074 6861 7420 7374  tion for that st",
            "-00001bc0: 7269 6e67 2062 7920 7768 6574 6865 7220  ring by whether ",
            "-00001bd0: 746f 2075 7365 2061 2064 6563 696d 616c  to use a decimal",
            "-00001be0: 2070 6f69 6e74 2c20 6f72 2074 6865 2073   point, or the s",
            "-00001bf0: 6369 656e 7469 6669 6320 6578 706f 6e65  cientific expone",
            "-00001c00: 6e74 1020 6e6f 7461 7469 6f6e 2027 6527  nt. notation 'e'",
            "-00001c10: 2e20 2a2f 0a20 2020 202f 2a20 5765 2064  . */.    /* We d",
            "-00001c20: 6f6e 2774 2070 6963 6b20 7468 6520 6162  on't pick the ab",
            "-00001c30: 736f 6c75 7465 2073 686f 7274 6573 7420  solute shortest ",
            "-00001c40: 7265 7072 6573 656e 7461 7469 6f6e 2c20  representation, ",
            "-00001c50: 6275 7420 7069 636b 2061 2062 616c 616e  but pick a balan",
            "-00001c60: 6365 2062 6574 7765 656e 2072 6561 6461  ce between reada",
            "-00001c70: 6269 6c69 7479 2061 6e64 2073 686f 7274  bility and short",
            "-00001c80: 6e65 7373 2c20 652e 672e 202a 2f0a 2020  ness, e.g. */.  ",
            "-00001c90: 2020 2f2a 2031 2e35 3435 3035 3631 3839    /* 1.545056189",
            "-00001ca0: 3535 3736 3737 652d 3330 3820 636f 756c  557677e-308 coul",
            "-00001cb0: 6420 6265 2072 6570 7265 7365 6e74 6564  d be represented",
            "-00001cc0: 2069 6e20 6120 7368 6f72 7465 7220 666f   in a shorter fo",
            "-00001cd0: 726d 202a 2f0a 2020 2020 2f2a 2031 3534  rm */.    /* 154",
            "-00001ce0: 3530 3536 3138 3935 3537 3637 3765 2d33  5056189557677e-3",
            "-00001cf0: 3233 2062 7574 2074 6861 7420 776f 756c  23 but that woul",
            "-00001d00: 6420 6265 2073 6f6d 6577 6861 7420 756e  d be somewhat un",
            "-00001d10: 7265 6164 6162 6c65 2e20 2a2f 0a20 2020  readable. */.   ",
            "-00001d20: 2064 6563 696d 616c 7320 3d20 4752 4953   decimals = GRIS",
            "-00001d30: 5533 5f4d 494e 282d 645f 6578 702c 2047  U3_MIN(-d_exp, G",
            "-00001d40: 5249 5355 335f 4d41 5828 312c 206c 656e  RISU3_MAX(1, len",
            "-00001d50: 2d31 2929 3b0a 0a20 2020 202f 2a20 6d69  -1));..    /* mi",
            "-00001d60: 6b6b 656c 666a 3a0a 2020 2020 202a 2066  kkelfj:.     * f",
            "-00001d70: 6978 207a 6572 6f20 7072 6566 6978 202e  ix zero prefix .",
            "-00001d80: 3120 3d3e 2030 2e31 2c20 696d 706f 7274  1 => 0.1, import",
            "-00001d90: 616e 7420 666f 7220 4a53 4f4e 2065 7870  ant for JSON exp",
            "-00001da0: 6f72 742e 0a20 2020 2020 2a20 7072 6566  ort..     * pref",
            "-00001db0: 6572 2075 6e73 6369 656e 7469 6669 6320  er unscientific ",
            "-00001dc0: 6e6f 7461 7469 6f6e 2061 7420 7361 6d65  notation at same",
            "-00001dd0: 206c 656e 6774 683a 0a20 2020 2020 2a20   length:.     * ",
            "-00001de0: 2d31 2e32 3334 3565 2d34 206f 7665 7220  -1.2345e-4 over ",
            "-00001df0: 2d31 2e30 3030 3132 3334 352c 0a20 2020  -1.00012345,.   ",
            "-00001e00: 2020 2a20 2d31 2e30 3031 3233 3435 206f    * -1.0012345 o",
            "-00001e10: 7665 7220 2d31 2e32 3334 3565 2d33 0a20  ver -1.2345e-3. ",
            "-00001e20: 2020 2020 2a2f 0a20 2020 2069 6620 2864      */.    if (d",
            "-00001e30: 5f65 7870 203c 2030 2026 2620 286c 656e  _exp < 0 && (len",
            "-00001e40: 202b 2064 5f65 7870 2920 3e20 2d33 2026   + d_exp) > -3 &",
            "-00001e50: 2620 6c65 6e20 3c3d 202d 645f 6578 7029  & len <= -d_exp)",
            "-00001e60: 0a20 2020 207b 0a20 2020 2020 2020 202f  .    {.        /",
            "-00001e70: 2a20 6d69 6b6b 656c 666a 3a20 6669 7820  * mikkelfj: fix ",
            "-00001e80: 7a65 726f 2070 7265 6669 7820 2e31 203d  zero prefix .1 =",
            "-00001e90: 3e20 302e 312c 2061 6e64 2073 686f 7274  > 0.1, and short",
            "-00001ea0: 2065 7870 6f6e 656e 7473 2031 2e33 652d   exponents 1.3e-",
            "-00001eb0: 3220 3d3e 2030 2e30 3133 2e20 2a2f 0a20  2 => 0.013. */. ",
            "-00001ec0: 2020 2020 2020 206d 656d 6d6f 7665 2873         memmove(s",
            "-00001ed0: 3220 2b20 3220 2d20 645f 6578 7020 2d20  2 + 2 - d_exp - ",
            "-00001ee0: 6c65 6e2c 2073 322c 206c 656e 293b 0a20  len, s2, len);. ",
            "-00001ef0: 2020 2020 2020 2073 325b 305d 203d 2027         s2[0] = '",
            "-00001f00: 3027 3b0a 2020 2020 2020 2020 7332 5b31  0';.        s2[1",
            "-00001f10: 5d20 3d20 272e 273b 0a20 2020 2020 2020  ] = '.';.       ",
            "-00001f20: 2066 6f72 2028 6920 3d20 323b 2069 203c   for (i = 2; i <",
            "-00001f30: 2032 2d64 5f65 7870 2d6c 656e 3b20 2b2b   2-d_exp-len; ++",
            "-00001f40: 6929 2073 325b 695d 203d 2027 3027 3b0a  i) s2[i] = '0';.",
            "-00001f50: 2020 2020 2020 2020 6c65 6e20 2b3d 2069          len += i",
            "-00001f60: 3b0a 2020 2020 7d0a 2020 2020 656c 7365  ;.    }.    else",
            "-00001f70: 2069 6620 2864 5f65 7870 203c 2030 2026   if (d_exp < 0 &",
            "-00001f80: 2620 6c65 6e20 3e20 3129 202f 2a20 4164  & len > 1) /* Ad",
            "-00001f90: 6420 6465 6369 6d61 6c20 706f 696e 743f  d decimal point?",
            "-00001fa0: 202a 2f0a 2020 2020 7b0a 2020 2020 2020   */.    {.      ",
            "-00001fb0: 2020 666f 7228 6920 3d20 303b 2069 203c    for(i = 0; i <",
            "-00001fc0: 2064 6563 696d 616c 733b 202b 2b69 2920   decimals; ++i) ",
            "-00001fd0: 7332 5b6c 656e 2d69 5d20 3d20 7332 5b6c  s2[len-i] = s2[l",
            "-00001fe0: 656e 2d69 2d31 5d3b 0a20 2020 2020 2020  en-i-1];.       ",
            "-00001ff0: 2073 325b 6c65 6e2b 2b20 2d20 6465 6369   s2[len++ - deci",
            "-00002000: 6d61 6c73 5d20 3d20 272e 273b 0a20 2020  mals] = '.';.   ",
            "-00002010: 2020 2020 2064 5f65 7870 202b 3d20 6465       d_exp += de",
            "-00002020: 6369 6d61 6c73 3b0a 2020 2020 2020 2020  cimals;.        ",
            "-00002030: 2f2a 204e 6565 6420 7363 6965 6e74 6966  /* Need scientif",
            "-00002040: 6963 206e 6f74 6174 696f 6e20 6173 2077  ic notation as w",
            "-00002050: 656c 6c3f 202a 2f0a 2020 2020 2020 2020  ell? */.        ",
            "-00002060: 6966 2028 645f 6578 7020 213d 2030 2920  if (d_exp != 0) ",
            "-00002070: 7b20 7332 5b6c 656e 2b2b 5d20 3d20 2765  { s2[len++] = 'e",
            "-00002080: 273b 206c 656e 202b 3d20 6772 6973 7533  '; len += grisu3",
            "-00002090: 5f69 5f74 6f5f 7374 7228 645f 6578 702c  _i_to_str(d_exp,",
            "-000020a0: 2073 322b 6c65 6e29 3b20 7d0a 2020 2020   s2+len); }.    ",
            "-000020b0: 7d0a 2020 2020 2f2a 2041 6464 2073 6369  }.    /* Add sci",
            "-000020c0: 656e 7469 6669 6320 6e6f 7461 7469 6f6e  entific notation",
            "-000020d0: 3f20 2a2f 0a20 2020 2065 6c73 6520 6966  ? */.    else if",
            "-000020e0: 2028 645f 6578 7020 3c20 3020 7c7c 2064   (d_exp < 0 || d",
            "-000020f0: 5f65 7870 203e 2032 2920 7b20 7332 5b6c  _exp > 2) { s2[l",
            "-00002100: 656e 2b2b 5d20 3d20 2765 273b 206c 656e  en++] = 'e'; len",
            "-00002110: 202b 3d20 6772 6973 7533 5f69 5f74 6f5f   += grisu3_i_to_",
            "-00002120: 7374 7228 645f 6578 702c 2073 322b 6c65  str(d_exp, s2+le",
            "-00002130: 6e29 3b20 7d0a 2020 2020 2f2a 2041 6464  n); }.    /* Add",
            "-00002140: 207a 6572 6f65 7320 696e 7374 6561 6420   zeroes instead ",
            "-00002150: 6f66 2073 6369 656e 7469 6669 6320 6e6f  of scientific no",
            "-00002160: 7461 7469 6f6e 3f20 2a2f 0a20 2020 2065  tation? */.    e",
            "-00002170: 6c73 6520 6966 2028 645f 6578 7020 3e20  lse if (d_exp > ",
            "-00002180: 3029 207b 2077 6869 6c65 2864 5f65 7870  0) { while(d_exp",
            "-00002190: 2d2d 203e 2030 2920 7332 5b6c 656e 2b2b  -- > 0) s2[len++",
            "-000021a0: 5d20 3d20 2730 273b 207d 0a20 2020 2073  ] = '0'; }.    s",
            "-000021b0: 325b 6c65 6e5d 203d 2027 5c30 273b 202f  2[len] = '\\0'; /",
            "-000021c0: 2a20 6772 6973 7533 2064 6f65 736e 2774  * grisu3 doesn't",
            "-000021d0: 206e 756c 6c20 7465 726d 696e 6174 652c   null terminate,",
            "-000021e0: 2073 6f20 656e 7375 7265 2074 6572 6d69   so ensure termi",
            "-000021f0: 6e61 7469 6f6e 2e20 2a2f 0a20 2020 2072  nation. */.    r",
            "-00002200: 6574 7572 6e20 2869 6e74 2928 7332 2b6c  eturn (int)(s2+l",
            "-00002210: 656e 2d64 7374 293b 0a7d 0a0a 2369 6664  en-dst);.}..#ifd",
            "-00002220: 6566 205f 5f63 706c 7573 706c 7573 0a7d  ef __cplusplus.}",
            "-00002230: 0a23 656e 6469 660a 0a23 656e 6469 6620  .#endif..#endif ",
            "-00002240: 2f2a 2047 5249 5355 335f 5052 494e 545f  /* GRISU3_PRINT_",
            "-00002250: 4820 2a2f 0a                             H */.",
            "+00000630: 696e 7466 2c20 6f6e 6c79 206e 6565 6465  intf, only neede",
            "+00000640: 6420 666f 7220 6661 6c6c 6261 636b 2070  d for fallback p",
            "+00000650: 7269 6e74 696e 6720 2a2f 0a23 696e 636c  rinting */.#incl",
            "+00000660: 7564 6520 3c61 7373 6572 742e 683e 202f  ude <assert.h> /",
            "+00000670: 2a20 6173 7365 7274 202a 2f0a 0a23 696e  * assert */..#in",
            "+00000680: 636c 7564 6520 2267 7269 7375 335f 6d61  clude \"grisu3_ma",
            "+00000690: 7468 2e68 220a 0a2f 2a0a 202a 2054 6865  th.h\"../*. * The",
            "+000006a0: 206c 6967 6874 7765 6967 6874 2022 706f   lightweight \"po",
            "+000006b0: 7274 6162 6c65 2220 4320 6c69 6272 6172  rtable\" C librar",
            "+000006c0: 7920 7265 636f 676e 697a 6573 2067 7269  y recognizes gri",
            "+000006d0: 7375 3320 7375 7070 6f72 7420 6966 0a20  su3 support if. ",
            "+000006e0: 2a20 696e 636c 7564 6564 2066 6972 7374  * included first",
            "+000006f0: 2e0a 202a 2f0a 2364 6566 696e 6520 6772  .. */.#define gr",
            "+00000700: 6973 7533 5f70 7269 6e74 5f64 6f75 626c  isu3_print_doubl",
            "+00000710: 655f 6973 5f64 6566 696e 6564 2031 0a0a  e_is_defined 1..",
            "+00000720: 2f2a 0a20 2a20 4e6f 7420 7375 7265 2077  /*. * Not sure w",
            "+00000730: 6520 6861 7665 2061 6e20 6578 6163 7420  e have an exact ",
            "+00000740: 6465 6669 6e69 7469 6f6e 2c20 6275 7420  definition, but ",
            "+00000750: 7765 2067 6574 2075 7020 746f 2032 330a  we get up to 23.",
            "+00000760: 202a 2065 6d70 6572 6963 616c 6c79 2e20   * emperically. ",
            "+00000770: 5468 6572 6520 6973 2073 6f6d 6520 6d61  There is some ma",
            "+00000780: 7468 2065 6e73 7572 696e 6720 6974 2064  th ensuring it d",
            "+00000790: 6f65 7320 6e6f 7420 676f 2061 776f 6c20  oes not go awol ",
            "+000007a0: 7468 6f75 6768 2c0a 202a 206c 696b 6520  though,. * like ",
            "+000007b0: 3138 2064 6967 6974 7320 2b20 6578 706f  18 digits + expo",
            "+000007c0: 6e65 6e74 206f 7220 736f 2e0a 202a 2054  nent or so.. * T",
            "+000007d0: 6869 7320 6d61 7820 7368 6f75 6c64 2062  his max should b",
            "+000007e0: 6520 7361 6665 2073 697a 6520 6275 6666  e safe size buff",
            "+000007f0: 6572 2066 6f72 2070 7269 6e74 696e 672c  er for printing,",
            "+00000800: 2069 6e63 6c75 6469 6e67 207a 6572 6f20   including zero ",
            "+00000810: 7465 726d 2e0a 202a 2f0a 2364 6566 696e  term.. */.#defin",
            "+00000820: 6520 4752 4953 5533 5f50 5249 4e54 5f4d  e GRISU3_PRINT_M",
            "+00000830: 4158 2033 300a 0a73 7461 7469 6320 696e  AX 30..static in",
            "+00000840: 7420 6772 6973 7533 5f72 6f75 6e64 5f77  t grisu3_round_w",
            "+00000850: 6565 6428 6368 6172 202a 6275 6666 6572  eed(char *buffer",
            "+00000860: 2c20 696e 7420 6c65 6e2c 2075 696e 7436  , int len, uint6",
            "+00000870: 345f 7420 7770 5f57 2c20 7569 6e74 3634  4_t wp_W, uint64",
            "+00000880: 5f74 2064 656c 7461 2c20 7569 6e74 3634  _t delta, uint64",
            "+00000890: 5f74 2072 6573 742c 2075 696e 7436 345f  _t rest, uint64_",
            "+000008a0: 7420 7465 6e5f 6b61 7070 612c 2075 696e  t ten_kappa, uin",
            "+000008b0: 7436 345f 7420 756c 7029 0a7b 0a20 2020  t64_t ulp).{.   ",
            "+000008c0: 2075 696e 7436 345f 7420 7770 5f57 7570   uint64_t wp_Wup",
            "+000008d0: 203d 2077 705f 5720 2d20 756c 703b 0a20   = wp_W - ulp;. ",
            "+000008e0: 2020 2075 696e 7436 345f 7420 7770 5f57     uint64_t wp_W",
            "+000008f0: 646f 776e 203d 2077 705f 5720 2b20 756c  down = wp_W + ul",
            "+00000900: 703b 0a20 2020 2077 6869 6c65 2872 6573  p;.    while(res",
            "+00000910: 7420 3c20 7770 5f57 7570 2026 2620 6465  t < wp_Wup && de",
            "+00000920: 6c74 6120 2d20 7265 7374 203e 3d20 7465  lta - rest >= te",
            "+00000930: 6e5f 6b61 7070 610a 2020 2020 2020 2020  n_kappa.        ",
            "+00000940: 2626 2028 7265 7374 202b 2074 656e 5f6b  && (rest + ten_k",
            "+00000950: 6170 7061 203c 2077 705f 5775 7020 7c7c  appa < wp_Wup ||",
            "+00000960: 2077 705f 5775 7020 2d20 7265 7374 203e   wp_Wup - rest >",
            "+00000970: 3d20 7265 7374 202b 2074 656e 5f6b 6170  = rest + ten_kap",
            "+00000980: 7061 202d 2077 705f 5775 7029 290a 2020  pa - wp_Wup)).  ",
            "+00000990: 2020 7b0a 2020 2020 2020 2020 2d2d 6275    {.        --bu",
            "+000009a0: 6666 6572 5b6c 656e 2d31 5d3b 0a20 2020  ffer[len-1];.   ",
            "+000009b0: 2020 2020 2072 6573 7420 2b3d 2074 656e       rest += ten",
            "+000009c0: 5f6b 6170 7061 3b0a 2020 2020 7d0a 2020  _kappa;.    }.  ",
            "+000009d0: 2020 6966 2028 7265 7374 203c 2077 705f    if (rest < wp_",
            "+000009e0: 5764 6f77 6e20 2626 2064 656c 7461 202d  Wdown && delta -",
            "+000009f0: 2072 6573 7420 3e3d 2074 656e 5f6b 6170   rest >= ten_kap",
            "+00000a00: 7061 0a20 2020 2020 2020 2026 2620 2872  pa.        && (r",
            "+00000a10: 6573 7420 2b20 7465 6e5f 6b61 7070 6120  est + ten_kappa ",
            "+00000a20: 3c20 7770 5f57 646f 776e 207c 7c20 7770  < wp_Wdown || wp",
            "+00000a30: 5f57 646f 776e 202d 2072 6573 7420 3e20  _Wdown - rest > ",
            "+00000a40: 7265 7374 202b 2074 656e 5f6b 6170 7061  rest + ten_kappa",
            "+00000a50: 202d 2077 705f 5764 6f77 6e29 290a 2020   - wp_Wdown)).  ",
            "+00000a60: 2020 2020 2020 7265 7475 726e 2030 3b0a        return 0;.",
            "+00000a70: 0a20 2020 2072 6574 7572 6e20 322a 756c  .    return 2*ul",
            "+00000a80: 7020 3c3d 2072 6573 7420 2626 2072 6573  p <= rest && res",
            "+00000a90: 7420 3c3d 2064 656c 7461 202d 2034 2a75  t <= delta - 4*u",
            "+00000aa0: 6c70 3b0a 7d0a 0a73 7461 7469 6320 696e  lp;.}..static in",
            "+00000ab0: 7420 6772 6973 7533 5f64 6967 6974 5f67  t grisu3_digit_g",
            "+00000ac0: 656e 2867 7269 7375 335f 6469 795f 6670  en(grisu3_diy_fp",
            "+00000ad0: 5f74 206c 6f77 2c20 6772 6973 7533 5f64  _t low, grisu3_d",
            "+00000ae0: 6979 5f66 705f 7420 772c 2067 7269 7375  iy_fp_t w, grisu",
            "+00000af0: 335f 6469 795f 6670 5f74 2068 6967 682c  3_diy_fp_t high,",
            "+00000b00: 2063 6861 7220 2a62 7566 6665 722c 2069   char *buffer, i",
            "+00000b10: 6e74 202a 6c65 6e67 7468 2c20 696e 7420  nt *length, int ",
            "+00000b20: 2a6b 6170 7061 290a 7b0a 2020 2020 7569  *kappa).{.    ui",
            "+00000b30: 6e74 3634 5f74 2075 6e69 7420 3d20 313b  nt64_t unit = 1;",
            "+00000b40: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "+00000b50: 6670 5f74 2074 6f6f 5f6c 6f77 203d 207b  fp_t too_low = {",
            "+00000b60: 206c 6f77 2e66 202d 2075 6e69 742c 206c   low.f - unit, l",
            "+00000b70: 6f77 2e65 207d 3b0a 2020 2020 6772 6973  ow.e };.    gris",
            "+00000b80: 7533 5f64 6979 5f66 705f 7420 746f 6f5f  u3_diy_fp_t too_",
            "+00000b90: 6869 6768 203d 207b 2068 6967 682e 6620  high = { high.f ",
            "+00000ba0: 2b20 756e 6974 2c20 6869 6768 2e65 207d  + unit, high.e }",
            "+00000bb0: 3b0a 2020 2020 6772 6973 7533 5f64 6979  ;.    grisu3_diy",
            "+00000bc0: 5f66 705f 7420 756e 7361 6665 5f69 6e74  _fp_t unsafe_int",
            "+00000bd0: 6572 7661 6c20 3d20 2067 7269 7375 335f  erval =  grisu3_",
            "+00000be0: 6469 795f 6670 5f6d 696e 7573 2874 6f6f  diy_fp_minus(too",
            "+00000bf0: 5f68 6967 682c 2074 6f6f 5f6c 6f77 293b  _high, too_low);",
            "+00000c00: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "+00000c10: 6670 5f74 206f 6e65 203d 207b 2031 554c  fp_t one = { 1UL",
            "+00000c20: 4c20 3c3c 202d 772e 652c 2077 2e65 207d  L << -w.e, w.e }",
            "+00000c30: 3b0a 2020 2020 7569 6e74 3332 5f74 2070  ;.    uint32_t p",
            "+00000c40: 3120 3d20 2875 696e 7433 325f 7429 2874  1 = (uint32_t)(t",
            "+00000c50: 6f6f 5f68 6967 682e 6620 3e3e 202d 6f6e  oo_high.f >> -on",
            "+00000c60: 652e 6529 3b0a 2020 2020 7569 6e74 3634  e.e);.    uint64",
            "+00000c70: 5f74 2070 3220 3d20 746f 6f5f 6869 6768  _t p2 = too_high",
            "+00000c80: 2e66 2026 2028 6f6e 652e 6620 2d20 3129  .f & (one.f - 1)",
            "+00000c90: 3b0a 2020 2020 7569 6e74 3332 5f74 2064  ;.    uint32_t d",
            "+00000ca0: 6976 3b0a 2020 2020 2a6b 6170 7061 203d  iv;.    *kappa =",
            "+00000cb0: 2067 7269 7375 335f 6c61 7267 6573 745f   grisu3_largest_",
            "+00000cc0: 706f 7731 3028 7031 2c20 4752 4953 5533  pow10(p1, GRISU3",
            "+00000cd0: 5f44 4959 5f46 505f 4652 4143 545f 5349  _DIY_FP_FRACT_SI",
            "+00000ce0: 5a45 202b 206f 6e65 2e65 2c20 2664 6976  ZE + one.e, &div",
            "+00000cf0: 293b 0a20 2020 202a 6c65 6e67 7468 203d  );.    *length =",
            "+00000d00: 2030 3b0a 0a20 2020 2077 6869 6c65 282a   0;..    while(*",
            "+00000d10: 6b61 7070 6120 3e20 3029 0a20 2020 207b  kappa > 0).    {",
            "+00000d20: 0a20 2020 2020 2020 2075 696e 7436 345f  .        uint64_",
            "+00000d30: 7420 7265 7374 3b0a 2020 2020 2020 2020  t rest;.        ",
            "+00000d40: 6368 6172 2064 6967 6974 203d 2028 6368  char digit = (ch",
            "+00000d50: 6172 2928 7031 202f 2064 6976 293b 0a20  ar)(p1 / div);. ",
            "+00000d60: 2020 2020 2020 2062 7566 6665 725b 2a6c         buffer[*l",
            "+00000d70: 656e 6774 685d 203d 2027 3027 202b 2064  ength] = '0' + d",
            "+00000d80: 6967 6974 3b0a 2020 2020 2020 2020 2b2b  igit;.        ++",
            "+00000d90: 2a6c 656e 6774 683b 0a20 2020 2020 2020  *length;.       ",
            "+00000da0: 2070 3120 253d 2064 6976 3b0a 2020 2020   p1 %= div;.    ",
            "+00000db0: 2020 2020 2d2d 2a6b 6170 7061 3b0a 2020      --*kappa;.  ",
            "+00000dc0: 2020 2020 2020 7265 7374 203d 2028 2875        rest = ((u",
            "+00000dd0: 696e 7436 345f 7429 7031 203c 3c20 2d6f  int64_t)p1 << -o",
            "+00000de0: 6e65 2e65 2920 2b20 7032 3b0a 2020 2020  ne.e) + p2;.    ",
            "+00000df0: 2020 2020 6966 2028 7265 7374 203c 2075      if (rest < u",
            "+00000e00: 6e73 6166 655f 696e 7465 7276 616c 2e66  nsafe_interval.f",
            "+00000e10: 2920 7265 7475 726e 2067 7269 7375 335f  ) return grisu3_",
            "+00000e20: 726f 756e 645f 7765 6564 2862 7566 6665  round_weed(buffe",
            "+00000e30: 722c 202a 6c65 6e67 7468 2c20 6772 6973  r, *length, gris",
            "+00000e40: 7533 5f64 6979 5f66 705f 6d69 6e75 7328  u3_diy_fp_minus(",
            "+00000e50: 746f 6f5f 6869 6768 2c20 7729 2e66 2c20  too_high, w).f, ",
            "+00000e60: 756e 7361 6665 5f69 6e74 6572 7661 6c2e  unsafe_interval.",
            "+00000e70: 662c 2072 6573 742c 2028 7569 6e74 3634  f, rest, (uint64",
            "+00000e80: 5f74 2964 6976 203c 3c20 2d6f 6e65 2e65  _t)div << -one.e",
            "+00000e90: 2c20 756e 6974 293b 0a20 2020 2020 2020  , unit);.       ",
            "+00000ea0: 2064 6976 202f 3d20 3130 3b0a 2020 2020   div /= 10;.    ",
            "+00000eb0: 7d0a 0a20 2020 2066 6f72 283b 3b29 0a20  }..    for(;;). ",
            "+00000ec0: 2020 207b 0a20 2020 2020 2020 2063 6861     {.        cha",
            "+00000ed0: 7220 6469 6769 743b 0a20 2020 2020 2020  r digit;.       ",
            "+00000ee0: 2070 3220 2a3d 2031 303b 0a20 2020 2020   p2 *= 10;.     ",
            "+00000ef0: 2020 2075 6e69 7420 2a3d 2031 303b 0a20     unit *= 10;. ",
            "+00000f00: 2020 2020 2020 2075 6e73 6166 655f 696e         unsafe_in",
            "+00000f10: 7465 7276 616c 2e66 202a 3d20 3130 3b0a  terval.f *= 10;.",
            "+00000f20: 2020 2020 2020 2020 2f2a 2049 6e74 6567          /* Integ",
            "+00000f30: 6572 2064 6976 6973 696f 6e20 6279 206f  er division by o",
            "+00000f40: 6e65 2e20 2a2f 0a20 2020 2020 2020 2064  ne. */.        d",
            "+00000f50: 6967 6974 203d 2028 6368 6172 2928 7032  igit = (char)(p2",
            "+00000f60: 203e 3e20 2d6f 6e65 2e65 293b 0a20 2020   >> -one.e);.   ",
            "+00000f70: 2020 2020 2062 7566 6665 725b 2a6c 656e       buffer[*len",
            "+00000f80: 6774 685d 203d 2027 3027 202b 2064 6967  gth] = '0' + dig",
            "+00000f90: 6974 3b0a 2020 2020 2020 2020 2b2b 2a6c  it;.        ++*l",
            "+00000fa0: 656e 6774 683b 0a20 2020 2020 2020 2070  ength;.        p",
            "+00000fb0: 3220 263d 206f 6e65 2e66 202d 2031 3b20  2 &= one.f - 1; ",
            "+00000fc0: 2f2a 204d 6f64 756c 6f20 6279 206f 6e65  /* Modulo by one",
            "+00000fd0: 2e20 2a2f 0a20 2020 2020 2020 202d 2d2a  . */.        --*",
            "+00000fe0: 6b61 7070 613b 0a20 2020 2020 2020 2069  kappa;.        i",
            "+00000ff0: 6620 2870 3220 3c20 756e 7361 6665 5f69  f (p2 < unsafe_i",
            "+00001000: 6e74 6572 7661 6c2e 6629 2072 6574 7572  nterval.f) retur",
            "+00001010: 6e20 6772 6973 7533 5f72 6f75 6e64 5f77  n grisu3_round_w",
            "+00001020: 6565 6428 6275 6666 6572 2c20 2a6c 656e  eed(buffer, *len",
            "+00001030: 6774 682c 2067 7269 7375 335f 6469 795f  gth, grisu3_diy_",
            "+00001040: 6670 5f6d 696e 7573 2874 6f6f 5f68 6967  fp_minus(too_hig",
            "+00001050: 682c 2077 292e 6620 2a20 756e 6974 2c20  h, w).f * unit, ",
            "+00001060: 756e 7361 6665 5f69 6e74 6572 7661 6c2e  unsafe_interval.",
            "+00001070: 662c 2070 322c 206f 6e65 2e66 2c20 756e  f, p2, one.f, un",
            "+00001080: 6974 293b 0a20 2020 207d 0a7d 0a0a 7374  it);.    }.}..st",
            "+00001090: 6174 6963 2069 6e74 2067 7269 7375 3328  atic int grisu3(",
            "+000010a0: 646f 7562 6c65 2076 2c20 6368 6172 202a  double v, char *",
            "+000010b0: 6275 6666 6572 2c20 696e 7420 2a6c 656e  buffer, int *len",
            "+000010c0: 6774 682c 2069 6e74 202a 645f 6578 7029  gth, int *d_exp)",
            "+000010d0: 0a7b 0a20 2020 2069 6e74 206d 6b2c 206b  .{.    int mk, k",
            "+000010e0: 6170 7061 2c20 7375 6363 6573 733b 0a20  appa, success;. ",
            "+000010f0: 2020 2067 7269 7375 335f 6469 795f 6670     grisu3_diy_fp",
            "+00001100: 5f74 2064 6670 203d 2067 7269 7375 335f  _t dfp = grisu3_",
            "+00001110: 6361 7374 5f64 6979 5f66 705f 6672 6f6d  cast_diy_fp_from",
            "+00001120: 5f64 6f75 626c 6528 7629 3b0a 2020 2020  _double(v);.    ",
            "+00001130: 6772 6973 7533 5f64 6979 5f66 705f 7420  grisu3_diy_fp_t ",
            "+00001140: 7720 3d20 6772 6973 7533 5f64 6979 5f66  w = grisu3_diy_f",
            "+00001150: 705f 6e6f 726d 616c 697a 6528 6466 7029  p_normalize(dfp)",
            "+00001160: 3b0a 0a20 2020 202f 2a20 6e6f 726d 616c  ;..    /* normal",
            "+00001170: 697a 6520 626f 756e 6461 7269 6573 202a  ize boundaries *",
            "+00001180: 2f0a 2020 2020 6772 6973 7533 5f64 6979  /.    grisu3_diy",
            "+00001190: 5f66 705f 7420 7420 3d20 7b20 2864 6670  _fp_t t = { (dfp",
            "+000011a0: 2e66 203c 3c20 3129 202b 2031 2c20 6466  .f << 1) + 1, df",
            "+000011b0: 702e 6520 2d20 3120 7d3b 0a20 2020 2067  p.e - 1 };.    g",
            "+000011c0: 7269 7375 335f 6469 795f 6670 5f74 2062  risu3_diy_fp_t b",
            "+000011d0: 5f70 6c75 7320 3d20 6772 6973 7533 5f64  _plus = grisu3_d",
            "+000011e0: 6979 5f66 705f 6e6f 726d 616c 697a 6528  iy_fp_normalize(",
            "+000011f0: 7429 3b0a 2020 2020 6772 6973 7533 5f64  t);.    grisu3_d",
            "+00001200: 6979 5f66 705f 7420 625f 6d69 6e75 733b  iy_fp_t b_minus;",
            "+00001210: 0a20 2020 2067 7269 7375 335f 6469 795f  .    grisu3_diy_",
            "+00001220: 6670 5f74 2063 5f6d 6b3b 202f 2a20 4361  fp_t c_mk; /* Ca",
            "+00001230: 6368 6564 2070 6f77 6572 206f 6620 7465  ched power of te",
            "+00001240: 6e3a 2031 305e 2d6b 202a 2f0a 2020 2020  n: 10^-k */.    ",
            "+00001250: 7569 6e74 3634 5f74 2075 3634 203d 2067  uint64_t u64 = g",
            "+00001260: 7269 7375 335f 6361 7374 5f75 696e 7436  risu3_cast_uint6",
            "+00001270: 345f 6672 6f6d 5f64 6f75 626c 6528 7629  4_from_double(v)",
            "+00001280: 3b0a 2020 2020 6173 7365 7274 2876 203e  ;.    assert(v >",
            "+00001290: 2030 2026 2620 7620 3c3d 2031 2e37 3937   0 && v <= 1.797",
            "+000012a0: 3639 3331 3334 3836 3233 3135 3765 3330  6931348623157e30",
            "+000012b0: 3829 3b20 2f2a 2047 7269 7375 206f 6e6c  8); /* Grisu onl",
            "+000012c0: 7920 6861 6e64 6c65 7320 7374 7269 6374  y handles strict",
            "+000012d0: 6c79 2070 6f73 6974 6976 6520 6669 6e69  ly positive fini",
            "+000012e0: 7465 206e 756d 6265 7273 2e20 2a2f 0a20  te numbers. */. ",
            "+000012f0: 2020 2069 6620 2821 2875 3634 2026 2047     if (!(u64 & G",
            "+00001300: 5249 5355 335f 4436 345f 4652 4143 545f  RISU3_D64_FRACT_",
            "+00001310: 4d41 534b 2920 2626 2028 7536 3420 2620  MASK) && (u64 & ",
            "+00001320: 4752 4953 5533 5f44 3634 5f45 5850 5f4d  GRISU3_D64_EXP_M",
            "+00001330: 4153 4b29 2021 3d20 3029 207b 2062 5f6d  ASK) != 0) { b_m",
            "+00001340: 696e 7573 2e66 203d 2028 6466 702e 6620  inus.f = (dfp.f ",
            "+00001350: 3c3c 2032 2920 2d20 313b 2062 5f6d 696e  << 2) - 1; b_min",
            "+00001360: 7573 2e65 203d 2020 6466 702e 6520 2d20  us.e =  dfp.e - ",
            "+00001370: 323b 7d20 2f2a 206c 6f77 6572 2062 6f75  2;} /* lower bou",
            "+00001380: 6e64 6172 7920 6973 2063 6c6f 7365 723f  ndary is closer?",
            "+00001390: 202a 2f0a 2020 2020 656c 7365 207b 2062   */.    else { b",
            "+000013a0: 5f6d 696e 7573 2e66 203d 2028 6466 702e  _minus.f = (dfp.",
            "+000013b0: 6620 3c3c 2031 2920 2d20 313b 2062 5f6d  f << 1) - 1; b_m",
            "+000013c0: 696e 7573 2e65 203d 2064 6670 2e65 202d  inus.e = dfp.e -",
            "+000013d0: 2031 3b20 7d0a 2020 2020 625f 6d69 6e75   1; }.    b_minu",
            "+000013e0: 732e 6620 3d20 625f 6d69 6e75 732e 6620  s.f = b_minus.f ",
            "+000013f0: 3c3c 2028 625f 6d69 6e75 732e 6520 2d20  << (b_minus.e - ",
            "+00001400: 625f 706c 7573 2e65 293b 0a20 2020 2062  b_plus.e);.    b",
            "+00001410: 5f6d 696e 7573 2e65 203d 2062 5f70 6c75  _minus.e = b_plu",
            "+00001420: 732e 653b 0a0a 2020 2020 6d6b 203d 2067  s.e;..    mk = g",
            "+00001430: 7269 7375 335f 6469 795f 6670 5f63 6163  risu3_diy_fp_cac",
            "+00001440: 6865 645f 706f 7728 4752 4953 5533 5f4d  hed_pow(GRISU3_M",
            "+00001450: 494e 5f54 4152 4745 545f 4558 5020 2d20  IN_TARGET_EXP - ",
            "+00001460: 4752 4953 5533 5f44 4959 5f46 505f 4652  GRISU3_DIY_FP_FR",
            "+00001470: 4143 545f 5349 5a45 202d 2077 2e65 2c20  ACT_SIZE - w.e, ",
            "+00001480: 2663 5f6d 6b29 3b0a 0a20 2020 2077 203d  &c_mk);..    w =",
            "+00001490: 2067 7269 7375 335f 6469 795f 6670 5f6d   grisu3_diy_fp_m",
            "+000014a0: 756c 7469 706c 7928 772c 2063 5f6d 6b29  ultiply(w, c_mk)",
            "+000014b0: 3b0a 2020 2020 625f 6d69 6e75 7320 3d20  ;.    b_minus = ",
            "+000014c0: 6772 6973 7533 5f64 6979 5f66 705f 6d75  grisu3_diy_fp_mu",
            "+000014d0: 6c74 6970 6c79 2862 5f6d 696e 7573 2c20  ltiply(b_minus, ",
            "+000014e0: 635f 6d6b 293b 0a20 2020 2062 5f70 6c75  c_mk);.    b_plu",
            "+000014f0: 7320 203d 2067 7269 7375 335f 6469 795f  s  = grisu3_diy_",
            "+00001500: 6670 5f6d 756c 7469 706c 7928 625f 706c  fp_multiply(b_pl",
            "+00001510: 7573 2c20 2063 5f6d 6b29 3b0a 0a20 2020  us,  c_mk);..   ",
            "+00001520: 2073 7563 6365 7373 203d 2067 7269 7375   success = grisu",
            "+00001530: 335f 6469 6769 745f 6765 6e28 625f 6d69  3_digit_gen(b_mi",
            "+00001540: 6e75 732c 2077 2c20 625f 706c 7573 2c20  nus, w, b_plus, ",
            "+00001550: 6275 6666 6572 2c20 6c65 6e67 7468 2c20  buffer, length, ",
            "+00001560: 266b 6170 7061 293b 0a20 2020 202a 645f  &kappa);.    *d_",
            "+00001570: 6578 7020 3d20 6b61 7070 6120 2d20 6d6b  exp = kappa - mk",
            "+00001580: 3b0a 2020 2020 7265 7475 726e 2073 7563  ;.    return suc",
            "+00001590: 6365 7373 3b0a 7d0a 0a73 7461 7469 6320  cess;.}..static ",
            "+000015a0: 696e 7420 6772 6973 7533 5f69 5f74 6f5f  int grisu3_i_to_",
            "+000015b0: 7374 7228 696e 7420 7661 6c2c 2063 6861  str(int val, cha",
            "+000015c0: 7220 2a73 7472 290a 7b0a 2020 2020 696e  r *str).{.    in",
            "+000015d0: 7420 6c65 6e2c 2069 3b0a 2020 2020 6368  t len, i;.    ch",
            "+000015e0: 6172 202a 733b 0a20 2020 2063 6861 7220  ar *s;.    char ",
            "+000015f0: 2a62 6567 696e 203d 2073 7472 3b0a 2020  *begin = str;.  ",
            "+00001600: 2020 6966 2028 7661 6c20 3c20 3029 207b    if (val < 0) {",
            "+00001610: 202a 7374 722b 2b20 3d20 272d 273b 2076   *str++ = '-'; v",
            "+00001620: 616c 203d 202d 7661 6c3b 207d 0a20 2020  al = -val; }.   ",
            "+00001630: 2073 203d 2073 7472 3b0a 0a20 2020 2066   s = str;..    f",
            "+00001640: 6f72 283b 3b29 0a20 2020 207b 0a20 2020  or(;;).    {.   ",
            "+00001650: 2020 2020 2069 6e74 206e 6920 3d20 7661       int ni = va",
            "+00001660: 6c20 2f20 3130 3b0a 2020 2020 2020 2020  l / 10;.        ",
            "+00001670: 696e 7420 6469 6769 7420 3d20 7661 6c20  int digit = val ",
            "+00001680: 2d20 6e69 2a31 303b 0a20 2020 2020 2020  - ni*10;.       ",
            "+00001690: 202a 732b 2b20 3d20 2863 6861 7229 2827   *s++ = (char)('",
            "+000016a0: 3027 202b 2064 6967 6974 293b 0a20 2020  0' + digit);.   ",
            "+000016b0: 2020 2020 2069 6620 286e 6920 3d3d 2030       if (ni == 0",
            "+000016c0: 290a 2020 2020 2020 2020 2020 2020 6272  ).            br",
            "+000016d0: 6561 6b3b 0a20 2020 2020 2020 2076 616c  eak;.        val",
            "+000016e0: 203d 206e 693b 0a20 2020 207d 0a20 2020   = ni;.    }.   ",
            "+000016f0: 202a 7320 3d20 275c 3027 3b0a 2020 2020   *s = '\\0';.    ",
            "+00001700: 6c65 6e20 3d20 2869 6e74 2928 7320 2d20  len = (int)(s - ",
            "+00001710: 7374 7229 3b0a 2020 2020 666f 7228 6920  str);.    for(i ",
            "+00001720: 3d20 303b 2069 203c 206c 656e 2f32 3b20  = 0; i < len/2; ",
            "+00001730: 2b2b 6929 0a20 2020 207b 0a20 2020 2020  ++i).    {.     ",
            "+00001740: 2020 2063 6861 7220 6368 203d 2073 7472     char ch = str",
            "+00001750: 5b69 5d3b 0a20 2020 2020 2020 2073 7472  [i];.        str",
            "+00001760: 5b69 5d20 3d20 7374 725b 6c65 6e2d 312d  [i] = str[len-1-",
            "+00001770: 695d 3b0a 2020 2020 2020 2020 7374 725b  i];.        str[",
            "+00001780: 6c65 6e2d 312d 695d 203d 2063 683b 0a20  len-1-i] = ch;. ",
            "+00001790: 2020 207d 0a0a 2020 2020 7265 7475 726e     }..    return",
            "+000017a0: 2028 696e 7429 2873 202d 2062 6567 696e   (int)(s - begin",
            "+000017b0: 293b 0a7d 0a0a 7374 6174 6963 2069 6e74  );.}..static int",
            "+000017c0: 2067 7269 7375 335f 7072 696e 745f 6e61   grisu3_print_na",
            "+000017d0: 6e28 7569 6e74 3634 5f74 2076 2c20 6368  n(uint64_t v, ch",
            "+000017e0: 6172 202a 6473 7429 0a7b 0a20 2020 2073  ar *dst).{.    s",
            "+000017f0: 7461 7469 6320 6368 6172 2068 6578 6469  tatic char hexdi",
            "+00001800: 6769 7473 5b31 365d 203d 2022 3031 3233  gits[16] = \"0123",
            "+00001810: 3435 3637 3839 4142 4344 4546 223b 0a20  456789ABCDEF\";. ",
            "+00001820: 2020 2069 6e74 2069 203d 2030 3b0a 0a20     int i = 0;.. ",
            "+00001830: 2020 2064 7374 5b30 5d20 3d20 274e 273b     dst[0] = 'N';",
            "+00001840: 0a20 2020 2064 7374 5b31 5d20 3d20 2761  .    dst[1] = 'a",
            "+00001850: 273b 0a20 2020 2064 7374 5b32 5d20 3d20  ';.    dst[2] = ",
            "+00001860: 274e 273b 0a20 2020 2064 7374 5b33 5d20  'N';.    dst[3] ",
            "+00001870: 3d20 2728 273b 0a20 2020 2064 7374 5b32  = '(';.    dst[2",
            "+00001880: 305d 203d 2027 2927 3b0a 2020 2020 6473  0] = ')';.    ds",
            "+00001890: 745b 3231 5d20 3d20 275c 3027 3b0a 2020  t[21] = '\\0';.  ",
            "+000018a0: 2020 6473 7420 2b3d 2034 3b0a 2020 2020    dst += 4;.    ",
            "+000018b0: 666f 7220 2869 203d 2031 353b 2069 203e  for (i = 15; i >",
            "+000018c0: 3d20 303b 202d 2d69 2920 7b0a 2020 2020  = 0; --i) {.    ",
            "+000018d0: 2020 2020 6473 745b 695d 203d 2068 6578      dst[i] = hex",
            "+000018e0: 6469 6769 7473 5b76 2026 2030 7830 465d  digits[v & 0x0F]",
            "+000018f0: 3b0a 2020 2020 2020 2020 7620 3e3e 3d20  ;.        v >>= ",
            "+00001900: 343b 0a20 2020 207d 0a20 2020 2072 6574  4;.    }.    ret",
            "+00001910: 7572 6e20 3231 3b0a 7d0a 0a73 7461 7469  urn 21;.}..stati",
            "+00001920: 6320 696e 7420 6772 6973 7533 5f70 7269  c int grisu3_pri",
            "+00001930: 6e74 5f64 6f75 626c 6528 646f 7562 6c65  nt_double(double",
            "+00001940: 2076 2c20 6368 6172 202a 6473 7429 0a7b   v, char *dst).{",
            "+00001950: 0a20 2020 2069 6e74 2064 5f65 7870 2c20  .    int d_exp, ",
            "+00001960: 6c65 6e2c 2073 7563 6365 7373 2c20 6465  len, success, de",
            "+00001970: 6369 6d61 6c73 2c20 693b 0a20 2020 2075  cimals, i;.    u",
            "+00001980: 696e 7436 345f 7420 7536 3420 3d20 6772  int64_t u64 = gr",
            "+00001990: 6973 7533 5f63 6173 745f 7569 6e74 3634  isu3_cast_uint64",
            "+000019a0: 5f66 726f 6d5f 646f 7562 6c65 2876 293b  _from_double(v);",
            "+000019b0: 0a20 2020 2063 6861 7220 2a73 3220 3d20  .    char *s2 = ",
            "+000019c0: 6473 743b 0a20 2020 2061 7373 6572 7428  dst;.    assert(",
            "+000019d0: 6473 7429 3b0a 0a20 2020 202f 2a20 5072  dst);..    /* Pr",
            "+000019e0: 6568 616e 646c 6520 4e61 4e73 202a 2f0a  ehandle NaNs */.",
            "+000019f0: 2020 2020 6966 2028 2875 3634 203c 3c20      if ((u64 << ",
            "+00001a00: 3129 203e 2030 7846 4645 3030 3030 3030  1) > 0xFFE000000",
            "+00001a10: 3030 3030 3030 3055 4c4c 2920 7265 7475  0000000ULL) retu",
            "+00001a20: 726e 2067 7269 7375 335f 7072 696e 745f  rn grisu3_print_",
            "+00001a30: 6e61 6e28 7536 342c 2064 7374 293b 0a20  nan(u64, dst);. ",
            "+00001a40: 2020 202f 2a20 5072 6568 616e 646c 6520     /* Prehandle ",
            "+00001a50: 6e65 6761 7469 7665 2076 616c 7565 732e  negative values.",
            "+00001a60: 202a 2f0a 2020 2020 6966 2028 2875 3634   */.    if ((u64",
            "+00001a70: 2026 2047 5249 5355 335f 4436 345f 5349   & GRISU3_D64_SI",
            "+00001a80: 474e 2920 213d 2030 2920 7b20 2a73 322b  GN) != 0) { *s2+",
            "+00001a90: 2b20 3d20 272d 273b 2076 203d 202d 763b  + = '-'; v = -v;",
            "+00001aa0: 2075 3634 205e 3d20 4752 4953 5533 5f44   u64 ^= GRISU3_D",
            "+00001ab0: 3634 5f53 4947 4e3b 207d 0a20 2020 202f  64_SIGN; }.    /",
            "+00001ac0: 2a20 5072 6568 616e 646c 6520 7a65 726f  * Prehandle zero",
            "+00001ad0: 2e20 2a2f 0a20 2020 2069 6620 2821 7536  . */.    if (!u6",
            "+00001ae0: 3429 207b 202a 7332 2b2b 203d 2027 3027  4) { *s2++ = '0'",
            "+00001af0: 3b20 2a73 3220 3d20 275c 3027 3b20 7265  ; *s2 = '\\0'; re",
            "+00001b00: 7475 726e 2028 696e 7429 2873 3220 2d20  turn (int)(s2 - ",
            "+00001b10: 6473 7429 3b20 7d0a 2020 2020 2f2a 2050  dst); }.    /* P",
            "+00001b20: 7265 6861 6e64 6c65 2069 6e66 696e 6974  rehandle infinit",
            "+00001b30: 792e 202a 2f0a 2020 2020 6966 2028 7536  y. */.    if (u6",
            "+00001b40: 3420 3d3d 2047 5249 5355 335f 4436 345f  4 == GRISU3_D64_",
            "+00001b50: 4558 505f 4d41 534b 2920 7b20 2a73 322b  EXP_MASK) { *s2+",
            "+00001b60: 2b20 3d20 2769 273b 202a 7332 2b2b 203d  + = 'i'; *s2++ =",
            "+00001b70: 2027 6e27 3b20 2a73 322b 2b20 3d20 2766   'n'; *s2++ = 'f",
            "+00001b80: 273b 202a 7332 203d 2027 5c30 273b 2072  '; *s2 = '\\0'; r",
            "+00001b90: 6574 7572 6e20 2869 6e74 2928 7332 202d  eturn (int)(s2 -",
            "+00001ba0: 2064 7374 293b 207d 0a0a 2020 2020 7375   dst); }..    su",
            "+00001bb0: 6363 6573 7320 3d20 6772 6973 7533 2876  ccess = grisu3(v",
            "+00001bc0: 2c20 7332 2c20 266c 656e 2c20 2664 5f65  , s2, &len, &d_e",
            "+00001bd0: 7870 293b 0a20 2020 202f 2a20 4966 2067  xp);.    /* If g",
            "+00001be0: 7269 7375 3320 7761 7320 6e6f 7420 6162  risu3 was not ab",
            "+00001bf0: 6c65 2074 6f20 636f 6e76 6572 7420 7468  le to convert th",
            "+00001c00: 6520 6e75 6d62 6572 2074 6f20 6120 7374  e number to a st",
            "+00001c10: 7269 6e67 2c20 7468 656e 2075 7365 206f  ring, then use o",
            "+00001c20: 6c64 2073 7072 696e 7466 2028 7375 626f  ld sprintf (subo",
            "+00001c30: 7074 696d 616c 292e 202a 2f0a 2020 2020  ptimal). */.    ",
            "+00001c40: 6966 2028 2173 7563 6365 7373 2920 7265  if (!success) re",
            "+00001c50: 7475 726e 2073 7072 696e 7466 2873 322c  turn sprintf(s2,",
            "+00001c60: 2022 252e 3137 6722 2c20 7629 202b 2028   \"%.17g\", v) + (",
            "+00001c70: 696e 7429 2873 3220 2d20 6473 7429 3b0a  int)(s2 - dst);.",
            "+00001c80: 0a20 2020 202f 2a20 5765 206e 6f77 2068  .    /* We now h",
            "+00001c90: 6176 6520 616e 2069 6e74 6567 6572 2073  ave an integer s",
            "+00001ca0: 7472 696e 6720 6f66 2066 6f72 6d20 2231  tring of form \"1",
            "+00001cb0: 3531 3332 3431 3335 2220 616e 6420 6120  51324135\" and a ",
            "+00001cc0: 6261 7365 2d31 3020 6578 706f 6e65 6e74  base-10 exponent",
            "+00001cd0: 2066 6f72 2074 6861 7420 6e75 6d62 6572   for that number",
            "+00001ce0: 2e20 2a2f 0a20 2020 202f 2a20 4e65 7874  . */.    /* Next",
            "+00001cf0: 2c20 6465 6369 6465 2074 6865 2062 6573  , decide the bes",
            "+00001d00: 7420 7072 6573 656e 7461 7469 6f6e 2066  t presentation f",
            "+00001d10: 6f72 2074 6861 7420 7374 7269 6e67 2062  or that string b",
            "+00001d20: 7920 7768 6574 6865 7220 746f 2075 7365  y whether to use",
            "+00001d30: 2061 2064 6563 696d 616c 2070 6f69 6e74   a decimal point",
            "+00001d40: 2c20 6f72 2074 6865 2073 6369 656e 7469  , or the scienti",
            "+00001d50: 6669 6320 6578 706f 6e65 6e74 1020 6e6f  fic exponent. no",
            "+00001d60: 7461 7469 6f6e 2027 6527 2e20 2a2f 0a20  tation 'e'. */. ",
            "+00001d70: 2020 202f 2a20 5765 2064 6f6e 2774 2070     /* We don't p",
            "+00001d80: 6963 6b20 7468 6520 6162 736f 6c75 7465  ick the absolute",
            "+00001d90: 2073 686f 7274 6573 7420 7265 7072 6573   shortest repres",
            "+00001da0: 656e 7461 7469 6f6e 2c20 6275 7420 7069  entation, but pi",
            "+00001db0: 636b 2061 2062 616c 616e 6365 2062 6574  ck a balance bet",
            "+00001dc0: 7765 656e 2072 6561 6461 6269 6c69 7479  ween readability",
            "+00001dd0: 2061 6e64 2073 686f 7274 6e65 7373 2c20   and shortness, ",
            "+00001de0: 652e 672e 202a 2f0a 2020 2020 2f2a 2031  e.g. */.    /* 1",
            "+00001df0: 2e35 3435 3035 3631 3839 3535 3736 3737  .545056189557677",
            "+00001e00: 652d 3330 3820 636f 756c 6420 6265 2072  e-308 could be r",
            "+00001e10: 6570 7265 7365 6e74 6564 2069 6e20 6120  epresented in a ",
            "+00001e20: 7368 6f72 7465 7220 666f 726d 202a 2f0a  shorter form */.",
            "+00001e30: 2020 2020 2f2a 2031 3534 3530 3536 3138      /* 154505618",
            "+00001e40: 3935 3537 3637 3765 2d33 3233 2062 7574  9557677e-323 but",
            "+00001e50: 2074 6861 7420 776f 756c 6420 6265 2073   that would be s",
            "+00001e60: 6f6d 6577 6861 7420 756e 7265 6164 6162  omewhat unreadab",
            "+00001e70: 6c65 2e20 2a2f 0a20 2020 2064 6563 696d  le. */.    decim",
            "+00001e80: 616c 7320 3d20 4752 4953 5533 5f4d 494e  als = GRISU3_MIN",
            "+00001e90: 282d 645f 6578 702c 2047 5249 5355 335f  (-d_exp, GRISU3_",
            "+00001ea0: 4d41 5828 312c 206c 656e 2d31 2929 3b0a  MAX(1, len-1));.",
            "+00001eb0: 0a20 2020 202f 2a20 6d69 6b6b 656c 666a  .    /* mikkelfj",
            "+00001ec0: 3a0a 2020 2020 202a 2066 6978 207a 6572  :.     * fix zer",
            "+00001ed0: 6f20 7072 6566 6978 202e 3120 3d3e 2030  o prefix .1 => 0",
            "+00001ee0: 2e31 2c20 696d 706f 7274 616e 7420 666f  .1, important fo",
            "+00001ef0: 7220 4a53 4f4e 2065 7870 6f72 742e 0a20  r JSON export.. ",
            "+00001f00: 2020 2020 2a20 7072 6566 6572 2075 6e73      * prefer uns",
            "+00001f10: 6369 656e 7469 6669 6320 6e6f 7461 7469  cientific notati",
            "+00001f20: 6f6e 2061 7420 7361 6d65 206c 656e 6774  on at same lengt",
            "+00001f30: 683a 0a20 2020 2020 2a20 2d31 2e32 3334  h:.     * -1.234",
            "+00001f40: 3565 2d34 206f 7665 7220 2d31 2e30 3030  5e-4 over -1.000",
            "+00001f50: 3132 3334 352c 0a20 2020 2020 2a20 2d31  12345,.     * -1",
            "+00001f60: 2e30 3031 3233 3435 206f 7665 7220 2d31  .0012345 over -1",
            "+00001f70: 2e32 3334 3565 2d33 0a20 2020 2020 2a2f  .2345e-3.     */",
            "+00001f80: 0a20 2020 2069 6620 2864 5f65 7870 203c  .    if (d_exp <",
            "+00001f90: 2030 2026 2620 286c 656e 202b 2064 5f65   0 && (len + d_e",
            "+00001fa0: 7870 2920 3e20 2d33 2026 2620 6c65 6e20  xp) > -3 && len ",
            "+00001fb0: 3c3d 202d 645f 6578 7029 0a20 2020 207b  <= -d_exp).    {",
            "+00001fc0: 0a20 2020 2020 2020 202f 2a20 6d69 6b6b  .        /* mikk",
            "+00001fd0: 656c 666a 3a20 6669 7820 7a65 726f 2070  elfj: fix zero p",
            "+00001fe0: 7265 6669 7820 2e31 203d 3e20 302e 312c  refix .1 => 0.1,",
            "+00001ff0: 2061 6e64 2073 686f 7274 2065 7870 6f6e   and short expon",
            "+00002000: 656e 7473 2031 2e33 652d 3220 3d3e 2030  ents 1.3e-2 => 0",
            "+00002010: 2e30 3133 2e20 2a2f 0a20 2020 2020 2020  .013. */.       ",
            "+00002020: 206d 656d 6d6f 7665 2873 3220 2b20 3220   memmove(s2 + 2 ",
            "+00002030: 2d20 645f 6578 7020 2d20 6c65 6e2c 2073  - d_exp - len, s",
            "+00002040: 322c 2028 7369 7a65 5f74 296c 656e 293b  2, (size_t)len);",
            "+00002050: 0a20 2020 2020 2020 2073 325b 305d 203d  .        s2[0] =",
            "+00002060: 2027 3027 3b0a 2020 2020 2020 2020 7332   '0';.        s2",
            "+00002070: 5b31 5d20 3d20 272e 273b 0a20 2020 2020  [1] = '.';.     ",
            "+00002080: 2020 2066 6f72 2028 6920 3d20 323b 2069     for (i = 2; i",
            "+00002090: 203c 2032 2d64 5f65 7870 2d6c 656e 3b20   < 2-d_exp-len; ",
            "+000020a0: 2b2b 6929 2073 325b 695d 203d 2027 3027  ++i) s2[i] = '0'",
            "+000020b0: 3b0a 2020 2020 2020 2020 6c65 6e20 2b3d  ;.        len +=",
            "+000020c0: 2069 3b0a 2020 2020 7d0a 2020 2020 656c   i;.    }.    el",
            "+000020d0: 7365 2069 6620 2864 5f65 7870 203c 2030  se if (d_exp < 0",
            "+000020e0: 2026 2620 6c65 6e20 3e20 3129 202f 2a20   && len > 1) /* ",
            "+000020f0: 4164 6420 6465 6369 6d61 6c20 706f 696e  Add decimal poin",
            "+00002100: 743f 202a 2f0a 2020 2020 7b0a 2020 2020  t? */.    {.    ",
            "+00002110: 2020 2020 666f 7228 6920 3d20 303b 2069      for(i = 0; i",
            "+00002120: 203c 2064 6563 696d 616c 733b 202b 2b69   < decimals; ++i",
            "+00002130: 2920 7332 5b6c 656e 2d69 5d20 3d20 7332  ) s2[len-i] = s2",
            "+00002140: 5b6c 656e 2d69 2d31 5d3b 0a20 2020 2020  [len-i-1];.     ",
            "+00002150: 2020 2073 325b 6c65 6e2b 2b20 2d20 6465     s2[len++ - de",
            "+00002160: 6369 6d61 6c73 5d20 3d20 272e 273b 0a20  cimals] = '.';. ",
            "+00002170: 2020 2020 2020 2064 5f65 7870 202b 3d20         d_exp += ",
            "+00002180: 6465 6369 6d61 6c73 3b0a 2020 2020 2020  decimals;.      ",
            "+00002190: 2020 2f2a 204e 6565 6420 7363 6965 6e74    /* Need scient",
            "+000021a0: 6966 6963 206e 6f74 6174 696f 6e20 6173  ific notation as",
            "+000021b0: 2077 656c 6c3f 202a 2f0a 2020 2020 2020   well? */.      ",
            "+000021c0: 2020 6966 2028 645f 6578 7020 213d 2030    if (d_exp != 0",
            "+000021d0: 2920 7b20 7332 5b6c 656e 2b2b 5d20 3d20  ) { s2[len++] = ",
            "+000021e0: 2765 273b 206c 656e 202b 3d20 6772 6973  'e'; len += gris",
            "+000021f0: 7533 5f69 5f74 6f5f 7374 7228 645f 6578  u3_i_to_str(d_ex",
            "+00002200: 702c 2073 322b 6c65 6e29 3b20 7d0a 2020  p, s2+len); }.  ",
            "+00002210: 2020 7d0a 2020 2020 2f2a 2041 6464 2073    }.    /* Add s",
            "+00002220: 6369 656e 7469 6669 6320 6e6f 7461 7469  cientific notati",
            "+00002230: 6f6e 3f20 2a2f 0a20 2020 2065 6c73 6520  on? */.    else ",
            "+00002240: 6966 2028 645f 6578 7020 3c20 3020 7c7c  if (d_exp < 0 ||",
            "+00002250: 2064 5f65 7870 203e 2032 2920 7b20 7332   d_exp > 2) { s2",
            "+00002260: 5b6c 656e 2b2b 5d20 3d20 2765 273b 206c  [len++] = 'e'; l",
            "+00002270: 656e 202b 3d20 6772 6973 7533 5f69 5f74  en += grisu3_i_t",
            "+00002280: 6f5f 7374 7228 645f 6578 702c 2073 322b  o_str(d_exp, s2+",
            "+00002290: 6c65 6e29 3b20 7d0a 2020 2020 2f2a 2041  len); }.    /* A",
            "+000022a0: 6464 207a 6572 6f65 7320 696e 7374 6561  dd zeroes instea",
            "+000022b0: 6420 6f66 2073 6369 656e 7469 6669 6320  d of scientific ",
            "+000022c0: 6e6f 7461 7469 6f6e 3f20 2a2f 0a20 2020  notation? */.   ",
            "+000022d0: 2065 6c73 6520 6966 2028 645f 6578 7020   else if (d_exp ",
            "+000022e0: 3e20 3029 207b 2077 6869 6c65 2864 5f65  > 0) { while(d_e",
            "+000022f0: 7870 2d2d 203e 2030 2920 7332 5b6c 656e  xp-- > 0) s2[len",
            "+00002300: 2b2b 5d20 3d20 2730 273b 207d 0a20 2020  ++] = '0'; }.   ",
            "+00002310: 2073 325b 6c65 6e5d 203d 2027 5c30 273b   s2[len] = '\\0';",
            "+00002320: 202f 2a20 6772 6973 7533 2064 6f65 736e   /* grisu3 doesn",
            "+00002330: 2774 206e 756c 6c20 7465 726d 696e 6174  't null terminat",
            "+00002340: 652c 2073 6f20 656e 7375 7265 2074 6572  e, so ensure ter",
            "+00002350: 6d69 6e61 7469 6f6e 2e20 2a2f 0a20 2020  mination. */.   ",
            "+00002360: 2072 6574 7572 6e20 2869 6e74 2928 7332   return (int)(s2",
            "+00002370: 2b6c 656e 2d64 7374 293b 0a7d 0a0a 2369  +len-dst);.}..#i",
            "+00002380: 6664 6566 205f 5f63 706c 7573 706c 7573  fdef __cplusplus",
            "+00002390: 0a7d 0a23 656e 6469 660a 0a23 656e 6469  .}.#endif..#endi",
            "+000023a0: 6620 2f2a 2047 5249 5355 335f 5052 494e  f /* GRISU3_PRIN",
            "+000023b0: 545f 4820 2a2f 0a                        T_H */."
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/paligned_alloc.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/paligned_alloc.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/paligned_alloc.h",
            "@@ -6,14 +6,18 @@",
            " ",
            " /*",
            "  * NOTE: MSVC in general has no aligned alloc function that is",
            "  * compatible with free and it is not trivial to implement a version",
            "  * which is. Therefore, to remain portable, end user code needs to",
            "  * use `aligned_free` which is not part of C11 but defined in this header.",
            "  *",
            "+ * glibc only provides aligned_alloc when _ISOC11_SOURCE is defined, but",
            "+ * MingW does not support aligned_alloc despite of this, it uses the",
            "+ * the _aligned_malloc as MSVC.",
            "+ *",
            "  * The same issue is present on some Unix systems not providing",
            "  * posix_memalign.",
            "  *",
            "  * Note that clang and gcc with -std=c11 or -std=c99 will not define",
            "  * _POSIX_C_SOURCE and thus posix_memalign cannot be detected but",
            "  * aligned_alloc is not necessarily available either. We assume",
            "  * that clang always has posix_memalign although it is not strictly",
            "@@ -37,16 +41,24 @@",
            " ",
            " #if 0",
            " #define PORTABLE_DEBUG_ALIGNED_ALLOC",
            " #endif",
            " ",
            " #if !defined(PORTABLE_C11_ALIGNED_ALLOC)",
            " ",
            "-#if defined (_ISOC11_SOURCE)",
            "-/* glibc aligned_alloc detection. */",
            "+/*",
            "+ * PORTABLE_C11_ALIGNED_ALLOC = 1",
            "+ * indicates that the system has builtin aligned_alloc",
            "+ * If it doesn't, the section after detection provides an implemention.",
            "+ */",
            "+#if defined (__MINGW32__)",
            "+/* MingW does not provide aligned_alloc despite defining _ISOC11_SOURCE */",
            "+#define PORTABLE_C11_ALIGNED_ALLOC 0",
            "+#elif defined (_ISOC11_SOURCE) ",
            "+/* glibc aligned_alloc detection, but MingW is not truthful */",
            " #define PORTABLE_C11_ALIGNED_ALLOC 1",
            " #elif defined (__GLIBC__)",
            " /* aligned_alloc is not available in glibc just because __STDC_VERSION__ >= 201112L. */",
            " #define PORTABLE_C11_ALIGNED_ALLOC 0",
            " #elif defined (__clang__)",
            " #define PORTABLE_C11_ALIGNED_ALLOC 0",
            " #elif defined(__IBMC__)",
            "@@ -56,51 +68,72 @@",
            " #else",
            " #define PORTABLE_C11_ALIGNED_ALLOC 0",
            " #endif",
            " ",
            " #endif /* PORTABLE_C11_ALIGNED_ALLOC */",
            " ",
            " /* https://linux.die.net/man/3/posix_memalign */",
            "-#if !defined(PORTABLE_POSIX_MEMALIGN)",
            "+#if !defined(PORTABLE_POSIX_MEMALIGN) && defined(_GNU_SOURCE)",
            "+#define PORTABLE_POSIX_MEMALIGN 1",
            "+#endif",
            " ",
            " /* https://forum.kde.org/viewtopic.php?p=66274 */",
            "-#if (defined _GNU_SOURCE) || ((_XOPEN_SOURCE + 0) >= 600) || (_POSIX_C_SOURCE + 0) >= 200112L ",
            "+#if !defined(PORTABLE_POSIX_MEMALIGN) && defined(_XOPEN_SOURCE)",
            "+#if _XOPEN_SOURCE >= 600",
            " #define PORTABLE_POSIX_MEMALIGN 1",
            "-#elif (__clang__)",
            "+#endif",
            "+#endif",
            "+",
            "+#if !defined(PORTABLE_POSIX_MEMALIGN) && defined(_POSIX_C_SOURCE)",
            "+#if _POSIX_C_SOURCE >= 200112L",
            " #define PORTABLE_POSIX_MEMALIGN 1",
            "-#else",
            "+#endif",
            "+#endif",
            "+",
            "+#if !defined(PORTABLE_POSIX_MEMALIGN) && defined(__clang__)",
            "+#define PORTABLE_POSIX_MEMALIGN 1",
            "+#endif",
            "+",
            "+#if !defined(PORTABLE_POSIX_MEMALIGN)",
            " #define PORTABLE_POSIX_MEMALIGN 0",
            " #endif",
            "-#endif /* PORTABLE_POSIX_MEMALIGN */",
            " ",
            " /* https://forum.kde.org/viewtopic.php?p=66274 */",
            " #if (defined(__STDC__) && __STDC__ && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L)",
            " /* C11 or newer */",
            " #include <stdalign.h>",
            " #endif",
            " ",
            " /* C11 or newer */",
            " #if !defined(aligned_alloc) && !defined(__aligned_alloc_is_defined)",
            " ",
            " #if PORTABLE_C11_ALIGNED_ALLOC",
            " #ifdef PORTABLE_DEBUG_ALIGNED_ALLOC",
            " #error \"DEBUG: C11_ALIGNED_ALLOC configured\"",
            " #endif",
            "-#elif defined(_MSC_VER)",
            "+#elif defined(_MSC_VER) || defined(__MINGW32__)",
            "+",
            "+#ifdef PORTABLE_DEBUG_ALIGNED_ALLOC",
            "+#error \"DEBUG: Windows _aligned_malloc configured\"",
            "+#endif",
            " ",
            " /* Aligned _aligned_malloc is not compatible with free. */",
            " #define aligned_alloc(alignment, size) _aligned_malloc(size, alignment)",
            " #define aligned_free(p) _aligned_free(p)",
            " #define __aligned_alloc_is_defined 1",
            " #define __aligned_free_is_defined 1",
            " ",
            " #elif PORTABLE_POSIX_MEMALIGN",
            " ",
            "-#if defined(__GNUC__) && __GNUCC__ < 5",
            "+#if defined(__GNUC__)",
            "+#if !defined(__GNUCC__)",
            " extern int posix_memalign (void **, size_t, size_t);",
            "+#elif __GNUCC__ < 5",
            "+extern int posix_memalign (void **, size_t, size_t);",
            "+#endif",
            " #endif",
            " ",
            " static inline void *__portable_aligned_alloc(size_t alignment, size_t size)",
            " {",
            "     int err;",
            "     void *p = 0;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pbase64.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pbase64.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pbase64.h",
            "@@ -20,15 +20,15 @@",
            " /* Unsupported mode, or modifier not supported by mode when encoding. */",
            " #define BASE64_EMODE  3",
            " /* Decoding ends at invalid tail length - either by source length or by non-alphabet symbol. */",
            " #define BASE64_ETAIL  4",
            " /* Decoding ends at valid tail length but last byte has non-zero bits where it shouldn't have. */",
            " #define BASE64_EDIRTY 5",
            " ",
            "-static const char *base64_strerror(int err);",
            "+static inline const char *base64_strerror(int err);",
            " ",
            " /* All codecs are URL safe. Only Crockford allow for non-canocical decoding. */",
            " enum {",
            "     /* Most common base64 codec, but not url friendly. */",
            "     base64_mode_rfc4648 = 0,",
            " ",
            "     /*  URL safe version, '+' -> '-', '/' -> '_'. */",
            "@@ -44,22 +44,22 @@",
            "     base64_enc_modifier_padding = 128,",
            " ",
            "     /* For internal use or to decide codec of mode. */",
            "     base64_modifier_mask = 32 + 64 + 128,",
            " };",
            " ",
            " /* Encoded size with or without padding. */",
            "-static size_t base64_encoded_size(size_t len, int mode);",
            "+static inline size_t base64_encoded_size(size_t len, int mode);",
            " ",
            " /*",
            "  * Decoded size assuming no padding.",
            "  * If `len` does include padding, the actual size may be less",
            "  * when decoding, but never more.",
            "  */",
            "-static size_t base64_decoded_size(size_t len);",
            "+static inline size_t base64_decoded_size(size_t len);",
            " ",
            " /*",
            "  * `dst` must hold ceil(len * 4 / 3) bytes.",
            "  * `src_len` points to length of source and is updated with length of",
            "  * parse on both success and failure. If `dst_len` is not null",
            "  * it is used to store resulting output lengt withh length of decoded",
            "  * output on both success and failure.",
            "@@ -72,15 +72,15 @@",
            "  * padding character '='. The following characters will work as",
            "  * terminator for all modes: { '\\0', '\\n', ' ', '\\t' }. A terminator is",
            "  * optional when the source length is given to the decoder. Note that",
            "  * crockford also reserves a few extra characters for checksum but the",
            "  * checksum must be separate from the main buffer and is not supported",
            "  * by this library.",
            "  */",
            "-static int base64_encode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode);",
            "+static inline int base64_encode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode);",
            " ",
            " /*",
            "  * Decodes according to mode while ignoring encoding modifiers.",
            "  * `src_len` and `dst_len` are optional pointers. If `src_len` is set it",
            "  * must contain the length of the input, otherwise the input must be",
            "  * terminated with a non-alphabet character or valid padding (a single",
            "  * padding character is accepted) - if the src_len output is needed but",
            "@@ -92,30 +92,30 @@",
            "  * and decoded length, when present, on both success and failure.",
            "  * Returns 0 on success. Invalid characters are not considered errors -",
            "  * they simply terminate the parse, however, if the termination is not",
            "  * at a block multiple or a valid partial block length then BASE64_ETAIL",
            "  * without output holding the last full block, if any. BASE64_ETAIL is also",
            "  * returned if the a valid length holds non-zero unused tail bits.",
            "  */",
            "-static int base64_decode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode);",
            "+static inline int base64_decode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode);",
            " ",
            "-static const char *base64_strerror(int err)",
            "+static inline const char *base64_strerror(int err)",
            " {",
            "     switch (err) {",
            "     case BASE64_EOK: return \"ok\";",
            "     case BASE64_EARGS: return \"invalid argument\";",
            "     case BASE64_EMODE: return \"invalid mode\";",
            "     case BASE64_EMORE: return \"destination full\";",
            "     case BASE64_ETAIL: return \"invalid tail length\";",
            "     case BASE64_EDIRTY: return \"invalid tail content\";",
            "     default: return \"unknown error\";",
            "     }",
            " }",
            " ",
            "-static size_t base64_encoded_size(size_t len, int mode)",
            "+static inline size_t base64_encoded_size(size_t len, int mode)",
            " {",
            "     size_t k = len % 3;",
            "     size_t n = (len * 4 / 3 + 3) & ~(size_t)3;",
            "     int pad = mode & base64_enc_modifier_padding;",
            " ",
            "     if (!pad) {",
            "         switch (k) {",
            "@@ -128,15 +128,15 @@",
            "         default:",
            "             break;",
            "         }",
            "     }",
            "     return n;",
            " }",
            " ",
            "-static size_t base64_decoded_size(size_t len)",
            "+static inline size_t base64_decoded_size(size_t len)",
            " {",
            "     size_t k = len % 4;",
            "     size_t n = len / 4 * 3;",
            " ",
            "     switch (k) {",
            "     case 3:",
            "         return n + 2;",
            "@@ -145,15 +145,15 @@",
            "     case 1: /* Not valid without padding. */",
            "     case 0:",
            "     default:",
            "         return n;",
            "     }",
            " }",
            " ",
            "-static int base64_encode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode)",
            "+static inline int base64_encode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode)",
            " {",
            "     const uint8_t *rfc4648_alphabet            = (const uint8_t *)",
            "         \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
            "     const uint8_t *url_alphabet                = (const uint8_t *)",
            "         \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";",
            " ",
            "     const uint8_t *T;",
            "@@ -215,23 +215,23 @@",
            "     default:",
            "         pad = 0;",
            "         break;",
            "     }",
            "     len = 0;",
            " done:",
            "     if (dst_len) {",
            "-        *dst_len = dst - dst_base;",
            "+        *dst_len = (size_t)(dst - dst_base);",
            "     }",
            "     if (src_len) {",
            "         *src_len -= len;",
            "     }",
            "     return ret;",
            " }",
            " ",
            "-static int base64_decode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode)",
            "+static inline int base64_decode(uint8_t *dst, const uint8_t *src, size_t *dst_len, size_t *src_len, int mode)",
            " {",
            "     static const uint8_t cinvalid = 64;",
            "     static const uint8_t cignore = 65;",
            "     static const uint8_t cpadding = 66;",
            " ",
            "     /*",
            "      * 0..63: 6-bit encoded value.",
            "@@ -380,26 +380,26 @@",
            "                 len -= i;",
            "                 goto tail;",
            "             }",
            "         }",
            "         if (limit < 3) {",
            "             goto more;",
            "         }",
            "-        dst[0] = (hold[0] << 2) | (hold[1] >> 4);",
            "-        dst[1] = (hold[1] << 4) | (hold[2] >> 2);",
            "-        dst[2] = (hold[2] << 6) | (hold[3]);",
            "+        dst[0] = (uint8_t)((hold[0] << 2) | (hold[1] >> 4));",
            "+        dst[1] = (uint8_t)((hold[1] << 4) | (hold[2] >> 2));",
            "+        dst[2] = (uint8_t)((hold[2] << 6) | (hold[3]));",
            "         dst += 3;",
            "         src += 4;",
            "         limit -= 3;",
            "         len -= 4;",
            "         mark = len;",
            "     }",
            " done:",
            "     if (dst_len) {",
            "-        *dst_len = dst - dst_base;",
            "+        *dst_len = (size_t)(dst - dst_base);",
            "     }",
            "     if (src_len) {",
            "         *src_len -= mark;",
            "     }",
            "     return ret;",
            " ",
            " tail:",
            "@@ -409,26 +409,26 @@",
            "     case 2:",
            "         if ((hold[1] << 4) & 0xff) {",
            "             goto dirty;",
            "         }",
            "         if (limit < 1) {",
            "             goto more;",
            "         }",
            "-        dst[0] = (hold[0] << 2) | (hold[1] >> 4);",
            "+        dst[0] = (uint8_t)((hold[0] << 2) | (hold[1] >> 4));",
            "         dst += 1;",
            "         break;",
            "     case 3:",
            "         if ((hold[2] << 6) & 0xff) {",
            "             goto dirty;",
            "         }",
            "         if (limit < 2) {",
            "             goto more;",
            "         }",
            "-        dst[0] = (hold[0] << 2) | (hold[1] >> 4);",
            "-        dst[1] = (hold[1] << 4) | (hold[2] >> 2);",
            "+        dst[0] = (uint8_t)((hold[0] << 2) | (hold[1] >> 4));",
            "+        dst[1] = (uint8_t)((hold[1] << 4) | (hold[2] >> 2));",
            "         dst += 2;",
            "         break;",
            "     default:",
            "         ret = BASE64_ETAIL;",
            "         goto done;",
            "     }",
            "     mark = len;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pdiagnostic.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pdiagnostic.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pdiagnostic.h",
            "@@ -14,23 +14,36 @@",
            "  * Alternatively use #include \"pdiagnostic_push/pop.h\"",
            "  */",
            " ",
            " #ifdef _MSC_VER",
            " #pragma warning(disable: 4668) /* preprocessor name not defined */",
            " #endif",
            " ",
            "-#if defined(_MSC_VER) && !defined(PDIAGNOSTIC_AWARE_MSVC)",
            "+#if !defined(PDIAGNOSTIC_AWARE_MSVC) && defined(_MSC_VER)",
            " #define PDIAGNOSTIC_AWARE_MSVC 1",
            "-#elif defined(__clang__) && !defined(PDIAGNOSTIC_AWARE_CLANG)",
            "+#elif !defined(PDIAGNOSTIC_AWARE_MSVC)",
            "+#define PDIAGNOSTIC_AWARE_MSVC 0",
            "+#endif",
            "+",
            "+#if !defined(PDIAGNOSTIC_AWARE_CLANG) && defined(__clang__)",
            " #define PDIAGNOSTIC_AWARE_CLANG 1",
            "+#elif !defined(PDIAGNOSTIC_AWARE_CLANG)",
            "+#define PDIAGNOSTIC_AWARE_CLANG 0",
            "+#endif",
            "+",
            "+#if !defined(PDIAGNOSTIC_AWARE_GCC) && defined(__GNUC__) && !defined(__clang__)",
            " /* Can disable some warnings even if push is not available (gcc-4.2 vs gcc-4.7) */",
            "-#elif ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)) && \\",
            "-        !defined(PDIAGNOSTIC_AWARE_GCC)",
            "+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)",
            " #define PDIAGNOSTIC_AWARE_GCC 1",
            " #endif",
            "+#endif",
            "+",
            "+#if !defined(PDIAGNOSTIC_AWARE_GCC)",
            "+#define PDIAGNOSTIC_AWARE_GCC 0",
            "+#endif",
            " ",
            " #if defined(PDIAGNOSTIC_IGNORE_UNUSED_FUNCTION) || defined(PDIAGNOSTIC_IGNORE_UNUSED)",
            " #if PDIAGNOSTIC_AWARE_CLANG",
            " #pragma clang diagnostic ignored \"-Wunused-function\"",
            " #elif PDIAGNOSTIC_AWARE_GCC",
            " #pragma GCC diagnostic ignored \"-Wunused-function\"",
            " #endif"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pdiagnostic_pop.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pdiagnostic_pop.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pdiagnostic_pop.h",
            "@@ -1,15 +1,20 @@",
            "-#ifndef PDIAGNOSTIC_POP_H",
            "-#define PDIAGNOSTIC_POP_H",
            "-",
            "+#if defined(PDIAGNOSTIC_PUSHED_MSVC)",
            " #if PDIAGNOSTIC_PUSHED_MSVC",
            " #pragma warning( pop )",
            "+#endif // PDIAGNOSTIC_PUSHED_MSVC",
            " #undef PDIAGNOSTIC_PUSHED_MSVC",
            "-#elif PDIAGNOSTIC_PUSHED_CLANG",
            "+#endif // defined(PDIAGNOSTIC_PUSHED_MSVC)",
            "+",
            "+#if defined(PDIAGNOSTIC_PUSHED_CLANG)",
            "+#if PDIAGNOSTIC_PUSHED_CLANG",
            " #pragma clang diagnostic pop",
            "+#endif // PDIAGNOSTIC_PUSHED_CLANG",
            " #undef PDIAGNOSTIC_PUSHED_CLANG",
            "-#elif PDIAGNOSTIC_PUSHED_GCC",
            "+#endif // defined(PDIAGNOSTIC_PUSHED_CLANG)",
            "+",
            "+#if defined(PDIAGNOSTIC_PUSHED_GCC)",
            "+#if PDIAGNOSTIC_PUSHED_GCC",
            " #pragma GCC diagnostic pop",
            "+#endif // PDIAGNOSTIC_PUSHED_GCC",
            " #undef PDIAGNOSTIC_PUSHED_GCC",
            "-#endif",
            "-",
            "-#endif /* PDIAGNOSTIC_POP_H */",
            "+#endif // defined(PDIAGNOSTIC_PUSHED_GCC)"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pdiagnostic_push.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pdiagnostic_push.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pdiagnostic_push.h",
            "@@ -1,10 +1,7 @@",
            "-#ifndef PDIAGNOSTIC_PUSH_H",
            "-#define PDIAGNOSTIC_PUSH_H",
            "-",
            " /*",
            "  * See also comment in \"pdiagnostic.h\"",
            "  *",
            "  * e.g.",
            "  * #define PDIAGNOSTIC_IGNORE_USED_FUNCTION",
            "  * #define PDIAGNOSTIC_IGNORE_USED_VARIABLE",
            "  * #include \"pdiagnostic_push\"",
            "@@ -25,22 +22,30 @@",
            "  * Use compiler switches like -Wno-unused-function",
            "  * to work around this.",
            "  */",
            " ",
            " #if defined(_MSC_VER)",
            " #pragma warning( push )",
            " #define PDIAGNOSTIC_PUSHED_MSVC 1",
            "-#elif defined(__clang__)",
            "+#else",
            "+#define PDIAGNOSTIC_PUSHED_MSVC 0",
            "+#endif",
            "+",
            "+#if defined(__clang__)",
            " #pragma clang diagnostic push",
            " #define PDIAGNOSTIC_PUSHED_CLANG 1",
            "-#elif ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))",
            "-#pragma GCC diagnostic push",
            "-#define PDIAGNOSTIC_PUSHED_GCC 1",
            "+#else",
            "+#define PDIAGNOSTIC_PUSHED_CLANG 0",
            " #endif",
            " ",
            "-#endif /* PDIAGNOSTIC_PUSH_H */",
            "+#if defined(__GNUC__) && !defined(__clang__)",
            "+#if ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))",
            "+#pragma GCC diagnostic push",
            "+#define PDIAGNOSTIC_PUSHED_GCC 1",
            "+#else",
            "+#define PDIAGNOSTIC_PUSHED_GCC 0",
            "+#endif // GNUC >= 4.6",
            "+#else",
            "+#define PDIAGNOSTIC_PUSHED_GCC 0",
            "+#endif // defined(__GNUC__) && !defined(__clang__)",
            " ",
            "-/*",
            "- * We cannot handle nested push, but we can add to the parent context",
            "- * so keep this outside the header include guard.",
            "- */",
            " #include \"pdiagnostic.h\""
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pendian.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pendian.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pendian.h",
            "@@ -33,42 +33,63 @@",
            "  * used with typesafe wrappers.",
            "  */",
            " ",
            " #ifndef UINT8_MAX",
            " #include \"pstdint.h\"",
            " #endif",
            " ",
            "+#if defined(__linux__)",
            "+#include <endian.h>",
            "+#elif defined(__OpenBSD__) || defined(__FreeBSD__)",
            "+#include <sys/endian.h>",
            "+#endif",
            "+",
            " #include \"pendian_detect.h\"",
            " ",
            " #if defined(_MSC_VER)",
            " #if _MSC_VER >= 1300",
            " #include <stdlib.h>",
            " #define bswap16 _byteswap_ushort",
            " #define bswap32 _byteswap_ulong",
            " #define bswap64 _byteswap_uint64",
            " #endif",
            " #elif defined(__clang__)",
            " #if __has_builtin(__builtin_bswap16)",
            "+#ifndef bswap16",
            " #define bswap16 __builtin_bswap16",
            " #endif",
            "+#endif",
            " #if __has_builtin(__builtin_bswap32)",
            "+#ifndef bswap32",
            " #define bswap32 __builtin_bswap32",
            " #endif",
            "+#endif",
            " #if __has_builtin(__builtin_bswap64)",
            "+#ifndef bswap64",
            " #define bswap64 __builtin_bswap64",
            " #endif",
            "-#elif defined(__OpenBSD__)",
            "-#include <sys/endian.h>",
            "+#endif",
            "+#elif defined(__OpenBSD__) || defined(__FreeBSD__)",
            "+#ifndef bswap16",
            " #define bswap16 swap16",
            "+#endif",
            "+#ifndef bswap32",
            " #define bswap32 swap32",
            "+#endif",
            "+#ifndef bswap64",
            " #define bswap64 swap64",
            "+#endif",
            " #elif defined(__GNUC__)  /* Supported since at least GCC 4.4 */",
            "+#ifndef bswap32",
            " #define bswap32 __builtin_bswap32",
            "+#endif",
            "+#ifndef bswap64",
            " #define bswap64 __builtin_bswap64",
            " #endif",
            "+#endif",
            " ",
            " #ifndef bswap16",
            " #define bswap16(v)                                                          \\",
            "       (((uint16_t)(v) << 8) | ((uint16_t)(v) >> 8))",
            " #endif",
            " ",
            " #ifndef bswap32"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pparsefp.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pparsefp.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pparsefp.h",
            "@@ -39,16 +39,28 @@",
            " #if defined(__GNUC__) || defined(__clang__) || defined(_MSC_VER) || defined(PORTABLE_USE_ISINF)",
            " #include <math.h>",
            " #if defined(_MSC_VER) && !defined(isinf)",
            " #include <float.h>",
            " #define isnan _isnan",
            " #define isinf(x) (!_finite(x))",
            " #endif",
            "+/*",
            "+ * clang-5 through clang-8 but not clang-9 issues incorrect precision",
            "+ * loss warning with -Wconversion flag when cast is absent.",
            "+ */",
            "+#if defined(__clang__)",
            "+#if __clang_major__ >= 5 && __clang_major__ <= 8",
            "+#define parse_double_isinf(x) isinf((float)x)",
            "+#endif",
            "+#endif",
            "+#if !defined(parse_double_isinf)",
            " #define parse_double_isinf isinf",
            "+#endif",
            " #define parse_float_isinf isinf",
            "+",
            " #else",
            " ",
            " #ifndef UINT8_MAX",
            " #include <stdint.h>",
            " #endif",
            " ",
            " /* Avoid linking with libmath but depends on float/double being IEEE754 */",
            "@@ -83,31 +95,31 @@",
            " #endif",
            " ",
            " #if PORTABLE_USE_GRISU3",
            " #include \"grisu3_parse.h\"",
            " #endif",
            " ",
            " #ifdef grisu3_parse_double_is_defined",
            "-static inline const char *parse_double(const char *buf, int len, double *result)",
            "+static inline const char *parse_double(const char *buf, size_t len, double *result)",
            " {",
            "     return grisu3_parse_double(buf, len, result);",
            " }",
            " #else",
            " #include <stdio.h>",
            "-static inline const char *parse_double(const char *buf, int len, double *result)",
            "+static inline const char *parse_double(const char *buf, size_t len, double *result)",
            " {",
            "     char *end;",
            " ",
            "     (void)len;",
            "     *result = strtod(buf, &end);",
            "     return end;",
            " }",
            " #endif",
            " ",
            "-static inline const char *parse_float(const char *buf, int len, float *result)",
            "+static inline const char *parse_float(const char *buf, size_t len, float *result)",
            " {",
            "     const char *end;",
            "     double v;",
            "     union { uint32_t u32; float f32; } inf;",
            "     inf.u32 = 0x7f800000;",
            " ",
            "     end = parse_double(buf, len, &v);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pparseint.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pparseint.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pparseint.h",
            "@@ -5,15 +5,15 @@",
            " extern \"C\" {",
            " #endif",
            " ",
            " /*",
            "  * Type specific integer parsers:",
            "  *",
            "  *     const char *",
            "- *     parse_<type-name>(const char *buf, int len, <type> *value, int *status);",
            "+ *     parse_<type-name>(const char *buf, size_t len, <type> *value, int *status);",
            "  *",
            "  *     parse_uint64, parse_int64",
            "  *     parse_uint32, parse_int32",
            "  *     parse_uint16, parse_int16",
            "  *     parse_uint8, parse_int8",
            "  *     parse_ushort,  parse_short",
            "  *     parse_uint, parse_int",
            "@@ -70,15 +70,15 @@",
            "  * differs from parse_uint64 by being able to return a negative",
            "  * UINT64_MAX successfully.",
            "  *",
            "  * This parser is used by all type specific integer parsers.",
            "  *",
            "  * Status argument can be null.",
            "  */",
            "-static const char *parse_integer(const char *buf, int len, uint64_t *value, int *status)",
            "+static const char *parse_integer(const char *buf, size_t len, uint64_t *value, int *status)",
            " {",
            "     uint64_t x0, x = 0;",
            "     const char *k, *end = buf + len;",
            "     int sign, status_;",
            " ",
            "     if (!status) {",
            "         status = &status_;",
            "@@ -88,15 +88,15 @@",
            "         return buf;",
            "     }",
            "     k = buf;",
            "     sign = *buf == '-';",
            "     buf += sign;",
            "     while (buf != end && *buf >= '0' && *buf <= '9') {",
            "         x0 = x;",
            "-        x = x * 10 + *buf - '0';",
            "+        x = x * 10 + (uint64_t)(*buf - '0');",
            "         if (x0 > x) {",
            "             *status = sign ? PARSE_INTEGER_UNDERFLOW : PARSE_INTEGER_OVERFLOW;",
            "             return 0;",
            "         }",
            "         ++buf;",
            "     }",
            "     if (buf == k) {",
            "@@ -119,15 +119,15 @@",
            "     return buf;",
            " }",
            " ",
            " /*",
            "  * Parse hex values like 0xff, -0xff, 0XdeAdBeaf42, cannot be trailed by '.', 'p', or 'P'.",
            "  * Overflows if string is more than 16 valid hex digits. Otherwise similar to parse_integer.",
            "  */",
            "-static const char *parse_hex_integer(const char *buf, int len, uint64_t *value, int *status)",
            "+static const char *parse_hex_integer(const char *buf, size_t len, uint64_t *value, int *status)",
            " {",
            "     uint64_t x = 0;",
            "     const char *k, *k2, *end = buf + len;",
            "     int sign, status_;",
            "     unsigned char c;",
            " ",
            "     if (!status) {",
            "@@ -146,15 +146,15 @@",
            "     buf += 2;",
            "     k = buf;",
            "     k2 = end;",
            "     if (end - buf > 16) {",
            "         k2 = buf + 16;",
            "     }",
            "     while (buf != k2) {",
            "-        c = *buf;",
            "+        c = (unsigned char)*buf;",
            "         if (c >= '0' && c <= '9') {",
            "             x = x * 16 + c - '0';",
            "         } else {",
            "             /* Lower case. */",
            "             c |= 0x20;",
            "             if (c >= 'a' && c <= 'f') {",
            "                 x = x * 16 + c - 'a' + 10;",
            "@@ -173,15 +173,15 @@",
            "             *status = PARSE_INTEGER_UNMATCHED;",
            "             return buf;",
            "         }",
            "     }",
            "     if (buf == end) {",
            "         goto done;",
            "     }",
            "-    c = *buf;",
            "+    c = (unsigned char)*buf;",
            "     if (buf == k2) {",
            "         if (c >= '0' && c <= '9') {",
            "             *status = sign ? PARSE_INTEGER_UNDERFLOW : PARSE_INTEGER_OVERFLOW;",
            "             return 0;",
            "         }",
            "         c |= 0x20;",
            "         if (c >= 'a' && c <= 'f') {",
            "@@ -199,15 +199,15 @@",
            "     *status = sign;",
            "     return buf;",
            " }",
            " ",
            " ",
            " #define __portable_define_parse_unsigned(NAME, TYPE, LIMIT)                 \\",
            " static inline const char *parse_ ## NAME                                    \\",
            "-        (const char *buf, int len, TYPE *value, int *status)                \\",
            "+        (const char *buf, size_t len, TYPE *value, int *status)             \\",
            " {                                                                           \\",
            "     int status_ = 0;                                                        \\",
            "     uint64_t x;                                                             \\",
            "                                                                             \\",
            "     if (!status) {                                                          \\",
            "         status = &status_;                                                  \\",
            "     }                                                                       \\",
            "@@ -226,15 +226,15 @@",
            "     default:                                                                \\",
            "         return buf;                                                         \\",
            "     }                                                                       \\",
            " }",
            " ",
            " #define __portable_define_parse_hex_unsigned(NAME, TYPE, LIMIT)             \\",
            " static inline const char *parse_hex_ ## NAME                                \\",
            "-        (const char *buf, int len, TYPE *value, int *status)                \\",
            "+        (const char *buf, size_t len, TYPE *value, int *status)             \\",
            " {                                                                           \\",
            "     int status_ = 0;                                                        \\",
            "     uint64_t x;                                                             \\",
            "                                                                             \\",
            "     if (!status) {                                                          \\",
            "         status = &status_;                                                  \\",
            "     }                                                                       \\",
            "@@ -254,15 +254,15 @@",
            "         return buf;                                                         \\",
            "     }                                                                       \\",
            " }",
            " ",
            " /* This assumes two's complement. */",
            " #define __portable_define_parse_signed(NAME, TYPE, LIMIT)                   \\",
            " static inline const char *parse_ ## NAME                                    \\",
            "-        (const char *buf, int len, TYPE *value, int *status)                \\",
            "+        (const char *buf, size_t len, TYPE *value, int *status)             \\",
            " {                                                                           \\",
            "     int status_ = 0;                                                        \\",
            "     uint64_t x;                                                             \\",
            "                                                                             \\",
            "     if (!status) {                                                          \\",
            "         status = &status_;                                                  \\",
            "     }                                                                       \\",
            "@@ -286,15 +286,15 @@",
            "         return buf;                                                         \\",
            "     }                                                                       \\",
            " }",
            " ",
            " /* This assumes two's complement. */",
            " #define __portable_define_parse_hex_signed(NAME, TYPE, LIMIT)               \\",
            " static inline const char *parse_hex_ ## NAME                                \\",
            "-        (const char *buf, int len, TYPE *value, int *status)                \\",
            "+        (const char *buf, size_t len, TYPE *value, int *status)             \\",
            " {                                                                           \\",
            "     int status_ = 0;                                                        \\",
            "     uint64_t x;                                                             \\",
            "                                                                             \\",
            "     if (!status) {                                                          \\",
            "         status = &status_;                                                  \\",
            "     }                                                                       \\",
            "@@ -315,25 +315,25 @@",
            "         *status = PARSE_INTEGER_UNDERFLOW;                                  \\",
            "         return 0;                                                           \\",
            "     default:                                                                \\",
            "         return buf;                                                         \\",
            "     }                                                                       \\",
            " }",
            " ",
            "-static inline const char *parse_uint64(const char *buf, int len, uint64_t *value, int *status)",
            "+static inline const char *parse_uint64(const char *buf, size_t len, uint64_t *value, int *status)",
            " {",
            "     buf = parse_integer(buf, len, value, status);",
            "     if (*status == PARSE_INTEGER_SIGNED) {",
            "         *status = PARSE_INTEGER_UNDERFLOW;",
            "         return 0;",
            "     }",
            "     return buf;",
            " }",
            " ",
            "-static inline const char *parse_hex_uint64(const char *buf, int len, uint64_t *value, int *status)",
            "+static inline const char *parse_hex_uint64(const char *buf, size_t len, uint64_t *value, int *status)",
            " {",
            "     buf = parse_hex_integer(buf, len, value, status);",
            "     if (*status == PARSE_INTEGER_SIGNED) {",
            "         *status = PARSE_INTEGER_UNDERFLOW;",
            "         return 0;",
            "     }",
            "     return buf;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pprintint.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pprintint.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pprintint.h",
            "@@ -71,14 +71,16 @@",
            " extern \"C\" {",
            " #endif",
            " ",
            " #ifndef UINT8_MAX",
            " #include <stdint.h>",
            " #endif",
            " ",
            "+#include \"pattributes.h\" /* fallthrough */",
            "+",
            " #define PDIAGNOSTIC_IGNORE_UNUSED_FUNCTION",
            " #include \"pdiagnostic_push.h\"",
            " ",
            " static int print_bool(int n, char *p);",
            " ",
            " static int print_uint8(uint8_t n, char *p);",
            " static int print_uint16(uint16_t n, char *p);",
            "@@ -144,25 +146,25 @@",
            " {",
            "     const char *dp;",
            " ",
            "     if (n >= 100) {",
            "         p += 3;",
            "         *p = '\\0';",
            "         __print_stage();",
            "-        p[-1] = n + '0';",
            "+        p[-1] = (char)n + '0';",
            "         return 3;",
            "     }",
            "     if (n >= 10) {",
            "         p += 2;",
            "         *p = '\\0';",
            "         __print_stage();",
            "         return 2;",
            "     }",
            "     p[1] = '\\0';",
            "-    p[0] = n + '0';",
            "+    p[0] = (char)n + '0';",
            "     return 1;",
            " }",
            " ",
            " static int print_uint16(uint16_t n, char *p)",
            " {",
            "     int k = 0;",
            "     const char *dp;",
            "@@ -181,31 +183,29 @@",
            "         } else {",
            "             k = 1;",
            "         }",
            "     }",
            "     p += k;",
            "     *p = '\\0';",
            "     if (k & 1) {",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (k) {",
            "         case 5:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 3:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 1:",
            "-            p[-1] = n + '0';",
            "+            p[-1] = (char)n + '0';",
            "         }",
            "     } else {",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (k) {",
            "         case 4:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 2:",
            "             __print_stage();",
            "         }",
            "     }",
            "     return k;",
            " }",
            " ",
            "@@ -246,49 +246,46 @@",
            "                 k = 1UL;",
            "             }",
            "         }",
            "     }",
            "     p += k;",
            "     *p = '\\0';",
            "     if (k & 1) {",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (k) {",
            "         case 9:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 7:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 5:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 3:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 1:",
            "-            p[-1] = n + '0';",
            "+            p[-1] = (char)n + '0';",
            "         }",
            "     } else {",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (k) {",
            "         case 10:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 8:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 6:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 4:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 2:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "         }",
            "     }",
            "     return k;",
            " }",
            " ",
            " static int print_uint64(uint64_t n, char *p)",
            " {",
            "@@ -335,50 +332,48 @@",
            "                 k = 1 + 9;",
            "             }",
            "         }",
            "     }",
            "     p += k;",
            "     *p = '\\0';",
            "     if (k & 1) {",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (k) {",
            "         case 19:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 17:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 15:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 13:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 11:",
            "             __print_stage()",
            "             __print_short_stage();",
            "         }",
            "     } else {",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (k) {",
            "         case 20:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 18:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 16:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 14:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 12:",
            "             __print_stage();",
            "-\t    /* Fall through */",
            "+\t    pattribute(fallthrough);",
            "         case 10:",
            "             __print_stage();",
            "         }",
            "     }",
            "     __print_long_stage()",
            "     __print_long_stage()",
            "     return k;",
            "@@ -388,48 +383,48 @@",
            " {",
            "     int sign;",
            " ",
            "     if ((sign = n < 0)) {",
            "         *p++ = '-';",
            "         n = -n;",
            "     }",
            "-    return print_uint8(n, p) + sign;",
            "+    return print_uint8((uint8_t)n, p) + sign;",
            " }",
            " ",
            " static int print_int16(int16_t n, char *p)",
            " {",
            "     int sign;",
            " ",
            "     if ((sign = n < 0)) {",
            "         *p++ = '-';",
            "         n = -n;",
            "     }",
            "-    return print_uint16(n, p) + sign;",
            "+    return print_uint16((uint16_t)n, p) + sign;",
            " }",
            " ",
            " static int print_int32(int32_t n, char *p)",
            " {",
            "     int sign;",
            " ",
            "     if ((sign = n < 0)) {",
            "         *p++ = '-';",
            "         n = -n;",
            "     }",
            "-    return print_uint32(n, p) + sign;",
            "+    return print_uint32((uint32_t)n, p) + sign;",
            " }",
            " ",
            " static int print_int64(int64_t n, char *p)",
            " {",
            "     int sign;",
            " ",
            "     if ((sign = n < 0)) {",
            "         *p++ = '-';",
            "         n = -n;",
            "     }",
            "-    return print_uint64(n, p) + sign;",
            "+    return print_uint64((uint64_t)n, p) + sign;",
            " }",
            " ",
            " #define __define_print_int_simple(NAME, UNAME, T, UT)                       \\",
            " static int UNAME(UT n, char *buf)                                           \\",
            " {                                                                           \\",
            "     char tmp[20];                                                           \\",
            "     char* p = tmp + 20;                                                     \\",
            "@@ -449,15 +444,15 @@",
            "         ++p;                                                                \\",
            "     }                                                                       \\",
            "     k = (unsigned int)(q - p);                                              \\",
            "     while (p != q) {                                                        \\",
            "         *buf++ = *p++;                                                      \\",
            "     }                                                                       \\",
            "     *buf = '\\0';                                                            \\",
            "-    return k;                                                               \\",
            "+    return (int)k;                                                          \\",
            " }                                                                           \\",
            "                                                                             \\",
            " static int NAME(T n, char *buf)                                             \\",
            " {                                                                           \\",
            "     int sign = n < 0;                                                       \\",
            "                                                                             \\",
            "     if (sign) {                                                             \\"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/portable/pstdalign.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/portable/pstdalign.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/portable/pstdalign.h",
            "@@ -7,14 +7,17 @@",
            "  * free also works on C11 and platforms with posix_memalign.",
            "  *",
            "  * NOTE: C++11 defines alignas as a keyword but then also defines",
            "  * __alignas_is_defined.",
            "  *",
            "  * C++14 does not define __alignas_is_defined, at least sometimes.",
            "  *",
            "+ * GCC 8.3 reverts on this and makes C++11 behave the same as C++14",
            "+ * preventing a simple __cplusplus version check from working.",
            "+ *",
            "  * Clang C++ without std=c++11 or std=c++14 does define alignas",
            "  * but does so incorrectly wrt. C11 and C++11 semantics because",
            "  * `alignas(4) float x;` is not recognized.",
            "  * To fix such issues, either move to a std version, or",
            "  * include a working stdalign.h for the given compiler before",
            "  * this file.",
            "  *",
            "@@ -23,33 +26,47 @@",
            "  * stdalign is not included.",
            "  *",
            "  * newlibs need for <stdalign.h> conflicts with broken C++ stdalign",
            "  * but this can be fixed be using std=C++11 or newer.",
            "  *",
            "  * MSVC does not support <stdalign.h> at least up to MSVC 2015,",
            "  * but does appear to support alignas and alignof keywords in",
            "- * recent standard C++. ",
            "+ * recent standard C++.",
            "+ *",
            "+ * TCC only supports alignas with a numeric argument like",
            "+ * `alignas(4)`, but not `alignas(float)`.",
            "  *",
            "  * If stdalign.h is supported but heuristics in this file are",
            "  * insufficient to detect this, try including <stdaligh.h> manually",
            "  * or define HAVE_STDALIGN_H.",
            "  */",
            " ",
            "+/* https://github.com/dvidelabs/flatcc/issues/130 */",
            "+#ifndef __alignas_is_defined",
            "+#if defined(__cplusplus)",
            "+#if __cplusplus == 201103 && !defined(__clang__) && ((__GNUC__ > 8) || (__GNUC__ == 8 && __GNUC_MINOR__ >= 3))",
            "+#define __alignas_is_defined 1",
            "+#define __alignof_is_defined 1",
            "+#include <stdalign.h>",
            "+#endif",
            "+#endif",
            "+#endif",
            "+",
            " /* Allow for alternative solution to be included first. */",
            " #ifndef __alignas_is_defined",
            " ",
            " #ifdef __cplusplus",
            " #if defined(PORTABLE_PATCH_CPLUSPLUS_STDALIGN)",
            " #include <stdalign.h>",
            " #undef alignas",
            " #define alignas(t) __attribute__((__aligned__(t)))",
            " #endif",
            " #endif",
            " ",
            "-#if !defined PORTABLE_HAS_INCLUDE_STDALIGN",
            "+#if !defined(PORTABLE_HAS_INCLUDE_STDALIGN)",
            " #if defined(__has_include)",
            " #if __has_include(<stdalign.h>)",
            " #define PORTABLE_HAS_INCLUDE_STDALIGN 1",
            " #else",
            " #define PORTABLE_HAS_INCLUDE_STDALIGN 0",
            " #endif",
            " #endif",
            "@@ -107,14 +124,20 @@",
            " #endif",
            " ",
            " #elif defined(_MSC_VER)",
            " ",
            " #define _Alignas(t) __declspec (align(t))",
            " #define _Alignof(t) __alignof(t)",
            " ",
            "+#elif defined(__TINYC__)",
            "+",
            "+/* Supports `_Alignas(integer-expression)`, but not `_Alignas(type)`. */",
            "+#define _Alignas(t) __attribute__(aligned(t))",
            "+#define _Alignof(t) __alignof__(t)",
            "+",
            " #else",
            " #error please update pstdalign.h with support for current compiler and library",
            " #endif",
            " ",
            " #endif /* __STDC__ */",
            " ",
            " #ifndef alignas"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/reflection/flatbuffers_common_builder.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/reflection/flatbuffers_common_builder.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/reflection/flatbuffers_common_builder.h",
            "@@ -1,11 +1,11 @@",
            " #ifndef FLATBUFFERS_COMMON_BUILDER_H",
            " #define FLATBUFFERS_COMMON_BUILDER_H",
            " ",
            "-/* Generated by flatcc 0.5.3 FlatBuffers schema compiler for C by dvide.com */",
            "+/* Generated by flatcc 0.6.1 FlatBuffers schema compiler for C by dvide.com */",
            " ",
            " /* Common FlatBuffers build functionality for C. */",
            " ",
            " #include \"flatcc/flatcc_prologue.h\"",
            " #ifndef FLATBUILDER_H",
            " #include \"flatcc/flatcc_builder.h\"",
            " #endif",
            "@@ -325,33 +325,43 @@",
            " { __flatbuffers_memoize(B, string, flatcc_builder_create_string(B, string, NS ## string_len(string))); }\\",
            " static inline NS ## string_ref_t NS ## string_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\\",
            " { size_t n = NS ## string_len(string); if (index >= n) index = n; n -= index; if (len > n) len = n;\\",
            "   return flatcc_builder_create_string(B, string + index, len); }\\",
            " __flatbuffers_build_string_ops(NS, NS ## string)\\",
            " __flatbuffers_build_offset_vector(NS, NS ## string)",
            " ",
            "-#define __flatbuffers_copy_from_pe(P, P2, N) (*(P) = N ## _cast_from_pe(*P2), (P))",
            "-#define __flatbuffers_from_pe(P, N) (*(P) = N ## _cast_from_pe(*P), (P))",
            "-#define __flatbuffers_copy_to_pe(P, P2, N) (*(P) = N ## _cast_to_pe(*P2), (P))",
            "-#define __flatbuffers_to_pe(P, N) (*(P) = N ## _cast_to_pe(*P), (P))",
            "+#define __flatbuffers_copy_from_pe(P, P2, N) (*(P) = N ## _read_from_pe(P2), (P))",
            "+#define __flatbuffers_from_pe(P, N) (*(P) = N ## _read_from_pe(P), (P))",
            "+#define __flatbuffers_copy_to_pe(P, P2, N) (N ## _write_to_pe((P), *(P2)), (P))",
            "+#define __flatbuffers_to_pe(P, N) (N ## _write_to_pe((P), *(P)), (P))",
            "+#define __flatbuffers_define_fixed_array_primitives(NS, N, T)\\",
            "+static inline T *N ## _array_copy(T *p, const T *p2, size_t n)\\",
            "+{ memcpy(p, p2, n * sizeof(T)); return p; }\\",
            "+static inline T *N ## _array_copy_from_pe(T *p, const T *p2, size_t n)\\",
            "+{ size_t i; if (NS ## is_native_pe()) memcpy(p, p2, n * sizeof(T)); else\\",
            "+  for (i = 0; i < n; ++i) N ## _copy_from_pe(&p[i], &p2[i]); return p; }\\",
            "+static inline T *N ## _array_copy_to_pe(T *p, const T *p2, size_t n)\\",
            "+{ size_t i; if (NS ## is_native_pe()) memcpy(p, p2, n * sizeof(T)); else\\",
            "+  for (i = 0; i < n; ++i) N ## _copy_to_pe(&p[i], &p2[i]); return p; }",
            " #define __flatbuffers_define_scalar_primitives(NS, N, T)\\",
            " static inline T *N ## _from_pe(T *p) { return __ ## NS ## from_pe(p, N); }\\",
            " static inline T *N ## _to_pe(T *p) { return __ ## NS ## to_pe(p, N); }\\",
            " static inline T *N ## _copy(T *p, const T *p2) { *p = *p2; return p; }\\",
            " static inline T *N ## _copy_from_pe(T *p, const T *p2)\\",
            " { return __ ## NS ## copy_from_pe(p, p2, N); }\\",
            " static inline T *N ## _copy_to_pe(T *p, const T *p2) \\",
            " { return __ ## NS ## copy_to_pe(p, p2, N); }\\",
            " static inline T *N ## _assign(T *p, const T v0) { *p = v0; return p; }\\",
            " static inline T *N ## _assign_from_pe(T *p, T v0)\\",
            "-{ *p = N ## _cast_from_pe(v0); return p; }\\",
            "+{ *p = N ## _read_from_pe(&v0); return p; }\\",
            " static inline T *N ## _assign_to_pe(T *p, T v0)\\",
            "-{ *p = N ## _cast_to_pe(v0); return p; }",
            "+{ N ## _write_to_pe(p, v0); return p; }",
            " #define __flatbuffers_build_scalar(NS, N, T)\\",
            " __ ## NS ## define_scalar_primitives(NS, N, T)\\",
            "+__ ## NS ## define_fixed_array_primitives(NS, N, T)\\",
            " __ ## NS ## build_vector(NS, N, T, sizeof(T), sizeof(T))",
            " /* Depends on generated copy_to/from_pe functions, and the type. */",
            " #define __flatbuffers_define_struct_primitives(NS, N)\\",
            " static inline N ## _t *N ##_to_pe(N ## _t *p)\\",
            " { if (!NS ## is_native_pe()) { N ## _copy_to_pe(p, p); }; return p; }\\",
            " static inline N ## _t *N ##_from_pe(N ## _t *p)\\",
            " { if (!NS ## is_native_pe()) { N ## _copy_from_pe(p, p); }; return p; }\\",
            "@@ -371,21 +381,22 @@",
            " static inline N ## _ref_t N ## _create(NS ## builder_t *B __ ## N ## _formal_args)\\",
            " { N ## _t *_p = N ## _start(B); if (!_p) return 0; N ##_assign_to_pe(_p __ ## N ## _call_args);\\",
            "   return N ## _end_pe(B); }\\",
            " static inline N ## _ref_t N ## _clone(NS ## builder_t *B, N ## _struct_t p)\\",
            " { N ## _t *_p; __flatbuffers_memoize_begin(B, p); _p = N ## _start(B); if (!_p) return 0;\\",
            "   N ## _copy(_p, p); __flatbuffers_memoize_end(B, p, N ##_end_pe(B)); }\\",
            " __flatbuffers_build_vector(NS, N, N ## _t, S, A)\\",
            "-__flatbuffers_build_struct_root(NS, N, A, FID, TFID)",
            "+__flatbuffers_build_struct_root(NS, N, A, FID, TFID)\\",
            " ",
            "+#define __flatbuffers_struct_clear_field(p) memset((p), 0, sizeof(*(p)))",
            " #define __flatbuffers_build_table(NS, N, K)\\",
            " static inline int N ## _start(NS ## builder_t *B)\\",
            " { return flatcc_builder_start_table(B, K); }\\",
            " static inline N ## _ref_t N ## _end(NS ## builder_t *B)\\",
            "-{ assert(flatcc_builder_check_required(B, __ ## N ## _required,\\",
            "+{ FLATCC_ASSERT(flatcc_builder_check_required(B, __ ## N ## _required,\\",
            "   sizeof(__ ## N ## _required) / sizeof(__ ## N ## _required[0]) - 1));\\",
            "   return flatcc_builder_end_table(B); }\\",
            " __flatbuffers_build_offset_vector(NS, N)",
            " ",
            " #define __flatbuffers_build_table_field(ID, NS, N, TN, TT)\\",
            " static inline int N ## _add(NS ## builder_t *B, TN ## _ref_t ref)\\",
            " { TN ## _ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ?\\",
            "@@ -400,16 +411,16 @@",
            " { return N ## _add(B, TN ## _clone(B, p)); }\\",
            " static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\",
            " { TN ## _table_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }",
            " ",
            " #define __flatbuffers_build_union_field(ID, NS, N, TN, TT)\\",
            " static inline int N ## _add(NS ## builder_t *B, TN ## _union_ref_t uref)\\",
            " { NS ## ref_t *_p; TN ## _union_type_t *_pt; if (uref.type == TN ## _NONE) return 0; if (uref.value == 0) return -1;\\",
            "-  if (!(_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1, sizeof(*_pt), sizeof(*_pt))) ||\\",
            "-  !(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_pt = uref.type; *_p = uref.value; return 0; }\\",
            "+  if (!(_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1, sizeof(*_pt), sizeof(*_pt)))) return -1;\\",
            "+  *_pt = uref.type; if (!(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_p = uref.value; return 0; }\\",
            " static inline int N ## _add_type(NS ## builder_t *B, TN ## _union_type_t type)\\",
            " { TN ## _union_type_t *_pt; if (type == TN ## _NONE) return 0; return (_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1,\\",
            "   sizeof(*_pt), sizeof(*_pt))) ? ((*_pt = type), 0) : -1; }\\",
            " static inline int N ## _add_value(NS ## builder_t *B, TN ## _union_ref_t uref)\\",
            " { NS ## ref_t *p; if (uref.type == TN ## _NONE) return 0; return (p = flatcc_builder_table_add_offset(B, ID)) ?\\",
            "   ((*p = uref.value), 0) : -1; }\\",
            " static inline int N ## _clone(NS ## builder_t *B, TN ## _union_t p)\\",
            "@@ -468,14 +479,27 @@",
            " /* Clone does not skip default values and expects pe endian content. */\\",
            " static inline int N ## _clone(NS ## builder_t *B, const T *p)\\",
            " { return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }\\",
            " /* Transferring a missing field is a nop success with 0 as result. */\\",
            " static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\",
            " { const T *_p = N ## _get_ptr(t); return _p ? N ## _clone(B, _p) : 0; }",
            " ",
            "+/* NS: common namespace, ID: table field id (not offset), TN: name of type T, TT: name of table type",
            "+ * S: sizeof of scalar type, A: alignment of type T. */",
            "+#define __flatbuffers_build_scalar_optional_field(ID, NS, N, TN, T, S, A, TT)\\",
            "+static inline int N ## _add(NS ## builder_t *B, const T v)\\",
            "+{ T *_p; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\\",
            "+  TN ## _assign_to_pe(_p, v); return 0; }\\",
            "+/* Clone does not skip default values and expects pe endian content. */\\",
            "+static inline int N ## _clone(NS ## builder_t *B, const T *p)\\",
            "+{ return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }\\",
            "+/* Transferring a missing field is a nop success with 0 as result. */\\",
            "+static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\",
            "+{ const T *_p = N ## _get_ptr(t); return _p ? N ## _clone(B, _p) : 0; }",
            "+",
            " #define __flatbuffers_build_struct_field(ID, NS, N, TN, S, A, TT)\\",
            " static inline TN ## _t *N ## _start(NS ## builder_t *B)\\",
            " { return (TN ## _t *)flatcc_builder_table_add(B, ID, S, A); }\\",
            " static inline int N ## _end(NS ## builder_t *B)\\",
            " { if (!NS ## is_native_pe()) { TN ## _to_pe((TN ## _t *)flatcc_builder_table_edit(B, S)); } return 0; }\\",
            " static inline int N ## _end_pe(NS ## builder_t *B) { return 0; }\\",
            " static inline int N ## _create(NS ## builder_t *B __ ## TN ## _formal_args)\\",
            "@@ -493,17 +517,17 @@",
            " { TN ## _vec_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\\",
            " static inline int N ## _start(NS ## builder_t *B)\\",
            " { return TN ## _vec_start(B); }\\",
            " static inline int N ## _end_pe(NS ## builder_t *B)\\",
            " { return N ## _add(B, TN ## _vec_end_pe(B)); }\\",
            " static inline int N ## _end(NS ## builder_t *B)\\",
            " { return N ## _add(B, TN ## _vec_end(B)); }\\",
            "-static inline int N ## _create_pe(NS ## builder_t *B, T *data, size_t len)\\",
            "+static inline int N ## _create_pe(NS ## builder_t *B, const T *data, size_t len)\\",
            " { return N ## _add(B, TN ## _vec_create_pe(B, data, len)); }\\",
            "-static inline int N ## _create(NS ## builder_t *B, T *data, size_t len)\\",
            "+static inline int N ## _create(NS ## builder_t *B, const T *data, size_t len)\\",
            " { return N ## _add(B, TN ## _vec_create(B, data, len)); }\\",
            " static inline int N ## _slice(NS ## builder_t *B, TN ## _vec_t vec, size_t index, size_t len)\\",
            " { return N ## _add(B, TN ## _vec_slice(B, vec, index, len)); }\\",
            " static inline int N ## _clone(NS ## builder_t *B, TN ## _vec_t vec)\\",
            " { return N ## _add(B, TN ## _vec_clone(B, vec)); }\\",
            " static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\",
            " { TN ## _vec_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }\\",
            "@@ -612,14 +636,16 @@",
            " static inline NU ## _union_ref_t *N ## _ ## M ## _push_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\\",
            " { return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_slice(B, string, index, len))); }",
            " ",
            " #define __flatbuffers_build_string_vector_field(ID, NS, N, TT)\\",
            " __flatbuffers_build_offset_vector_field(ID, NS, N, NS ## string, TT)\\",
            " __flatbuffers_build_string_vector_ops(NS, N)",
            " ",
            "+#define __flatbuffers_char_formal_args , char v0",
            "+#define __flatbuffers_char_call_args , v0",
            " #define __flatbuffers_uint8_formal_args , uint8_t v0",
            " #define __flatbuffers_uint8_call_args , v0",
            " #define __flatbuffers_int8_formal_args , int8_t v0",
            " #define __flatbuffers_int8_call_args , v0",
            " #define __flatbuffers_bool_formal_args , flatbuffers_bool_t v0",
            " #define __flatbuffers_bool_call_args , v0",
            " #define __flatbuffers_uint16_formal_args , uint16_t v0",
            "@@ -635,14 +661,15 @@",
            " #define __flatbuffers_int64_formal_args , int64_t v0",
            " #define __flatbuffers_int64_call_args , v0",
            " #define __flatbuffers_float_formal_args , float v0",
            " #define __flatbuffers_float_call_args , v0",
            " #define __flatbuffers_double_formal_args , double v0",
            " #define __flatbuffers_double_call_args , v0",
            " ",
            "+__flatbuffers_build_scalar(flatbuffers_, flatbuffers_char, char)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint8, uint8_t)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_int8, int8_t)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_bool, flatbuffers_bool_t)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint16, uint16_t)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint32, uint32_t)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint64, uint64_t)",
            " __flatbuffers_build_scalar(flatbuffers_, flatbuffers_int16, int16_t)"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/reflection/flatbuffers_common_reader.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/reflection/flatbuffers_common_reader.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/reflection/flatbuffers_common_reader.h",
            "@@ -1,28 +1,28 @@",
            " #ifndef FLATBUFFERS_COMMON_READER_H",
            " #define FLATBUFFERS_COMMON_READER_H",
            " ",
            "-/* Generated by flatcc 0.5.3 FlatBuffers schema compiler for C by dvide.com */",
            "+/* Generated by flatcc 0.6.1 FlatBuffers schema compiler for C by dvide.com */",
            " ",
            " /* Common FlatBuffers read functionality for C. */",
            " ",
            " #include \"flatcc/flatcc_prologue.h\"",
            " #include \"flatcc/flatcc_flatbuffers.h\"",
            " ",
            " ",
            " #define __flatbuffers_read_scalar_at_byteoffset(N, p, o) N ## _read_from_pe((uint8_t *)(p) + (o))",
            " #define __flatbuffers_read_scalar(N, p) N ## _read_from_pe(p)",
            " #define __flatbuffers_read_vt(ID, offset, t)\\",
            " flatbuffers_voffset_t offset = 0;\\",
            " {   flatbuffers_voffset_t id__tmp, *vt__tmp;\\",
            "-    assert(t != 0 && \"null pointer table access\");\\",
            "+    FLATCC_ASSERT(t != 0 && \"null pointer table access\");\\",
            "     id__tmp = ID;\\",
            "     vt__tmp = (flatbuffers_voffset_t *)((uint8_t *)(t) -\\",
            "         __flatbuffers_soffset_read_from_pe(t));\\",
            "-    if (__flatbuffers_voffset_read_from_pe(vt__tmp) >= sizeof(vt__tmp[0]) * (id__tmp + 3)) {\\",
            "+    if (__flatbuffers_voffset_read_from_pe(vt__tmp) >= sizeof(vt__tmp[0]) * (id__tmp + 3u)) {\\",
            "         offset = __flatbuffers_voffset_read_from_pe(vt__tmp + id__tmp + 2);\\",
            "     }\\",
            " }",
            " #define __flatbuffers_field_present(ID, t) { __flatbuffers_read_vt(ID, offset__tmp, t) return offset__tmp != 0; }",
            " #define __flatbuffers_scalar_field(T, ID, t)\\",
            " {\\",
            "     __flatbuffers_read_vt(ID, offset__tmp, t)\\",
            "@@ -41,34 +41,41 @@",
            "   return offset__tmp ? __flatbuffers_read_scalar_at_byteoffset(TK, t__tmp, offset__tmp) : V;\\",
            " }\\",
            " static inline const T *N ## _ ## NK ## _get_ptr(N ## _table_t t__tmp)\\",
            " __flatbuffers_scalar_field(T, ID, t__tmp)\\",
            " static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\\",
            " __flatbuffers_field_present(ID, t__tmp)\\",
            " __flatbuffers_define_scan_by_scalar_field(N, NK, T)",
            "+#define __flatbuffers_define_scalar_optional_field(ID, N, NK, TK, T, V)\\",
            "+__flatbuffers_define_scalar_field(ID, N, NK, TK, T, V)\\",
            "+static inline TK ## _option_t N ## _ ## NK ## _option(N ## _table_t t__tmp)\\",
            "+{ TK ## _option_t ret; __flatbuffers_read_vt(ID, offset__tmp, t__tmp)\\",
            "+  ret.is_null = offset__tmp == 0; ret.value = offset__tmp ?\\",
            "+  __flatbuffers_read_scalar_at_byteoffset(TK, t__tmp, offset__tmp) : V;\\",
            "+  return ret; }",
            " #define __flatbuffers_struct_field(T, ID, t, r)\\",
            " {\\",
            "     __flatbuffers_read_vt(ID, offset__tmp, t)\\",
            "     if (offset__tmp) {\\",
            "         return (T)((uint8_t *)(t) + offset__tmp);\\",
            "     }\\",
            "-    assert(!(r) && \"required field missing\");\\",
            "+    FLATCC_ASSERT(!(r) && \"required field missing\");\\",
            "     return 0;\\",
            " }",
            " #define __flatbuffers_offset_field(T, ID, t, r, adjust)\\",
            " {\\",
            "     flatbuffers_uoffset_t *elem__tmp;\\",
            "     __flatbuffers_read_vt(ID, offset__tmp, t)\\",
            "     if (offset__tmp) {\\",
            "         elem__tmp = (flatbuffers_uoffset_t *)((uint8_t *)(t) + offset__tmp);\\",
            "         /* Add sizeof so C api can have raw access past header field. */\\",
            "         return (T)((uint8_t *)(elem__tmp) + adjust +\\",
            "               __flatbuffers_uoffset_read_from_pe(elem__tmp));\\",
            "     }\\",
            "-    assert(!(r) && \"required field missing\");\\",
            "+    FLATCC_ASSERT(!(r) && \"required field missing\");\\",
            "     return 0;\\",
            " }",
            " #define __flatbuffers_vector_field(T, ID, t, r) __flatbuffers_offset_field(T, ID, t, r, sizeof(flatbuffers_uoffset_t))",
            " #define __flatbuffers_table_field(T, ID, t, r) __flatbuffers_offset_field(T, ID, t, r, 0)",
            " #define __flatbuffers_define_struct_field(ID, N, NK, T, r)\\",
            " static inline T N ## _ ## NK ## _get(N ## _table_t t__tmp)\\",
            " __flatbuffers_struct_field(T, ID, t__tmp, r)\\",
            "@@ -100,22 +107,22 @@",
            " __flatbuffers_define_scan_by_string_field(N, NK)",
            " #define __flatbuffers_vec_len(vec)\\",
            " { return (vec) ? (size_t)__flatbuffers_uoffset_read_from_pe((flatbuffers_uoffset_t *)vec - 1) : 0; }",
            " #define __flatbuffers_string_len(s) __flatbuffers_vec_len(s)",
            " static inline size_t flatbuffers_vec_len(const void *vec)",
            " __flatbuffers_vec_len(vec)",
            " #define __flatbuffers_scalar_vec_at(N, vec, i)\\",
            "-{ assert(flatbuffers_vec_len(vec) > (i) && \"index out of range\");\\",
            "+{ FLATCC_ASSERT(flatbuffers_vec_len(vec) > (i) && \"index out of range\");\\",
            "   return __flatbuffers_read_scalar(N, &(vec)[i]); }",
            " #define __flatbuffers_struct_vec_at(vec, i)\\",
            "-{ assert(flatbuffers_vec_len(vec) > (i) && \"index out of range\"); return (vec) + (i); }",
            "+{ FLATCC_ASSERT(flatbuffers_vec_len(vec) > (i) && \"index out of range\"); return (vec) + (i); }",
            " /* `adjust` skips past the header for string vectors. */",
            " #define __flatbuffers_offset_vec_at(T, vec, i, adjust)\\",
            " { const flatbuffers_uoffset_t *elem__tmp = (vec) + (i);\\",
            "-  assert(flatbuffers_vec_len(vec) > (i) && \"index out of range\");\\",
            "+  FLATCC_ASSERT(flatbuffers_vec_len(vec) > (i) && \"index out of range\");\\",
            "   return (T)((uint8_t *)(elem__tmp) + (size_t)__flatbuffers_uoffset_read_from_pe(elem__tmp) + (adjust)); }",
            " #define __flatbuffers_define_scalar_vec_len(N)\\",
            " static inline size_t N ## _vec_len(N ##_vec_t vec__tmp)\\",
            " { return flatbuffers_vec_len(vec__tmp); }",
            " #define __flatbuffers_define_scalar_vec_at(N, T) \\",
            " static inline T N ## _vec_at(N ## _vec_t vec__tmp, size_t i__tmp)\\",
            " __flatbuffers_scalar_vec_at(N, vec__tmp, i__tmp)",
            "@@ -125,14 +132,15 @@",
            " typedef const flatbuffers_uoffset_t *flatbuffers_string_vec_t;",
            " typedef flatbuffers_uoffset_t *flatbuffers_string_mutable_vec_t;",
            " static inline size_t flatbuffers_string_vec_len(flatbuffers_string_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline flatbuffers_string_t flatbuffers_string_vec_at(flatbuffers_string_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(flatbuffers_string_t, vec, i, sizeof(vec[0]))",
            " typedef const void *flatbuffers_generic_t;",
            "+typedef void *flatbuffers_mutable_generic_t;",
            " static inline flatbuffers_string_t flatbuffers_string_cast_from_generic(const flatbuffers_generic_t p)",
            " { return p ? ((const char *)p) + __flatbuffers_uoffset__size() : 0; }",
            " typedef const flatbuffers_uoffset_t *flatbuffers_generic_vec_t;",
            " typedef flatbuffers_uoffset_t *flatbuffers_generic_table_mutable_vec_t;",
            " static inline size_t flatbuffers_generic_vec_len(flatbuffers_generic_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline flatbuffers_generic_t flatbuffers_generic_vec_at(flatbuffers_generic_vec_t vec, size_t i)",
            "@@ -143,14 +151,28 @@",
            "     flatbuffers_union_type_t type;",
            "     flatbuffers_generic_t value;",
            " } flatbuffers_union_t;",
            " typedef struct flatbuffers_union_vec {",
            "     const flatbuffers_union_type_t *type;",
            "     const flatbuffers_uoffset_t *value;",
            " } flatbuffers_union_vec_t;",
            "+typedef struct flatbuffers_mutable_union {",
            "+    flatbuffers_union_type_t type;",
            "+    flatbuffers_mutable_generic_t value;",
            "+} flatbuffers_mutable_union_t;",
            "+typedef struct flatbuffers_mutable_union_vec {",
            "+    flatbuffers_union_type_t *type;",
            "+    flatbuffers_uoffset_t *value;",
            "+} flatbuffers_mutable_union_vec_t;",
            "+static inline flatbuffers_mutable_union_t flatbuffers_mutable_union_cast(flatbuffers_union_t u__tmp)\\",
            "+{ flatbuffers_mutable_union_t mu = { u__tmp.type, (flatbuffers_mutable_generic_t)u__tmp.value };\\",
            "+  return mu; }",
            "+static inline flatbuffers_mutable_union_vec_t flatbuffers_mutable_union_vec_cast(flatbuffers_union_vec_t uv__tmp)\\",
            "+{ flatbuffers_mutable_union_vec_t muv =\\",
            "+  { (flatbuffers_union_type_t *)uv__tmp.type, (flatbuffers_uoffset_t *)uv__tmp.value }; return muv; }",
            " #define __flatbuffers_union_type_field(ID, t)\\",
            " {\\",
            "     __flatbuffers_read_vt(ID, offset__tmp, t)\\",
            "     return offset__tmp ? __flatbuffers_read_scalar_at_byteoffset(__flatbuffers_utype, t, offset__tmp) : 0;\\",
            " }",
            " static inline flatbuffers_string_t flatbuffers_string_cast_from_union(const flatbuffers_union_t u__tmp)\\",
            " { return flatbuffers_string_cast_from_generic(u__tmp.value); }",
            "@@ -172,38 +194,44 @@",
            " { return NS ## string_cast_from_generic(N ## _ ## NK ## _get(t__tmp)); }\\",
            " ",
            " #define __flatbuffers_define_union_vector_ops(NS, T)\\",
            " static inline size_t T ## _union_vec_len(T ## _union_vec_t uv__tmp)\\",
            " { return NS ## vec_len(uv__tmp.type); }\\",
            " static inline T ## _union_t T ## _union_vec_at(T ## _union_vec_t uv__tmp, size_t i__tmp)\\",
            " { T ## _union_t u__tmp = { 0, 0 }; size_t n__tmp = NS ## vec_len(uv__tmp.type);\\",
            "-  assert(n__tmp > (i__tmp) && \"index out of range\"); u__tmp.type = uv__tmp.type[i__tmp];\\",
            "+  FLATCC_ASSERT(n__tmp > (i__tmp) && \"index out of range\"); u__tmp.type = uv__tmp.type[i__tmp];\\",
            "   /* Unknown type is treated as NONE for schema evolution. */\\",
            "   if (u__tmp.type == 0) return u__tmp;\\",
            "   u__tmp.value = NS ## generic_vec_at(uv__tmp.value, i__tmp); return u__tmp; }\\",
            " static inline NS ## string_t T ## _union_vec_at_as_string(T ## _union_vec_t uv__tmp, size_t i__tmp)\\",
            " { return (NS ## string_t) NS ## generic_vec_at_as_string(uv__tmp.value, i__tmp); }\\",
            " ",
            " #define __flatbuffers_define_union_vector(NS, T)\\",
            " typedef NS ## union_vec_t T ## _union_vec_t;\\",
            "+typedef NS ## mutable_union_vec_t T ## _mutable_union_vec_t;\\",
            "+static inline T ## _mutable_union_vec_t T ## _mutable_union_vec_cast(T ## _union_vec_t u__tmp)\\",
            "+{ return NS ## mutable_union_vec_cast(u__tmp); }\\",
            " __## NS ## define_union_vector_ops(NS, T)",
            " #define __flatbuffers_define_union(NS, T)\\",
            " typedef NS ## union_t T ## _union_t;\\",
            "+typedef NS ## mutable_union_t T ## _mutable_union_t;\\",
            "+static inline T ## _mutable_union_t T ## _mutable_union_cast(T ## _union_t u__tmp)\\",
            "+{ return NS ## mutable_union_cast(u__tmp); }\\",
            " __## NS ## define_union_vector(NS, T)",
            " #define __flatbuffers_define_union_vector_field(NS, ID, N, NK, T, r)\\",
            " __## NS ## define_vector_field(ID - 1, N, NK ## _type, T ## _vec_t, r)\\",
            " __## NS ## define_vector_field(ID, N, NK, flatbuffers_generic_vec_t, r)\\",
            " static inline T ## _union_vec_t N ## _ ## NK ## _union(N ## _table_t t__tmp)\\",
            " { T ## _union_vec_t uv__tmp; uv__tmp.type = N ## _ ## NK ## _type_get(t__tmp);\\",
            "   uv__tmp.value = N ## _ ## NK(t__tmp);\\",
            "-  assert(NS ## vec_len(uv__tmp.type) == NS ## vec_len(uv__tmp.value)\\",
            "+  FLATCC_ASSERT(NS ## vec_len(uv__tmp.type) == NS ## vec_len(uv__tmp.value)\\",
            "   && \"union vector type length mismatch\"); return uv__tmp; }",
            " #include <string.h>",
            "-static size_t flatbuffers_not_found = (size_t)-1;",
            "-static size_t flatbuffers_end = (size_t)-1;",
            "+static const size_t flatbuffers_not_found = (size_t)-1;",
            "+static const size_t flatbuffers_end = (size_t)-1;",
            " #define __flatbuffers_identity(n) (n)",
            " #define __flatbuffers_min(a, b) ((a) < (b) ? (a) : (b))",
            " /* Subtraction doesn't work for unsigned types. */",
            " #define __flatbuffers_scalar_cmp(x, y, n) ((x) < (y) ? -1 : (x) > (y))",
            " static inline int __flatbuffers_string_n_cmp(flatbuffers_string_t v, const char *s, size_t n)",
            " { size_t nv = flatbuffers_string_len(v); int x = strncmp(v, s, nv < n ? nv : n);",
            "   return x != 0 ? x : nv < n ? -1 : nv > n; }",
            "@@ -243,23 +271,23 @@",
            " #define __flatbuffers_define_scalar_find(N, T)\\",
            " static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, T key__tmp)\\",
            " __flatbuffers_find_by_scalar_field(__flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)",
            " #define __flatbuffers_define_find_by_string_field(N, NK) \\",
            " /* Note: find only works on vectors sorted by this field. */\\",
            " static inline size_t N ## _vec_find_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\\",
            " __flatbuffers_find_by_string_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\",
            "-static inline size_t N ## _vec_find_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_find_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\",
            " __flatbuffers_find_by_string_n_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)",
            " #define __flatbuffers_define_default_find_by_scalar_field(N, NK, TK)\\",
            " static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, TK key__tmp)\\",
            " { return N ## _vec_find_by_ ## NK(vec__tmp, key__tmp); }",
            " #define __flatbuffers_define_default_find_by_string_field(N, NK) \\",
            " static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, const char *s__tmp)\\",
            " { return N ## _vec_find_by_ ## NK(vec__tmp, s__tmp); }\\",
            "-static inline size_t N ## _vec_find_n(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_find_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\",
            " { return N ## _vec_find_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }",
            " /* A = identity if searching scalar vectors rather than key fields. */",
            " /* Returns lowest matching index or not_found. */",
            " #define __flatbuffers_scan_by_field(b, e, A, V, E, L, K, Kn, T, D)\\",
            " { T v__tmp; size_t i__tmp;\\",
            "   for (i__tmp = b; i__tmp < e; ++i__tmp) {\\",
            "     v__tmp = A(E(V, i__tmp));\\",
            "@@ -308,53 +336,53 @@",
            " static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, T key__tmp)\\",
            " __flatbuffers_rscan_by_scalar_field(0, N ## _vec_len(vec__tmp), __flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\\",
            " static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, T key__tmp)\\",
            " __flatbuffers_rscan_by_scalar_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), __flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)",
            " #define __flatbuffers_define_scan_by_string_field(N, NK) \\",
            " static inline size_t N ## _vec_scan_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\\",
            " __flatbuffers_scan_by_string_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\",
            "-static inline size_t N ## _vec_scan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_scan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\",
            " __flatbuffers_scan_by_string_n_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\",
            " static inline size_t N ## _vec_scan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\",
            " __flatbuffers_scan_by_string_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\",
            "-static inline size_t N ## _vec_scan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_scan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\",
            " __flatbuffers_scan_by_string_n_field(begin__tmp, __flatbuffers_min( end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\",
            " static inline size_t N ## _vec_rscan_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\\",
            " __flatbuffers_rscan_by_string_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\",
            "-static inline size_t N ## _vec_rscan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_rscan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\",
            " __flatbuffers_rscan_by_string_n_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\",
            " static inline size_t N ## _vec_rscan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\",
            " __flatbuffers_rscan_by_string_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\",
            "-static inline size_t N ## _vec_rscan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_rscan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\",
            " __flatbuffers_rscan_by_string_n_field(begin__tmp, __flatbuffers_min( end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)",
            " #define __flatbuffers_define_default_scan_by_scalar_field(N, NK, TK)\\",
            " static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, TK key__tmp)\\",
            " { return N ## _vec_scan_by_ ## NK(vec__tmp, key__tmp); }\\",
            " static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, TK key__tmp)\\",
            " { return N ## _vec_scan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, key__tmp); }\\",
            " static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, TK key__tmp)\\",
            " { return N ## _vec_rscan_by_ ## NK(vec__tmp, key__tmp); }\\",
            " static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, TK key__tmp)\\",
            " { return N ## _vec_rscan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, key__tmp); }",
            " #define __flatbuffers_define_default_scan_by_string_field(N, NK) \\",
            " static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, const char *s__tmp)\\",
            " { return N ## _vec_scan_by_ ## NK(vec__tmp, s__tmp); }\\",
            "-static inline size_t N ## _vec_scan_n(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_scan_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\",
            " { return N ## _vec_scan_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\\",
            " static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\",
            " { return N ## _vec_scan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp); }\\",
            "-static inline size_t N ## _vec_scan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_scan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\",
            " { return N ## _vec_scan_ex_n_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp, n__tmp); }\\",
            " static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, const char *s__tmp)\\",
            " { return N ## _vec_rscan_by_ ## NK(vec__tmp, s__tmp); }\\",
            "-static inline size_t N ## _vec_rscan_n(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_rscan_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\",
            " { return N ## _vec_rscan_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\\",
            " static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\",
            " { return N ## _vec_rscan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp); }\\",
            "-static inline size_t N ## _vec_rscan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\",
            "+static inline size_t N ## _vec_rscan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\",
            " { return N ## _vec_rscan_ex_n_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp, n__tmp); }",
            " #define __flatbuffers_heap_sort(N, X, A, E, L, TK, TE, D, S)\\",
            " static inline void __ ## N ## X ## __heap_sift_down(\\",
            "         N ## _mutable_vec_t vec__tmp, size_t start__tmp, size_t end__tmp)\\",
            " { size_t child__tmp, root__tmp; TK v1__tmp, v2__tmp, vroot__tmp;\\",
            "   root__tmp = start__tmp;\\",
            "   while ((root__tmp << 1) <= end__tmp) {\\",
            "@@ -408,27 +436,43 @@",
            "   __flatbuffers_define_sort_by_field(N, NK, TK, TE, __flatbuffers_scalar_diff, __flatbuffers_struct_swap)",
            " #define __flatbuffers_define_table_sort_by_scalar_field(N, NK, TK)\\",
            "   __flatbuffers_define_sort_by_field(N, NK, TK, flatbuffers_uoffset_t, __flatbuffers_scalar_diff, __flatbuffers_table_swap)",
            " #define __flatbuffers_define_table_sort_by_string_field(N, NK)\\",
            "   __flatbuffers_define_sort_by_field(N, NK, flatbuffers_string_t, flatbuffers_uoffset_t, __flatbuffers_string_diff, __flatbuffers_table_swap)",
            " #define __flatbuffers_define_scalar_sort(N, T) __flatbuffers_define_sort(N, T, T, __flatbuffers_scalar_diff, __flatbuffers_scalar_swap)",
            " #define __flatbuffers_define_string_sort() __flatbuffers_define_sort(flatbuffers_string, flatbuffers_string_t, flatbuffers_uoffset_t, __flatbuffers_string_diff, __flatbuffers_string_swap)",
            "+#define __flatbuffers_sort_vector_field(N, NK, T, t)\\",
            "+{ T ## _mutable_vec_t v__tmp = (T ## _mutable_vec_t) N ## _ ## NK ## _get(t);\\",
            "+  if (v__tmp) T ## _vec_sort(v__tmp); }",
            "+#define __flatbuffers_sort_table_field(N, NK, T, t)\\",
            "+{ T ## _sort((T ## _mutable_table_t)N ## _ ## NK ## _get(t)); }",
            "+#define __flatbuffers_sort_union_field(N, NK, T, t)\\",
            "+{ T ## _sort(T ## _mutable_union_cast(N ## _ ## NK ## _union(t))); }",
            "+#define __flatbuffers_sort_table_vector_field_elements(N, NK, T, t)\\",
            "+{ T ## _vec_t v__tmp = N ## _ ## NK ## _get(t); size_t i__tmp, n__tmp;\\",
            "+  n__tmp = T ## _vec_len(v__tmp); for (i__tmp = 0; i__tmp < n__tmp; ++i__tmp) {\\",
            "+  T ## _sort((T ## _mutable_table_t)T ## _vec_at(v__tmp, i__tmp)); }}",
            "+#define __flatbuffers_sort_union_vector_field_elements(N, NK, T, t)\\",
            "+{ T ## _union_vec_t v__tmp = N ## _ ## NK ## _union(t); size_t i__tmp, n__tmp;\\",
            "+  n__tmp = T ## _union_vec_len(v__tmp); for (i__tmp = 0; i__tmp < n__tmp; ++i__tmp) {\\",
            "+  T ## _sort(T ## _mutable_union_cast(T ## _union_vec_at(v__tmp, i__tmp))); }}",
            " #define __flatbuffers_define_scalar_vector(N, T)\\",
            " typedef const T *N ## _vec_t;\\",
            " typedef T *N ## _mutable_vec_t;\\",
            " __flatbuffers_define_scalar_vec_len(N)\\",
            " __flatbuffers_define_scalar_vec_at(N, T)\\",
            " __flatbuffers_define_scalar_find(N, T)\\",
            " __flatbuffers_define_scalar_scan(N, T)\\",
            " __flatbuffers_define_scalar_sort(N, T)",
            " ",
            " #define __flatbuffers_define_integer_type(N, T, W)\\",
            " __flatcc_define_integer_accessors(N, T, W, flatbuffers_endian)\\",
            " __flatbuffers_define_scalar_vector(N, T)",
            " __flatbuffers_define_scalar_vector(flatbuffers_bool, flatbuffers_bool_t)",
            "+__flatbuffers_define_scalar_vector(flatbuffers_char, char)",
            " __flatbuffers_define_scalar_vector(flatbuffers_uint8, uint8_t)",
            " __flatbuffers_define_scalar_vector(flatbuffers_int8, int8_t)",
            " __flatbuffers_define_scalar_vector(flatbuffers_uint16, uint16_t)",
            " __flatbuffers_define_scalar_vector(flatbuffers_int16, int16_t)",
            " __flatbuffers_define_scalar_vector(flatbuffers_uint32, uint32_t)",
            " __flatbuffers_define_scalar_vector(flatbuffers_int32, int32_t)",
            " __flatbuffers_define_scalar_vector(flatbuffers_uint64, uint64_t)",
            "@@ -453,14 +497,30 @@",
            " static inline size_t flatbuffers_string_vec_rscan_n(flatbuffers_string_vec_t vec, const char *s, size_t n)",
            " __flatbuffers_rscan_by_string_n_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)",
            " static inline size_t flatbuffers_string_vec_rscan_ex(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s)",
            " __flatbuffers_rscan_by_string_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)",
            " static inline size_t flatbuffers_string_vec_rscan_ex_n(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s, size_t n)",
            " __flatbuffers_rscan_by_string_n_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)",
            " __flatbuffers_define_string_sort()",
            "+#define __flatbuffers_define_struct_scalar_fixed_array_field(N, NK, TK, T, L)\\",
            "+static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp, size_t i__tmp)\\",
            "+{ if (!t__tmp || i__tmp >= L) return 0;\\",
            "+  return __flatbuffers_read_scalar(TK, &(t__tmp->NK[i__tmp])); }\\",
            "+static inline const T *N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\\",
            "+{ return t__tmp ? t__tmp->NK : 0; }\\",
            "+static inline size_t N ## _ ## NK ## _get_len(void) { return L; }\\",
            "+static inline T N ## _ ## NK (N ## _struct_t t__tmp, size_t i__tmp)\\",
            "+{ return N ## _ ## NK ## _get(t__tmp, i__tmp); }",
            "+#define __flatbuffers_define_struct_struct_fixed_array_field(N, NK, T, L)\\",
            "+static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp, size_t i__tmp)\\",
            "+{ if (!t__tmp || i__tmp >= L) return 0; return t__tmp->NK + i__tmp; }static inline T N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\\",
            "+{ return t__tmp ? t__tmp->NK : 0; }\\",
            "+static inline size_t N ## _ ## NK ## _get_len(void) { return L; }\\",
            "+static inline T N ## _ ## NK(N ## _struct_t t__tmp, size_t i__tmp)\\",
            "+{ if (!t__tmp || i__tmp >= L) return 0; return t__tmp->NK + i__tmp; }",
            " #define __flatbuffers_define_struct_scalar_field(N, NK, TK, T)\\",
            " static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp)\\",
            " { return t__tmp ? __flatbuffers_read_scalar(TK, &(t__tmp->NK)) : 0; }\\",
            " static inline const T *N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\\",
            " { return t__tmp ? &(t__tmp->NK) : 0; }\\",
            " static inline T N ## _ ## NK (N ## _struct_t t__tmp)\\",
            " { return t__tmp ? __flatbuffers_read_scalar(TK, &(t__tmp->NK)) : 0; }\\",
            "@@ -495,23 +555,23 @@",
            "     __flatbuffers_uoffset_read_from_pe(buffer))))",
            " #define __flatbuffers_nested_buffer_as_root(C, N, T, K)\\",
            " static inline T ## _ ## K ## t C ## _ ## N ## _as_root_with_identifier(C ## _ ## table_t t__tmp, const char *fid__tmp)\\",
            " { const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __flatbuffers_read_root(T, K, buffer__tmp, fid__tmp); }\\",
            " static inline T ## _ ## K ## t C ## _ ## N ## _as_typed_root(C ## _ ## table_t t__tmp)\\",
            " { const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __flatbuffers_read_root(T, K, buffer__tmp, C ## _ ## type_identifier); }\\",
            " static inline T ## _ ## K ## t C ## _ ## N ## _as_root(C ## _ ## table_t t__tmp)\\",
            "-{ const char *fid__tmp = T ## _identifier;\\",
            "+{ const char *fid__tmp = T ## _file_identifier;\\",
            "   const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __flatbuffers_read_root(T, K, buffer__tmp, fid__tmp); }",
            " #define __flatbuffers_buffer_as_root(N, K)\\",
            " static inline N ## _ ## K ## t N ## _as_root_with_identifier(const void *buffer__tmp, const char *fid__tmp)\\",
            " { return __flatbuffers_read_root(N, K, buffer__tmp, fid__tmp); }\\",
            " static inline N ## _ ## K ## t N ## _as_root_with_type_hash(const void *buffer__tmp, flatbuffers_thash_t thash__tmp)\\",
            " { return __flatbuffers_read_typed_root(N, K, buffer__tmp, thash__tmp); }\\",
            " static inline N ## _ ## K ## t N ## _as_root(const void *buffer__tmp)\\",
            "-{ const char *fid__tmp = N ## _identifier;\\",
            "+{ const char *fid__tmp = N ## _file_identifier;\\",
            "   return __flatbuffers_read_root(N, K, buffer__tmp, fid__tmp); }\\",
            " static inline N ## _ ## K ## t N ## _as_typed_root(const void *buffer__tmp)\\",
            " { return __flatbuffers_read_typed_root(N, K, buffer__tmp, N ## _type_hash); }",
            " #define __flatbuffers_struct_as_root(N) __flatbuffers_buffer_as_root(N, struct_)",
            " #define __flatbuffers_table_as_root(N) __flatbuffers_buffer_as_root(N, table_)",
            " ",
            " #include \"flatcc/flatcc_epilogue.h\""
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/reflection/reflection_builder.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/reflection/reflection_builder.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/reflection/reflection_builder.h",
            "@@ -1,128 +1,159 @@",
            " #ifndef REFLECTION_BUILDER_H",
            " #define REFLECTION_BUILDER_H",
            " ",
            "-/* Generated by flatcc 0.5.3 FlatBuffers schema compiler for C by dvide.com */",
            "+/* Generated by flatcc 0.6.1 FlatBuffers schema compiler for C by dvide.com */",
            " ",
            " #ifndef REFLECTION_READER_H",
            " #include \"reflection_reader.h\"",
            " #endif",
            " #ifndef FLATBUFFERS_COMMON_BUILDER_H",
            " #include \"flatbuffers_common_builder.h\"",
            " #endif",
            " #include \"flatcc/flatcc_prologue.h\"",
            " #undef flatbuffers_identifier",
            " #define flatbuffers_identifier \"BFBS\"",
            " #undef flatbuffers_extension",
            "-#define flatbuffers_extension \".bfbs\"",
            "+#define flatbuffers_extension \"bfbs\"",
            " ",
            " #define __reflection_BaseType_formal_args , reflection_BaseType_enum_t v0",
            " #define __reflection_BaseType_call_args , v0",
            " __flatbuffers_build_scalar(flatbuffers_, reflection_BaseType, reflection_BaseType_enum_t)",
            " ",
            " static const flatbuffers_voffset_t __reflection_Type_required[] = { 0 };",
            " typedef flatbuffers_ref_t reflection_Type_ref_t;",
            " static reflection_Type_ref_t reflection_Type_clone(flatbuffers_builder_t *B, reflection_Type_table_t t);",
            "-__flatbuffers_build_table(flatbuffers_, reflection_Type, 3)",
            "+__flatbuffers_build_table(flatbuffers_, reflection_Type, 4)",
            " ",
            " static const flatbuffers_voffset_t __reflection_KeyValue_required[] = { 0, 0 };",
            " typedef flatbuffers_ref_t reflection_KeyValue_ref_t;",
            " static reflection_KeyValue_ref_t reflection_KeyValue_clone(flatbuffers_builder_t *B, reflection_KeyValue_table_t t);",
            " __flatbuffers_build_table(flatbuffers_, reflection_KeyValue, 2)",
            " ",
            " static const flatbuffers_voffset_t __reflection_EnumVal_required[] = { 0, 0 };",
            " typedef flatbuffers_ref_t reflection_EnumVal_ref_t;",
            " static reflection_EnumVal_ref_t reflection_EnumVal_clone(flatbuffers_builder_t *B, reflection_EnumVal_table_t t);",
            "-__flatbuffers_build_table(flatbuffers_, reflection_EnumVal, 4)",
            "+__flatbuffers_build_table(flatbuffers_, reflection_EnumVal, 5)",
            " ",
            " static const flatbuffers_voffset_t __reflection_Enum_required[] = { 0, 1, 3, 0 };",
            " typedef flatbuffers_ref_t reflection_Enum_ref_t;",
            " static reflection_Enum_ref_t reflection_Enum_clone(flatbuffers_builder_t *B, reflection_Enum_table_t t);",
            "-__flatbuffers_build_table(flatbuffers_, reflection_Enum, 5)",
            "+__flatbuffers_build_table(flatbuffers_, reflection_Enum, 6)",
            " ",
            " static const flatbuffers_voffset_t __reflection_Field_required[] = { 0, 1, 0 };",
            " typedef flatbuffers_ref_t reflection_Field_ref_t;",
            " static reflection_Field_ref_t reflection_Field_clone(flatbuffers_builder_t *B, reflection_Field_table_t t);",
            "-__flatbuffers_build_table(flatbuffers_, reflection_Field, 10)",
            "+__flatbuffers_build_table(flatbuffers_, reflection_Field, 12)",
            " ",
            " static const flatbuffers_voffset_t __reflection_Object_required[] = { 0, 1, 0 };",
            " typedef flatbuffers_ref_t reflection_Object_ref_t;",
            " static reflection_Object_ref_t reflection_Object_clone(flatbuffers_builder_t *B, reflection_Object_table_t t);",
            "-__flatbuffers_build_table(flatbuffers_, reflection_Object, 6)",
            "+__flatbuffers_build_table(flatbuffers_, reflection_Object, 7)",
            "+",
            "+static const flatbuffers_voffset_t __reflection_RPCCall_required[] = { 0, 1, 2, 0 };",
            "+typedef flatbuffers_ref_t reflection_RPCCall_ref_t;",
            "+static reflection_RPCCall_ref_t reflection_RPCCall_clone(flatbuffers_builder_t *B, reflection_RPCCall_table_t t);",
            "+__flatbuffers_build_table(flatbuffers_, reflection_RPCCall, 5)",
            "+",
            "+static const flatbuffers_voffset_t __reflection_Service_required[] = { 0, 0 };",
            "+typedef flatbuffers_ref_t reflection_Service_ref_t;",
            "+static reflection_Service_ref_t reflection_Service_clone(flatbuffers_builder_t *B, reflection_Service_table_t t);",
            "+__flatbuffers_build_table(flatbuffers_, reflection_Service, 4)",
            " ",
            " static const flatbuffers_voffset_t __reflection_Schema_required[] = { 0, 1, 0 };",
            " typedef flatbuffers_ref_t reflection_Schema_ref_t;",
            " static reflection_Schema_ref_t reflection_Schema_clone(flatbuffers_builder_t *B, reflection_Schema_table_t t);",
            "-__flatbuffers_build_table(flatbuffers_, reflection_Schema, 5)",
            "+__flatbuffers_build_table(flatbuffers_, reflection_Schema, 6)",
            " ",
            "-#define __reflection_Type_formal_args , reflection_BaseType_enum_t v0, reflection_BaseType_enum_t v1, int32_t v2",
            "-#define __reflection_Type_call_args , v0, v1, v2",
            "+#define __reflection_Type_formal_args , reflection_BaseType_enum_t v0, reflection_BaseType_enum_t v1, int32_t v2, uint16_t v3",
            "+#define __reflection_Type_call_args , v0, v1, v2, v3",
            " static inline reflection_Type_ref_t reflection_Type_create(flatbuffers_builder_t *B __reflection_Type_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_Type, reflection_Type_identifier, reflection_Type_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_Type, reflection_Type_file_identifier, reflection_Type_type_identifier)",
            " ",
            " #define __reflection_KeyValue_formal_args , flatbuffers_string_ref_t v0, flatbuffers_string_ref_t v1",
            " #define __reflection_KeyValue_call_args , v0, v1",
            " static inline reflection_KeyValue_ref_t reflection_KeyValue_create(flatbuffers_builder_t *B __reflection_KeyValue_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_KeyValue, reflection_KeyValue_identifier, reflection_KeyValue_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_KeyValue, reflection_KeyValue_file_identifier, reflection_KeyValue_type_identifier)",
            " ",
            "-#define __reflection_EnumVal_formal_args , flatbuffers_string_ref_t v0, int64_t v1, reflection_Object_ref_t v2, reflection_Type_ref_t v3",
            "-#define __reflection_EnumVal_call_args , v0, v1, v2, v3",
            "+#define __reflection_EnumVal_formal_args ,\\",
            "+  flatbuffers_string_ref_t v0, int64_t v1, reflection_Object_ref_t v2, reflection_Type_ref_t v3, flatbuffers_string_vec_ref_t v4",
            "+#define __reflection_EnumVal_call_args ,\\",
            "+  v0, v1, v2, v3, v4",
            " static inline reflection_EnumVal_ref_t reflection_EnumVal_create(flatbuffers_builder_t *B __reflection_EnumVal_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_EnumVal, reflection_EnumVal_identifier, reflection_EnumVal_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_EnumVal, reflection_EnumVal_file_identifier, reflection_EnumVal_type_identifier)",
            " ",
            " #define __reflection_Enum_formal_args ,\\",
            "-  flatbuffers_string_ref_t v0, reflection_EnumVal_vec_ref_t v1, flatbuffers_bool_t v2, reflection_Type_ref_t v3, reflection_KeyValue_vec_ref_t v4",
            "+  flatbuffers_string_ref_t v0, reflection_EnumVal_vec_ref_t v1, flatbuffers_bool_t v2, reflection_Type_ref_t v3, reflection_KeyValue_vec_ref_t v4, flatbuffers_string_vec_ref_t v5",
            " #define __reflection_Enum_call_args ,\\",
            "-  v0, v1, v2, v3, v4",
            "+  v0, v1, v2, v3, v4, v5",
            " static inline reflection_Enum_ref_t reflection_Enum_create(flatbuffers_builder_t *B __reflection_Enum_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_Enum, reflection_Enum_identifier, reflection_Enum_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_Enum, reflection_Enum_file_identifier, reflection_Enum_type_identifier)",
            " ",
            " #define __reflection_Field_formal_args ,\\",
            "   flatbuffers_string_ref_t v0, reflection_Type_ref_t v1, uint16_t v2, uint16_t v3,\\",
            "-  int64_t v4, double v5, flatbuffers_bool_t v6, flatbuffers_bool_t v7, flatbuffers_bool_t v8, reflection_KeyValue_vec_ref_t v9",
            "+  int64_t v4, double v5, flatbuffers_bool_t v6, flatbuffers_bool_t v7,\\",
            "+  flatbuffers_bool_t v8, reflection_KeyValue_vec_ref_t v9, flatbuffers_string_vec_ref_t v10, flatbuffers_bool_t v11",
            " #define __reflection_Field_call_args ,\\",
            "   v0, v1, v2, v3,\\",
            "-  v4, v5, v6, v7, v8, v9",
            "+  v4, v5, v6, v7,\\",
            "+  v8, v9, v10, v11",
            " static inline reflection_Field_ref_t reflection_Field_create(flatbuffers_builder_t *B __reflection_Field_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_Field, reflection_Field_identifier, reflection_Field_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_Field, reflection_Field_file_identifier, reflection_Field_type_identifier)",
            " ",
            " #define __reflection_Object_formal_args ,\\",
            "-  flatbuffers_string_ref_t v0, reflection_Field_vec_ref_t v1, flatbuffers_bool_t v2, int32_t v3, int32_t v4, reflection_KeyValue_vec_ref_t v5",
            "+  flatbuffers_string_ref_t v0, reflection_Field_vec_ref_t v1, flatbuffers_bool_t v2, int32_t v3,\\",
            "+  int32_t v4, reflection_KeyValue_vec_ref_t v5, flatbuffers_string_vec_ref_t v6",
            " #define __reflection_Object_call_args ,\\",
            "-  v0, v1, v2, v3, v4, v5",
            "+  v0, v1, v2, v3,\\",
            "+  v4, v5, v6",
            " static inline reflection_Object_ref_t reflection_Object_create(flatbuffers_builder_t *B __reflection_Object_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_Object, reflection_Object_identifier, reflection_Object_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_Object, reflection_Object_file_identifier, reflection_Object_type_identifier)",
            "+",
            "+#define __reflection_RPCCall_formal_args ,\\",
            "+  flatbuffers_string_ref_t v0, reflection_Object_ref_t v1, reflection_Object_ref_t v2, reflection_KeyValue_vec_ref_t v3, flatbuffers_string_vec_ref_t v4",
            "+#define __reflection_RPCCall_call_args ,\\",
            "+  v0, v1, v2, v3, v4",
            "+static inline reflection_RPCCall_ref_t reflection_RPCCall_create(flatbuffers_builder_t *B __reflection_RPCCall_formal_args);",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_RPCCall, reflection_RPCCall_file_identifier, reflection_RPCCall_type_identifier)",
            "+",
            "+#define __reflection_Service_formal_args , flatbuffers_string_ref_t v0, reflection_RPCCall_vec_ref_t v1, reflection_KeyValue_vec_ref_t v2, flatbuffers_string_vec_ref_t v3",
            "+#define __reflection_Service_call_args , v0, v1, v2, v3",
            "+static inline reflection_Service_ref_t reflection_Service_create(flatbuffers_builder_t *B __reflection_Service_formal_args);",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_Service, reflection_Service_file_identifier, reflection_Service_type_identifier)",
            " ",
            " #define __reflection_Schema_formal_args ,\\",
            "-  reflection_Object_vec_ref_t v0, reflection_Enum_vec_ref_t v1, flatbuffers_string_ref_t v2, flatbuffers_string_ref_t v3, reflection_Object_ref_t v4",
            "+  reflection_Object_vec_ref_t v0, reflection_Enum_vec_ref_t v1, flatbuffers_string_ref_t v2, flatbuffers_string_ref_t v3, reflection_Object_ref_t v4, reflection_Service_vec_ref_t v5",
            " #define __reflection_Schema_call_args ,\\",
            "-  v0, v1, v2, v3, v4",
            "+  v0, v1, v2, v3, v4, v5",
            " static inline reflection_Schema_ref_t reflection_Schema_create(flatbuffers_builder_t *B __reflection_Schema_formal_args);",
            "-__flatbuffers_build_table_prolog(flatbuffers_, reflection_Schema, reflection_Schema_identifier, reflection_Schema_type_identifier)",
            "+__flatbuffers_build_table_prolog(flatbuffers_, reflection_Schema, reflection_Schema_file_identifier, reflection_Schema_type_identifier)",
            " ",
            " __flatbuffers_build_scalar_field(0, flatbuffers_, reflection_Type_base_type, reflection_BaseType, reflection_BaseType_enum_t, 1, 1, INT8_C(0), reflection_Type)",
            " __flatbuffers_build_scalar_field(1, flatbuffers_, reflection_Type_element, reflection_BaseType, reflection_BaseType_enum_t, 1, 1, INT8_C(0), reflection_Type)",
            " __flatbuffers_build_scalar_field(2, flatbuffers_, reflection_Type_index, flatbuffers_int32, int32_t, 4, 4, INT32_C(-1), reflection_Type)",
            "+__flatbuffers_build_scalar_field(3, flatbuffers_, reflection_Type_fixed_length, flatbuffers_uint16, uint16_t, 2, 2, UINT16_C(0), reflection_Type)",
            " ",
            " static inline reflection_Type_ref_t reflection_Type_create(flatbuffers_builder_t *B __reflection_Type_formal_args)",
            " {",
            "     if (reflection_Type_start(B)",
            "         || reflection_Type_index_add(B, v2)",
            "+        || reflection_Type_fixed_length_add(B, v3)",
            "         || reflection_Type_base_type_add(B, v0)",
            "         || reflection_Type_element_add(B, v1)) {",
            "         return 0;",
            "     }",
            "     return reflection_Type_end(B);",
            " }",
            " ",
            " static reflection_Type_ref_t reflection_Type_clone(flatbuffers_builder_t *B, reflection_Type_table_t t)",
            " {",
            "     __flatbuffers_memoize_begin(B, t);",
            "     if (reflection_Type_start(B)",
            "         || reflection_Type_index_pick(B, t)",
            "+        || reflection_Type_fixed_length_pick(B, t)",
            "         || reflection_Type_base_type_pick(B, t)",
            "         || reflection_Type_element_pick(B, t)) {",
            "         return 0;",
            "     }",
            "     __flatbuffers_memoize_end(B, t, reflection_Type_end(B));",
            " }",
            " ",
            "@@ -150,141 +181,155 @@",
            "     __flatbuffers_memoize_end(B, t, reflection_KeyValue_end(B));",
            " }",
            " ",
            " __flatbuffers_build_string_field(0, flatbuffers_, reflection_EnumVal_name, reflection_EnumVal)",
            " __flatbuffers_build_scalar_field(1, flatbuffers_, reflection_EnumVal_value, flatbuffers_int64, int64_t, 8, 8, INT64_C(0), reflection_EnumVal)",
            " __flatbuffers_build_table_field(2, flatbuffers_, reflection_EnumVal_object, reflection_Object, reflection_EnumVal)",
            " __flatbuffers_build_table_field(3, flatbuffers_, reflection_EnumVal_union_type, reflection_Type, reflection_EnumVal)",
            "+__flatbuffers_build_string_vector_field(4, flatbuffers_, reflection_EnumVal_documentation, reflection_EnumVal)",
            " ",
            " static inline reflection_EnumVal_ref_t reflection_EnumVal_create(flatbuffers_builder_t *B __reflection_EnumVal_formal_args)",
            " {",
            "     if (reflection_EnumVal_start(B)",
            "         || reflection_EnumVal_value_add(B, v1)",
            "         || reflection_EnumVal_name_add(B, v0)",
            "         || reflection_EnumVal_object_add(B, v2)",
            "-        || reflection_EnumVal_union_type_add(B, v3)) {",
            "+        || reflection_EnumVal_union_type_add(B, v3)",
            "+        || reflection_EnumVal_documentation_add(B, v4)) {",
            "         return 0;",
            "     }",
            "     return reflection_EnumVal_end(B);",
            " }",
            " ",
            " static reflection_EnumVal_ref_t reflection_EnumVal_clone(flatbuffers_builder_t *B, reflection_EnumVal_table_t t)",
            " {",
            "     __flatbuffers_memoize_begin(B, t);",
            "     if (reflection_EnumVal_start(B)",
            "         || reflection_EnumVal_value_pick(B, t)",
            "         || reflection_EnumVal_name_pick(B, t)",
            "         || reflection_EnumVal_object_pick(B, t)",
            "-        || reflection_EnumVal_union_type_pick(B, t)) {",
            "+        || reflection_EnumVal_union_type_pick(B, t)",
            "+        || reflection_EnumVal_documentation_pick(B, t)) {",
            "         return 0;",
            "     }",
            "     __flatbuffers_memoize_end(B, t, reflection_EnumVal_end(B));",
            " }",
            " ",
            " __flatbuffers_build_string_field(0, flatbuffers_, reflection_Enum_name, reflection_Enum)",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(1, flatbuffers_, reflection_Enum_values, reflection_EnumVal, reflection_Enum)",
            " __flatbuffers_build_scalar_field(2, flatbuffers_, reflection_Enum_is_union, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), reflection_Enum)",
            " __flatbuffers_build_table_field(3, flatbuffers_, reflection_Enum_underlying_type, reflection_Type, reflection_Enum)",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(4, flatbuffers_, reflection_Enum_attributes, reflection_KeyValue, reflection_Enum)",
            "+__flatbuffers_build_string_vector_field(5, flatbuffers_, reflection_Enum_documentation, reflection_Enum)",
            " ",
            " static inline reflection_Enum_ref_t reflection_Enum_create(flatbuffers_builder_t *B __reflection_Enum_formal_args)",
            " {",
            "     if (reflection_Enum_start(B)",
            "         || reflection_Enum_name_add(B, v0)",
            "         || reflection_Enum_values_add(B, v1)",
            "         || reflection_Enum_underlying_type_add(B, v3)",
            "         || reflection_Enum_attributes_add(B, v4)",
            "+        || reflection_Enum_documentation_add(B, v5)",
            "         || reflection_Enum_is_union_add(B, v2)) {",
            "         return 0;",
            "     }",
            "     return reflection_Enum_end(B);",
            " }",
            " ",
            " static reflection_Enum_ref_t reflection_Enum_clone(flatbuffers_builder_t *B, reflection_Enum_table_t t)",
            " {",
            "     __flatbuffers_memoize_begin(B, t);",
            "     if (reflection_Enum_start(B)",
            "         || reflection_Enum_name_pick(B, t)",
            "         || reflection_Enum_values_pick(B, t)",
            "         || reflection_Enum_underlying_type_pick(B, t)",
            "         || reflection_Enum_attributes_pick(B, t)",
            "+        || reflection_Enum_documentation_pick(B, t)",
            "         || reflection_Enum_is_union_pick(B, t)) {",
            "         return 0;",
            "     }",
            "     __flatbuffers_memoize_end(B, t, reflection_Enum_end(B));",
            " }",
            " ",
            " __flatbuffers_build_string_field(0, flatbuffers_, reflection_Field_name, reflection_Field)",
            " __flatbuffers_build_table_field(1, flatbuffers_, reflection_Field_type, reflection_Type, reflection_Field)",
            " __flatbuffers_build_scalar_field(2, flatbuffers_, reflection_Field_id, flatbuffers_uint16, uint16_t, 2, 2, UINT16_C(0), reflection_Field)",
            " __flatbuffers_build_scalar_field(3, flatbuffers_, reflection_Field_offset, flatbuffers_uint16, uint16_t, 2, 2, UINT16_C(0), reflection_Field)",
            " __flatbuffers_build_scalar_field(4, flatbuffers_, reflection_Field_default_integer, flatbuffers_int64, int64_t, 8, 8, INT64_C(0), reflection_Field)",
            "-__flatbuffers_build_scalar_field(5, flatbuffers_, reflection_Field_default_real, flatbuffers_double, double, 8, 8, 0.000000, reflection_Field)",
            "+__flatbuffers_build_scalar_field(5, flatbuffers_, reflection_Field_default_real, flatbuffers_double, double, 8, 8, 0.0000000000000000, reflection_Field)",
            " __flatbuffers_build_scalar_field(6, flatbuffers_, reflection_Field_deprecated, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), reflection_Field)",
            " __flatbuffers_build_scalar_field(7, flatbuffers_, reflection_Field_required, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), reflection_Field)",
            " __flatbuffers_build_scalar_field(8, flatbuffers_, reflection_Field_key, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), reflection_Field)",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(9, flatbuffers_, reflection_Field_attributes, reflection_KeyValue, reflection_Field)",
            "+__flatbuffers_build_string_vector_field(10, flatbuffers_, reflection_Field_documentation, reflection_Field)",
            "+__flatbuffers_build_scalar_field(11, flatbuffers_, reflection_Field_optional, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), reflection_Field)",
            " ",
            " static inline reflection_Field_ref_t reflection_Field_create(flatbuffers_builder_t *B __reflection_Field_formal_args)",
            " {",
            "     if (reflection_Field_start(B)",
            "         || reflection_Field_default_integer_add(B, v4)",
            "         || reflection_Field_default_real_add(B, v5)",
            "         || reflection_Field_name_add(B, v0)",
            "         || reflection_Field_type_add(B, v1)",
            "         || reflection_Field_attributes_add(B, v9)",
            "+        || reflection_Field_documentation_add(B, v10)",
            "         || reflection_Field_id_add(B, v2)",
            "         || reflection_Field_offset_add(B, v3)",
            "         || reflection_Field_deprecated_add(B, v6)",
            "         || reflection_Field_required_add(B, v7)",
            "-        || reflection_Field_key_add(B, v8)) {",
            "+        || reflection_Field_key_add(B, v8)",
            "+        || reflection_Field_optional_add(B, v11)) {",
            "         return 0;",
            "     }",
            "     return reflection_Field_end(B);",
            " }",
            " ",
            " static reflection_Field_ref_t reflection_Field_clone(flatbuffers_builder_t *B, reflection_Field_table_t t)",
            " {",
            "     __flatbuffers_memoize_begin(B, t);",
            "     if (reflection_Field_start(B)",
            "         || reflection_Field_default_integer_pick(B, t)",
            "         || reflection_Field_default_real_pick(B, t)",
            "         || reflection_Field_name_pick(B, t)",
            "         || reflection_Field_type_pick(B, t)",
            "         || reflection_Field_attributes_pick(B, t)",
            "+        || reflection_Field_documentation_pick(B, t)",
            "         || reflection_Field_id_pick(B, t)",
            "         || reflection_Field_offset_pick(B, t)",
            "         || reflection_Field_deprecated_pick(B, t)",
            "         || reflection_Field_required_pick(B, t)",
            "-        || reflection_Field_key_pick(B, t)) {",
            "+        || reflection_Field_key_pick(B, t)",
            "+        || reflection_Field_optional_pick(B, t)) {",
            "         return 0;",
            "     }",
            "     __flatbuffers_memoize_end(B, t, reflection_Field_end(B));",
            " }",
            " ",
            " __flatbuffers_build_string_field(0, flatbuffers_, reflection_Object_name, reflection_Object)",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(1, flatbuffers_, reflection_Object_fields, reflection_Field, reflection_Object)",
            " __flatbuffers_build_scalar_field(2, flatbuffers_, reflection_Object_is_struct, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(0), reflection_Object)",
            " __flatbuffers_build_scalar_field(3, flatbuffers_, reflection_Object_minalign, flatbuffers_int32, int32_t, 4, 4, INT32_C(0), reflection_Object)",
            " __flatbuffers_build_scalar_field(4, flatbuffers_, reflection_Object_bytesize, flatbuffers_int32, int32_t, 4, 4, INT32_C(0), reflection_Object)",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(5, flatbuffers_, reflection_Object_attributes, reflection_KeyValue, reflection_Object)",
            "+__flatbuffers_build_string_vector_field(6, flatbuffers_, reflection_Object_documentation, reflection_Object)",
            " ",
            " static inline reflection_Object_ref_t reflection_Object_create(flatbuffers_builder_t *B __reflection_Object_formal_args)",
            " {",
            "     if (reflection_Object_start(B)",
            "         || reflection_Object_name_add(B, v0)",
            "         || reflection_Object_fields_add(B, v1)",
            "         || reflection_Object_minalign_add(B, v3)",
            "         || reflection_Object_bytesize_add(B, v4)",
            "         || reflection_Object_attributes_add(B, v5)",
            "+        || reflection_Object_documentation_add(B, v6)",
            "         || reflection_Object_is_struct_add(B, v2)) {",
            "         return 0;",
            "     }",
            "     return reflection_Object_end(B);",
            " }",
            " ",
            " static reflection_Object_ref_t reflection_Object_clone(flatbuffers_builder_t *B, reflection_Object_table_t t)",
            "@@ -292,50 +337,121 @@",
            "     __flatbuffers_memoize_begin(B, t);",
            "     if (reflection_Object_start(B)",
            "         || reflection_Object_name_pick(B, t)",
            "         || reflection_Object_fields_pick(B, t)",
            "         || reflection_Object_minalign_pick(B, t)",
            "         || reflection_Object_bytesize_pick(B, t)",
            "         || reflection_Object_attributes_pick(B, t)",
            "+        || reflection_Object_documentation_pick(B, t)",
            "         || reflection_Object_is_struct_pick(B, t)) {",
            "         return 0;",
            "     }",
            "     __flatbuffers_memoize_end(B, t, reflection_Object_end(B));",
            " }",
            " ",
            "+__flatbuffers_build_string_field(0, flatbuffers_, reflection_RPCCall_name, reflection_RPCCall)",
            "+__flatbuffers_build_table_field(1, flatbuffers_, reflection_RPCCall_request, reflection_Object, reflection_RPCCall)",
            "+__flatbuffers_build_table_field(2, flatbuffers_, reflection_RPCCall_response, reflection_Object, reflection_RPCCall)",
            "+/* vector has keyed elements */",
            "+__flatbuffers_build_table_vector_field(3, flatbuffers_, reflection_RPCCall_attributes, reflection_KeyValue, reflection_RPCCall)",
            "+__flatbuffers_build_string_vector_field(4, flatbuffers_, reflection_RPCCall_documentation, reflection_RPCCall)",
            "+",
            "+static inline reflection_RPCCall_ref_t reflection_RPCCall_create(flatbuffers_builder_t *B __reflection_RPCCall_formal_args)",
            "+{",
            "+    if (reflection_RPCCall_start(B)",
            "+        || reflection_RPCCall_name_add(B, v0)",
            "+        || reflection_RPCCall_request_add(B, v1)",
            "+        || reflection_RPCCall_response_add(B, v2)",
            "+        || reflection_RPCCall_attributes_add(B, v3)",
            "+        || reflection_RPCCall_documentation_add(B, v4)) {",
            "+        return 0;",
            "+    }",
            "+    return reflection_RPCCall_end(B);",
            "+}",
            "+",
            "+static reflection_RPCCall_ref_t reflection_RPCCall_clone(flatbuffers_builder_t *B, reflection_RPCCall_table_t t)",
            "+{",
            "+    __flatbuffers_memoize_begin(B, t);",
            "+    if (reflection_RPCCall_start(B)",
            "+        || reflection_RPCCall_name_pick(B, t)",
            "+        || reflection_RPCCall_request_pick(B, t)",
            "+        || reflection_RPCCall_response_pick(B, t)",
            "+        || reflection_RPCCall_attributes_pick(B, t)",
            "+        || reflection_RPCCall_documentation_pick(B, t)) {",
            "+        return 0;",
            "+    }",
            "+    __flatbuffers_memoize_end(B, t, reflection_RPCCall_end(B));",
            "+}",
            "+",
            "+__flatbuffers_build_string_field(0, flatbuffers_, reflection_Service_name, reflection_Service)",
            "+/* vector has keyed elements */",
            "+__flatbuffers_build_table_vector_field(1, flatbuffers_, reflection_Service_calls, reflection_RPCCall, reflection_Service)",
            "+/* vector has keyed elements */",
            "+__flatbuffers_build_table_vector_field(2, flatbuffers_, reflection_Service_attributes, reflection_KeyValue, reflection_Service)",
            "+__flatbuffers_build_string_vector_field(3, flatbuffers_, reflection_Service_documentation, reflection_Service)",
            "+",
            "+static inline reflection_Service_ref_t reflection_Service_create(flatbuffers_builder_t *B __reflection_Service_formal_args)",
            "+{",
            "+    if (reflection_Service_start(B)",
            "+        || reflection_Service_name_add(B, v0)",
            "+        || reflection_Service_calls_add(B, v1)",
            "+        || reflection_Service_attributes_add(B, v2)",
            "+        || reflection_Service_documentation_add(B, v3)) {",
            "+        return 0;",
            "+    }",
            "+    return reflection_Service_end(B);",
            "+}",
            "+",
            "+static reflection_Service_ref_t reflection_Service_clone(flatbuffers_builder_t *B, reflection_Service_table_t t)",
            "+{",
            "+    __flatbuffers_memoize_begin(B, t);",
            "+    if (reflection_Service_start(B)",
            "+        || reflection_Service_name_pick(B, t)",
            "+        || reflection_Service_calls_pick(B, t)",
            "+        || reflection_Service_attributes_pick(B, t)",
            "+        || reflection_Service_documentation_pick(B, t)) {",
            "+        return 0;",
            "+    }",
            "+    __flatbuffers_memoize_end(B, t, reflection_Service_end(B));",
            "+}",
            "+",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(0, flatbuffers_, reflection_Schema_objects, reflection_Object, reflection_Schema)",
            " /* vector has keyed elements */",
            " __flatbuffers_build_table_vector_field(1, flatbuffers_, reflection_Schema_enums, reflection_Enum, reflection_Schema)",
            " __flatbuffers_build_string_field(2, flatbuffers_, reflection_Schema_file_ident, reflection_Schema)",
            " __flatbuffers_build_string_field(3, flatbuffers_, reflection_Schema_file_ext, reflection_Schema)",
            " __flatbuffers_build_table_field(4, flatbuffers_, reflection_Schema_root_table, reflection_Object, reflection_Schema)",
            "+/* vector has keyed elements */",
            "+__flatbuffers_build_table_vector_field(5, flatbuffers_, reflection_Schema_services, reflection_Service, reflection_Schema)",
            " ",
            " static inline reflection_Schema_ref_t reflection_Schema_create(flatbuffers_builder_t *B __reflection_Schema_formal_args)",
            " {",
            "     if (reflection_Schema_start(B)",
            "         || reflection_Schema_objects_add(B, v0)",
            "         || reflection_Schema_enums_add(B, v1)",
            "         || reflection_Schema_file_ident_add(B, v2)",
            "         || reflection_Schema_file_ext_add(B, v3)",
            "-        || reflection_Schema_root_table_add(B, v4)) {",
            "+        || reflection_Schema_root_table_add(B, v4)",
            "+        || reflection_Schema_services_add(B, v5)) {",
            "         return 0;",
            "     }",
            "     return reflection_Schema_end(B);",
            " }",
            " ",
            " static reflection_Schema_ref_t reflection_Schema_clone(flatbuffers_builder_t *B, reflection_Schema_table_t t)",
            " {",
            "     __flatbuffers_memoize_begin(B, t);",
            "     if (reflection_Schema_start(B)",
            "         || reflection_Schema_objects_pick(B, t)",
            "         || reflection_Schema_enums_pick(B, t)",
            "         || reflection_Schema_file_ident_pick(B, t)",
            "         || reflection_Schema_file_ext_pick(B, t)",
            "-        || reflection_Schema_root_table_pick(B, t)) {",
            "+        || reflection_Schema_root_table_pick(B, t)",
            "+        || reflection_Schema_services_pick(B, t)) {",
            "         return 0;",
            "     }",
            "     __flatbuffers_memoize_end(B, t, reflection_Schema_end(B));",
            " }",
            " ",
            " #include \"flatcc/flatcc_epilogue.h\"",
            " #endif /* REFLECTION_BUILDER_H */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/reflection/reflection_reader.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/reflection/reflection_reader.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/reflection/reflection_reader.h",
            "@@ -1,82 +1,170 @@",
            " #ifndef REFLECTION_READER_H",
            " #define REFLECTION_READER_H",
            " ",
            "-/* Generated by flatcc 0.5.3 FlatBuffers schema compiler for C by dvide.com */",
            "+/* Generated by flatcc 0.6.1 FlatBuffers schema compiler for C by dvide.com */",
            " ",
            " #ifndef FLATBUFFERS_COMMON_READER_H",
            " #include \"flatbuffers_common_reader.h\"",
            " #endif",
            " #include \"flatcc/flatcc_flatbuffers.h\"",
            " #ifndef __alignas_is_defined",
            " #include <stdalign.h>",
            " #endif",
            " #include \"flatcc/flatcc_prologue.h\"",
            " #undef flatbuffers_identifier",
            " #define flatbuffers_identifier \"BFBS\"",
            " #undef flatbuffers_extension",
            "-#define flatbuffers_extension \".bfbs\"",
            "+#define flatbuffers_extension \"bfbs\"",
            " ",
            " ",
            " typedef const struct reflection_Type_table *reflection_Type_table_t;",
            "+typedef struct reflection_Type_table *reflection_Type_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_Type_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_Type_mutable_vec_t;",
            " typedef const struct reflection_KeyValue_table *reflection_KeyValue_table_t;",
            "+typedef struct reflection_KeyValue_table *reflection_KeyValue_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_KeyValue_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_KeyValue_mutable_vec_t;",
            " typedef const struct reflection_EnumVal_table *reflection_EnumVal_table_t;",
            "+typedef struct reflection_EnumVal_table *reflection_EnumVal_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_EnumVal_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_EnumVal_mutable_vec_t;",
            " typedef const struct reflection_Enum_table *reflection_Enum_table_t;",
            "+typedef struct reflection_Enum_table *reflection_Enum_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_Enum_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_Enum_mutable_vec_t;",
            " typedef const struct reflection_Field_table *reflection_Field_table_t;",
            "+typedef struct reflection_Field_table *reflection_Field_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_Field_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_Field_mutable_vec_t;",
            " typedef const struct reflection_Object_table *reflection_Object_table_t;",
            "+typedef struct reflection_Object_table *reflection_Object_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_Object_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_Object_mutable_vec_t;",
            "+typedef const struct reflection_RPCCall_table *reflection_RPCCall_table_t;",
            "+typedef struct reflection_RPCCall_table *reflection_RPCCall_mutable_table_t;",
            "+typedef const flatbuffers_uoffset_t *reflection_RPCCall_vec_t;",
            "+typedef flatbuffers_uoffset_t *reflection_RPCCall_mutable_vec_t;",
            "+typedef const struct reflection_Service_table *reflection_Service_table_t;",
            "+typedef struct reflection_Service_table *reflection_Service_mutable_table_t;",
            "+typedef const flatbuffers_uoffset_t *reflection_Service_vec_t;",
            "+typedef flatbuffers_uoffset_t *reflection_Service_mutable_vec_t;",
            " typedef const struct reflection_Schema_table *reflection_Schema_table_t;",
            "+typedef struct reflection_Schema_table *reflection_Schema_mutable_table_t;",
            " typedef const flatbuffers_uoffset_t *reflection_Schema_vec_t;",
            " typedef flatbuffers_uoffset_t *reflection_Schema_mutable_vec_t;",
            "+#ifndef reflection_Type_file_identifier",
            "+#define reflection_Type_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_Type_file_identifier */",
            " #ifndef reflection_Type_identifier",
            "-#define reflection_Type_identifier flatbuffers_identifier",
            "+#define reflection_Type_identifier \"BFBS\"",
            " #endif",
            " #define reflection_Type_type_hash ((flatbuffers_thash_t)0x44c8fe5e)",
            " #define reflection_Type_type_identifier \"\\x5e\\xfe\\xc8\\x44\"",
            "+#ifndef reflection_Type_file_extension",
            "+#define reflection_Type_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_KeyValue_file_identifier",
            "+#define reflection_KeyValue_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_KeyValue_file_identifier */",
            " #ifndef reflection_KeyValue_identifier",
            "-#define reflection_KeyValue_identifier flatbuffers_identifier",
            "+#define reflection_KeyValue_identifier \"BFBS\"",
            " #endif",
            " #define reflection_KeyValue_type_hash ((flatbuffers_thash_t)0x8c761eaa)",
            " #define reflection_KeyValue_type_identifier \"\\xaa\\x1e\\x76\\x8c\"",
            "+#ifndef reflection_KeyValue_file_extension",
            "+#define reflection_KeyValue_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_EnumVal_file_identifier",
            "+#define reflection_EnumVal_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_EnumVal_file_identifier */",
            " #ifndef reflection_EnumVal_identifier",
            "-#define reflection_EnumVal_identifier flatbuffers_identifier",
            "+#define reflection_EnumVal_identifier \"BFBS\"",
            " #endif",
            " #define reflection_EnumVal_type_hash ((flatbuffers_thash_t)0x9531c946)",
            " #define reflection_EnumVal_type_identifier \"\\x46\\xc9\\x31\\x95\"",
            "+#ifndef reflection_EnumVal_file_extension",
            "+#define reflection_EnumVal_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_Enum_file_identifier",
            "+#define reflection_Enum_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_Enum_file_identifier */",
            " #ifndef reflection_Enum_identifier",
            "-#define reflection_Enum_identifier flatbuffers_identifier",
            "+#define reflection_Enum_identifier \"BFBS\"",
            " #endif",
            " #define reflection_Enum_type_hash ((flatbuffers_thash_t)0xacffa90f)",
            " #define reflection_Enum_type_identifier \"\\x0f\\xa9\\xff\\xac\"",
            "+#ifndef reflection_Enum_file_extension",
            "+#define reflection_Enum_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_Field_file_identifier",
            "+#define reflection_Field_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_Field_file_identifier */",
            " #ifndef reflection_Field_identifier",
            "-#define reflection_Field_identifier flatbuffers_identifier",
            "+#define reflection_Field_identifier \"BFBS\"",
            " #endif",
            " #define reflection_Field_type_hash ((flatbuffers_thash_t)0x9f7e408a)",
            " #define reflection_Field_type_identifier \"\\x8a\\x40\\x7e\\x9f\"",
            "+#ifndef reflection_Field_file_extension",
            "+#define reflection_Field_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_Object_file_identifier",
            "+#define reflection_Object_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_Object_file_identifier */",
            " #ifndef reflection_Object_identifier",
            "-#define reflection_Object_identifier flatbuffers_identifier",
            "+#define reflection_Object_identifier \"BFBS\"",
            " #endif",
            " #define reflection_Object_type_hash ((flatbuffers_thash_t)0xb09729bd)",
            " #define reflection_Object_type_identifier \"\\xbd\\x29\\x97\\xb0\"",
            "+#ifndef reflection_Object_file_extension",
            "+#define reflection_Object_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_RPCCall_file_identifier",
            "+#define reflection_RPCCall_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_RPCCall_file_identifier */",
            "+#ifndef reflection_RPCCall_identifier",
            "+#define reflection_RPCCall_identifier \"BFBS\"",
            "+#endif",
            "+#define reflection_RPCCall_type_hash ((flatbuffers_thash_t)0xe2d586f1)",
            "+#define reflection_RPCCall_type_identifier \"\\xf1\\x86\\xd5\\xe2\"",
            "+#ifndef reflection_RPCCall_file_extension",
            "+#define reflection_RPCCall_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_Service_file_identifier",
            "+#define reflection_Service_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_Service_file_identifier */",
            "+#ifndef reflection_Service_identifier",
            "+#define reflection_Service_identifier \"BFBS\"",
            "+#endif",
            "+#define reflection_Service_type_hash ((flatbuffers_thash_t)0xf31a13b5)",
            "+#define reflection_Service_type_identifier \"\\xb5\\x13\\x1a\\xf3\"",
            "+#ifndef reflection_Service_file_extension",
            "+#define reflection_Service_file_extension \"bfbs\"",
            "+#endif",
            "+#ifndef reflection_Schema_file_identifier",
            "+#define reflection_Schema_file_identifier \"BFBS\"",
            "+#endif",
            "+/* deprecated, use reflection_Schema_file_identifier */",
            " #ifndef reflection_Schema_identifier",
            "-#define reflection_Schema_identifier flatbuffers_identifier",
            "+#define reflection_Schema_identifier \"BFBS\"",
            " #endif",
            " #define reflection_Schema_type_hash ((flatbuffers_thash_t)0xfaf93779)",
            " #define reflection_Schema_type_identifier \"\\x79\\x37\\xf9\\xfa\"",
            "+#ifndef reflection_Schema_file_extension",
            "+#define reflection_Schema_file_extension \"bfbs\"",
            "+#endif",
            " ",
            " typedef int8_t reflection_BaseType_enum_t;",
            " __flatbuffers_define_integer_type(reflection_BaseType, reflection_BaseType_enum_t, 8)",
            " #define reflection_BaseType_None ((reflection_BaseType_enum_t)INT8_C(0))",
            " #define reflection_BaseType_UType ((reflection_BaseType_enum_t)INT8_C(1))",
            " #define reflection_BaseType_Bool ((reflection_BaseType_enum_t)INT8_C(2))",
            " #define reflection_BaseType_Byte ((reflection_BaseType_enum_t)INT8_C(3))",
            "@@ -89,14 +177,16 @@",
            " #define reflection_BaseType_ULong ((reflection_BaseType_enum_t)INT8_C(10))",
            " #define reflection_BaseType_Float ((reflection_BaseType_enum_t)INT8_C(11))",
            " #define reflection_BaseType_Double ((reflection_BaseType_enum_t)INT8_C(12))",
            " #define reflection_BaseType_String ((reflection_BaseType_enum_t)INT8_C(13))",
            " #define reflection_BaseType_Vector ((reflection_BaseType_enum_t)INT8_C(14))",
            " #define reflection_BaseType_Obj ((reflection_BaseType_enum_t)INT8_C(15))",
            " #define reflection_BaseType_Union ((reflection_BaseType_enum_t)INT8_C(16))",
            "+#define reflection_BaseType_Array ((reflection_BaseType_enum_t)INT8_C(17))",
            "+#define reflection_BaseType_MaxBaseType ((reflection_BaseType_enum_t)INT8_C(18))",
            " ",
            " static inline const char *reflection_BaseType_name(reflection_BaseType_enum_t value)",
            " {",
            "     switch (value) {",
            "     case reflection_BaseType_None: return \"None\";",
            "     case reflection_BaseType_UType: return \"UType\";",
            "     case reflection_BaseType_Bool: return \"Bool\";",
            "@@ -110,14 +200,16 @@",
            "     case reflection_BaseType_ULong: return \"ULong\";",
            "     case reflection_BaseType_Float: return \"Float\";",
            "     case reflection_BaseType_Double: return \"Double\";",
            "     case reflection_BaseType_String: return \"String\";",
            "     case reflection_BaseType_Vector: return \"Vector\";",
            "     case reflection_BaseType_Obj: return \"Obj\";",
            "     case reflection_BaseType_Union: return \"Union\";",
            "+    case reflection_BaseType_Array: return \"Array\";",
            "+    case reflection_BaseType_MaxBaseType: return \"MaxBaseType\";",
            "     default: return \"\";",
            "     }",
            " }",
            " ",
            " static inline int reflection_BaseType_is_known_value(reflection_BaseType_enum_t value)",
            " {",
            "     switch (value) {",
            "@@ -134,14 +226,16 @@",
            "     case reflection_BaseType_ULong: return 1;",
            "     case reflection_BaseType_Float: return 1;",
            "     case reflection_BaseType_Double: return 1;",
            "     case reflection_BaseType_String: return 1;",
            "     case reflection_BaseType_Vector: return 1;",
            "     case reflection_BaseType_Obj: return 1;",
            "     case reflection_BaseType_Union: return 1;",
            "+    case reflection_BaseType_Array: return 1;",
            "+    case reflection_BaseType_MaxBaseType: return 1;",
            "     default: return 0;",
            "     }",
            " }",
            " ",
            " ",
            " ",
            " struct reflection_Type_table { uint8_t unused__; };",
            "@@ -151,14 +245,15 @@",
            " static inline reflection_Type_table_t reflection_Type_vec_at(reflection_Type_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(reflection_Type_table_t, vec, i, 0)",
            " __flatbuffers_table_as_root(reflection_Type)",
            " ",
            " __flatbuffers_define_scalar_field(0, reflection_Type, base_type, reflection_BaseType, reflection_BaseType_enum_t, INT8_C(0))",
            " __flatbuffers_define_scalar_field(1, reflection_Type, element, reflection_BaseType, reflection_BaseType_enum_t, INT8_C(0))",
            " __flatbuffers_define_scalar_field(2, reflection_Type, index, flatbuffers_int32, int32_t, INT32_C(-1))",
            "+__flatbuffers_define_scalar_field(3, reflection_Type, fixed_length, flatbuffers_uint16, uint16_t, UINT16_C(0))",
            " ",
            " struct reflection_KeyValue_table { uint8_t unused__; };",
            " ",
            " static inline size_t reflection_KeyValue_vec_len(reflection_KeyValue_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline reflection_KeyValue_table_t reflection_KeyValue_vec_at(reflection_KeyValue_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(reflection_KeyValue_table_t, vec, i, 0)",
            "@@ -186,14 +281,15 @@",
            " __flatbuffers_define_find_by_scalar_field(reflection_EnumVal, value, int64_t)",
            " __flatbuffers_define_table_sort_by_scalar_field(reflection_EnumVal, value, int64_t)",
            " __flatbuffers_define_default_find_by_scalar_field(reflection_EnumVal, value, int64_t)",
            " __flatbuffers_define_default_scan_by_scalar_field(reflection_EnumVal, value, int64_t)",
            " #define reflection_EnumVal_vec_sort reflection_EnumVal_vec_sort_by_value",
            " __flatbuffers_define_table_field(2, reflection_EnumVal, object, reflection_Object_table_t, 0)",
            " __flatbuffers_define_table_field(3, reflection_EnumVal, union_type, reflection_Type_table_t, 0)",
            "+__flatbuffers_define_vector_field(4, reflection_EnumVal, documentation, flatbuffers_string_vec_t, 0)",
            " ",
            " struct reflection_Enum_table { uint8_t unused__; };",
            " ",
            " static inline size_t reflection_Enum_vec_len(reflection_Enum_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline reflection_Enum_table_t reflection_Enum_vec_at(reflection_Enum_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(reflection_Enum_table_t, vec, i, 0)",
            "@@ -205,14 +301,15 @@",
            " __flatbuffers_define_default_find_by_string_field(reflection_Enum, name)",
            " __flatbuffers_define_default_scan_by_string_field(reflection_Enum, name)",
            " #define reflection_Enum_vec_sort reflection_Enum_vec_sort_by_name",
            " __flatbuffers_define_vector_field(1, reflection_Enum, values, reflection_EnumVal_vec_t, 1)",
            " __flatbuffers_define_scalar_field(2, reflection_Enum, is_union, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(0))",
            " __flatbuffers_define_table_field(3, reflection_Enum, underlying_type, reflection_Type_table_t, 1)",
            " __flatbuffers_define_vector_field(4, reflection_Enum, attributes, reflection_KeyValue_vec_t, 0)",
            "+__flatbuffers_define_vector_field(5, reflection_Enum, documentation, flatbuffers_string_vec_t, 0)",
            " ",
            " struct reflection_Field_table { uint8_t unused__; };",
            " ",
            " static inline size_t reflection_Field_vec_len(reflection_Field_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline reflection_Field_table_t reflection_Field_vec_at(reflection_Field_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(reflection_Field_table_t, vec, i, 0)",
            "@@ -224,19 +321,21 @@",
            " __flatbuffers_define_default_find_by_string_field(reflection_Field, name)",
            " __flatbuffers_define_default_scan_by_string_field(reflection_Field, name)",
            " #define reflection_Field_vec_sort reflection_Field_vec_sort_by_name",
            " __flatbuffers_define_table_field(1, reflection_Field, type, reflection_Type_table_t, 1)",
            " __flatbuffers_define_scalar_field(2, reflection_Field, id, flatbuffers_uint16, uint16_t, UINT16_C(0))",
            " __flatbuffers_define_scalar_field(3, reflection_Field, offset, flatbuffers_uint16, uint16_t, UINT16_C(0))",
            " __flatbuffers_define_scalar_field(4, reflection_Field, default_integer, flatbuffers_int64, int64_t, INT64_C(0))",
            "-__flatbuffers_define_scalar_field(5, reflection_Field, default_real, flatbuffers_double, double, 0.000000)",
            "+__flatbuffers_define_scalar_field(5, reflection_Field, default_real, flatbuffers_double, double, 0.0000000000000000)",
            " __flatbuffers_define_scalar_field(6, reflection_Field, deprecated, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(0))",
            " __flatbuffers_define_scalar_field(7, reflection_Field, required, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(0))",
            " __flatbuffers_define_scalar_field(8, reflection_Field, key, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(0))",
            " __flatbuffers_define_vector_field(9, reflection_Field, attributes, reflection_KeyValue_vec_t, 0)",
            "+__flatbuffers_define_vector_field(10, reflection_Field, documentation, flatbuffers_string_vec_t, 0)",
            "+__flatbuffers_define_scalar_field(11, reflection_Field, optional, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(0))",
            " ",
            " struct reflection_Object_table { uint8_t unused__; };",
            " ",
            " static inline size_t reflection_Object_vec_len(reflection_Object_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline reflection_Object_table_t reflection_Object_vec_at(reflection_Object_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(reflection_Object_table_t, vec, i, 0)",
            "@@ -249,24 +348,64 @@",
            " __flatbuffers_define_default_scan_by_string_field(reflection_Object, name)",
            " #define reflection_Object_vec_sort reflection_Object_vec_sort_by_name",
            " __flatbuffers_define_vector_field(1, reflection_Object, fields, reflection_Field_vec_t, 1)",
            " __flatbuffers_define_scalar_field(2, reflection_Object, is_struct, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(0))",
            " __flatbuffers_define_scalar_field(3, reflection_Object, minalign, flatbuffers_int32, int32_t, INT32_C(0))",
            " __flatbuffers_define_scalar_field(4, reflection_Object, bytesize, flatbuffers_int32, int32_t, INT32_C(0))",
            " __flatbuffers_define_vector_field(5, reflection_Object, attributes, reflection_KeyValue_vec_t, 0)",
            "+__flatbuffers_define_vector_field(6, reflection_Object, documentation, flatbuffers_string_vec_t, 0)",
            "+",
            "+struct reflection_RPCCall_table { uint8_t unused__; };",
            "+",
            "+static inline size_t reflection_RPCCall_vec_len(reflection_RPCCall_vec_t vec)",
            "+__flatbuffers_vec_len(vec)",
            "+static inline reflection_RPCCall_table_t reflection_RPCCall_vec_at(reflection_RPCCall_vec_t vec, size_t i)",
            "+__flatbuffers_offset_vec_at(reflection_RPCCall_table_t, vec, i, 0)",
            "+__flatbuffers_table_as_root(reflection_RPCCall)",
            "+",
            "+__flatbuffers_define_string_field(0, reflection_RPCCall, name, 1)",
            "+__flatbuffers_define_find_by_string_field(reflection_RPCCall, name)",
            "+__flatbuffers_define_table_sort_by_string_field(reflection_RPCCall, name)",
            "+__flatbuffers_define_default_find_by_string_field(reflection_RPCCall, name)",
            "+__flatbuffers_define_default_scan_by_string_field(reflection_RPCCall, name)",
            "+#define reflection_RPCCall_vec_sort reflection_RPCCall_vec_sort_by_name",
            "+__flatbuffers_define_table_field(1, reflection_RPCCall, request, reflection_Object_table_t, 1)",
            "+__flatbuffers_define_table_field(2, reflection_RPCCall, response, reflection_Object_table_t, 1)",
            "+__flatbuffers_define_vector_field(3, reflection_RPCCall, attributes, reflection_KeyValue_vec_t, 0)",
            "+__flatbuffers_define_vector_field(4, reflection_RPCCall, documentation, flatbuffers_string_vec_t, 0)",
            "+",
            "+struct reflection_Service_table { uint8_t unused__; };",
            "+",
            "+static inline size_t reflection_Service_vec_len(reflection_Service_vec_t vec)",
            "+__flatbuffers_vec_len(vec)",
            "+static inline reflection_Service_table_t reflection_Service_vec_at(reflection_Service_vec_t vec, size_t i)",
            "+__flatbuffers_offset_vec_at(reflection_Service_table_t, vec, i, 0)",
            "+__flatbuffers_table_as_root(reflection_Service)",
            "+",
            "+__flatbuffers_define_string_field(0, reflection_Service, name, 1)",
            "+__flatbuffers_define_find_by_string_field(reflection_Service, name)",
            "+__flatbuffers_define_table_sort_by_string_field(reflection_Service, name)",
            "+__flatbuffers_define_default_find_by_string_field(reflection_Service, name)",
            "+__flatbuffers_define_default_scan_by_string_field(reflection_Service, name)",
            "+#define reflection_Service_vec_sort reflection_Service_vec_sort_by_name",
            "+__flatbuffers_define_vector_field(1, reflection_Service, calls, reflection_RPCCall_vec_t, 0)",
            "+__flatbuffers_define_vector_field(2, reflection_Service, attributes, reflection_KeyValue_vec_t, 0)",
            "+__flatbuffers_define_vector_field(3, reflection_Service, documentation, flatbuffers_string_vec_t, 0)",
            " ",
            " struct reflection_Schema_table { uint8_t unused__; };",
            " ",
            " static inline size_t reflection_Schema_vec_len(reflection_Schema_vec_t vec)",
            " __flatbuffers_vec_len(vec)",
            " static inline reflection_Schema_table_t reflection_Schema_vec_at(reflection_Schema_vec_t vec, size_t i)",
            " __flatbuffers_offset_vec_at(reflection_Schema_table_t, vec, i, 0)",
            " __flatbuffers_table_as_root(reflection_Schema)",
            " ",
            " __flatbuffers_define_vector_field(0, reflection_Schema, objects, reflection_Object_vec_t, 1)",
            " __flatbuffers_define_vector_field(1, reflection_Schema, enums, reflection_Enum_vec_t, 1)",
            " __flatbuffers_define_string_field(2, reflection_Schema, file_ident, 0)",
            " __flatbuffers_define_string_field(3, reflection_Schema, file_ext, 0)",
            " __flatbuffers_define_table_field(4, reflection_Schema, root_table, reflection_Object_table_t, 0)",
            "+__flatbuffers_define_vector_field(5, reflection_Schema, services, reflection_Service_vec_t, 0)",
            "+",
            " ",
            " #include \"flatcc/flatcc_epilogue.h\"",
            " #endif /* REFLECTION_READER_H */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/reflection/reflection_verifier.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/reflection/reflection_verifier.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/reflection/reflection_verifier.h",
            "@@ -1,32 +1,35 @@",
            " #ifndef REFLECTION_VERIFIER_H",
            " #define REFLECTION_VERIFIER_H",
            " ",
            "-/* Generated by flatcc 0.5.3 FlatBuffers schema compiler for C by dvide.com */",
            "+/* Generated by flatcc 0.6.1 FlatBuffers schema compiler for C by dvide.com */",
            " ",
            " #ifndef REFLECTION_READER_H",
            " #include \"reflection_reader.h\"",
            " #endif",
            " #include \"flatcc/flatcc_verifier.h\"",
            " #include \"flatcc/flatcc_prologue.h\"",
            " ",
            " static int reflection_Type_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " static int reflection_KeyValue_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " static int reflection_EnumVal_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " static int reflection_Enum_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " static int reflection_Field_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " static int reflection_Object_verify_table(flatcc_table_verifier_descriptor_t *td);",
            "+static int reflection_RPCCall_verify_table(flatcc_table_verifier_descriptor_t *td);",
            "+static int reflection_Service_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " static int reflection_Schema_verify_table(flatcc_table_verifier_descriptor_t *td);",
            " ",
            " static int reflection_Type_verify_table(flatcc_table_verifier_descriptor_t *td)",
            " {",
            "     int ret;",
            "     if ((ret = flatcc_verify_field(td, 0, 1, 1) /* base_type */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 1, 1, 1) /* element */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 2, 4, 4) /* index */)) return ret;",
            "+    if ((ret = flatcc_verify_field(td, 3, 2, 2) /* fixed_length */)) return ret;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int reflection_Type_verify_as_root(const void *buf, size_t bufsiz)",
            " {",
            "     return flatcc_verify_table_as_root(buf, bufsiz, reflection_Type_identifier, &reflection_Type_verify_table);",
            " }",
            "@@ -77,14 +80,15 @@",
            " static int reflection_EnumVal_verify_table(flatcc_table_verifier_descriptor_t *td)",
            " {",
            "     int ret;",
            "     if ((ret = flatcc_verify_string_field(td, 0, 1) /* name */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 1, 8, 8) /* value */)) return ret;",
            "     if ((ret = flatcc_verify_table_field(td, 2, 0, &reflection_Object_verify_table) /* object */)) return ret;",
            "     if ((ret = flatcc_verify_table_field(td, 3, 0, &reflection_Type_verify_table) /* union_type */)) return ret;",
            "+    if ((ret = flatcc_verify_string_vector_field(td, 4, 0) /* documentation */)) return ret;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int reflection_EnumVal_verify_as_root(const void *buf, size_t bufsiz)",
            " {",
            "     return flatcc_verify_table_as_root(buf, bufsiz, reflection_EnumVal_identifier, &reflection_EnumVal_verify_table);",
            " }",
            "@@ -108,14 +112,15 @@",
            " {",
            "     int ret;",
            "     if ((ret = flatcc_verify_string_field(td, 0, 1) /* name */)) return ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 1, 1, &reflection_EnumVal_verify_table) /* values */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 2, 1, 1) /* is_union */)) return ret;",
            "     if ((ret = flatcc_verify_table_field(td, 3, 1, &reflection_Type_verify_table) /* underlying_type */)) return ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 4, 0, &reflection_KeyValue_verify_table) /* attributes */)) return ret;",
            "+    if ((ret = flatcc_verify_string_vector_field(td, 5, 0) /* documentation */)) return ret;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int reflection_Enum_verify_as_root(const void *buf, size_t bufsiz)",
            " {",
            "     return flatcc_verify_table_as_root(buf, bufsiz, reflection_Enum_identifier, &reflection_Enum_verify_table);",
            " }",
            "@@ -144,14 +149,16 @@",
            "     if ((ret = flatcc_verify_field(td, 3, 2, 2) /* offset */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 4, 8, 8) /* default_integer */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 5, 8, 8) /* default_real */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 6, 1, 1) /* deprecated */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 7, 1, 1) /* required */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 8, 1, 1) /* key */)) return ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 9, 0, &reflection_KeyValue_verify_table) /* attributes */)) return ret;",
            "+    if ((ret = flatcc_verify_string_vector_field(td, 10, 0) /* documentation */)) return ret;",
            "+    if ((ret = flatcc_verify_field(td, 11, 1, 1) /* optional */)) return ret;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int reflection_Field_verify_as_root(const void *buf, size_t bufsiz)",
            " {",
            "     return flatcc_verify_table_as_root(buf, bufsiz, reflection_Field_identifier, &reflection_Field_verify_table);",
            " }",
            "@@ -176,14 +183,15 @@",
            "     int ret;",
            "     if ((ret = flatcc_verify_string_field(td, 0, 1) /* name */)) return ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 1, 1, &reflection_Field_verify_table) /* fields */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 2, 1, 1) /* is_struct */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 3, 4, 4) /* minalign */)) return ret;",
            "     if ((ret = flatcc_verify_field(td, 4, 4, 4) /* bytesize */)) return ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 5, 0, &reflection_KeyValue_verify_table) /* attributes */)) return ret;",
            "+    if ((ret = flatcc_verify_string_vector_field(td, 6, 0) /* documentation */)) return ret;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int reflection_Object_verify_as_root(const void *buf, size_t bufsiz)",
            " {",
            "     return flatcc_verify_table_as_root(buf, bufsiz, reflection_Object_identifier, &reflection_Object_verify_table);",
            " }",
            "@@ -199,22 +207,84 @@",
            " }",
            " ",
            " static inline int reflection_Object_verify_as_root_with_type_hash(const void *buf, size_t bufsiz, flatbuffers_thash_t thash)",
            " {",
            "     return flatcc_verify_table_as_typed_root(buf, bufsiz, thash, &reflection_Object_verify_table);",
            " }",
            " ",
            "+static int reflection_RPCCall_verify_table(flatcc_table_verifier_descriptor_t *td)",
            "+{",
            "+    int ret;",
            "+    if ((ret = flatcc_verify_string_field(td, 0, 1) /* name */)) return ret;",
            "+    if ((ret = flatcc_verify_table_field(td, 1, 1, &reflection_Object_verify_table) /* request */)) return ret;",
            "+    if ((ret = flatcc_verify_table_field(td, 2, 1, &reflection_Object_verify_table) /* response */)) return ret;",
            "+    if ((ret = flatcc_verify_table_vector_field(td, 3, 0, &reflection_KeyValue_verify_table) /* attributes */)) return ret;",
            "+    if ((ret = flatcc_verify_string_vector_field(td, 4, 0) /* documentation */)) return ret;",
            "+    return flatcc_verify_ok;",
            "+}",
            "+",
            "+static inline int reflection_RPCCall_verify_as_root(const void *buf, size_t bufsiz)",
            "+{",
            "+    return flatcc_verify_table_as_root(buf, bufsiz, reflection_RPCCall_identifier, &reflection_RPCCall_verify_table);",
            "+}",
            "+",
            "+static inline int reflection_RPCCall_verify_as_typed_root(const void *buf, size_t bufsiz)",
            "+{",
            "+    return flatcc_verify_table_as_root(buf, bufsiz, reflection_RPCCall_type_identifier, &reflection_RPCCall_verify_table);",
            "+}",
            "+",
            "+static inline int reflection_RPCCall_verify_as_root_with_identifier(const void *buf, size_t bufsiz, const char *fid)",
            "+{",
            "+    return flatcc_verify_table_as_root(buf, bufsiz, fid, &reflection_RPCCall_verify_table);",
            "+}",
            "+",
            "+static inline int reflection_RPCCall_verify_as_root_with_type_hash(const void *buf, size_t bufsiz, flatbuffers_thash_t thash)",
            "+{",
            "+    return flatcc_verify_table_as_typed_root(buf, bufsiz, thash, &reflection_RPCCall_verify_table);",
            "+}",
            "+",
            "+static int reflection_Service_verify_table(flatcc_table_verifier_descriptor_t *td)",
            "+{",
            "+    int ret;",
            "+    if ((ret = flatcc_verify_string_field(td, 0, 1) /* name */)) return ret;",
            "+    if ((ret = flatcc_verify_table_vector_field(td, 1, 0, &reflection_RPCCall_verify_table) /* calls */)) return ret;",
            "+    if ((ret = flatcc_verify_table_vector_field(td, 2, 0, &reflection_KeyValue_verify_table) /* attributes */)) return ret;",
            "+    if ((ret = flatcc_verify_string_vector_field(td, 3, 0) /* documentation */)) return ret;",
            "+    return flatcc_verify_ok;",
            "+}",
            "+",
            "+static inline int reflection_Service_verify_as_root(const void *buf, size_t bufsiz)",
            "+{",
            "+    return flatcc_verify_table_as_root(buf, bufsiz, reflection_Service_identifier, &reflection_Service_verify_table);",
            "+}",
            "+",
            "+static inline int reflection_Service_verify_as_typed_root(const void *buf, size_t bufsiz)",
            "+{",
            "+    return flatcc_verify_table_as_root(buf, bufsiz, reflection_Service_type_identifier, &reflection_Service_verify_table);",
            "+}",
            "+",
            "+static inline int reflection_Service_verify_as_root_with_identifier(const void *buf, size_t bufsiz, const char *fid)",
            "+{",
            "+    return flatcc_verify_table_as_root(buf, bufsiz, fid, &reflection_Service_verify_table);",
            "+}",
            "+",
            "+static inline int reflection_Service_verify_as_root_with_type_hash(const void *buf, size_t bufsiz, flatbuffers_thash_t thash)",
            "+{",
            "+    return flatcc_verify_table_as_typed_root(buf, bufsiz, thash, &reflection_Service_verify_table);",
            "+}",
            "+",
            " static int reflection_Schema_verify_table(flatcc_table_verifier_descriptor_t *td)",
            " {",
            "     int ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 0, 1, &reflection_Object_verify_table) /* objects */)) return ret;",
            "     if ((ret = flatcc_verify_table_vector_field(td, 1, 1, &reflection_Enum_verify_table) /* enums */)) return ret;",
            "     if ((ret = flatcc_verify_string_field(td, 2, 0) /* file_ident */)) return ret;",
            "     if ((ret = flatcc_verify_string_field(td, 3, 0) /* file_ext */)) return ret;",
            "     if ((ret = flatcc_verify_table_field(td, 4, 0, &reflection_Object_verify_table) /* root_table */)) return ret;",
            "+    if ((ret = flatcc_verify_table_vector_field(td, 5, 0, &reflection_Service_verify_table) /* services */)) return ret;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int reflection_Schema_verify_as_root(const void *buf, size_t bufsiz)",
            " {",
            "     return flatcc_verify_table_as_root(buf, bufsiz, reflection_Schema_identifier, &reflection_Schema_verify_table);",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/support/cdump.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/support/cdump.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/support/cdump.h",
            "@@ -4,17 +4,16 @@",
            " #ifdef __cplusplus",
            " extern \"C\" {",
            " #endif",
            " ",
            " #include <stdio.h>",
            " ",
            " /* Generates a constant a C byte array. */",
            "-static void cdump(char *name, void *addr, size_t len, FILE *fp) {",
            "+static void cdump(const char *name, void *addr, size_t len, FILE *fp) {",
            "     unsigned int i;",
            "-    unsigned char buff[17];",
            "     unsigned char *pc = (unsigned char*)addr;",
            " ",
            "     // Output description if given.",
            "     name = name ? name : \"dump\";",
            "     fprintf(fp, \"const unsigned char %s[] = {\", name);",
            " ",
            "     // Process every byte in the data."
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/support/elapsed.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/support/elapsed.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/support/elapsed.h",
            "@@ -12,15 +12,15 @@",
            " #include <sys/time.h>",
            " static double elapsed_realtime(void) { // returns 0 seconds first time called",
            "     static struct timeval t0;",
            "     struct timeval tv;",
            "     gettimeofday(&tv, 0);",
            "     if (!t0.tv_sec)",
            "         t0 = tv;",
            "-    return tv.tv_sec - t0.tv_sec + (tv.tv_usec - t0.tv_usec) / 1000000.;",
            "+    return (double)(tv.tv_sec - t0.tv_sec) + (double)(tv.tv_usec - t0.tv_usec) / 1e6;",
            " }",
            " #else",
            " #include <windows.h>",
            " #ifndef FatalError",
            " #define FatalError(s) do { perror(s); exit(-1); } while(0)",
            " #endif",
            " static double elapsed_realtime(void) { // granularity about 50 microsecs on my machine",
            "@@ -44,15 +44,15 @@",
            "     double tdiff = t2 - t1;",
            "     double nstime;",
            " ",
            "     printf(\"operation: %s\\n\", descr);",
            "     printf(\"elapsed time: %.3f (s)\\n\", tdiff);",
            "     printf(\"iterations: %d\\n\", rep);",
            "     printf(\"size: %lu (bytes)\\n\", (unsigned long)size);",
            "-    printf(\"bandwidth: %.3f (MB/s)\\n\", (double)rep * size / 1e6 / tdiff);",
            "+    printf(\"bandwidth: %.3f (MB/s)\\n\", (double)rep * (double)size / 1e6 / tdiff);",
            "     printf(\"throughput in ops per sec: %.3f\\n\", rep / tdiff);",
            "     if (reptext && rep != 1) {",
            "         printf(\"throughput in %s ops per sec: %.3f\\n\", reptext, 1 / tdiff);",
            "     }",
            "     nstime = tdiff * 1e9 / rep;",
            "     if (nstime < 1000) {",
            "         printf(\"time per op: %.3f (ns)\\n\", nstime);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/support/hexdump.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/support/hexdump.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/support/hexdump.h",
            "@@ -4,18 +4,18 @@",
            " #ifdef __cplusplus",
            " extern \"C\" {",
            " #endif",
            " ",
            " #include <stdio.h>",
            " ",
            " /* Based on: http://stackoverflow.com/a/7776146 */",
            "-static void hexdump(char *desc, void *addr, size_t len, FILE *fp) {",
            "+static void hexdump(const char *desc, const void *addr, size_t len, FILE *fp) {",
            "     unsigned int i;",
            "     unsigned char buf[17];",
            "-    unsigned char *pc = (unsigned char*)addr;",
            "+    const unsigned char *pc = (const unsigned char*)addr;",
            " ",
            "     /* Output description if given. */",
            "     if (desc != NULL) fprintf(fp, \"%s:\\n\", desc);",
            " ",
            "     for (i = 0; i < (unsigned int)len; i++) {",
            " ",
            "         if ((i % 16) == 0) {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/include/flatcc/support/readfile.h",
          "change": [
            "--- /home/flatcc-0.5.3/include/flatcc/support/readfile.h",
            "+++ /home/flatcc-0.6.1/include/flatcc/support/readfile.h",
            "@@ -7,34 +7,37 @@",
            " ",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " ",
            " static char *readfile(const char *filename, size_t max_size, size_t *size_out)",
            " {",
            "     FILE *fp;",
            "+    long k;",
            "     size_t size, pos, n, _out;",
            "     char *buf;",
            " ",
            "     size_out = size_out ? size_out : &_out;",
            " ",
            "     fp = fopen(filename, \"rb\");",
            "     size = 0;",
            "     buf = 0;",
            " ",
            "     if (!fp) {",
            "         goto fail;",
            "     }",
            "     fseek(fp, 0L, SEEK_END);",
            "-    size = ftell(fp);",
            "+    k = ftell(fp);",
            "+    if (k < 0) goto fail;",
            "+    size = (size_t)k;",
            "     *size_out = size;",
            "     if (max_size > 0 && size > max_size) {",
            "         goto fail;",
            "     }",
            "     rewind(fp);",
            "-    buf = malloc(size ? size : 1);",
            "+    buf = (char *)malloc(size ? size : 1);",
            "     if (!buf) {",
            "         goto fail;",
            "     }",
            "     pos = 0;",
            "     while ((n = fread(buf + pos, 1, size - pos, fp))) {",
            "         pos += n;",
            "     }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/samples/monster/monster.c",
          "change": [
            "--- /home/flatcc-0.5.3/samples/monster/monster.c",
            "+++ /home/flatcc-0.6.1/samples/monster/monster.c",
            "@@ -25,19 +25,19 @@",
            " #define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)",
            " ",
            " // Bottom-up approach where we create child objects and store these",
            " // in temporary references before a parent object is created with",
            " // these references.",
            " int create_monster_bottom_up(flatcc_builder_t *B, int flexible)",
            " {",
            "-    ns(Weapon_ref_t) weapon_one_name = flatbuffers_string_create_str(B, \"Sword\");",
            "-    uint16_t weapon_one_damage = 3;",
            "+    flatbuffers_string_ref_t weapon_one_name = flatbuffers_string_create_str(B, \"Sword\");",
            "+    int16_t weapon_one_damage = 3;",
            " ",
            "-    ns(Weapon_ref_t) weapon_two_name = flatbuffers_string_create_str(B, \"Axe\");",
            "-    uint16_t weapon_two_damage = 5;",
            "+    flatbuffers_string_ref_t weapon_two_name = flatbuffers_string_create_str(B, \"Axe\");",
            "+    int16_t weapon_two_damage = 5;",
            " ",
            "     // Use the `MyGame_Sample_Weapon_create` shortcut to create Weapons",
            "     // with all the fields set.",
            "     //",
            "     // In the C-API, verbs (here create) always follow the type name",
            "     // (here Weapon), prefixed by the namespace (here MyGame_Sample_):",
            "     // MyGame_Sample_Weapon_create(...), or ns(Weapone_create(...)).",
            "@@ -66,17 +66,17 @@",
            " ",
            " ",
            "     // Create a `Vec3`, representing the Orc's position in 3-D space.",
            "     ns(Vec3_t) pos = { 1.0f, 2.0f, 3.0f };",
            " ",
            " ",
            "     // Set his hit points to 300 and his mana to 150.",
            "-    uint16_t hp = 300;",
            "+    int16_t hp = 300;",
            "     // The default value is 150, so we will never store this field.",
            "-    uint16_t mana = 150;",
            "+    int16_t mana = 150;",
            " ",
            "     // Create the equipment union. In the C++ language API this is given",
            "     // as two arguments to the create call, or as two separate add",
            "     // operations for the type and the table reference. Here we create",
            "     // a single union value that carries both the type and reference.",
            "     ns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));",
            " ",
            "@@ -206,16 +206,16 @@",
            "     ns(Monster_table_t) monster = ns(Monster_as_root(buffer));",
            " ",
            "     // Note: root object pointers are NOT the same as the `buffer` pointer.",
            " ",
            "     // Make sure the buffer is accessible.",
            "     test_assert(monster != 0);",
            " ",
            "-    uint16_t hp = ns(Monster_hp(monster));",
            "-    uint16_t mana = ns(Monster_mana(monster));",
            "+    int16_t hp = ns(Monster_hp(monster));",
            "+    int16_t mana = ns(Monster_mana(monster));",
            "     // This is just a const char *, but it also supports a fast length operation.",
            "     flatbuffers_string_t name = ns(Monster_name(monster));",
            "     size_t name_len = flatbuffers_string_len(name);",
            " ",
            "     test_assert(hp == 300);",
            "     // Since 150 is the default, we are reading a value that wasn't stored.",
            "     test_assert(mana == 150);",
            "@@ -267,25 +267,25 @@",
            "     test_assert(third_item == 2);",
            " ",
            "     ns(Weapon_vec_t) weapons = ns(Monster_weapons(monster));",
            "     size_t weapons_len = ns(Weapon_vec_len(weapons));",
            "     test_assert(weapons_len == 2);",
            "     // We can use `const char *` instead of `flatbuffers_string_t`.",
            "     const char *second_weapon_name = ns(Weapon_name(ns(Weapon_vec_at(weapons, 1))));",
            "-    uint16_t second_weapon_damage =  ns(Weapon_damage(ns(Weapon_vec_at(weapons, 1))));",
            "+    int16_t second_weapon_damage =  ns(Weapon_damage(ns(Weapon_vec_at(weapons, 1))));",
            "     test_assert(second_weapon_name != 0 && strcmp(second_weapon_name, \"Axe\") == 0);",
            "     test_assert(second_weapon_damage == 5);",
            " ",
            "     // Access union type field.",
            "     if (ns(Monster_equipped_type(monster)) == ns(Equipment_Weapon)) {",
            "         // Cast to appropriate type:",
            "         // C does not require the cast to Weapon_table_t, but C++ does.",
            "         ns(Weapon_table_t) weapon = (ns(Weapon_table_t)) ns(Monster_equipped(monster));",
            "         const char *weapon_name = ns(Weapon_name(weapon));",
            "-        uint16_t weapon_damage = ns(Weapon_damage(weapon));",
            "+        int16_t weapon_damage = ns(Weapon_damage(weapon));",
            " ",
            "         test_assert(0 == strcmp(weapon_name, \"Axe\"));",
            "         test_assert(weapon_damage == 5);",
            "     }",
            "     return 0;",
            " }",
            " ",
            "@@ -304,22 +304,25 @@",
            "     (void)argv;",
            " ",
            "     // Initialize the builder object.",
            "     flatcc_builder_init(&builder);",
            "     test_assert(0 == create_monster_bottom_up(&builder, 0));",
            " ",
            "     // Allocate and extract a readable buffer from internal builder heap.",
            "-    // The returned buffer must be deallocated using `free`.",
            "     // NOTE: Finalizing the buffer does NOT change the builder, it",
            "     // just creates a snapshot of the builder content.",
            "     // NOTE2: finalize_buffer uses malloc while finalize_aligned_buffer",
            "     // uses a portable aligned allocation method. Often the malloc",
            "     // version is sufficient, but won't work for all schema on all",
            "     // systems. If the buffer is written to disk or network, but not",
            "     // accessed in memory, `finalize_buffer` is also sufficient.",
            "+    // The flatcc_builder version of free or aligned_free should be used",
            "+    // instead of `free` although free will often work on POSIX systems.",
            "+    // This ensures portability and prevents issues when linking to",
            "+    // allocation libraries other than malloc.",
            "     buf = flatcc_builder_finalize_aligned_buffer(&builder, &size);",
            "     //buf = flatcc_builder_finalize_buffer(&builder, &size);",
            " ",
            "     // We now have a FlatBuffer we can store on disk or send over a network.",
            "     // ** file/network code goes here :) **",
            "     // Instead, we're going to access it right away (as if we just received it).",
            "     //access_monster_buffer(buf);",
            "@@ -336,15 +339,15 @@",
            "     buf = flatcc_builder_finalize_aligned_buffer(&builder, &size);",
            "     access_monster_buffer(buf);",
            "     flatcc_builder_aligned_free(buf);",
            "     flatcc_builder_reset(&builder);",
            "     create_monster_top_down(&builder);",
            "     buf = flatcc_builder_finalize_buffer(&builder, &size);",
            "     test_assert(0 == access_monster_buffer(buf));",
            "-    free(buf);",
            "+    flatcc_builder_free(buf);",
            "     // Eventually the builder must be cleaned up:",
            "     flatcc_builder_clear(&builder);",
            " ",
            "     printf(\"The FlatBuffer was successfully created and accessed!\\n\");",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/samples/reflection/bfbs2json.c",
          "change": [
            "--- /home/flatcc-0.5.3/samples/reflection/bfbs2json.c",
            "+++ /home/flatcc-0.6.1/samples/reflection/bfbs2json.c",
            "@@ -1,21 +1,24 @@",
            " #include \"flatcc/support/readfile.h\"",
            " #include \"flatcc/reflection/reflection_reader.h\"",
            " ",
            "-/* Portable way to print 64-bit integers. */",
            "-#define lld(x) (long long int)(x)",
            "+/* -DFLATCC_PORTABLE may help if inttypes.h is missing. */",
            "+#ifndef PRId64",
            "+#include <inttypes.h>",
            "+#endif",
            "+",
            " ",
            " /*",
            "  * Reads a binary schema generated by `flatcc` or Googles `flatc` tool,",
            "  * then prints the content out in a custom JSON format.",
            "  *",
            "  * Note: This is completely unrelated to `flatcc's` JSON support - we",
            "  * just needed to do something tangible with the data we read from the",
            "  * binary schema and opted to print it as JSON.",
            "- * ",
            "+ *",
            "  * The JSON can be pretty printed with an external tool, for example:",
            "  *",
            "  *     cat monster_test_schema.json | jq '.'",
            "  */",
            " ",
            " void print_type(reflection_Type_table_t T)",
            " {",
            "@@ -38,14 +41,21 @@",
            "     if (reflection_Type_index_is_present(T)) {",
            "         if (!first) {",
            "             printf(\",\");",
            "         }",
            "         printf(\"\\\"index\\\":%d\", reflection_Type_index(T));",
            "         first = 0;",
            "     }",
            "+    if (reflection_Type_fixed_length_is_present(T)) {",
            "+        if (!first) {",
            "+            printf(\",\");",
            "+        }",
            "+        printf(\"\\\"fixed_length\\\":%d\", reflection_Type_fixed_length(T));",
            "+        first = 0;",
            "+    }",
            "     printf(\"}\");",
            " }",
            " ",
            " void print_attributes(reflection_KeyValue_vec_t KV)",
            " {",
            "     size_t i;",
            "     reflection_KeyValue_table_t attribute;",
            "@@ -85,15 +95,15 @@",
            "         F = reflection_Field_vec_at(Flds, i);",
            "         printf(\"{\\\"name\\\":\\\"%s\\\",\\\"type\\\":\", reflection_Field_name(F));",
            "         print_type(reflection_Field_type(F));",
            "         if (reflection_Field_id_is_present(F)) {",
            "             printf(\",\\\"id\\\":%hu\", reflection_Field_id(F));",
            "         }",
            "         if (reflection_Field_default_integer_is_present(F)) {",
            "-            printf(\",\\\"default_integer\\\":%lld\", lld(reflection_Field_default_integer(F)));",
            "+            printf(\",\\\"default_integer\\\":%\"PRId64\"\", (int64_t)reflection_Field_default_integer(F));",
            "         }",
            "         if (reflection_Field_default_real_is_present(F)) {",
            "             printf(\",\\\"default_integer\\\":%lf\", reflection_Field_default_real(F));",
            "         }",
            "         if (reflection_Field_required_is_present(F)) {",
            "             printf(\",\\\"required\\\":%s\", reflection_Field_required(F) ? \"true\" : \"false\");",
            "         }",
            "@@ -135,24 +145,24 @@",
            "     for (i = 0; i < reflection_Enum_vec_len(EnumVals); ++i) {",
            "         EV = reflection_EnumVal_vec_at(EnumVals, i);",
            "         if (i > 0) {",
            "             printf(\",\");",
            "         }",
            "         printf(\"{\\\"name\\\":\\\"%s\\\"\", reflection_EnumVal_name(EV));",
            "         if (reflection_EnumVal_value_is_present(EV)) {",
            "-            printf(\",\\\"value\\\":%lld\", lld(reflection_EnumVal_value(EV)));",
            "+            printf(\",\\\"value\\\":%\"PRId64\"\", (int64_t)reflection_EnumVal_value(EV));",
            "         }",
            "         if (reflection_EnumVal_object_is_present(EV)) {",
            "             printf(\",\\\"object\\\":\");",
            "             print_object(reflection_EnumVal_object(EV));",
            "         }",
            "         if (reflection_EnumVal_union_type_is_present(EV)) {",
            "             printf(\",\\\"union_type\\\":\");",
            "             print_type(reflection_EnumVal_union_type(EV));",
            "-        } ",
            "+        }",
            "         printf(\"}\");",
            "     }",
            "     printf(\"]\");",
            "     if (reflection_Enum_is_union_is_present(E)) {",
            "         printf(\",\\\"is_union\\\":%s\", reflection_Enum_is_union(E) ? \"true\" : \"false\");",
            "     }",
            "     printf(\",\\\"underlying_type\\\":\");",
            "@@ -160,18 +170,58 @@",
            "     if (reflection_Enum_attributes_is_present(E)) {",
            "         printf(\",\\\"attributes\\\":\");",
            "         print_attributes(reflection_Enum_attributes(E));",
            "     }",
            "     printf(\"}\");",
            " }",
            " ",
            "+void print_call(reflection_RPCCall_table_t C)",
            "+{",
            "+    printf(\"{\\\"name\\\":\\\"%s\\\"\", reflection_RPCCall_name(C));",
            "+    printf(\",\\\"request\\\":\");",
            "+    print_object(reflection_RPCCall_request(C));",
            "+    printf(\",\\\"response\\\":\");",
            "+    print_object(reflection_RPCCall_response(C));",
            "+",
            "+    if (reflection_RPCCall_attributes_is_present(C)) {",
            "+        printf(\",\\\"attributes\\\":\");",
            "+        print_attributes(reflection_RPCCall_attributes(C));",
            "+    }",
            "+    printf(\"}\");",
            "+}",
            "+",
            "+void print_service(reflection_Service_table_t S)",
            "+{",
            "+    reflection_RPCCall_vec_t calls;",
            "+    size_t i;",
            "+",
            "+    printf(\"{\\\"name\\\":\\\"%s\\\"\", reflection_Service_name(S));",
            "+",
            "+    printf(\",\\\"calls\\\":[\");",
            "+    calls = reflection_Service_calls(S);",
            "+    for (i = 0; i < reflection_RPCCall_vec_len(calls); ++i) {",
            "+        if (i > 0) {",
            "+            printf(\",\");",
            "+        }",
            "+        print_call(reflection_RPCCall_vec_at(calls, i));",
            "+    }",
            "+    printf(\"]\");",
            "+",
            "+    if (reflection_Service_attributes_is_present(S)) {",
            "+        printf(\",\\\"attributes\\\":\");",
            "+        print_attributes(reflection_Service_attributes(S));",
            "+    }",
            "+    printf(\"}\");",
            "+}",
            "+",
            " void print_schema(reflection_Schema_table_t S)",
            " {",
            "     reflection_Object_vec_t Objs;",
            "     reflection_Enum_vec_t Enums;",
            "+    reflection_Service_vec_t Services;",
            "     size_t i;",
            " ",
            "     Objs = reflection_Schema_objects(S);",
            "     printf(\"{\");",
            "     printf(\"\\\"objects\\\":[\");",
            "     for (i = 0; i < reflection_Object_vec_len(Objs); ++i) {",
            "         if (i > 0) {",
            "@@ -195,14 +245,25 @@",
            "     if (reflection_Schema_file_ext_is_present(S)) {",
            "         printf(\",\\\"file_ext\\\":\\\"%s\\\"\", reflection_Schema_file_ext(S));",
            "     }",
            "     if (reflection_Schema_root_table_is_present(S)) {",
            "         printf(\",\\\"root_table\\\":\");",
            "         print_object(reflection_Schema_root_table(S));",
            "     }",
            "+    if (reflection_Schema_services_is_present(S)) {",
            "+        printf(\",\\\"services\\\":[\");",
            "+        Services = reflection_Schema_services(S);",
            "+        for (i = 0; i < reflection_Service_vec_len(Services); ++i) {",
            "+            if (i > 0) {",
            "+                printf(\",\");",
            "+            }",
            "+            print_service(reflection_Service_vec_at(Services, i));",
            "+        }",
            "+        printf(\"]\");",
            "+    }",
            "     printf(\"}\\n\");",
            " }",
            " ",
            " int load_and_dump_schema(const char *filename)",
            " {",
            "     void *buffer;",
            "     size_t size;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/cli/flatcc_cli.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/cli/flatcc_cli.c",
            "+++ /home/flatcc-0.6.1/src/cli/flatcc_cli.c",
            "@@ -161,24 +161,24 @@",
            " int set_opt(flatcc_options_t *opts, const char *s, const char *a)",
            " {",
            "     int ret = noarg;",
            "     size_t n = strlen(s);",
            "     const char *v = strchr(s, '=');",
            "     if (v) {",
            "         a = v + 1;",
            "-        n = v - s;",
            "+        n = (size_t)(v - s);",
            "     }",
            "     if (*s == 'h' || 0 == strcmp(\"-help\", s)) {",
            "         /* stdout so less and more works. */",
            "         help(stdout);",
            "         exit(0);",
            "     }",
            "     if (0 == strcmp(\"-version\", s)) {",
            "-        fprintf(stderr, \"%s\\n\", TITLE);",
            "-        fprintf(stderr, \"version: %s\\n\", VERSION);",
            "+        fprintf(stdout, \"%s\\n\", TITLE);",
            "+        fprintf(stdout, \"version: %s\\n\", VERSION);",
            "         exit(0);",
            "     }",
            "     if (0 == strcmp(\"-stdout\", s)) {",
            "         opts->gen_stdout = 1;",
            "         return noarg;",
            "     }",
            "     if (0 == strcmp(\"-common\", s)) {",
            "@@ -412,29 +412,31 @@",
            "     ctx = 0;",
            "     ret = 0;",
            "     if (argc < 2) {",
            "         usage(stderr);",
            "         exit(-1);",
            "     }",
            "     flatcc_init_options(&opts);",
            "-    if (!(opts.inpaths = malloc(argc * sizeof(char *)))) {",
            "+    if (!(opts.inpaths = malloc((size_t)argc * sizeof(char *)))) {",
            "         fprintf(stderr, \"memory allocation failure\\n\");",
            "         exit(-1);",
            "     }",
            "-    if (!(opts.srcpaths = malloc(argc * sizeof(char *)))) {",
            "+    if (!(opts.srcpaths = malloc((size_t)argc * sizeof(char *)))) {",
            "         fprintf(stderr, \"memory allocation failure\\n\");",
            "         free((void *)opts.inpaths);",
            "         exit(-1);",
            "     }",
            "- ",
            "+",
            "     parse_opts(argc, argv, &opts);",
            "-    opts.cgen_common_builder = opts.cgen_builder && opts.cgen_common_reader;",
            "+    if (opts.cgen_builder && opts.cgen_common_reader) {",
            "+        opts.cgen_common_builder = 1;",
            "+    }",
            "     if (opts.srcpath_count == 0) {",
            "-        /* No input files, so only generate header. */",
            "-        if (!opts.cgen_common_reader || opts.bgen_bfbs) {",
            "+        /* No input files, so only generate header(s). */",
            "+        if (!(opts.cgen_common_reader || opts.cgen_common_builder) || opts.bgen_bfbs) {",
            "             fprintf(stderr, \"filename missing\\n\");",
            "             goto fail;",
            "         }",
            "         if (!(ctx = flatcc_create_context(&opts, 0, 0, 0))) {",
            "             fprintf(stderr, \"internal error: failed to create parsing context\\n\");",
            "             goto fail;",
            "         }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/catalog.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/catalog.h",
            "+++ /home/flatcc-0.6.1/src/compiler/catalog.h",
            "@@ -6,14 +6,15 @@",
            " ",
            " /* Helper to build more intuitive schema data with fully qualified names. */",
            " ",
            " ",
            " typedef struct entry entry_t;",
            " typedef entry_t object_entry_t;",
            " typedef entry_t enum_entry_t;",
            "+typedef entry_t service_entry_t;",
            " typedef struct scope_entry scope_entry_t;",
            " ",
            " struct entry {",
            "     fb_compound_type_t *ct;",
            "     char *name;",
            " };",
            " ",
            "@@ -24,24 +25,29 @@",
            " ",
            " typedef struct catalog catalog_t;",
            " ",
            " struct catalog {",
            "     int qualify_names;",
            "     int nobjects;",
            "     int nenums;",
            "+    int nservices;",
            "     size_t name_table_size;",
            "     object_entry_t *objects;",
            "     enum_entry_t *enums;",
            "+    service_entry_t *services;",
            "     char *name_table;",
            "     object_entry_t *next_object;",
            "     enum_entry_t *next_enum;",
            "+    service_entry_t *next_service;",
            "     char *next_name;",
            "     fb_schema_t *schema;",
            " };",
            " ",
            "+#include <stdio.h>",
            "+",
            " static void count_symbol(void *context, fb_symbol_t *sym)",
            " {",
            "     catalog_t *catalog = context;",
            "     fb_ref_t *scope_name;",
            "     size_t n = 0;",
            "     fb_compound_type_t *ct;",
            "     ",
            "@@ -71,14 +77,17 @@",
            "     case fb_is_table:",
            "         ++catalog->nobjects;",
            "         break;",
            "     case fb_is_union:",
            "     case fb_is_enum:",
            "         ++catalog->nenums;",
            "         break;",
            "+    case fb_is_rpc_service:",
            "+        ++catalog->nservices;",
            "+        break;",
            "     default: return;",
            "     }",
            " }",
            " ",
            " static void install_symbol(void *context, fb_symbol_t *sym)",
            " {",
            "     catalog_t *catalog = context;",
            "@@ -92,23 +101,23 @@",
            "     }",
            " ",
            "     s = catalog->next_name;",
            "     name = s;",
            "     if (catalog->qualify_names) {",
            "         scope_name = ct->scope->name;",
            "         while (scope_name) {",
            "-            n = scope_name->ident->len;",
            "-            memcpy(s, scope_name->ident->text, n);",
            "+            n = (int)scope_name->ident->len;",
            "+            memcpy(s, scope_name->ident->text, (size_t)n);",
            "             s += n;",
            "             *s++ = '.';",
            "             scope_name = scope_name->link;",
            "         }",
            "     }",
            "-    n = sym->ident->len;",
            "-    memcpy(s, sym->ident->text, n);",
            "+    n = (int)sym->ident->len;",
            "+    memcpy(s, sym->ident->text, (size_t)n);",
            "     s += n;",
            "     *s++ = '\\0';",
            "     catalog->next_name = s;",
            " ",
            "     switch (sym->kind) {",
            "     case fb_is_struct:",
            "     case fb_is_table:",
            "@@ -118,14 +127,19 @@",
            "         break;",
            "     case fb_is_union:",
            "     case fb_is_enum:",
            "         catalog->next_enum->ct = (fb_compound_type_t *)sym;",
            "         catalog->next_enum->name = name;",
            "         catalog->next_enum++;",
            "         break;",
            "+    case fb_is_rpc_service:",
            "+        catalog->next_service->ct = (fb_compound_type_t *)sym;",
            "+        catalog->next_service->name = name;",
            "+        catalog->next_service++;",
            "+        break;",
            "     default: break;",
            "     }",
            " }",
            " ",
            " static void count_symbols(void *context, fb_scope_t *scope)",
            " {",
            "     fb_symbol_table_visit(&scope->symbol_index, count_symbol, context);",
            "@@ -141,56 +155,63 @@",
            "     return strcmp(((const entry_t *)x)->name, ((const entry_t *)y)->name);",
            " }",
            " ",
            " static void sort_entries(entry_t *entries, int count)",
            " {",
            "     int i;",
            " ",
            "-    qsort(entries, count, sizeof(entries[0]), compare_entries);",
            "+    qsort(entries, (size_t)count, sizeof(entries[0]), compare_entries);",
            " ",
            "     for (i = 0; i < count; ++i) {",
            "         entries[i].ct->export_index = (size_t)i;",
            "     }",
            " }",
            " ",
            " static void clear_catalog(catalog_t *catalog)",
            " {",
            "     if (catalog->objects) {",
            "         free(catalog->objects);",
            "     }",
            "     if (catalog->enums) {",
            "         free(catalog->enums);",
            "     }",
            "+    if (catalog->services) {",
            "+        free(catalog->services);",
            "+    }",
            "     if (catalog->name_table) {",
            "         free(catalog->name_table);",
            "     }",
            "     memset(catalog, 0, sizeof(*catalog));",
            " }",
            " ",
            " static int build_catalog(catalog_t *catalog, fb_schema_t *schema, int qualify_names, fb_scope_table_t *index)",
            " {",
            "     memset(catalog, 0, sizeof(*catalog));",
            "     catalog->qualify_names = qualify_names;",
            "     catalog->schema = schema;",
            " ",
            "     /* Build support datastructures before export. */",
            "     fb_scope_table_visit(index, count_symbols, catalog);",
            "-    catalog->objects = calloc(catalog->nobjects, sizeof(catalog->objects[0]));",
            "-    catalog->enums = calloc(catalog->nenums, sizeof(catalog->enums[0]));",
            "+    catalog->objects = calloc((size_t)catalog->nobjects, sizeof(catalog->objects[0]));",
            "+    catalog->enums = calloc((size_t)catalog->nenums, sizeof(catalog->enums[0]));",
            "+    catalog->services = calloc((size_t)catalog->nservices, sizeof(catalog->services[0]));",
            "     catalog->name_table = malloc(catalog->name_table_size);",
            "     catalog->next_object = catalog->objects;",
            "     catalog->next_enum = catalog->enums;",
            "+    catalog->next_service = catalog->services;",
            "     catalog->next_name = catalog->name_table;",
            "     if ((!catalog->objects && catalog->nobjects > 0) ||",
            "         (!catalog->enums && catalog->nenums > 0) ||",
            "+        (!catalog->services && catalog->nservices > 0) ||",
            "         (!catalog->name_table && catalog->name_table_size > 0)) {",
            "         clear_catalog(catalog);",
            "         return -1;",
            "     }",
            "     fb_scope_table_visit(index, install_symbols, catalog);",
            "     /* Presort objects and enums because the sorted index is required in Type tables. */",
            "     sort_entries(catalog->objects, catalog->nobjects);",
            "     sort_entries(catalog->enums, catalog->nenums);",
            "+    sort_entries(catalog->services, catalog->nservices);",
            "     return 0;",
            " }",
            " ",
            " #endif /* CATALOG_H */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_c.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_c.c",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_c.c",
            "@@ -121,20 +121,20 @@",
            " ",
            "     fb_clear(set);",
            " ",
            "     /* Don't include our own file. */",
            "     str_set_insert_item(&set, fb_copy_path(out->S->basenameup), ht_keep);",
            "     while (inc) {",
            "         checkmem((basename = fb_create_basename(",
            "-                    inc->name.s.s, inc->name.s.len, out->opts->default_schema_ext)));",
            "+                    inc->name.s.s, (size_t)inc->name.s.len, out->opts->default_schema_ext)));",
            "         inc = inc->link;",
            "         checkmem((basenameup = fb_copy_path(basename)));",
            "         s = basenameup;",
            "         while (*s) {",
            "-            *s = toupper(*s);",
            "+            *s = (char)toupper(*s);",
            "             ++s;",
            "         }",
            "         if (str_set_insert_item(&set, basenameup, ht_keep)) {",
            "             free(basenameup);",
            "             free(basename);",
            "             continue;",
            "         }",
            "@@ -151,27 +151,27 @@",
            " }",
            " ",
            " int fb_copy_scope(fb_scope_t *scope, char *buf)",
            " {",
            "     size_t n, len;",
            "     fb_ref_t *name;",
            " ",
            "-    len = scope->prefix.len;",
            "+    len = (size_t)scope->prefix.len;",
            "     for (name = scope->name; name; name = name->link) {",
            "-        n = name->ident->len;",
            "+        n = (size_t)name->ident->len;",
            "         len += n + 1;",
            "     }",
            "     if (len > FLATCC_NAMESPACE_MAX + 1) {",
            "         buf[0] = '\\0';",
            "         return -1;",
            "     }",
            "-    len = scope->prefix.len;",
            "+    len = (size_t)scope->prefix.len;",
            "     memcpy(buf, scope->prefix.s, len);",
            "     for (name = scope->name; name; name = name->link) {",
            "-        n = name->ident->len;",
            "+        n = (size_t)name->ident->len;",
            "         memcpy(buf + len, name->ident->text, n);",
            "         len += n + 1;",
            "         buf[len - 1] = '_';",
            "     }",
            "     buf[len] = '\\0';",
            "     return (int)len;",
            " }",
            "@@ -182,22 +182,22 @@",
            " ",
            "     if (sn->scope != scope) {",
            "         if (0 > (sn->scope_len = fb_copy_scope(scope, sn->text))) {",
            "             sn->scope_len = 0;",
            "             fprintf(stderr, \"skipping too long namespace\\n\");",
            "         }",
            "     }",
            "-    sn->len = t->len;",
            "+    sn->len = (int)t->len;",
            "     sn->total_len = sn->scope_len + sn->len;",
            "     if (sn->total_len > FLATCC_NAME_BUFSIZ - 1) {",
            "         fprintf(stderr, \"warning: truncating identifier: %.*s\\n\", sn->len, t->text);",
            "         sn->len = FLATCC_NAME_BUFSIZ - sn->scope_len - 1;",
            "         sn->total_len = sn->scope_len + sn->len;",
            "     }",
            "-    memcpy(sn->text + sn->scope_len, t->text, sn->len);",
            "+    memcpy(sn->text + sn->scope_len, t->text, (size_t)sn->len);",
            "     sn->text[sn->total_len] = '\\0';",
            " }",
            " ",
            " int fb_codegen_common_c(fb_output_t *out)",
            " {",
            "     size_t nsc_len;",
            "     int ret;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_c.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_c.h",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_c.h",
            "@@ -4,25 +4,28 @@",
            " #include <assert.h>",
            " #include <stdarg.h>",
            " ",
            " #include \"symbols.h\"",
            " #include \"parser.h\"",
            " #include \"codegen.h\"",
            " ",
            "+/* -DFLATCC_PORTABLE may help if inttypes.h is missing. */",
            "+#ifndef PRId64",
            "+#include <inttypes.h>",
            "+#endif",
            "+",
            " #define __FLATCC_ERROR_TYPE \"INTERNAL_ERROR_UNEXPECTED_TYPE\"",
            " ",
            " #ifndef gen_panic",
            " #define gen_panic(context, msg) fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, msg), assert(0), exit(-1)",
            " #endif",
            " ",
            "-#define llu(x) (long long unsigned int)(x)",
            "-#define lld(x) (long long int)(x)",
            " ",
            " static inline void token_name(fb_token_t *t, int *n, const char **s) {",
            "-    *n = t->len;",
            "+    *n = (int)t->len;",
            "     *s = t->text;",
            " }",
            " ",
            " typedef char fb_symbol_text_t[FLATCC_NAME_BUFSIZ];",
            " typedef struct fb_scoped_name fb_scoped_name_t;",
            " ",
            " /* Should be zeroed because scope is cached across updates. */",
            "@@ -64,14 +67,17 @@",
            "         break;",
            "     case fb_uint:",
            "         tname = \"uint32\";",
            "         break;",
            "     case fb_ushort:",
            "         tname = \"uint16\";",
            "         break;",
            "+    case fb_char:",
            "+        tname = \"char\";",
            "+        break;",
            "     case fb_ubyte:",
            "         tname = \"uint8\";",
            "         break;",
            "     case fb_bool:",
            "         tname = \"bool\";",
            "         break;",
            "     case fb_long:",
            "@@ -109,14 +115,17 @@",
            "         break;",
            "     case fb_uint:",
            "         tname = \"uint32_t\";",
            "         break;",
            "     case fb_ushort:",
            "         tname = \"uint16_t\";",
            "         break;",
            "+    case fb_char:",
            "+        tname = \"char\";",
            "+        break;",
            "     case fb_ubyte:",
            "         tname = \"uint8_t\";",
            "         break;",
            "     case fb_bool:",
            "         tname = \"bool_t\";",
            "         break;",
            "     case fb_long:",
            "@@ -154,14 +163,17 @@",
            "         break;",
            "     case fb_uint:",
            "         tname = \"uint32_vec_t\";",
            "         break;",
            "     case fb_ushort:",
            "         tname = \"uint16_vec_t\";",
            "         break;",
            "+    case fb_char:",
            "+        tname = \"char_vec_t\";",
            "+        break;",
            "     case fb_ubyte:",
            "         tname = \"uint8_vec_t\";",
            "         break;",
            "     case fb_bool:",
            "         tname = \"uint8_vec_t\";",
            "         break;",
            "     case fb_long:",
            "@@ -200,14 +212,17 @@",
            "         break;",
            "     case fb_uint:",
            "         cast = \"UINT32_C\";",
            "         break;",
            "     case fb_ushort:",
            "         cast = \"UINT16_C\";",
            "         break;",
            "+    case fb_char:",
            "+        cast = \"char\";",
            "+        break;",
            "     case fb_ubyte:",
            "         cast = \"UINT8_C\";",
            "         break;",
            "     case fb_bool:",
            "         cast = \"UINT8_C\";",
            "         break;",
            "     case fb_long:",
            "@@ -235,29 +250,36 @@",
            " static inline size_t print_literal(fb_scalar_type_t scalar_type, const fb_value_t *value, fb_literal_t literal)",
            " {",
            "     const char *cast;",
            " ",
            "     switch (value->type) {",
            "     case vt_uint:",
            "         cast = scalar_cast(scalar_type);",
            "-        return sprintf(literal, \"%s(%llu)\", cast, llu(value->u));",
            "+        return (size_t)sprintf(literal, \"%s(%\"PRIu64\")\", cast, (uint64_t)value->u);",
            "         break;",
            "     case vt_int:",
            "         cast = scalar_cast(scalar_type);",
            "-        return sprintf(literal, \"%s(%lld)\", cast, lld(value->i));",
            "+        return (size_t)sprintf(literal, \"%s(%\"PRId64\")\", cast, (int64_t)value->i);",
            "         break;",
            "     case vt_bool:",
            "         cast = scalar_cast(scalar_type);",
            "-        return sprintf(literal, \"%s(%u)\", cast, (unsigned)value->b);",
            "+        return (size_t)sprintf(literal, \"%s(%u)\", cast, (unsigned)value->b);",
            "         break;",
            "     case vt_float:",
            "+        /*",
            "+         * .9g ensures sufficient precision in 32-bit floats and",
            "+         * .17g ensures sufficient precision for 64-bit floats (double).",
            "+         * The '#' forces a decimal point that would not be printed",
            "+         * for integers which would result in the wrong type in C",
            "+         * source.",
            "+         */",
            "         if (scalar_type == fb_float) {",
            "-            return sprintf(literal, \"%ff\", (float)value->f);",
            "+            return (size_t)sprintf(literal, \"%#.9gf\", (float)value->f);",
            "         } else {",
            "-            return sprintf(literal, \"%lf\", (double)value->f);",
            "+            return (size_t)sprintf(literal, \"%#.17g\", (double)value->f);",
            "         }",
            "         break;",
            "     default:",
            "         gen_panic(0, \"internal error: unexpected type during code generation\");",
            "         *literal = 0;",
            "         return 0;",
            "     }",
            "@@ -272,14 +294,17 @@",
            "         break;",
            "     case fb_uint:",
            "         suffix = \"UL\";",
            "         break;",
            "     case fb_ushort:",
            "         suffix = \"U\";",
            "         break;",
            "+    case fb_char:",
            "+        suffix = \"\";",
            "+        break;",
            "     case fb_ubyte:",
            "         suffix = \"U\";",
            "         break;",
            "     case fb_bool:",
            "         suffix = \"U\";",
            "         break;",
            "     case fb_long:",
            "@@ -356,14 +381,17 @@",
            " ",
            " int __flatcc_fb_gen_c_builder(fb_output_t *out);",
            " #define fb_gen_c_builder __flatcc_fb_gen_c_builder",
            " ",
            " int __flatcc_fb_gen_c_verifier(fb_output_t *out);",
            " #define fb_gen_c_verifier __flatcc_fb_gen_c_verifier",
            " ",
            "+int __flatcc_fb_gen_c_sorter(fb_output_t *out);",
            "+#define fb_gen_c_sorter __flatcc_fb_gen_c_sorter",
            "+",
            " int __flatcc_fb_gen_c_json_parser(fb_output_t *out);",
            " #define fb_gen_c_json_parser __flatcc_fb_gen_c_json_parser",
            " ",
            " int __flatcc_fb_gen_c_json_printer(fb_output_t *out);",
            " #define fb_gen_c_json_printer __flatcc_fb_gen_c_json_printer",
            " ",
            " #endif /* CODEGEN_C_H */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_c_builder.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_c_builder.c",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_c_builder.c",
            "@@ -402,35 +402,47 @@",
            "         \"{ size_t n = NS ## string_len(string); if (index >= n) index = n; n -= index; if (len > n) len = n;\\\\\\n\"",
            "         \"  return flatcc_builder_create_string(B, string + index, len); }\\\\\\n\"",
            "         \"__%sbuild_string_ops(NS, NS ## string)\\\\\\n\"",
            "         \"__%sbuild_offset_vector(NS, NS ## string)\\n\"",
            "         \"\\n\",",
            "         nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "-        \"#define __%scopy_from_pe(P, P2, N) (*(P) = N ## _cast_from_pe(*P2), (P))\\n\"",
            "-        \"#define __%sfrom_pe(P, N) (*(P) = N ## _cast_from_pe(*P), (P))\\n\"",
            "-        \"#define __%scopy_to_pe(P, P2, N) (*(P) = N ## _cast_to_pe(*P2), (P))\\n\"",
            "-        \"#define __%sto_pe(P, N) (*(P) = N ## _cast_to_pe(*P), (P))\\n\",",
            "+        \"#define __%scopy_from_pe(P, P2, N) (*(P) = N ## _read_from_pe(P2), (P))\\n\"",
            "+        \"#define __%sfrom_pe(P, N) (*(P) = N ## _read_from_pe(P), (P))\\n\"",
            "+        \"#define __%scopy_to_pe(P, P2, N) (N ## _write_to_pe((P), *(P2)), (P))\\n\"",
            "+        \"#define __%sto_pe(P, N) (N ## _write_to_pe((P), *(P)), (P))\\n\",",
            "         nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "+        \"#define __%sdefine_fixed_array_primitives(NS, N, T)\\\\\\n\"",
            "+        \"static inline T *N ## _array_copy(T *p, const T *p2, size_t n)\\\\\\n\"",
            "+        \"{ memcpy(p, p2, n * sizeof(T)); return p; }\\\\\\n\"",
            "+        \"static inline T *N ## _array_copy_from_pe(T *p, const T *p2, size_t n)\\\\\\n\"",
            "+        \"{ size_t i; if (NS ## is_native_pe()) memcpy(p, p2, n * sizeof(T)); else\\\\\\n\"",
            "+        \"  for (i = 0; i < n; ++i) N ## _copy_from_pe(&p[i], &p2[i]); return p; }\\\\\\n\"",
            "+        \"static inline T *N ## _array_copy_to_pe(T *p, const T *p2, size_t n)\\\\\\n\"",
            "+        \"{ size_t i; if (NS ## is_native_pe()) memcpy(p, p2, n * sizeof(T)); else\\\\\\n\"",
            "+        \"  for (i = 0; i < n; ++i) N ## _copy_to_pe(&p[i], &p2[i]); return p; }\\n\",",
            "+        nsc);",
            "+    fprintf(out->fp,",
            "         \"#define __%sdefine_scalar_primitives(NS, N, T)\\\\\\n\"",
            "         \"static inline T *N ## _from_pe(T *p) { return __ ## NS ## from_pe(p, N); }\\\\\\n\"",
            "         \"static inline T *N ## _to_pe(T *p) { return __ ## NS ## to_pe(p, N); }\\\\\\n\"",
            "         \"static inline T *N ## _copy(T *p, const T *p2) { *p = *p2; return p; }\\\\\\n\"",
            "         \"static inline T *N ## _copy_from_pe(T *p, const T *p2)\\\\\\n\"",
            "         \"{ return __ ## NS ## copy_from_pe(p, p2, N); }\\\\\\n\"",
            "         \"static inline T *N ## _copy_to_pe(T *p, const T *p2) \\\\\\n\"",
            "         \"{ return __ ## NS ## copy_to_pe(p, p2, N); }\\\\\\n\"",
            "         \"static inline T *N ## _assign(T *p, const T v0) { *p = v0; return p; }\\\\\\n\"",
            "         \"static inline T *N ## _assign_from_pe(T *p, T v0)\\\\\\n\"",
            "-        \"{ *p = N ## _cast_from_pe(v0); return p; }\\\\\\n\"",
            "+        \"{ *p = N ## _read_from_pe(&v0); return p; }\\\\\\n\"",
            "         \"static inline T *N ## _assign_to_pe(T *p, T v0)\\\\\\n\"",
            "-        \"{ *p = N ## _cast_to_pe(v0); return p; }\\n\"",
            "+        \"{ N ## _write_to_pe(p, v0); return p; }\\n\"",
            "         \"#define __%sbuild_scalar(NS, N, T)\\\\\\n\"",
            "         \"__ ## NS ## define_scalar_primitives(NS, N, T)\\\\\\n\"",
            "+        \"__ ## NS ## define_fixed_array_primitives(NS, N, T)\\\\\\n\"",
            "         \"__ ## NS ## build_vector(NS, N, T, sizeof(T), sizeof(T))\\n\",",
            "         nsc, nsc);",
            " ",
            "     fprintf(out->fp,",
            "         \"/* Depends on generated copy_to/from_pe functions, and the type. */\\n\"",
            "         \"#define __%sdefine_struct_primitives(NS, N)\\\\\\n\"",
            "         \"static inline N ## _t *N ##_to_pe(N ## _t *p)\\\\\\n\"",
            "@@ -473,24 +485,27 @@",
            "         \"static inline N ## _ref_t N ## _create(NS ## builder_t *B __ ## N ## _formal_args)\\\\\\n\"",
            "         \"{ N ## _t *_p = N ## _start(B); if (!_p) return 0; N ##_assign_to_pe(_p __ ## N ## _call_args);\\\\\\n\"",
            "         \"  return N ## _end_pe(B); }\\\\\\n\"",
            "         \"static inline N ## _ref_t N ## _clone(NS ## builder_t *B, N ## _struct_t p)\\\\\\n\"",
            "         \"{ N ## _t *_p; __%smemoize_begin(B, p); _p = N ## _start(B); if (!_p) return 0;\\\\\\n\"",
            "         \"  N ## _copy(_p, p); __%smemoize_end(B, p, N ##_end_pe(B)); }\\\\\\n\"",
            "         \"__%sbuild_vector(NS, N, N ## _t, S, A)\\\\\\n\"",
            "-        \"__%sbuild_struct_root(NS, N, A, FID, TFID)\\n\"",
            "+        \"__%sbuild_struct_root(NS, N, A, FID, TFID)\\\\\\n\"",
            "         \"\\n\",",
            "         nsc, nsc, nsc, nsc, nsc, nsc);",
            "+    fprintf(out->fp,",
            "+        \"#define __%sstruct_clear_field(p) memset((p), 0, sizeof(*(p)))\\n\",",
            "+        nsc);",
            " ",
            "     fprintf(out->fp,",
            "         \"#define __%sbuild_table(NS, N, K)\\\\\\n\"",
            "         \"static inline int N ## _start(NS ## builder_t *B)\\\\\\n\"",
            "         \"{ return flatcc_builder_start_table(B, K); }\\\\\\n\"",
            "         \"static inline N ## _ref_t N ## _end(NS ## builder_t *B)\\\\\\n\"",
            "-        \"{ assert(flatcc_builder_check_required(B, __ ## N ## _required,\\\\\\n\"",
            "+        \"{ FLATCC_ASSERT(flatcc_builder_check_required(B, __ ## N ## _required,\\\\\\n\"",
            "         \"  sizeof(__ ## N ## _required) / sizeof(__ ## N ## _required[0]) - 1));\\\\\\n\"",
            "         \"  return flatcc_builder_end_table(B); }\\\\\\n\"",
            "         \"__%sbuild_offset_vector(NS, N)\\n\"",
            "         \"\\n\",",
            "         nsc, nsc);",
            " ",
            "     fprintf(out->fp,",
            "@@ -511,16 +526,16 @@",
            "         \"\\n\",",
            "         nsc);",
            " ",
            "     fprintf(out->fp,",
            "         \"#define __%sbuild_union_field(ID, NS, N, TN, TT)\\\\\\n\"",
            "         \"static inline int N ## _add(NS ## builder_t *B, TN ## _union_ref_t uref)\\\\\\n\"",
            "         \"{ NS ## ref_t *_p; TN ## _union_type_t *_pt; if (uref.type == TN ## _NONE) return 0; if (uref.value == 0) return -1;\\\\\\n\"",
            "-        \"  if (!(_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1, sizeof(*_pt), sizeof(*_pt))) ||\\\\\\n\"",
            "-        \"  !(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_pt = uref.type; *_p = uref.value; return 0; }\\\\\\n\"",
            "+        \"  if (!(_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1, sizeof(*_pt), sizeof(*_pt)))) return -1;\\\\\\n\"",
            "+        \"  *_pt = uref.type; if (!(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_p = uref.value; return 0; }\\\\\\n\"",
            "         \"static inline int N ## _add_type(NS ## builder_t *B, TN ## _union_type_t type)\\\\\\n\"",
            "         \"{ TN ## _union_type_t *_pt; if (type == TN ## _NONE) return 0; return (_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1,\\\\\\n\"",
            "         \"  sizeof(*_pt), sizeof(*_pt))) ? ((*_pt = type), 0) : -1; }\\\\\\n\"",
            "         \"static inline int N ## _add_value(NS ## builder_t *B, TN ## _union_ref_t uref)\\\\\\n\"",
            "         \"{ NS ## ref_t *p; if (uref.type == TN ## _NONE) return 0; return (p = flatcc_builder_table_add_offset(B, ID)) ?\\\\\\n\"",
            "         \"  ((*p = uref.value), 0) : -1; }\\\\\\n\"",
            "         \"static inline int N ## _clone(NS ## builder_t *B, TN ## _union_t p)\\\\\\n\"",
            "@@ -595,14 +610,30 @@",
            "         \"/* Transferring a missing field is a nop success with 0 as result. */\\\\\\n\"",
            "         \"static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\\\\\n\"",
            "         \"{ const T *_p = N ## _get_ptr(t); return _p ? N ## _clone(B, _p) : 0; }\\n\"",
            "         \"\\n\",",
            "         nsc);",
            " ",
            "     fprintf(out->fp,",
            "+        \"/* NS: common namespace, ID: table field id (not offset), TN: name of type T, TT: name of table type\\n\"",
            "+        \" * S: sizeof of scalar type, A: alignment of type T. */\\n\"",
            "+        \"#define __%sbuild_scalar_optional_field(ID, NS, N, TN, T, S, A, TT)\\\\\\n\"",
            "+        \"static inline int N ## _add(NS ## builder_t *B, const T v)\\\\\\n\"",
            "+        \"{ T *_p; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\\\\\\n\"",
            "+        \"  TN ## _assign_to_pe(_p, v); return 0; }\\\\\\n\"",
            "+        \"/* Clone does not skip default values and expects pe endian content. */\\\\\\n\"",
            "+        \"static inline int N ## _clone(NS ## builder_t *B, const T *p)\\\\\\n\"",
            "+        \"{ return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }\\\\\\n\"",
            "+        \"/* Transferring a missing field is a nop success with 0 as result. */\\\\\\n\"",
            "+        \"static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\\\\\n\"",
            "+        \"{ const T *_p = N ## _get_ptr(t); return _p ? N ## _clone(B, _p) : 0; }\\n\"",
            "+        \"\\n\",",
            "+        nsc);",
            "+",
            "+    fprintf(out->fp,",
            "         \"#define __%sbuild_struct_field(ID, NS, N, TN, S, A, TT)\\\\\\n\"",
            "         \"static inline TN ## _t *N ## _start(NS ## builder_t *B)\\\\\\n\"",
            "         \"{ return (TN ## _t *)flatcc_builder_table_add(B, ID, S, A); }\\\\\\n\"",
            "         \"static inline int N ## _end(NS ## builder_t *B)\\\\\\n\"",
            "         \"{ if (!NS ## is_native_pe()) { TN ## _to_pe((TN ## _t *)flatcc_builder_table_edit(B, S)); } return 0; }\\\\\\n\"",
            "         \"static inline int N ## _end_pe(NS ## builder_t *B) { return 0; }\\\\\\n\"",
            "         \"static inline int N ## _create(NS ## builder_t *B __ ## TN ## _formal_args)\\\\\\n\"",
            "@@ -624,17 +655,17 @@",
            "         \"{ TN ## _vec_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\\\\\\n\"",
            "         \"static inline int N ## _start(NS ## builder_t *B)\\\\\\n\"",
            "         \"{ return TN ## _vec_start(B); }\\\\\\n\"",
            "         \"static inline int N ## _end_pe(NS ## builder_t *B)\\\\\\n\"",
            "         \"{ return N ## _add(B, TN ## _vec_end_pe(B)); }\\\\\\n\"",
            "         \"static inline int N ## _end(NS ## builder_t *B)\\\\\\n\"",
            "         \"{ return N ## _add(B, TN ## _vec_end(B)); }\\\\\\n\"",
            "-        \"static inline int N ## _create_pe(NS ## builder_t *B, T *data, size_t len)\\\\\\n\"",
            "+        \"static inline int N ## _create_pe(NS ## builder_t *B, const T *data, size_t len)\\\\\\n\"",
            "         \"{ return N ## _add(B, TN ## _vec_create_pe(B, data, len)); }\\\\\\n\"",
            "-        \"static inline int N ## _create(NS ## builder_t *B, T *data, size_t len)\\\\\\n\"",
            "+        \"static inline int N ## _create(NS ## builder_t *B, const T *data, size_t len)\\\\\\n\"",
            "         \"{ return N ## _add(B, TN ## _vec_create(B, data, len)); }\\\\\\n\"",
            "         \"static inline int N ## _slice(NS ## builder_t *B, TN ## _vec_t vec, size_t index, size_t len)\\\\\\n\"",
            "         \"{ return N ## _add(B, TN ## _vec_slice(B, vec, index, len)); }\\\\\\n\"",
            "         \"static inline int N ## _clone(NS ## builder_t *B, TN ## _vec_t vec)\\\\\\n\"",
            "         \"{ return N ## _add(B, TN ## _vec_clone(B, vec)); }\\\\\\n\"",
            "         \"static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\\\\\\n\"",
            "         \"{ TN ## _vec_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }\\\\\\n\"",
            "@@ -773,14 +804,16 @@",
            "      fprintf(out->fp,",
            "         \"#define __%sbuild_string_vector_field(ID, NS, N, TT)\\\\\\n\"",
            "         \"__%sbuild_offset_vector_field(ID, NS, N, NS ## string, TT)\\\\\\n\"",
            "         \"__%sbuild_string_vector_ops(NS, N)\\n\"",
            "         \"\\n\",",
            "         nsc, nsc, nsc);",
            " ",
            "+    fprintf(out->fp, \"#define __%schar_formal_args , char v0\\n\", nsc);",
            "+    fprintf(out->fp, \"#define __%schar_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%suint8_formal_args , uint8_t v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%suint8_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sint8_formal_args , int8_t v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sint8_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sbool_formal_args , %sbool_t v0\\n\", nsc, nsc);",
            "     fprintf(out->fp, \"#define __%sbool_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%suint16_formal_args , uint16_t v0\\n\", nsc);",
            "@@ -796,14 +829,15 @@",
            "     fprintf(out->fp, \"#define __%sint64_formal_args , int64_t v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sint64_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sfloat_formal_args , float v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sfloat_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sdouble_formal_args , double v0\\n\", nsc);",
            "     fprintf(out->fp, \"#define __%sdouble_call_args , v0\\n\", nsc);",
            "     fprintf(out->fp, \"\\n\");",
            "+    fprintf(out->fp, \"__%sbuild_scalar(%s, %schar, char)\\n\", nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %suint8, uint8_t)\\n\", nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %sint8, int8_t)\\n\", nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %sbool, %sbool_t)\\n\", nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %suint16, uint16_t)\\n\", nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %suint32, uint32_t)\\n\", nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %suint64, uint64_t)\\n\", nsc, nsc, nsc);",
            "     fprintf(out->fp, \"__%sbuild_scalar(%s, %sint16, int16_t)\\n\", nsc, nsc, nsc);",
            "@@ -859,49 +893,51 @@",
            "             \"#define %sidentifier 0\\n\"",
            "             \"#endif\\n\",",
            "             nsc, nsc);",
            "     }",
            "     if (out->S->file_extension.type == vt_string) {",
            "         fprintf(out->fp,",
            "             \"#undef %sextension\\n\"",
            "-            \"#define %sextension \\\".%.*s\\\"\\n\",",
            "+            \"#define %sextension \\\"%.*s\\\"\\n\",",
            "             nsc,",
            "             nsc, out->S->file_extension.s.len, out->S->file_extension.s.s);",
            "     } else {",
            "         fprintf(out->fp,",
            "-            /* Configured extensions include dot, schema does not. */",
            "             \"#ifndef %sextension\\n\"",
            "             \"#define %sextension \\\"%s\\\"\\n\"",
            "             \"#endif\\n\",",
            "             nsc, nsc, out->opts->default_bin_ext);",
            "     }",
            "     fprintf(out->fp, \"\\n\");",
            "     return 0;",
            " }",
            " ",
            " static int get_total_struct_field_count(fb_compound_type_t *ct)",
            " {",
            "     fb_member_t *member;",
            "     fb_symbol_t *sym;",
            "     int count = 0;",
            "+",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "-        /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (member->type.type) {",
            "+        /* struct arrays count as 1 but struct fields are expanded */",
            "         case vt_compound_type_ref:",
            "             if (member->type.ct->symbol.kind == fb_is_struct) {",
            "                 count += get_total_struct_field_count(member->type.ct);",
            "                 continue;",
            "             }",
            "-            /* Fall through */",
            "+            ++count;",
            "+            break;",
            "         default:",
            "             ++count;",
            "+            break;",
            "         }",
            "     }",
            "     return count;",
            " }",
            " ",
            " static inline void gen_comma(fb_output_t *out, int index, int count, int is_macro)",
            " {",
            "@@ -937,23 +973,38 @@",
            " ",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         switch (member->type.type) {",
            "+        case vt_fixed_array_compound_type_ref:",
            "+            gen_comma(out, index, len, is_macro);",
            "+            fb_compound_name(member->type.ct, &snref);",
            "+            if (member->type.ct->symbol.kind == fb_is_struct) {",
            "+                fprintf(out->fp, \"const %s_t v%i[%i]\", snref.text, index++, (int)member->type.len);",
            "+            } else {",
            "+                fprintf(out->fp, \"%s_enum_t v%i[%i]\", snref.text, index++, (int)member->type.len);",
            "+            }",
            "+            break;",
            "         case vt_compound_type_ref:",
            "             if (member->type.ct->symbol.kind == fb_is_struct) {",
            "                 index = gen_builder_struct_args(out, member->type.ct, index, len, is_macro);",
            "                 continue;",
            "             }",
            "             gen_comma(out, index, len, is_macro);",
            "             fb_compound_name(member->type.ct, &snref);",
            "             fprintf(out->fp, \"%s_enum_t v%i\", snref.text, index++);",
            "             break;",
            "+        case vt_fixed_array_type:",
            "+            gen_comma(out, index, len, is_macro);",
            "+            tname_ns = scalar_type_ns(member->type.st, nsc);",
            "+            tname = scalar_type_name(member->type.st);",
            "+            fprintf(out->fp, \"const %s%s v%i[%i]\", tname_ns, tname, index++, (int)member->type.len);",
            "+            break;",
            "         case vt_scalar_type:",
            "             gen_comma(out, index, len, is_macro);",
            "             tname_ns = scalar_type_ns(member->type.st, nsc);",
            "             tname = scalar_type_name(member->type.st);",
            "             fprintf(out->fp, \"%s%s v%i\", tname_ns, tname, index++);",
            "             break;",
            "         default:",
            "@@ -975,20 +1026,21 @@",
            "     }",
            "     return index;",
            " }",
            " ",
            " enum { no_conversion, convert_from_pe, convert_to_pe };",
            " ",
            " /* Note: returned index is not correct when using from_ptr since it doesn't track arguments, but it shouldn't matter. */",
            "-static int gen_builder_struct_field_assign(fb_output_t *out, fb_compound_type_t *ct, int index, int arg_count, int conversion, int from_ptr)",
            "+static int gen_builder_struct_field_assign(fb_output_t *out, fb_compound_type_t *ct, int index, int arg_count,",
            "+        int conversion, int from_ptr)",
            " {",
            "     const char *nsc = out->nsc;",
            "     fb_member_t *member;",
            "     fb_symbol_t *sym;",
            "-    int n;",
            "+    int n, len;",
            "     const char *s;",
            "     int deprecated_index = 0;",
            "     const char *kind, *tprefix;",
            "     fb_scoped_name_t snref;",
            " ",
            "     fb_clear(snref);",
            "     switch (conversion) {",
            "@@ -1004,20 +1056,39 @@",
            "             if (index % 4 == 0) {",
            "                 fprintf(out->fp, \";\\n  \");",
            "             } else {",
            "                 fprintf(out->fp, \"; \");",
            "             }",
            "         }",
            "         switch (member->type.type) {",
            "+        case vt_fixed_array_compound_type_ref:",
            "+            len = (int)member->type.len;",
            "+            fb_compound_name(member->type.ct, &snref);",
            "+            if (member->metadata_flags & fb_f_deprecated) {",
            "+                fprintf(out->fp, \"__%sstruct_clear_field(p->__deprecated%i)\",",
            "+                        nsc, deprecated_index);",
            "+                ++deprecated_index;",
            "+                ++index;",
            "+                continue;",
            "+            }",
            "+            if (from_ptr) {",
            "+                fprintf(out->fp, \"%s_array_copy%s(p->%.*s, p2->%.*s, %d)\",",
            "+                        snref.text, kind, n, s, n, s, len);",
            "+            } else {",
            "+                fprintf(out->fp, \"%s_array_copy%s(p->%.*s, v%i, %d)\",",
            "+                        snref.text, kind, n, s, index, len);",
            "+            }",
            "+            ++index;",
            "+            continue;",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             if (member->type.ct->symbol.kind == fb_is_struct) {",
            "                 if (member->metadata_flags & fb_f_deprecated) {",
            "-                    fprintf(out->fp, \"memset(p->__deprecated%i, 0, sizeof(*p->__deprecated%i))\",",
            "-                            deprecated_index, deprecated_index);",
            "+                    fprintf(out->fp, \"__%sstruct_clear_field(p->__deprecated%i)\",",
            "+                            nsc, deprecated_index);",
            "                     deprecated_index++;",
            "                     index += get_total_struct_field_count(member->type.ct);",
            "                     continue;",
            "                 }",
            "                 if (from_ptr) {",
            "                     fprintf(out->fp, \"%s_copy%s(&p->%.*s, &p2->%.*s)\", snref.text, kind, n, s, n, s);",
            "                     /* `index` does not count children, but it doesn't matter here. */",
            "@@ -1026,15 +1097,17 @@",
            "                     fprintf(out->fp, \"%s_assign%s(&p->%.*s\", snref.text, kind, n, s);",
            "                     index = gen_builder_struct_call_list(out, member->type.ct, index, arg_count, 0);",
            "                     fprintf(out->fp, \")\");",
            "                 }",
            "                 continue;",
            "             }",
            "             if (member->metadata_flags & fb_f_deprecated) {",
            "-                fprintf(out->fp, \"p->__deprecated%i = 0\", deprecated_index++);",
            "+                fprintf(out->fp, \"__%sstruct_clear_field(p->__deprecated%i)\",",
            "+                        nsc, deprecated_index);",
            "+                ++deprecated_index;",
            "                 ++index;",
            "                 continue;",
            "             }",
            "             switch (member->size == 1 ? no_conversion : conversion) {",
            "             case convert_from_pe:",
            "                 if (from_ptr) {",
            "                     fprintf(out->fp, \"%s_copy_from_pe(&p->%.*s, &p2->%.*s)\",",
            "@@ -1059,18 +1132,39 @@",
            "                 } else {",
            "                     fprintf(out->fp, \"p->%.*s = v%i\", n, s, index);",
            "                 }",
            "                 break;",
            "             }",
            "             ++index;",
            "             continue;",
            "+        case vt_fixed_array_type:",
            "+            tprefix = scalar_type_prefix(member->type.st);",
            "+            len = (int)member->type.len;",
            "+            if (member->metadata_flags & fb_f_deprecated) {",
            "+                fprintf(out->fp, \"__%sstruct_clear_field(p->__deprecated%i)\",",
            "+                        nsc, deprecated_index);",
            "+                ++deprecated_index;",
            "+                ++index;",
            "+                continue;",
            "+            }",
            "+            if (from_ptr) {",
            "+                fprintf(out->fp, \"%s%s_array_copy%s(p->%.*s, p2->%.*s, %d)\",",
            "+                        nsc, tprefix, kind, n, s, n, s, len);",
            "+            } else {",
            "+                fprintf(out->fp, \"%s%s_array_copy%s(p->%.*s, v%i, %d)\",",
            "+                        nsc, tprefix, kind, n, s, index, len);",
            "+            }",
            "+            ++index;",
            "+            break;",
            "         case vt_scalar_type:",
            "             tprefix = scalar_type_prefix(member->type.st);",
            "             if (member->metadata_flags & fb_f_deprecated) {",
            "-                fprintf(out->fp, \"p->__deprecated%i = 0\", deprecated_index++);",
            "+                fprintf(out->fp, \"__%sstruct_clear_field(p->__deprecated%i)\",",
            "+                        nsc, deprecated_index);",
            "+                ++deprecated_index;",
            "                 ++index;",
            "                 continue;",
            "             }",
            "             switch (member->size == 1 ? no_conversion : conversion) {",
            "             case convert_from_pe:",
            "                 if (from_ptr) {",
            "                     fprintf(out->fp, \"%s%s_copy_from_pe(&p->%.*s, &p2->%.*s)\",",
            "@@ -1162,16 +1256,21 @@",
            "     fprintf(out->fp, \"return p; }\\n\");",
            "     fprintf(out->fp,",
            "             \"static inline %s_t *%s_copy_from_pe(%s_t *p, const %s_t *p2)\\n\",",
            "             snt.text, snt.text, snt.text, snt.text);",
            "     fprintf(out->fp, \"{ \");",
            "     gen_builder_struct_field_assign(out, ct, 0, arg_count, convert_from_pe, 1);",
            "     fprintf(out->fp, \"return p; }\\n\");",
            "-    fprintf(out->fp, \"__%sbuild_struct(%s, %s, %llu, %u, %s_identifier, %s_type_identifier)\\n\",",
            "-            nsc, nsc, snt.text, llu(ct->size), ct->align, snt.text, snt.text);",
            "+    fprintf(out->fp, \"__%sbuild_struct(%s, %s, %\"PRIu64\", %u, %s_file_identifier, %s_type_identifier)\\n\",",
            "+            nsc, nsc, snt.text, (uint64_t)ct->size, ct->align, snt.text, snt.text);",
            "+",
            "+    if (ct->size > 0) {",
            "+        fprintf(out->fp, \"__%sdefine_fixed_array_primitives(%s, %s, %s_t)\\n\",",
            "+                nsc, nsc, snt.text, snt.text);",
            "+    }",
            " }",
            " ",
            " static int get_create_table_arg_count(fb_compound_type_t *ct)",
            " {",
            "     fb_member_t *member;",
            "     fb_symbol_t *sym;",
            "     int count = 0;",
            "@@ -1194,15 +1293,15 @@",
            " ",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         gen_comma(out, index, arg_count, is_macro);",
            "-        fprintf(out->fp, \"v%llu\", llu(member->id));",
            "+        fprintf(out->fp, \"v%\"PRIu64\"\", (uint64_t)member->id);",
            "         ++index;",
            "     }",
            "     return index;",
            " }",
            " ",
            " ",
            " static int gen_required_table_fields(fb_output_t *out, fb_compound_type_t *ct)",
            "@@ -1263,64 +1362,64 @@",
            "         }",
            "         gen_comma(out, index++, arg_count, is_macro);",
            "         switch (member->type.type) {",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_struct:",
            "-                fprintf(out->fp, \"%s_t *v%llu\", snref.text, llu(member->id));",
            "+                fprintf(out->fp, \"%s_t *v%\"PRIu64\"\", snref.text, (uint64_t)member->id);",
            "                 break;",
            "             case fb_is_enum:",
            "-                fprintf(out->fp, \"%s_enum_t v%llu\", snref.text, llu(member->id));",
            "+                fprintf(out->fp, \"%s_enum_t v%\"PRIu64\"\", snref.text, (uint64_t)member->id);",
            "                 break;",
            "             case fb_is_table:",
            "-                fprintf(out->fp, \"%s_ref_t v%llu\", snref.text, llu(member->id));",
            "+                fprintf(out->fp, \"%s_ref_t v%\"PRIu64\"\", snref.text, (uint64_t)member->id);",
            "                 break;",
            "             case fb_is_union:",
            "                 /* Unions jump an index because it is two fields. */",
            "-                fprintf(out->fp, \"%s_union_ref_t v%llu\", snref.text, llu(member->id));",
            "+                fprintf(out->fp, \"%s_union_ref_t v%\"PRIu64\"\", snref.text, (uint64_t)member->id);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected table field type\");",
            "                 continue;",
            "             }",
            "             break;",
            "         case vt_vector_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_struct:",
            "             case fb_is_enum:",
            "             case fb_is_table:",
            "-                fprintf(out->fp, \"%s_vec_ref_t v%llu\", snref.text, llu(member->id));",
            "+                fprintf(out->fp, \"%s_vec_ref_t v%\"PRIu64\"\", snref.text, (uint64_t)member->id);",
            "                 break;",
            "             case fb_is_union:",
            "-                fprintf(out->fp, \"%s_union_vec_ref_t v%llu\", snref.text, llu(member->id));",
            "+                fprintf(out->fp, \"%s_union_vec_ref_t v%\"PRIu64\"\", snref.text, (uint64_t)member->id);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected table table type\");",
            "                 continue;",
            "             }",
            "             break;",
            "         case vt_scalar_type:",
            "             tname_ns = scalar_type_ns(member->type.st, nsc);",
            "             tname = scalar_type_name(member->type.st);",
            "-            fprintf(out->fp, \"%s%s v%llu\", tname_ns, tname, llu(member->id));",
            "+            fprintf(out->fp, \"%s%s v%\"PRIu64\"\", tname_ns, tname, (uint64_t)member->id);",
            "             break;",
            "         case vt_vector_type:",
            "             tname = scalar_type_prefix(member->type.st);",
            "-            fprintf(out->fp, \"%s%s_vec_ref_t v%llu\", nsc, tname, llu(member->id));",
            "+            fprintf(out->fp, \"%s%s_vec_ref_t v%\"PRIu64\"\", nsc, tname, (uint64_t)member->id);",
            "             break;",
            "         case vt_string_type:",
            "-            fprintf(out->fp, \"%sstring_ref_t v%llu\", nsc, llu(member->id));",
            "+            fprintf(out->fp, \"%sstring_ref_t v%\"PRIu64\"\", nsc, (uint64_t)member->id);",
            "             break;",
            "         case vt_vector_string_type:",
            "-            fprintf(out->fp, \"%sstring_vec_ref_t v%llu\", nsc, llu(member->id));",
            "+            fprintf(out->fp, \"%sstring_vec_ref_t v%\"PRIu64\"\", nsc, (uint64_t)member->id);",
            "             break;",
            "         default:",
            "-            gen_panic(out, \"internal error: unexpected struct member type\");",
            "+            gen_panic(out, \"internal error: unexpected table member type\");",
            "             continue;",
            "         }",
            "     }",
            "     return index;",
            " }",
            " ",
            " static int gen_builder_create_table_decl(fb_output_t *out, fb_compound_type_t *ct)",
            "@@ -1368,28 +1467,28 @@",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         symbol_name(&member->symbol, &n, &s);",
            "         if (member->type.type == vt_compound_type_ref && member->type.ct->symbol.kind == fb_is_union) {",
            "             has_union = 1;",
            "             if (patch_union) {",
            "-                fprintf(out->fp, \"\\n        || %s_%.*s_add_value(B, v%llu)\", snt.text, n, s, llu(member->id));",
            "+                fprintf(out->fp, \"\\n        || %s_%.*s_add_value(B, v%\"PRIu64\")\", snt.text, n, s, (uint64_t)member->id);",
            "                 continue;",
            "             }",
            "         }",
            "-        fprintf(out->fp, \"\\n        || %s_%.*s_add(B, v%llu)\", snt.text, n, s, llu(member->id));",
            "+        fprintf(out->fp, \"\\n        || %s_%.*s_add(B, v%\"PRIu64\")\", snt.text, n, s, (uint64_t)member->id);",
            "     }",
            "     if (patch_union && has_union) {",
            "         for (member = ct->ordered_members; member; member = member->order) {",
            "             if (member->metadata_flags & fb_f_deprecated) {",
            "                 continue;",
            "             }",
            "             if (member->type.type == vt_compound_type_ref && member->type.ct->symbol.kind == fb_is_union) {",
            "                 symbol_name(&member->symbol, &n, &s);",
            "-                fprintf(out->fp, \"\\n        || %s_%.*s_add_type(B, v%llu.type)\", snt.text, n, s, llu(member->id));",
            "+                fprintf(out->fp, \"\\n        || %s_%.*s_add_type(B, v%\"PRIu64\".type)\", snt.text, n, s, (uint64_t)member->id);",
            "             }",
            "         }",
            "     }",
            "     fprintf(out->fp, \") {\\n        return 0;\\n    }\\n    return %s_end(B);\\n}\\n\\n\", snt.text);",
            "     return 0;",
            " }",
            " ",
            "@@ -1415,28 +1514,28 @@",
            " ",
            "     fprintf(out->fp,",
            "             \"typedef %sref_t %s_ref_t;\\n\",",
            "             nsc, snt.text);",
            "     fprintf(out->fp,",
            "             \"static %s_ref_t %s_clone(%sbuilder_t *B, %s_table_t t);\\n\",",
            "             snt.text, snt.text, nsc, snt.text);",
            "-    fprintf(out->fp, \"__%sbuild_table(%s, %s, %llu)\\n\",",
            "-            nsc, nsc, snt.text, llu(ct->count));",
            "+    fprintf(out->fp, \"__%sbuild_table(%s, %s, %\"PRIu64\")\\n\",",
            "+            nsc, nsc, snt.text, (uint64_t)ct->count);",
            "     return 0;",
            " }",
            " ",
            " static int gen_builder_table_prolog(fb_output_t *out, fb_compound_type_t *ct)",
            " {",
            "     const char *nsc = out->nsc;",
            "     fb_scoped_name_t snt;",
            " ",
            "     fb_clear(snt);",
            "     fb_compound_name(ct, &snt);",
            " ",
            "-    fprintf(out->fp, \"__%sbuild_table_prolog(%s, %s, %s_identifier, %s_type_identifier)\\n\",",
            "+    fprintf(out->fp, \"__%sbuild_table_prolog(%s, %s, %s_file_identifier, %s_type_identifier)\\n\",",
            "             nsc, nsc, snt.text, snt.text, snt.text);",
            "     return 0;",
            " }",
            " ",
            " static int gen_union_fields(fb_output_t *out, const char *st, int n, const char *s,",
            "         fb_compound_type_t *ct, int is_vector)",
            " {",
            "@@ -1492,14 +1591,15 @@",
            " static int gen_builder_table_fields(fb_output_t *out, fb_compound_type_t *ct)",
            " {",
            "     const char *nsc = out->nsc;",
            "     fb_member_t *member;",
            "     fb_symbol_t *sym;",
            "     const char *s, *tprefix, *tname, *tname_ns;",
            "     int n;",
            "+    int is_optional;",
            "     fb_scoped_name_t snt;",
            "     fb_scoped_name_t snref;",
            "     fb_literal_t literal;",
            " ",
            "     fb_clear(snt);",
            "     fb_clear(snref);",
            "     fb_compound_name(ct, &snt);",
            "@@ -1507,32 +1607,40 @@",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         symbol_name(&member->symbol, &n, &s);",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             fprintf(out->fp, \"/* Skipping build of deprecated field: '%s_%.*s' */\\n\\n\", snt.text, n, s);",
            "             continue;",
            "         }",
            "+        is_optional = member->flags & fb_fm_optional;",
            "         switch (member->type.type) {",
            "         case vt_scalar_type:",
            "             tname_ns = scalar_type_ns(member->type.st, nsc);",
            "             tname = scalar_type_name(member->type.st);",
            "             tprefix = scalar_type_prefix(member->type.st);",
            "-            print_literal(member->type.st, &member->value, literal);",
            "-            fprintf(out->fp,",
            "-                \"__%sbuild_scalar_field(%llu, %s, %s_%.*s, %s%s, %s%s, %llu, %u, %s, %s)\\n\",",
            "-                nsc, llu(member->id), nsc, snt.text, n, s, nsc, tprefix, tname_ns, tname,",
            "-                llu(member->size), member->align, literal, snt.text);",
            "+            if (is_optional) {",
            "+                fprintf(out->fp,",
            "+                    \"__%sbuild_scalar_optional_field(%\"PRIu64\", %s, %s_%.*s, %s%s, %s%s, %\"PRIu64\", %u, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, nsc, tprefix, tname_ns, tname,",
            "+                    (uint64_t)member->size, member->align, snt.text);",
            "+            } else {",
            "+                print_literal(member->type.st, &member->value, literal);",
            "+                fprintf(out->fp,",
            "+                    \"__%sbuild_scalar_field(%\"PRIu64\", %s, %s_%.*s, %s%s, %s%s, %\"PRIu64\", %u, %s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, nsc, tprefix, tname_ns, tname,",
            "+                    (uint64_t)member->size, member->align, literal, snt.text);",
            "+            }",
            "             break;",
            "         case vt_vector_type:",
            "             tname_ns = scalar_type_ns(member->type.st, nsc);",
            "             tname = scalar_type_name(member->type.st);",
            "             tprefix = scalar_type_prefix(member->type.st);",
            "             fprintf(out->fp,",
            "-                \"__%sbuild_vector_field(%llu, %s, %s_%.*s, %s%s, %s%s, %s)\\n\",",
            "-                nsc, llu(member->id), nsc, snt.text, n, s, nsc, tprefix, tname_ns, tname, snt.text);",
            "+                \"__%sbuild_vector_field(%\"PRIu64\", %s, %s_%.*s, %s%s, %s%s, %s)\\n\",",
            "+                nsc, (uint64_t)member->id, nsc, snt.text, n, s, nsc, tprefix, tname_ns, tname, snt.text);",
            "             /* [ubyte] vectors can nest buffers. */",
            "             if (member->nest) {",
            "                 switch (member->nest->symbol.kind) {",
            "                 case fb_is_table:",
            "                     fb_compound_name((fb_compound_type_t *)(&member->nest->symbol), &snref);",
            "                     fprintf(out->fp, \"__%sbuild_nested_table_root(%s, %s_%.*s, %s, %s_identifier, %s_type_identifier)\\n\",",
            "                         nsc, nsc, snt.text, n, s, snref.text, snref.text, snref.text);",
            "@@ -1547,46 +1655,53 @@",
            "                     gen_panic(out, \"internal error: unexpected nested type\");",
            "                     continue;",
            "                 }",
            "             }",
            "             break;",
            "         case vt_string_type:",
            "             fprintf(out->fp,",
            "-                \"__%sbuild_string_field(%llu, %s, %s_%.*s, %s)\\n\",",
            "-                nsc, llu(member->id), nsc, snt.text, n, s, snt.text);",
            "+                \"__%sbuild_string_field(%\"PRIu64\", %s, %s_%.*s, %s)\\n\",",
            "+                nsc, (uint64_t)member->id, nsc, snt.text, n, s, snt.text);",
            "             break;",
            "         case vt_vector_string_type:",
            "             fprintf(out->fp,",
            "-                \"__%sbuild_string_vector_field(%llu, %s, %s_%.*s, %s)\\n\",",
            "-                nsc, llu(member->id), nsc, snt.text, n, s, snt.text);",
            "+                \"__%sbuild_string_vector_field(%\"PRIu64\", %s, %s_%.*s, %s)\\n\",",
            "+                nsc, (uint64_t)member->id, nsc, snt.text, n, s, snt.text);",
            "             break;",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_struct:",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_struct_field(%llu, %s, %s_%.*s, %s, %llu, %u, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, llu(member->size), member->align, snt.text);",
            "+                    \"__%sbuild_struct_field(%\"PRIu64\", %s, %s_%.*s, %s, %\"PRIu64\", %u, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, (uint64_t)member->size, member->align, snt.text);",
            "                 break;",
            "             case fb_is_table:",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_table_field(%llu, %s, %s_%.*s, %s, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snt.text);",
            "+                    \"__%sbuild_table_field(%\"PRIu64\", %s, %s_%.*s, %s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snt.text);",
            "                 break;",
            "             case fb_is_enum:",
            "-                print_literal(member->type.ct->type.st, &member->value, literal);",
            "-                fprintf(out->fp,",
            "-                    \"__%sbuild_scalar_field(%llu, %s, %s_%.*s, %s, %s_enum_t, %llu, %u, %s, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snref.text,",
            "-                    llu(member->size), member->align, literal, snt.text);",
            "+                if (is_optional) {",
            "+                    fprintf(out->fp,",
            "+                        \"__%sbuild_scalar_optional_field(%\"PRIu64\", %s, %s_%.*s, %s, %s_enum_t, %\"PRIu64\", %u, %s)\\n\",",
            "+                        nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snref.text,",
            "+                        (uint64_t)member->size, member->align, snt.text);",
            "+                } else {",
            "+                    print_literal(member->type.ct->type.st, &member->value, literal);",
            "+                    fprintf(out->fp,",
            "+                        \"__%sbuild_scalar_field(%\"PRIu64\", %s, %s_%.*s, %s, %s_enum_t, %\"PRIu64\", %u, %s, %s)\\n\",",
            "+                        nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snref.text,",
            "+                        (uint64_t)member->size, member->align, literal, snt.text);",
            "+                }",
            "                 break;",
            "             case fb_is_union:",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_union_field(%llu, %s, %s_%.*s, %s, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snt.text);",
            "+                    \"__%sbuild_union_field(%\"PRIu64\", %s, %s_%.*s, %s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snt.text);",
            "                 gen_union_fields(out, snt.text, n, s, member->type.ct, 0);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected compound type in table during code generation\");",
            "                 break;",
            "             }",
            "             break;",
            "@@ -1594,34 +1709,34 @@",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_struct:",
            "                 if (member->type.ct->symbol.flags & fb_indexed) {",
            "                     fprintf(out->fp, \"/* vector has keyed elements */\\n\");",
            "                 }",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_vector_field(%llu, %s, %s_%.*s, %s, %s_t, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snref.text, snt.text);",
            "+                    \"__%sbuild_vector_field(%\"PRIu64\", %s, %s_%.*s, %s, %s_t, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snref.text, snt.text);",
            "                 break;",
            "             case fb_is_table:",
            "                 if (member->type.ct->symbol.flags & fb_indexed) {",
            "                     fprintf(out->fp, \"/* vector has keyed elements */\\n\");",
            "                 }",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_table_vector_field(%llu, %s, %s_%.*s, %s, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snt.text);",
            "+                    \"__%sbuild_table_vector_field(%\"PRIu64\", %s, %s_%.*s, %s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snt.text);",
            "                 break;",
            "             case fb_is_enum:",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_vector_field(%llu, %s, %s_%.*s, %s, %s_enum_t, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snref.text, snt.text);",
            "+                    \"__%sbuild_vector_field(%\"PRIu64\", %s, %s_%.*s, %s, %s_enum_t, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snref.text, snt.text);",
            "                 break;",
            "             case fb_is_union:",
            "                 fprintf(out->fp,",
            "-                    \"__%sbuild_union_vector_field(%llu, %s, %s_%.*s, %s, %s)\\n\",",
            "-                    nsc, llu(member->id), nsc, snt.text, n, s, snref.text, snt.text);",
            "+                    \"__%sbuild_union_vector_field(%\"PRIu64\", %s, %s_%.*s, %s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, nsc, snt.text, n, s, snref.text, snt.text);",
            "                 gen_union_fields(out, snt.text, n, s, member->type.ct, 1);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected vector compound type in table during code generation\");",
            "                 break;",
            "             }",
            "             break;",
            "@@ -1835,15 +1950,15 @@",
            "                 \"static inline %s_union_ref_t %s_as_%.*s(%sstring_ref_t ref)\\n\"",
            "                 \"{ %s_union_ref_t uref; uref.type = %s_%.*s; uref.value = ref; return uref; }\\n\",",
            "                 snt.text, snt.text, n, s, nsc,",
            "                 snt.text, snt.text, n, s);",
            "             break;",
            "         case vt_missing:",
            "             fprintf(out->fp,",
            "-                \"static inline %s_union_ref_t %s_as_NONE()\\n\"",
            "+                \"static inline %s_union_ref_t %s_as_NONE(void)\\n\"",
            "                 \"{ %s_union_ref_t uref; uref.type = %s_NONE; uref.value = 0; return uref; }\\n\",",
            "                 snt.text, snt.text, snt.text, snt.text);",
            "             break;",
            "         default:",
            "             gen_panic(out, \"internal error: unexpected union value type\");",
            "             break;",
            "         }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_c_json_parser.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_c_json_parser.c",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_c_json_parser.c",
            "@@ -4,14 +4,16 @@",
            " #include \"catalog.h\"",
            " ",
            " /* -DFLATCC_PORTABLE may help if inttypes.h is missing. */",
            " #ifndef PRId64",
            " #include <inttypes.h>",
            " #endif",
            " ",
            "+#include \"flatcc/portable/pattributes.h\" /* fallthrough */",
            "+",
            " #define PRINTLN_SPMAX 64",
            " static char println_spaces[PRINTLN_SPMAX];",
            " ",
            " static void println(fb_output_t *out, const char * format, ...)",
            " {",
            "     int i = out->indent * out->opts->cgen_spacing;",
            "     va_list ap;",
            "@@ -232,35 +234,35 @@",
            "             && member->type.ct->symbol.kind == fb_is_union;",
            " }",
            " ",
            " static dict_entry_t *build_compound_dict(fb_compound_type_t *ct, int *count_out)",
            " {",
            "     fb_symbol_t *sym;",
            "     fb_member_t *member;",
            "-    int n;",
            "+    size_t n;",
            "     dict_entry_t *dict, *de;",
            "     char *strbuf = 0;",
            "-    int strbufsiz = 0;",
            "+    size_t strbufsiz = 0;",
            "     int is_union;",
            "-    int union_index = 0;",
            "+    size_t union_index = 0;",
            " ",
            "     n = 0;",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         is_union = is_union_member(member);",
            "         if (is_union) {",
            "             ++n;",
            "-            strbufsiz += member->symbol.ident->len + 6;",
            "+            strbufsiz += (size_t)member->symbol.ident->len + 6;",
            "         }",
            "         ++n;",
            "     }",
            "-    *count_out = n;",
            "+    *count_out = (int)n;",
            "     if (n == 0) {",
            "         return 0;",
            "     }",
            "     dict = malloc(n * sizeof(dict_entry_t) + strbufsiz);",
            "     if (!dict) {",
            "         return 0;",
            "     }",
            "@@ -268,24 +270,24 @@",
            "     de = dict;",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         de->text = member->symbol.ident->text;",
            "-        de->len = member->symbol.ident->len;",
            "+        de->len = (int)member->symbol.ident->len;",
            "         de->data = member;",
            "         de->hint = 0;",
            "         ++de;",
            "         is_union = is_union_member(member);",
            "         if (is_union) {",
            "             member->export_index = union_index++;",
            "-            de->len = member->symbol.ident->len + 5;",
            "+            de->len = (int)member->symbol.ident->len + 5;",
            "             de->text = strbuf;",
            "-            memcpy(strbuf, member->symbol.ident->text, member->symbol.ident->len);",
            "+            memcpy(strbuf, member->symbol.ident->text, (size_t)member->symbol.ident->len);",
            "             strbuf += member->symbol.ident->len;",
            "             strcpy(strbuf, \"_type\");",
            "             strbuf += 6;",
            "             de->data = member;",
            "             de->hint = 1;",
            "             ++de;",
            "         }",
            "@@ -311,15 +313,15 @@",
            " ",
            " static void install_visible_enum_symbol(void *context, fb_symbol_t *sym)",
            " {",
            "     install_enum_context_t *p = context;",
            " ",
            "     if (get_enum_if_visible(p->schema, sym)) {",
            "         p->de->text = sym->ident->text;",
            "-        p->de->len = sym->ident->len;",
            "+        p->de->len = (int)sym->ident->len;",
            "         p->de->data = sym;",
            "         p->de++;",
            "     }",
            " }",
            " ",
            " /*",
            "  * A scope dictionary contains all the enum types defined under the given",
            "@@ -351,44 +353,44 @@",
            " ",
            "     fb_symbol_table_visit(&scope->symbol_index, count_visible_enum_symbol, &iec);",
            "     *count_out = iec.count;",
            " ",
            "     if (iec.count == 0) {",
            "         return 0;",
            "     }",
            "-    dict = malloc(iec.count * sizeof(dict[0]));",
            "+    dict = malloc((size_t)iec.count * sizeof(dict[0]));",
            "     if (!dict) {",
            "         return 0;",
            "     }",
            "     iec.de = dict;",
            "     fb_symbol_table_visit(&scope->symbol_index, install_visible_enum_symbol, &iec);",
            "-    qsort(dict, iec.count, sizeof(dict[0]), dict_cmp);",
            "+    qsort(dict, (size_t)iec.count, sizeof(dict[0]), dict_cmp);",
            "     return dict;",
            " }",
            " ",
            " static dict_entry_t *build_global_scope_dict(catalog_t *catalog, int *count_out)",
            " {",
            "-    int i, n = catalog->nenums;",
            "+    size_t i, n = (size_t)catalog->nenums;",
            "     dict_entry_t *dict;",
            " ",
            "-    *count_out = n;",
            "+    *count_out = (int)n;",
            "     if (n == 0) {",
            "         return 0;",
            "     }",
            "     dict = malloc(n * sizeof(dict[0]));",
            "     if (!dict) {",
            "         return 0;",
            "     }",
            "-    for (i = 0; i < catalog->nenums; ++i) {",
            "+    for (i = 0; i < (size_t)catalog->nenums; ++i) {",
            "         dict[i].text = catalog->enums[i].name;",
            "         dict[i].len = (int)strlen(catalog->enums[i].name);",
            "         dict[i].data = catalog->enums[i].ct;",
            "         dict[i].hint = 0;",
            "     }",
            "-    qsort(dict, catalog->nenums, sizeof(dict[0]), dict_cmp);",
            "+    qsort(dict, (size_t)catalog->nenums, sizeof(dict[0]), dict_cmp);",
            "     *count_out = catalog->nenums;",
            "     return dict;",
            " }",
            " ",
            " static void clear_dict(dict_entry_t *dict)",
            " {",
            "     if (dict) {",
            "@@ -404,39 +406,46 @@",
            " ",
            "     int is_struct_container;",
            "     int is_string = 0;",
            "     int is_enum = 0;",
            "     int is_vector = 0;",
            "     int is_offset = 0;",
            "     int is_scalar = 0;",
            "+    int is_optional = 0;",
            "     int is_table = 0;",
            "     int is_struct = 0;",
            "     int is_union = 0;",
            "     int is_union_vector = 0;",
            "     int is_union_type_vector = 0;",
            "     int is_base64 = 0;",
            "     int is_base64url = 0;",
            "     int is_nested = 0;",
            "-    int st = 0;",
            "+    int is_array = 0;",
            "+    int is_char_array = 0;",
            "+    size_t array_len = 0;",
            "+    fb_scalar_type_t st = 0;",
            "     const char *tname_prefix = \"n/a\", *tname = \"n/a\"; /* suppress compiler warnigns */",
            "+    fb_literal_t literal;",
            " ",
            "     fb_clear(snref);",
            " ",
            "     fb_copy_scope(ct->scope, scope_name);",
            "     is_struct_container = ct->symbol.kind == fb_is_struct;",
            "+    is_optional = !!(member->flags & fb_fm_optional);",
            " ",
            "     switch (member->type.type) {",
            "     case vt_vector_type:",
            "     case vt_vector_compound_type_ref:",
            "     case vt_vector_string_type:",
            "         is_vector = 1;",
            "         break;",
            "     }",
            " ",
            "     switch (member->type.type) {",
            "+    case vt_fixed_array_compound_type_ref:",
            "     case vt_vector_compound_type_ref:",
            "     case vt_compound_type_ref:",
            "         fb_compound_name(member->type.ct, &snref);",
            "         is_enum = member->type.ct->symbol.kind == fb_is_enum;",
            "         is_struct = member->type.ct->symbol.kind == fb_is_struct;",
            "         is_table = member->type.ct->symbol.kind == fb_is_table;",
            "         is_union = member->type.ct->symbol.kind == fb_is_union && !is_union_type;",
            "@@ -450,20 +459,33 @@",
            "         is_string = 1;",
            "         break;",
            "     case vt_vector_type:",
            "         /* Nested types are processed twice, once as an array, once as an object. */",
            "         is_nested = member->nest != 0;",
            "         is_base64 = member->metadata_flags & fb_f_base64;",
            "         is_base64url = member->metadata_flags & fb_f_base64url;",
            "-        /* Fall through. */",
            "+        is_scalar = 1;",
            "+        st = member->type.st;",
            "+        break;",
            "+    case vt_fixed_array_type:",
            "+        is_scalar = 1;",
            "+        is_array = 1;",
            "+        array_len = member->type.len;",
            "+        st = member->type.st;",
            "+        break;",
            "     case vt_scalar_type:",
            "         is_scalar = 1;",
            "         st = member->type.st;",
            "         break;",
            "     }",
            "+    if (member->type.type == vt_fixed_array_compound_type_ref) {",
            "+        assert(is_struct_container);",
            "+        is_array = 1;",
            "+        array_len = member->type.len;",
            "+    }",
            "     if (is_base64 || is_base64url) {",
            "         /* Even if it is nested, parse it as a regular base64 or base64url encoded vector. */",
            "         if (st != fb_ubyte || !is_vector) {",
            "             gen_panic(out, \"internal error: unexpected base64 or base64url field type\\n\");",
            "             return -1;",
            "         }",
            "         is_nested = 0;",
            "@@ -477,15 +499,19 @@",
            "         is_union_type_vector = 1;",
            "         is_vector = 0;",
            "     }",
            "     if (is_vector && is_union) {",
            "         is_union_vector = 1;",
            "         is_vector = 0;",
            "     }",
            "-",
            "+    if (is_array && is_scalar && st == fb_char) {",
            "+        is_array = 0;",
            "+        is_scalar = 0;",
            "+        is_char_array = 1;",
            "+    }",
            "     if (is_nested == 1) {",
            "         println(out, \"if (buf != end && *buf == '[') { /* begin nested */\"); indent();",
            "     }",
            " repeat_nested:",
            "     if (is_nested == 2) {",
            "         unindent(); println(out, \"} else { /* nested */\"); indent();",
            "         fb_compound_name((fb_compound_type_t *)&member->nest->symbol, &snref);",
            "@@ -511,14 +537,33 @@",
            "             println(out, \"if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;\");",
            "         } else {",
            "             println(out,",
            "                 \"if (flatcc_builder_start_vector(ctx->ctx, %\"PRIu64\", %hu, UINT64_C(%\"PRIu64\"))) goto failed;\",",
            "                 (uint64_t)member->size, (short)member->align,",
            "                 (uint64_t)FLATBUFFERS_COUNT_MAX(member->size));",
            "         }",
            "+    }",
            "+    if (is_array) {",
            "+        if (is_scalar) {",
            "+            println(out, \"size_t count = %d;\", array_len);",
            "+            println(out, \"%s *base = (%s *)((size_t)struct_base + %\"PRIu64\");\",",
            "+                    tname, tname, (uint64_t)member->offset);",
            "+        }",
            "+        else {",
            "+            println(out, \"size_t count = %d;\", array_len);",
            "+            println(out, \"void *base = (void *)((size_t)struct_base + %\"PRIu64\");\",",
            "+                    (uint64_t)member->offset);",
            "+        }",
            "+    }",
            "+    if (is_char_array) {",
            "+        println(out, \"char *base = (char *)((size_t)struct_base + %\"PRIu64\");\",",
            "+                    (uint64_t)member->offset);",
            "+        println(out, \"buf = flatcc_json_parser_char_array(ctx, buf, end, base, %d);\", array_len);",
            "+    }",
            "+    if (is_array || is_vector) {",
            "         println(out, \"buf = flatcc_json_parser_array_start(ctx, buf, end, &more);\");",
            "         /* Note that we reuse `more` which is safe because it is updated at the end of the main loop. */",
            "         println(out, \"while (more) {\"); indent();",
            "     }",
            "     if (is_scalar) {",
            "         println(out, \"%s val = 0;\", tname);",
            "         println(out, \"static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {\");",
            "@@ -539,16 +584,18 @@",
            "         unindent(); unindent();",
            "     }",
            "     /* It is not safe to acquire the pointer before building element table or string. */",
            "     if (is_vector && !is_offset) {",
            "         println(out, \"if (!(pval = flatcc_builder_extend_vector(ctx->ctx, 1))) goto failed;\");",
            "     }",
            "     if (is_struct_container) {",
            "-        /* `struct_base` is given as argument to struct parsers. */",
            "-        println(out, \"pval = (void *)((size_t)struct_base + %\"PRIu64\");\", (uint64_t)member->offset);",
            "+        if (!is_array && !is_char_array) {",
            "+            /* `struct_base` is given as argument to struct parsers. */",
            "+            println(out, \"pval = (void *)((size_t)struct_base + %\"PRIu64\");\", (uint64_t)member->offset);",
            "+        }",
            "     } else if (is_struct && !is_vector) {",
            "         /* Same logic as scalars in tables, but scalars must be tested for default. */",
            "         println(out,",
            "             \"if (!(pval = flatcc_builder_table_add(ctx->ctx, %\"PRIu64\", %\"PRIu64\", %\"PRIu16\"))) goto failed;\",",
            "             (uint64_t)member->id, (uint64_t)member->size, (uint16_t)member->align);",
            "     }",
            "     if (is_scalar) {",
            "@@ -556,57 +603,51 @@",
            "         println(out, \"if (mark == buf) {\"); indent();",
            "         println(out, \"buf = flatcc_json_parser_symbolic_%s(ctx, (mark = buf), end, symbolic_parsers, &val);\", tname_prefix);",
            "         println(out, \"if (buf == mark || buf == end) goto failed;\");",
            "         unindent(); println(out, \"}\");",
            "         if (!is_struct_container && !is_vector && !is_base64 && !is_base64url) {",
            " #if !FLATCC_JSON_PARSE_FORCE_DEFAULTS",
            "             /* We need to create a check for the default value and create a table field if not the default. */",
            "-            switch(member->value.type) {",
            "-            case vt_bool:",
            "-            case vt_uint:",
            "-                println(out, \"if (val != %\"PRIu64\" || (ctx->flags & flatcc_json_parser_f_force_add)) {\", member->value.u); indent();",
            "-                break;",
            "-            case vt_int:",
            "-                println(out, \"if (val != %\"PRId64\" || (ctx->flags & flatcc_json_parser_f_force_add)) {\", member->value.i); indent();",
            "-                break;",
            "-                /*",
            "-                 * NOTE: We only store default value as a double float -",
            "-                 * if the field type is a 32-bit single precision float",
            "-                 * we might not print the exact value and thus we cannot",
            "-                 * test exactly for default - but then we store a value",
            "-                 * close to the default, or get a default close to the",
            "-                 * value. The same problem exists in the generated",
            "-                 * builder. Regardless, there is also truncation and",
            "-                 * rounding when parsing the original default value from",
            "-                 * the schema, so as long as we are consistent ... The",
            "-                 * flatbuffers reflection schema also only has a real",
            "-                 * type (64-bit double precision float).",
            "-                 * Even with double precision, printing is not an exact",
            "-                 * science and depends on the runtime library.",
            "-                 */",
            "-            case vt_float:",
            "-                println(out, \"if (val != %lf || (ctx->flags & flatcc_json_parser_f_force_add)) {\", (double)member->value.f); indent();",
            "-                break;",
            "-            default:",
            "-                gen_panic(out, \"internal error: unexpected default value type\\n\");",
            "-                return -1;",
            "+            if (!is_optional) {",
            "+                if (!print_literal(st, &member->value, literal)) return -1;",
            "+                println(out, \"if (val != %s || (ctx->flags & flatcc_json_parser_f_force_add)) {\", literal); indent();",
            "             }",
            " #endif",
            "             println(out, \"if (!(pval = flatcc_builder_table_add(ctx->ctx, %\"PRIu64\", %\"PRIu64\", %hu))) goto failed;\",",
            "                     (uint64_t)member->id, (uint64_t)member->size, (short)member->align);",
            " #if !FLATCC_JSON_PARSE_FORCE_DEFAULTS",
            " #endif",
            "         }",
            "         /* For scalars in table field, and in struct container. */",
            "-        println(out, \"%s%s_write_to_pe(pval, val);\", out->nsc, tname_prefix);",
            "-        if (!is_struct_container && !is_vector) {",
            "+        if (is_array) {",
            "+            println(out, \"if (count) {\"); indent();",
            "+            println(out, \"%s%s_write_to_pe(base, val);\", out->nsc, tname_prefix);",
            "+            println(out, \"--count;\");",
            "+            println(out, \"++base;\");",
            "+            unindent(); println(out, \"} else if (!(ctx->flags & flatcc_json_parser_f_skip_array_overflow)) {\"); indent();",
            "+            println(out, \"return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_array_overflow);\");",
            "+            unindent(); println(out, \"}\");",
            "+        } else {",
            "+            println(out, \"%s%s_write_to_pe(pval, val);\", out->nsc, tname_prefix);",
            "+        }",
            "+        if (!is_struct_container && !is_vector && !(is_scalar && is_optional)) {",
            "             unindent(); println(out, \"}\");",
            "         }",
            "     } else if (is_struct) {",
            "+        if (is_array) {",
            "+            println(out, \"if (count) {\"); indent();",
            "+            println(out, \"buf = %s_parse_json_struct_inline(ctx, buf, end, base);\", snref.text);",
            "+            println(out, \"--count;\");",
            "+            println(out, \"base = (void *)((size_t)base + %\"PRIu64\");\", member->type.ct->size);",
            "+            unindent(); println(out, \"} else if (!(ctx->flags & flatcc_json_parser_f_skip_array_overflow)) {\"); indent();",
            "+            println(out, \"return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_array_overflow);\");",
            "+            unindent(); println(out, \"}\");",
            "+        } else {",
            "             println(out, \"buf = %s_parse_json_struct_inline(ctx, buf, end, pval);\", snref.text);",
            "+        }",
            "     } else if (is_string) {",
            "         println(out, \"buf = flatcc_json_parser_build_string(ctx, buf, end, &ref);\");",
            "     } else if (is_base64 || is_base64url) {",
            "         println(out, \"buf = flatcc_json_parser_build_uint8_vector_base64(ctx, buf, end, &ref, %u);\",",
            "                 !is_base64);",
            "     } else if (is_table) {",
            "         println(out, \"buf = %s_parse_json_table(ctx, buf, end, &ref);\", snref.text);",
            "@@ -628,15 +669,15 @@",
            "         if (is_union_type_vector) {",
            "         println(out, \"buf = flatcc_json_parser_union_type_vector(ctx, buf, end, %\"PRIu64\", %\"PRIu64\", h_unions, symbolic_parsers, %s_parse_json_union, %s_json_union_accept_type);\",",
            "                 (uint64_t)member->export_index, member->id, snref.text, snref.text);",
            "         } else {",
            "             println(out, \"buf = flatcc_json_parser_union_type(ctx, buf, end, %\"PRIu64\", %\"PRIu64\", h_unions, symbolic_parsers, %s_parse_json_union);\",",
            "                 (uint64_t)member->export_index, member->id, snref.text);",
            "         }",
            "-    } else if (!is_vector) {",
            "+    } else if (!is_vector && !is_char_array) {",
            "         gen_panic(out, \"internal error: unexpected type for trie member\\n\");",
            "         return -1;",
            "     }",
            "     if (is_vector) {",
            "         if (is_offset) {",
            "             /* Deal with table and string vector elements - unions cannot be elements. */",
            "             println(out, \"if (!ref || !(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;\");",
            "@@ -647,14 +688,28 @@",
            "         unindent(); println(out, \"}\");",
            "         if (is_offset) {",
            "             println(out, \"ref = flatcc_builder_end_offset_vector(ctx->ctx);\");",
            "         } else {",
            "             println(out, \"ref = flatcc_builder_end_vector(ctx->ctx);\");",
            "         }",
            "     }",
            "+    if (is_array) {",
            "+        println(out, \"buf = flatcc_json_parser_array_end(ctx, buf, end, &more);\");",
            "+        unindent(); println(out, \"}\");",
            "+        println(out, \"if (count) {\"); indent();",
            "+        println(out, \"if (ctx->flags & flatcc_json_parser_f_reject_array_underflow) {\"); indent();",
            "+        println(out, \"return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_array_underflow);\");",
            "+        unindent(); println(out, \"}\");",
            "+        if (is_scalar) {",
            "+            println(out, \"memset(base, 0, count * sizeof(*base));\");",
            "+        } else {",
            "+            println(out, \"memset(base, 0, count * %\"PRIu64\");\", (uint64_t)member->type.ct->size);",
            "+        }",
            "+        unindent(); println(out, \"}\");",
            "+    }",
            "     if (is_nested == 1) {",
            "         is_nested = 2;",
            "         goto repeat_nested;",
            "     }",
            "     if (is_nested == 2) {",
            "         println(out, \"if (!ref) goto failed;\");",
            "         println(out, \"ref = flatcc_builder_end_buffer(ctx->ctx, ref);\");",
            "@@ -1357,15 +1412,15 @@",
            "     println(out, \"{\"); indent();",
            "     println(out, \"void *pval;\");",
            "     println(out, \"\");",
            "     println(out, \"*result = 0;\");",
            "     println(out, \"if (!(pval = flatcc_builder_start_struct(ctx->ctx, %\"PRIu64\", %\"PRIu16\"))) goto failed;\",",
            "             (uint64_t)ct->size, (uint16_t)ct->align);",
            "     println(out, \"buf = %s_parse_json_struct_inline(ctx, buf, end, pval);\", snt.text);",
            "-    println(out, \"if (buf == end || !(*result = flatcc_builder_end_struct(ctx->ctx))) goto failed;\");",
            "+    println(out, \"if (ctx->error || !(*result = flatcc_builder_end_struct(ctx->ctx))) goto failed;\");",
            "     println(out, \"return buf;\");",
            "     margin();",
            "     println(out, \"failed:\");",
            "     unmargin();",
            "     println(out, \"return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);\");",
            "     unindent(); println(out, \"}\");",
            "     println(out, \"\");",
            "@@ -1442,18 +1497,18 @@",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         is_union = is_union_member(member);",
            "         is_required = member->metadata_flags & fb_f_required;",
            "         if (is_required) {",
            "             if (first) {",
            "-                println(out, \"if (!flatcc_builder_check_required_field(ctx->ctx, %\"PRIu64\")\", member->id - is_union);",
            "+                println(out, \"if (!flatcc_builder_check_required_field(ctx->ctx, %\"PRIu64\")\", member->id - !!is_union);",
            "                 indent();",
            "             } else {",
            "-                println(out, \"||  !flatcc_builder_check_required_field(ctx->ctx, %\"PRIu64\")\", member->id - is_union);",
            "+                println(out, \"||  !flatcc_builder_check_required_field(ctx->ctx, %\"PRIu64\")\", member->id - !!is_union);",
            "             }",
            "             first = 0;",
            "         }",
            "     }",
            "     if (!first) {",
            "         unindent(); println(out, \") {\"); indent();",
            "         println(out, \"buf = flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_required);\");",
            "@@ -1711,14 +1766,15 @@",
            "         println(out, \" */\");",
            "     println(out, \"static int %s_parse_json(flatcc_builder_t *B, flatcc_json_parser_t *ctx,\",",
            "             out->S->basename);",
            "     indent(); indent();",
            "     println(out, \"const char *buf, size_t bufsiz, int flags);\");",
            "     unindent(); unindent();",
            "         println(out, \"\");",
            "+        fallthrough;",
            "     default:",
            "         break;",
            "     }",
            "     for (sym = out->S->symbols; sym; sym = sym->link) {",
            "         switch (sym->kind) {",
            "         case fb_is_union:",
            "             fb_compound_name((fb_compound_type_t *)sym, &snt);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_c_json_printer.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_c_json_printer.c",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_c_json_printer.c",
            "@@ -2,14 +2,16 @@",
            " #include \"flatcc/flatcc_types.h\"",
            " ",
            " /* -DFLATCC_PORTABLE may help if inttypes.h is missing. */",
            " #ifndef PRId64",
            " #include <inttypes.h>",
            " #endif",
            " ",
            "+#include \"flatcc/portable/pattributes.h\" /* fallthrough */",
            "+",
            " static int gen_json_printer_pretext(fb_output_t *out)",
            " {",
            "     fprintf(out->fp,",
            "         \"#ifndef %s_JSON_PRINTER_H\\n\"",
            "         \"#define %s_JSON_PRINTER_H\\n\",",
            "         out->S->basenameup, out->S->basenameup);",
            " ",
            "@@ -34,38 +36,39 @@",
            " {",
            "     fb_symbol_t *sym;",
            "     fb_member_t *member;",
            "     fb_scoped_name_t snt, snref;",
            "     const char *tp, *tn, *ns;",
            "     int bit_flags;",
            "     uint64_t mask = 0;",
            "-    char *suffix = \"\";",
            "+    char *constwrap = \"\";",
            "     char *ut = \"\";",
            "+    fb_scalar_type_t st = ct->type.st;",
            " ",
            "     fb_clear(snt);",
            "     fb_clear(snref);",
            "     fb_compound_name(ct, &snt);",
            "-    tp = scalar_type_prefix(ct->type.st);",
            "-    tn = scalar_type_name(ct->type.st);",
            "-    ns = scalar_type_ns(ct->type.st, out->nsc);",
            "+    tp = scalar_type_prefix(st);",
            "+    tn = scalar_type_name(st);",
            "+    ns = scalar_type_ns(st, out->nsc);",
            " ",
            "     bit_flags = !!(ct->metadata_flags & fb_f_bit_flags);",
            "     if (bit_flags) {",
            "         switch (ct->size) {",
            "         case 1:",
            "-            mask = 0xff, suffix = \"U\", ut = \"uint8_t\";",
            "+            mask = UINT8_MAX, constwrap = \"UINT8_C\", ut = \"uint8_t\";",
            "             break;",
            "         case 2:",
            "-            mask = 0xffff, suffix = \"U\", ut = \"uint16_t\";",
            "+            mask = UINT16_MAX, constwrap = \"UINT16_C\", ut = \"uint16_t\";",
            "             break;",
            "         case 4:",
            "-            mask = 0xffffffffL, suffix = \"UL\", ut = \"uint32_t\";",
            "+            mask = UINT32_MAX, constwrap = \"UINT32_C\", ut = \"uint32_t\";",
            "             break;",
            "         default:",
            "-            mask = 0xffffffffffffffffULL, suffix = \"ULL\", ut = \"uint64_t\";",
            "+            mask = UINT64_MAX, constwrap = \"UINT64_C\", ut = \"uint64_t\";",
            "             break;",
            "         }",
            "         for (sym = ct->members; sym; sym = sym->link) {",
            "             member = (fb_member_t *)sym;",
            "             switch (member->value.type) {",
            "             case vt_uint:",
            "                 mask &= ~(uint64_t)member->value.u;",
            "@@ -96,66 +99,66 @@",
            "         fprintf(out->fp, \"\\n\");",
            "         /*",
            "          * If the value is not entirely within the known bit flags, print as",
            "          * a number.",
            "          */",
            "         if (mask) {",
            "             fprintf(out->fp,",
            "-                    \"    if ((x & 0x%\"PRIx64\") || x == 0) {\\n\"",
            "+                    \"    if ((x & %s(0x%\"PRIx64\")) || x == 0) {\\n\"",
            "                     \"        flatcc_json_printer_%s(ctx, v);\\n\"",
            "                     \"        return;\\n\"",
            "                     \"    }\\n\",",
            "-                   mask, tp);",
            "+                   constwrap, mask, tp);",
            "         }",
            "         /*",
            "          * Test if multiple bits set. We may have a configuration option",
            "          * that requires multiple flags to be quoted like `color: \"Red Green\"`",
            "          * but unquoted if just a single value like `color: Green`.",
            "          *",
            "          * The index `i` is used to add space separators much like an",
            "          * index is provided for struct members to handle comma.",
            "          */",
            "         fprintf(out->fp, \"    flatcc_json_printer_delimit_enum_flags(ctx, multiple);\\n\");",
            "         for (sym = ct->members; sym; sym = sym->link) {",
            "             member = (fb_member_t *)sym;",
            "             switch (member->value.type) {",
            "             case vt_uint:",
            "-                fprintf(out->fp, \"    if (x & 0x%\"PRIx64\"%s) flatcc_json_printer_enum_flag(ctx, i++, \\\"%.*s\\\", %ld);\\n\",",
            "-                        member->value.u, suffix, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                fprintf(out->fp, \"    if (x & %s(0x%\"PRIx64\")) flatcc_json_printer_enum_flag(ctx, i++, \\\"%.*s\\\", %ld);\\n\",",
            "+                        constwrap, member->value.u, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            "             case vt_int:",
            "-                fprintf(out->fp, \"    if (x & 0x%\"PRIx64\"%s) flatcc_json_printer_enum_flag(ctx, i++, \\\"%.*s\\\", %ld);\\n\",",
            "-                        (uint64_t)member->value.i, suffix, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                fprintf(out->fp, \"    if (x & %s(0x%\"PRIx64\")) flatcc_json_printer_enum_flag(ctx, i++, \\\"%.*s\\\", %ld);\\n\",",
            "+                        constwrap, (uint64_t)member->value.i, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            "             case vt_bool:",
            "-                fprintf(out->fp, \"    if (x & 0x%\"PRIx64\"%s) flatcc_json_printer_enum_flag(ctx, i++, \\\"%.*s\\\", %ld);\\n\",",
            "-                        (uint64_t)member->value.b, suffix, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                fprintf(out->fp, \"    if (x & %s(0x%\"PRIx64\")) flatcc_json_printer_enum_flag(ctx, i++, \\\"%.*s\\\", %ld);\\n\",",
            "+                        constwrap, (uint64_t)member->value.b, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected value type for enum json_print\");",
            "                 break;",
            "             }",
            "         }",
            "         fprintf(out->fp, \"    flatcc_json_printer_delimit_enum_flags(ctx, multiple);\\n\");",
            "     } else {",
            "         fprintf(out->fp, \"\\n    switch (v) {\\n\");",
            "         for (sym = ct->members; sym; sym = sym->link) {",
            "             member = (fb_member_t *)sym;",
            "             switch (member->value.type) {",
            "             case vt_uint:",
            "-                fprintf(out->fp, \"    case %\"PRIu64\": flatcc_json_printer_enum(ctx, \\\"%.*s\\\", %ld); break;\\n\",",
            "-                        member->value.u, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                fprintf(out->fp, \"    case %s(%\"PRIu64\"): flatcc_json_printer_enum(ctx, \\\"%.*s\\\", %ld); break;\\n\",",
            "+                        constwrap, member->value.u, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            "             case vt_int:",
            "-                fprintf(out->fp, \"    case %\"PRId64\": flatcc_json_printer_enum(ctx, \\\"%.*s\\\", %ld); break;\\n\",",
            "-                        member->value.i, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                fprintf(out->fp, \"    case %s(%\"PRId64\"): flatcc_json_printer_enum(ctx, \\\"%.*s\\\", %ld); break;\\n\",",
            "+                        constwrap, member->value.i, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            "             case vt_bool:",
            "-                fprintf(out->fp, \"    case %u: flatcc_json_printer_enum(ctx, \\\"%.*s\\\", %ld); break;\\n\",",
            "-                        member->value.b, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                fprintf(out->fp, \"    case %s(%u): flatcc_json_printer_enum(ctx, \\\"%.*s\\\", %ld); break;\\n\",",
            "+                        constwrap, member->value.b, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected value type for enum json_print\");",
            "                 break;",
            "             }",
            "         }",
            "         fprintf(out->fp,",
            "@@ -292,14 +295,46 @@",
            "         case vt_scalar_type:",
            "             tp = scalar_type_prefix(member->type.st);",
            "             fprintf(",
            "                     out->fp,",
            "                     \"    flatcc_json_printer_%s_struct_field(ctx, %d, p, %\"PRIu64\", \\\"%.*s\\\", %ld);\\n\",",
            "                     tp, index, (uint64_t)member->offset, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "             break;",
            "+        case vt_fixed_array_type:",
            "+            tp = scalar_type_prefix(member->type.st);",
            "+            fprintf(",
            "+                    out->fp,",
            "+                    \"    flatcc_json_printer_%s_array_struct_field(ctx, %d, p, %\"PRIu64\", \\\"%.*s\\\", %ld, %d);\\n\",",
            "+                    tp, index, (uint64_t)member->offset, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->type.len);",
            "+            break;",
            "+        case vt_fixed_array_compound_type_ref:",
            "+            fb_compound_name(member->type.ct, &snref);",
            "+            switch (member->type.ct->symbol.kind) {",
            "+            case fb_is_enum:",
            "+#if FLATCC_JSON_PRINT_MAP_ENUMS",
            "+                tp = scalar_type_prefix(member->type.ct->type.st);",
            "+                fprintf(out->fp,",
            "+                        \"    flatcc_json_printer_%s_enum_array_struct_field(ctx, %d, p, %\"PRIu64\", \\\"%.*s\\\", %ld, %d, %s_print_json_enum);\\n\",",
            "+                        tp, index, (uint64_t)member->offset, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->type.len, snref.text);",
            "+                break;",
            "+#else",
            "+                tp = scalar_type_prefix(member->type.ct->type.st);",
            "+                fprintf(",
            "+                        out->fp,",
            "+                        \"    flatcc_json_printer_%s_array_struct_field(ctx, %d, p, %\"PRIu64\", \\\"%.*s\\\", %ld, %d);\\n\",",
            "+                        tp, index, (uint64_t)member->offset, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->type.len);",
            "+                break;",
            "+#endif",
            "+            case fb_is_struct:",
            "+                fprintf(out->fp,",
            "+                        \"    flatcc_json_printer_embedded_struct_array_field(ctx, %d, p, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRIu64\", %\"PRIu64\", %s_print_json_struct);\\n\",",
            "+                        index, (uint64_t)member->offset, (int)sym->ident->len, sym->ident->text, sym->ident->len,",
            "+                        (uint64_t)member->type.ct->size, (uint64_t)member->type.len, snref.text);",
            "+            }",
            "+            break;",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_enum:",
            " #if FLATCC_JSON_PRINT_MAP_ENUMS",
            "                 tp = scalar_type_prefix(member->type.ct->type.st);",
            "                 fprintf(out->fp,",
            "@@ -316,14 +351,15 @@",
            " #endif",
            "             case fb_is_struct:",
            "                 fprintf(out->fp,",
            "                         \"    flatcc_json_printer_embedded_struct_field(ctx, %d, p, %\"PRIu64\", \\\"%.*s\\\", %ld, %s_print_json_struct);\\n\",",
            "                         index, (uint64_t)member->offset, (int)sym->ident->len, sym->ident->text, sym->ident->len, snref.text);",
            "                 break;",
            "             }",
            "+            break;",
            "         }",
            "     }",
            "     fprintf(out->fp, \"}\\n\\n\");",
            "     fprintf(out->fp,",
            "             \"static inline int %s_print_json_as_root(flatcc_json_printer_t *ctx, const void *buf, size_t bufsiz, const char *fid)\\n\"",
            "             \"{\\n    return flatcc_json_printer_struct_as_root(ctx, buf, bufsiz, fid, %s_print_json_struct);\\n}\\n\\n\",",
            "             snt.text, snt.text);",
            "@@ -332,14 +368,15 @@",
            " ",
            " static int gen_json_printer_table(fb_output_t *out, fb_compound_type_t *ct)",
            " {",
            "     fb_symbol_t *sym;",
            "     fb_member_t *member;",
            "     fb_scoped_name_t snt, snref;",
            "     const char *tp;",
            "+    int is_optional;",
            "     int ret = 0;",
            " ",
            "     fb_clear(snt);",
            "     fb_clear(snref);",
            "     fb_compound_name(ct, &snt);",
            " ",
            "     /* Fields are printed in field id order for consistency across schema version. */",
            "@@ -350,39 +387,29 @@",
            " ",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         sym = &member->symbol;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "+        is_optional = !!(member->flags & fb_fm_optional);",
            "         fprintf(out->fp, \"\\n    \");",
            "         switch (member->type.type) {",
            "         case vt_scalar_type:",
            "             tp = scalar_type_prefix(member->type.st);",
            "-",
            "-            switch(member->value.type) {",
            "-            case vt_bool:",
            "-            case vt_uint:",
            "-                fprintf( out->fp,",
            "-                    \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRIu64\");\",",
            "-                    tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.u);",
            "-                break;",
            "-            case vt_int:",
            "+            if (is_optional) {",
            "                 fprintf( out->fp,",
            "-                    \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRId64\");\",",
            "-                    tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.i);",
            "-                break;",
            "-            case vt_float:",
            "+                    \"flatcc_json_printer_%s_optional_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld);\",",
            "+                    tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+            } else {",
            "+                fb_literal_t literal;",
            "+                if (!print_literal(member->type.st, &member->value, literal)) return -1;",
            "                 fprintf( out->fp,",
            "-                    \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %lf);\",",
            "-                    tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.f);",
            "-                break;",
            "-            default:",
            "-                gen_panic(out, \"internal error: unexpected default value type\\n\");",
            "-                goto fail;",
            "+                    \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s);\",",
            "+                    tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, literal);",
            "             }",
            "             break;",
            "         case vt_vector_type:",
            "             if (member->metadata_flags & (fb_f_base64 | fb_f_base64url)) {",
            "                 fprintf(out->fp,",
            "                         \"flatcc_json_printer_uint8_vector_base64_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %u);\",",
            "                         member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len,",
            "@@ -424,43 +451,39 @@",
            "                     member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "             break;",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_enum:",
            "                 tp = scalar_type_prefix(member->type.ct->type.st);",
            "-                switch(member->value.type) {",
            "-                case vt_bool:",
            " #if FLATCC_JSON_PRINT_MAP_ENUMS",
            "-                case vt_uint:",
            "-                    fprintf( out->fp,",
            "-                        \"flatcc_json_printer_%s_enum_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRIu64\", %s_print_json_enum);\",",
            "-                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.u, snref.text);",
            "-                    break;",
            "-                case vt_int:",
            "-                    fprintf( out->fp,",
            "-                        \"flatcc_json_printer_%s_enum_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRId64\", %s_print_json_enum);\",",
            "-                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.i, snref.text);",
            "-                    break;",
            "+                if (is_optional) {",
            "+                    fprintf(out->fp,",
            "+                        \"flatcc_json_printer_%s_enum_optional_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s_print_json_enum);\",",
            "+                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, snref.text);",
            "+                } else {",
            "+                    fb_literal_t literal;",
            "+                    if (!print_literal(member->type.ct->type.st, &member->value, literal)) return -1;",
            "+                    fprintf(out->fp,",
            "+                        \"flatcc_json_printer_%s_enum_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s, %s_print_json_enum);\",",
            "+                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, literal, snref.text);",
            "+                }",
            " #else",
            "-                case vt_uint:",
            "+                if (is_optional) {",
            "                     fprintf( out->fp,",
            "-                        \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRIu64\");\",",
            "-                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.u);",
            "-                    break;",
            "-                case vt_int:",
            "+                        \"flatcc_json_printer_%s_optional_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld);\",",
            "+                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "+                } else {",
            "+                    fb_literal_t literal;",
            "+                    if (!print_literal(member->type.ct->type.st, &member->value, literal)) return -1;",
            "                     fprintf( out->fp,",
            "-                        \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRId64\");\",",
            "-                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, member->value.i);",
            "-                    break;",
            "-#endif",
            "-                default:",
            "-                    gen_panic(out, \"internal error: unexpected default value type for enum\\n\");",
            "-                    goto fail;",
            "+                        \"flatcc_json_printer_%s_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s);\",",
            "+                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, literal);",
            "                 }",
            "+#endif",
            "                 break;",
            "             case fb_is_struct:",
            "                 fprintf(out->fp,",
            "                         \"flatcc_json_printer_struct_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s_print_json_struct);\",",
            "                         member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, snref.text);",
            "                 break;",
            "             case fb_is_table:",
            "@@ -484,22 +507,21 @@",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_table:",
            "                 fprintf(out->fp,",
            "                         \"flatcc_json_printer_table_vector_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s_print_json_table);\",",
            "                         member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, snref.text);",
            "                 break;",
            "             case fb_is_enum:",
            "+                tp = scalar_type_prefix(member->type.ct->type.st);",
            " #if FLATCC_JSON_PRINT_MAP_ENUMS",
            "-                tp = scalar_type_prefix(member->type.st);",
            "                 fprintf(out->fp,",
            "-                        \"flatcc_json_printer_%s_enum_vector_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %\"PRIu64\", %s_print_json_enum);\",",
            "-                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, (uint64_t)ct->size, snref.text);",
            "+                        \"flatcc_json_printer_%s_enum_vector_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld, %s_print_json_enum);\",",
            "+                        tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len, snref.text);",
            "                 break;",
            " #else",
            "-                tp = scalar_type_prefix(member->type.st);",
            "                 fprintf(out->fp,",
            "                         \"flatcc_json_printer_%s_vector_field(ctx, td, %\"PRIu64\", \\\"%.*s\\\", %ld);\",",
            "                         tp, member->id, (int)sym->ident->len, sym->ident->text, sym->ident->len);",
            "                 break;",
            " #endif",
            "             case fb_is_struct:",
            "                 fprintf(out->fp,",
            "@@ -557,14 +579,15 @@",
            "                 \" * be initialized with the appropriate output type, or it can be 0 which\\n\"",
            "                 \" * defaults to stdout. NOTE: `ctx` is not generally allowed to be null, only\\n\"",
            "                 \" * here for a simplified interface.\\n\"",
            "                 \" */\\n\");",
            "     fprintf(out->fp,",
            "             \"static int %s_print_json(flatcc_json_printer_t *ctx, const char *buf, size_t bufsiz);\\n\\n\",",
            "             out->S->basename);",
            "+        fallthrough;",
            "     default:",
            "         break;",
            "     }",
            " ",
            "     for (sym = out->S->symbols; sym; sym = sym->link) {",
            "         switch (sym->kind) {",
            "         case fb_is_union:"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_c_reader.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_c_reader.c",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_c_reader.c",
            "@@ -1,14 +1,20 @@",
            " #include <stdio.h>",
            " #include <assert.h>",
            " #include <string.h>",
            " ",
            " #include \"codegen_c.h\"",
            " #include \"codegen_c_sort.h\"",
            " ",
            "+static inline int match_kw_identifier(fb_symbol_t *sym)",
            "+{",
            "+    return (sym->ident->len == 10 &&",
            "+            memcmp(sym->ident->text, \"identifier\", 10) == 0);",
            "+}",
            "+",
            " /*",
            "  * Use of file identifiers for undeclared roots is fuzzy, but we need an",
            "  * identifer for all, so we use the one defined for the current schema",
            "  * file and allow the user to override. This avoids tedious runtime file",
            "  * id arguments to all create calls.",
            "  *",
            "  * As later addition to FlatBuffers, type hashes may replace file",
            "@@ -25,26 +31,59 @@",
            "     uint8_t *p;",
            "     uint8_t x;",
            "     int i;",
            "     const char *nsc = out->nsc;",
            "     fb_scoped_name_t snt;",
            "     const char *name;",
            "     uint32_t type_hash;",
            "+    int conflict = 0;",
            "+    fb_symbol_t *sym;",
            "+    const char *file_identifier;",
            "+    int file_identifier_len;",
            "+    const char *quote;",
            " ",
            "     fb_clear(snt);",
            " ",
            "     fb_compound_name(ct, &snt);",
            "     name = snt.text;",
            "     type_hash = ct->type_hash;",
            " ",
            "+    /*",
            "+     * It's not practical to detect all possible name conflicts, but",
            "+     * 'identifier' is common enough to require special handling.",
            "+     */",
            "+    for (sym = ct->members; sym; sym = sym->link) {",
            "+        if (match_kw_identifier(sym)) {",
            "+            conflict = 1;",
            "+            break;",
            "+        }",
            "+    }",
            "+    if (out->S->file_identifier.type == vt_string) {",
            "+        quote = \"\\\"\";",
            "+        file_identifier = out->S->file_identifier.s.s;",
            "+        file_identifier_len = out->S->file_identifier.s.len;",
            "+    } else {",
            "+        quote = \"\";",
            "+        file_identifier = \"0\";",
            "+        file_identifier_len = 1;",
            "+    }",
            "     fprintf(out->fp,",
            "-            \"#ifndef %s_identifier\\n\"",
            "-            \"#define %s_identifier %sidentifier\\n\"",
            "+            \"#ifndef %s_file_identifier\\n\"",
            "+            \"#define %s_file_identifier %s%.*s%s\\n\"",
            "             \"#endif\\n\",",
            "-            name, name, nsc);",
            "+            name, name, quote, file_identifier_len, file_identifier, quote);",
            "+    if (!conflict) {",
            "+        /* For backwards compatibility. */",
            "+        fprintf(out->fp,",
            "+                \"/* deprecated, use %s_file_identifier */\\n\"",
            "+                \"#ifndef %s_identifier\\n\"",
            "+                \"#define %s_identifier %s%.*s%s\\n\"",
            "+                \"#endif\\n\",",
            "+                name, name, name, quote, file_identifier_len, file_identifier, quote);",
            "+    }",
            "     fprintf(out->fp,",
            "         \"#define %s_type_hash ((%sthash_t)0x%lx)\\n\",",
            "         name, nsc, (unsigned long)(type_hash));",
            "     p = buf;",
            "     i = 4;",
            "     while (i--) {",
            "         *p++ = '\\\\';",
            "@@ -61,14 +100,38 @@",
            "     }",
            "     *p = '\\0';",
            "     fprintf(out->fp,",
            "         \"#define %s_type_identifier \\\"%s\\\"\\n\",",
            "         name, buf);",
            " }",
            " ",
            "+static void print_file_extension(fb_output_t *out, fb_compound_type_t *ct)",
            "+{",
            "+    fb_scoped_name_t snt;",
            "+    const char *name;",
            "+",
            "+    fb_clear(snt);",
            "+    fb_compound_name(ct, &snt);",
            "+    name = snt.text;",
            "+",
            "+    if (out->S->file_extension.type == vt_string) {",
            "+        fprintf(out->fp,",
            "+                \"#ifndef %s_file_extension\\n\"",
            "+                \"#define %s_file_extension \\\"%.*s\\\"\\n\"",
            "+                \"#endif\\n\",",
            "+                name, name, out->S->file_extension.s.len, out->S->file_extension.s.s);",
            "+    } else {",
            "+        fprintf(out->fp,",
            "+                \"#ifndef %s_file_extension\\n\"",
            "+                \"#define %s_file_extension \\\"%s\\\"\\n\"",
            "+                \"#endif\\n\",",
            "+                name, name, out->opts->default_bin_ext);",
            "+    }",
            "+}",
            "+",
            " /* Finds first occurrence of matching key when vector is sorted on the named field. */",
            " static void gen_find(fb_output_t *out)",
            " {",
            "     const char *nsc = out->nsc;",
            " ",
            "     /*",
            "      * E: Element accessor (elem = E(vector, index)).",
            "@@ -80,16 +143,16 @@",
            "      * Kn: optional key length so external strings do not have to be zero terminated.",
            "      * D: the diff function D(v, K, Kn) :: v - <K, Kn>",
            "      *",
            "      * returns index (0..len - 1), or not_found (-1).",
            "      */",
            "     fprintf(out->fp,",
            "         \"#include <string.h>\\n\"",
            "-        \"static size_t %snot_found = (size_t)-1;\\n\"",
            "-        \"static size_t %send = (size_t)-1;\\n\"",
            "+        \"static const size_t %snot_found = (size_t)-1;\\n\"",
            "+        \"static const size_t %send = (size_t)-1;\\n\"",
            "         \"#define __%sidentity(n) (n)\\n\"",
            "         \"#define __%smin(a, b) ((a) < (b) ? (a) : (b))\\n\",",
            "         nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"/* Subtraction doesn't work for unsigned types. */\\n\"",
            "         \"#define __%sscalar_cmp(x, y, n) ((x) < (y) ? -1 : (x) > (y))\\n\"",
            "         \"static inline int __%sstring_n_cmp(%sstring_t v, const char *s, size_t n)\\n\"",
            "@@ -142,27 +205,27 @@",
            "         \"__%sfind_by_scalar_field(__%sidentity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\\n\",",
            "         nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_find_by_string_field(N, NK) \\\\\\n\"",
            "         \"/* Note: find only works on vectors sorted by this field. */\\\\\\n\"",
            "         \"static inline size_t N ## _vec_find_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"__%sfind_by_string_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_find_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_find_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"__%sfind_by_string_n_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\n\",",
            "         nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_default_find_by_scalar_field(N, NK, TK)\\\\\\n\"",
            "         \"static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, TK key__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_find_by_ ## NK(vec__tmp, key__tmp); }\\n\",",
            "         nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_default_find_by_string_field(N, NK) \\\\\\n\"",
            "         \"static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_find_by_ ## NK(vec__tmp, s__tmp); }\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_find_n(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_find_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_find_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\\n\",",
            "         nsc);",
            " }",
            " ",
            " static void gen_union(fb_output_t *out)",
            " {",
            "     const char *nsc = out->nsc;",
            "@@ -174,14 +237,34 @@",
            "         \"} %sunion_t;\\n\"",
            "         \"typedef struct %sunion_vec {\\n\"",
            "         \"    const %sunion_type_t *type;\\n\"",
            "         \"    const %suoffset_t *value;\\n\"",
            "         \"} %sunion_vec_t;\\n\",",
            "         nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "+        \"typedef struct %smutable_union {\\n\"",
            "+        \"    %sunion_type_t type;\\n\"",
            "+        \"    %smutable_generic_t value;\\n\"",
            "+        \"} %smutable_union_t;\\n\"",
            "+        \"typedef struct %smutable_union_vec {\\n\"",
            "+        \"    %sunion_type_t *type;\\n\"",
            "+        \"    %suoffset_t *value;\\n\"",
            "+        \"} %smutable_union_vec_t;\\n\",",
            "+        nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "+    fprintf(out->fp,",
            "+        \"static inline %smutable_union_t %smutable_union_cast(%sunion_t u__tmp)\\\\\\n\"",
            "+        \"{ %smutable_union_t mu = { u__tmp.type, (%smutable_generic_t)u__tmp.value };\\\\\\n\"",
            "+        \"  return mu; }\\n\",",
            "+        nsc, nsc, nsc, nsc, nsc);",
            "+    fprintf(out->fp,",
            "+        \"static inline %smutable_union_vec_t %smutable_union_vec_cast(%sunion_vec_t uv__tmp)\\\\\\n\"",
            "+        \"{ %smutable_union_vec_t muv =\\\\\\n\"",
            "+        \"  { (%sunion_type_t *)uv__tmp.type, (%suoffset_t *)uv__tmp.value }; return muv; }\\n\",",
            "+        nsc, nsc, nsc, nsc, nsc, nsc);",
            "+    fprintf(out->fp,",
            "         \"#define __%sunion_type_field(ID, t)\\\\\\n\"",
            "         \"{\\\\\\n\"",
            "         \"    __%sread_vt(ID, offset__tmp, t)\\\\\\n\"",
            "         \"    return offset__tmp ? __%sread_scalar_at_byteoffset(__%sutype, t, offset__tmp) : 0;\\\\\\n\"",
            "         \"}\\n\",",
            "         nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "@@ -212,40 +295,46 @@",
            "         \"\\n\");",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_union_vector_ops(NS, T)\\\\\\n\"",
            "         \"static inline size_t T ## _union_vec_len(T ## _union_vec_t uv__tmp)\\\\\\n\"",
            "         \"{ return NS ## vec_len(uv__tmp.type); }\\\\\\n\"",
            "         \"static inline T ## _union_t T ## _union_vec_at(T ## _union_vec_t uv__tmp, size_t i__tmp)\\\\\\n\"",
            "         \"{ T ## _union_t u__tmp = { 0, 0 }; size_t n__tmp = NS ## vec_len(uv__tmp.type);\\\\\\n\"",
            "-        \"  assert(n__tmp > (i__tmp) && \\\"index out of range\\\"); u__tmp.type = uv__tmp.type[i__tmp];\\\\\\n\"",
            "+        \"  FLATCC_ASSERT(n__tmp > (i__tmp) && \\\"index out of range\\\"); u__tmp.type = uv__tmp.type[i__tmp];\\\\\\n\"",
            "         \"  /* Unknown type is treated as NONE for schema evolution. */\\\\\\n\"",
            "         \"  if (u__tmp.type == 0) return u__tmp;\\\\\\n\"",
            "         \"  u__tmp.value = NS ## generic_vec_at(uv__tmp.value, i__tmp); return u__tmp; }\\\\\\n\"",
            "         \"static inline NS ## string_t T ## _union_vec_at_as_string(T ## _union_vec_t uv__tmp, size_t i__tmp)\\\\\\n\"",
            "         \"{ return (NS ## string_t) NS ## generic_vec_at_as_string(uv__tmp.value, i__tmp); }\\\\\\n\"",
            "         \"\\n\",",
            "         nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_union_vector(NS, T)\\\\\\n\"",
            "         \"typedef NS ## union_vec_t T ## _union_vec_t;\\\\\\n\"",
            "+        \"typedef NS ## mutable_union_vec_t T ## _mutable_union_vec_t;\\\\\\n\"",
            "+        \"static inline T ## _mutable_union_vec_t T ## _mutable_union_vec_cast(T ## _union_vec_t u__tmp)\\\\\\n\"",
            "+        \"{ return NS ## mutable_union_vec_cast(u__tmp); }\\\\\\n\"",
            "         \"__## NS ## define_union_vector_ops(NS, T)\\n\",",
            "         nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_union(NS, T)\\\\\\n\"",
            "         \"typedef NS ## union_t T ## _union_t;\\\\\\n\"",
            "+        \"typedef NS ## mutable_union_t T ## _mutable_union_t;\\\\\\n\"",
            "+        \"static inline T ## _mutable_union_t T ## _mutable_union_cast(T ## _union_t u__tmp)\\\\\\n\"",
            "+        \"{ return NS ## mutable_union_cast(u__tmp); }\\\\\\n\"",
            "         \"__## NS ## define_union_vector(NS, T)\\n\",",
            "         nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_union_vector_field(NS, ID, N, NK, T, r)\\\\\\n\"",
            "         \"__## NS ## define_vector_field(ID - 1, N, NK ## _type, T ## _vec_t, r)\\\\\\n\"",
            "         \"__## NS ## define_vector_field(ID, N, NK, flatbuffers_generic_vec_t, r)\\\\\\n\"",
            "         \"static inline T ## _union_vec_t N ## _ ## NK ## _union(N ## _table_t t__tmp)\\\\\\n\"",
            "         \"{ T ## _union_vec_t uv__tmp; uv__tmp.type = N ## _ ## NK ## _type_get(t__tmp);\\\\\\n\"",
            "         \"  uv__tmp.value = N ## _ ## NK(t__tmp);\\\\\\n\"",
            "-        \"  assert(NS ## vec_len(uv__tmp.type) == NS ## vec_len(uv__tmp.value)\\\\\\n\"",
            "+        \"  FLATCC_ASSERT(NS ## vec_len(uv__tmp.type) == NS ## vec_len(uv__tmp.value)\\\\\\n\"",
            "         \"  && \\\"union vector type length mismatch\\\"); return uv__tmp; }\\n\",",
            "         nsc);",
            " }",
            " ",
            " /* Linearly finds first occurrence of matching key, doesn't require vector to be sorted. */",
            " static void gen_scan(fb_output_t *out)",
            " {",
            "@@ -329,27 +418,27 @@",
            "         \"static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, T key__tmp)\\\\\\n\"",
            "         \"__%srscan_by_scalar_field(begin__tmp, __%smin(end__tmp, N ## _vec_len(vec__tmp)), __%sidentity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\\n\",",
            "         nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_scan_by_string_field(N, NK) \\\\\\n\"",
            "         \"static inline size_t N ## _vec_scan_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"__%sscan_by_string_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_scan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_scan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"__%sscan_by_string_n_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\\\\\n\"",
            "         \"static inline size_t N ## _vec_scan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"__%sscan_by_string_field(begin__tmp, __%smin(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_scan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_scan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"__%sscan_by_string_n_field(begin__tmp, __%smin( end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\\\\\n\"",
            "         \"static inline size_t N ## _vec_rscan_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"__%srscan_by_string_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_rscan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_rscan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"__%srscan_by_string_n_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\\\\\n\"",
            "         \"static inline size_t N ## _vec_rscan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"__%srscan_by_string_field(begin__tmp, __%smin(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_rscan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_rscan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"__%srscan_by_string_n_field(begin__tmp, __%smin( end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\\n\",",
            "         nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_default_scan_by_scalar_field(N, NK, TK)\\\\\\n\"",
            "         \"static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, TK key__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_scan_by_ ## NK(vec__tmp, key__tmp); }\\\\\\n\"",
            "         \"static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, TK key__tmp)\\\\\\n\"",
            "@@ -359,27 +448,27 @@",
            "         \"static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, TK key__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_rscan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, key__tmp); }\\n\",",
            "         nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sdefine_default_scan_by_string_field(N, NK) \\\\\\n\"",
            "         \"static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_scan_by_ ## NK(vec__tmp, s__tmp); }\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_scan_n(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_scan_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_scan_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\\\\\\n\"",
            "         \"static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_scan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp); }\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_scan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_scan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_scan_ex_n_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp, n__tmp); }\\\\\\n\"",
            "         \"static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_rscan_by_ ## NK(vec__tmp, s__tmp); }\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_rscan_n(N ## _vec_t vec__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_rscan_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_rscan_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\\\\\\n\"",
            "         \"static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_rscan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp); }\\\\\\n\"",
            "-        \"static inline size_t N ## _vec_rscan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, int n__tmp)\\\\\\n\"",
            "+        \"static inline size_t N ## _vec_rscan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\\\\\\n\"",
            "         \"{ return N ## _vec_rscan_ex_n_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp, n__tmp); }\\n\",",
            "         nsc);",
            " }",
            " ",
            " static void gen_helpers(fb_output_t *out)",
            " {",
            "     const char *nsc = out->nsc;",
            "@@ -445,19 +534,19 @@",
            "         \"#define __%sread_scalar_at_byteoffset(N, p, o) N ## _read_from_pe((uint8_t *)(p) + (o))\\n\"",
            "         \"#define __%sread_scalar(N, p) N ## _read_from_pe(p)\\n\",",
            "         nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sread_vt(ID, offset, t)\\\\\\n\"",
            "         \"%svoffset_t offset = 0;\\\\\\n\"",
            "         \"{   %svoffset_t id__tmp, *vt__tmp;\\\\\\n\"",
            "-        \"    assert(t != 0 && \\\"null pointer table access\\\");\\\\\\n\"",
            "+        \"    FLATCC_ASSERT(t != 0 && \\\"null pointer table access\\\");\\\\\\n\"",
            "         \"    id__tmp = ID;\\\\\\n\"",
            "         \"    vt__tmp = (%svoffset_t *)((uint8_t *)(t) -\\\\\\n\"",
            "         \"        __%ssoffset_read_from_pe(t));\\\\\\n\"",
            "-        \"    if (__%svoffset_read_from_pe(vt__tmp) >= sizeof(vt__tmp[0]) * (id__tmp + 3)) {\\\\\\n\"",
            "+        \"    if (__%svoffset_read_from_pe(vt__tmp) >= sizeof(vt__tmp[0]) * (id__tmp + 3u)) {\\\\\\n\"",
            "         \"        offset = __%svoffset_read_from_pe(vt__tmp + id__tmp + 2);\\\\\\n\"",
            "         \"    }\\\\\\n\"",
            "         \"}\\n\",",
            "         nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "             \"#define __%sfield_present(ID, t) { __%sread_vt(ID, offset__tmp, t) return offset__tmp != 0; }\\n\",",
            "             nsc, nsc);",
            "@@ -492,36 +581,44 @@",
            "         \"__%sfield_present(ID, t__tmp)\",nsc);",
            "     if (out->opts->allow_scan_for_all_fields) {",
            "         fprintf(out->fp, \"\\\\\\n__%sdefine_scan_by_scalar_field(N, NK, T)\\n\", nsc);",
            "     } else {",
            "         fprintf(out->fp, \"\\n\");",
            "     }",
            "     fprintf(out->fp,",
            "+        \"#define __%sdefine_scalar_optional_field(ID, N, NK, TK, T, V)\\\\\\n\"",
            "+        \"__%sdefine_scalar_field(ID, N, NK, TK, T, V)\\\\\\n\"",
            "+        \"static inline TK ## _option_t N ## _ ## NK ## _option(N ## _table_t t__tmp)\\\\\\n\"",
            "+        \"{ TK ## _option_t ret; __%sread_vt(ID, offset__tmp, t__tmp)\\\\\\n\"",
            "+        \"  ret.is_null = offset__tmp == 0; ret.value = offset__tmp ?\\\\\\n\"",
            "+        \"  __%sread_scalar_at_byteoffset(TK, t__tmp, offset__tmp) : V;\\\\\\n\"",
            "+        \"  return ret; }\\n\", nsc, nsc, nsc, nsc);",
            "+    fprintf(out->fp,",
            "         \"#define __%sstruct_field(T, ID, t, r)\\\\\\n\"",
            "         \"{\\\\\\n\"",
            "         \"    __%sread_vt(ID, offset__tmp, t)\\\\\\n\"",
            "         \"    if (offset__tmp) {\\\\\\n\"",
            "         \"        return (T)((uint8_t *)(t) + offset__tmp);\\\\\\n\"",
            "         \"    }\\\\\\n\"",
            "-        \"    assert(!(r) && \\\"required field missing\\\");\\\\\\n\"",
            "+        \"    FLATCC_ASSERT(!(r) && \\\"required field missing\\\");\\\\\\n\"",
            "         \"    return 0;\\\\\\n\"",
            "         \"}\\n\",",
            "         nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%soffset_field(T, ID, t, r, adjust)\\\\\\n\"",
            "         \"{\\\\\\n\"",
            "         \"    %suoffset_t *elem__tmp;\\\\\\n\"",
            "         \"    __%sread_vt(ID, offset__tmp, t)\\\\\\n\"",
            "         \"    if (offset__tmp) {\\\\\\n\"",
            "         \"        elem__tmp = (%suoffset_t *)((uint8_t *)(t) + offset__tmp);\\\\\\n\"",
            "         \"        /* Add sizeof so C api can have raw access past header field. */\\\\\\n\"",
            "         \"        return (T)((uint8_t *)(elem__tmp) + adjust +\\\\\\n\"",
            "         \"              __%suoffset_read_from_pe(elem__tmp));\\\\\\n\"",
            "         \"    }\\\\\\n\"",
            "-        \"    assert(!(r) && \\\"required field missing\\\");\\\\\\n\"",
            "+        \"    FLATCC_ASSERT(!(r) && \\\"required field missing\\\");\\\\\\n\"",
            "         \"    return 0;\\\\\\n\"",
            "         \"}\\n\",",
            "         nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%svector_field(T, ID, t, r) __%soffset_field(T, ID, t, r, sizeof(%suoffset_t))\\n\"",
            "         \"#define __%stable_field(T, ID, t, r) __%soffset_field(T, ID, t, r, 0)\\n\",",
            "         nsc, nsc, nsc, nsc, nsc);",
            "@@ -586,26 +683,26 @@",
            "     fprintf(out->fp,",
            "         \"static inline size_t %svec_len(const void *vec)\\n\"",
            "         \"__%svec_len(vec)\\n\",",
            "         nsc, nsc);",
            "     fprintf(out->fp,",
            "         /* Tb is the base type for loads. */",
            "         \"#define __%sscalar_vec_at(N, vec, i)\\\\\\n\"",
            "-        \"{ assert(%svec_len(vec) > (i) && \\\"index out of range\\\");\\\\\\n\"",
            "+        \"{ FLATCC_ASSERT(%svec_len(vec) > (i) && \\\"index out of range\\\");\\\\\\n\"",
            "         \"  return __%sread_scalar(N, &(vec)[i]); }\\n\",",
            "         nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"#define __%sstruct_vec_at(vec, i)\\\\\\n\"",
            "-        \"{ assert(%svec_len(vec) > (i) && \\\"index out of range\\\"); return (vec) + (i); }\\n\",",
            "+        \"{ FLATCC_ASSERT(%svec_len(vec) > (i) && \\\"index out of range\\\"); return (vec) + (i); }\\n\",",
            "         nsc, nsc);",
            "     fprintf(out->fp,",
            "         \"/* `adjust` skips past the header for string vectors. */\\n\"",
            "         \"#define __%soffset_vec_at(T, vec, i, adjust)\\\\\\n\"",
            "         \"{ const %suoffset_t *elem__tmp = (vec) + (i);\\\\\\n\"",
            "-        \"  assert(%svec_len(vec) > (i) && \\\"index out of range\\\");\\\\\\n\"",
            "+        \"  FLATCC_ASSERT(%svec_len(vec) > (i) && \\\"index out of range\\\");\\\\\\n\"",
            "         \"  return (T)((uint8_t *)(elem__tmp) + (size_t)__%suoffset_read_from_pe(elem__tmp) + (adjust)); }\\n\",",
            "         nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "             \"#define __%sdefine_scalar_vec_len(N)\\\\\\n\"",
            "             \"static inline size_t N ## _vec_len(N ##_vec_t vec__tmp)\\\\\\n\"",
            "             \"{ return %svec_len(vec__tmp); }\\n\",",
            "             nsc, nsc);",
            "@@ -624,14 +721,15 @@",
            "             \"typedef %suoffset_t *%sstring_mutable_vec_t;\\n\"",
            "             \"static inline size_t %sstring_vec_len(%sstring_vec_t vec)\\n\"",
            "             \"__%svec_len(vec)\\n\"",
            "             \"static inline %sstring_t %sstring_vec_at(%sstring_vec_t vec, size_t i)\\n\"",
            "             \"__%soffset_vec_at(%sstring_t, vec, i, sizeof(vec[0]))\\n\",",
            "             nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp, \"typedef const void *%sgeneric_t;\\n\", nsc);",
            "+    fprintf(out->fp, \"typedef void *%smutable_generic_t;\\n\", nsc);",
            "     fprintf(out->fp,",
            "         \"static inline %sstring_t %sstring_cast_from_generic(const %sgeneric_t p)\\n\"",
            "         \"{ return p ? ((const char *)p) + __%suoffset__size() : 0; }\\n\",",
            "         nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "             \"typedef const %suoffset_t *%sgeneric_vec_t;\\n\"",
            "             \"typedef %suoffset_t *%sgeneric_table_mutable_vec_t;\\n\"",
            "@@ -643,14 +741,39 @@",
            "             \"__%soffset_vec_at(%sgeneric_t, vec, i, sizeof(vec[0]))\\n\",",
            "             nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     gen_union(out);",
            "     gen_find(out);",
            "     gen_scan(out);",
            "     if (out->opts->cgen_sort) {",
            "         gen_sort(out);",
            "+        fprintf(out->fp,",
            "+            \"#define __%ssort_vector_field(N, NK, T, t)\\\\\\n\"",
            "+            \"{ T ## _mutable_vec_t v__tmp = (T ## _mutable_vec_t) N ## _ ## NK ## _get(t);\\\\\\n\"",
            "+            \"  if (v__tmp) T ## _vec_sort(v__tmp); }\\n\",",
            "+            nsc);",
            "+        fprintf(out->fp,",
            "+            \"#define __%ssort_table_field(N, NK, T, t)\\\\\\n\"",
            "+            \"{ T ## _sort((T ## _mutable_table_t)N ## _ ## NK ## _get(t)); }\\n\",",
            "+            nsc);",
            "+        fprintf(out->fp,",
            "+            \"#define __%ssort_union_field(N, NK, T, t)\\\\\\n\"",
            "+            \"{ T ## _sort(T ## _mutable_union_cast(N ## _ ## NK ## _union(t))); }\\n\",",
            "+            nsc);",
            "+        fprintf(out->fp,",
            "+            \"#define __%ssort_table_vector_field_elements(N, NK, T, t)\\\\\\n\"",
            "+            \"{ T ## _vec_t v__tmp = N ## _ ## NK ## _get(t); size_t i__tmp, n__tmp;\\\\\\n\"",
            "+            \"  n__tmp = T ## _vec_len(v__tmp); for (i__tmp = 0; i__tmp < n__tmp; ++i__tmp) {\\\\\\n\"",
            "+            \"  T ## _sort((T ## _mutable_table_t)T ## _vec_at(v__tmp, i__tmp)); }}\\n\",",
            "+            nsc);",
            "+        fprintf(out->fp,",
            "+            \"#define __%ssort_union_vector_field_elements(N, NK, T, t)\\\\\\n\"",
            "+            \"{ T ## _union_vec_t v__tmp = N ## _ ## NK ## _union(t); size_t i__tmp, n__tmp;\\\\\\n\"",
            "+            \"  n__tmp = T ## _union_vec_len(v__tmp); for (i__tmp = 0; i__tmp < n__tmp; ++i__tmp) {\\\\\\n\"",
            "+            \"  T ## _sort(T ## _mutable_union_cast(T ## _union_vec_at(v__tmp, i__tmp))); }}\\n\",",
            "+            nsc);",
            "     } else {",
            "         fprintf(out->fp, \"/* sort disabled */\\n\");",
            "     }",
            "     fprintf(out->fp,",
            "             \"#define __%sdefine_scalar_vector(N, T)\\\\\\n\"",
            "             \"typedef const T *N ## _vec_t;\\\\\\n\"",
            "             \"typedef T *N ## _mutable_vec_t;\\\\\\n\"",
            "@@ -669,27 +792,28 @@",
            "     fprintf(out->fp,",
            "             \"#define __%sdefine_integer_type(N, T, W)\\\\\\n\"",
            "             \"__flatcc_define_integer_accessors(N, T, W, %sendian)\\\\\\n\"",
            "             \"__%sdefine_scalar_vector(N, T)\\n\",",
            "             nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "             \"__%sdefine_scalar_vector(%sbool, %sbool_t)\\n\"",
            "+            \"__%sdefine_scalar_vector(%schar, char)\\n\"",
            "             \"__%sdefine_scalar_vector(%suint8, uint8_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%sint8, int8_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%suint16, uint16_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%sint16, int16_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%suint32, uint32_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%sint32, int32_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%suint64, uint64_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%sint64, int64_t)\\n\"",
            "             \"__%sdefine_scalar_vector(%sfloat, float)\\n\"",
            "             \"__%sdefine_scalar_vector(%sdouble, double)\\n\"",
            "             \"__%sdefine_scalar_vector(%sunion_type, %sunion_type_t)\\n\",",
            "-            nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc,",
            "-            nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "+            nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc,",
            "+            nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "             \"static inline size_t %sstring_vec_find(%sstring_vec_t vec, const char *s)\\n\"",
            "             \"__%sfind_by_string_field(__%sidentity, vec, %sstring_vec_at, %sstring_vec_len, s)\\n\"",
            "             \"static inline size_t %sstring_vec_find_n(%sstring_vec_t vec, const char *s, size_t n)\\n\"",
            "             \"__%sfind_by_string_n_field(__%sidentity, vec, %sstring_vec_at, %sstring_vec_len, s, n)\\n\",",
            "             nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "@@ -714,14 +838,43 @@",
            "             nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc,",
            "             nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc,",
            "             nsc, nsc, nsc, nsc);",
            "     if (out->opts->cgen_sort) {",
            "         fprintf(out->fp, \"__%sdefine_string_sort()\\n\", nsc);",
            "     }",
            "     fprintf(out->fp,",
            "+        \"#define __%sdefine_struct_scalar_fixed_array_field(N, NK, TK, T, L)\\\\\\n\"",
            "+        \"static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp, size_t i__tmp)\\\\\\n\"",
            "+        \"{ if (!t__tmp || i__tmp >= L) return 0;\\\\\\n\"",
            "+        \"  return __%sread_scalar(TK, &(t__tmp->NK[i__tmp])); }\\\\\\n\"",
            "+        \"static inline const T *N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\\\\\\n\"",
            "+        \"{ return t__tmp ? t__tmp->NK : 0; }\\\\\\n\"",
            "+        \"static inline size_t N ## _ ## NK ## _get_len(void) { return L; }\",",
            "+        nsc, nsc);",
            "+    if (!out->opts->cgen_no_conflicts) {",
            "+        fprintf(out->fp,",
            "+            \"\\\\\\nstatic inline T N ## _ ## NK (N ## _struct_t t__tmp, size_t i__tmp)\\\\\\n\"",
            "+            \"{ return N ## _ ## NK ## _get(t__tmp, i__tmp); }\");",
            "+    }",
            "+    fprintf(out->fp, \"\\n\");;",
            "+    fprintf(out->fp,",
            "+        \"#define __%sdefine_struct_struct_fixed_array_field(N, NK, T, L)\\\\\\n\"",
            "+        \"static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp, size_t i__tmp)\\\\\\n\"",
            "+        \"{ if (!t__tmp || i__tmp >= L) return 0; return t__tmp->NK + i__tmp; }\"",
            "+        \"static inline T N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\\\\\\n\"",
            "+        \"{ return t__tmp ? t__tmp->NK : 0; }\\\\\\n\"",
            "+        \"static inline size_t N ## _ ## NK ## _get_len(void) { return L; }\",",
            "+        nsc);",
            "+    if (!out->opts->cgen_no_conflicts) {",
            "+        fprintf(out->fp,",
            "+            \"\\\\\\nstatic inline T N ## _ ## NK(N ## _struct_t t__tmp, size_t i__tmp)\\\\\\n\"",
            "+            \"{ if (!t__tmp || i__tmp >= L) return 0; return t__tmp->NK + i__tmp; }\");",
            "+    }",
            "+    fprintf(out->fp, \"\\n\");",
            "+    fprintf(out->fp,",
            "         \"#define __%sdefine_struct_scalar_field(N, NK, TK, T)\\\\\\n\"",
            "         \"static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp)\\\\\\n\"",
            "         \"{ return t__tmp ? __%sread_scalar(TK, &(t__tmp->NK)) : 0; }\\\\\\n\"",
            "         \"static inline const T *N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\\\\\\n\"",
            "         \"{ return t__tmp ? &(t__tmp->NK) : 0; }\",",
            "         nsc, nsc);",
            "     if (!out->opts->cgen_no_conflicts) {",
            "@@ -776,25 +929,25 @@",
            "     fprintf(out->fp,",
            "             \"#define __%snested_buffer_as_root(C, N, T, K)\\\\\\n\"",
            "             \"static inline T ## _ ## K ## t C ## _ ## N ## _as_root_with_identifier(C ## _ ## table_t t__tmp, const char *fid__tmp)\\\\\\n\"",
            "             \"{ const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __%sread_root(T, K, buffer__tmp, fid__tmp); }\\\\\\n\"",
            "             \"static inline T ## _ ## K ## t C ## _ ## N ## _as_typed_root(C ## _ ## table_t t__tmp)\\\\\\n\"",
            "             \"{ const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __%sread_root(T, K, buffer__tmp, C ## _ ## type_identifier); }\\\\\\n\"",
            "             \"static inline T ## _ ## K ## t C ## _ ## N ## _as_root(C ## _ ## table_t t__tmp)\\\\\\n\"",
            "-            \"{ const char *fid__tmp = T ## _identifier;\\\\\\n\"",
            "+            \"{ const char *fid__tmp = T ## _file_identifier;\\\\\\n\"",
            "             \"  const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __%sread_root(T, K, buffer__tmp, fid__tmp); }\\n\",",
            "             nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp,",
            "             \"#define __%sbuffer_as_root(N, K)\\\\\\n\"",
            "             \"static inline N ## _ ## K ## t N ## _as_root_with_identifier(const void *buffer__tmp, const char *fid__tmp)\\\\\\n\"",
            "             \"{ return __%sread_root(N, K, buffer__tmp, fid__tmp); }\\\\\\n\"",
            "             \"static inline N ## _ ## K ## t N ## _as_root_with_type_hash(const void *buffer__tmp, %sthash_t thash__tmp)\\\\\\n\"",
            "             \"{ return __%sread_typed_root(N, K, buffer__tmp, thash__tmp); }\\\\\\n\"",
            "             \"static inline N ## _ ## K ## t N ## _as_root(const void *buffer__tmp)\\\\\\n\"",
            "-            \"{ const char *fid__tmp = N ## _identifier;\\\\\\n\"",
            "+            \"{ const char *fid__tmp = N ## _file_identifier;\\\\\\n\"",
            "             \"  return __%sread_root(N, K, buffer__tmp, fid__tmp); }\\\\\\n\"",
            "             \"static inline N ## _ ## K ## t N ## _as_typed_root(const void *buffer__tmp)\\\\\\n\"",
            "             \"{ return __%sread_typed_root(N, K, buffer__tmp, N ## _type_hash); }\\n\"",
            "             \"#define __%sstruct_as_root(N) __%sbuffer_as_root(N, struct_)\\n\"",
            "             \"#define __%stable_as_root(N) __%sbuffer_as_root(N, table_)\\n\",",
            "             nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc, nsc);",
            "     fprintf(out->fp, \"\\n\");",
            "@@ -888,20 +1041,19 @@",
            "             \"#define %sidentifier 0\\n\"",
            "             \"#endif\\n\",",
            "             nsc, nsc);",
            "     }",
            "     if (out->S->file_extension.type == vt_string) {",
            "         fprintf(out->fp,",
            "             \"#undef %sextension\\n\"",
            "-            \"#define %sextension \\\".%.*s\\\"\\n\",",
            "+            \"#define %sextension \\\"%.*s\\\"\\n\",",
            "             nsc,",
            "             nsc, out->S->file_extension.s.len, out->S->file_extension.s.s);",
            "     } else {",
            "         fprintf(out->fp,",
            "-            /* Configured extensions include dot, schema does not. */",
            "             \"#ifndef %sextension\\n\"",
            "             \"#define %sextension \\\"%s\\\"\\n\"",
            "             \"#endif\\n\",",
            "             nsc, nsc, out->opts->default_bin_ext);",
            "     }",
            "     fprintf(out->fp, \"\\n\");",
            " }",
            "@@ -920,16 +1072,16 @@",
            "     fb_clear(snt);",
            " ",
            "     assert(ct->symbol.kind == fb_is_struct || ct->symbol.kind == fb_is_table);",
            " ",
            "     fb_compound_name(ct, &snt);",
            "     if (ct->symbol.kind == fb_is_struct) {",
            "         if (ct->size == 0) {",
            "-            fprintf(out->fp, \"typedef void %s_t; /* empty struct */\\n\",",
            "-                    snt.text);",
            "+            gen_panic(out, \"internal error: unexpected empty struct\");",
            "+            return;",
            "         } else {",
            "             fprintf(out->fp, \"typedef struct %s %s_t;\\n\",",
            "                     snt.text, snt.text);",
            "         }",
            "         fprintf(out->fp, \"typedef const %s_t *%s_struct_t;\\n\",",
            "                 snt.text, snt.text);",
            "         fprintf(out->fp, \"typedef %s_t *%s_mutable_struct_t;\\n\",",
            "@@ -937,14 +1089,16 @@",
            "         fprintf(out->fp, \"typedef const %s_t *%s_vec_t;\\n\",",
            "                 snt.text, snt.text);",
            "         fprintf(out->fp, \"typedef %s_t *%s_mutable_vec_t;\\n\",",
            "                 snt.text, snt.text);",
            "     } else {",
            "         fprintf(out->fp, \"typedef const struct %s_table *%s_table_t;\\n\",",
            "                 snt.text, snt.text);",
            "+        fprintf(out->fp, \"typedef struct %s_table *%s_mutable_table_t;\\n\",",
            "+                snt.text, snt.text);",
            "         fprintf(out->fp, \"typedef const %suoffset_t *%s_vec_t;\\n\", nsc, snt.text);",
            "         fprintf(out->fp, \"typedef %suoffset_t *%s_mutable_vec_t;\\n\", nsc, snt.text);",
            "     }",
            " }",
            " ",
            " static inline void print_doc(fb_output_t *out, const char *indent, fb_doc_t *doc)",
            " {",
            "@@ -974,20 +1128,20 @@",
            " static void gen_struct(fb_output_t *out, fb_compound_type_t *ct)",
            " {",
            "     fb_member_t *member;",
            "     fb_symbol_t *sym;",
            "     unsigned align;",
            "     size_t offset = 0;",
            "     const char *tname, *tname_ns, *tname_prefix;",
            "-    int n;",
            "+    int n, len;",
            "     const char *s;",
            "     unsigned pad_index = 0, deprecated_index = 0, pad;",
            "     const char *kind;",
            "     int do_pad = out->opts->cgen_pad;",
            "-    int current_key_processed, already_has_key;",
            "+    int is_primary_key, current_key_processed;",
            "     const char *nsc = out->nsc;",
            " ",
            "     fb_scoped_name_t snt;",
            "     fb_scoped_name_t snref;",
            " ",
            "     fb_clear(snt);",
            "     fb_clear(snref);",
            "@@ -995,34 +1149,15 @@",
            "     assert(ct->symbol.kind == fb_is_struct);",
            "     assert(ct->align > 0 || ct->count == 0);",
            "     assert(ct->size > 0 || ct->count == 0);",
            " ",
            "     fb_compound_name(ct, &snt);",
            "     print_doc(out, \"\", ct->doc);",
            "     if (ct->size == 0) {",
            "-        /*",
            "-         * This implies that sizeof(typename) is not valid, where",
            "-         * non-std gcc extension might return 0, or 1 of an empty",
            "-         * struct. All copy_from/to etc. operations on this type",
            "-         * just returns a pointer without using sizeof.",
            "-         *",
            "-         * We ought to define size as a define so it can be used in a",
            "-         * switch, but that does not mesth with flatcc_accessors.h",
            "-         * macros, so we use an inline function. Users would normally",
            "-         * use sizeof which will break for empty which is ok, and",
            "-         * internal operations can use size() where generic behavior is",
            "-         * required.",
            "-         */",
            "-        fprintf(out->fp, \"/* empty struct already typedef'ed as void since this not permitted in std. C: struct %s {}; */\\n\", snt.text);",
            "-        fprintf(out->fp,",
            "-                \"static inline const %s_t *%s__const_ptr_add(const %s_t *p, size_t i) { return p; }\\n\", snt.text, snt.text, snt.text);",
            "-        fprintf(out->fp,",
            "-                \"static inline %s_t *%s__ptr_add(%s_t *p, size_t i) { return p; }\\n\", snt.text, snt.text, snt.text);",
            "-        fprintf(out->fp,",
            "-                \"static inline %s_struct_t %s_vec_at(%s_vec_t vec, size_t i) { return vec; }\\n\", snt.text, snt.text, snt.text);",
            "+        gen_panic(out, \"internal error: unexpected empty struct\");",
            "     } else {",
            "         if (do_pad) {",
            "             fprintf(out->fp, \"#pragma pack(1)\\n\");",
            "         }",
            "         /*",
            "          * Unfortunately the following is not valid in C11:",
            "          *",
            "@@ -1031,23 +1166,20 @@",
            "          * we can only use alignas on members (unlike C++, and unlike",
            "          * non-portable C compiler variants).",
            "          *",
            "          * By padding the first element to the struct size we get around",
            "          * this problem. It shouldn't strictly be necessary to add padding",
            "          * fields, but compilers might not support padding above 16 bytes,",
            "          * so we do that as a precaution with an optional compiler flag.",
            "-         *",
            "-         * It is unclear how to align empty structs without padding but it",
            "-         * shouldn't really matter since not field is accessed then.",
            "          */",
            "         fprintf(out->fp, \"struct %s {\\n\", snt.text);",
            "-        already_has_key = 0;",
            "         for (sym = ct->members; sym; sym = sym->link) {",
            "             current_key_processed = 0;",
            "             member = (fb_member_t *)sym;",
            "+            is_primary_key = ct->primary_key == member;",
            "             print_doc(out, \"    \", member->doc);",
            "             symbol_name(sym, &n, &s);",
            "             align = offset == 0 ? ct->align : member->align;",
            "             if (do_pad && (pad = (unsigned)(member->offset - offset))) {",
            "                 fprintf(out->fp, \"    uint8_t __padding%u[%u];\\n\",",
            "                         pad_index++, pad);",
            "             }",
            "@@ -1060,162 +1192,210 @@",
            "                     fprintf(out->fp, \"    alignas(%u) uint8_t __deprecated%u[%u]; /* was: '%.*s' */\\n\",",
            "                             align, deprecated_index++, pad, n, s);",
            "                 }",
            "                 offset = (unsigned)(member->offset + member->size);",
            "                 continue;",
            "             }",
            "             switch (member->type.type) {",
            "+            case vt_fixed_array_type:",
            "+                tname_ns = scalar_type_ns(member->type.st, nsc);",
            "+                tname = scalar_type_name(member->type.st);",
            "+                len = (int)member->type.len;",
            "+                if (do_pad) {",
            "+                    fprintf(out->fp, \"    %s%s \", tname_ns, tname);",
            "+                } else {",
            "+                    fprintf(out->fp, \"    alignas(%u) %s%s \", align, tname_ns, tname);",
            "+                }",
            "+                fprintf(out->fp, \"%.*s[%d];\\n\", n, s, len);",
            "+                break;",
            "             case vt_scalar_type:",
            "                 tname_ns = scalar_type_ns(member->type.st, nsc);",
            "                 tname = scalar_type_name(member->type.st);",
            "                 if (do_pad) {",
            "                     fprintf(out->fp, \"    %s%s \", tname_ns, tname);",
            "                 } else {",
            "                     fprintf(out->fp, \"    alignas(%u) %s%s \", align, tname_ns, tname);",
            "                 }",
            "+                fprintf(out->fp, \"%.*s;\\n\", n, s);",
            "+                break;",
            "+            case vt_fixed_array_compound_type_ref:",
            "+                assert(member->type.ct->symbol.kind == fb_is_struct || member->type.ct->symbol.kind == fb_is_enum);",
            "+                kind = member->type.ct->symbol.kind == fb_is_struct ? \"\" : \"enum_\";",
            "+                fb_compound_name(member->type.ct, &snref);",
            "+                len = (int)member->type.len;",
            "+                if (do_pad) {",
            "+                    fprintf(out->fp, \"    %s_%st \", snref.text, kind);",
            "+                } else {",
            "+                    fprintf(out->fp, \"    alignas(%u) %s_%st \", align, snref.text, kind);",
            "+                }",
            "+                fprintf(out->fp, \"%.*s[%d];\\n\", n, s, len);",
            "                 break;",
            "             case vt_compound_type_ref:",
            "                 assert(member->type.ct->symbol.kind == fb_is_struct || member->type.ct->symbol.kind == fb_is_enum);",
            "                 kind = member->type.ct->symbol.kind == fb_is_struct ? \"\" : \"enum_\";",
            "                 fb_compound_name(member->type.ct, &snref);",
            "                 if (do_pad) {",
            "                     fprintf(out->fp, \"    %s_%st \", snref.text, kind);",
            "                 } else {",
            "                     fprintf(out->fp, \"    alignas(%u) %s_%st \", align, snref.text, kind);",
            "                 }",
            "+                fprintf(out->fp, \"%.*s;\\n\", n, s);",
            "                 break;",
            "             default:",
            "                 fprintf(out->fp, \"    %s \", __FLATCC_ERROR_TYPE);",
            "+                fprintf(out->fp, \"%.*s;\\n\", n, s);",
            "                 gen_panic(out, \"internal error: unexpected type during code generation\");",
            "                 break;",
            "             }",
            "-            fprintf(out->fp, \"%.*s;\\n\", n, s);",
            "             offset = (unsigned)(member->offset + member->size);",
            "         }",
            "         if (do_pad && (pad = (unsigned)(ct->size - offset))) {",
            "             fprintf(out->fp, \"    uint8_t __padding%u[%u];\\n\",",
            "                     pad_index, pad);",
            "         }",
            "         fprintf(out->fp, \"};\\n\");",
            "         if (do_pad) {",
            "             fprintf(out->fp, \"#pragma pack()\\n\");",
            "         }",
            "         fprintf(out->fp,",
            "-                \"static_assert(sizeof(%s_t) == %llu, \\\"struct size mismatch\\\");\\n\\n\",",
            "-                snt.text, llu(ct->size));",
            "+                \"static_assert(sizeof(%s_t) == %\"PRIu64\", \\\"struct size mismatch\\\");\\n\\n\",",
            "+                snt.text, (uint64_t)ct->size);",
            "         fprintf(out->fp,",
            "                 \"static inline const %s_t *%s__const_ptr_add(const %s_t *p, size_t i) { return p + i; }\\n\", snt.text, snt.text, snt.text);",
            "         fprintf(out->fp,",
            "                 \"static inline %s_t *%s__ptr_add(%s_t *p, size_t i) { return p + i; }\\n\", snt.text, snt.text, snt.text);",
            "         fprintf(out->fp,",
            "                 \"static inline %s_struct_t %s_vec_at(%s_vec_t vec, size_t i)\\n\"",
            "                 \"__%sstruct_vec_at(vec, i)\\n\",",
            "                 snt.text, snt.text, snt.text,",
            "                 nsc);",
            "     }",
            "-    fprintf(out->fp, \"static inline size_t %s__size() { return %llu; }\\n\",",
            "-            snt.text, llu(ct->size));",
            "+    fprintf(out->fp, \"static inline size_t %s__size(void) { return %\"PRIu64\"; }\\n\",",
            "+            snt.text, (uint64_t)ct->size);",
            "     fprintf(out->fp,",
            "             \"static inline size_t %s_vec_len(%s_vec_t vec)\\n\"",
            "             \"__%svec_len(vec)\\n\",",
            "             snt.text, snt.text, nsc);",
            "     fprintf(out->fp,",
            "             \"__%sstruct_as_root(%s)\\n\",",
            "             nsc, snt.text);",
            "     fprintf(out->fp, \"\\n\");",
            " ",
            "     /* Create accessors which respect endianness and which return 0 on null struct access. */",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "+        is_primary_key = ct->primary_key == member;",
            "         if (member->metadata_flags & fb_f_deprecated) {",
            "             continue;",
            "         }",
            "         symbol_name(&member->symbol, &n, &s);",
            "         switch (member->type.type) {",
            "+        case vt_fixed_array_type:",
            "+            tname_ns = scalar_type_ns(member->type.st, nsc);",
            "+            tname = scalar_type_name(member->type.st);",
            "+            tname_prefix = scalar_type_prefix(member->type.st);",
            "+            fprintf(out->fp,",
            "+                \"__%sdefine_struct_scalar_fixed_array_field(%s, %.*s, %s%s, %s%s, %d)\\n\",",
            "+                nsc, snt.text, n, s, nsc, tname_prefix, tname_ns, tname, member->type.len);",
            "+            /* TODO: if member->type.st == fb_char add string specific methods. */",
            "+            break;",
            "         case vt_scalar_type:",
            "             tname_ns = scalar_type_ns(member->type.st, nsc);",
            "             tname = scalar_type_name(member->type.st);",
            "             tname_prefix = scalar_type_prefix(member->type.st);",
            "             fprintf(out->fp,",
            "                 \"__%sdefine_struct_scalar_field(%s, %.*s, %s%s, %s%s)\\n\",",
            "                 nsc, snt.text, n, s, nsc, tname_prefix, tname_ns, tname);",
            "             if (!out->opts->allow_scan_for_all_fields && (member->metadata_flags & fb_f_key)) {",
            "                 fprintf(out->fp,",
            "                         \"__%sdefine_scan_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "             }",
            "             if (member->metadata_flags & fb_f_key) {",
            "-                if (already_has_key) {",
            "-                    fprintf(out->fp, \"/* Note: this is not the first field with a key on this struct. */\\n\");",
            "+                if (!is_primary_key) {",
            "+                    fprintf(out->fp, \"/* Note: this is not the primary key field on this struct. */\\n\");",
            "                 }",
            "                 fprintf(out->fp,     \"/* Note: find only works on vectors sorted by this field. */\\n\");",
            "                 fprintf(out->fp,",
            "                         \"__%sdefine_find_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                 if (out->opts->cgen_sort) {",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_struct_sort_by_scalar_field(%s, %.*s, %s%s, %s_t)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname, snt.text);",
            "                 }",
            "-                if (!already_has_key) {",
            "+                if (is_primary_key) {",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_default_find_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_default_scan_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                     if (out->opts->cgen_sort) {",
            "                         fprintf(out->fp,",
            "                             \"#define %s_vec_sort %s_vec_sort_by_%.*s\\n\",",
            "                             snt.text, snt.text, n, s);",
            "                     }",
            "-                    already_has_key = 1;",
            "                 }",
            "                 current_key_processed = 1;",
            "             }",
            "             break;",
            "+        case vt_fixed_array_compound_type_ref:",
            "+            fb_compound_name(member->type.ct, &snref);",
            "+            switch (member->type.ct->symbol.kind) {",
            "+            case fb_is_enum:",
            "+                fprintf(out->fp,",
            "+                    \"__%sdefine_struct_scalar_fixed_array_field(%s, %.*s, %s, %s_enum_t, %d)\\n\",",
            "+                    nsc, snt.text, n, s, snref.text, snref.text, member->type.len);",
            "+                break;",
            "+            case fb_is_struct:",
            "+                fprintf(out->fp,",
            "+                    \"__%sdefine_struct_struct_fixed_array_field(%s, %.*s, %s_struct_t, %d)\\n\",",
            "+                    nsc, snt.text, n, s, snref.text, member->type.len);",
            "+                break;",
            "+            }",
            "+            break;",
            "+",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_enum:",
            "-                tname_prefix = scalar_type_prefix(member->type.ct->type.st);",
            "                 fprintf(out->fp,",
            "                     \"__%sdefine_struct_scalar_field(%s, %.*s, %s, %s_enum_t)\\n\",",
            "                     nsc, snt.text, n, s, snref.text, snref.text);",
            "                 if (!out->opts->allow_scan_for_all_fields && (member->metadata_flags & fb_f_key)) {",
            "                     fprintf(out->fp,",
            "                             \"__%sdefine_scan_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text);",
            "                 }",
            "                 if (member->metadata_flags & fb_f_key) {",
            "-                    if (already_has_key) {",
            "-                        fprintf(out->fp, \"/* Note: this is not the first field with a key on this table. */\\n\");",
            "+                    if (!is_primary_key) {",
            "+                        fprintf(out->fp, \"/* Note: this is not the primary key of this table. */\\n\");",
            "                     }",
            "                     fprintf(out->fp,     \"/* Note: find only works on vectors sorted by this field. */\\n\");",
            "                     fprintf(out->fp,",
            "                             \"__%sdefine_find_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text);",
            "                     if (out->opts->cgen_sort) {",
            "                         fprintf(out->fp,",
            "                             \"__%sdefine_struct_sort_by_scalar_field(%s, %.*s, %s_enum_t, %s_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text, snt.text);",
            "                     }",
            "-                    if (!already_has_key) {",
            "+                    if (is_primary_key) {",
            "                         fprintf(out->fp,",
            "                             \"__%sdefine_default_find_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text);",
            "                         fprintf(out->fp,",
            "                             \"__%sdefine_default_scan_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text);",
            "                         if (out->opts->cgen_sort) {",
            "                             fprintf(out->fp,",
            "                                 \"#define %s_vec_sort %s_vec_sort_by_%.*s\\n\",",
            "                                 snt.text, snt.text, n, s);",
            "                         }",
            "-                        already_has_key = 1;",
            "                     }",
            "                     current_key_processed = 1;",
            "                 }",
            "                 break;",
            "             case fb_is_struct:",
            "                 /*",
            "                  * For completeness provide an accessor which returns member pointer",
            "@@ -1231,15 +1411,14 @@",
            "         if ((member->metadata_flags & fb_f_key) && !current_key_processed) {",
            "             fprintf(out->fp,",
            "                 \"/* Note: field has key, but there is no support for find by fields of this type. */\\n\");",
            "             /*",
            "              * If the first key already exists, but was for an unsupported",
            "              * type, we do not map the next possible key to generic find.",
            "              */",
            "-            already_has_key = 1;",
            "         }",
            "     }",
            "     fprintf(out->fp, \"\\n\");",
            " }",
            " ",
            " /*",
            "  * Enums are integers, but we cannot control the size.",
            "@@ -1406,20 +1585,21 @@",
            " ",
            " static void gen_table(fb_output_t *out, fb_compound_type_t *ct)",
            " {",
            "     fb_member_t *member;",
            "     fb_symbol_t *sym;",
            "     const char *s, *tname, *tname_ns, *tname_prefix;",
            "     int n, r;",
            "-    int already_has_key, current_key_processed;",
            "+    int is_primary_key, current_key_processed;",
            "     const char *nsc = out->nsc;",
            "     fb_scoped_name_t snt;",
            "     fb_scoped_name_t snref;",
            "     uint64_t present_id;",
            "     fb_literal_t literal;",
            "+    int is_optional;",
            " ",
            "     assert(ct->symbol.kind == fb_is_table);",
            " ",
            "     fb_clear(snt);",
            "     fb_clear(snref);",
            " ",
            "     fprintf(out->fp, \"\\n\");",
            "@@ -1442,19 +1622,20 @@",
            "             \"__%soffset_vec_at(%s_table_t, vec, i, 0)\\n\",",
            "             snt.text, snt.text, snt.text, nsc, snt.text);",
            "     fprintf(out->fp,",
            "             \"__%stable_as_root(%s)\\n\",",
            "             nsc, snt.text);",
            "     fprintf(out->fp, \"\\n\");",
            " ",
            "-    already_has_key = 0;",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         current_key_processed = 0;",
            "         member = (fb_member_t *)sym;",
            "         present_id = member->id;",
            "+        is_primary_key = ct->primary_key == member;",
            "+        is_optional = !!(member->flags & fb_fm_optional);",
            "         print_doc(out, \"\", member->doc);",
            "         /*",
            "          * In flatc, there can at most one key field, and it should be",
            "          * scalar or string. Here we export all keys using the",
            "          * <table>_vec_find_by_<fieldname> convention and let the parser deal with",
            "          * semantics. Keys on unsupported fields are ignored. The first",
            "          * valid find operation is also mapped to just <table>_vec_find.",
            "@@ -1467,164 +1648,173 @@",
            "         r = (member->metadata_flags & fb_f_required) != 0;",
            "         switch (member->type.type) {",
            "         case vt_scalar_type:",
            "             tname_ns = scalar_type_ns(member->type.st, nsc);",
            "             tname = scalar_type_name(member->type.st);",
            "             tname_prefix = scalar_type_prefix(member->type.st);",
            "             print_literal(member->type.st, &member->value, literal);",
            "-            fprintf(out->fp,",
            "-                \"__%sdefine_scalar_field(%llu, %s, %.*s, %s%s, %s%s, %s)\\n\",",
            "-                nsc, llu(member->id), snt.text, n, s, nsc, tname_prefix, tname_ns, tname, literal);",
            "+            if (is_optional) {",
            "+                fprintf(out->fp,",
            "+                    \"__%sdefine_scalar_optional_field(%\"PRIu64\", %s, %.*s, %s%s, %s%s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, snt.text, n, s, nsc, tname_prefix, tname_ns, tname, literal);",
            "+            } else {",
            "+                fprintf(out->fp,",
            "+                    \"__%sdefine_scalar_field(%\"PRIu64\", %s, %.*s, %s%s, %s%s, %s)\\n\",",
            "+                    nsc, (uint64_t)member->id, snt.text, n, s, nsc, tname_prefix, tname_ns, tname, literal);",
            "+            }",
            "             if (!out->opts->allow_scan_for_all_fields && (member->metadata_flags & fb_f_key)) {",
            "                 fprintf(out->fp,",
            "                         \"__%sdefine_scan_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "             }",
            "             if (member->metadata_flags & fb_f_key) {",
            "-                if (already_has_key) {",
            "-                    fprintf(out->fp, \"/* Note: this is not the first field with a key on this table. */\\n\");",
            "+                if (!is_primary_key) {",
            "+                    fprintf(out->fp, \"/* Note: this is not the primary key of this table. */\\n\");",
            "                 }",
            "                 fprintf(out->fp,     \"/* Note: find only works on vectors sorted by this field. */\\n\");",
            "                 fprintf(out->fp,",
            "                         \"__%sdefine_find_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                 if (out->opts->cgen_sort) {",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_table_sort_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                 }",
            "-                if (!already_has_key) {",
            "+                if (is_primary_key) {",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_default_find_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_default_scan_by_scalar_field(%s, %.*s, %s%s)\\n\",",
            "                         nsc, snt.text, n, s, tname_ns, tname);",
            "                     if (out->opts->cgen_sort) {",
            "                         fprintf(out->fp,",
            "                             \"#define %s_vec_sort %s_vec_sort_by_%.*s\\n\",",
            "                             snt.text, snt.text, n, s);",
            "                     }",
            "-                    already_has_key = 1;",
            "                 }",
            "                 current_key_processed = 1;",
            "             }",
            "             break;",
            "         case vt_vector_type:",
            "             /* They all use a namespace. */",
            "             tname = scalar_vector_type_name(member->type.st);",
            "             tname_ns = nsc;",
            "             fprintf(out->fp,",
            "-                \"__%sdefine_vector_field(%llu, %s, %.*s, %s%s, %u)\\n\",",
            "-                nsc, llu(member->id), snt.text, n, s, tname_ns, tname, r);",
            "+                \"__%sdefine_vector_field(%\"PRIu64\", %s, %.*s, %s%s, %u)\\n\",",
            "+                nsc, (uint64_t)member->id, snt.text, n, s, tname_ns, tname, r);",
            "             if (member->nest) {",
            "                 gen_nested_root(out, &member->nest->symbol, &ct->symbol, &member->symbol);",
            "             }",
            "             break;",
            "         case vt_string_type:",
            "             fprintf(out->fp,",
            "-                \"__%sdefine_string_field(%llu, %s, %.*s, %u)\\n\",",
            "-                nsc, llu(member->id), snt.text, n, s, r);",
            "+                \"__%sdefine_string_field(%\"PRIu64\", %s, %.*s, %u)\\n\",",
            "+                nsc, (uint64_t)member->id, snt.text, n, s, r);",
            "             if (!out->opts->allow_scan_for_all_fields && (member->metadata_flags & fb_f_key)) {",
            "                 fprintf(out->fp,",
            "                     \"__%sdefine_scan_by_string_field(%s, %.*s)\\n\",",
            "                     nsc, snt.text, n, s);",
            "             }",
            "             if (member->metadata_flags & fb_f_key) {",
            "-                if (already_has_key) {",
            "-                    fprintf(out->fp, \"/* Note: this is not the first field with a key on this table. */\\n\");",
            "+                if (!is_primary_key) {",
            "+                    fprintf(out->fp, \"/* Note: this is not the primary key of this table. */\\n\");",
            "                 }",
            "                 fprintf(out->fp,",
            "                     \"__%sdefine_find_by_string_field(%s, %.*s)\\n\",",
            "                     nsc, snt.text, n, s);",
            "                 if (out->opts->cgen_sort) {",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_table_sort_by_string_field(%s, %.*s)\\n\",",
            "                         nsc, snt.text, n, s);",
            "                 }",
            "-                if (!already_has_key) {",
            "+                if (is_primary_key) {",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_default_find_by_string_field(%s, %.*s)\\n\",",
            "                         nsc, snt.text, n, s);",
            "                     fprintf(out->fp,",
            "                         \"__%sdefine_default_scan_by_string_field(%s, %.*s)\\n\",",
            "                         nsc, snt.text, n, s);",
            "                     if (out->opts->cgen_sort) {",
            "                         fprintf(out->fp,",
            "                             \"#define %s_vec_sort %s_vec_sort_by_%.*s\\n\",",
            "                             snt.text, snt.text, n, s);",
            "                     }",
            "-                    already_has_key = 1;",
            "                 }",
            "                 current_key_processed = 1;",
            "             }",
            "             break;",
            "         case vt_vector_string_type:",
            "             fprintf(out->fp,",
            "-                \"__%sdefine_vector_field(%llu, %s, %.*s, %sstring_vec_t, %u)\\n\",",
            "-                nsc, llu(member->id), snt.text, n, s, nsc, r);",
            "+                \"__%sdefine_vector_field(%\"PRIu64\", %s, %.*s, %sstring_vec_t, %u)\\n\",",
            "+                nsc, (uint64_t)member->id, snt.text, n, s, nsc, r);",
            "             break;",
            "         case vt_compound_type_ref:",
            "             fb_compound_name(member->type.ct, &snref);",
            "             switch (member->type.ct->symbol.kind) {",
            "             case fb_is_struct:",
            "                 fprintf(out->fp,",
            "-                    \"__%sdefine_struct_field(%llu, %s, %.*s, %s_struct_t, %u)\\n\",",
            "-                    nsc, llu(member->id), snt.text, n, s, snref.text, r);",
            "+                    \"__%sdefine_struct_field(%\"PRIu64\", %s, %.*s, %s_struct_t, %u)\\n\",",
            "+                    nsc, (uint64_t)member->id, snt.text, n, s, snref.text, r);",
            "                 break;",
            "             case fb_is_table:",
            "                 fprintf(out->fp,",
            "-                    \"__%sdefine_table_field(%llu, %s, %.*s, %s_table_t, %u)\\n\",",
            "-                    nsc, llu(member->id), snt.text, n, s, snref.text, r);",
            "+                    \"__%sdefine_table_field(%\"PRIu64\", %s, %.*s, %s_table_t, %u)\\n\",",
            "+                    nsc, (uint64_t)member->id, snt.text, n, s, snref.text, r);",
            "                 break;",
            "             case fb_is_enum:",
            "                 print_literal(member->type.ct->type.st, &member->value, literal);",
            "-                fprintf(out->fp,",
            "-                    \"__%sdefine_scalar_field(%llu, %s, %.*s, %s, %s_enum_t, %s)\\n\",",
            "-                    nsc, llu(member->id), snt.text, n, s, snref.text, snref.text, literal);",
            "+                if (is_optional) {",
            "+                    fprintf(out->fp,",
            "+                        \"__%sdefine_scalar_optional_field(%\"PRIu64\", %s, %.*s, %s, %s_enum_t, %s)\\n\",",
            "+                        nsc, (uint64_t)member->id, snt.text, n, s, snref.text, snref.text, literal);",
            "+                } else {",
            "+                    fprintf(out->fp,",
            "+                        \"__%sdefine_scalar_field(%\"PRIu64\", %s, %.*s, %s, %s_enum_t, %s)\\n\",",
            "+                        nsc, (uint64_t)member->id, snt.text, n, s, snref.text, snref.text, literal);",
            "+                }",
            "                 if (!out->opts->allow_scan_for_all_fields && (member->metadata_flags & fb_f_key)) {",
            "                     fprintf(out->fp,",
            "                             \"__%sdefine_scan_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text);",
            "                 }",
            "                 if (member->metadata_flags & fb_f_key) {",
            "-                    if (already_has_key) {",
            "-                        fprintf(out->fp, \"/* Note: this is not the first field with a key on this table. */\\n\");",
            "+                    if (!is_primary_key) {",
            "+                        fprintf(out->fp, \"/* Note: this is not the primary key of this table. */\\n\");",
            "                     }",
            "                     fprintf(out->fp,     \"/* Note: find only works on vectors sorted by this field. */\\n\");",
            "                     fprintf(out->fp,",
            "                             \"__%sdefine_find_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                             nsc, snt.text, n, s, snref.text);",
            "                     if (out->opts->cgen_sort) {",
            "                         fprintf(out->fp,",
            "                                 \"__%sdefine_table_sort_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                                 nsc, snt.text, n, s, snref.text);",
            "                     }",
            "-                    if (!already_has_key) {",
            "+                    if (is_primary_key) {",
            "                         fprintf(out->fp,",
            "                                 \"__%sdefine_default_find_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                                 nsc, snt.text, n, s, snref.text);",
            "                         fprintf(out->fp,",
            "                                 \"__%sdefine_default_scan_by_scalar_field(%s, %.*s, %s_enum_t)\\n\",",
            "                                 nsc, snt.text, n, s, snref.text);",
            "                         if (out->opts->cgen_sort) {",
            "                             fprintf(out->fp,",
            "                                     \"#define %s_vec_sort %s_vec_sort_by_%.*s\\n\",",
            "                                     snt.text, snt.text, n, s);",
            "                         }",
            "-                        already_has_key = 1;",
            "                     }",
            "                     current_key_processed = 1;",
            "                 }",
            "                 break;",
            "             case fb_is_union:",
            "                 present_id--;",
            "                 fprintf(out->fp,",
            "-                    \"__%sdefine_union_field(%s, %llu, %s, %.*s, %s, %u)\\n\",",
            "-                    nsc, nsc, llu(member->id), snt.text, n, s, snref.text, r);",
            "+                    \"__%sdefine_union_field(%s, %\"PRIu64\", %s, %.*s, %s, %u)\\n\",",
            "+                    nsc, nsc, (uint64_t)member->id, snt.text, n, s, snref.text, r);",
            "                 break;",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected compound type in table during code generation\");",
            "                 break;",
            "             }",
            "             break;",
            "         case vt_vector_compound_type_ref:",
            "@@ -1641,34 +1831,33 @@",
            "             default:",
            "                 gen_panic(out, \"internal error: unexpected vector compound type in table during code generation\");",
            "                 break;",
            "             }",
            "             if (member->type.ct->symbol.kind == fb_is_union) {",
            "                 present_id--;",
            "                 fprintf(out->fp,",
            "-                    \"__%sdefine_union_vector_field(%s, %llu, %s, %.*s, %s, %u)\\n\",",
            "-                    nsc, nsc, llu(member->id), snt.text, n, s, snref.text, r);",
            "+                    \"__%sdefine_union_vector_field(%s, %\"PRIu64\", %s, %.*s, %s, %u)\\n\",",
            "+                    nsc, nsc, (uint64_t)member->id, snt.text, n, s, snref.text, r);",
            "             } else {",
            "                 fprintf(out->fp,",
            "-                    \"__%sdefine_vector_field(%llu, %s, %.*s, %s_vec_t, %u)\\n\",",
            "-                    nsc, llu(member->id), snt.text, n, s, snref.text, r);",
            "+                    \"__%sdefine_vector_field(%\"PRIu64\", %s, %.*s, %s_vec_t, %u)\\n\",",
            "+                    nsc, (uint64_t)member->id, snt.text, n, s, snref.text, r);",
            "             }",
            "             break;",
            "         default:",
            "             gen_panic(out, \"internal error: unexpected table member type during code generation\");",
            "             break;",
            "         }",
            "         if ((member->metadata_flags & fb_f_key) && !current_key_processed) {",
            "             fprintf(out->fp,",
            "                 \"/* Note: field has key, but there is no support for find by fields of this type. */\\n\");",
            "             /*",
            "              * If the first key already exists, but was for an unsupported",
            "              * type, we do not map the next possible key to generic find.",
            "              */",
            "-            already_has_key = 1;",
            "         }",
            "     }",
            " }",
            " ",
            " int fb_gen_c_reader(fb_output_t *out)",
            " {",
            "     fb_symbol_t *sym;",
            "@@ -1690,14 +1879,15 @@",
            "     /* Must be placed early due to nested buffer circular references. */",
            "     for (sym = out->S->symbols; sym; sym = sym->link) {",
            "         switch (sym->kind) {",
            "         case fb_is_struct:",
            "             /* Fall through. */",
            "         case fb_is_table:",
            "             print_type_identifier(out, (fb_compound_type_t *)sym);",
            "+            print_file_extension(out, (fb_compound_type_t *)sym);",
            "             break;",
            "         }",
            "     }",
            "     fprintf(out->fp, \"\\n\");",
            "     for (sym = out->S->symbols; sym; sym = sym->link) {",
            "         switch (sym->kind) {",
            "          /* Enums must come before structs in case they are referenced. */",
            "@@ -1728,10 +1918,15 @@",
            "             break;",
            "         default:",
            "             gen_panic(out, \"internal error: unexpected schema component\");",
            "             break;",
            "         }",
            "     }",
            "     fprintf(out->fp, \"\\n\");",
            "+",
            "+    if (out->opts->cgen_sort) {",
            "+        fb_gen_c_sorter(out);",
            "+    }",
            "+",
            "     gen_footer(out);",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/codegen_schema.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/codegen_schema.c",
            "+++ /home/flatcc-0.6.1/src/compiler/codegen_schema.c",
            "@@ -6,21 +6,31 @@",
            " #include \"codegen.h\"",
            " #include \"fileio.h\"",
            " /* Needed to store length prefix. */",
            " #include \"catalog.h\"",
            " ",
            " #define BaseType(x) FLATBUFFERS_WRAP_NAMESPACE(reflection_BaseType, x)",
            " ",
            "+static flatbuffers_bool_t is_optional_type(fb_value_t type, int optional, int required)",
            "+{",
            "+    if (required) return 0;",
            "+    if (optional) return 1;",
            "+    if (type.type == vt_scalar_type) return 0;",
            "+    if (type.type == vt_compound_type_ref && type.ct->symbol.kind == fb_is_enum) return 0;",
            "+    return 1;",
            "+}",
            "+",
            " static reflection_Type_ref_t export_type(flatcc_builder_t *B, fb_value_t type)",
            " {",
            "     fb_scalar_type_t st = fb_missing_type;",
            "     int32_t index = -1;",
            "     reflection_BaseType_enum_t base_type = BaseType(None);",
            "     reflection_BaseType_enum_t element = BaseType(None);",
            "     reflection_BaseType_enum_t primitive = BaseType(None);",
            "+    uint16_t fixed_length = 0;",
            " ",
            "     switch (type.type) {",
            "     case vt_scalar_type:",
            "         st = type.st;",
            "         break;",
            "     case vt_vector_type:",
            "         st = type.st;",
            "@@ -67,14 +77,44 @@",
            "             base_type = BaseType(Union);",
            "             break;",
            "         default:",
            "             index = -1;",
            "             break;",
            "         }",
            "         break;",
            "+    case vt_fixed_array_type:",
            "+        st = type.st;",
            "+        base_type = BaseType(Array);",
            "+        fixed_length = (uint16_t)type.len;",
            "+        break;",
            "+    case vt_fixed_array_string_type:",
            "+        break;",
            "+        element = BaseType(Byte);",
            "+        base_type = BaseType(Array);",
            "+        fixed_length = (uint16_t)type.len;",
            "+        break;",
            "+    case vt_fixed_array_compound_type_ref:",
            "+        index = (int32_t)type.ct->export_index;",
            "+        switch (type.ct->symbol.kind) {",
            "+        case fb_is_enum:",
            "+            st = type.ct->type.st;",
            "+            break;",
            "+        case fb_is_struct:",
            "+        case fb_is_table:",
            "+            element = BaseType(Obj);",
            "+            break;",
            "+        case fb_is_union:",
            "+            element = BaseType(Union);",
            "+            break;",
            "+        default:",
            "+            break;",
            "+        }",
            "+        base_type = BaseType(Array);",
            "+        fixed_length = (uint16_t)type.len;",
            "+        break;",
            "     default:",
            "         break;",
            "     }",
            "     /* If st is set, resolve scalar type and set it to base_type or element. */",
            "     switch (st) {",
            "     case fb_missing_type: break;",
            "     case fb_ulong: primitive = BaseType(ULong); break;",
            "@@ -84,44 +124,46 @@",
            "     case fb_bool: primitive = BaseType(Bool); break;",
            "     case fb_long: primitive = BaseType(Long); break;",
            "     case fb_int: primitive = BaseType(Int); break;",
            "     case fb_short: primitive = BaseType(Short); break;",
            "     case fb_byte: primitive = BaseType(Byte); break;",
            "     case fb_double: primitive = BaseType(Double); break;",
            "     case fb_float: primitive = BaseType(Float); break;",
            "+    /* TODO: Googles flatc tool does not have char arrays so we use Byte as element type */",
            "+    case fb_char: primitive = BaseType(Byte); break;",
            "     default: break;",
            "     }",
            " ",
            "     if (base_type == BaseType(None)) {",
            "         base_type = primitive;",
            "-    } else if (base_type == BaseType(Vector)) {",
            "+    } else if (base_type == BaseType(Vector) || base_type == BaseType(Array)) {",
            "         if (element == BaseType(None)) {",
            "             element = primitive;",
            "         }",
            "     }",
            "-    return reflection_Type_create(B, base_type, element, index);",
            "+    return reflection_Type_create(B, base_type, element, index, fixed_length);",
            " }",
            " ",
            " static void export_attributes(flatcc_builder_t *B, fb_metadata_t *m)",
            " {",
            "     for (; m; m = m->link) {",
            "         reflection_KeyValue_vec_push_start(B);",
            "-        reflection_KeyValue_key_create_strn(B, m->ident->text, m->ident->len);",
            "+        reflection_KeyValue_key_create_strn(B, m->ident->text, (size_t)m->ident->len);",
            "         if (m->value.type == vt_string) {",
            "-            reflection_KeyValue_value_create_strn(B, m->value.s.s, m->value.s.len);",
            "+            reflection_KeyValue_value_create_strn(B, m->value.s.s, (size_t)m->value.s.len);",
            "         }",
            "         reflection_KeyValue_vec_push_end(B);",
            "     }",
            " }",
            " ",
            " static void export_fields(flatcc_builder_t *B, fb_compound_type_t *ct)",
            " {",
            "     fb_symbol_t *sym;",
            "     fb_member_t *member;",
            "-    flatbuffers_bool_t has_key, deprecated, required, key_processed = 0;",
            "+    flatbuffers_bool_t has_key, deprecated, required, optional, key_processed = 0;",
            "     int64_t default_integer;",
            "     double default_real;",
            " ",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         member = (fb_member_t *)sym;",
            "         /*",
            "          * Unlike `flatc` we allow multiple keys in the parser, but",
            "@@ -130,37 +172,43 @@",
            "          * export the default (first) key.",
            "          */",
            "         has_key = !key_processed && (member->metadata_flags & fb_f_key) != 0;",
            "         required = (member->metadata_flags & fb_f_required) != 0;",
            "         default_integer = 0;",
            "         default_real = 0.0;",
            "         deprecated = (member->metadata_flags & fb_f_deprecated) != 0;",
            "+        /*",
            "+         * Flag is only set when `= null` is used in the schema, but",
            "+         * non-scalar types are optional by default and therfore also",
            "+         * true in the binary schema.",
            "+         */",
            "+        optional = is_optional_type(member->type, !!(member->flags & fb_fm_optional), required);",
            " ",
            "         if ((member->type.type == vt_compound_type_ref || member->type.type == vt_vector_compound_type_ref)",
            "                 && member->type.ct->symbol.kind == fb_is_union) {",
            "             reflection_Field_vec_push_start(B);",
            "             reflection_Field_name_start(B);",
            "-            reflection_Field_name_append(B, member->symbol.ident->text, member->symbol.ident->len);",
            "+            reflection_Field_name_append(B, member->symbol.ident->text, (size_t)member->symbol.ident->len);",
            "             reflection_Field_name_append(B, \"_type\", 5);",
            "             reflection_Field_name_end(B);",
            "             switch(member->type.type) {",
            "             case vt_compound_type_ref:",
            "-                reflection_Field_type_create(B, BaseType(UType), BaseType(None), -1);",
            "+                reflection_Field_type_create(B, BaseType(UType), BaseType(None), -1, 0);",
            "                 break;",
            "             case vt_vector_compound_type_ref:",
            "-                reflection_Field_type_create(B, BaseType(Vector), BaseType(UType), -1);",
            "+                reflection_Field_type_create(B, BaseType(Vector), BaseType(UType), -1, 0);",
            "                 break;",
            "             }",
            "             reflection_Field_offset_add(B, (uint16_t)(member->id - 1 + 2) * sizeof(flatbuffers_voffset_t));",
            "             reflection_Field_id_add(B, (uint16_t)(member->id - 1));",
            "             reflection_Field_deprecated_add(B, deprecated);",
            "             reflection_Field_vec_push_end(B);",
            "         }",
            "         reflection_Field_vec_push_start(B);",
            "-        reflection_Field_name_create(B, member->symbol.ident->text, member->symbol.ident->len);",
            "+        reflection_Field_name_create(B, member->symbol.ident->text, (size_t)member->symbol.ident->len);",
            "         reflection_Field_type_add(B, export_type(B, member->type));",
            "         switch (ct->symbol.kind) {",
            "         case fb_is_table:",
            "             switch (member->value.type) {",
            "             case vt_uint:",
            "                 default_integer = (int64_t)member->value.u;",
            "                 break;",
            "@@ -176,14 +224,15 @@",
            "             }",
            "             reflection_Field_default_integer_add(B, default_integer);",
            "             reflection_Field_default_real_add(B, default_real);",
            "             reflection_Field_id_add(B, (uint16_t)member->id);",
            "             reflection_Field_offset_add(B, (uint16_t)(member->id + 2) * sizeof(flatbuffers_voffset_t));",
            "             reflection_Field_key_add(B, has_key);",
            "             reflection_Field_required_add(B, required);",
            "+            reflection_Field_optional_add(B, optional);",
            "             break;",
            "         case fb_is_struct:",
            "             reflection_Field_offset_add(B, (uint16_t)member->offset);",
            "             break;",
            "         default: break;",
            "         }",
            "         /* Deprecated struct fields not supported by `flatc` but is here as an option. */",
            "@@ -214,42 +263,42 @@",
            "          * objects and enums.",
            "          */",
            "         reflection_Object_fields_start(B);",
            "         export_fields(B, ct);",
            "         reflection_Object_fields_end(B);",
            "         is_struct = ct->symbol.kind == fb_is_struct;",
            "         if (is_struct) {",
            "-            reflection_Object_bytesize_add(B, (uint32_t)ct->size);",
            "+            reflection_Object_bytesize_add(B, (int32_t)ct->size);",
            "         }",
            "-        reflection_Object_is_struct_add(B, is_struct);",
            "+        reflection_Object_is_struct_add(B, (flatbuffers_bool_t)is_struct);",
            "         reflection_Object_minalign_add(B, ct->align);",
            "         if (ct->metadata) {",
            "             reflection_Object_attributes_start(B);",
            "             export_attributes(B, ct->metadata);",
            "             reflection_Object_attributes_end(B);",
            "         }",
            "         object_map[i] = reflection_Object_end(B);",
            "     }",
            "-    reflection_Schema_objects_create(B, object_map, nobjects);",
            "+    reflection_Schema_objects_create(B, object_map, (size_t)nobjects);",
            " }",
            " ",
            " static void export_enumval(flatcc_builder_t *B, fb_member_t *member, reflection_Object_ref_t *object_map)",
            " {",
            "     int is_union = object_map != 0;",
            " ",
            "     reflection_EnumVal_vec_push_start(B);",
            "-    reflection_EnumVal_name_create(B, member->symbol.ident->text, member->symbol.ident->len);",
            "+    reflection_EnumVal_name_create(B, member->symbol.ident->text, (size_t)member->symbol.ident->len);",
            "     if (is_union) {",
            "         if (member->type.type == vt_compound_type_ref) {",
            "             /* object is deprecated in favor of union_type to support mixed union types. */",
            "             reflection_EnumVal_object_add(B, object_map[member->type.ct->export_index]);",
            "         }",
            "         reflection_EnumVal_union_type_add(B, export_type(B, member->type));",
            "     }",
            "-    reflection_EnumVal_value_add(B, member->value.u);",
            "+    reflection_EnumVal_value_add(B, (int64_t)member->value.u);",
            "     reflection_EnumVal_vec_push_end(B);",
            " }",
            " ",
            " static void export_enums(flatcc_builder_t *B, enum_entry_t *enums, int nenums,",
            "         reflection_Object_ref_t *object_map)",
            " {",
            "     int i, is_union;",
            "@@ -263,15 +312,15 @@",
            "         reflection_Enum_vec_push_start(B);",
            "         reflection_Enum_name_create_str(B, enums[i].name);",
            "         reflection_Enum_values_start(B);",
            "         for (sym = ct->members; sym; sym = sym->link) {",
            "             export_enumval(B, (fb_member_t *)sym, is_union ? object_map : 0);",
            "         }",
            "         reflection_Enum_values_end(B);",
            "-        reflection_Enum_is_union_add(B, is_union);",
            "+        reflection_Enum_is_union_add(B, (flatbuffers_bool_t)is_union);",
            "         reflection_Enum_underlying_type_add(B, export_type(B, ct->type));",
            "         if (ct->metadata) {",
            "             reflection_Enum_attributes_start(B);",
            "             export_attributes(B, ct->metadata);",
            "             reflection_Enum_attributes_end(B);",
            "         }",
            "         reflection_Enum_vec_push_end(B);",
            "@@ -292,46 +341,88 @@",
            "         if (root_type->kind == fb_is_table) {",
            "             ct = (fb_compound_type_t *)root_type;",
            "             reflection_Schema_root_table_add(B, object_map[ct->export_index]);",
            "         }",
            "     }",
            " }",
            " ",
            "+static void export_call(flatcc_builder_t *B, fb_member_t *member, reflection_Object_ref_t *object_map)",
            "+{",
            "+    reflection_RPCCall_vec_push_start(B);",
            "+    reflection_RPCCall_name_create(B, member->symbol.ident->text, (size_t)member->symbol.ident->len);",
            "+    reflection_RPCCall_request_add(B, object_map[member->req_type.ct->export_index]);",
            "+    reflection_RPCCall_response_add(B, object_map[member->type.ct->export_index]);",
            "+    if (member->metadata) {",
            "+        reflection_RPCCall_attributes_start(B);",
            "+        export_attributes(B, member->metadata);",
            "+        reflection_RPCCall_attributes_end(B);",
            "+    }",
            "+    reflection_RPCCall_vec_push_end(B);",
            "+}",
            "+",
            "+static void export_services(flatcc_builder_t *B, service_entry_t *services, int nservices,",
            "+        reflection_Object_ref_t *object_map)",
            "+{",
            "+    int i;",
            "+    fb_compound_type_t *ct;",
            "+    fb_symbol_t *sym;",
            "+",
            "+    reflection_Schema_services_start(B);",
            "+    for (i = 0; i < nservices; ++i) {",
            "+        ct = services[i].ct;",
            "+        reflection_Service_vec_push_start(B);",
            "+        reflection_Service_name_create_str(B, services[i].name);",
            "+        reflection_Service_calls_start(B);",
            "+        for (sym = ct->members; sym; sym = sym->link) {",
            "+            export_call(B, (fb_member_t *)sym, object_map);",
            "+        }",
            "+        reflection_Service_calls_end(B);",
            "+        if (ct->metadata) {",
            "+            reflection_Service_attributes_start(B);",
            "+            export_attributes(B, ct->metadata);",
            "+            reflection_Service_attributes_end(B);",
            "+        }",
            "+        reflection_Service_vec_push_end(B);",
            "+    }",
            "+    reflection_Schema_services_end(B);",
            "+}",
            "+",
            " static int export_schema(flatcc_builder_t *B, fb_options_t *opts, fb_schema_t *S)",
            " {",
            "     catalog_t catalog;",
            "     reflection_Object_ref_t *object_map = 0;",
            " ",
            "     if (build_catalog(&catalog, S, opts->bgen_qualify_names, &S->root_schema->scope_index)) {",
            "         return -1;",
            "     }",
            " ",
            "-    if (catalog.nobjects > 0 && !(object_map = malloc(catalog.nobjects * sizeof(object_map[0])))) {",
            "+    if (catalog.nobjects > 0 && !(object_map = malloc((size_t)catalog.nobjects * sizeof(object_map[0])))) {",
            "         clear_catalog(&catalog);",
            "         return -1;",
            "     }",
            " ",
            "     /* Build the schema. */",
            " ",
            "     if (opts->bgen_length_prefix) {",
            "         reflection_Schema_start_as_root_with_size(B);",
            "     } else {",
            "         reflection_Schema_start_as_root(B);",
            "     }",
            "     if (S->file_identifier.type == vt_string) {",
            "         reflection_Schema_file_ident_create(B,",
            "-                S->file_identifier.s.s, S->file_identifier.s.len);",
            "+                S->file_identifier.s.s, (size_t)S->file_identifier.s.len);",
            "     }",
            "     if (S->file_extension.type == vt_string) {",
            "         reflection_Schema_file_ext_create(B,",
            "-                S->file_extension.s.s, S->file_extension.s.len);",
            "+                S->file_extension.s.s, (size_t)S->file_extension.s.len);",
            "     }",
            "     export_objects(B, catalog.objects, catalog.nobjects, object_map);",
            "     export_enums(B, catalog.enums, catalog.nenums, object_map);",
            "     export_root_type(B, S->root_type.type, object_map);",
            "+    export_services(B, catalog.services, catalog.nservices, object_map);",
            " ",
            "     reflection_Schema_end_as_root(B);",
            " ",
            "     /* Clean up support datastructures. */",
            " ",
            "     clear_catalog(&catalog);",
            "     if (object_map) {",
            "@@ -370,35 +461,34 @@",
            "         }",
            "     }",
            " }",
            " ",
            " static FILE *open_file(fb_options_t *opts, fb_schema_t *S)",
            " {",
            "     FILE *fp = 0;",
            "-    char *path;",
            "+    char *path = 0, *ext = 0;",
            "     const char *prefix = opts->outpath ? opts->outpath : \"\";",
            "     size_t len, prefix_len = strlen(prefix);",
            "     const char *name;",
            "-    const char *ext;",
            " ",
            "     name = S->basename;",
            "     len = strlen(name);",
            " ",
            "-    ext = flatbuffers_extension;",
            "-",
            "+    ext = fb_create_path_ext(\".\", flatbuffers_extension);",
            "     /* We generally should not use cgen options here, but in this case it makes sense. */",
            "     if (opts->gen_stdout) {",
            "         return stdout;",
            "     }",
            "     checkmem((path = fb_create_join_path_n(prefix, prefix_len, name, len, ext, 1)));",
            "     fp = fopen(path, \"wb\");",
            "     if (!fp) {",
            "         fprintf(stderr, \"error opening file for writing binary schema: %s\\n\", path);",
            "     }",
            "     free(path);",
            "+    free(ext);",
            "     return fp;",
            " }",
            " ",
            " static void close_file(FILE *fp)",
            " {",
            "     if (fp && fp != stdout) {",
            "         fclose(fp);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/coerce.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/coerce.c",
            "+++ /home/flatcc-0.6.1/src/compiler/coerce.c",
            "@@ -79,14 +79,16 @@",
            "         }",
            "         if (value->u > UINT16_MAX) {",
            "             error_sym(P, sym, \"16-bit unsigned short overflow\");",
            "             value->type = vt_invalid;",
            "             return -1;",
            "         }",
            "         return 0;",
            "+    case fb_char:",
            "+        /* Although C treats char as signed by default, flatcc treats it as unsigned. */",
            "     case fb_ubyte:",
            "         if (value->type != vt_uint) {",
            "             error_sym(P, sym, \"8-bit unsigned byte type only accepts unsigned integers\");",
            "             value->type = vt_invalid;",
            "             return -1;",
            "         }",
            "         if (value->u > UINT8_MAX) {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/coerce.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/coerce.h",
            "+++ /home/flatcc-0.6.1/src/compiler/coerce.h",
            "@@ -6,17 +6,8 @@",
            " #include \"symbols.h\"",
            " #include \"parser.h\"",
            " ",
            " int __flatcc_fb_coerce_scalar_type(fb_parser_t *P,",
            "         fb_symbol_t *sym, fb_scalar_type_t st, fb_value_t *value);",
            " #define fb_coerce_scalar_type __flatcc_fb_coerce_scalar_type",
            " ",
            "-static inline size_t sizeof_scalar_type(fb_scalar_type_t st)",
            "-{",
            "-    static const int scalar_type_size[] = {",
            "-        0, 8, 4, 2, 1, 1, 8, 4, 2, 1, 8, 4",
            "-    };",
            "-",
            "-    return scalar_type_size[st];",
            "-}",
            "-",
            " #endif /* COERCE_H */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/fileio.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/fileio.c",
            "+++ /home/flatcc-0.6.1/src/compiler/fileio.c",
            "@@ -53,21 +53,23 @@",
            "             (suffix_len > 1 && suffix[1] == ':')) {",
            "         prefix_len = 0;",
            "     }",
            "     if (path_sep && (prefix_len == 0 ||",
            "             (prefix[prefix_len - 1] == '/' || prefix[prefix_len - 1] == '\\\\'))) {",
            "         path_sep = 0;",
            "     }",
            "-    path = malloc(prefix_len + path_sep + suffix_len + ext_len + 1);",
            "+    path = malloc(prefix_len + !!path_sep + suffix_len + ext_len + 1);",
            "     if (!path) {",
            "         return 0;",
            "     }",
            "     n = 0;",
            "-    memcpy(path, prefix, prefix_len);",
            "-    n += prefix_len;",
            "+    if (prefix_len > 0) {",
            "+        memcpy(path, prefix, prefix_len);",
            "+        n += prefix_len;",
            "+    }",
            "     if (path_sep) {",
            "         path[n++] = '/';",
            "     }",
            "     memcpy(path + n, suffix, suffix_len);",
            "     n += suffix_len;",
            "     memcpy(path + n, ext, ext_len);",
            "     n += ext_len;",
            "@@ -148,15 +150,15 @@",
            "     while(p != path) {",
            "         --p;",
            "         if (*p == '/' || *p == '\\\\') {",
            "             ++p;",
            "             break;",
            "         }",
            "     }",
            "-    return p - path;",
            "+    return (size_t)(p - path);",
            " }",
            " ",
            " char *fb_create_basename(const char *path, size_t len, const char *ext)",
            " {",
            "     size_t pos;",
            "     char *s;",
            " ",
            "@@ -170,28 +172,31 @@",
            "     }",
            "     return s;",
            " }",
            " ",
            " char *fb_read_file(const char *filename, size_t max_size, size_t *size_out)",
            " {",
            "     FILE *fp;",
            "+    long k;",
            "     size_t size, pos, n, _out;",
            "     char *buf;",
            " ",
            "     size_out = size_out ? size_out : &_out;",
            " ",
            "     fp = fopen(filename, \"rb\");",
            "     size = 0;",
            "     buf = 0;",
            " ",
            "     if (!fp) {",
            "         goto fail;",
            "     }",
            "     fseek(fp, 0L, SEEK_END);",
            "-    size = ftell(fp);",
            "+    k = ftell(fp);",
            "+    if (k < 0) goto fail;",
            "+    size = (size_t)k;",
            "     *size_out = size;",
            "     if (max_size > 0 && size > max_size) {",
            "         goto fail;",
            "     }",
            "     rewind(fp);",
            "     buf = malloc(size ? size : 1);",
            "     if (!buf) {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/flatcc.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/flatcc.c",
            "+++ /home/flatcc-0.6.1/src/compiler/flatcc.c",
            "@@ -15,14 +15,15 @@",
            "     opts->max_schema_size = FLATCC_MAX_SCHEMA_SIZE;",
            "     opts->max_include_depth = FLATCC_MAX_INCLUDE_DEPTH;",
            "     opts->max_include_count = FLATCC_MAX_INCLUDE_COUNT;",
            "     opts->allow_boolean_conversion = FLATCC_ALLOW_BOOLEAN_CONVERSION;",
            "     opts->allow_enum_key = FLATCC_ALLOW_ENUM_KEY;",
            "     opts->allow_enum_struct_field = FLATCC_ALLOW_ENUM_STRUCT_FIELD;",
            "     opts->allow_multiple_key_fields = FLATCC_ALLOW_MULTIPLE_KEY_FIELDS;",
            "+    opts->allow_primary_key = FLATCC_ALLOW_PRIMARY_KEY;",
            "     opts->allow_scan_for_all_fields = FLATCC_ALLOW_SCAN_FOR_ALL_FIELDS;",
            "     opts->allow_string_key = FLATCC_ALLOW_STRING_KEY;",
            "     opts->allow_struct_field_deprecate = FLATCC_ALLOW_STRUCT_FIELD_DEPRECATE;",
            "     opts->allow_struct_field_key = FLATCC_ALLOW_STRUCT_FIELD_KEY;",
            "     opts->allow_struct_root = FLATCC_ALLOW_STRUCT_ROOT;",
            "     opts->ascending_enum = FLATCC_ASCENDING_ENUM;",
            "     opts->hide_later_enum = FLATCC_HIDE_LATER_ENUM;",
            "@@ -340,15 +341,14 @@",
            "      * included files (`referer_path` set), first try include paths",
            "      * in order, then path relative to including file.",
            "      */",
            "     if (is_root) {",
            "         if (!(buf = fb_read_file(filename, P->opts.max_schema_size, &size))) {",
            "             if (size + P->schema.root_schema->total_source_size > P->opts.max_schema_size && P->opts.max_schema_size > 0) {",
            "                 fb_print_error(P, \"input exceeds maximum allowed size\\n\");",
            "-                ret = -1;",
            "                 goto done;",
            "             }",
            "         } else {",
            "             checkmem((path = fb_copy_path(filename)));",
            "         }",
            "     }",
            "     for (i = 0; !buf && i < P->opts.inpath_count; ++i) {",
            "@@ -356,29 +356,27 @@",
            "         inpath_len = strlen(inpath);",
            "         checkmem((path = fb_create_join_path_n(inpath, inpath_len, filename, filename_len, \"\", 1)));",
            "         if (!(buf = fb_read_file(path, P->opts.max_schema_size, &size))) {",
            "             free(path);",
            "             path = 0;",
            "             if (size > P->opts.max_schema_size && P->opts.max_schema_size > 0) {",
            "                 fb_print_error(P, \"input exceeds maximum allowed size\\n\");",
            "-                ret = -1;",
            "                 goto done;",
            "             }",
            "         }",
            "     }",
            "     if (!buf && !is_root) {",
            "         inpath = P->referer_path;",
            "         inpath_len = fb_find_basename(inpath, strlen(inpath));",
            "         checkmem((path = fb_create_join_path_n(inpath, inpath_len, filename, filename_len, \"\", 1)));",
            "         if (!(buf = fb_read_file(path, P->opts.max_schema_size, &size))) {",
            "             free(path);",
            "             path = 0;",
            "             if (size > P->opts.max_schema_size && P->opts.max_schema_size > 0) {",
            "                 fb_print_error(P, \"input exceeds maximum allowed size\\n\");",
            "-                ret = -1;",
            "                 goto done;",
            "             }",
            "         }",
            "     }",
            "     if (!buf) {",
            "         fb_print_error(P, \"error reading included schema file: %s\\n\", filename);",
            "         goto done;",
            "@@ -388,20 +386,20 @@",
            "     /* Parser owns path. */",
            "     path = 0;",
            "     /*",
            "      * Even if we do not have the recursive option set, we still",
            "      * need to parse all include files to make sense of the current",
            "      * file.",
            "      */",
            "-    if (!(ret = fb_parse(P, buf, size, 1))) {",
            "+    if (!fb_parse(P, buf, size, 1)) {",
            "         /* Parser owns buffer. */",
            "         buf = 0;",
            "         inc = P->schema.includes;",
            "         while (inc) {",
            "-            checkmem((include_file = fb_copy_path_n(inc->name.s.s, inc->name.s.len)));",
            "+            checkmem((include_file = fb_copy_path_n(inc->name.s.s, (size_t)inc->name.s.len)));",
            "             if (__parse_include_file(P, include_file)) {",
            "                 goto done;",
            "             }",
            "             free(include_file);",
            "             include_file = 0;",
            "             inc = inc->link;",
            "         }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/hash_tables/name_table.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/hash_tables/name_table.c",
            "+++ /home/flatcc-0.6.1/src/compiler/hash_tables/name_table.c",
            "@@ -13,9 +13,9 @@",
            " static inline const void *ht_key(fb_name_t *name)",
            " {",
            "     return name->name.s.s;",
            " }",
            " ",
            " static inline size_t ht_key_len(fb_name_t *name)",
            " {",
            "-    return name->name.s.len;",
            "+    return (size_t)name->name.s.len;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/hash_tables/schema_table.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/hash_tables/schema_table.c",
            "+++ /home/flatcc-0.6.1/src/compiler/hash_tables/schema_table.c",
            "@@ -13,9 +13,9 @@",
            " static inline const void *ht_key(fb_schema_t *schema)",
            " {",
            "     return schema->name.name.s.s;",
            " }",
            " ",
            " static inline size_t ht_key_len(fb_schema_t *schema)",
            " {",
            "-    return schema->name.name.s.len;",
            "+    return (size_t)schema->name.name.s.len;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/hash_tables/scope_table.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/hash_tables/scope_table.c",
            "+++ /home/flatcc-0.6.1/src/compiler/hash_tables/scope_table.c",
            "@@ -76,16 +76,16 @@",
            "         /*",
            "          * If count is negative, this is the token count of the key",
            "          * which may have suffix to be ignored, otherwise the key is the",
            "          * full list.",
            "          */",
            "         /* `key` is a ref list (a list of tokens). */",
            "         while (name && keyname) {",
            "-            n1 = name->ident->len;",
            "-            n2 = keyname->ident->len;",
            "+            n1 = (size_t)name->ident->len;",
            "+            n2 = (size_t)keyname->ident->len;",
            "             if (n1 != n2 || strncmp(name->ident->text, keyname->ident->text, n1)) {",
            "                 return 0;",
            "             }",
            "             name = name->link;",
            "             keyname = keyname->link;",
            "             if (++count == 0) {",
            "                 return name == 0;",
            "@@ -96,15 +96,15 @@",
            "         }",
            "         return 1;",
            "     } else {",
            "         /* `key` is a dotted string. */",
            "         const char *s1, *s2 = key;",
            "         while (name) {",
            "             s1 = name->ident->text;",
            "-            n1 = name->ident->len;",
            "+            n1 = (size_t)name->ident->len;",
            "             if (n1 > len) {",
            "                 return 0;",
            "             }",
            "             for (i = 0; i < n1; ++i) {",
            "                 if (s1[i] != s2[i]) {",
            "                     return 0;",
            "                 }",
            "@@ -144,15 +144,15 @@",
            "     size_t h = 0, i;",
            "     int count = (int)len;",
            " ",
            "     if (count <= 0) {",
            "         const fb_ref_t *name = key;",
            " ",
            "         while (name) {",
            "-            h ^= ht_strn_hash_function(name->ident->text, name->ident->len);",
            "+            h ^= ht_strn_hash_function(name->ident->text, (size_t)name->ident->len);",
            "             h = ht_int_hash_function((void *)h, 0);",
            "             name = name->link;",
            "             if (++count == 0) {",
            "                 break;",
            "             }",
            "         }",
            "         return h;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/hash_tables/symbol_table.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/hash_tables/symbol_table.c",
            "+++ /home/flatcc-0.6.1/src/compiler/hash_tables/symbol_table.c",
            "@@ -14,9 +14,9 @@",
            "     return sym->ident->text;",
            " }",
            " ",
            " static inline size_t ht_key_len(fb_symbol_t *sym)",
            " {",
            "     fb_token_t *ident = sym->ident;",
            " ",
            "-    return ident->len;",
            "+    return (size_t)ident->len;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/keywords.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/keywords.h",
            "+++ /home/flatcc-0.6.1/src/compiler/keywords.h",
            "@@ -14,17 +14,19 @@",
            "  * project - we don't need it. The keywords should be sorted.",
            "  */",
            " ",
            " LEX_KW_TABLE_BEGIN",
            "     lex_kw(int, '3', 'i', 'n', 't')",
            "     lex_kw(bool, '4', 'b', 'o', 'l')",
            "     lex_kw(byte, '4', 'b', 'y', 'e')",
            "+    lex_kw(char, '4', 'c', 'h', 'r')",
            "     lex_kw(enum, '4', 'e', 'n', 'm')",
            "     lex_kw(int8, '4', 'i', 'n', '8')",
            "     lex_kw(long, '4', 'l', 'o', 'g')",
            "+    lex_kw(null, '4', 'n', 'u', 'l')",
            "     lex_kw(true, '4', 't', 'r', 'e')",
            "     lex_kw(uint, '4', 'u', 'i', 't')",
            "     lex_kw(false, '5', 'f', 'a', 'e')",
            "     lex_kw(float, '5', 'f', 'l', 't')",
            "     lex_kw(int32, '5', 'i', 'n', '2')",
            "     lex_kw(int16, '5', 'i', 'n', '6')",
            "     lex_kw(int64, '5', 'i', 'n', '4')"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/parser.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/parser.c",
            "+++ /home/flatcc-0.6.1/src/compiler/parser.c",
            "@@ -12,17 +12,18 @@",
            " #include <assert.h>",
            " #include <stdarg.h>",
            " ",
            " #include \"semantics.h\"",
            " #include \"codegen.h\"",
            " #include \"fileio.h\"",
            " #include \"pstrutil.h\"",
            "+#include \"flatcc/portable/pattributes.h\" /* fallthrough */",
            " #include \"flatcc/portable/pparseint.h\"",
            " ",
            "-void fb_default_error_out(void *err_ctx, const char *buf, int len)",
            "+void fb_default_error_out(void *err_ctx, const char *buf, size_t len)",
            " {",
            "     (void)err_ctx;",
            " ",
            "     fwrite(buf, 1, len, stderr);",
            " }",
            " ",
            " int fb_print_error(fb_parser_t *P, const char * format, ...)",
            "@@ -34,15 +35,15 @@",
            "     va_start (ap, format);",
            "     n = vsnprintf (buf, ERROR_BUFSIZ, format, ap);",
            "     va_end (ap);",
            "     if (n >= ERROR_BUFSIZ) {",
            "         strcpy(buf + ERROR_BUFSIZ - 5, \"...\\n\");",
            "         n = ERROR_BUFSIZ - 1;",
            "     }",
            "-    P->error_out(P->error_ctx, buf, n);",
            "+    P->error_out(P->error_ctx, buf, (size_t)n);",
            "     return n;",
            " }",
            " ",
            " const char *error_find_file_of_token(fb_parser_t *P, fb_token_t *t)",
            " {",
            "     /*",
            "      * Search token in dependent buffers if not in current token",
            "@@ -54,21 +55,21 @@",
            "             return P->schema.errorname;",
            "         }",
            "         P = P->dependencies;",
            "     }",
            "     return \"\";",
            " }",
            " ",
            "-void error_report(fb_parser_t *P, fb_token_t *t, const char *msg, fb_token_t *peer, const char *s, int len)",
            "+void error_report(fb_parser_t *P, fb_token_t *t, const char *msg, fb_token_t *peer, const char *s, size_t len)",
            " {",
            "     const char *file, *peer_file;",
            " ",
            "     if (t && !s) {",
            "         s = t->text;",
            "-        len = (int)t->len;",
            "+        len = (size_t)t->len;",
            "     }",
            "     if (!msg) {",
            "         msg = \"\";",
            "     }",
            "     if (!s) {",
            "         s = \"\";",
            "         len = 0;",
            "@@ -96,36 +97,42 @@",
            "     ++P->failed;",
            " }",
            " ",
            " void error_ref_sym(fb_parser_t *P, fb_ref_t *ref, const char *msg, fb_symbol_t *s2)",
            " {",
            "     fb_ref_t *p;",
            "     char buf[FLATCC_MAX_IDENT_SHOW + 1];",
            "-    int k = FLATCC_MAX_IDENT_SHOW;",
            "-    int n = 0;",
            "-    int n0 = 0;",
            "+    size_t k = FLATCC_MAX_IDENT_SHOW;",
            "+    size_t n = 0;",
            "+    size_t n0 = 0;",
            "+    int truncated = 0;",
            "+",
            "     p = ref;",
            "     while (p && k > 0) {",
            "-        n = p->ident->len;",
            "+        if (n0 > 0) {",
            "+            buf[n0] = '.';",
            "+            --k;",
            "+            ++n0;",
            "+        }",
            "+        n = (size_t)p->ident->len;",
            "         if (k < n) {",
            "             n = k;",
            "+            truncated = 1;",
            "         }",
            "         memcpy(buf + n0, p->ident->text, n);",
            "         k -= n;",
            "         n0 += n;",
            "-        buf[n0] = '.';",
            "-        --k;",
            "-        ++n0;",
            "         p = p->link;",
            "     }",
            "+    if (p) truncated = 1;",
            "     buf[n0] = '\\0';",
            "     if (n0 > 0) {",
            "         --n0;",
            "     }",
            "-    if (k <= 0) {",
            "+    if (truncated) {",
            "         memcpy(buf + FLATCC_MAX_IDENT_SHOW + 1 - 4, \"...\\0\", 4);",
            "         n0 = FLATCC_MAX_IDENT_SHOW;",
            "     }",
            "     error_report(P, ref->ident, msg, s2 ? s2->ident : 0, buf, n0);",
            " }",
            " ",
            " //#define LEX_DEBUG",
            "@@ -405,14 +412,45 @@",
            "         next(P);",
            "     } else {",
            "         error_tok(P, P->token, msg);",
            "     }",
            "     return t;",
            " }",
            " ",
            "+/*",
            "+ * When a keyword should also be accepted as an identifier.",
            "+ * This is useful for JSON where field naems are visible.",
            "+ * Since field names are not referenced within the schema,",
            "+ * this is generally safe. Enums can also be resererved but",
            "+ * they can then not be used as default values. Table names",
            "+ * and other type names should not be remapped as they can then",
            "+ * not by used as a type name for other fields.",
            "+ */",
            "+#if FLATCC_ALLOW_KW_FIELDS",
            "+static inline void remap_field_ident(fb_parser_t *P)",
            "+{",
            "+    if (P->token->id >= LEX_TOK_KW_BASE && P->token->id < LEX_TOK_KW_END) {",
            "+        P->token->id = LEX_TOK_ID;",
            "+    }",
            "+}",
            "+#else",
            "+static inline void remap_field_ident(fb_parser_t *P) { (void)P; }",
            "+#endif",
            "+",
            "+#if FLATCC_ALLOW_KW_ENUMS",
            "+static inline void remap_enum_ident(fb_parser_t *P)",
            "+{",
            "+    if (P->token->id >= LEX_TOK_KW_BASE && P->token->id < LEX_TOK_KW_END) {",
            "+        P->token->id = LEX_TOK_ID;",
            "+    }",
            "+}",
            "+#else",
            "+static inline void remap_enum_ident(fb_parser_t *P) { (void)P; }",
            "+#endif",
            "+",
            " static fb_token_t *advance(fb_parser_t *P, long id, const char *msg, fb_token_t *peer)",
            " {",
            "     /*",
            "      * `advance` is generally used at end of statements so it is a",
            "      * convenient place to get rid of rogue doc comments we can't attach",
            "      * to anything meaningful.",
            "      */",
            "@@ -426,15 +464,15 @@",
            " ",
            " static void read_integer_value(fb_parser_t *P, fb_token_t *t, fb_value_t *v, int sign)",
            " {",
            "     int status;",
            " ",
            "     v->type = vt_uint;",
            "     /* The token does not store the sign internally. */",
            "-    parse_integer(t->text, t->len, &v->u, &status);",
            "+    parse_integer(t->text, (size_t)t->len, &v->u, &status);",
            "     if (status != PARSE_INTEGER_UNSIGNED) {",
            "         v->type = vt_invalid;",
            "         error_tok(P, t, \"invalid integer format\");",
            "     }",
            "     if (sign) {",
            "         v->i = -(int64_t)v->u;",
            "         v->type = vt_int;",
            "@@ -450,15 +488,15 @@",
            " ",
            " static void read_hex_value(fb_parser_t *P, fb_token_t *t, fb_value_t *v, int sign)",
            " {",
            "     int status;",
            " ",
            "     v->type = vt_uint;",
            "     /* The token does not store the sign internally. */",
            "-    parse_hex_integer(t->text, t->len, &v->u, &status);",
            "+    parse_hex_integer(t->text, (size_t)t->len, &v->u, &status);",
            "     if (status != PARSE_INTEGER_UNSIGNED) {",
            "         v->type = vt_invalid;",
            "         error_tok(P, t, \"invalid hex integer format\");",
            "     }",
            "     if (sign) {",
            "         v->i = -(int64_t)v->u;",
            "         v->type = vt_int;",
            "@@ -546,15 +584,15 @@",
            "     }",
            " done:",
            "     /*",
            "      * If we were to ignore all errors, we would get the full",
            "      * string as is excluding delimiting quotes.",
            "      */",
            "     if (v->s.s) {",
            "-        v->s.len = (long)(P->token->text - v->s.s);",
            "+        v->s.len = (int)(P->token->text - v->s.s);",
            "     }",
            "     if (!match(P, LEX_TOK_STRING_END, \"unterminated string\")) {",
            "         v->type = vt_invalid;",
            "     }",
            " }",
            " ",
            " /* Current token must be an identifier. */",
            "@@ -571,15 +609,15 @@",
            "         *ref = fb_add_ref(P, P->token);",
            "         ref = &((*ref)->link);",
            "         next(P);",
            "     }",
            " }",
            " ",
            " /* `flags` */",
            "-enum { allow_string_value = 1, allow_id_value = 2 };",
            "+enum { allow_string_value = 1, allow_id_value = 2, allow_null_value = 4 };",
            " static void parse_value(fb_parser_t *P, fb_value_t *v, int flags, const char *error_msg)",
            " {",
            "     fb_token_t *t;",
            "     fb_token_t *sign;",
            " ",
            "     sign = optional(P, '-');",
            "     t = P->token;",
            "@@ -598,14 +636,22 @@",
            "         v->b = 1;",
            "         v->type = vt_bool;",
            "         break;",
            "     case tok_kw_false:",
            "         v->b = 0;",
            "         v->type = vt_bool;",
            "         break;",
            "+    case tok_kw_null:",
            "+        if (!(flags & allow_null_value)) {",
            "+            v->type = vt_invalid;",
            "+            error_tok(P, t, error_msg);",
            "+            return;",
            "+        }",
            "+        v->type = vt_null;",
            "+        break;",
            "     case LEX_TOK_STRING_BEGIN:",
            "         next(P);",
            "         parse_string_literal(P, v);",
            "         if (!(flags & allow_string_value)) {",
            "             v->type = vt_invalid;",
            "             error_tok(P, t, error_msg);",
            "             return;",
            "@@ -633,36 +679,88 @@",
            "     if (sign && v->type == vt_bool) {",
            "         v->type = vt_invalid;",
            "         error_tok(P, t, \"boolean constants cannot be signed\");",
            "     }",
            "     next(P);",
            " }",
            " ",
            "+static void parse_fixed_array_size(fb_parser_t *P, fb_token_t *ttype, fb_value_t *v)",
            "+{",
            "+    const char *error_msg = \"fixed length array length expected to be an unsigned integer\";",
            "+    fb_value_t vsize;",
            "+    fb_token_t *tlen = P->token;",
            "+",
            "+    parse_value(P, &vsize, 0, error_msg);",
            "+    if (vsize.type != vt_uint) {",
            "+        error_tok(P, tlen, error_msg);",
            "+        v->type = vt_invalid;",
            "+        return;",
            "+    }",
            "+    if (v->type == vt_invalid) return;",
            "+    switch (v->type) {",
            "+    case vt_vector_type:",
            "+        v->type = vt_fixed_array_type;",
            "+        break;",
            "+    case vt_vector_type_ref:",
            "+        v->type = vt_fixed_array_type_ref;",
            "+        break;",
            "+    case vt_vector_string_type:",
            "+        v->type = vt_fixed_array_string_type;",
            "+        break;",
            "+    case vt_invalid:",
            "+        return;",
            "+    default:",
            "+        error_tok(P, ttype, \"invalid fixed length array type\");",
            "+        v->type = vt_invalid;",
            "+        return;",
            "+    }",
            "+    if (vsize.u == 0) {",
            "+        error_tok(P, tlen, \"fixed length array length cannot be 0\");",
            "+        v->type = vt_invalid;",
            "+        return;",
            "+    }",
            "+    /*",
            "+     * This allows for safe 64-bit multiplication by elements no",
            "+     * larger than 2^32-1 and also fits into the value len field.",
            "+     * without extra size cost.",
            "+     */",
            "+    if (vsize.u > UINT32_MAX) {",
            "+        error_tok(P, tlen, \"fixed length array length overflow\");",
            "+        v->type = vt_invalid;",
            "+        return;",
            "+    }",
            "+    v->len = (uint32_t)vsize.u;",
            "+}",
            "+",
            " /* ':' must already be matched */",
            " static void parse_type(fb_parser_t *P, fb_value_t *v)",
            " {",
            "     fb_token_t *t = 0;",
            "+    fb_token_t *ttype = 0;",
            "     fb_token_t *t0 = P->token;",
            "     int vector = 0;",
            " ",
            "+    v->len = 1;",
            "     v->type = vt_invalid;",
            "     while ((t = optional(P, '['))) {",
            "         ++vector;",
            "     }",
            "     if (vector > 1) {",
            "         error_tok(P, t0, \"vector type can only be one-dimensional\");",
            "     }",
            "-    switch (P->token->id) {",
            "+    ttype = P->token;",
            "+    switch (ttype->id) {",
            "     case tok_kw_int:",
            "     case tok_kw_bool:",
            "     case tok_kw_byte:",
            "     case tok_kw_long:",
            "     case tok_kw_uint:",
            "     case tok_kw_float:",
            "     case tok_kw_short:",
            "+    case tok_kw_char:",
            "     case tok_kw_ubyte:",
            "     case tok_kw_ulong:",
            "     case tok_kw_ushort:",
            "     case tok_kw_double:",
            "     case tok_kw_int8:",
            "     case tok_kw_int16:",
            "     case tok_kw_int32:",
            "@@ -686,27 +784,36 @@",
            "         parse_ref(P, &v->ref);",
            "         v->type = vector ? vt_vector_type_ref : vt_type_ref;",
            "         break;",
            "     case ']':",
            "         error_tok(P, t, \"vector type cannot be empty\");",
            "         break;",
            "     default:",
            "-        error_tok(P, t, \"invalid type specifier\");",
            "+        error_tok(P, ttype, \"invalid type specifier\");",
            "         break;",
            "     }",
            "+    if (vector && optional(P, ':')) {",
            "+        parse_fixed_array_size(P, ttype, v);",
            "+    }",
            "     while (optional(P, ']') && vector--) {",
            "     }",
            "     if (vector) {",
            "         error_tok_2(P, t, \"vector type missing ']' to match\", t0);",
            "     }",
            "     if ((t = optional(P, ']'))) {",
            "         error_tok_2(P, t, \"extra ']' not matching\", t0);",
            "         while (optional(P, ']')) {",
            "         }",
            "     }",
            "+    if (ttype->id == tok_kw_char && v->type != vt_invalid) {",
            "+        if (v->type != vt_fixed_array_type) {",
            "+            error_tok(P, ttype, \"char can only be used as a fixed length array type [char:<n>]\");",
            "+            v->type = vt_invalid;",
            "+        }",
            "+    }",
            " }",
            " ",
            " static fb_metadata_t *parse_metadata(fb_parser_t *P)",
            " {",
            "     fb_token_t *t, *t0;",
            "     fb_metadata_t *md = 0;",
            " ",
            "@@ -734,14 +841,16 @@",
            "     revert_metadata(&md);",
            "     return md;",
            " }",
            " ",
            " static void parse_field(fb_parser_t *P, fb_member_t *fld)",
            " {",
            "     fb_token_t *t;",
            "+",
            "+    remap_field_ident(P);",
            "     if (!(t = match(P, LEX_TOK_ID, \"field expected identifier\"))) {",
            "         goto fail;",
            "     }",
            "     fld->symbol.ident = t;",
            "     if (!match(P, ':', \"field expected ':' before mandatory type\")) {",
            "         goto fail;",
            "     }",
            "@@ -749,15 +858,15 @@",
            "     if (optional(P, '=')) {",
            "         /*",
            "          * Because types can be named references, we do not check the",
            "          * default assignment before the schema is fully parsed.",
            "          * We allow the initializer to be a name in case it is an enum",
            "          * name.",
            "          */",
            "-        parse_value(P, &fld->value, allow_id_value, \"initializer must be of scalar type\");",
            "+        parse_value(P, &fld->value, allow_id_value | allow_null_value, \"initializer must be of scalar type or null\");",
            "     }",
            "     fld->metadata = parse_metadata(P);",
            "     advance(P, ';', \"field must be terminated with ';'\", 0);",
            "     return;",
            " fail:",
            "     recover2(P, ';', 1, '}', 0);",
            " }",
            "@@ -807,24 +916,26 @@",
            "         } else {",
            "             switch (ct->type.t->id) {",
            "             case tok_kw_float:",
            "             case tok_kw_double:",
            "             case tok_kw_float32:",
            "             case tok_kw_float64:",
            "                 error_tok(P, ct->type.t, \"integral type expected\");",
            "+                fallthrough;",
            "             default:",
            "                 break;",
            "             }",
            "         }",
            "     }",
            "     ct->metadata = parse_metadata(P);",
            "     if (!((t0 = match(P, '{', \"enum declaration expected '{'\")))) {",
            "         goto fail;",
            "     }",
            "     for (;;) {",
            "+        remap_enum_ident(P);",
            "         if (!(t = match(P, LEX_TOK_ID,",
            "                 \"member identifier expected\"))) {",
            "             goto fail;",
            "         }",
            "         if (P->failed >= FLATCC_MAX_ERRORS) {",
            "             goto fail;",
            "         }",
            "@@ -1016,15 +1127,15 @@",
            "     }",
            "     match(P, ';', \"attribute expected ';'\");",
            " }",
            " ",
            " static void parse_file_extension(fb_parser_t *P, fb_value_t *v)",
            " {",
            "     if (v->type == vt_string) {",
            "-        error_tok_as_string(P, P->token, \"file extension already set\", v->s.s, v->s.len);",
            "+        error_tok_as_string(P, P->token, \"file extension already set\", v->s.s, (size_t)v->s.len);",
            "     }",
            "     if (!match(P, LEX_TOK_STRING_BEGIN, \"file_extension expected string literal\")) {",
            "         goto fail;",
            "     }",
            "     parse_string_literal(P, v);",
            "     match(P, ';', \"file_extension expected ';'\");",
            "     return;",
            "@@ -1032,15 +1143,15 @@",
            "     recover(P, ';', 1);",
            " }",
            " ",
            " static void parse_file_identifier(fb_parser_t *P, fb_value_t *v)",
            " {",
            "     fb_token_t *t;",
            "     if (v->type != vt_missing) {",
            "-        error_tok_as_string(P, P->token, \"file identifier already set\", v->s.s, v->s.len);",
            "+        error_tok_as_string(P, P->token, \"file identifier already set\", v->s.s, (size_t)v->s.len);",
            "     }",
            "     if (!match(P, LEX_TOK_STRING_BEGIN, \"file_identifier expected string literal\")) {",
            "         goto fail;",
            "     }",
            "     t = P->token;",
            "     parse_string_literal(P, v);",
            "     if (v->s.s && v->s.len != 4) {",
            "@@ -1160,17 +1271,17 @@",
            " static void push_token(fb_parser_t *P, long id, const char *first, const char *last)",
            " {",
            "     size_t offset;",
            "     fb_token_t *t;",
            " ",
            "     P->te = P->ts + P->tcapacity;",
            "     if (P->token == P->te) {",
            "-        offset = P->token - P->ts;",
            "+        offset = (size_t)(P->token - P->ts);",
            "         P->tcapacity = P->tcapacity ? 2 * P->tcapacity : 1024;",
            "-        P->ts = realloc(P->ts, P->tcapacity * sizeof(fb_token_t));",
            "+        P->ts = realloc(P->ts, (size_t)P->tcapacity * sizeof(fb_token_t));",
            "         checkmem(P->ts);",
            "         P->te = P->ts + P->tcapacity;",
            "         P->token = P->ts + offset;",
            "     }",
            "     t = P->token;",
            "     t->id = id;",
            "     t->text = first;",
            "@@ -1316,19 +1427,19 @@",
            "     name_len = strlen(name);",
            "     checkmem((P->schema.basename = fb_create_basename(name, name_len, opts->default_schema_ext)));",
            "     n = strlen(P->schema.basename);",
            "     checkmem(s = fb_copy_path_n(P->schema.basename, n));",
            "     pstrntoupper(s, n);",
            "     P->schema.basenameup = s;",
            "     P->schema.name.name.s.s = s;",
            "-    P->schema.name.name.s.len = (long)n;",
            "+    P->schema.name.name.s.len = (int)n;",
            "     checkmem((P->schema.errorname = fb_create_basename(name, name_len, \"\")));",
            "     if (opts->ns) {",
            "         P->schema.prefix.s = (char *)opts->ns;",
            "-        P->schema.prefix.len = (long)strlen(opts->ns);",
            "+        P->schema.prefix.len = (int)strlen(opts->ns);",
            "     }",
            "     P->current_scope = fb_add_scope(P, 0);",
            "     assert(P->current_scope == fb_scope_table_find(&P->schema.root_schema->scope_index, 0, 0));",
            "     return 0;",
            " }",
            " ",
            " /*"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/parser.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/parser.h",
            "+++ /home/flatcc-0.6.1/src/compiler/parser.h",
            "@@ -24,17 +24,17 @@",
            "         }                                                                   \\",
            "         *(HEAD) = tmp__prev;                                                \\",
            "     } while (0)",
            " ",
            " typedef struct fb_parser fb_parser_t;",
            " typedef flatcc_options_t fb_options_t;",
            " ",
            "-typedef void (*fb_error_fun)(void *err_ctx, const char *buf, int len);",
            "+typedef void (*fb_error_fun)(void *err_ctx, const char *buf, size_t len);",
            " ",
            "-void __flatcc_fb_default_error_out(void *err_ctx, const char *buf, int len);",
            "+void __flatcc_fb_default_error_out(void *err_ctx, const char *buf, size_t len);",
            " #define  fb_default_error_out __flatcc_fb_default_error_out",
            " ",
            " int __flatcc_fb_print_error(fb_parser_t *P, const char * format, ...);",
            " #define fb_print_error __flatcc_fb_print_error",
            " ",
            " struct fb_parser {",
            "     fb_parser_t *dependencies;",
            "@@ -80,20 +80,20 @@",
            " {",
            "     if (!p) {",
            "         fprintf(stderr, \"error: out of memory, aborting...\\n\");",
            "         exit(1);",
            "     }",
            " }",
            " ",
            "-static inline void *new_elem(fb_parser_t *P, int size)",
            "+static inline void *new_elem(fb_parser_t *P, size_t size)",
            " {",
            "     size_t elem;",
            "     void *buf;",
            " ",
            "-    size = (size + 15) & ~15;",
            "+    size = (size + 15) & ~(size_t)15;",
            "     elem = P->elem;",
            "     if (elem + size > P->elem_end) {",
            "         buf = calloc(ELEM_BUFSIZ, 1);",
            "         checkmem(buf);",
            "         *(void**)buf = P->elem_buffers;",
            "         P->elem_buffers = buf;",
            "         elem = P->elem = (size_t)buf + 16;",
            "@@ -119,44 +119,44 @@",
            "  * `msg` may be the only non-zero argument besides `P`.",
            "  *",
            "  * Various helper functions are available for the various cases.",
            "  *",
            "  * `fb_print_error` may be called instead to generate text to the error",
            "  * output that is not counted as an error.",
            "  */",
            "-void __flatcc_error_report(fb_parser_t *P, fb_token_t *t, const char *msg, fb_token_t *peer, const char *s, int len);",
            "+void __flatcc_error_report(fb_parser_t *P, fb_token_t *t, const char *msg, fb_token_t *peer, const char *s, size_t len);",
            " #define error_report __flatcc_error_report",
            " ",
            " static void error_tok_2(fb_parser_t *P, fb_token_t *t, const char *msg, fb_token_t *peer)",
            " {",
            "     error_report(P, t, msg, peer, 0, 0);",
            " }",
            " ",
            " static inline void error_tok(fb_parser_t *P, fb_token_t *t, const char *msg)",
            " {",
            "     error_tok_2(P, t, msg, 0);",
            " }",
            " ",
            " /* Only use the token location. */",
            "-static inline void error_tok_as_string(fb_parser_t *P, fb_token_t *t, const char *msg, char *s, int len)",
            "+static inline void error_tok_as_string(fb_parser_t *P, fb_token_t *t, const char *msg, char *s, size_t len)",
            " {",
            "     error_report(P, t, msg, 0, s, len);",
            " }",
            " ",
            " static inline void error(fb_parser_t *P, const char *msg)",
            " {",
            "     error_tok(P, 0, msg);",
            " }",
            " ",
            " static inline void error_name(fb_parser_t *P, fb_name_t *name, const char *msg)",
            " {",
            "     if (!name) {",
            "         error(P, msg);",
            "     } else {",
            "-        error_report(P, 0, msg, 0, name->name.s.s, name->name.s.len);",
            "+        error_report(P, 0, msg, 0, name->name.s.s, (size_t)name->name.s.len);",
            "     }",
            " }",
            " ",
            " static inline void error_sym(fb_parser_t *P, fb_symbol_t *s, const char *msg)",
            " {",
            "     error_tok(P, s->ident, msg);",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/pstrutil.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/pstrutil.h",
            "+++ /home/flatcc-0.6.1/src/compiler/pstrutil.h",
            "@@ -15,43 +15,43 @@",
            "     const char *end = memchr (s, 0, max_len);",
            "     return end ? (size_t)(end - s) : max_len;",
            " }",
            " ",
            " static inline char *pstrcpyupper(char *dst, const char *src) {",
            "     char *p = dst;",
            "     while (*src) {",
            "-        *p++ = toupper(*src++);",
            "+        *p++ = (char)toupper(*src++);",
            "     }",
            "     *p = '\\0';",
            "     return dst;",
            " }",
            " ",
            " static inline char *pstrncpyupper(char *dst, const char *src, size_t n) {",
            "     size_t i;",
            "     for (i = 0; i < n && src[i]; ++i) {",
            "-        dst[i] = toupper(src[i]);",
            "+        dst[i] = (char)toupper(src[i]);",
            "     }",
            "     if (i < n) {",
            "         dst[i] = '\\0';",
            "     }",
            "     return dst;",
            " }",
            " ",
            " static inline char *pstrtoupper(char *dst) {",
            "     char *p;",
            "     for (p = dst; *p; ++p) {",
            "-        *p = toupper(*p);",
            "+        *p = (char)toupper(*p);",
            "     }",
            "     return dst;",
            " }",
            " ",
            " static inline char *pstrntoupper(char *dst, size_t n) {",
            "     size_t i;",
            "     for (i = 0; i < n && dst[i]; ++i) {",
            "-        dst[i] = toupper(dst[i]);",
            "+        dst[i] = (char)toupper(dst[i]);",
            "     }",
            "     return dst;",
            " }",
            " ",
            " #undef strnlen",
            " #define strnlen pstrnlen"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/semantics.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/semantics.c",
            "+++ /home/flatcc-0.6.1/src/compiler/semantics.c",
            "@@ -7,28 +7,32 @@",
            " #include \"stdio.h\"",
            " ",
            " /* -DFLATCC_PORTABLE may help if inttypes.h is missing. */",
            " #ifndef PRId64",
            " #include <inttypes.h>",
            " #endif",
            " ",
            "+#include \"flatcc/portable/pattributes.h\" /* fallthrough */",
            "+",
            " /* Same order as enum! */",
            " static const char *fb_known_attribute_names[] = {",
            "     \"\",",
            "     \"id\",",
            "     \"deprecated\",",
            "     \"original_order\",",
            "     \"force_align\",",
            "     \"bit_flags\",",
            "     \"nested_flatbuffer\",",
            "     \"key\",",
            "     \"required\",",
            "     \"hash\",",
            "     \"base64\",",
            "     \"base64url\",",
            "+    \"primary_key\",",
            "+    \"sorted\",",
            " };",
            " ",
            " static const int fb_known_attribute_types[] = {",
            "     vt_invalid, /* Unknowns have arbitrary types. */",
            "     vt_uint,",
            "     vt_missing,",
            "     vt_missing,",
            "@@ -36,14 +40,16 @@",
            "     vt_missing,",
            "     vt_string,",
            "     vt_missing,",
            "     vt_missing,",
            "     vt_string,",
            "     vt_missing,",
            "     vt_missing,",
            "+    vt_missing,",
            "+    vt_missing,",
            " };",
            " ",
            " static fb_scalar_type_t map_scalar_token_type(fb_token_t *t)",
            " {",
            "     switch (t->id) {",
            "     case tok_kw_uint64:",
            "     case tok_kw_ulong:",
            "@@ -53,14 +59,16 @@",
            "         return fb_uint;",
            "     case tok_kw_uint16:",
            "     case tok_kw_ushort:",
            "         return fb_ushort;",
            "     case tok_kw_uint8:",
            "     case tok_kw_ubyte:",
            "         return fb_ubyte;",
            "+    case tok_kw_char:",
            "+        return fb_char;",
            "     case tok_kw_bool:",
            "         return fb_bool;",
            "     case tok_kw_int64:",
            "     case tok_kw_long:",
            "         return fb_long;",
            "     case tok_kw_int32:",
            "     case tok_kw_int:",
            "@@ -121,35 +129,35 @@",
            "     fb_ref_t *name;",
            "     fb_symbol_t *sym;",
            "     uint32_t hash;",
            " ",
            "     hash = fb_hash_fnv1a_32_init();",
            "     if (ct->scope)",
            "     for (name = ct->scope->name; name; name = name->link) {",
            "-        hash = fb_hash_fnv1a_32_append(hash, name->ident->text, name->ident->len);",
            "+        hash = fb_hash_fnv1a_32_append(hash, name->ident->text, (size_t)name->ident->len);",
            "         hash = fb_hash_fnv1a_32_append(hash, \".\", 1);",
            "     }",
            "     sym = &ct->symbol;",
            "-    hash = fb_hash_fnv1a_32_append(hash, sym->ident->text, sym->ident->len);",
            "+    hash = fb_hash_fnv1a_32_append(hash, sym->ident->text, (size_t)sym->ident->len);",
            "     if (hash == 0) {",
            "         hash = fb_hash_fnv1a_32_init();",
            "     }",
            "     ct->type_hash = hash;",
            " }",
            " ",
            "-static inline fb_scope_t *fb_find_scope_by_string(fb_schema_t *S, const char *name, int len)",
            "+static inline fb_scope_t *fb_find_scope_by_string(fb_schema_t *S, const char *name, size_t len)",
            " {",
            "     if (!S || !S->root_schema) {",
            "         return 0;",
            "     }",
            "     if (len == 0) {",
            "         /* Global scope. */",
            "         name = 0;",
            "     }",
            "-    return fb_scope_table_find(&S->root_schema->scope_index, name, (size_t)len);",
            "+    return fb_scope_table_find(&S->root_schema->scope_index, name, len);",
            " }",
            " ",
            " /* count = 0 indicates zero-terminated ref list, name = 0 indicates global scope. */",
            " static inline fb_scope_t *fb_find_scope_by_ref(fb_schema_t *S, const fb_ref_t *name, int count)",
            " {",
            "     if (!S || !S->root_schema) {",
            "         return 0;",
            "@@ -160,25 +168,25 @@",
            " static inline fb_symbol_t *define_fb_symbol(fb_symbol_table_t *si, fb_symbol_t *sym)",
            " {",
            "     return fb_symbol_table_insert_item(si, sym, ht_keep);",
            " }",
            " ",
            " static inline fb_symbol_t *find_fb_symbol_by_token(fb_symbol_table_t *si, fb_token_t *token)",
            " {",
            "-    return fb_symbol_table_find(si, token->text, token->len);",
            "+    return fb_symbol_table_find(si, token->text, (size_t)token->len);",
            " }",
            " ",
            " static inline fb_name_t *define_fb_name(fb_name_table_t *ni, fb_name_t *name)",
            " {",
            "     return fb_name_table_insert_item(ni, name, ht_keep);",
            " }",
            " ",
            "-static inline fb_name_t * find_fb_name_by_token(fb_name_table_t *ni, fb_token_t *token)",
            "+static inline fb_name_t *find_fb_name_by_token(fb_name_table_t *ni, fb_token_t *token)",
            " {",
            "-    return fb_name_table_find(ni, token->text, token->len);",
            "+    return fb_name_table_find(ni, token->text, (size_t)token->len);",
            " }",
            " ",
            " /* Returns 1 if value exists, 0 otherwise, */",
            " static inline int add_to_value_set(fb_value_set_t *vs, fb_value_t *value)",
            " {",
            "     return fb_value_set_insert_item(vs, value, ht_keep) != 0;",
            " }",
            "@@ -189,15 +197,15 @@",
            " }",
            " ",
            " /*",
            "  * An immediate parent scope does not necessarily exist and it might",
            "  * appear in a later search, so we return the nearest existing parent",
            "  * and do not cache the parent.",
            "  */",
            "-static inline fb_scope_t *find_parent_scope(fb_parser_t *P, fb_scope_t *scope) ",
            "+static inline fb_scope_t *find_parent_scope(fb_parser_t *P, fb_scope_t *scope)",
            " {",
            "     fb_ref_t *p;",
            "     int count;",
            "     fb_scope_t *parent;",
            " ",
            "     parent = 0;",
            "     count = 0;",
            "@@ -217,20 +225,20 @@",
            "             return parent;",
            "         }",
            "     }",
            "     /* Root scope. */",
            "     return fb_find_scope_by_ref(&P->schema, 0, 0);",
            " }",
            " ",
            "-static inline fb_symbol_t *lookup_string_reference(fb_parser_t *P, fb_scope_t *local, const char *s, int len)",
            "+static inline fb_symbol_t *lookup_string_reference(fb_parser_t *P, fb_scope_t *local, const char *s, size_t len)",
            " {",
            "     fb_symbol_t *sym;",
            "     fb_scope_t *scope;",
            "     const char *name, *basename;",
            "-    int k;",
            "+    size_t k;",
            " ",
            "     name = s;",
            "     basename = s;",
            "     k = len;",
            "     while (k > 0) {",
            "         if (s[--k] == '.') {",
            "             basename = s + k + 1;",
            "@@ -364,23 +372,23 @@",
            "     *value = member->value;",
            "     return 0;",
            " }",
            " ",
            " /* This is repeated for every include file, but this pose no problem. */",
            " static void install_known_attributes(fb_parser_t *P)",
            " {",
            "-    int i;",
            "+    unsigned int i;",
            "     fb_attribute_t *a;",
            " ",
            "     for (i = 0; i < KNOWN_ATTR_COUNT; ++i) {",
            "         /* Don't put it in the parsed list, just the index. */",
            "         a = new_elem(P, sizeof(*a));",
            "         a->known = i;",
            "         a->name.name.s.s = (char *)fb_known_attribute_names[i];",
            "-        a->name.name.s.len = (long)strlen(fb_known_attribute_names[i]);",
            "+        a->name.name.s.len = (int)strlen(fb_known_attribute_names[i]);",
            "         a->name.name.type = vt_string;",
            "         a->name.link = 0;",
            "         if ((a = (fb_attribute_t *)define_fb_name(&P->schema.root_schema->attribute_index, &a->name))) {",
            "             /*",
            "              * If the user alredy defined the attribute, keep that instead.",
            "              * (Memory leak is ok here.)",
            "              */",
            "@@ -398,19 +406,18 @@",
            "         prev = link;",
            "         link = next;",
            "     }",
            "     *list = prev;",
            " }",
            " ",
            " static inline unsigned short process_metadata(fb_parser_t *P, fb_metadata_t *m,",
            "-        unsigned short expect, fb_metadata_t *out[KNOWN_ATTR_COUNT])",
            "+        uint16_t expect, fb_metadata_t *out[KNOWN_ATTR_COUNT])",
            " {",
            "-    unsigned short flags;",
            "-    int n = FLATCC_ATTR_MAX;",
            "-    int i;",
            "+    uint16_t flags;",
            "+    unsigned int i, n = FLATCC_ATTR_MAX;",
            "     int type;",
            "     fb_attribute_t *a;",
            " ",
            "     memset(out, 0, sizeof(out[0]) * KNOWN_ATTR_COUNT);",
            "     for (flags = 0; m && n; --n, m = m->link) {",
            "         a = (fb_attribute_t *)find_fb_name_by_token(&P->schema.root_schema->attribute_index, m->ident);",
            "         if (!a) {",
            "@@ -512,32 +519,36 @@",
            "         type = 0;",
            "         if (P->nesting_level >= FLATCC_NESTING_MAX) {",
            "             error(P, \"maximum allowed nesting level exceeded while processing struct hierarchy\");",
            "             return -1;",
            "         }",
            "         member = (fb_member_t *)sym;",
            "         switch (member->type.type) {",
            "+        case vt_fixed_array_type:",
            "+            /* fall through */",
            "         case vt_scalar_type:",
            "             t = member->type.t;",
            "             member->type.st = map_scalar_token_type(t);",
            "             size = sizeof_scalar_type(member->type.st);",
            "             if (size < 1) {",
            "                 error_sym_tok(P, sym, \"unexpected type\", t);",
            "                 return -1;",
            "             }",
            "             member->align = (uint16_t)size;",
            "-            member->size = size;",
            "+            member->size = size * member->type.len;",
            "             break;",
            "+        case vt_fixed_array_compound_type_ref:",
            "+            /* fall through */",
            "         case vt_compound_type_ref:",
            "             /* Enums might not be valid, but then it would be detected earlier. */",
            "             if (member->type.ct->symbol.kind == fb_is_enum) {",
            "                 type = member->type.ct;",
            "                 size = type->size;",
            "                 member->align = (uint16_t)size;",
            "-                member->size = size;",
            "+                member->size = member->type.len * type->size;",
            "                 break;",
            "             } else if (member->type.ct->symbol.kind == fb_is_struct) {",
            "                 type = member->type.ct;",
            "                 if (type->symbol.flags & fb_circular_open) {",
            "                     error_sym_2(P, sym, \"circular reference to struct at\", &type->symbol);",
            "                     return -1;",
            "                 }",
            "@@ -549,15 +560,15 @@",
            "                     ret = analyze_struct(P, type);",
            "                     --P->nesting_level;",
            "                     if (ret) {",
            "                         return ret;",
            "                     }",
            "                 }",
            "                 member->align = type->align;",
            "-                member->size = type->size;",
            "+                member->size = member->type.len * type->size;",
            "                 break;",
            "             } else {",
            "                 error_sym(P, sym, \"unexpected compound type for field\");",
            "                 return -1;",
            "             }",
            "             break;",
            "         case vt_invalid:",
            "@@ -596,16 +607,21 @@",
            "         }",
            "     } else {",
            "         ct->align = align;",
            "     }",
            "     /* Add trailing padding if necessary. */",
            "     ct->size = fb_align(ct->size, ct->align);",
            " ",
            "+    if (ct->size == 0) {",
            "+        error_sym(P, &ct->symbol, \"struct cannot be empty\");",
            "+        return -1;",
            "+    }",
            "+",
            "     ct->symbol.flags |= fb_circular_closed;",
            "-    ct->symbol.flags &= ~fb_circular_open;",
            "+    ct->symbol.flags &= (uint16_t)~fb_circular_open;",
            "     ct->order = P->schema.ordered_structs;",
            "     P->schema.ordered_structs = ct;",
            "     return ret;",
            " }",
            " ",
            " static int define_nested_table(fb_parser_t *P, fb_scope_t *local, fb_member_t *member, fb_metadata_t *m)",
            " {",
            "@@ -615,17 +631,17 @@",
            "         error_tok(P, m->ident, \"'nested_flatbuffer' attribute requires a [ubyte] vector type\");",
            "         return -1;",
            "     }",
            "     if (m->value.type != vt_string) {",
            "         /* All known attributes get automatically type checked, so just ignore. */",
            "         return -1;",
            "     }",
            "-    type_sym = lookup_string_reference(P, local, m->value.s.s, m->value.s.len);",
            "+    type_sym = lookup_string_reference(P, local, m->value.s.s, (size_t)m->value.s.len);",
            "     if (!type_sym) {",
            "-        error_tok_as_string(P, m->ident, \"nested reference not found\", m->value.s.s, m->value.s.len);",
            "+        error_tok_as_string(P, m->ident, \"nested reference not found\", m->value.s.s, (size_t)m->value.s.len);",
            "         return -1;",
            "     }",
            "     if (type_sym->kind != fb_is_table) {",
            "         if (!P->opts.allow_struct_root) {",
            "             error_tok_2(P, m->ident, \"nested reference does not refer to a table\", type_sym->ident);",
            "             return -1;",
            "         }",
            "@@ -640,15 +656,15 @@",
            " ",
            " static int process_struct(fb_parser_t *P, fb_compound_type_t *ct)",
            " {",
            "     fb_symbol_t *sym, *old, *type_sym;",
            "     fb_member_t *member;",
            "     fb_metadata_t *knowns[KNOWN_ATTR_COUNT], *m;",
            "     uint16_t allow_flags;",
            "-    int key_count = 0;",
            "+    int key_count = 0, primary_count = 0, key_ok = 0;",
            " ",
            "     if (ct->type.type) {",
            "         error_sym(P, &ct->symbol, \"internal error: struct cannot have a type\");",
            "         return -1;",
            "     }",
            "     ct->metadata_flags = process_metadata(P, ct->metadata, fb_f_force_align, knowns);",
            "     if ((m = knowns[fb_attr_force_align])) {",
            "@@ -664,79 +680,130 @@",
            "             error_sym_2(P, sym, \"struct field already defined here\", old);",
            "             continue;",
            "         }",
            "         if (sym->kind != fb_is_member) {",
            "             error_sym(P, sym, \"internal error: field type expected\");",
            "             return -1;",
            "         }",
            "+        key_ok = 1;",
            "         member = (fb_member_t *)sym;",
            "         allow_flags = 0;",
            "         /* Notice the difference between fb_f_ and fb_attr_ (flag vs index). */",
            "         if (P->opts.allow_struct_field_key) {",
            "             allow_flags |= fb_f_key;",
            "+            if (P->opts.allow_primary_key) {",
            "+                allow_flags |= fb_f_primary_key;",
            "+            }",
            "         }",
            "         if (P->opts.allow_struct_field_deprecate) {",
            "             allow_flags |= fb_f_deprecated;",
            "         }",
            "         member->metadata_flags = process_metadata(P, member->metadata, allow_flags, knowns);",
            "         switch (member->type.type) {",
            "+        case vt_fixed_array_type_ref:",
            "+            key_ok = 0;",
            "+            fallthrough;",
            "         case vt_type_ref:",
            "             type_sym = lookup_type_reference(P, ct->scope, member->type.ref);",
            "             if (!type_sym) {",
            "                 error_ref_sym(P, member->type.ref, \"unknown type reference used with struct field\", sym);",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "             member->type.ct = (fb_compound_type_t*)type_sym;",
            "-            member->type.type = vt_compound_type_ref;",
            "+            member->type.type = member->type.type == vt_fixed_array_type_ref ?",
            "+                vt_fixed_array_compound_type_ref : vt_compound_type_ref;",
            "             if (type_sym->kind != fb_is_struct) {",
            "                 if (P->opts.allow_enum_struct_field) {",
            "                     if (type_sym->kind != fb_is_enum) {",
            "-                        error_sym_2(P, sym, \"struct fields can only be scalars, structs, and enums, but has type\", type_sym);",
            "+                        error_sym_2(P, sym, \"struct fields can only be scalars, structs, and enums, or arrays of these, but has type\", type_sym);",
            "                         member->type.type = vt_invalid;",
            "                         return -1;",
            "                     }",
            "-                    if (member->metadata_flags & fb_f_key) {",
            "-                        if (!P->opts.allow_enum_key) {",
            "-                            error_sym(P, sym, \"key attribute now allowed for this kind of field\");",
            "-                            member->type.type = vt_invalid;",
            "-                            return -1;",
            "-                        }",
            "-                        key_count++;",
            "+                    if (!P->opts.allow_enum_key) {",
            "+                        key_ok = 0;",
            "+                        break;",
            "                     }",
            "                 } else {",
            "-                    error_sym_2(P, sym, \"struct fields can only be scalars and structs, but has type\", type_sym);",
            "+                    error_sym_2(P, sym, \"struct fields can only be scalars and structs, or arrays of these, but has type\", type_sym);",
            "                     member->type.type = vt_invalid;",
            "                     return -1;",
            "                 }",
            "             } else {",
            "-                if (member->metadata_flags & fb_f_key) {",
            "-                    error_sym(P, sym, \"key attribute now allowed for this kind of field\");",
            "-                    member->type.type = vt_invalid;",
            "-                    return -1;",
            "-                }",
            "+                key_ok = 0;",
            "             }",
            "             break;",
            "+        case vt_fixed_array_string_type:",
            "+            error_sym(P, sym, \"fixed length arrays cannot have string elements\");",
            "+            member->type.type = vt_invalid;",
            "+            return -1;",
            "+        case vt_fixed_array_type:",
            "+            key_ok = 0;",
            "+            break;",
            "         case vt_scalar_type:",
            "-            if (member->metadata_flags & fb_f_key) {",
            "-                key_count++;",
            "-            }",
            "             break;",
            "         default:",
            "-            error_sym(P, sym, \"struct member member can only be of struct or scalar type\");",
            "+            error_sym(P, sym, \"struct member member can only be of struct scalar, or fixed length scalar array type\");",
            "             return -1;",
            "         }",
            "+        if (!key_ok) {",
            "+            if (member->metadata_flags & fb_f_key) {",
            "+                member->type.type = vt_invalid;",
            "+                error_sym(P, sym, \"key attribute now allowed for this kind of field\");",
            "+                return -1;",
            "+            }",
            "+            if (member->metadata_flags & fb_f_primary_key) {",
            "+                member->type.type = vt_invalid;",
            "+                error_sym(P, sym, \"primary_key attribute now allowed for this kind of field\");",
            "+                return -1;",
            "+            }",
            "+        }",
            "+        if (member->metadata_flags & fb_f_deprecated) {",
            "+            if (member->metadata_flags & fb_f_key) {",
            "+                error_sym(P, sym, \"key attribute not allowed for deprecated struct member\");",
            "+                return -1;",
            "+            } else if (member->metadata_flags & fb_f_primary_key) {",
            "+                error_sym(P, sym, \"primary_key attribute not allowed for deprecated struct member\");",
            "+                return -1;",
            "+            }",
            "+        }",
            "+        if (member->metadata_flags & fb_f_key) {",
            "+            if (member->metadata_flags & fb_f_primary_key) {",
            "+                error_sym(P, sym, \"primary_key attribute conflicts with key attribute\");",
            "+                member->type.type = vt_invalid;",
            "+                return -1;",
            "+            }",
            "+            key_count++;",
            "+            if (!ct->primary_key) {",
            "+                /* First key is primary key if no primary key is given explicitly. */",
            "+                ct->primary_key = member;",
            "+            }",
            "+        } else if (member->metadata_flags & fb_f_primary_key) {",
            "+            if (primary_count++) {",
            "+                error_sym(P, sym, \"at most one struct member can have a primary_key attribute\");",
            "+                member->type.type = vt_invalid;",
            "+                return -1;",
            "+            }",
            "+            key_count++;",
            "+            /* Allow backends to treat primary key as an ordinary key. */",
            "+            member->metadata_flags |= fb_f_key;",
            "+            ct->primary_key = member;",
            "+        }",
            "         if (member->value.type) {",
            "             error_sym(P, sym, \"struct member member cannot have a default value\");",
            "             continue;",
            "         }",
            "     }",
            "     if (key_count) {",
            "         ct->symbol.flags |= fb_indexed;",
            "     }",
            "+    /* Set primary key flag for backends even if chosen by default. */",
            "+    if (ct->primary_key) {",
            "+        ct->primary_key->metadata_flags |= fb_f_primary_key;",
            "+    }",
            "     if (key_count > 1 && !P->opts.allow_multiple_key_fields) {",
            "         error_sym(P, &ct->symbol, \"table has multiple key fields, but at most one is permitted\");",
            "         return -1;",
            "     }",
            "     return 0;",
            " }",
            " ",
            "@@ -782,31 +849,30 @@",
            "                 break;",
            "             case fb_is_union:",
            "                 /*",
            "                  * Unions align to their offsets because the type can",
            "                  * always be added last in a second pass since it is 1",
            "                  * byte.",
            "                  */",
            "-                k = P->opts.offset_size;",
            "+                k = (uint16_t)P->opts.offset_size;",
            "                 break;",
            "             default:",
            "-                k = P->opts.offset_size;",
            "+                k = (uint16_t)P->opts.offset_size;",
            "                 break;",
            "             }",
            "             break;",
            "         case vt_vector_compound_type_ref:",
            "         case vt_string_type:",
            "         case vt_vector_type:",
            "         case vt_vector_string_type:",
            "-            k = P->opts.offset_size;",
            "+            k = (uint16_t)P->opts.offset_size;",
            "             break;",
            "         case vt_invalid:",
            "             /* Just to have some sane behavior. */",
            "-            // TODO: old",
            "-            //return original_order_members(P, members);",
            "+            return original_order_members(P, members);",
            "         default:",
            "             k = next->align;",
            "             break;",
            "         }",
            "         assert(k > 0);",
            "         i = 0;",
            "         while (k >>= 1) {",
            "@@ -844,18 +910,19 @@",
            "     fb_symbol_t *sym, *old, *type_sym;",
            "     fb_member_t *member;",
            "     fb_metadata_t *knowns[KNOWN_ATTR_COUNT], *m;",
            "     int ret = 0;",
            "     uint64_t count = 0;",
            "     int need_id = 0, id_failed = 0;",
            "     uint64_t max_id = 0;",
            "-    int key_ok, key_count = 0;",
            "-    int is_union_vector;",
            "+    int key_ok, key_count = 0, primary_count = 0;",
            "+    int is_union_vector, is_vector;",
            "     uint64_t i, j;",
            "     int max_id_errors = 10;",
            "+    int allow_flags = 0;",
            " ",
            "     /*",
            "      * This just tracks the presence of a `normal_field` or a hidden",
            "      * `type_field`.  The size is litmited to 16-bit unsigned offsets.",
            "      * It is only of relevance for ithe optional `id` table field",
            "      * attribute.",
            "      */",
            "@@ -869,14 +936,16 @@",
            "     /*",
            "      * `original_order` now lives as a flag, we need not consider it",
            "      * further until code generation.",
            "      */",
            "     for (sym = ct->members; sym; sym = sym->link) {",
            "         key_ok = 0;",
            "         type_sym = 0;",
            "+        is_vector = 0;",
            "+        is_union_vector = 0;",
            "         if ((old = define_fb_symbol(&ct->index, sym))) {",
            "             error_sym_2(P, sym, \"table member already defined here\", old);",
            "             continue;",
            "         }",
            "         if (sym->kind != fb_is_member) {",
            "             error_sym(P, sym, \"internal error: member type expected\");",
            "             return -1;",
            "@@ -884,23 +953,25 @@",
            "         member = (fb_member_t *)sym;",
            "         if (member->type.type == vt_invalid) {",
            "             continue;",
            "         }",
            "         if (member->type.type == vt_scalar_type || member->type.type == vt_vector_type) {",
            "             member->type.st = map_scalar_token_type(member->type.t);",
            "         }",
            "-        member->metadata_flags = process_metadata(P, member->metadata,",
            "+        allow_flags =",
            "                 fb_f_id | fb_f_nested_flatbuffer | fb_f_deprecated | fb_f_key |",
            "-                fb_f_required | fb_f_hash | fb_f_base64 | fb_f_base64url, knowns);",
            "+                fb_f_required | fb_f_hash | fb_f_base64 | fb_f_base64url | fb_f_sorted;",
            "+",
            "+        if (P->opts.allow_primary_key) {",
            "+            allow_flags |= fb_f_primary_key;",
            "+        }",
            "+        member->metadata_flags = process_metadata(P, member->metadata, (uint16_t)allow_flags, knowns);",
            "         if ((m = knowns[fb_attr_nested_flatbuffer])) {",
            "             define_nested_table(P, ct->scope, member, m);",
            "         }",
            "-        if ((member->metadata_flags & fb_f_required) && member->type.type == vt_scalar_type) {",
            "-            error_sym(P, sym, \"'required' attribute is redundant on scalar table field\");",
            "-        }",
            "         /* Note: we allow base64 and base64url with nested attribute. */",
            "         if ((member->metadata_flags & fb_f_base64) &&",
            "                 (member->type.type != vt_vector_type || member->type.st != fb_ubyte)) {",
            "             error_sym(P, sym, \"'base64' attribute is only allowed on vectors of type ubyte\");",
            "         }",
            "         if ((member->metadata_flags & fb_f_base64url) &&",
            "                 (member->type.type != vt_vector_type || member->type.st != fb_ubyte)) {",
            "@@ -920,60 +991,79 @@",
            "             if (count >= P->opts.vt_max_count) {",
            "                 error_sym(P, sym, \"too many fields for vtable size\");",
            "                 id_failed = 1;",
            "             } else if (!need_id) {",
            "                 member->id = (unsigned short)count;",
            "             }",
            "             ++count;",
            "-        } ",
            "+        }",
            "         switch (member->type.type) {",
            "         case vt_scalar_type:",
            "+            if (member->value.type == vt_null) {",
            "+                member->value.type = vt_uint;",
            "+                member->value.u = 0;",
            "+                member->flags |= fb_fm_optional;",
            "+            }",
            "+            if (member->metadata_flags & fb_f_required) {",
            "+                if (member->flags & fb_fm_optional) {",
            "+                    error_sym(P, sym, \"'required' attribute is incompatible with optional table field (= null)\");",
            "+                } else {",
            "+                    error_sym(P, sym, \"'required' attribute is redundant on scalar table field\");",
            "+                }",
            "+            }",
            "             key_ok = 1;",
            "             if (member->value.type == vt_name_ref) {",
            "                 if (lookup_enum_name(P, ct->scope, 0, member->value.ref, &member->value)) {",
            "                     error_ref_sym(P, member->value.ref, \"unknown name used as initializer for scalar field\", sym);",
            "                     member->type.type = vt_invalid;",
            "                     continue;",
            "                 }",
            "             }",
            "             if (!member->value.type) {",
            "                 /*",
            "                  * Simplifying by ensuring we always have a default",
            "-                 * value where an initializer is possible (also goes for enum",
            "-                 * above).",
            "+                 * value where an initializer is possible (also goes for enum).",
            "                  */",
            "                 member->value.type = vt_uint;",
            "                 member->value.u = 0;",
            "             }",
            "             if (fb_coerce_scalar_type(P, sym, member->type.st, &member->value)) {",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "             member->size = sizeof_scalar_type(member->type.st);",
            "             member->align = (uint16_t)member->size;",
            "             break;",
            "         case vt_vector_type:",
            "+            is_vector = 1;",
            "             member->size = sizeof_scalar_type(member->type.st);",
            "             member->align =(uint16_t) member->size;",
            "             if (member->value.type) {",
            "                 error_sym(P, sym, \"scalar vectors cannot have an initializer\");",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "             break;",
            "+        case vt_fixed_array_type_ref:",
            "+        case vt_fixed_array_string_type:",
            "+        case vt_fixed_array_type:",
            "+            error_sym(P, sym, \"fixed length arrays can only be used with structs\");",
            "+            member->type.type = vt_invalid;",
            "+            return -1;",
            "         case vt_string_type:",
            "             /* `size` or `align` not defined - these are implicit uoffset types. */",
            "             key_ok = P->opts.allow_string_key;",
            "             if (member->value.type) {",
            "                 error_sym(P, sym, \"strings cannot have an initializer\");",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "             break;",
            "         case vt_vector_string_type:",
            "+            is_vector = 1;",
            "             /* `size` or `align` not defined - these are implicit uoffset types. */",
            "             if (member->value.type) {",
            "                 error_sym(P, sym, \"string vectors cannot have an initializer\");",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "             break;",
            "@@ -984,16 +1074,32 @@",
            "                 member->type.type = vt_invalid;",
            "                 /* We cannot count id's without knowing if it is a union. */",
            "                 id_failed = 1;",
            "                 continue;",
            "             }",
            "             switch (type_sym->kind) {",
            "             case fb_is_enum:",
            "+                /*",
            "+                 * Note the enums without a 0 element requires an",
            "+                 * initializer in the schema, but that cannot happen",
            "+                 * with a null value, so in this case the value is force",
            "+                 * to 0. This is only relevant when using the `_get()`",
            "+                 * accessor instead of the `_option()`.",
            "+                 */",
            "+                if (member->value.type == vt_null) {",
            "+                    member->value.type = vt_uint;",
            "+                    member->value.u = 0;",
            "+                    member->flags |= fb_fm_optional;",
            "+                }",
            "                 if (member->metadata_flags & fb_f_required) {",
            "-                    error_sym(P, sym, \"'required' attribute is redundant on enum table field\");",
            "+                    if (member->flags & fb_fm_optional) {",
            "+                        error_sym(P, sym, \"'required' attribute is incompatible with optional enum table field (= null)\");",
            "+                    } else {",
            "+                        error_sym(P, sym, \"'required' attribute is redundant on enum table field\");",
            "+                    }",
            "                 }",
            "                 key_ok = P->opts.allow_enum_key;",
            "                 break;",
            "             case fb_is_table:",
            "             case fb_is_struct:",
            "             case fb_is_union:",
            "                 break;",
            "@@ -1036,15 +1142,17 @@",
            "                         continue;",
            "                     }",
            "                 } else {",
            "                     if (fb_coerce_scalar_type(P, sym, ((fb_compound_type_t *)type_sym)->type.st, &member->value)) {",
            "                         member->type.type = vt_invalid;",
            "                         continue;",
            "                     }",
            "-                    if (P->opts.strict_enum_init) {",
            "+                    /* Bitflags can have complex combinations of values, and do not nativele have a 0 value. */",
            "+                    if (P->opts.strict_enum_init && !(member->type.ct->metadata_flags & fb_f_bit_flags)",
            "+                            && !(member->flags & fb_fm_optional)) {",
            "                         if (!is_in_value_set(&member->type.ct->value_set, &member->value)) {",
            "                             error_sym(P, sym, \"initializer does not match a defined enum value\");",
            "                             member->type.type = vt_invalid;",
            "                             continue;",
            "                         }",
            "                     }",
            "                 }",
            "@@ -1054,14 +1162,15 @@",
            "                     member->value.type = vt_uint;",
            "                     member->value.u = 0;",
            "                     if (fb_coerce_scalar_type(P, type_sym, ((fb_compound_type_t *)type_sym)->type.st, &member->value)) {",
            "                         member->type.type = vt_invalid;",
            "                         continue;",
            "                     }",
            "                     if (P->opts.strict_enum_init) {",
            "+                        /* TODO: consider if this error is necessary for bit_flags - flatc 2.0.0 errors on this. */",
            "                         if (!is_in_value_set(&member->type.ct->value_set, &member->value)) {",
            "                             error_sym_2(P, sym,",
            "                                     \"enum type requires an explicit initializer because it has no 0 value\", type_sym);",
            "                             member->type.type = vt_invalid;",
            "                             continue;",
            "                         }",
            "                     }",
            "@@ -1083,14 +1192,16 @@",
            "                 break;",
            "             default:",
            "                 /* Vectors of strings are handled separately but this is irrelevant to the user. */",
            "                 error_sym_tok(P, sym, \"vectors can only hold scalars, structs, enums, strings, tables, and unions\", member->type.t);",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "+            is_vector = 1;",
            "+            is_union_vector = type_sym->kind == fb_is_union;",
            "             if (member->value.type) {",
            "                 error_sym(P, sym, \"non-scalar field cannot have an initializer\");",
            "                 member->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "             /* Size of the vector element, not of the vector itself. */",
            "             member->type.type = vt_vector_compound_type_ref;",
            "@@ -1143,19 +1254,18 @@",
            "                 id_failed = normal_field;",
            "             } else if (field_marker[member->id]) {",
            "                 error_tok(P, m->ident, \"id attribute value conflicts with another field\");",
            "             } else {",
            "                 field_marker[member->id] = normal_field;",
            "             }",
            "             if (!id_failed && type_sym && type_sym->kind == fb_is_union) {",
            "-                is_union_vector = member->type.type == vt_vector_type_ref;",
            "                 if (member->id <= 1) {",
            "                     error_tok(P, m->ident, is_union_vector ?",
            "-                            \"id attribute value should be larger to accomdate hidden union vector type field\" :",
            "-                            \"id attribute value should be larger to accomdate hidden union type field\");",
            "+                            \"id attribute value should be larger to accommodate hidden union vector type field\" :",
            "+                            \"id attribute value should be larger to accommodate hidden union type field\");",
            "                     id_failed = 1;",
            "                 } else if (field_marker[member->id - 1] == type_field) {",
            "                     error_tok(P, m->ident, is_union_vector ?",
            "                             \"hidden union vector type field below attribute id value conflicts with another hidden type field\" :",
            "                             \"hidden union type field below attribute id value conflicts with another hidden type field\");",
            "                     id_failed = 1;",
            "                 } else if (field_marker[member->id - 1]) {",
            "@@ -1164,19 +1274,69 @@",
            "                             \"hidden union type field below attribute id value conflicts with another field\");",
            "                     id_failed = 1;",
            "                 } else {",
            "                     field_marker[member->id - 1] = type_field;",
            "                 }",
            "             }",
            "         }",
            "+        if (member->metadata_flags & fb_f_deprecated) {",
            "+            if (member->metadata_flags & fb_f_key) {",
            "+                error_sym(P, sym, \"key attribute not allowed for deprecated field\");",
            "+                return -1;",
            "+            } else if (member->metadata_flags & fb_f_primary_key) {",
            "+                error_sym(P, sym, \"primary_key attribute not allowed for deprecated field\");",
            "+                return -1;",
            "+            }",
            "+        }",
            "         if (member->metadata_flags & fb_f_key) {",
            "             ++key_count;",
            "             if (!key_ok) {",
            "                 error_sym(P, sym, \"key attribute not allowed for this kind of field\");",
            "+                member->type.type = vt_invalid;",
            "+            } else if (member->metadata_flags & fb_f_primary_key) {",
            "+                error_sym(P, sym, \"primary_key attribute conflicts with key attribute\");",
            "+                member->type.type = vt_invalid;",
            "+            } else if (!ct->primary_key ||",
            "+                    (primary_count == 0 && ct->primary_key->id > member->id)) {",
            "+                /*",
            "+                 * Set key field with lowest id as default primary key",
            "+                 * unless a key field also has a primary attribute.",
            "+                 */",
            "+                ct->primary_key = member;",
            "+            }",
            "+        } else if (member->metadata_flags & fb_f_primary_key) {",
            "+            if (member->metadata_flags & fb_f_primary_key) {",
            "+                if (primary_count++) {",
            "+                    error_sym(P, sym, \"at most one field can have a primary_key attribute\");",
            "+                    member->type.type = vt_invalid;",
            "+                    continue;",
            "+                } else {",
            "+                    ct->primary_key = member;",
            "+                }",
            "             }",
            "+            key_count++;",
            "+            /* Allow backends to treat primary key as an ordinary key. */",
            "+            member->metadata_flags |= fb_f_key;",
            "+        }",
            "+        if (member->metadata_flags & fb_f_sorted) {",
            "+            if (is_union_vector) {",
            "+                error_sym(P, sym, \"sorted attribute not allowed for union vectors\");",
            "+                member->type.type = vt_invalid;",
            "+                return -1;",
            "+            } else if (!is_vector) {",
            "+                error_sym(P, sym, \"sorted attribute only allowed for vectors\");",
            "+                member->type.type = vt_invalid;",
            "+                return -1;",
            "+            }",
            "+            /*",
            "+             * A subsequent call to validate_table_attr will verify that a",
            "+             * sorted vector of tables or structs have a defined field",
            "+             * key. This cannot be done before all types have been",
            "+             * processed.",
            "+             */",
            "         }",
            "     }",
            "     if (!id_failed) {",
            "         ct->count = count;",
            "     }",
            "     if (!id_failed && need_id) {",
            "         if (count && max_id >= count) {",
            "@@ -1193,18 +1353,18 @@",
            "             id_failed = 1;",
            "         }",
            "     }",
            "     /* Order in which data is ordered in binary buffer. */",
            "     if (ct->metadata_flags & fb_f_original_order) {",
            "         ct->ordered_members = original_order_members(P, (fb_member_t *)ct->members);",
            "     } else {",
            "-        /* Size efficient ordering. */ ",
            "+        /* Size efficient ordering. */",
            "         ct->ordered_members = align_order_members(P, (fb_member_t *)ct->members);",
            "     }",
            "-    if (!id_failed && count > 0) {",
            "+    if (!id_failed && need_id && count > 0) {",
            "         field_index = P->tmp_field_index;",
            "         memset(field_index, 0, sizeof(field_index[0]) * (size_t)P->opts.vt_max_count);",
            "         /*",
            "          * Reorder by id so table constructor arguments in code",
            "          * generators always use same ordering across versions.",
            "          */",
            "         for (sym = ct->members; sym; sym = sym->link) {",
            "@@ -1212,34 +1372,78 @@",
            "             field_index[member->id] = sym;",
            "         }",
            "         j = 0;",
            "         if (field_index[0] == 0) {",
            "             j = 1; /* Adjust for union type. */",
            "         }",
            "         ct->members = field_index[j];",
            "-        for (i = j + 1; i < max_id; ++i) {",
            "+        for (i = j + 1; i <= max_id; ++i) {",
            "             if (field_index[i] == 0) ++i; /* Adjust for union type. */",
            "             field_index[j]->link = field_index[i];",
            "             j = i;",
            "         }",
            "+        field_index[max_id]->link = 0;",
            "     }",
            "     if (key_count) {",
            "         ct->symbol.flags |= fb_indexed;",
            "     }",
            "+    /* Set primary key flag for backends even if chosen by default. */",
            "+    if (ct->primary_key) {",
            "+        ct->primary_key->metadata_flags |= fb_f_primary_key;",
            "+    }",
            "     if (key_count > 1 && !P->opts.allow_multiple_key_fields) {",
            "         error_sym(P, &ct->symbol, \"table has multiple key fields, but at most one is permitted\");",
            "         ret = -1;",
            "     }",
            "     if (id_failed) {",
            "         ret = -1;",
            "     }",
            "     return ret;",
            " }",
            " ",
            " /*",
            "+ * Post processing of process_table because some information is only",
            "+ * available when all types have been processed.",
            "+ */",
            "+static int validate_table_attr(fb_parser_t *P, fb_compound_type_t *ct)",
            "+{",
            "+    fb_symbol_t *sym;",
            "+    fb_member_t *member;",
            "+",
            "+    for (sym = ct->members; sym; sym = sym->link) {",
            "+        member = (fb_member_t *)sym;",
            "+        if (member->metadata_flags & fb_f_deprecated) {",
            "+            continue;",
            "+        }",
            "+",
            "+        if (member->type.type == vt_vector_compound_type_ref &&",
            "+                member->metadata_flags & fb_f_sorted) {",
            "+            switch (member->type.ct->symbol.kind) {",
            "+            case fb_is_table:",
            "+                if (!member->type.ct->primary_key) {",
            "+                    error_sym(P, sym, \"sorted table vector only valid when table has a key field\");",
            "+                    return -1;",
            "+                }",
            "+                break;",
            "+            case fb_is_struct:",
            "+                if (!member->type.ct->primary_key) {",
            "+                    error_sym(P, sym, \"sorted struct vector only valid when struct has a key field\");",
            "+                    return -1;",
            "+                }",
            "+                break;",
            "+            /* Other cases already handled in process_table. */",
            "+            default:",
            "+                continue;",
            "+            }",
            "+        }",
            "+    }",
            "+    return 0;",
            "+}",
            "+",
            "+/*",
            "  * The parser already makes sure we have exactly one request type,",
            "  * one response type, and no initializer.",
            "  *",
            "  * We are a bit heavy on flagging attributes because their behavior",
            "  * isn't really specified at this point.",
            "  */",
            " static int process_rpc_service(fb_parser_t *P, fb_compound_type_t *ct)",
            "@@ -1340,15 +1544,15 @@",
            " }",
            " ",
            " static int process_enum(fb_parser_t *P, fb_compound_type_t *ct)",
            " {",
            "     fb_symbol_t *sym, *old, *type_sym;",
            "     fb_member_t *member;",
            "     fb_metadata_t *knowns[KNOWN_ATTR_COUNT];",
            "-    fb_value_t index;",
            "+    fb_value_t index = { { { 0 } }, 0, 0 };",
            "     fb_value_t old_index;",
            "     int first = 1;",
            "     int bit_flags = 0;",
            "     int is_union = ct->symbol.kind == fb_is_union;",
            " ",
            "     if (!is_union) {",
            "         assert(ct->symbol.kind == fb_is_enum);",
            "@@ -1439,19 +1643,19 @@",
            "         /* Enum / union values cannot have metadata. */",
            "         assert(member->metadata == 0);",
            "         if (is_union) {",
            "             if (member->symbol.ident == &P->t_none) {",
            "                 /* Handle implicit NONE specially. */",
            "                 member->type.type = vt_missing;",
            "             } else if (member->type.type == vt_string_type) {",
            "-\t\t\t\tmember->size = 0;",
            "+                member->size = 0;",
            "             } else if (member->type.type != vt_type_ref) {",
            "                 if (member->type.type != vt_invalid) {",
            "                     error_sym(P, sym, \"union member type must be string or a reference to a table or a struct\");",
            "-                \tmember->type.type = vt_invalid;",
            "+                    member->type.type = vt_invalid;",
            "                 }",
            "                 continue;",
            "             } else {",
            "                 type_sym = lookup_type_reference(P, ct->scope, member->type.ref);",
            "                 if (!type_sym) {",
            "                     error_ref_sym(P, member->type.ref, \"unknown type reference used with union member\", sym);",
            "                     member->type.type = vt_invalid;",
            "@@ -1498,33 +1702,33 @@",
            "                     index = member->value;",
            "                 }",
            "             }",
            "             if (index.u >= sizeof_scalar_type(ct->type.st) * 8) {",
            "                 error_sym(P, sym, \"enum value out of range when used with 'bit_flags'\");",
            "                 return -1;",
            "             }",
            "-            member->value.u = 1LL << index.u;",
            "+            member->value.u = UINT64_C(1) << index.u;",
            "             member->value.type = vt_uint;",
            "             if (fb_coerce_scalar_type(P, sym, ct->type.st, &member->value)) {",
            "                  /* E.g. enumval = 15 causes signed overflow with short. */",
            "                 error_sym(P, sym, \"enum value out of range when used with 'bit_flags'\");",
            "                 return -1;",
            "             }",
            "         } else {",
            "             if (member->value.type) {",
            "                 index = member->value;",
            "-                /*",
            "-                 * Captures errors in user assigned values. Also captures",
            "-                 * overflow on auto-increment on all types except maximum",
            "-                 * representation size, i.e. long or ulong which we handled",
            "-                 * above.",
            "-                 */",
            "-                if (fb_coerce_scalar_type(P, sym, ct->type.st, &index)) {",
            "-                    return -1;",
            "-                }",
            "+            }",
            "+            /*",
            "+             * Captures errors in user assigned values. Also captures",
            "+             * overflow on auto-increment on all types except maximum",
            "+             * representation size, i.e. long or ulong which we handled",
            "+             * above.",
            "+             */",
            "+            if (fb_coerce_scalar_type(P, sym, ct->type.st, &index)) {",
            "+                return -1;",
            "             }",
            "             member->value = index;",
            "         }",
            "         if (!first && P->opts.ascending_enum) {",
            "             /* Without ascending enum we also allow duplicate values (but not names). */",
            "             if ((index.type == vt_uint && index.u <= old_index.u) ||",
            "                     (index.type == vt_int && index.i <= old_index.i)) {",
            "@@ -1606,15 +1810,21 @@",
            "     /*",
            "      * Known attributes will be pre-defined if not provided by the",
            "      * user. After that point, all attribute references must be",
            "      * defined.",
            "      */",
            "     for (a = (fb_attribute_t *)S->attributes; a; a = (fb_attribute_t *)a->name.link) {",
            "         if ((old_name = define_fb_name(&S->root_schema->attribute_index, &a->name))) {",
            "+            /*",
            "+             * Allow attributes to be defined multiple times, including",
            "+             * known attributes.",
            "+             */",
            "+#if 0",
            "             error_name(P, &a->name, \"attribute already defined\");",
            "+#endif",
            "         }",
            "     }",
            "     install_known_attributes(P);",
            " ",
            "     if (!P->opts.hide_later_enum) {",
            "         for (sym = S->symbols; sym; sym = sym->link) {",
            "             switch (sym->kind) {",
            "@@ -1706,29 +1916,29 @@",
            "             /* Only now is the full struct size available. */",
            "             if (ct->type.type != vt_invalid && process_rpc_service(P, ct)) {",
            "                 ct->type.type = vt_invalid;",
            "                 continue;",
            "             }",
            "         }",
            "     }",
            "-    revert_order(&P->schema.ordered_structs);",
            "-//TODO: old",
            "-    /*",
            "     for (sym = P->schema.symbols; sym; sym = sym->link) {",
            "         switch (sym->kind) {",
            "         case fb_is_table:",
            "             ct = (fb_compound_type_t *)sym;",
            "-            if (ct->metadata_flags & fb_f_original_order) {",
            "-                ct->ordered_members = original_order_members(P, (fb_member_t *)ct->members);",
            "-            } else {",
            "-                ct->ordered_members = align_order_members(P, (fb_member_t *)ct->members);",
            "+            /*",
            "+             * Some table attributes depend on attributes on members and",
            "+             * therefore can only be validated after procesing.",
            "+             */",
            "+            if (ct->type.type != vt_invalid && validate_table_attr(P, ct)) {",
            "+                ct->type.type = vt_invalid;",
            "+                continue;",
            "             }",
            "         }",
            "     }",
            "-    */",
            "+    revert_order(&P->schema.ordered_structs);",
            "     if (!S->root_type.name) {",
            "         if (P->opts.require_root_type) {",
            "             error(P, \"root type not declared\");",
            "         }",
            "     } else {",
            "         sym = S->root_type.type = lookup_type_reference(P,",
            "                 S->root_type.scope, S->root_type.name);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/compiler/symbols.h",
          "change": [
            "--- /home/flatcc-0.5.3/src/compiler/symbols.h",
            "+++ /home/flatcc-0.6.1/src/compiler/symbols.h",
            "@@ -33,23 +33,25 @@",
            " typedef struct fb_root_type fb_root_type_t;",
            " typedef struct fb_schema fb_schema_t;",
            " ",
            " enum {",
            "     tok_kw_base = LEX_TOK_KW_BASE,",
            "     tok_kw_bool,",
            "     tok_kw_byte,",
            "+    tok_kw_char,",
            "     tok_kw_enum,",
            "     tok_kw_float32,",
            "     tok_kw_float64,",
            "     tok_kw_int,",
            "     tok_kw_int8,",
            "     tok_kw_int16,",
            "     tok_kw_int32,",
            "     tok_kw_int64,",
            "     tok_kw_long,",
            "+    tok_kw_null,",
            "     tok_kw_true,",
            "     tok_kw_uint,",
            "     tok_kw_false,",
            "     tok_kw_float,",
            "     tok_kw_short,",
            "     tok_kw_table,",
            "     tok_kw_ubyte,",
            "@@ -66,14 +68,15 @@",
            "     tok_kw_include,",
            "     tok_kw_attribute,",
            "     tok_kw_namespace,",
            "     tok_kw_root_type,",
            "     tok_kw_rpc_service,",
            "     tok_kw_file_extension,",
            "     tok_kw_file_identifier,",
            "+    LEX_TOK_KW_END,",
            "     /* Pseudo keywords. */",
            "     tok_kw_doc_comment",
            " };",
            " ",
            " struct fb_token {",
            "     const char *text;",
            "     long len;",
            "@@ -91,35 +94,50 @@",
            "     fb_bool,",
            "     fb_long,",
            "     fb_int,",
            "     fb_short,",
            "     fb_byte,",
            "     fb_double,",
            "     fb_float,",
            "+    fb_char,",
            " };",
            " ",
            " typedef enum fb_scalar_type fb_scalar_type_t;",
            " ",
            "+static inline size_t sizeof_scalar_type(fb_scalar_type_t st)",
            "+{",
            "+    static const size_t scalar_type_size[] = {",
            "+        0, 8, 4, 2, 1, 1, 8, 4, 2, 1, 8, 4, 1",
            "+    };",
            "+",
            "+    return scalar_type_size[st];",
            "+}",
            "+",
            " enum fb_value_type {",
            "     vt_missing = 0,",
            "     vt_invalid = 1,",
            "+    vt_null,",
            "     vt_string,",
            "     vt_float,",
            "     vt_int,",
            "     vt_uint,",
            "     vt_bool,",
            "     vt_vector_type,",
            "     vt_scalar_type,",
            "     vt_vector_string_type,",
            "     vt_string_type,",
            "     vt_vector_type_ref,",
            "     vt_type_ref,",
            "     vt_name_ref,",
            "     vt_compound_type_ref,",
            "-    vt_vector_compound_type_ref",
            "+    vt_vector_compound_type_ref,",
            "+    vt_fixed_array_type,",
            "+    vt_fixed_array_type_ref,",
            "+    vt_fixed_array_string_type,",
            "+    vt_fixed_array_compound_type_ref",
            " };",
            " ",
            " struct fb_string {",
            "     char *s;",
            "     /* printf statements relies on this being int. */",
            "     int len;",
            " };",
            "@@ -133,14 +151,15 @@",
            "         uint8_t b;",
            "         fb_token_t *t;",
            "         fb_compound_type_t *ct;",
            "         fb_scalar_type_t st;",
            "         fb_ref_t *ref;",
            "     };",
            "     unsigned short type;",
            "+    uint32_t len;",
            " };",
            " ",
            " enum fb_kind {",
            "     fb_is_table,",
            "     fb_is_struct,",
            "     fb_is_rpc_service,",
            "     fb_is_enum,",
            "@@ -155,14 +174,18 @@",
            " enum fb_symbol_flags {",
            "     fb_circular_open = 1,",
            "     fb_circular_closed = 2,",
            "     fb_duplicate = 4,",
            "     fb_indexed = 8,",
            " };",
            " ",
            "+enum fb_member_flags {",
            "+    fb_fm_optional = 1",
            "+};",
            "+",
            " /*",
            "  * We keep the link first in all structs so that we can use a",
            "  * generic list reverse function after all symbols have been pushed",
            "  * within a scope.",
            "  */",
            " struct fb_symbol {",
            "     fb_symbol_t *link;",
            "@@ -199,14 +222,15 @@",
            "     uint16_t metadata_flags;",
            "     /*",
            "      * `align`, `offset` are for structs only.  64-bit allows for",
            "      * dynamically configured 64-bit file offsets. Align is restricted to",
            "      * at most 256 and must be a power of 2.",
            "      */",
            "     uint16_t align;",
            "+    uint16_t flags;",
            "     uint64_t offset;",
            "     uint64_t size;",
            " ",
            "     /* `id` is for table fields only. */",
            "     uint64_t id;",
            "     /*",
            "      * Resolved `nested_flatbuffer` attribute type. Always a table if",
            "@@ -233,14 +257,15 @@",
            "     fb_symbol_t symbol;",
            "     /* `scope` may span multiple input files, but has a unique namespace. */",
            "     fb_scope_t *scope;",
            "     /* Identifies the the schema the symbol belongs. */",
            "     fb_schema_t *schema;",
            "     fb_symbol_t *members;",
            "     fb_member_t *ordered_members;",
            "+    fb_member_t *primary_key;",
            "     fb_metadata_t *metadata;",
            "     fb_doc_t *doc;",
            "     fb_value_t type;",
            "     fb_symbol_table_t index;",
            "     /* Only for enums. */",
            "     fb_value_set_t value_set;",
            "     /* FNV-1a 32 bit hash of fully qualified name, accidental 0 maps to hash(\"\"). */",
            "@@ -251,15 +276,15 @@",
            "     /* `align`, `size` is for structs only. */",
            "     uint16_t align;",
            "     uint64_t size;",
            "     /* Sort structs with forward references. */",
            "     fb_compound_type_t *order;",
            "     /*",
            "      * Use by code generators. Only valid during export and may hold",
            "-     * garbage from a prevous export.",
            "+     * garbage from a previous export.",
            "      */",
            "     size_t export_index;",
            " };",
            " ",
            " enum fb_known_attributes {",
            "     fb_attr_unknown = 0,",
            "     fb_attr_id = 1,",
            "@@ -269,14 +294,16 @@",
            "     fb_attr_bit_flags = 5,",
            "     fb_attr_nested_flatbuffer = 6,",
            "     fb_attr_key = 7,",
            "     fb_attr_required = 8,",
            "     fb_attr_hash = 9,",
            "     fb_attr_base64 = 10,",
            "     fb_attr_base64url = 11,",
            "+    fb_attr_primary_key = 12,",
            "+    fb_attr_sorted = 13,",
            "     KNOWN_ATTR_COUNT",
            " };",
            " ",
            " enum fb_known_attribute_flags {",
            "     fb_f_unknown = 1 << fb_attr_unknown,",
            "     fb_f_id = 1 << fb_attr_id,",
            "     fb_f_deprecated = 1 << fb_attr_deprecated,",
            "@@ -284,15 +311,17 @@",
            "     fb_f_force_align = 1 << fb_attr_force_align,",
            "     fb_f_bit_flags = 1 << fb_attr_bit_flags,",
            "     fb_f_nested_flatbuffer = 1 << fb_attr_nested_flatbuffer,",
            "     fb_f_key = 1 << fb_attr_key,",
            "     fb_f_required = 1 << fb_attr_required,",
            "     fb_f_hash = 1 << fb_attr_hash,",
            "     fb_f_base64 = 1 << fb_attr_base64,",
            "-    fb_f_base64url = 1 << fb_attr_base64url",
            "+    fb_f_base64url = 1 << fb_attr_base64url,",
            "+    fb_f_primary_key = 1 << fb_attr_primary_key,",
            "+    fb_f_sorted = 1 << fb_attr_sorted,",
            " };",
            " ",
            " struct fb_attribute {",
            "     fb_name_t name;",
            "     unsigned int known;",
            " };",
            " ",
            "@@ -407,15 +436,15 @@",
            "     default:",
            "         break;",
            "     }",
            "     return ct;",
            " }",
            " ",
            " /* Constants are specific to 32-bit FNV-1a hash. It is important to use unsigned integers. */",
            "-static inline uint32_t fb_hash_fnv1a_32_init()",
            "+static inline uint32_t fb_hash_fnv1a_32_init(void)",
            " {",
            "     return 2166136261UL;",
            " }",
            " ",
            " static inline uint32_t fb_hash_fnv1a_32_append(uint32_t hash, const char *data, size_t len)",
            " {",
            "     while (len--) {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/runtime/builder.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/runtime/builder.c",
            "+++ /home/flatcc-0.6.1/src/runtime/builder.c",
            "@@ -11,15 +11,14 @@",
            "  *",
            "  * Mutable buffers are not supported in this version.",
            "  *",
            "  */",
            " ",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include <assert.h>",
            " ",
            " #include \"flatcc/flatcc_builder.h\"",
            " #include \"flatcc/flatcc_emitter.h\"",
            " ",
            " /*",
            "  * `check` is designed to handle incorrect use errors that can be",
            "  * ignored in production of a tested product.",
            "@@ -45,32 +44,29 @@",
            " {",
            "     const char *end = memchr(s, 0, max_len);",
            "     return end ? (size_t)(end - s) : max_len;",
            " }",
            " #undef strnlen",
            " #define strnlen pstrnlen",
            " ",
            "-/* `align` must be a power of 2. */",
            "-#define alignup(x, align) (((x) + (align) - 1) & ~((align) - 1))",
            "-",
            " /* Padding can be up to 255 zeroes, and 1 zero string termination byte.",
            "  * When two paddings are combined at nested buffers, we need twice that.",
            "  * Visible to emitter so it can test for zero padding in iov. */",
            " const uint8_t flatcc_builder_padding_base[512] = { 0 };",
            " #define _pad flatcc_builder_padding_base",
            " ",
            " #define uoffset_t flatbuffers_uoffset_t",
            " #define soffset_t flatbuffers_soffset_t",
            " #define voffset_t flatbuffers_voffset_t",
            " #define utype_t flatbuffers_utype_t",
            " ",
            "-#define store_uoffset __flatbuffers_uoffset_cast_to_pe",
            "-#define store_voffset  __flatbuffers_voffset_cast_to_pe",
            "-#define store_identifier __flatbuffers_uoffset_cast_to_pe",
            "-#define store_utype __flatbuffers_utype_cast_to_pe",
            "+#define write_uoffset __flatbuffers_uoffset_write_to_pe",
            "+#define write_voffset  __flatbuffers_voffset_write_to_pe",
            "+#define write_identifier __flatbuffers_uoffset_write_to_pe",
            "+#define write_utype __flatbuffers_utype_write_to_pe",
            " ",
            " #define field_size sizeof(uoffset_t)",
            " #define max_offset_count FLATBUFFERS_COUNT_MAX(field_size)",
            " #define union_size sizeof(flatcc_builder_union_ref_t)",
            " #define max_union_count FLATBUFFERS_COUNT_MAX(union_size)",
            " #define utype_size sizeof(utype_t)",
            " #define max_utype_count FLATBUFFERS_COUNT_MAX(utype_size)",
            "@@ -79,14 +75,27 @@",
            " #define identifier_size FLATBUFFERS_IDENTIFIER_SIZE",
            " ",
            " ",
            " #define iovec_t flatcc_iovec_t",
            " #define frame_size sizeof(__flatcc_builder_frame_t)",
            " #define frame(x) (B->frame[0].x)",
            " ",
            "+",
            "+/* `align` must be a power of 2. */",
            "+static inline uoffset_t alignup_uoffset(uoffset_t x, size_t align)",
            "+{",
            "+    return (x + (uoffset_t)align - 1u) & ~((uoffset_t)align - 1u);",
            "+}",
            "+",
            "+static inline size_t alignup_size(size_t x, size_t align)",
            "+{",
            "+    return (x + align - 1u) & ~(align - 1u);",
            "+}",
            "+",
            "+",
            " typedef struct vtable_descriptor vtable_descriptor_t;",
            " struct vtable_descriptor {",
            "     /* Where the vtable is emitted. */",
            "     flatcc_builder_ref_t vt_ref;",
            "     /* Which buffer it was emitted to. */",
            "     uoffset_t nest_id;",
            "     /* Where the vtable is cached. */",
            "@@ -263,40 +272,40 @@",
            "      * We calculate table field alignment relative to first entry, not",
            "      * header field with vtable offset.",
            "      *",
            "      * Note: >= comparison handles special case where B->ds is not",
            "      * allocated yet and size is 0 so the return value would be mistaken",
            "      * for an error.",
            "      */",
            "-    offset = alignup(B->ds_offset, align);",
            "+    offset = alignup_uoffset(B->ds_offset, align);",
            "     if ((B->ds_offset = offset + size) >= B->ds_limit) {",
            "         if (reserve_ds(B, B->ds_offset + 1, table_limit)) {",
            "             return 0;",
            "         }",
            "     }",
            "     B->vs[id] = (voffset_t)(offset + field_size);",
            "     if (id >= B->id_end) {",
            "-        B->id_end = id + 1;",
            "+        B->id_end = id + 1u;",
            "     }",
            "     return B->ds + offset;",
            " }",
            " ",
            " static inline void *push_ds_offset_field(flatcc_builder_t *B, voffset_t id)",
            " {",
            "     uoffset_t offset;",
            " ",
            "-    offset = alignup(B->ds_offset, field_size);",
            "+    offset = alignup_uoffset(B->ds_offset, field_size);",
            "     if ((B->ds_offset = offset + field_size) > B->ds_limit) {",
            "         if (reserve_ds(B, B->ds_offset, table_limit)) {",
            "             return 0;",
            "         }",
            "     }",
            "     B->vs[id] = (voffset_t)(offset + field_size);",
            "     if (id >= B->id_end) {",
            "-        B->id_end = id + 1;",
            "+        B->id_end = id + 1u;",
            "     }",
            "     *B->pl++ = (flatbuffers_voffset_t)offset;",
            "     return B->ds + offset;",
            " }",
            " ",
            " static inline void *reserve_buffer(flatcc_builder_t *B, int alloc_type, size_t used, size_t need, int zero_init)",
            " {",
            "@@ -309,40 +318,40 @@",
            "         }",
            "     }",
            "     return (void *)((size_t)buf->iov_base + used);",
            " }",
            " ",
            " static inline int reserve_fields(flatcc_builder_t *B, int count)",
            " {",
            "-    uoffset_t used, need;",
            "+    size_t used, need;",
            " ",
            "     /* Provide faster stack operations for common table operations. */",
            "-    used = frame(table.vs_end) + frame(table.id_end) * sizeof(voffset_t);",
            "-    need = (count + 2) * sizeof(voffset_t);",
            "+    used = frame(container.table.vs_end) + frame(container.table.id_end) * sizeof(voffset_t);",
            "+    need = (size_t)(count + 2) * sizeof(voffset_t);",
            "     if (!(B->vs = reserve_buffer(B, flatcc_builder_alloc_vs, used, need, 1))) {",
            "         return -1;",
            "     }",
            "     /* Move past header for convenience. */",
            "     B->vs += 2;",
            "-    used = frame(table.pl_end);",
            "+    used = frame(container.table.pl_end);",
            "     /* Add one to handle special case of first table being empty. */",
            "-    need = count * sizeof(*(B->pl)) + 1;",
            "+    need = (size_t)count * sizeof(*(B->pl)) + 1;",
            "     if (!(B->pl = reserve_buffer(B, flatcc_builder_alloc_pl, used, need, 0))) {",
            "         return -1;",
            "     }",
            "     return 0;",
            " }",
            " ",
            " static int alloc_ht(flatcc_builder_t *B)",
            " {",
            "     iovec_t *buf = B->buffers + flatcc_builder_alloc_ht;",
            " ",
            "     size_t size, k;",
            "     /* Allocate null entry so we can check for return errors. */",
            "-    assert(B->vd_end == 0);",
            "+    FLATCC_ASSERT(B->vd_end == 0);",
            "     if (!reserve_buffer(B, flatcc_builder_alloc_vd, B->vd_end, sizeof(vtable_descriptor_t), 0)) {",
            "         return -1;",
            "     }",
            "     B->vd_end = sizeof(vtable_descriptor_t);",
            "     size = field_size * FLATCC_BUILDER_MIN_HASH_COUNT;",
            "     if (B->alloc(B->alloc_context, buf, size, 1, flatcc_builder_alloc_ht)) {",
            "         return -1;",
            "@@ -426,15 +435,15 @@",
            "             /* Don't try to reduce the hash table. */",
            "             if (i != flatcc_builder_alloc_ht &&",
            "                 reduce_buffers && B->alloc(B->alloc_context, buf, 1, 1, i)) {",
            "                 return -1;",
            "             }",
            "             memset(buf->iov_base, 0, buf->iov_len);",
            "         } else {",
            "-            assert(buf->iov_len == 0);",
            "+            FLATCC_ASSERT(buf->iov_len == 0);",
            "         }",
            "     }",
            "     B->vb_end = 0;",
            "     if (B->vd_end > 0) {",
            "         /* Reset past null entry. */",
            "         B->vd_end = sizeof(vtable_descriptor_t);",
            "     }",
            "@@ -507,15 +516,15 @@",
            "     }",
            " }",
            " ",
            " void *flatcc_builder_enter_user_frame_ptr(flatcc_builder_t *B, size_t size)",
            " {",
            "     size_t *frame;",
            " ",
            "-    size = alignup(size, sizeof(size_t)) + sizeof(size_t);",
            "+    size = alignup_size(size, sizeof(size_t)) + sizeof(size_t);",
            " ",
            "     if (!(frame = reserve_buffer(B, flatcc_builder_alloc_us, B->user_frame_end, size, 0))) {",
            "         return 0;",
            "     }",
            "     memset(frame, 0, size);",
            "     *frame++ = B->user_frame_offset;",
            "     B->user_frame_offset = B->user_frame_end + sizeof(size_t);",
            "@@ -523,15 +532,15 @@",
            "     return frame;",
            " }",
            " ",
            " size_t flatcc_builder_enter_user_frame(flatcc_builder_t *B, size_t size)",
            " {",
            "     size_t *frame;",
            " ",
            "-    size = alignup(size, sizeof(size_t)) + sizeof(size_t);",
            "+    size = alignup_size(size, sizeof(size_t)) + sizeof(size_t);",
            " ",
            "     if (!(frame = reserve_buffer(B, flatcc_builder_alloc_us, B->user_frame_end, size, 0))) {",
            "         return 0;",
            "     }",
            "     memset(frame, 0, size);",
            "     *frame++ = B->user_frame_offset;",
            "     B->user_frame_offset = B->user_frame_end + sizeof(size_t);",
            "@@ -540,24 +549,24 @@",
            " }",
            " ",
            " ",
            " size_t flatcc_builder_exit_user_frame(flatcc_builder_t *B)",
            " {",
            "     size_t *hdr;",
            " ",
            "-    assert(B->user_frame_offset > 0);",
            "+    FLATCC_ASSERT(B->user_frame_offset > 0);",
            " ",
            "     hdr = us_ptr(B->user_frame_offset);",
            "     B->user_frame_end = B->user_frame_offset - sizeof(size_t);",
            "     return B->user_frame_offset = hdr[-1];",
            " }",
            " ",
            " size_t flatcc_builder_exit_user_frame_at(flatcc_builder_t *B, size_t handle)",
            " {",
            "-    assert(B->user_frame_offset >= handle);",
            "+    FLATCC_ASSERT(B->user_frame_offset >= handle);",
            " ",
            "     B->user_frame_offset = handle;",
            "     return flatcc_builder_exit_user_frame(B);",
            " }",
            " ",
            " size_t flatcc_builder_get_current_user_frame(flatcc_builder_t *B)",
            " {",
            "@@ -572,15 +581,15 @@",
            " static int enter_frame(flatcc_builder_t *B, uint16_t align)",
            " {",
            "     if (++B->level > B->limit_level) {",
            "         if (B->max_level > 0 && B->level > B->max_level) {",
            "             return -1;",
            "         }",
            "         if (!(B->frame = reserve_buffer(B, flatcc_builder_alloc_fs,",
            "-                        (B->level - 1) * frame_size, frame_size, 0))) {",
            "+                        (size_t)(B->level - 1) * frame_size, frame_size, 0))) {",
            "             return -1;",
            "         }",
            "         B->limit_level = (int)(B->buffers[flatcc_builder_alloc_fs].iov_len / frame_size);",
            "         if (B->max_level > 0 && B->max_level < B->limit_level) {",
            "             B->limit_level = B->max_level;",
            "         }",
            "     } else {",
            "@@ -588,15 +597,15 @@",
            "     }",
            "     frame(ds_offset) = B->ds_offset;",
            "     frame(align) = B->align;",
            "     B->align = align;",
            "     /* Note: do not assume padding before first has been allocated! */",
            "     frame(ds_first) = B->ds_first;",
            "     frame(type_limit) = data_limit;",
            "-    B->ds_first = alignup(B->ds_first + B->ds_offset, 8);",
            "+    B->ds_first = alignup_uoffset(B->ds_first + B->ds_offset, 8);",
            "     B->ds_offset = 0;",
            "     return 0;",
            " }",
            " ",
            " static inline void exit_frame(flatcc_builder_t *B)",
            " {",
            "     memset(B->ds, 0, B->ds_offset);",
            "@@ -616,20 +625,20 @@",
            " ",
            "     --B->frame;",
            "     --B->level;",
            " }",
            " ",
            " static inline uoffset_t front_pad(flatcc_builder_t *B, uoffset_t size, uint16_t align)",
            " {",
            "-    return (B->emit_start - size) & (align - 1);",
            "+    return (uoffset_t)(B->emit_start - (flatcc_builder_ref_t)size) & (align - 1u);",
            " }",
            " ",
            " static inline uoffset_t back_pad(flatcc_builder_t *B, uint16_t align)",
            " {",
            "-    return (B->emit_end) & (align - 1);",
            "+    return (uoffset_t)(B->emit_end) & (align - 1u);",
            " }",
            " ",
            " static inline flatcc_builder_ref_t emit_front(flatcc_builder_t *B, iov_state_t *iov)",
            " {",
            "     flatcc_builder_ref_t ref;",
            " ",
            "     /*",
            "@@ -719,16 +728,16 @@",
            "     uoffset_t size_field, pad;",
            "     iov_state_t iov;",
            "     int with_size = flags & flatcc_builder_with_size;",
            " ",
            "     if (align_to_block(B, &align, block_align, !is_top_buffer(B))) {",
            "         return 0;",
            "     }",
            "-    pad = front_pad(B, (uoffset_t)size + (with_size ? field_size : 0), align);",
            "-    size_field = store_uoffset((uoffset_t)size + pad);",
            "+    pad = front_pad(B, (uoffset_t)(size + (with_size ? field_size : 0)), align);",
            "+    write_uoffset(&size_field, (uoffset_t)size + pad);",
            "     init_iov();",
            "     /* Add ubyte vector size header if nested buffer. */",
            "     push_iov_cond(&size_field, field_size, !is_top_buffer(B));",
            "     push_iov(data, size);",
            "     push_iov(_pad, pad);",
            "     return emit_front(B, &iov);",
            " }",
            "@@ -746,37 +755,37 @@",
            "     int with_size = (flags & flatcc_builder_with_size) != 0;",
            " ",
            "     if (align_to_block(B, &align, block_align, is_nested)) {",
            "         return 0;",
            "     }",
            "     set_min_align(B, align);",
            "     if (identifier) {",
            "-        assert(sizeof(flatcc_builder_identifier_t) == identifier_size);",
            "-        assert(sizeof(flatcc_builder_identifier_t) == field_size);",
            "+        FLATCC_ASSERT(sizeof(flatcc_builder_identifier_t) == identifier_size);",
            "+        FLATCC_ASSERT(sizeof(flatcc_builder_identifier_t) == field_size);",
            "         memcpy(&id_out, identifier, identifier_size);",
            "-        id_out = __flatbuffers_thash_cast_from_le(id_out);",
            "-        id_out = store_identifier(id_out);",
            "+        id_out = __flatbuffers_thash_read_from_le(&id_out);",
            "+        write_identifier(&id_out, id_out);",
            "     }",
            "     id_size = id_out ? identifier_size : 0;",
            "-    header_pad = front_pad(B, field_size + id_size + (with_size ? field_size : 0), align);",
            "+    header_pad = front_pad(B, field_size + id_size + (uoffset_t)(with_size ? field_size : 0), align);",
            "     init_iov();",
            "     /* ubyte vectors size field wrapping nested buffer. */",
            "     push_iov_cond(&buffer_size, field_size, is_nested || with_size);",
            "     push_iov(&object_offset, field_size);",
            "     /* Identifiers are not always present in buffer. */",
            "     push_iov(&id_out, id_size);",
            "     push_iov(_pad, header_pad);",
            "-    buffer_base = (uoffset_t)B->emit_start - (uoffset_t)iov.len + ((is_nested || with_size) ? field_size : 0);",
            "+    buffer_base = (uoffset_t)B->emit_start - (uoffset_t)iov.len + (uoffset_t)((is_nested || with_size) ? field_size : 0);",
            "     if (is_nested) {",
            "-        buffer_size = store_uoffset((uoffset_t)B->buffer_mark - buffer_base);",
            "+        write_uoffset(&buffer_size, (uoffset_t)B->buffer_mark - buffer_base);",
            "     } else {",
            "         /* Also include clustered vtables. */",
            "-        buffer_size = store_uoffset((uoffset_t)B->emit_end - buffer_base);",
            "+        write_uoffset(&buffer_size, (uoffset_t)B->emit_end - buffer_base);",
            "     }",
            "-    object_offset = store_uoffset((uoffset_t)object_ref - buffer_base);",
            "+    write_uoffset(&object_offset, (uoffset_t)object_ref - buffer_base);",
            "     if (0 == (buffer_ref = emit_front(B, &iov))) {",
            "         check(0, \"emitter rejected buffer content\");",
            "         return 0;",
            "     }",
            "     return buffer_ref;",
            " }",
            " ",
            "@@ -809,29 +818,29 @@",
            "      */",
            "     if (enter_frame(B, B->min_align)) {",
            "         return -1;",
            "     }",
            "     /* B->align now has parent min_align, and child frames will save it. */",
            "     B->min_align = 1;",
            "     /* Save the parent block align, and set proper defaults for this buffer. */",
            "-    frame(buffer.block_align) = B->block_align;",
            "+    frame(container.buffer.block_align) = B->block_align;",
            "     B->block_align = block_align;",
            "-    frame(buffer.flags = B->buffer_flags);",
            "-    B->buffer_flags = flags;",
            "-    frame(buffer.mark) = B->buffer_mark;",
            "-    frame(buffer.nest_id) = B->nest_id;",
            "+    frame(container.buffer.flags = B->buffer_flags);",
            "+    B->buffer_flags = (uint16_t)flags;",
            "+    frame(container.buffer.mark) = B->buffer_mark;",
            "+    frame(container.buffer.nest_id) = B->nest_id;",
            "     /*",
            "      * End of buffer when nested. Not defined for top-level because we",
            "      * here (on only here) permit strings etc. to be created before buffer start and",
            "      * because top-level buffer vtables can be clustered.",
            "      */",
            "     B->buffer_mark = B->emit_start;",
            "     /* Must be 0 before and after entering top-level buffer, and unique otherwise. */",
            "     B->nest_id = B->nest_count++;",
            "-    frame(buffer.identifier) = B->identifier;",
            "+    frame(container.buffer.identifier) = B->identifier;",
            "     set_identifier(identifier);",
            "     frame(type) = flatcc_builder_buffer;",
            "     return 0;",
            " }",
            " ",
            " flatcc_builder_ref_t flatcc_builder_end_buffer(flatcc_builder_t *B, flatcc_builder_ref_t root)",
            " {",
            "@@ -842,18 +851,18 @@",
            "     flags |= is_top_buffer(B) ? 0 : flatcc_builder_is_nested;",
            "     check(frame(type) == flatcc_builder_buffer, \"expected buffer frame\");",
            "     set_min_align(B, B->block_align);",
            "     if (0 == (buffer_ref = flatcc_builder_create_buffer(B, (void *)&B->identifier,",
            "             B->block_align, root, B->min_align, flags))) {",
            "         return 0;",
            "     }",
            "-    B->buffer_mark = frame(buffer.mark);",
            "-    B->nest_id = frame(buffer.nest_id);",
            "-    B->identifier = frame(buffer.identifier);",
            "-    B->buffer_flags = frame(buffer.flags);",
            "+    B->buffer_mark = frame(container.buffer.mark);",
            "+    B->nest_id = frame(container.buffer.nest_id);",
            "+    B->identifier = frame(container.buffer.identifier);",
            "+    B->buffer_flags = frame(container.buffer.flags);",
            "     exit_frame(B);",
            "     return buffer_ref;",
            " }",
            " ",
            " void *flatcc_builder_start_struct(flatcc_builder_t *B, size_t size, uint16_t align)",
            " {",
            "     /* Allocate space for the struct on the ds stack. */",
            "@@ -881,84 +890,84 @@",
            "     exit_frame(B);",
            "     return object_ref;",
            " }",
            " ",
            " static inline int vector_count_add(flatcc_builder_t *B, uoffset_t count, uoffset_t max_count)",
            " {",
            "     uoffset_t n, n1;",
            "-    n = frame(vector.count);",
            "+    n = frame(container.vector.count);",
            "     n1 = n + count;",
            "     /*",
            "      * This prevents elem_size * count from overflowing iff max_vector",
            "      * has been set sensible. Without this check we might allocate to",
            "      * little on the ds stack and return a buffer the user thinks is",
            "      * much larger which of course is bad even though the buffer eventually",
            "      * would fail anyway.",
            "      */",
            "     check_error(n <= n1 && n1 <= max_count, -1, \"vector too large to represent\");",
            "-    frame(vector.count) = n1;",
            "+    frame(container.vector.count) = n1;",
            "     return 0;",
            " }",
            " ",
            " void *flatcc_builder_extend_vector(flatcc_builder_t *B, size_t count)",
            " {",
            "-    if (vector_count_add(B, (uoffset_t)count, frame(vector.max_count))) {",
            "+    if (vector_count_add(B, (uoffset_t)count, frame(container.vector.max_count))) {",
            "         return 0;",
            "     }",
            "-    return push_ds(B, frame(vector.elem_size) * (uoffset_t)count);",
            "+    return push_ds(B, frame(container.vector.elem_size) * (uoffset_t)count);",
            " }",
            " ",
            " void *flatcc_builder_vector_push(flatcc_builder_t *B, const void *data)",
            " {",
            "     check(frame(type) == flatcc_builder_vector, \"expected vector frame\");",
            "-    check_error(frame(vector.count) <= frame(vector.max_count), 0, \"vector max count exceeded\");",
            "-    frame(vector.count) += 1;",
            "-    return push_ds_copy(B, data, frame(vector.elem_size));",
            "+    check_error(frame(container.vector.count) <= frame(container.vector.max_count), 0, \"vector max count exceeded\");",
            "+    frame(container.vector.count) += 1;",
            "+    return push_ds_copy(B, data, frame(container.vector.elem_size));",
            " }",
            " ",
            " void *flatcc_builder_append_vector(flatcc_builder_t *B, const void *data, size_t count)",
            " {",
            "     check(frame(type) == flatcc_builder_vector, \"expected vector frame\");",
            "-    if (vector_count_add(B, (uoffset_t)count, frame(vector.max_count))) {",
            "+    if (vector_count_add(B, (uoffset_t)count, frame(container.vector.max_count))) {",
            "         return 0;",
            "     }",
            "-    return push_ds_copy(B, data, frame(vector.elem_size) * (uoffset_t)count);",
            "+    return push_ds_copy(B, data, frame(container.vector.elem_size) * (uoffset_t)count);",
            " }",
            " ",
            " flatcc_builder_ref_t *flatcc_builder_extend_offset_vector(flatcc_builder_t *B, size_t count)",
            " {",
            "     if (vector_count_add(B, (uoffset_t)count, max_offset_count)) {",
            "         return 0;",
            "     }",
            "-    return push_ds(B, field_size * (uoffset_t)count);",
            "+    return push_ds(B, (uoffset_t)(field_size * count));",
            " }",
            " ",
            " flatcc_builder_ref_t *flatcc_builder_offset_vector_push(flatcc_builder_t *B, flatcc_builder_ref_t ref)",
            " {",
            "     flatcc_builder_ref_t *p;",
            " ",
            "     check(frame(type) == flatcc_builder_offset_vector, \"expected offset vector frame\");",
            "-    if (frame(vector.count) == max_offset_count) {",
            "+    if (frame(container.vector.count) == max_offset_count) {",
            "         return 0;",
            "     }",
            "-    frame(vector.count) += 1;",
            "+    frame(container.vector.count) += 1;",
            "     if (0 == (p = push_ds(B, field_size))) {",
            "         return 0;",
            "     }",
            "     *p = ref;",
            "     return p;",
            " }",
            " ",
            " flatcc_builder_ref_t *flatcc_builder_append_offset_vector(flatcc_builder_t *B, const flatcc_builder_ref_t *refs, size_t count)",
            " {",
            "     check(frame(type) == flatcc_builder_offset_vector, \"expected offset vector frame\");",
            "     if (vector_count_add(B, (uoffset_t)count, max_offset_count)) {",
            "         return 0;",
            "     }",
            "-    return push_ds_copy(B, refs, field_size * (uoffset_t)count);",
            "+    return push_ds_copy(B, refs, (uoffset_t)(field_size * count));",
            " }",
            " ",
            " char *flatcc_builder_extend_string(flatcc_builder_t *B, size_t len)",
            " {",
            "     check(frame(type) == flatcc_builder_string, \"expected string frame\");",
            "     if (vector_count_add(B, (uoffset_t)len, max_string_len)) {",
            "         return 0;",
            "@@ -984,59 +993,59 @@",
            " {",
            "     return flatcc_builder_append_string(B, s, strnlen(s, max_len));",
            " }",
            " ",
            " int flatcc_builder_truncate_vector(flatcc_builder_t *B, size_t count)",
            " {",
            "     check(frame(type) == flatcc_builder_vector, \"expected vector frame\");",
            "-    check_error(frame(vector.count) >= count, -1, \"cannot truncate vector past empty\");",
            "-    frame(vector.count) -= (uoffset_t)count;",
            "-    unpush_ds(B, frame(vector.elem_size) * (uoffset_t)count);",
            "+    check_error(frame(container.vector.count) >= count, -1, \"cannot truncate vector past empty\");",
            "+    frame(container.vector.count) -= (uoffset_t)count;",
            "+    unpush_ds(B, frame(container.vector.elem_size) * (uoffset_t)count);",
            "     return 0;",
            " }",
            " ",
            " int flatcc_builder_truncate_offset_vector(flatcc_builder_t *B, size_t count)",
            " {",
            "     check(frame(type) == flatcc_builder_offset_vector, \"expected offset vector frame\");",
            "-    check_error(frame(vector.count) >= (uoffset_t)count, -1, \"cannot truncate vector past empty\");",
            "-    frame(vector.count) -= (uoffset_t)count;",
            "-    unpush_ds(B, frame(vector.elem_size) * (uoffset_t)count);",
            "+    check_error(frame(container.vector.count) >= (uoffset_t)count, -1, \"cannot truncate vector past empty\");",
            "+    frame(container.vector.count) -= (uoffset_t)count;",
            "+    unpush_ds(B, frame(container.vector.elem_size) * (uoffset_t)count);",
            "     return 0;",
            " }",
            " ",
            " int flatcc_builder_truncate_string(flatcc_builder_t *B, size_t len)",
            " {",
            "     check(frame(type) == flatcc_builder_string, \"expected string frame\");",
            "-    check_error(frame(vector.count) >= len, -1, \"cannot truncate string past empty\");",
            "-    frame(vector.count) -= (uoffset_t)len;",
            "+    check_error(frame(container.vector.count) >= len, -1, \"cannot truncate string past empty\");",
            "+    frame(container.vector.count) -= (uoffset_t)len;",
            "     unpush_ds(B, (uoffset_t)len);",
            "     return 0;",
            " }",
            " ",
            " int flatcc_builder_start_vector(flatcc_builder_t *B, size_t elem_size, uint16_t align, size_t max_count)",
            " {",
            "     get_min_align(&align, field_size);",
            "     if (enter_frame(B, align)) {",
            "         return -1;",
            "     }",
            "-    frame(vector.elem_size) = (uoffset_t)elem_size;",
            "-    frame(vector.count) = 0;",
            "-    frame(vector.max_count) = (uoffset_t)max_count;",
            "+    frame(container.vector.elem_size) = (uoffset_t)elem_size;",
            "+    frame(container.vector.count) = 0;",
            "+    frame(container.vector.max_count) = (uoffset_t)max_count;",
            "     frame(type) = flatcc_builder_vector;",
            "     refresh_ds(B, data_limit);",
            "     return 0;",
            " }",
            " ",
            " int flatcc_builder_start_offset_vector(flatcc_builder_t *B)",
            " {",
            "     if (enter_frame(B, field_size)) {",
            "         return -1;",
            "     }",
            "-    frame(vector.elem_size) = field_size;",
            "-    frame(vector.count) = 0;",
            "+    frame(container.vector.elem_size) = field_size;",
            "+    frame(container.vector.count) = 0;",
            "     frame(type) = flatcc_builder_offset_vector;",
            "     refresh_ds(B, data_limit);",
            "     return 0;",
            " }",
            " ",
            " flatcc_builder_ref_t flatcc_builder_create_offset_vector(flatcc_builder_t *B,",
            "         const flatcc_builder_ref_t *vec, size_t count)",
            "@@ -1054,16 +1063,16 @@",
            " }",
            " ",
            " int flatcc_builder_start_string(flatcc_builder_t *B)",
            " {",
            "     if (enter_frame(B, 1)) {",
            "         return -1;",
            "     }",
            "-    frame(vector.elem_size) = 1;",
            "-    frame(vector.count) = 0;",
            "+    frame(container.vector.elem_size) = 1;",
            "+    frame(container.vector.count) = 0;",
            "     frame(type) = flatcc_builder_string;",
            "     refresh_ds(B, data_limit);",
            "     return 0;",
            " }",
            " ",
            " int flatcc_builder_reserve_table(flatcc_builder_t *B, int count)",
            " {",
            "@@ -1072,18 +1081,18 @@",
            " }",
            " ",
            " int flatcc_builder_start_table(flatcc_builder_t *B, int count)",
            " {",
            "     if (enter_frame(B, field_size)) {",
            "         return -1;",
            "     }",
            "-    frame(table.vs_end) = vs_offset(B->vs);",
            "-    frame(table.pl_end) = pl_offset(B->pl);",
            "-    frame(table.vt_hash) = B->vt_hash;",
            "-    frame(table.id_end) = B->id_end;",
            "+    frame(container.table.vs_end) = vs_offset(B->vs);",
            "+    frame(container.table.pl_end) = pl_offset(B->pl);",
            "+    frame(container.table.vt_hash) = B->vt_hash;",
            "+    frame(container.table.id_end) = B->id_end;",
            "     B->vt_hash = 0;",
            "     FLATCC_BUILDER_INIT_VT_HASH(B->vt_hash);",
            "     B->id_end = 0;",
            "     frame(type) = flatcc_builder_table;",
            "     if (reserve_fields(B, count)) {",
            "         return -1;",
            "     }",
            "@@ -1124,15 +1133,15 @@",
            " ",
            "     if (!flatbuffers_is_native_pe()) {",
            "         /* Make space in vtable cache for temporary endian conversion. */",
            "         if (!(vt_ = reserve_buffer(B, flatcc_builder_alloc_vb, B->vb_end, vt_size, 0))) {",
            "             return 0;",
            "         }",
            "         for (i = 0; i < vt_size / sizeof(voffset_t); ++i) {",
            "-            vt_[i] = store_voffset(vt[i]);",
            "+            write_voffset(&vt_[i], vt[i]);",
            "         }",
            "         vt = vt_;",
            "         /* We don't need to free the reservation since we don't advance any base pointer. */",
            "     }",
            " ",
            "     init_iov();",
            "     push_iov(vt, vt_size);",
            "@@ -1198,15 +1207,15 @@",
            "         return vd->vt_ref;",
            "     }",
            "     /* Allocate new descriptor. */",
            "     if (!(vd = reserve_buffer(B, flatcc_builder_alloc_vd, B->vd_end, sizeof(vtable_descriptor_t), 0))) {",
            "         return 0;",
            "     }",
            "     next = B->vd_end;",
            "-    B->vd_end += sizeof(vtable_descriptor_t);",
            "+    B->vd_end += (uoffset_t)sizeof(vtable_descriptor_t);",
            " ",
            "     /* Identify the buffer this vtable descriptor belongs to. */",
            "     vd->nest_id = B->nest_id;",
            " ",
            "     /* Move to front hash strategy. */",
            "     vd->next = *pvd_head;",
            "     *pvd_head = next;",
            "@@ -1255,19 +1264,19 @@",
            "     vt_base = (uoffset_t)(vt_ref - 1);",
            "     vt_offset = base - vt_base;",
            "     /* Avoid overflow. */",
            "     if (base - vt_offset != vt_base) {",
            "         return -1;",
            "     }",
            "     /* Protocol endian encoding. */",
            "-    vt_offset_field = store_uoffset(vt_offset);",
            "+    write_uoffset(&vt_offset_field, vt_offset);",
            "     for (i = 0; i < offset_count; ++i) {",
            "         offset_field = (uoffset_t *)((size_t)data + offsets[i]);",
            "-        offset = *offset_field - base - offsets[i] - field_size;",
            "-        *offset_field = store_uoffset(offset);",
            "+        offset = *offset_field - base - offsets[i] - (uoffset_t)field_size;",
            "+        write_uoffset(offset_field, offset);",
            "     }",
            "     init_iov();",
            "     push_iov(&vt_offset_field, field_size);",
            "     push_iov(data, size);",
            "     push_iov(_pad, pad);",
            "     return emit_front(B, &iov);",
            " }",
            "@@ -1320,40 +1329,40 @@",
            "     voffset_t *pl;",
            " ",
            "     check(frame(type) == flatcc_builder_table, \"expected table frame\");",
            " ",
            "     /* We have `ds_limit`, so we should not have to check for overflow here. */",
            " ",
            "     vt = B->vs - 2;",
            "-    vt_size = sizeof(voffset_t) * (B->id_end + 2);",
            "+    vt_size = (voffset_t)(sizeof(voffset_t) * (B->id_end + 2u));",
            "     /* Update vtable header fields, first vtable size, then object table size. */",
            "     vt[0] = vt_size;",
            "     /*",
            "      * The `ds` buffer is always at least `field_size` aligned but excludes the",
            "      * initial vtable offset field. Therefore `field_size` is added here",
            "      * to the total table size in the vtable.",
            "      */",
            "-    vt[1] = (voffset_t)B->ds_offset + field_size;",
            "+    vt[1] = (voffset_t)(B->ds_offset + field_size);",
            "     FLATCC_BUILDER_UPDATE_VT_HASH(B->vt_hash, (uint32_t)vt[0], (uint32_t)vt[1]);",
            "     /* Find already emitted vtable, or emit a new one. */",
            "     if (!(vt_ref = flatcc_builder_create_cached_vtable(B, vt, vt_size, B->vt_hash))) {",
            "         return 0;",
            "     }",
            "     /* Clear vs stack so it is ready for the next vtable (ds stack is cleared by exit frame). */",
            "     memset(vt, 0, vt_size);",
            " ",
            "-    pl = pl_ptr(frame(table.pl_end));",
            "+    pl = pl_ptr(frame(container.table.pl_end));",
            "     pl_count = (int)(B->pl - pl);",
            "     if (0 == (table_ref = flatcc_builder_create_table(B, B->ds, B->ds_offset, B->align, pl, pl_count, vt_ref))) {",
            "         return 0;",
            "     }",
            "-    B->vt_hash = frame(table.vt_hash);",
            "-    B->id_end = frame(table.id_end);",
            "-    B->vs = vs_ptr(frame(table.vs_end));",
            "-    B->pl = pl_ptr(frame(table.pl_end));",
            "+    B->vt_hash = frame(container.table.vt_hash);",
            "+    B->id_end = frame(container.table.id_end);",
            "+    B->vs = vs_ptr(frame(container.table.vs_end));",
            "+    B->pl = pl_ptr(frame(container.table.pl_end));",
            "     exit_frame(B);",
            "     return table_ref;",
            " }",
            " ",
            " flatcc_builder_ref_t flatcc_builder_create_vector(flatcc_builder_t *B,",
            "         const void *data, size_t count, size_t elem_size, uint16_t align, size_t max_count)",
            " {",
            "@@ -1374,15 +1383,15 @@",
            "     /*",
            "      * That can happen on 32 bit systems when uoffset_t is defined as 64-bit.",
            "      * `emit_front/back` captures overflow, but not if our size type wraps first.",
            "      */",
            " #if FLATBUFFERS_UOFFSET_MAX > SIZE_MAX",
            "     check_error(vec_size < SIZE_MAX, 0, \"vector larger than address space\");",
            " #endif",
            "-    length_prefix = store_uoffset((uoffset_t)count);",
            "+    write_uoffset(&length_prefix, (uoffset_t)count);",
            "     /* Alignment is calculated for the first element, not the header. */",
            "     vec_pad = front_pad(B, vec_size, align);",
            "     init_iov();",
            "     push_iov(&length_prefix, field_size);",
            "     push_iov(data, vec_size);",
            "     push_iov(_pad, vec_pad);",
            "     return emit_front(B, &iov);",
            "@@ -1401,67 +1410,69 @@",
            " flatcc_builder_ref_t flatcc_builder_end_vector(flatcc_builder_t *B)",
            " {",
            "     flatcc_builder_ref_t vector_ref;",
            " ",
            "     check(frame(type) == flatcc_builder_vector, \"expected vector frame\");",
            " ",
            "     if (0 == (vector_ref = flatcc_builder_create_vector(B, B->ds,",
            "-            frame(vector.count), frame(vector.elem_size),",
            "-            B->align, frame(vector.max_count)))) {",
            "+            frame(container.vector.count), frame(container.vector.elem_size),",
            "+            B->align, frame(container.vector.max_count)))) {",
            "         return 0;",
            "     }",
            "     exit_frame(B);",
            "     return vector_ref;",
            " }",
            " ",
            " size_t flatcc_builder_vector_count(flatcc_builder_t *B)",
            " {",
            "-    return frame(vector.count);",
            "+    return frame(container.vector.count);",
            " }",
            " ",
            " void *flatcc_builder_vector_edit(flatcc_builder_t *B)",
            " {",
            "     return B->ds;",
            " }",
            " ",
            " /* This function destroys the source content but avoids stack allocation. */",
            " static flatcc_builder_ref_t _create_offset_vector_direct(flatcc_builder_t *B,",
            "         flatcc_builder_ref_t *vec, size_t count, const utype_t *types)",
            " {",
            "     uoffset_t vec_size, vec_pad;",
            "-    uoffset_t length_prefix, base, offset;",
            "+    uoffset_t length_prefix, offset;",
            "     uoffset_t i;",
            "+    soffset_t base;",
            "     iov_state_t iov;",
            " ",
            "     if ((uoffset_t)count > max_offset_count) {",
            "         return 0;",
            "     }",
            "     set_min_align(B, field_size);",
            "-    vec_size = (uoffset_t)count * field_size;",
            "-    length_prefix = store_uoffset((uoffset_t)count);",
            "+    vec_size = (uoffset_t)(count * field_size);",
            "+    write_uoffset(&length_prefix, (uoffset_t)count);",
            "     /* Alignment is calculated for the first element, not the header. */",
            "     vec_pad = front_pad(B, vec_size, field_size);",
            "     init_iov();",
            "     push_iov(&length_prefix, field_size);",
            "     push_iov(vec, vec_size);",
            "     push_iov(_pad, vec_pad);",
            "-    base = (uoffset_t)B->emit_start - (uoffset_t)iov.len;",
            "+    base = B->emit_start - (soffset_t)iov.len;",
            "     for (i = 0; i < (uoffset_t)count; ++i) {",
            "         /*",
            "          * 0 is either end of buffer, start of vtables, or start of",
            "          * buffer depending on the direction in which the buffer is",
            "          * built. None of these can create a valid 0 reference but it",
            "          * is easy to create by mistake when manually building offset",
            "          * vectors.",
            "          *",
            "          * Unions do permit nulls, but only when the type is NONE.",
            "          */",
            "         if (vec[i] != 0) {",
            "-            offset = vec[i] - base - i * field_size - field_size;",
            "-            vec[i] = store_uoffset(offset);",
            "+            offset = (uoffset_t)",
            "+                (vec[i] - base - (soffset_t)(i * field_size) - (soffset_t)field_size);",
            "+            write_uoffset(&vec[i], offset);",
            "             if (types) {",
            "                 check(types[i] != 0, \"union vector cannot have non-null element with type NONE\");",
            "             }",
            "         } else {",
            "             if (types) {",
            "                 check(types[i] == 0, \"union vector cannot have null element without type NONE\");",
            "             } else {",
            "@@ -1480,42 +1491,42 @@",
            " ",
            " flatcc_builder_ref_t flatcc_builder_end_offset_vector(flatcc_builder_t *B)",
            " {",
            "     flatcc_builder_ref_t vector_ref;",
            " ",
            "     check(frame(type) == flatcc_builder_offset_vector, \"expected offset vector frame\");",
            "     if (0 == (vector_ref = flatcc_builder_create_offset_vector_direct(B,",
            "-            (flatcc_builder_ref_t *)B->ds, frame(vector.count)))) {",
            "+            (flatcc_builder_ref_t *)B->ds, frame(container.vector.count)))) {",
            "         return 0;",
            "     }",
            "     exit_frame(B);",
            "     return vector_ref;",
            " }",
            " ",
            " flatcc_builder_ref_t flatcc_builder_end_offset_vector_for_unions(flatcc_builder_t *B, const utype_t *types)",
            " {",
            "     flatcc_builder_ref_t vector_ref;",
            " ",
            "     check(frame(type) == flatcc_builder_offset_vector, \"expected offset vector frame\");",
            "     if (0 == (vector_ref = _create_offset_vector_direct(B,",
            "-            (flatcc_builder_ref_t *)B->ds, frame(vector.count), types))) {",
            "+            (flatcc_builder_ref_t *)B->ds, frame(container.vector.count), types))) {",
            "         return 0;",
            "     }",
            "     exit_frame(B);",
            "     return vector_ref;",
            " }",
            " ",
            " void *flatcc_builder_offset_vector_edit(flatcc_builder_t *B)",
            " {",
            "     return B->ds;",
            " }",
            " ",
            " size_t flatcc_builder_offset_vector_count(flatcc_builder_t *B)",
            " {",
            "-    return frame(vector.count);",
            "+    return frame(container.vector.count);",
            " }",
            " ",
            " int flatcc_builder_table_add_union(flatcc_builder_t *B, int id,",
            "     flatcc_builder_union_ref_t uref)",
            " {",
            "     flatcc_builder_ref_t *pref;",
            "     flatcc_builder_utype_t *putype;",
            "@@ -1525,15 +1536,15 @@",
            "     if (uref.value != 0) {",
            "         pref = flatcc_builder_table_add_offset(B, id);",
            "         check_error(pref != 0, -1, \"unable to add union value\");",
            "         *pref = uref.value;",
            "     }",
            "     putype = flatcc_builder_table_add(B, id - 1, utype_size, utype_size);",
            "     check_error(putype != 0, -1, \"unable to add union type\");",
            "-    *putype = store_utype(uref.type);",
            "+    write_utype(putype, uref.type);",
            "     return 0;",
            " }",
            " ",
            " int flatcc_builder_table_add_union_vector(flatcc_builder_t *B, int id,",
            "         flatcc_builder_union_vec_ref_t uvref)",
            " {",
            "     flatcc_builder_ref_t *pref;",
            "@@ -1606,16 +1617,16 @@",
            " }",
            " ",
            " int flatcc_builder_start_union_vector(flatcc_builder_t *B)",
            " {",
            "     if (enter_frame(B, field_size)) {",
            "         return -1;",
            "     }",
            "-    frame(vector.elem_size) = union_size;",
            "-    frame(vector.count) = 0;",
            "+    frame(container.vector.elem_size) = union_size;",
            "+    frame(container.vector.count) = 0;",
            "     frame(type) = flatcc_builder_union_vector;",
            "     refresh_ds(B, data_limit);",
            "     return 0;",
            " }",
            " ",
            " flatcc_builder_union_vec_ref_t flatcc_builder_end_union_vector(flatcc_builder_t *B)",
            " {",
            "@@ -1656,71 +1667,71 @@",
            " void *flatcc_builder_union_vector_edit(flatcc_builder_t *B)",
            " {",
            "     return B->ds;",
            " }",
            " ",
            " size_t flatcc_builder_union_vector_count(flatcc_builder_t *B)",
            " {",
            "-    return frame(vector.count);",
            "+    return frame(container.vector.count);",
            " }",
            " ",
            " flatcc_builder_union_ref_t *flatcc_builder_extend_union_vector(flatcc_builder_t *B, size_t count)",
            " {",
            "     if (vector_count_add(B, (uoffset_t)count, max_union_count)) {",
            "         return 0;",
            "     }",
            "-    return push_ds(B, union_size * (uoffset_t)count);",
            "+    return push_ds(B, (uoffset_t)(union_size * count));",
            " }",
            " ",
            " int flatcc_builder_truncate_union_vector(flatcc_builder_t *B, size_t count)",
            " {",
            "     check(frame(type) == flatcc_builder_union_vector, \"expected union vector frame\");",
            "-    check_error(frame(vector.count) >= (uoffset_t)count, -1, \"cannot truncate vector past empty\");",
            "-    frame(vector.count) -= (uoffset_t)count;",
            "-    unpush_ds(B, frame(vector.elem_size) * (uoffset_t)count);",
            "+    check_error(frame(container.vector.count) >= (uoffset_t)count, -1, \"cannot truncate vector past empty\");",
            "+    frame(container.vector.count) -= (uoffset_t)count;",
            "+    unpush_ds(B, frame(container.vector.elem_size) * (uoffset_t)count);",
            "     return 0;",
            " }",
            " ",
            " flatcc_builder_union_ref_t *flatcc_builder_union_vector_push(flatcc_builder_t *B,",
            "         flatcc_builder_union_ref_t uref)",
            " {",
            "     flatcc_builder_union_ref_t *p;",
            " ",
            "     check(frame(type) == flatcc_builder_union_vector, \"expected union vector frame\");",
            "-    if (frame(vector.count) == max_union_count) {",
            "+    if (frame(container.vector.count) == max_union_count) {",
            "         return 0;",
            "     }",
            "-    frame(vector.count) += 1;",
            "+    frame(container.vector.count) += 1;",
            "     if (0 == (p = push_ds(B, union_size))) {",
            "         return 0;",
            "     }",
            "     *p = uref;",
            "     return p;",
            " }",
            " ",
            " flatcc_builder_union_ref_t *flatcc_builder_append_union_vector(flatcc_builder_t *B,",
            "         const flatcc_builder_union_ref_t *urefs, size_t count)",
            " {",
            "     check(frame(type) == flatcc_builder_union_vector, \"expected union vector frame\");",
            "     if (vector_count_add(B, (uoffset_t)count, max_union_count)) {",
            "         return 0;",
            "     }",
            "-    return push_ds_copy(B, urefs, union_size * (uoffset_t)count);",
            "+    return push_ds_copy(B, urefs, (uoffset_t)(union_size * count));",
            " }",
            " ",
            " flatcc_builder_ref_t flatcc_builder_create_string(flatcc_builder_t *B, const char *s, size_t len)",
            " {",
            "     uoffset_t s_pad;",
            "     uoffset_t length_prefix;",
            "     iov_state_t iov;",
            " ",
            "     if (len > max_string_len) {",
            "         return 0;",
            "     }",
            "-    length_prefix = store_uoffset((uoffset_t)len);",
            "+    write_uoffset(&length_prefix, (uoffset_t)len);",
            "     /* Add 1 for zero termination. */",
            "     s_pad = front_pad(B, (uoffset_t)len + 1, field_size) + 1;",
            "     init_iov();",
            "     push_iov(&length_prefix, field_size);",
            "     push_iov(s, len);",
            "     push_iov(_pad, s_pad);",
            "     return emit_front(B, &iov);",
            "@@ -1737,15 +1748,15 @@",
            " }",
            " ",
            " flatcc_builder_ref_t flatcc_builder_end_string(flatcc_builder_t *B)",
            " {",
            "     flatcc_builder_ref_t string_ref;",
            " ",
            "     check(frame(type) == flatcc_builder_string, \"expected string frame\");",
            "-    assert(frame(vector.count) == B->ds_offset);",
            "+    FLATCC_ASSERT(frame(container.vector.count) == B->ds_offset);",
            "     if (0 == (string_ref = flatcc_builder_create_string(B,",
            "             (const char *)B->ds, B->ds_offset))) {",
            "         return 0;",
            "     }",
            "     exit_frame(B);",
            "     return string_ref;",
            " }",
            "@@ -1753,15 +1764,15 @@",
            " char *flatcc_builder_string_edit(flatcc_builder_t *B)",
            " {",
            "     return (char *)B->ds;",
            " }",
            " ",
            " size_t flatcc_builder_string_len(flatcc_builder_t *B)",
            " {",
            "-    return frame(vector.count);",
            "+    return frame(container.vector.count);",
            " }",
            " ",
            " void *flatcc_builder_table_add(flatcc_builder_t *B, int id, size_t size, uint16_t align)",
            " {",
            "     /*",
            "      * We align the offset relative to the first table field, excluding",
            "      * the header holding the vtable reference. On the stack, `ds_first`",
            "@@ -1793,15 +1804,15 @@",
            " #else",
            "     if (B->vs[id] != 0) {",
            "         check(0, \"table field already set\");",
            "         return 0;",
            "     }",
            " #endif",
            "     FLATCC_BUILDER_UPDATE_VT_HASH(B->vt_hash, (uint32_t)id, (uint32_t)size);",
            "-    return push_ds_field(B, (uoffset_t)size, align, id);",
            "+    return push_ds_field(B, (uoffset_t)size, align, (voffset_t)id);",
            " }",
            " ",
            " void *flatcc_builder_table_edit(flatcc_builder_t *B, size_t size)",
            " {",
            "     check(frame(type) == flatcc_builder_table, \"expected table frame\");",
            " ",
            "     return B->ds + B->ds_offset - size;",
            "@@ -1828,15 +1839,15 @@",
            " #else",
            "     if (B->vs[id] != 0) {",
            "         check(0, \"table field already set\");",
            "         return 0;",
            "     }",
            " #endif",
            "     FLATCC_BUILDER_UPDATE_VT_HASH(B->vt_hash, (uint32_t)id, (uint32_t)field_size);",
            "-    return push_ds_offset_field(B, id);",
            "+    return push_ds_offset_field(B, (voffset_t)id);",
            " }",
            " ",
            " uint16_t flatcc_builder_push_buffer_alignment(flatcc_builder_t *B)",
            " {",
            "     uint16_t old_min_align = B->min_align;",
            " ",
            "     B->min_align = field_size;",
            "@@ -2004,11 +2015,21 @@",
            " }",
            " ",
            " void flatcc_builder_aligned_free(void *p)",
            " {",
            "     FLATCC_BUILDER_ALIGNED_FREE(p);",
            " }",
            " ",
            "+void *flatcc_builder_alloc(size_t size)",
            "+{",
            "+    return FLATCC_BUILDER_ALLOC(size);",
            "+}",
            "+",
            "+void flatcc_builder_free(void *p)",
            "+{",
            "+    FLATCC_BUILDER_FREE(p);",
            "+}",
            "+",
            " void *flatcc_builder_get_emit_context(flatcc_builder_t *B)",
            " {",
            "     return B->emit_context;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/runtime/json_parser.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/runtime/json_parser.c",
            "+++ /home/flatcc-0.6.1/src/runtime/json_parser.c",
            "@@ -1,9 +1,10 @@",
            " #include \"flatcc/flatcc_rtconfig.h\"",
            " #include \"flatcc/flatcc_json_parser.h\"",
            "+#include \"flatcc/flatcc_assert.h\"",
            " ",
            " #define uoffset_t flatbuffers_uoffset_t",
            " #define soffset_t flatbuffers_soffset_t",
            " #define voffset_t flatbuffers_voffset_t",
            " #define utype_t flatbuffers_utype_t",
            " ",
            " #define uoffset_size sizeof(uoffset_t)",
            "@@ -139,16 +140,16 @@",
            "     while (buf != end && *buf == 0x20) {",
            "         ++buf;",
            "     }",
            "     while (buf != end && *buf <= 0x20) {",
            "         /* Fall through comments needed to silence gcc 7 warnings. */",
            "         switch (*buf) {",
            "         case 0x0d: buf += (end - buf > 1 && buf[1] == 0x0a);",
            "-            /* Fall through */",
            "             /* Consume following LF or treating CR as LF. */",
            "+            fallthrough;",
            "         case 0x0a: ++ctx->line; ctx->line_start = ++buf; continue;",
            "         case 0x09: ++buf; continue;",
            "         case 0x20: goto again; /* Don't consume here, sync with power of 2 spaces. */",
            "         default: return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_unexpected_character);",
            "         }",
            "     }",
            "     return buf;",
            "@@ -158,63 +159,63 @@",
            " {",
            "     uint32_t u, x;",
            "     char c;",
            " ",
            "     u = 0;",
            "     c = buf[0];",
            "     if (c >= '0' && c <= '9') {",
            "-        x = c - '0';",
            "+        x = (uint32_t)(c - '0');",
            "         u = x << 12;",
            "     } else {",
            "         /* Lower case. */",
            "         c |= 0x20;",
            "         if (c >= 'a' && c <= 'f') {",
            "-            x = c - 'a' + 10;",
            "+            x = (uint32_t)(c - 'a' + 10);",
            "             u |= x << 12;",
            "         } else {",
            "             return -1;",
            "         }",
            "     }",
            "     c = buf[1];",
            "     if (c >= '0' && c <= '9') {",
            "-        x = c - '0';",
            "+        x = (uint32_t)(c - '0');",
            "         u |= x << 8;",
            "     } else {",
            "         /* Lower case. */",
            "         c |= 0x20;",
            "         if (c >= 'a' && c <= 'f') {",
            "-            x = c - 'a' + 10;",
            "+            x = (uint32_t)(c - 'a' + 10);",
            "             u |= x << 8;",
            "         } else {",
            "             return -1;",
            "         }",
            "     }",
            "     c = buf[2];",
            "     if (c >= '0' && c <= '9') {",
            "-        x = c - '0';",
            "+        x = (uint32_t)(c - '0');",
            "         u |= x << 4;",
            "     } else {",
            "         /* Lower case. */",
            "         c |= 0x20;",
            "         if (c >= 'a' && c <= 'f') {",
            "-            x = c - 'a' + 10;",
            "+            x = (uint32_t)(c - 'a' + 10);",
            "             u |= x << 4;",
            "         } else {",
            "             return -1;",
            "         }",
            "     }",
            "     c = buf[3];",
            "     if (c >= '0' && c <= '9') {",
            "-        x = c - '0';",
            "+        x = (uint32_t)(c - '0');",
            "         u |= x;",
            "     } else {",
            "         /* Lower case. */",
            "         c |= 0x20;",
            "         if (c >= 'a' && c <= 'f') {",
            "-            x = c - 'a' + 10;",
            "+            x = (uint32_t)(c - 'a' + 10);",
            "             u |= x;",
            "         } else {",
            "             return -1;",
            "         }",
            "     }",
            "     *result = u;",
            "     return 0;",
            "@@ -254,15 +255,15 @@",
            " ",
            " static inline int decode_utf16_surrogate_pair(uint32_t high, uint32_t low, char *code)",
            " {",
            "     return decode_unicode_char(combine_utf16_surrogate_pair(high, low), code);",
            " }",
            " ",
            " ",
            "-/* ",
            "+/*",
            "  * UTF-8 code points can have up to 4 bytes but JSON can only",
            "  * encode up to 3 bytes via the \\uXXXX syntax.",
            "  * To handle the range U+10000..U+10FFFF two UTF-16 surrogate",
            "  * pairs must be used. If this is not detected, the pairs",
            "  * survive in the output which is not valid but often tolerated.",
            "  * Emojis generally require such a pair, unless encoded",
            "  * unescaped in UTF-8.",
            "@@ -324,30 +325,30 @@",
            "             return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_escape);",
            "         }",
            "         if (decode_hex4(buf + 2, &u)) {",
            "             code[0] = 0;",
            "             return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_escape);",
            "         };",
            "         /* If a high UTF-16 surrogate half pair was detected */",
            "-        if (u >= 0xd800 && u <= 0xdbff && ",
            "+        if (u >= 0xd800 && u <= 0xdbff &&",
            "                 /* and there is space for a matching low half pair */",
            "                 end - buf >= 12 &&",
            "                 /* and there is a second escape following immediately */",
            "                 buf[6] == '\\\\' && buf[7] == 'u' &&",
            "                 /* and it is valid hex */",
            "                 decode_hex4(buf + 8, &u2) == 0 &&",
            "                 /* and it is a low UTF-16 surrogate pair */",
            "                 u2 >= 0xdc00 && u2 <= 0xdfff) {",
            "             /* then decode the pair into a single 4 byte utf-8 sequence. */",
            "             if (decode_utf16_surrogate_pair(u, u2, code)) {",
            "                 code[0] = 0;",
            "                 return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_escape);",
            "             }",
            "             return buf + 12;",
            "-            /*  ",
            "+            /*",
            "              *  Otherwise decode unmatched surrogate pairs as is any",
            "              *  other UTF-8. Some systems might depend on these surviving.",
            "              *  Leave ignored errors for the next parse step.",
            "              */",
            "         }",
            "         decode_unicode_char(u, code);",
            "         return buf + 6;",
            "@@ -484,15 +485,15 @@",
            "         }",
            "     }",
            "     switch (*buf) {",
            "     case '\\\\':",
            "         *more = 0;",
            "         return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_escape);",
            "     case '\\\"':",
            "-        buf = flatcc_json_parser_space(ctx, buf + 1, 0);",
            "+        buf = flatcc_json_parser_space(ctx, buf + 1, end);",
            "         *more = 0;",
            "         return buf;",
            "     }",
            "     *more = 0;",
            "     return mark;",
            " }",
            " ",
            "@@ -599,15 +600,15 @@",
            "         return buf;",
            "     }",
            "     k = buf;",
            "     if (*buf == '-') ++k;",
            "     if (end - k > 1 && (k[0] == '.' || (k[0] == '0' && k[1] == '0'))) {",
            "         return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_numeric);",
            "     }",
            "-    next = parse_double(buf, (int)(end - buf), v);",
            "+    next = parse_double(buf, (size_t)(end - buf), v);",
            "     if (next == 0 || next == buf) {",
            "         if (parse_double_isinf(*v)) {",
            "             return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_overflow);",
            "         }",
            "         return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_numeric);",
            "     }",
            "     return next;",
            "@@ -622,15 +623,15 @@",
            "         return buf;",
            "     }",
            "     k = buf;",
            "     if (*buf == '-') ++k;",
            "     if (end - k > 1 && (k[0] == '.' || (k[0] == '0' && k[1] == '0'))) {",
            "         return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_numeric);",
            "     }",
            "-    next = parse_float(buf, (int)(end - buf), v);",
            "+    next = parse_float(buf, (size_t)(end - buf), v);",
            "     if (next == 0 || next == buf) {",
            "         if (parse_float_isinf(*v)) {",
            "             return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_overflow);",
            "         }",
            "         return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_invalid_numeric);",
            "     }",
            "     return next;",
            "@@ -761,15 +762,15 @@",
            "         return buf;",
            "     }",
            "     k = buf;",
            "     *value_sign = *buf == '-';",
            "     buf += *value_sign;",
            "     while (buf != end && *buf >= '0' && *buf <= '9') {",
            "         x0 = x;",
            "-        x = x * 10 + *buf - '0';",
            "+        x = x * 10 + (uint64_t)(*buf - '0');",
            "         if (x0 > x) {",
            "             return flatcc_json_parser_set_error(ctx, buf, end, value_sign ?",
            "                     flatcc_json_parser_error_underflow : flatcc_json_parser_error_overflow);",
            "         }",
            "         ++buf;",
            "     }",
            "     if (buf == k) {",
            "@@ -797,15 +798,15 @@",
            " ",
            "     mode = urlsafe ? base64_mode_url : base64_mode_rfc4648;",
            "     buf = flatcc_json_parser_string_start(ctx, buf, end);",
            "     buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);",
            "     if (buf == end || *buf != '\\\"') {",
            "         goto base64_failed;",
            "     }",
            "-    max_len = base64_decoded_size(buf - mark);",
            "+    max_len = base64_decoded_size((size_t)(buf - mark));",
            "     if (flatcc_builder_start_vector(ctx->ctx, 1, 1, FLATBUFFERS_COUNT_MAX((utype_size)))) {",
            "         goto failed;",
            "     }",
            "     if (!(pval = flatcc_builder_extend_vector(ctx->ctx, max_len))) {",
            "         goto failed;",
            "     }",
            "     src_len = (size_t)(buf - mark);",
            "@@ -834,34 +835,81 @@",
            " ",
            " base64_failed:",
            "     *ref = 0;",
            "     return flatcc_json_parser_set_error(ctx, buf, end,",
            "             urlsafe ? flatcc_json_parser_error_base64url : flatcc_json_parser_error_base64);",
            " }",
            " ",
            "+const char *flatcc_json_parser_char_array(flatcc_json_parser_t *ctx,",
            "+        const char *buf, const char *end, char *s, size_t n)",
            "+{",
            "+    flatcc_json_parser_escape_buffer_t code;",
            "+    const char *mark;",
            "+    size_t k = 0;",
            "+",
            "+    buf = flatcc_json_parser_string_start(ctx, buf, end);",
            "+    if (buf != end)",
            "+    while (*buf != '\\\"') {",
            "+        buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);",
            "+        if (buf == end) return end;",
            "+        k = (size_t)(buf - mark);",
            "+        if (k > n) {",
            "+            if (!(ctx->flags & flatcc_json_parser_f_skip_array_overflow)) {",
            "+                return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_array_overflow);",
            "+            }",
            "+            k = n; /* Might truncate UTF-8. */",
            "+        }",
            "+        memcpy(s, mark, k);",
            "+        s += k;",
            "+        n -= k;",
            "+        if (*buf == '\\\"') break;",
            "+        buf = flatcc_json_parser_string_escape(ctx, buf, end, code);",
            "+        if (buf == end) return end;",
            "+        k = (size_t)code[0];",
            "+        mark = code + 1;",
            "+        if (k > n) {",
            "+            if (!(ctx->flags & flatcc_json_parser_f_skip_array_overflow)) {",
            "+                return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_array_overflow);",
            "+            }",
            "+            k = n; /* Might truncate UTF-8. */",
            "+        }",
            "+        memcpy(s, mark, k);",
            "+        s += k;",
            "+        n -= k;",
            "+    }",
            "+    if (n != 0) {",
            "+        if (ctx->flags & flatcc_json_parser_f_reject_array_underflow) {",
            "+            return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_array_underflow);",
            "+        }",
            "+        memset(s, 0, n - k);",
            "+    }",
            "+    return flatcc_json_parser_string_end(ctx, buf, end);",
            "+}",
            "+",
            "+",
            " /* String Creation - depends on flatcc builder. */",
            " ",
            " const char *flatcc_json_parser_build_string(flatcc_json_parser_t *ctx,",
            "         const char *buf, const char *end, flatcc_builder_ref_t *ref)",
            " {",
            "     flatcc_json_parser_escape_buffer_t code;",
            "     const char *mark;",
            " ",
            "     buf = flatcc_json_parser_string_start(ctx, buf, end);",
            "     buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);",
            "     if (buf != end && *buf == '\\\"') {",
            "-        *ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);",
            "+        *ref = flatcc_builder_create_string(ctx->ctx, mark, (size_t)(buf - mark));",
            "     } else {",
            "         if (flatcc_builder_start_string(ctx->ctx) ||",
            "-                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;",
            "+                0 == flatcc_builder_append_string(ctx->ctx, mark, (size_t)(buf - mark))) goto failed;",
            "         while (buf != end && *buf != '\\\"') {",
            "             buf = flatcc_json_parser_string_escape(ctx, buf, end, code);",
            "-            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;",
            "+            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, (size_t)code[0])) goto failed;",
            "             if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {",
            "-                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;",
            "+                if (0 == flatcc_builder_append_string(ctx->ctx, mark, (size_t)(buf - mark))) goto failed;",
            "             }",
            "         }",
            "         *ref = flatcc_builder_end_string(ctx->ctx);",
            "     }",
            "     return flatcc_json_parser_string_end(ctx, buf, end);",
            " ",
            " failed:",
            "@@ -1029,15 +1077,15 @@",
            "         buf = flatcc_json_parser_symbolic_uint8(ctx, buf, end, type_parsers, &e->type);",
            "     }",
            "     /* Only count the union if the type is not NONE. */",
            "     if (e->backtrace == 0) {",
            "         f->union_count += e->type != 0;",
            "         return buf;",
            "     }",
            "-    assert(f->union_count);",
            "+    FLATCC_ASSERT(f->union_count);",
            "     --f->union_count;",
            "     /*",
            "      * IMPORTANT: we cannot access any value in the frame or entry",
            "      * pointer after calling union parse because it might cause the",
            "      * stack to reallocate. We should read the frame pointer again if",
            "      * needed - we don't but remember it if refactoring code.",
            "      *",
            "@@ -1186,15 +1234,15 @@",
            "     e = f->unions + union_index;",
            " ",
            "     e->h_types = h_types;",
            "     if (e->backtrace == 0) {",
            "         ++f->union_count;",
            "         return buf;",
            "     }",
            "-    assert(f->union_count);",
            "+    FLATCC_ASSERT(f->union_count);",
            "     --f->union_count;",
            "     line = ctx->line;",
            "     line_start = ctx->line_start;",
            "     ctx->line = e->line;",
            "     ctx->line_start = e->line_start;",
            "     /* We must not assign buf here because we are backtracking. */",
            "     if (end == _parse_union_vector(ctx, e->backtrace, end, h_types, count, id, union_parser)) return end;",
            "@@ -1216,15 +1264,15 @@",
            "     flatcc_json_parser_t _ctx;",
            "     flatcc_builder_ref_t root;",
            "     int builder_flags = flags & flatcc_json_parser_f_with_size ? flatcc_builder_with_size : 0;",
            " ",
            "     ctx = ctx ? ctx : &_ctx;",
            "     flatcc_json_parser_init(ctx, B, buf, buf + bufsiz, flags);",
            "     if (flatcc_builder_start_buffer(B, fid, 0, builder_flags)) return -1;",
            "-    parser(ctx, buf, buf + bufsiz, &root);",
            "+    buf = parser(ctx, buf, buf + bufsiz, &root);",
            "     if (ctx->error) {",
            "         return ctx->error;",
            "     }",
            "     if (!flatcc_builder_end_buffer(B, root)) return -1;",
            "     ctx->end_loc = buf;",
            "     return 0;",
            " }",
            "@@ -1236,15 +1284,15 @@",
            "     flatcc_json_parser_t _ctx;",
            "     flatcc_builder_ref_t root;",
            "     int builder_flags = flags & flatcc_json_parser_f_with_size ? flatcc_builder_with_size : 0;",
            " ",
            "     ctx = ctx ? ctx : &_ctx;",
            "     flatcc_json_parser_init(ctx, B, buf, buf + bufsiz, flags);",
            "     if (flatcc_builder_start_buffer(B, fid, 0, builder_flags)) return -1;",
            "-    parser(ctx, buf, buf + bufsiz, &root);",
            "+    buf = parser(ctx, buf, buf + bufsiz, &root);",
            "     if (ctx->error) {",
            "         return ctx->error;",
            "     }",
            "     if (!flatcc_builder_end_buffer(B, root)) return -1;",
            "     ctx->end_loc = buf;",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/runtime/json_printer.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/runtime/json_printer.c",
            "+++ /home/flatcc-0.6.1/src/runtime/json_printer.c",
            "@@ -1,17 +1,17 @@",
            " /*",
            "  * Runtime support for printing flatbuffers to JSON.",
            "  */",
            " ",
            " #include <stdio.h>",
            "-#include <assert.h>",
            " #include <string.h>",
            " #include <stdlib.h>",
            " ",
            " #include \"flatcc/flatcc_rtconfig.h\"",
            "+#include \"flatcc/flatcc_assert.h\"",
            " ",
            " /*",
            "  * Grisu significantly improves printing speed of floating point values",
            "  * and also the overall printing speed when floating point values are",
            "  * present in non-trivial amounts. (Also applies to parsing).",
            "  */",
            " #if FLATCC_USE_GRISU3 && !defined(PORTABLE_USE_GRISU3)",
            "@@ -75,17 +75,17 @@",
            " static inline voffset_t read_voffset(const void *p, uoffset_t base)",
            " {",
            "     return __flatbuffers_voffset_read_from_pe((uint8_t *)p + base);",
            " }",
            " ",
            " static inline const void *get_field_ptr(flatcc_json_printer_table_descriptor_t *td, int id)",
            " {",
            "-    int vo = (id + 2) * sizeof(voffset_t);",
            "+    uoffset_t vo = (uoffset_t)(id + 2) * (uoffset_t)sizeof(voffset_t);",
            " ",
            "-    if (vo >= td->vsize) {",
            "+    if (vo >= (uoffset_t)td->vsize) {",
            "         return 0;",
            "     }",
            "     vo = read_voffset(td->vtable, vo);",
            "     if (vo == 0) {",
            "         return 0;",
            "     }",
            "     return (uint8_t *)td->table + vo;",
            "@@ -167,22 +167,22 @@",
            " static void print_ex(flatcc_json_printer_t *ctx, const char *s, size_t n)",
            " {",
            "     size_t k;",
            " ",
            "     if (ctx->p >= ctx->pflush) {",
            "         ctx->flush(ctx, 0);",
            "     }",
            "-    k = ctx->pflush - ctx->p;",
            "+    k = (size_t)(ctx->pflush - ctx->p);",
            "     while (n > k) {",
            "         memcpy(ctx->p, s, k);",
            "         ctx->p += k;",
            "         s += k;",
            "         n -= k;",
            "         ctx->flush(ctx, 0);",
            "-        k = ctx->pflush - ctx->p;",
            "+        k = (size_t)(ctx->pflush - ctx->p);",
            "     }",
            "     memcpy(ctx->p, s, n);",
            "     ctx->p += n;",
            " }",
            " ",
            " static inline void print(flatcc_json_printer_t *ctx, const char *s, size_t n)",
            " {",
            "@@ -190,68 +190,106 @@",
            "         print_ex(ctx, s, n);",
            "     } else {",
            "         memcpy(ctx->p, s, n);",
            "         ctx->p += n;",
            "     }",
            " }",
            " ",
            "+static void print_escape(flatcc_json_printer_t *ctx, unsigned char c)",
            "+{",
            "+    unsigned char x;",
            "+",
            "+    print_char('\\\\');",
            "+    switch (c) {",
            "+    case '\"': print_char('\\\"'); break;",
            "+    case '\\\\': print_char('\\\\'); break;",
            "+    case '\\t' : print_char('t'); break;",
            "+    case '\\f' : print_char('f'); break;",
            "+    case '\\r' : print_char('r'); break;",
            "+    case '\\n' : print_char('n'); break;",
            "+    case '\\b' : print_char('b'); break;",
            "+    default:",
            "+        print_char('u');",
            "+        print_char('0');",
            "+        print_char('0');",
            "+        x = c >> 4;",
            "+        x += x < 10 ? '0' : 'a' - 10;",
            "+        print_char((char)x);",
            "+        x = c & 15;",
            "+        x += x < 10 ? '0' : 'a' - 10;",
            "+        print_char((char)x);",
            "+        break;",
            "+    }",
            "+}",
            "+",
            " /*",
            "  * Even though we know the the string length, we need to scan for escape",
            "- * characters. There may be embedded zeroes. Beause FlatBuffer strings",
            "+ * characters. There may be embedded zeroes. Because FlatBuffer strings",
            "  * are always zero terminated, we assume and optimize for this.",
            "  *",
            "  * We enforce \\u00xx for control characters, but not for invalid",
            "  * characters like 0xff - this makes it possible to handle some other",
            "  * codepages transparently while formally not valid.  (Formally JSON",
            "  * also supports UTF-16/32 little/big endian but flatbuffers only",
            "  * support UTF-8 and we expect this in JSON input/output too).",
            "  */",
            " static void print_string(flatcc_json_printer_t *ctx, const char *s, size_t n)",
            " {",
            "     const char *p = s;",
            "     /* Unsigned is important. */",
            "-    unsigned char c, x;",
            "+    unsigned char c;",
            "     size_t k;",
            " ",
            "     print_char('\\\"');",
            "     for (;;) {",
            "-        /*",
            "-         */",
            "-        c = *p;",
            "+        c = (unsigned char)*p;",
            "         while (c >= 0x20 && c != '\\\"' && c != '\\\\') {",
            "-            c = *++p;",
            "+            c = (unsigned char)*++p;",
            "         }",
            "-        k = p - s;",
            "+        k = (size_t)(p - s);",
            "+        /* Even if k == 0, print ensures buffer flush. */",
            "         print(ctx, s, k);",
            "         n -= k;",
            "-        if (n == 0) {",
            "-            break;",
            "-        }",
            "+        if (n == 0) break;",
            "         s += k;",
            "-        print_char('\\\\');",
            "-        switch (c) {",
            "-        case '\"': print_char('\\\"'); break;",
            "-        case '\\\\': print_char('\\\\'); break;",
            "-        case '\\t' : print_char('t'); break;",
            "-        case '\\f' : print_char('f'); break;",
            "-        case '\\r' : print_char('r'); break;",
            "-        case '\\n' : print_char('n'); break;",
            "-        case '\\b' : print_char('b'); break;",
            "-        default:",
            "-            print_char('u');",
            "-            print_char('0');",
            "-            print_char('0');",
            "-            x = c >> 4;",
            "-            x += x < 10 ? '0' : 'a' - 10;",
            "-            print_char(x);",
            "-            x = c & 15;",
            "-            x += x < 10 ? '0' : 'a' - 10;",
            "-            print_char(x);",
            "-            break;",
            "+        print_escape(ctx, c);",
            "+        ++p;",
            "+        --n;",
            "+        ++s;",
            "+    }",
            "+    print_char('\\\"');",
            "+}",
            "+",
            "+/*",
            "+ * Similar to print_string, but null termination is not guaranteed, and",
            "+ * trailing nulls are stripped.",
            "+ */",
            "+static void print_char_array(flatcc_json_printer_t *ctx, const char *s, size_t n)",
            "+{",
            "+    const char *p = s;",
            "+    /* Unsigned is important. */",
            "+    unsigned char c = 0;",
            "+    size_t k;",
            "+",
            "+    while (n > 0 && s[n - 1] == '\\0') --n;",
            "+",
            "+    print_char('\\\"');",
            "+    for (;;) {",
            "+        while (n) {",
            "+            c = (unsigned char)*p;",
            "+            if (c < 0x20 || c == '\\\"' || c == '\\\\') break;",
            "+            ++p;",
            "+            --n;",
            "         }",
            "+        k = (size_t)(p - s);",
            "+        /* Even if k == 0, print ensures buffer flush. */",
            "+        print(ctx, s, k);",
            "+        if (n == 0) break;",
            "+        s += k;",
            "+        print_escape(ctx, c);",
            "         ++p;",
            "         --n;",
            "         ++s;",
            "     }",
            "     print_char('\\\"');",
            " }",
            " ",
            "@@ -269,17 +307,17 @@",
            " ",
            "     len = base64_encoded_size(data_len, mode);",
            "     if (ctx->p + len >= ctx->pflush) {",
            "         ctx->flush(ctx, 0);",
            "     }",
            "     while (ctx->p + len > ctx->pflush) {",
            "         /* Multiples of 4 output chars consumes exactly 3 bytes before final padding. */",
            "-        k = (ctx->pflush - ctx->p) & ~(size_t)3;",
            "+        k = (size_t)(ctx->pflush - ctx->p) & ~(size_t)3;",
            "         n = k * 3 / 4;",
            "-        assert(n > 0);",
            "+        FLATCC_ASSERT(n > 0);",
            "         src_len = k * 3 / 4;",
            "         base64_encode((uint8_t *)ctx->p, data, 0, &src_len, unpadded_mode);",
            "         ctx->p += k;",
            "         data += n;",
            "         data_len -= n;",
            "         ctx->flush(ctx, 0);",
            "         len = base64_encoded_size(data_len, mode);",
            "@@ -292,48 +330,48 @@",
            " static void print_indent_ex(flatcc_json_printer_t *ctx, size_t n)",
            " {",
            "     size_t k;",
            " ",
            "     if (ctx->p >= ctx->pflush) {",
            "         ctx->flush(ctx, 0);",
            "     }",
            "-    k = ctx->pflush - ctx->p;",
            "+    k = (size_t)(ctx->pflush - ctx->p);",
            "     while (n > k) {",
            "         memset(ctx->p, ' ', k);",
            "         ctx->p += k;",
            "         n -= k;",
            "         ctx->flush(ctx, 0);",
            "-        k = ctx->pflush - ctx->p;",
            "+        k = (size_t)(ctx->pflush - ctx->p);",
            "     }",
            "     memset(ctx->p, ' ', n);",
            "     ctx->p += n;",
            " }",
            " ",
            " static inline void print_indent(flatcc_json_printer_t *ctx)",
            " {",
            "-    size_t n = ctx->level * ctx->indent;",
            "+    size_t n = (size_t)(ctx->level * ctx->indent);",
            " ",
            "     if (ctx->p + n > ctx->pflush) {",
            "         print_indent_ex(ctx, n);",
            "     } else {",
            "         memset(ctx->p, ' ', n);",
            "         ctx->p += n;",
            "     }",
            " }",
            " ",
            " /*",
            "  * Helpers for external use - does not do autmatic pretty printing, but",
            "  * does escape strings.",
            "  */",
            "-void flatcc_json_printer_string(flatcc_json_printer_t *ctx, const char *s, int n)",
            "+void flatcc_json_printer_string(flatcc_json_printer_t *ctx, const char *s, size_t n)",
            " {",
            "     print_string(ctx, s, n);",
            " }",
            " ",
            "-void flatcc_json_printer_write(flatcc_json_printer_t *ctx, const char *s, int n)",
            "+void flatcc_json_printer_write(flatcc_json_printer_t *ctx, const char *s, size_t n)",
            " {",
            "     print(ctx, s, n);",
            " }",
            " ",
            " void flatcc_json_printer_nl(flatcc_json_printer_t *ctx)",
            " {",
            "     print_char('\\n');",
            "@@ -400,15 +438,15 @@",
            " __flatcc_define_json_printer_scalar(int8, int8_t)",
            " __flatcc_define_json_printer_scalar(int16, int16_t)",
            " __flatcc_define_json_printer_scalar(int32, int32_t)",
            " __flatcc_define_json_printer_scalar(int64, int64_t)",
            " __flatcc_define_json_printer_scalar(float, float)",
            " __flatcc_define_json_printer_scalar(double, double)",
            " ",
            "-void flatcc_json_printer_enum(flatcc_json_printer_t *ctx, const char *symbol, int len)",
            "+void flatcc_json_printer_enum(flatcc_json_printer_t *ctx, const char *symbol, size_t len)",
            " {",
            "     print_symbol(ctx, symbol, len);",
            " }",
            " ",
            " void flatcc_json_printer_delimit_enum_flags(flatcc_json_printer_t *ctx, int multiple)",
            " {",
            " #if FLATCC_JSON_PRINT_ALWAYS_QUOTE_MULTIPLE_FLAGS",
            "@@ -416,15 +454,15 @@",
            " #else",
            "     int quote = !ctx->unquote;",
            " #endif",
            "     *ctx->p = '\"';",
            "     ctx->p += quote;",
            " }",
            " ",
            "-void flatcc_json_printer_enum_flag(flatcc_json_printer_t *ctx, int count, const char *symbol, int len)",
            "+void flatcc_json_printer_enum_flag(flatcc_json_printer_t *ctx, int count, const char *symbol, size_t len)",
            " {",
            "     *ctx->p = ' ';",
            "     ctx->p += count > 0;",
            "     print(ctx, symbol, len);",
            " }",
            " ",
            " static inline void print_string_object(flatcc_json_printer_t *ctx, const void *p)",
            "@@ -436,30 +474,114 @@",
            "     s = (const char *)p + uoffset_size;",
            "     print_string(ctx, s, len);",
            " }",
            " ",
            " #define __define_print_scalar_struct_field(TN, T)                           \\",
            " void flatcc_json_printer_ ## TN ## _struct_field(flatcc_json_printer_t *ctx,\\",
            "         int index, const void *p, size_t offset,                            \\",
            "-        const char *name, int len)                                          \\",
            "+        const char *name, size_t len)                                       \\",
            " {                                                                           \\",
            "     T x = flatbuffers_ ## TN ## _read_from_pe((uint8_t *)p + offset);       \\",
            "                                                                             \\",
            "     if (index) {                                                            \\",
            "         print_char(',');                                                    \\",
            "     }                                                                       \\",
            "     print_name(ctx, name, len);                                             \\",
            "     ctx->p += print_ ## TN (x, ctx->p);                                     \\",
            " }",
            " ",
            "+void flatcc_json_printer_char_array_struct_field(",
            "+        flatcc_json_printer_t *ctx,",
            "+        int index, const void *p, size_t offset,",
            "+        const char *name, size_t len, size_t count)",
            "+{",
            "+    p = (void *)((size_t)p + offset);",
            "+    if (index) {",
            "+        print_char(',');",
            "+    }",
            "+    print_name(ctx, name, len);",
            "+    print_char_array(ctx, p, count);",
            "+}",
            "+",
            "+#define __define_print_scalar_array_struct_field(TN, T)                     \\",
            "+void flatcc_json_printer_ ## TN ## _array_struct_field(                     \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        int index, const void *p, size_t offset,                            \\",
            "+        const char *name, size_t len, size_t count)                         \\",
            "+{                                                                           \\",
            "+    p = (void *)((size_t)p + offset);                                       \\",
            "+    if (index) {                                                            \\",
            "+        print_char(',');                                                    \\",
            "+    }                                                                       \\",
            "+    print_name(ctx, name, len);                                             \\",
            "+    print_start('[');                                                       \\",
            "+    if (count) {                                                            \\",
            "+        print_nl();                                                         \\",
            "+        ctx->p += print_ ## TN (                                            \\",
            "+                flatbuffers_ ## TN ## _read_from_pe(p),                     \\",
            "+                ctx->p);                                                    \\",
            "+        p = (void *)((size_t)p + sizeof(T));                                \\",
            "+        --count;                                                            \\",
            "+    }                                                                       \\",
            "+    while (count--) {                                                       \\",
            "+        print_char(',');                                                    \\",
            "+        print_nl();                                                         \\",
            "+        ctx->p += print_ ## TN (                                            \\",
            "+                flatbuffers_ ## TN ## _read_from_pe(p),                     \\",
            "+                ctx->p);                                                    \\",
            "+        p = (void *)((size_t)p + sizeof(T));                                \\",
            "+    }                                                                       \\",
            "+    print_end(']');                                                         \\",
            "+}",
            "+",
            "+#define __define_print_enum_array_struct_field(TN, T)                       \\",
            "+void flatcc_json_printer_ ## TN ## _enum_array_struct_field(                \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        int index, const void *p, size_t offset,                            \\",
            "+        const char *name, size_t len, size_t count,                         \\",
            "+        flatcc_json_printer_ ## TN ##_enum_f *pf)                           \\",
            "+{                                                                           \\",
            "+    T x;                                                                    \\",
            "+                                                                            \\",
            "+    p = (void *)((size_t)p + offset);                                       \\",
            "+    if (index) {                                                            \\",
            "+        print_char(',');                                                    \\",
            "+    }                                                                       \\",
            "+    print_name(ctx, name, len);                                             \\",
            "+    print_start('[');                                                       \\",
            "+    if (count) {                                                            \\",
            "+        print_nl();                                                         \\",
            "+        x = flatbuffers_ ## TN ## _read_from_pe(p);                         \\",
            "+        if (ctx->noenum) {                                                  \\",
            "+            ctx->p += print_ ## TN (x, ctx->p);                             \\",
            "+        } else {                                                            \\",
            "+            pf(ctx, x);                                                     \\",
            "+        }                                                                   \\",
            "+        p = (void *)((size_t)p + sizeof(T));                                \\",
            "+        --count;                                                            \\",
            "+    }                                                                       \\",
            "+    while (count--) {                                                       \\",
            "+        print_char(',');                                                    \\",
            "+        print_nl();                                                         \\",
            "+        x = flatbuffers_ ## TN ## _read_from_pe(p);                         \\",
            "+        if (ctx->noenum) {                                                  \\",
            "+            ctx->p += print_ ## TN (x, ctx->p);                             \\",
            "+        } else {                                                            \\",
            "+            pf(ctx, x);                                                     \\",
            "+        }                                                                   \\",
            "+        p = (void *)((size_t)p + sizeof(T));                                \\",
            "+    }                                                                       \\",
            "+    print_end(']');                                                         \\",
            "+}",
            "+",
            " #define __define_print_enum_struct_field(TN, T)                             \\",
            " void flatcc_json_printer_ ## TN ## _enum_struct_field(                      \\",
            "         flatcc_json_printer_t *ctx,                                         \\",
            "         int index, const void *p, size_t offset,                            \\",
            "-        const char *name, int len,                                          \\",
            "+        const char *name, size_t len,                                       \\",
            "         flatcc_json_printer_ ## TN ##_enum_f *pf)                           \\",
            " {                                                                           \\",
            "     T x = flatbuffers_ ## TN ## _read_from_pe((uint8_t *)p + offset);       \\",
            "                                                                             \\",
            "     if (index) {                                                            \\",
            "         print_char(',');                                                    \\",
            "     }                                                                       \\",
            "@@ -470,15 +592,15 @@",
            "         pf(ctx, x);                                                         \\",
            "     }                                                                       \\",
            " }",
            " ",
            " #define __define_print_scalar_field(TN, T)                                  \\",
            " void flatcc_json_printer_ ## TN ## _field(flatcc_json_printer_t *ctx,       \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len, T v)                             \\",
            "+        int id, const char *name, size_t len, T v)                          \\",
            " {                                                                           \\",
            "     T x;                                                                    \\",
            "     const void *p = get_field_ptr(td, id);                                  \\",
            "                                                                             \\",
            "     if (p) {                                                                \\",
            "         x = flatbuffers_ ## TN ## _read_from_pe(p);                         \\",
            "         if (x == v && ctx->skip_default) {                                  \\",
            "@@ -493,18 +615,37 @@",
            "     if (td->count++) {                                                      \\",
            "         print_char(',');                                                    \\",
            "     }                                                                       \\",
            "     print_name(ctx, name, len);                                             \\",
            "     ctx->p += print_ ## TN (x, ctx->p);                                     \\",
            " }",
            " ",
            "+#define __define_print_scalar_optional_field(TN, T)                         \\",
            "+void flatcc_json_printer_ ## TN ## _optional_field(                         \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        flatcc_json_printer_table_descriptor_t *td,                         \\",
            "+        int id, const char *name, size_t len)                               \\",
            "+{                                                                           \\",
            "+    T x;                                                                    \\",
            "+    const void *p = get_field_ptr(td, id);                                  \\",
            "+                                                                            \\",
            "+    if (!p) return;                                                         \\",
            "+    x = flatbuffers_ ## TN ## _read_from_pe(p);                             \\",
            "+    if (td->count++) {                                                      \\",
            "+        print_char(',');                                                    \\",
            "+    }                                                                       \\",
            "+    print_name(ctx, name, len);                                             \\",
            "+    ctx->p += print_ ## TN (x, ctx->p);                                     \\",
            "+}",
            "+",
            "+",
            " #define __define_print_enum_field(TN, T)                                    \\",
            " void flatcc_json_printer_ ## TN ## _enum_field(flatcc_json_printer_t *ctx,  \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len, T v,                             \\",
            "+        int id, const char *name, size_t len, T v,                          \\",
            "         flatcc_json_printer_ ## TN ##_enum_f *pf)                           \\",
            " {                                                                           \\",
            "     T x;                                                                    \\",
            "     const void *p = get_field_ptr(td, id);                                  \\",
            "                                                                             \\",
            "     if (p) {                                                                \\",
            "         x = flatbuffers_ ## TN ## _read_from_pe(p);                         \\",
            "@@ -524,14 +665,37 @@",
            "     if (ctx->noenum) {                                                      \\",
            "         ctx->p += print_ ## TN (x, ctx->p);                                 \\",
            "     } else {                                                                \\",
            "         pf(ctx, x);                                                         \\",
            "     }                                                                       \\",
            " }",
            " ",
            "+#define __define_print_enum_optional_field(TN, T)                           \\",
            "+void flatcc_json_printer_ ## TN ## _enum_optional_field(                    \\",
            "+        flatcc_json_printer_t *ctx,                                         \\",
            "+        flatcc_json_printer_table_descriptor_t *td,                         \\",
            "+        int id, const char *name, size_t len,                               \\",
            "+        flatcc_json_printer_ ## TN ##_enum_f *pf)                           \\",
            "+{                                                                           \\",
            "+    T x;                                                                    \\",
            "+    const void *p = get_field_ptr(td, id);                                  \\",
            "+                                                                            \\",
            "+    if (!p) return;                                                         \\",
            "+    x = flatbuffers_ ## TN ## _read_from_pe(p);                             \\",
            "+    if (td->count++) {                                                      \\",
            "+        print_char(',');                                                    \\",
            "+    }                                                                       \\",
            "+    print_name(ctx, name, len);                                             \\",
            "+    if (ctx->noenum) {                                                      \\",
            "+        ctx->p += print_ ## TN (x, ctx->p);                                 \\",
            "+    } else {                                                                \\",
            "+        pf(ctx, x);                                                         \\",
            "+    }                                                                       \\",
            "+}",
            "+",
            " static inline void print_table_object(flatcc_json_printer_t *ctx,",
            "         const void *p, int ttl, flatcc_json_printer_table_f pf)",
            " {",
            "     flatcc_json_printer_table_descriptor_t td;",
            " ",
            "     if (!--ttl) {",
            "         flatcc_json_printer_set_error(ctx, flatcc_json_printer_error_deep_recursion);",
            "@@ -545,30 +709,30 @@",
            "     td.vsize = __flatbuffers_voffset_read_from_pe(td.vtable);",
            "     pf(ctx, &td);",
            "     print_end('}');",
            " }",
            " ",
            " void flatcc_json_printer_string_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len)",
            "+        int id, const char *name, size_t len)",
            " {",
            "     const void *p = get_field_ptr(td, id);",
            " ",
            "     if (p) {",
            "         if (td->count++) {",
            "             print_char(',');",
            "         }",
            "         print_name(ctx, name, len);",
            "         print_string_object(ctx, read_uoffset_ptr(p));",
            "     }",
            " }",
            " ",
            " void flatcc_json_printer_uint8_vector_base64_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len, int urlsafe)",
            "+        int id, const char *name, size_t len, int urlsafe)",
            " {",
            "     const void *p = get_field_ptr(td, id);",
            "     int mode;",
            " ",
            "     mode = urlsafe ? base64_mode_url : base64_mode_rfc4648;",
            "     mode |= base64_enc_modifier_padding;",
            " ",
            "@@ -581,15 +745,15 @@",
            "     }",
            " }",
            " ",
            " #define __define_print_scalar_vector_field(TN, T)                           \\",
            " void flatcc_json_printer_ ## TN ## _vector_field(                           \\",
            "         flatcc_json_printer_t *ctx,                                         \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len)                                  \\",
            "+        int id, const char *name, size_t len)                               \\",
            " {                                                                           \\",
            "     const void *p = get_field_ptr(td, id);                                  \\",
            "     uoffset_t count;                                                        \\",
            "                                                                             \\",
            "     if (p) {                                                                \\",
            "         if (td->count++) {                                                  \\",
            "             print_char(',');                                                \\",
            "@@ -619,15 +783,15 @@",
            "     }                                                                       \\",
            " }",
            " ",
            " #define __define_print_enum_vector_field(TN, T)                             \\",
            " void flatcc_json_printer_ ## TN ## _enum_vector_field(                      \\",
            "         flatcc_json_printer_t *ctx,                                         \\",
            "         flatcc_json_printer_table_descriptor_t *td,                         \\",
            "-        int id, const char *name, int len,                                  \\",
            "+        int id, const char *name, size_t len,                               \\",
            "         flatcc_json_printer_ ## TN ##_enum_f *pf)                           \\",
            " {                                                                           \\",
            "     const void *p;                                                          \\",
            "     uoffset_t count;                                                        \\",
            "                                                                             \\",
            "     if (ctx->noenum) {                                                      \\",
            "         flatcc_json_printer_ ## TN ## _vector_field(ctx, td, id, name, len);\\",
            "@@ -677,26 +841,70 @@",
            " __define_print_enum_field(uint64, uint64_t)",
            " __define_print_enum_field(int8, int8_t)",
            " __define_print_enum_field(int16, int16_t)",
            " __define_print_enum_field(int32, int32_t)",
            " __define_print_enum_field(int64, int64_t)",
            " __define_print_enum_field(bool, flatbuffers_bool_t)",
            " ",
            "+__define_print_scalar_optional_field(uint8, uint8_t)",
            "+__define_print_scalar_optional_field(uint16, uint16_t)",
            "+__define_print_scalar_optional_field(uint32, uint32_t)",
            "+__define_print_scalar_optional_field(uint64, uint64_t)",
            "+__define_print_scalar_optional_field(int8, int8_t)",
            "+__define_print_scalar_optional_field(int16, int16_t)",
            "+__define_print_scalar_optional_field(int32, int32_t)",
            "+__define_print_scalar_optional_field(int64, int64_t)",
            "+__define_print_scalar_optional_field(bool, flatbuffers_bool_t)",
            "+__define_print_scalar_optional_field(float, float)",
            "+__define_print_scalar_optional_field(double, double)",
            "+",
            "+__define_print_enum_optional_field(uint8, uint8_t)",
            "+__define_print_enum_optional_field(uint16, uint16_t)",
            "+__define_print_enum_optional_field(uint32, uint32_t)",
            "+__define_print_enum_optional_field(uint64, uint64_t)",
            "+__define_print_enum_optional_field(int8, int8_t)",
            "+__define_print_enum_optional_field(int16, int16_t)",
            "+__define_print_enum_optional_field(int32, int32_t)",
            "+__define_print_enum_optional_field(int64, int64_t)",
            "+__define_print_enum_optional_field(bool, flatbuffers_bool_t)",
            "+",
            " __define_print_scalar_struct_field(uint8, uint8_t)",
            " __define_print_scalar_struct_field(uint16, uint16_t)",
            " __define_print_scalar_struct_field(uint32, uint32_t)",
            " __define_print_scalar_struct_field(uint64, uint64_t)",
            " __define_print_scalar_struct_field(int8, int8_t)",
            " __define_print_scalar_struct_field(int16, int16_t)",
            " __define_print_scalar_struct_field(int32, int32_t)",
            " __define_print_scalar_struct_field(int64, int64_t)",
            " __define_print_scalar_struct_field(bool, flatbuffers_bool_t)",
            " __define_print_scalar_struct_field(float, float)",
            " __define_print_scalar_struct_field(double, double)",
            " ",
            "+__define_print_scalar_array_struct_field(uint8, uint8_t)",
            "+__define_print_scalar_array_struct_field(uint16, uint16_t)",
            "+__define_print_scalar_array_struct_field(uint32, uint32_t)",
            "+__define_print_scalar_array_struct_field(uint64, uint64_t)",
            "+__define_print_scalar_array_struct_field(int8, int8_t)",
            "+__define_print_scalar_array_struct_field(int16, int16_t)",
            "+__define_print_scalar_array_struct_field(int32, int32_t)",
            "+__define_print_scalar_array_struct_field(int64, int64_t)",
            "+__define_print_scalar_array_struct_field(bool, flatbuffers_bool_t)",
            "+__define_print_scalar_array_struct_field(float, float)",
            "+__define_print_scalar_array_struct_field(double, double)",
            "+",
            "+__define_print_enum_array_struct_field(uint8, uint8_t)",
            "+__define_print_enum_array_struct_field(uint16, uint16_t)",
            "+__define_print_enum_array_struct_field(uint32, uint32_t)",
            "+__define_print_enum_array_struct_field(uint64, uint64_t)",
            "+__define_print_enum_array_struct_field(int8, int8_t)",
            "+__define_print_enum_array_struct_field(int16, int16_t)",
            "+__define_print_enum_array_struct_field(int32, int32_t)",
            "+__define_print_enum_array_struct_field(int64, int64_t)",
            "+__define_print_enum_array_struct_field(bool, flatbuffers_bool_t)",
            "+",
            " __define_print_enum_struct_field(uint8, uint8_t)",
            " __define_print_enum_struct_field(uint16, uint16_t)",
            " __define_print_enum_struct_field(uint32, uint32_t)",
            " __define_print_enum_struct_field(uint64, uint64_t)",
            " __define_print_enum_struct_field(int8, int8_t)",
            " __define_print_enum_struct_field(int16, int16_t)",
            " __define_print_enum_struct_field(int32, int32_t)",
            "@@ -725,15 +933,15 @@",
            " __define_print_enum_vector_field(int16, int16_t)",
            " __define_print_enum_vector_field(int32, int32_t)",
            " __define_print_enum_vector_field(int64, int64_t)",
            " __define_print_enum_vector_field(bool, flatbuffers_bool_t)",
            " ",
            " void flatcc_json_printer_struct_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         size_t size,",
            "         flatcc_json_printer_struct_f pf)",
            " {",
            "     const uint8_t *p = get_field_ptr(td, id);",
            "     uoffset_t count;",
            " ",
            "     if (p) {",
            "@@ -762,15 +970,15 @@",
            "         }",
            "         print_end(']');",
            "     }",
            " }",
            " ",
            " void flatcc_json_printer_string_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len)",
            "+        int id, const char *name, size_t len)",
            " {",
            "     const uoffset_t *p = get_field_ptr(td, id);",
            "     uoffset_t count;",
            " ",
            "     if (p) {",
            "         if (td->count++) {",
            "             print_char(',');",
            "@@ -793,15 +1001,15 @@",
            "         }",
            "         print_end(']');",
            "     }",
            " }",
            " ",
            " void flatcc_json_printer_table_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_table_f pf)",
            " {",
            "     const uoffset_t *p = get_field_ptr(td, id);",
            "     uoffset_t count;",
            " ",
            "     if (p) {",
            "         if (td->count++) {",
            "@@ -823,29 +1031,29 @@",
            "         }",
            "         print_end(']');",
            "     }",
            " }",
            " ",
            " void flatcc_json_printer_union_vector_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_union_type_f ptf,",
            "         flatcc_json_printer_union_f pf)",
            " {",
            "     const uoffset_t *pt = get_field_ptr(td, id - 1);",
            "     const uoffset_t *p = get_field_ptr(td, id);",
            "     utype_t *types, type;",
            "     uoffset_t count;",
            "     char type_name[FLATCC_JSON_PRINT_NAME_LEN_MAX + 5];",
            "     flatcc_json_printer_union_descriptor_t ud;",
            " ",
            "     ud.ttl = td->ttl;",
            "     if (len > FLATCC_JSON_PRINT_NAME_LEN_MAX) {",
            "         RAISE_ERROR(bad_input);",
            "-        assert(0 && \"identifier too long\");",
            "+        FLATCC_ASSERT(0 && \"identifier too long\");",
            "         return;",
            "     }",
            "     memcpy(type_name, name, len);",
            "     memcpy(type_name + len, \"_type\", 5);",
            "     if (p && pt) {",
            "         flatcc_json_printer_utype_enum_vector_field(ctx, td, id - 1,",
            "                 type_name, len + 5, ptf);",
            "@@ -887,15 +1095,15 @@",
            "         }",
            "         print_end(']');",
            "     }",
            " }",
            " ",
            " void flatcc_json_printer_table_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_table_f pf)",
            " {",
            "     const void *p = get_field_ptr(td, id);",
            " ",
            "     if (p) {",
            "         if (td->count++) {",
            "             print_char(',');",
            "@@ -903,15 +1111,15 @@",
            "         print_name(ctx, name, len);",
            "         print_table_object(ctx, read_uoffset_ptr(p), td->ttl, pf);",
            "     }",
            " }",
            " ",
            " void flatcc_json_printer_union_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_union_type_f ptf,",
            "         flatcc_json_printer_union_f pf)",
            " {",
            "     const void *pt = get_field_ptr(td, id - 1);",
            "     const void *p = get_field_ptr(td, id);",
            "     utype_t type;",
            "     flatcc_json_printer_union_descriptor_t ud;",
            "@@ -972,29 +1180,52 @@",
            "         flatcc_json_printer_union_descriptor_t *ud)",
            " {",
            "     print_string_object(ctx, read_uoffset_ptr(ud->member));",
            " }",
            " ",
            " void flatcc_json_printer_embedded_struct_field(flatcc_json_printer_t *ctx,",
            "         int index, const void *p, size_t offset,",
            "-        const char *name, int len,",
            "+        const char *name, size_t len,",
            "         flatcc_json_printer_struct_f pf)",
            " {",
            "     if (index) {",
            "         print_char(',');",
            "     }",
            "     print_name(ctx, name, len);",
            "     print_start('{');",
            "     pf(ctx, (uint8_t *)p + offset);",
            "     print_end('}');",
            " }",
            " ",
            "+void flatcc_json_printer_embedded_struct_array_field(flatcc_json_printer_t *ctx,",
            "+        int index, const void *p, size_t offset,",
            "+        const char *name, size_t len,",
            "+        size_t size, size_t count,",
            "+        flatcc_json_printer_struct_f pf)",
            "+{",
            "+    size_t i;",
            "+    if (index) {",
            "+        print_char(',');",
            "+    }",
            "+    print_name(ctx, name, len);",
            "+    print_start('[');",
            "+    for (i = 0; i < count; ++i) {",
            "+        if (i > 0) {",
            "+            print_char(',');",
            "+        }",
            "+        print_start('{');                                                   \\",
            "+        pf(ctx, (uint8_t *)p + offset + i * size);",
            "+        print_end('}');",
            "+    }",
            "+    print_end(']');",
            "+}",
            "+",
            " void flatcc_json_printer_struct_field(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         flatcc_json_printer_struct_f *pf)",
            " {",
            "     const void *p = get_field_ptr(td, id);",
            " ",
            "     if (p) {",
            "         if (td->count++) {",
            "             print_char(',');",
            "@@ -1016,23 +1247,23 @@",
            " static int accept_header(flatcc_json_printer_t * ctx,",
            "         const void *buf, size_t bufsiz, const char *fid)",
            " {",
            "     flatbuffers_thash_t id, id2 = 0;",
            " ",
            "     if (buf == 0 || bufsiz < offset_size + FLATBUFFERS_IDENTIFIER_SIZE) {",
            "         RAISE_ERROR(bad_input);",
            "-        assert(0 && \"buffer header too small\");",
            "+        FLATCC_ASSERT(0 && \"buffer header too small\");",
            "         return 0;",
            "     }",
            "     if (fid != 0) {",
            "         id2 = flatbuffers_type_hash_from_string(fid);",
            "         id = __flatbuffers_thash_read_from_pe((uint8_t *)buf + offset_size);",
            "         if (!(id2 == 0 || id == id2)) {",
            "             RAISE_ERROR(bad_input);",
            "-            assert(0 && \"identifier mismatch\");",
            "+            FLATCC_ASSERT(0 && \"identifier mismatch\");",
            "             return 0;",
            "         }",
            "     }",
            "     return 1;",
            " }",
            " ",
            " int flatcc_json_printer_struct_as_root(flatcc_json_printer_t *ctx,",
            "@@ -1042,31 +1273,31 @@",
            "     if (!accept_header(ctx, buf, bufsiz, fid)) {",
            "         return -1;",
            "     }",
            "     print_start('{');",
            "     pf(ctx, read_uoffset_ptr(buf));",
            "     print_end('}');",
            "     print_last_nl();",
            "-    return flatcc_json_printer_get_error(ctx) ? -1 : (int)(ctx->total + (ctx->p - ctx->buf));",
            "+    return flatcc_json_printer_get_error(ctx) ? -1 : (int)ctx->total + (int)(ctx->p - ctx->buf);",
            " }",
            " ",
            " int flatcc_json_printer_table_as_root(flatcc_json_printer_t *ctx,",
            "         const void *buf, size_t bufsiz, const char *fid, flatcc_json_printer_table_f *pf)",
            " {",
            "     if (!accept_header(ctx, buf, bufsiz, fid)) {",
            "         return -1;",
            "     }",
            "     print_table_object(ctx, read_uoffset_ptr(buf), FLATCC_JSON_PRINT_MAX_LEVELS, pf);",
            "     print_last_nl();",
            "-    return flatcc_json_printer_get_error(ctx) ? -1 : (int)(ctx->total + (ctx->p - ctx->buf));",
            "+    return flatcc_json_printer_get_error(ctx) ? -1 : (int)ctx->total + (int)(ctx->p - ctx->buf);",
            " }",
            " ",
            " void flatcc_json_printer_struct_as_nested_root(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         const char *fid,",
            "         flatcc_json_printer_struct_f *pf)",
            " {",
            "     const uoffset_t *buf;",
            "     uoffset_t bufsiz;",
            " ",
            "     if (0 == (buf = get_field_ptr(td, id))) {",
            "@@ -1084,15 +1315,15 @@",
            "     print_start('{');",
            "     pf(ctx, read_uoffset_ptr(buf));",
            "     print_end('}');",
            " }",
            " ",
            " void flatcc_json_printer_table_as_nested_root(flatcc_json_printer_t *ctx,",
            "         flatcc_json_printer_table_descriptor_t *td,",
            "-        int id, const char *name, int len,",
            "+        int id, const char *name, size_t len,",
            "         const char *fid,",
            "         flatcc_json_printer_table_f pf)",
            " {",
            "     const uoffset_t *buf;",
            "     uoffset_t bufsiz;",
            " ",
            "     if (0 == (buf = get_field_ptr(td, id))) {",
            "@@ -1110,22 +1341,22 @@",
            "     print_name(ctx, name, len);",
            "     print_table_object(ctx, read_uoffset_ptr(buf), td->ttl, pf);",
            " }",
            " ",
            " static void __flatcc_json_printer_flush(flatcc_json_printer_t *ctx, int all)",
            " {",
            "     if (!all && ctx->p >= ctx->pflush) {",
            "-        size_t spill = ctx->p - ctx->pflush;",
            "+        size_t spill = (size_t)(ctx->p - ctx->pflush);",
            " ",
            "         fwrite(ctx->buf, ctx->flush_size, 1, ctx->fp);",
            "         memcpy(ctx->buf, ctx->buf + ctx->flush_size, spill);",
            "         ctx->p = ctx->buf + spill;",
            "         ctx->total += ctx->flush_size;",
            "     } else {",
            "-        size_t len = ctx->p - ctx->buf;",
            "+        size_t len = (size_t)(ctx->p - ctx->buf);",
            " ",
            "         fwrite(ctx->buf, len, 1, ctx->fp);",
            "         ctx->p = ctx->buf;",
            "         ctx->total += len;",
            "     }",
            "     *ctx->p = '\\0';",
            " }",
            "@@ -1143,33 +1374,33 @@",
            "     ctx->flush_size = FLATCC_JSON_PRINT_FLUSH_SIZE;",
            "     ctx->p = ctx->buf;",
            "     ctx->pflush = ctx->buf + ctx->flush_size;",
            "     /*",
            "      * Make sure we have space for primitive operations such as printing numbers",
            "      * without having to flush.",
            "      */",
            "-    assert(ctx->flush_size + FLATCC_JSON_PRINT_RESERVE <= ctx->size);",
            "+    FLATCC_ASSERT(ctx->flush_size + FLATCC_JSON_PRINT_RESERVE <= ctx->size);",
            "     return 0;",
            " }",
            " ",
            " static void __flatcc_json_printer_flush_buffer(flatcc_json_printer_t *ctx, int all)",
            " {",
            "     (void)all;",
            " ",
            "     if (ctx->p >= ctx->pflush) {",
            "         RAISE_ERROR(overflow);",
            "-        ctx->total += ctx->p - ctx->buf;",
            "+        ctx->total += (size_t)(ctx->p - ctx->buf);",
            "         ctx->p = ctx->buf;",
            "     }",
            "     *ctx->p = '\\0';",
            " }",
            " ",
            " int flatcc_json_printer_init_buffer(flatcc_json_printer_t *ctx, char *buffer, size_t buffer_size)",
            " {",
            "-    assert(buffer_size >= FLATCC_JSON_PRINT_RESERVE);",
            "+    FLATCC_ASSERT(buffer_size >= FLATCC_JSON_PRINT_RESERVE);",
            "     if (buffer_size < FLATCC_JSON_PRINT_RESERVE) {",
            "         return -1;",
            "     }",
            "     memset(ctx, 0, sizeof(*ctx));",
            "     ctx->buf = buffer;",
            "     ctx->size = buffer_size;",
            "     ctx->flush_size = ctx->size - FLATCC_JSON_PRINT_RESERVE;",
            "@@ -1177,15 +1408,15 @@",
            "     ctx->pflush = ctx->buf + ctx->flush_size;",
            "     ctx->flush = __flatcc_json_printer_flush_buffer;",
            "     return 0;",
            " }",
            " ",
            " static void __flatcc_json_printer_flush_dynamic_buffer(flatcc_json_printer_t *ctx, int all)",
            " {",
            "-    size_t len = ctx->p - ctx->buf;",
            "+    size_t len = (size_t)(ctx->p - ctx->buf);",
            "     char *p;",
            " ",
            "     (void)all;",
            " ",
            "     *ctx->p = '\\0';",
            "     if (ctx->p < ctx->pflush) {",
            "         return;",
            "@@ -1228,15 +1459,15 @@",
            "     return 0;",
            " }",
            " ",
            " void *flatcc_json_printer_get_buffer(flatcc_json_printer_t *ctx, size_t *buffer_size)",
            " {",
            "     ctx->flush(ctx, 0);",
            "     if (buffer_size) {",
            "-        *buffer_size = ctx->p - ctx->buf;",
            "+        *buffer_size = (size_t)(ctx->p - ctx->buf);",
            "     }",
            "     return ctx->buf;",
            " }",
            " ",
            " void *flatcc_json_printer_finalize_dynamic_buffer(flatcc_json_printer_t *ctx, size_t *buffer_size)",
            " {",
            "     void *buffer;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/runtime/refmap.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/runtime/refmap.c",
            "+++ /home/flatcc-0.6.1/src/runtime/refmap.c",
            "@@ -8,19 +8,19 @@",
            "  * references. In the basic use case no allocation takes place because a",
            "  * few references can be held using only a small stack allocated hash",
            "  * table.",
            "  */",
            " ",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include <assert.h>",
            " ",
            " #include \"flatcc/flatcc_rtconfig.h\"",
            " #include \"flatcc/flatcc_refmap.h\"",
            " #include \"flatcc/flatcc_alloc.h\"",
            "+#include \"flatcc/flatcc_assert.h\"",
            " ",
            " #define _flatcc_refmap_calloc FLATCC_CALLOC",
            " #define _flatcc_refmap_free FLATCC_FREE",
            " ",
            " /* Can be used as a primitive defense against collision attacks. */",
            " #ifdef FLATCC_HASH_SEED",
            " #define _flatcc_refmap_seed FLATCC_HASH_SEED",
            "@@ -98,15 +98,15 @@",
            "     if (buckets == min_buckets) {",
            "         memset(refmap->min_table, 0, sizeof(refmap->min_table));",
            "         refmap->table = refmap->min_table;",
            "     } else {",
            "         refmap->table = _flatcc_refmap_calloc(buckets, sizeof(refmap->table[0]));",
            "         if (refmap->table == 0) {",
            "             refmap->table = T_old;",
            "-            assert(0); /* out of memory */",
            "+            FLATCC_ASSERT(0); /* out of memory */",
            "             return -1;",
            "         }",
            "     }",
            "     refmap->buckets = buckets;",
            "     refmap->count = 0;",
            "     for (i = 0; i < buckets_old; ++i) {",
            "         if (T_old[i].src) {"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/src/runtime/verifier.c",
          "change": [
            "--- /home/flatcc-0.5.3/src/runtime/verifier.c",
            "+++ /home/flatcc-0.6.1/src/runtime/verifier.c",
            "@@ -1,28 +1,27 @@",
            " /*",
            "  * Runtime support for verifying flatbuffers.",
            "  *",
            "  * Depends mutually on generated verifier functions for table types that",
            "  * call into this library.",
            "  */",
            "-#include <assert.h>",
            " #include <string.h>",
            " ",
            " #include \"flatcc/flatcc_rtconfig.h\"",
            " #include \"flatcc/flatcc_flatbuffers.h\"",
            " #include \"flatcc/flatcc_verifier.h\"",
            " #include \"flatcc/flatcc_identifier.h\"",
            " ",
            " /* Customization for testing. */",
            " #if FLATCC_DEBUG_VERIFY",
            " #define FLATCC_VERIFIER_ASSERT_ON_ERROR 1",
            " #include <stdio.h>",
            " #define FLATCC_VERIFIER_ASSERT(cond, reason)                                \\",
            "     if (!(cond)) { fprintf(stderr, \"verifier assert: %s\\n\",                 \\",
            "-        flatcc_verify_error_string(reason)); assert(0); return reason; }",
            "+        flatcc_verify_error_string(reason)); FLATCC_ASSERT(0); return reason; }",
            " #endif",
            " ",
            " #if FLATCC_TRACE_VERIFY",
            " #include <stdio.h>",
            " #define trace_verify(s, p) \\",
            "     fprintf(stderr, \"trace verify: %s: 0x%02x\\n\", (s), (unsigned)(size_t)(p));",
            " #else",
            "@@ -49,15 +48,15 @@",
            "  */",
            " #ifndef FLATCC_VERIFIER_ASSERT_ON_ERROR",
            " #define FLATCC_VERIFIER_ASSERT_ON_ERROR 1",
            " #endif",
            " ",
            " /* May be redefined for logging purposes. */",
            " #ifndef FLATCC_VERIFIER_ASSERT",
            "-#define FLATCC_VERIFIER_ASSERT(cond, reason) assert(cond)",
            "+#define FLATCC_VERIFIER_ASSERT(cond, reason) FLATCC_ASSERT(cond)",
            " #endif",
            " ",
            " #if FLATCC_VERIFIER_ASSERT_ON_ERROR",
            " #define flatcc_verify(cond, reason) if (!(cond)) { FLATCC_VERIFIER_ASSERT(cond, reason); return reason; }",
            " #else",
            " #define flatcc_verify(cond, reason) if (!(cond)) { return reason; }",
            " #endif",
            "@@ -143,33 +142,33 @@",
            "     if (uoffset_size <= voffset_size && k + offset_size < k) {",
            "         return 0;",
            "     }",
            "     /* Alignment refers to element 0 and header must also be aligned. */",
            "     align = align < uoffset_size ? uoffset_size : align;",
            " ",
            "     /* Note to self: the builder can also use the mask OR trick to propagate `min_align`. */",
            "-    return k > base && k + offset_size <= end && !((k + offset_size) & ((offset_size - 1) | (align - 1)));",
            "+    return k > base && k + offset_size <= end && !((k + offset_size) & ((offset_size - 1) | (align - 1u)));",
            " }",
            " ",
            " static inline int verify_struct(uoffset_t end, uoffset_t base, uoffset_t offset, uoffset_t size, uint16_t align)",
            " {",
            "     /* Structs can have zero size so `end` is a valid value. */",
            "     if (offset == 0 || base + offset > end) {",
            "         return flatcc_verify_error_offset_out_of_range;",
            "     }",
            "     base += offset;",
            "     verify(base + size >= base, flatcc_verify_error_struct_size_overflow);",
            "     verify(base + size <= end, flatcc_verify_error_struct_out_of_range);",
            "-    verify (!(base & (align - 1)), flatcc_verify_error_struct_unaligned);",
            "+    verify (!(base & (align - 1u)), flatcc_verify_error_struct_unaligned);",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            "-static inline uoffset_t read_vt_entry(flatcc_table_verifier_descriptor_t *td, voffset_t id)",
            "+static inline voffset_t read_vt_entry(flatcc_table_verifier_descriptor_t *td, voffset_t id)",
            " {",
            "-    voffset_t vo = (id + 2) * sizeof(voffset_t);",
            "+    voffset_t vo = (id + 2u) * sizeof(voffset_t);",
            " ",
            "     /* Assumes tsize has been verified for alignment. */",
            "     if (vo >= td->vsize) {",
            "         return 0;",
            "     }",
            "     return read_voffset(td->vtable, vo);",
            " }",
            "@@ -188,16 +187,16 @@",
            "     uoffset_t base = (uoffset_t)(size_t)td->buf;",
            " ",
            " ",
            "     /*",
            "      * Otherwise range check assumptions break, and normal access code likely also.",
            "      * We don't require voffset_size < uoffset_size, but some checks are faster if true.",
            "      */",
            "-    assert(uoffset_size >= voffset_size);",
            "-    assert(soffset_size == uoffset_size);",
            "+    FLATCC_ASSERT(uoffset_size >= voffset_size);",
            "+    FLATCC_ASSERT(soffset_size == uoffset_size);",
            " ",
            "     vte = read_vt_entry(td, id);",
            "     if (!vte) {",
            "         verify(!required, flatcc_verify_error_required_field_missing);",
            "         return flatcc_verify_ok;",
            "     }",
            "     trace_verify(\"table buffer\", td->buf);",
            "@@ -216,16 +215,16 @@",
            "     verify(k2 <= td->tsize, flatcc_verify_error_table_field_out_of_range);",
            "     /* This normally optimizes to nop. */",
            "     verify(uoffset_size > voffset_size || k <= k2, flatcc_verify_error_table_field_size_overflow);",
            "     trace_verify(\"table + vte\", vte + td->table);",
            "     k += td->table + base;",
            "     trace_verify(\"entry: buf + table + vte\", k);",
            "     trace_verify(\"align\", align);",
            "-    trace_verify(\"align masked entry\", k & (align - 1));",
            "-    verify(!(k & (align - 1)), flatcc_verify_error_table_field_not_aligned);",
            "+    trace_verify(\"align masked entry\", k & (align - 1u));",
            "+    verify(!(k & (align - 1u)), flatcc_verify_error_table_field_not_aligned);",
            "     /* We assume the table size has already been verified. */",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static int get_offset_field(flatcc_table_verifier_descriptor_t *td, voffset_t id, int required, uoffset_t *out)",
            " {",
            "     uoffset_t k, k2;",
            "@@ -248,29 +247,29 @@",
            "      */",
            "     k = vte;",
            "     k2 = k + offset_size;",
            "     verify(k2 <= td->tsize, flatcc_verify_error_table_field_out_of_range);",
            "     /* This normally optimizes to nop. */",
            "     verify(uoffset_size > voffset_size || k <= k2, flatcc_verify_error_table_field_size_overflow);",
            "     k += td->table;",
            "-    verify(!(k & (offset_size - 1)), flatcc_verify_error_table_field_not_aligned);",
            "+    verify(!(k & (offset_size - 1u)), flatcc_verify_error_table_field_not_aligned);",
            "     /* We assume the table size has already been verified. */",
            "     *out = k;",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " static inline int verify_string(const void *buf, uoffset_t end, uoffset_t base, uoffset_t offset)",
            " {",
            "     uoffset_t n;",
            " ",
            "     verify(check_header(end, base, offset), flatcc_verify_error_string_header_out_of_range_or_unaligned);",
            "     base += offset;",
            "     n = read_uoffset(buf, base);",
            "     base += offset_size;",
            "-    verify(end - base >= n + 1, flatcc_verify_error_string_out_of_range);",
            "+    verify(end - base > n, flatcc_verify_error_string_out_of_range);",
            "     verify(((uint8_t *)buf + base)[n] == 0, flatcc_verify_error_string_not_zero_terminated);",
            "     return flatcc_verify_ok;",
            " }",
            " ",
            " /*",
            "  * Keep interface somwewhat similar ot flatcc_builder_start_vector.",
            "  * `max_count` is a precomputed division to manage overflow check on vector length."
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/emit_test/emit_test.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/emit_test/emit_test.c",
            "+++ /home/flatcc-0.6.1/test/emit_test/emit_test.c",
            "@@ -26,15 +26,15 @@",
            "                     (long)offset, (long)iov[i].iov_len);",
            "         }",
            "         offset += (flatbuffers_soffset_t)iov[i].iov_len;",
            "     }",
            "     return 0;",
            " }",
            " ",
            "-int debug_test()",
            "+int debug_test(void)",
            " {",
            "     flatcc_builder_t builder, *B;",
            "     float x[10] = { 0 };",
            " ",
            "     B = &builder;",
            "     printf(\"dbg: output is generated by a custom emitter that doesn't actually build a buffer\\n\");",
            "     flatcc_builder_custom_init(B, dbg_emitter, 0, 0, 0);",
            "@@ -44,15 +44,15 @@",
            "     return 0;",
            " }",
            " ",
            " /*",
            "  * this assumes a very simple schema:",
            "  * \"table { time: long; device: ubyte; samples: [float]; }\"",
            "  */",
            "-int emit_test()",
            "+int emit_test(void)",
            " {",
            "     /*",
            "      * Note that there is some apparently unnecessary padding after 0x01",
            "      * which is caused by the end of the buffer content excluding",
            "      * vtables is forced to buffer alignment due to clustering and",
            "      * because alignment happens before the buffer is fully generated.",
            "      */",
            "@@ -74,15 +74,15 @@",
            "     uint8_t *buf;",
            "     flatcc_emitter_t *E;",
            "     flatcc_builder_t builder, *B;",
            "     flatbuffers_float_vec_ref_t vref;",
            "     float data[4] = { 1.0f, 1.1f, 1.2f, 1.3f };",
            " ",
            "     main_table_t mt;",
            "-    uint64_t time;",
            "+    int64_t time;",
            " ",
            "     (void)expect;",
            "     B = &builder;",
            " ",
            "     flatcc_builder_init(B);",
            " ",
            "     /* Get the default emitter. */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/flatc_compat/flatc_compat.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/flatc_compat/flatc_compat.c",
            "+++ /home/flatcc-0.6.1/test/flatc_compat/flatc_compat.c",
            "@@ -3,15 +3,15 @@",
            " ",
            " #include \"monster_test_reader.h\"",
            " #include \"monster_test_verifier.h\"",
            " #include \"flatcc/support/readfile.h\"",
            " #include \"flatcc/support/hexdump.h\"",
            " ",
            " #define align_up(alignment, size)                                           \\",
            "-    (((size) + (alignment) - 1) & ~((alignment) - 1))",
            "+    (((size_t)(size) + (size_t)(alignment) - 1) & ~((size_t)(alignment) - 1))",
            " ",
            " const char *filename = \"monsterdata_test.mon\";",
            " ",
            " #undef ns",
            " #define ns(x) MyGame_Example_ ## x",
            " ",
            " int verify_monster(void *buffer)",
            "@@ -22,29 +22,29 @@",
            "     ns(Test_vec_t) testvec;",
            "     ns(Any_union_type_t) mini_type;",
            "     flatbuffers_string_t name;",
            "     size_t offset;",
            "     flatbuffers_uint8_vec_t inv;",
            "     flatbuffers_string_vec_t aofs;",
            "     flatbuffers_string_t s;",
            "-    int i;",
            "+    size_t i;",
            " ",
            "     if (!(monster = ns(Monster_as_root(buffer)))) {",
            "         printf(\"Monster not available\\n\");",
            "         return -1;",
            "     }",
            "     if (ns(Monster_hp(monster)) != 80) {",
            "         printf(\"Health points are not as expected\\n\");",
            "         return -1;",
            "     }",
            "     if (!(vec = ns(Monster_pos(monster)))) {",
            "         printf(\"Position is absent\\n\");",
            "         return -1;",
            "     }",
            "-    offset = (char *)vec - (char *)buffer;",
            "+    offset = (size_t)((char *)vec - (char *)buffer);",
            "     if (offset & 15) {",
            "         printf(\"Force align of Vec3 struct not correct\\n\");",
            "         return -1;",
            "     }",
            "     if (ns(Vec3_x(vec)) != 1) {",
            "         printf(\"Position failing on x coordinate\\n\");",
            "         return -1;",
            "@@ -82,15 +82,15 @@",
            "     inv = ns(Monster_inventory(monster));",
            "     if (flatbuffers_uint8_vec_len(inv) != 5) {",
            "         printf(\"Inventory has wrong length\\n\");",
            "         return -1;",
            "     }",
            "     for (i = 0; i < 5; ++i) {",
            "         if (flatbuffers_uint8_vec_at(inv, i) != i) {",
            "-            printf(\"Inventory item #%d is wrong\\n\", i);",
            "+            printf(\"Inventory item #%d is wrong\\n\", (int)i);",
            "             return -1;",
            "         }",
            "     }",
            "     if (!(aofs = ns(Monster_testarrayofstring(monster)))) {",
            "         printf(\"Array of string not present\\n\");",
            "         return -1;",
            "     }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/json_test/test_basic_parse.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/json_test/test_basic_parse.c",
            "+++ /home/flatcc-0.6.1/test/json_test/test_basic_parse.c",
            "@@ -85,15 +85,16 @@",
            " const char *test(flatcc_builder_t *B, const char *buf, const char *end, int *ret)",
            " {",
            "     flatcc_json_parser_t parse_ctx, *ctx;",
            "     flatcc_builder_ref_t root = 0, ref, *p_ref;",
            "     uint64_t w;",
            "     const char *k;",
            "     char *s;",
            "-    char code[4];",
            "+    flatcc_json_parser_escape_buffer_t code;",
            "+",
            "     void *p;",
            " ",
            "     ctx = &parse_ctx;",
            "     memset(ctx, 0, sizeof(*ctx));",
            "     ctx->line = 1;",
            "     ctx->line_start = buf;",
            " ",
            "@@ -206,30 +207,30 @@",
            "                 buf = flatcc_json_parser_string_start(ctx, buf, end);",
            "                 k = buf;",
            "                 buf = flatcc_json_parser_string_part(ctx, buf, end);",
            "                 if (buf == end) {",
            "                     goto fail;",
            "                 }",
            "                 if (buf[0] == '\\\"') {",
            "-                    ref = flatcc_builder_create_string(B, k, buf - k);",
            "+                    ref = flatcc_builder_create_string(B, k, (size_t)(buf - k));",
            "                 } else {",
            "                     /* Start string with enough space for what we have. */",
            "                     flatcc_builder_start_string(B);",
            "-                    s = flatcc_builder_extend_string(B, buf - k);",
            "+                    s = flatcc_builder_extend_string(B, (size_t)(buf - k));",
            "                     if (!s) { goto fail; }",
            "-                    memcpy(s, k, buf - k);",
            "+                    memcpy(s, k, (size_t)(buf - k));",
            "                     do {",
            "                         buf = flatcc_json_parser_string_escape(ctx, buf, end, code);",
            "-                        flatcc_builder_append_string(B, code + 1, code[0]);",
            "+                        flatcc_builder_append_string(B, code + 1, (size_t)code[0]);",
            "                         k = buf;",
            "                         buf = flatcc_json_parser_string_part(ctx, buf, end);",
            "                         if (buf == end) {",
            "                             goto fail;",
            "                         }",
            "-                        flatcc_builder_append_string(B, k, buf - k);",
            "+                        flatcc_builder_append_string(B, k, (size_t)(buf - k));",
            "                     } while (buf[0] != '\\\"');",
            "                     ref = flatcc_builder_end_string(B);",
            "                 }",
            "                 if (!ref) {",
            "                     goto fail;",
            "                 }",
            "                 /* Duplicate fields may fail or assert. */"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/json_test/test_json.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/json_test/test_json.c",
            "+++ /home/flatcc-0.6.1/test/json_test/test_json.c",
            "@@ -19,15 +19,15 @@",
            "     flatcc_json_parser_table_f *parser;",
            "     flatcc_json_printer_table_f *printer;",
            "     flatcc_table_verifier_f *verifier;",
            " };",
            " ",
            " static const struct test_scope Monster = {",
            "     /* The is the schema global file identifier. */",
            "-    ns(Monster_identifier),",
            "+    ns(Monster_file_identifier),",
            "     ns(Monster_parse_json_table),",
            "     ns(Monster_print_json_table),",
            "     ns(Monster_verify_table)",
            " };",
            " ",
            " static const struct test_scope Alt = {",
            "     /* This is the type hash identifier. */",
            "@@ -132,15 +132,18 @@",
            " ",
            " #define TEST_ERROR(x, err) \\",
            "     ret |= test_json(scope, (x), 0, err, 0, 0, __LINE__);",
            " ",
            " #define TEST_FLAGS(fparse, fprint, x, y) \\",
            "     ret |= test_json(scope, (x), (y), 0, (fparse), (fprint), __LINE__);",
            " ",
            "-int edge_case_tests()",
            "+#define TEST_ERROR_FLAGS(fparse, fprint, x, err) \\",
            "+    ret |= test_json(scope, (x), 0, err, (fparse), (fprint), __LINE__);",
            "+",
            "+int edge_case_tests(void)",
            " {",
            "     BEGIN_TEST(Monster);",
            " /*",
            "  * Each symbolic value is type coerced and added. One might expect",
            "  * or'ing flags together, but it doesn't work with signed values",
            "  * and floating point target values. We would either need a much",
            "  * more complicated parser or restrict the places where symbols are",
            "@@ -273,15 +276,15 @@",
            "             \"{\\\"name\\\":\\\"Monster\\\",\\\"color\\\":0}\");",
            " ",
            " #endif",
            " ",
            "     END_TEST();",
            " }",
            " ",
            "-int error_case_tests()",
            "+int error_case_tests(void)",
            " {",
            "     BEGIN_TEST(Monster);",
            " ",
            "     TEST_ERROR( \"{ \\\"nickname\\\": \\\"Monster\\\" }\",",
            "                 flatcc_json_parser_error_unknown_symbol );",
            "     TEST_ERROR( \"{ \\\"name\\\": \\\"Monster\\\", \\\"test_type\\\": \\\"Monster\\\", \\\"test\\\": { \\\"nickname\\\": \\\"Joker\\\", \\\"color\\\": \\\"Red\\\" } } }\",",
            "                 flatcc_json_parser_error_unknown_symbol );",
            "@@ -356,15 +359,15 @@",
            " ",
            " #define RANDOM_BASE64URL \"zLOuiUjH49tz4Ap2JnmpTX5NqoiMzlD8hSw45QCS2yaSp7UYoA\" \\",
            "     \"oE8KpY_5pKYmk-54NI40hyeyZ1zRUE4vKQT0hEdVl0iXq2fqPamkVD1AZlVvQJ1m00PaoXOSgG-64Zv-Uygw==\"",
            " ",
            " #define RANDOM_BASE64URL_NOPAD \"zLOuiUjH49tz4Ap2JnmpTX5NqoiMzlD8hSw45QCS2yaSp7UYoA\" \\",
            "     \"oE8KpY_5pKYmk-54NI40hyeyZ1zRUE4vKQT0hEdVl0iXq2fqPamkVD1AZlVvQJ1m00PaoXOSgG-64Zv-Uygw\"",
            " ",
            "-int base64_tests()",
            "+int base64_tests(void)",
            " {",
            "     BEGIN_TEST(Monster);",
            " ",
            "     /* Reference */",
            "     TEST(   \"{ \\\"name\\\": \\\"Monster\\\" }\",",
            "             \"{\\\"name\\\":\\\"Monster\\\"}\");",
            " ",
            "@@ -418,15 +421,15 @@",
            "             \"\\\"nested\\\":\\\"FAAAAE1PTlMMAAwAAAAEAAYACAAMAAAAAAAAAAQAAAANAAAATmVzdGVkTW9uc3RlcgAAAA==\\\"\"",
            "             \"}}\");",
            " #endif",
            " ",
            "     END_TEST();",
            " }",
            " ",
            "-int mixed_type_union_tests()",
            "+int mixed_type_union_tests(void)",
            " {",
            "     BEGIN_TEST(Movie);",
            " ",
            "     /* Reference */",
            " ",
            "     TEST(   \"{ \\\"main_character_type\\\": \\\"Rapunzel\\\", \\\"main_character\\\": { \\\"hair_length\\\": 19 } }\",",
            "             \"{\\\"main_character_type\\\":\\\"Rapunzel\\\",\\\"main_character\\\":{\\\"hair_length\\\":19}}\");",
            "@@ -472,15 +475,15 @@",
            "             \"  \\\"side_kick_type\\\": \\\"Character.Other\\\", \\\"side_kick\\\": \\\"a donkey\\\"}\",",
            "             \"{\\\"main_character_type\\\":\\\"Rapunzel\\\",\\\"main_character\\\":{\\\"hair_length\\\":19},\"",
            "             \"\\\"side_kick_type\\\":\\\"Other\\\",\\\"side_kick\\\":\\\"a donkey\\\"}\");",
            " ",
            "     END_TEST();",
            " }",
            " ",
            "-int union_vector_tests()",
            "+int union_vector_tests(void)",
            " {",
            "     BEGIN_TEST(Alt);",
            "     /* Union vector */",
            " ",
            "     TEST(   \"{ \\\"manyany_type\\\": [ \\\"Monster\\\" ], \\\"manyany\\\": [{\\\"name\\\": \\\"Joe\\\"}] }\",",
            "             \"{\\\"manyany_type\\\":[\\\"Monster\\\"],\\\"manyany\\\":[{\\\"name\\\":\\\"Joe\\\"}]}\");",
            " ",
            "@@ -498,14 +501,83 @@",
            " ",
            "     TEST(   \"{\\\"manyany\\\": [{\\\"manyany\\\":[null, null], \\\"manyany_type\\\": [\\\"NONE\\\", \\\"NONE\\\"]}], \\\"manyany_type\\\": [ \\\"Alt\\\" ] }\",",
            "             \"{\\\"manyany_type\\\":[\\\"Alt\\\"],\\\"manyany\\\":[{\\\"manyany_type\\\":[\\\"NONE\\\",\\\"NONE\\\"],\\\"manyany\\\":[null,null]}]}\");",
            " ",
            "     END_TEST();",
            " }",
            " ",
            "+int fixed_array_tests(void)",
            "+{",
            "+    BEGIN_TEST(Alt);",
            "+    /* Fixed array */",
            "+",
            "+#if UQ",
            "+    TEST(   \"{ \\\"fixed_array\\\": { \\\"foo\\\": [ 1.0, 2.0, 0, 0, 0, 0, 0,\"",
            "+            \" 0, 0, 0, 0, 0, 0, 0, 0, 16.0], col:[\\\"Blue Red\\\", Green, Red],\"",
            "+            \"tests:[ {b:4}, {a:1, b:2}],\"",
            "+            \" \\\"bar\\\": [ 100, 0, 0, 0, 0, 0, 0, 0, 0, 1000],\"",
            "+            \" \\\"text\\\":\\\"hello\\\"}}\",",
            "+            \"{\\\"fixed_array\\\":{\\\"foo\\\":[1,2,0,0,0,0,0,\"",
            "+            \"0,0,0,0,0,0,0,0,16],\"",
            "+            \"\\\"bar\\\":[100,0,0,0,0,0,0,0,0,1000],\"",
            "+            \"\\\"col\\\":[\\\"Red Blue\\\",\\\"Green\\\",\\\"Red\\\"],\"",
            "+            \"\\\"tests\\\":[{\\\"a\\\":0,\\\"b\\\":4},{\\\"a\\\":1,\\\"b\\\":2}],\"",
            "+            \"\\\"text\\\":\\\"hello\\\"}}\");",
            "+#else",
            "+    TEST(   \"{ \\\"fixed_array\\\": { \\\"foo\\\": [ 1.0, 2.0, 0, 0, 0, 0, 0,\"",
            "+            \" 0, 0, 0, 0, 0, 0, 0, 0, 16.0], \\\"col\\\":[\\\"Blue Red\\\", \\\"Green\\\", \\\"Red\\\"],\"",
            "+            \"\\\"tests\\\":[ {\\\"b\\\":4}, {\\\"a\\\":1, \\\"b\\\":2}],\"",
            "+            \" \\\"bar\\\": [ 100, 0, 0, 0, 0, 0, 0, 0, 0, 1000],\"",
            "+            \" \\\"text\\\":\\\"hello\\\"}}\",",
            "+            \"{\\\"fixed_array\\\":{\\\"foo\\\":[1,2,0,0,0,0,0,\"",
            "+            \"0,0,0,0,0,0,0,0,16],\"",
            "+            \"\\\"bar\\\":[100,0,0,0,0,0,0,0,0,1000],\"",
            "+            \"\\\"col\\\":[\\\"Red Blue\\\",\\\"Green\\\",\\\"Red\\\"],\"",
            "+            \"\\\"tests\\\":[{\\\"a\\\":0,\\\"b\\\":4},{\\\"a\\\":1,\\\"b\\\":2}],\"",
            "+            \"\\\"text\\\":\\\"hello\\\"}}\");",
            "+#endif",
            "+",
            "+    TEST_FLAGS(flatcc_json_parser_f_skip_array_overflow, 0,",
            "+            \"{ \\\"fixed_array\\\": { \\\"foo\\\": [ 1.0, 2.0, 0, 0, 0, 0, 0,\"",
            "+            \" 0, 0, 0, 0, 0, 0, 0, 0, 16.0, 99],\"",
            "+            \" \\\"bar\\\": [ 100, 0, 0, 0, 0, 0, 0, 0, 0, 1000, 99],\"",
            "+            \" \\\"text\\\":\\\"hello, world\\\"}}\",",
            "+            \"{\\\"fixed_array\\\":{\\\"foo\\\":[1,2,0,0,0,0,0,\"",
            "+            \"0,0,0,0,0,0,0,0,16],\"",
            "+            \"\\\"bar\\\":[100,0,0,0,0,0,0,0,0,1000],\"",
            "+            \"\\\"col\\\":[0,0,0],\"",
            "+            \"\\\"tests\\\":[{\\\"a\\\":0,\\\"b\\\":0},{\\\"a\\\":0,\\\"b\\\":0}],\"",
            "+            \"\\\"text\\\":\\\"hello\\\"}}\");",
            "+",
            "+    TEST(   \"{ \\\"fixed_array\\\": { \\\"foo\\\": [ 1.0, 2.0 ],\"",
            "+            \" \\\"bar\\\": [ 100 ], \\\"text\\\": \\\"K\\\\x00A\\\\x00\\\" }}\",",
            "+            \"{\\\"fixed_array\\\":{\\\"foo\\\":[1,2,0,0,0,0,0,\"",
            "+            \"0,0,0,0,0,0,0,0,0],\"",
            "+            \"\\\"bar\\\":[100,0,0,0,0,0,0,0,0,0],\"",
            "+            \"\\\"col\\\":[0,0,0],\"",
            "+            \"\\\"tests\\\":[{\\\"a\\\":0,\\\"b\\\":0},{\\\"a\\\":0,\\\"b\\\":0}],\"",
            "+            \"\\\"text\\\":\\\"K\\\\u0000A\\\"}}\");",
            "+",
            "+    TEST_ERROR_FLAGS(flatcc_json_parser_f_reject_array_underflow, 0,",
            "+            \"{ \\\"fixed_array\\\": { \\\"foo\\\": [ 1.0, 2.0 ] }}\",",
            "+            flatcc_json_parser_error_array_underflow);",
            "+",
            "+    TEST_ERROR_FLAGS(flatcc_json_parser_f_reject_array_underflow, 0,",
            "+            \"{ \\\"fixed_array\\\": { \\\"text\\\": \\\"K\\\\x00A\\\\x00\\\" }}\",",
            "+            flatcc_json_parser_error_array_underflow);",
            "+",
            "+    TEST_ERROR(",
            "+            \"{ \\\"fixed_array\\\": { \\\"foo\\\": [ 1.0, 2.0, 0, 0, 0, 0, 0,\"",
            "+            \" 0, 0, 0, 0, 0, 0, 0, 0, 16.0, 99],\"",
            "+            \" \\\"bar\\\": [ 100, 0, 0, 0, 0, 0, 0, 0, 0, 1000, 99] }}\",",
            "+            flatcc_json_parser_error_array_overflow);",
            "+",
            "+    END_TEST();",
            "+}",
            "+",
            " /*",
            "  * Here we cover some border cases around unions and flag",
            "  * enumerations, and nested buffers.",
            "  *",
            "  * More complex objects with struct members etc. are reasonably",
            "  * covered in the printer and parser tests using the golden data",
            "  * set.",
            "@@ -513,14 +585,15 @@",
            " int main()",
            " {",
            "     BEGIN_TEST(Monster);",
            " ",
            "     ret |= edge_case_tests();",
            "     ret |= error_case_tests();",
            "     ret |= union_vector_tests();",
            "+    ret |= fixed_array_tests();",
            "     ret |= base64_tests();",
            "     ret |= mixed_type_union_tests();",
            " ",
            "     /* Allow trailing comma. */",
            "     TEST(   \"{ \\\"name\\\": \\\"Monster\\\", }\",",
            "             \"{\\\"name\\\":\\\"Monster\\\"}\");"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/json_test/test_json_parser.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/json_test/test_json_parser.c",
            "+++ /home/flatcc-0.6.1/test/json_test/test_json_parser.c",
            "@@ -35,15 +35,15 @@",
            " /* A helper to simplify creating buffers vectors from C-arrays. */",
            " #define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))",
            " ",
            " int verify_parse(void *buffer)",
            " {",
            "     ns(Test_struct_t) test;",
            "     ns(Vec3_struct_t) pos;",
            "-    ns(Monster_table_t) monster = ns(Monster_as_root_with_identifier)(buffer, ns(Monster_identifier));",
            "+    ns(Monster_table_t) monster = ns(Monster_as_root_with_identifier)(buffer, ns(Monster_file_identifier));",
            " ",
            "     pos = ns(Monster_pos(monster));",
            "     test_assert(pos);",
            "     test_assert(ns(Vec3_x(pos) == 1));",
            "     test_assert(ns(Vec3_y(pos) == 2));",
            "     test_assert(ns(Vec3_z(pos) == 3));",
            "     test_assert(ns(Vec3_test1(pos) == 3.0));",
            "@@ -60,15 +60,15 @@",
            " }",
            " // TODO:",
            " // when running benchmark with the wrong size argument (output size",
            " // instead of input size), the warmup loop iterates indefinitely in the",
            " // first iteration. This suggests there is an end check missing somwhere",
            " // and this needs to be debugged. The input size as of this writing is 701",
            " // bytes, and the output size is 288 bytes.",
            "-int test_parse()",
            "+int test_parse(void)",
            " {",
            " #if FLATCC_BENCHMARK",
            "     double t1, t2;",
            "     int i;",
            "     int rep = 1000000;",
            "     int warmup_rep = 1000000;",
            " #endif"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/json_test/test_json_printer.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/json_test/test_json_printer.c",
            "+++ /home/flatcc-0.6.1/test/json_test/test_json_printer.c",
            "@@ -19,15 +19,15 @@",
            " /* A helper to simplify creating buffers vectors from C-arrays. */",
            " #define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))",
            " ",
            " const char *filename = 0; /* \"monsterdata_test.mon\"; */",
            " const char *golden_filename = \"monsterdata_test.golden\";",
            " const char *target_filename = \"monsterdata_test.json.txt\";",
            " ",
            "-int test_print()",
            "+int test_print(void)",
            " {",
            "     int ret = 0;",
            "     const char *buf = 0;",
            "     const char *golden = 0;",
            "     const char *target = 0;",
            "     size_t size = 0, golden_size = 0, target_size = 0;",
            "     flatcc_json_printer_t ctx_obj, *ctx;"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/load_test/load_test.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/load_test/load_test.c",
            "+++ /home/flatcc-0.6.1/test/load_test/load_test.c",
            "@@ -101,18 +101,19 @@",
            "     FILE *fp;",
            "     void *buffer;",
            "     size_t size;",
            "     flatcc_builder_t builder, *B;",
            "     ns(Monster_table_t) mon;",
            "     ns(Monster_vec_t) mv;",
            "     double t1, t2;",
            "-    int rep = 10, i, ret = 0;",
            "+    int rep = 10, i;",
            "+    int ret = 0;",
            " ",
            " #if MEASURE_DECODE",
            "-    int j;",
            "+    size_t j;",
            " #endif",
            " ",
            "     (void)argc;",
            "     (void)argv;",
            " ",
            "     B = &builder;",
            "     flatcc_builder_init(B);"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/monster_test/monster_test.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/monster_test/monster_test.c",
            "+++ /home/flatcc-0.6.1/test/monster_test/monster_test.c",
            "@@ -41,15 +41,15 @@",
            " #define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))",
            " ",
            " static const char zero_pad[100];",
            " ",
            " int verify_empty_monster(void *buffer)",
            " {",
            "     /* Proper id given. */",
            "-    ns(Monster_table_t) monster = ns(Monster_as_root_with_identifier)(buffer, ns(Monster_identifier));",
            "+    ns(Monster_table_t) monster = ns(Monster_as_root_with_identifier)(buffer, ns(Monster_file_identifier));",
            "     /* Invalid id. */",
            "     ns(Monster_table_t) monster2 = ns(Monster_as_root_with_identifier(buffer, \"1234\"));",
            "     /* `with_id` can also mean ignore id when given a null argument. */",
            "     ns(Monster_table_t) monster3 = ns(Monster_as_root_with_identifier(buffer, 0));",
            "     /* Excessive text in identifier is ignored. */",
            "     ns(Monster_table_t) monster4 = ns(Monster_as_root_with_identifier(buffer, \"MONSX\"));",
            "     /* Default id should match proper id. */",
            "@@ -92,14 +92,16 @@",
            "         return -1;",
            "     }",
            "     return 0;",
            " }",
            " ",
            " int test_enums(flatcc_builder_t *B)",
            " {",
            "+    (void)B;",
            "+",
            "     if (ns(neg_enum_neg1) != -12) {",
            "         printf(\"neg_enum_neg1 should be -12, was %d\\n\", ns(neg_enum_neg1));",
            "         return -1;",
            "     }",
            "     if (ns(neg_enum_neg2) != -11) {",
            "         printf(\"neg_enum_neg1 should be -11, was %d\\n\", ns(neg_enum_neg2));",
            "         return -1;",
            "@@ -188,29 +190,29 @@",
            "     int ret;",
            "     ns(Monster_ref_t) root;",
            "     void *buffer;",
            "     size_t size;",
            " ",
            "     flatcc_builder_reset(B);",
            " ",
            "-    flatbuffers_buffer_start(B, ns(Monster_identifier));",
            "+    flatbuffers_buffer_start(B, ns(Monster_file_identifier));",
            "     ns(Monster_start(B));",
            "     /* Cannot make monster empty as name is required. */",
            "     ns(Monster_name_create_str(B, \"MyMonster\"));",
            "     root = ns(Monster_end(B));",
            "     flatbuffers_buffer_end(B, root);",
            " ",
            "     buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            " ",
            "     hexdump(\"empty monster table\", buffer, size, stderr);",
            "     if ((ret = verify_empty_monster(buffer))) {",
            "         goto done;",
            "     }",
            " ",
            "-    if ((ret = ns(Monster_verify_as_root_with_identifier(buffer, size, ns(Monster_identifier))))) {",
            "+    if ((ret = ns(Monster_verify_as_root_with_identifier(buffer, size, ns(Monster_file_identifier))))) {",
            "         printf(\"could not verify empty monster, got %s\\n\", flatcc_verify_error_string(ret));",
            "         return -1;",
            "     }",
            " ",
            "     /*",
            "      * Note: this will assert if the verifier is set to assert during",
            "      * debugging. Also not that a buffer size - 1 is not necessarily",
            "@@ -303,162 +305,14 @@",
            "     ret = 0;",
            " ",
            " done:",
            "     flatcc_builder_aligned_free(buffer);",
            "     return ret;",
            " }",
            " ",
            "-/*",
            "- * C standard does not provide support for empty structs,",
            "- * but they do exist in FlatBuffers. We can use most operations",
            "- * but we cannot declare an instance of not can we take the size of.",
            "- * The mytype_size() funciton is provided and returns 0 for empty",
            "- * structs.",
            "- *",
            "- * GCC provides support for empty structs, but it isn't portable,",
            "- * and compilers may define sizeof such structs differently.",
            "- */",
            "-",
            "-int verify_table_with_emptystruct(void *buffer)",
            "-{",
            "-    ns(with_emptystruct_table_t) withempty;",
            "-    const ns(emptystruct_t *) empty;",
            "-",
            "-    withempty = ns(with_emptystruct_as_root(buffer));",
            "-    if (!withempty) {",
            "-        printf(\"table with emptystruct not available\\n\");",
            "-        return -1;",
            "-    }",
            "-    empty = ns(with_emptystruct_empty)(withempty);",
            "-    if (!empty) {",
            "-        printf(\"empty member not available\\n\");",
            "-        return -1;",
            "-    }",
            "-    // sizeof empty won't compile since it is a void.",
            "-    //if (sizeof(*empty)) {",
            "-    if (ns(emptystruct__size())) {",
            "-        printf(\"empty isn't really empty\\n\");",
            "-        return -1;",
            "-    }",
            "-    return 0;",
            "-}",
            "-",
            "-int test_table_with_emptystruct(flatcc_builder_t *B)",
            "-{",
            "-    int ret;",
            "-    ns(emptystruct_t) *empty = 0; /* empty structs cannot instantiated. */",
            "-    void *buffer;",
            "-    size_t size;",
            "-",
            "-    flatcc_builder_reset(B);",
            "-",
            "-    ns(with_emptystruct_create_as_root)(B, empty);",
            "-",
            "-    buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            "-",
            "-    /*",
            "-     * We should expect an empty table with a vtable holding",
            "-     * a single entry pointing to the end of the table.",
            "-     * We could also drop the entry from the vtable, but then what",
            "-     * would be the point of having an empty struct at all? Here",
            "-     * we can use it as a cheap presence flag.",
            "-     */",
            "-    hexdump(\"table with empty struct\", buffer, size, stderr);",
            "-    ret = verify_table_with_emptystruct(buffer);",
            "-    flatcc_builder_aligned_free(buffer);",
            "-",
            "-    return ret;",
            "-}",
            "-",
            "-int test_typed_table_with_emptystruct(flatcc_builder_t *B)",
            "-{",
            "-    int ret = 0;",
            "-    ns(emptystruct_t) *empty = 0; /* empty structs cannot instantiated. */",
            "-    void *buffer;",
            "-    size_t size;",
            "-",
            "-    flatcc_builder_reset(B);",
            "-",
            "-    ns(with_emptystruct_create_as_typed_root(B, empty));",
            "-",
            "-    buffer = flatcc_builder_get_direct_buffer(B, &size);",
            "-",
            "-    /*",
            "-     * We should expect an empty table with a vtable holding",
            "-     * a single entry pointing to the end of the table.",
            "-     * We could also drop the entry from the vtable, but then what",
            "-     * would be the point of having an empty struct at all? Here",
            "-     * we can use it as a cheap presence flag.",
            "-     */",
            "-    hexdump(\"typed table with empty struct\", buffer, size, stderr);",
            "-    if (flatcc_verify_ok != ns(with_emptystruct_verify_as_root_with_identifier(buffer, size, ns(with_emptystruct_type_identifier)))) {",
            "-        printf(\"explicit verify_as_root failed\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (flatcc_verify_ok != ns(with_emptystruct_verify_as_typed_root(buffer, size))) {",
            "-        printf(\"typed verify_as_root failed\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (flatcc_verify_ok != ns(with_emptystruct_verify_as_root_with_type_hash(buffer, size, ns(with_emptystruct_type_hash)))) {",
            "-        printf(\"verify_as_root_with_type_hash failed\\n\");",
            "-        return -1;",
            "-    }",
            "-#if 0",
            "-    flatcc_builder_reset(B);",
            "-    ns(with_emptystruct_start_as_typed_root(B));",
            "-    ns(with_emptystruct_end_as_typed_root(B));",
            "-    buffer = flatcc_builder_get_direct_buffer(B, &size);",
            "-#endif",
            "-    if (!buffer) {",
            "-        printf(\"failed to create buffer\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!flatbuffers_has_type_hash(buffer, ns(with_emptystruct_type_hash))) {",
            "-        printf(\"has_type failed\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!flatbuffers_has_type_hash(buffer, 0)) {",
            "-        printf(\"null type failed\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (flatbuffers_has_type_hash(buffer, 1)) {",
            "-        printf(\"wrong has type unexpected succeeed\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!flatbuffers_has_identifier(buffer, 0)) {",
            "-        printf(\"has identifier failed for null id\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!flatbuffers_has_identifier(buffer, \"\\xb6\\x37\\xdd\\xb0\")) {",
            "-        printf(\"has identifier failed for explicit string\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (ns(with_emptystruct_as_root(buffer))) {",
            "-        printf(\"as_root unexpctedly succeeded\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (ns(with_emptystruct_as_root_with_type_hash(buffer, 1))) {",
            "-        printf(\"with wrong type unexptedly succeeded\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!ns(with_emptystruct_as_root_with_identifier(buffer, ns(with_emptystruct_type_identifier)))) {",
            "-        printf(\"as_root_with_identifier failed to match type_identifier\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!ns(with_emptystruct_as_typed_root(buffer))) {",
            "-        printf(\"as_typed_root_failed\\n\");",
            "-        return -1;",
            "-    }",
            "-    if (!ns(with_emptystruct_as_root_with_type_hash(buffer, 0))) {",
            "-        printf(\"with ignored type failed\\n\");",
            "-        return -1;",
            "-    }",
            "-    return ret;",
            "-}",
            "-",
            " int verify_monster(void *buffer)",
            " {",
            "     ns(Monster_table_t) monster, mon, mon2;",
            "     ns(Monster_vec_t) monsters;",
            "     ns(Any_union_type_t) test_type;",
            "     ns(Any_union_t) test_union;",
            "     /* This is an encoded struct pointer. */",
            "@@ -493,15 +347,15 @@",
            "         printf(\"extra characters in identifier should be ignored\\n\");",
            "         return -1;",
            "     }",
            "     if (nsc(has_identifier(buffer, \"MON1\"))) {",
            "         printf(\"accepted wrong monster identifier (when explicit)\\n\");",
            "         return -1;",
            "     }",
            "-    if (!nsc(has_identifier(buffer, ns(Monster_identifier)))) {",
            "+    if (!nsc(has_identifier(buffer, ns(Monster_file_identifier)))) {",
            "         printf(\"wrong monster identifier (via defined identifier)\\n\");",
            "         return -1;",
            "     }",
            " ",
            "     if (!(monster = ns(Monster_as_root(buffer)))) {",
            "         printf(\"Monster not available\\n\");",
            "         return -1;",
            "@@ -864,16 +718,22 @@",
            "     test->b = 0x20;",
            "     test = ns(Monster_test4_extend(B, 2));",
            "     test->a = 0x30;",
            "     test->b = 0x40;",
            "     test[1].a = 0x50;",
            "     test[1].b = 0x60;",
            "     ns(Monster_test4_push_create(B, 0x70, (int8_t)0x80));",
            "+    /*",
            "+     * Zero padding within struct",
            "+     * - not needed when receiving a pointer like `test` in the above.",
            "+     */",
            "+    ns(Test_clear(&x));",
            "     x.a = 0x190; /* This is a short. */",
            "     x.b = (int8_t)0x91; /* This is a byte. */",
            "+    /* And x also has a hidden trailing padding byte. */",
            "     ns(Monster_test4_push(B, &x));",
            "     ns(Monster_test4_push(B, &x));",
            "     /* We can use either field mapped push or push on the type. */",
            "     ns(Test_vec_push(B, &x));",
            "     /*",
            "      * `_reserved_len` is similar to the `_vec_len` function in the",
            "      * reader interface but `_vec_len` would not work here.",
            "@@ -1824,76 +1684,79 @@",
            " int verify_union_vector(void *buffer, size_t size)",
            " {",
            "     int ret = -1;",
            "     size_t n;",
            "     int color;",
            " ",
            "     ns(Monster_table_t) mon;",
            "-    ns(Stat_table_t) stat;",
            "     ns(TestSimpleTableWithEnum_table_t) kermit;",
            "     flatbuffers_generic_vec_t anyvec;",
            "     ns(Any_vec_t) anyvec_type;",
            "     ns(Any_union_vec_t) anyvec_union;",
            "     ns(Any_union_t) anyelem;",
            "     ns(Alt_table_t) alt;",
            " ",
            "     if ((ret = ns(Monster_verify_as_root(buffer, size)))) {",
            "         printf(\"Monster buffer with union vector failed to verify, got: %s\\n\", flatcc_verify_error_string(ret));",
            "-        return -1;",
            "+        goto failed;",
            "     }",
            " ",
            "     mon = ns(Monster_as_root(buffer));",
            "     if (ns(Monster_test_type(mon)) != ns(Any_Alt)) {",
            "         printf(\"test field does not have Alt type\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     alt = ns(Monster_test(mon));",
            "-    if (!alt || ns(Alt_manyany_is_present(alt))) {",
            "+    if (!alt || !ns(Alt_manyany_is_present(alt))) {",
            "         printf(\"manyany union vector should be present.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     anyvec_type = ns(Alt_manyany_type(alt));",
            "     anyvec = ns(Alt_manyany(alt));",
            "     n = ns(Any_vec_len(anyvec_type));",
            "     if (n != 1) {",
            "         printf(\"manyany union vector has wrong length.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     if (nsc(union_type_vec_at(anyvec_type, 0)) != ns(Any_TestSimpleTableWithEnum)) {",
            "         printf(\"manyany union vector has wrong element type.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     kermit = flatbuffers_generic_vec_at(anyvec, 0);",
            "     if (!kermit) {",
            "         printf(\"Kermit is lost.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     color = ns(TestSimpleTableWithEnum_color(kermit));",
            "     if (color != ns(Color_Green)) {",
            "         printf(\"Kermit has wrong color: %i.\\n\", (int)color);",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     anyvec_union = ns(Alt_manyany_union(alt));",
            "     if (ns(Any_union_vec_len(anyvec_union)) != 1) {",
            "         printf(\"manyany union vector has wrong length from a different perspective.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     anyelem = ns(Any_union_vec_at(anyvec_union, 0));",
            "     if (anyelem.type != nsc(union_type_vec_at(anyvec_type, 0))) {",
            "         printf(\"Kermit is now different.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     if (anyelem.value != kermit) {",
            "         printf(\"Kermit is incoherent.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     ret = 0;",
            " ",
            " done:",
            "     return ret;",
            "+",
            "+failed:",
            "+    ret = -1;",
            "+    goto done;",
            " }",
            " ",
            " int test_union_vector(flatcc_builder_t *B)",
            " {",
            "     void *buffer = 0, *cloned_buffer = 0;",
            "     size_t size;",
            "     int ret = -1;",
            "@@ -1921,44 +1784,290 @@",
            " ",
            "     ns(Monster_end_as_root(B));",
            " ",
            "     buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            " ",
            "     if (verify_union_vector(buffer, size)) {",
            "         printf(\"Union vector Monster didn't verify.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            "     flatcc_builder_reset(B);",
            "     refmap_old = flatcc_builder_set_refmap(B, &refmap);",
            "     if (!ns(Monster_clone_as_root(B, ns(Monster_as_root(buffer))))) {",
            "         printf(\"Cloned union vector Monster didn't actually clone.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     };",
            "     flatcc_builder_set_refmap(B, refmap_old);",
            "     cloned_buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            " ",
            "     if (verify_union_vector(buffer, size)) {",
            "         printf(\"Cloned union vector Monster didn't verify.\\n\");",
            "-        goto done;",
            "+        goto failed;",
            "     }",
            " ",
            "     ret = 0;",
            " ",
            " done:",
            "     flatcc_refmap_clear(&refmap);",
            "     flatcc_builder_aligned_free(buffer);",
            "     flatcc_builder_aligned_free(cloned_buffer);",
            "     return ret;",
            "+",
            "+failed:",
            "+    ret = -1;",
            "+    goto done;",
            "+}",
            "+",
            "+int verify_fixed_length_array(const void *buffer, size_t size)",
            "+{",
            "+    const char *text;",
            "+    ns(Monster_table_t) mon;",
            "+    ns(Alt_table_t) alt;",
            "+    ns(FooBar_struct_t) fa;",
            "+    ns(FooBar_t) fa2;",
            "+    ns(Test_struct_t) t0, t1;",
            "+    int ret;",
            "+",
            "+    if ((ret = ns(Monster_verify_as_root(buffer, size)))) {",
            "+        printf(\"Monster buffer with fixed length arrays failed to verify, got: %s\\n\", flatcc_verify_error_string(ret));",
            "+        return -1;",
            "+    }",
            "+",
            "+    mon = ns(Monster_as_root(buffer));",
            "+    if (ns(Monster_test_type(mon)) != ns(Any_Alt)) {",
            "+        printf(\"test field does not have Alt type\");",
            "+        return -1;",
            "+    }",
            "+",
            "+    alt = ns(Monster_test(mon));",
            "+    if (!alt || !ns(Alt_fixed_array_is_present(alt))) {",
            "+        printf(\"fixed array should be present.\\n\");",
            "+        return -1;",
            "+    }",
            "+",
            "+    fa = ns(Alt_fixed_array(alt));",
            "+",
            "+    if (ns(FooBar_foo(fa, 0)) != 1.0f || ns(FooBar_bar(fa, 9) != 1000)) {",
            "+        printf(\"Monster buffer with fixed length arrays has wrong content\\n\");",
            "+        return -1;",
            "+    }",
            "+",
            "+    if (ns(FooBar_foo_get(fa, 0)) != 1.0f || ns(FooBar_bar_get(fa, 9) != 1000)) {",
            "+        printf(\"Monster buffer with fixed length arrays has wrong content\\n\");",
            "+        return -1;",
            "+    }",
            "+    if (ns(FooBar_foo_get(fa, 16)) != 0.0f || ns(FooBar_bar_get(fa, 10) != 0)) {",
            "+        printf(\"Monster buffer with fixed length arrays has bad bounds check\\n\");",
            "+        return -1;",
            "+    }",
            "+    if (ns(FooBar_col_get(fa, 2)) != ns(Color_Red)) {",
            "+        printf(\"Fixed length enum array content not correct\\n\");",
            "+        return -1;",
            "+    }",
            "+    t0 = ns(FooBar_tests_get(fa, 0));",
            "+    t1 = ns(FooBar_tests_get(fa, 1));",
            "+    if (!t0 || !t1) {",
            "+        printf(\"Monster buffer with fixed length struct arrays has missing element\\n\");",
            "+        return -1;",
            "+    }",
            "+    if (ns(Test_a_get(t0)) != 0 || ns(Test_b_get(t0)) != 4) {",
            "+        printf(\"Monster buffer with fixed length struct arrays has wrong first element member content\\n\");",
            "+        return -1;",
            "+    }",
            "+    if (ns(Test_a_get(t1)) != 1 || ns(Test_b_get(t1)) != 2) {",
            "+        printf(\"Monster buffer with fixed length struct arrays has wrong second element member content\\n\");",
            "+        return -1;",
            "+    }",
            "+",
            "+    /* Endian safe because char arrays are endian neutral. */",
            "+    text = ns(FooBar_text_get_ptr(fa));",
            "+    if (strncmp(text, \"hello\", ns(FooBar_text_get_len())) != 0) {",
            "+        printf(\"Monster buffer with fixed length array field has wrong text\\n\");",
            "+        return -1;",
            "+    }",
            "+",
            "+    /*",
            "+     * Note: use ns(FooBar_foo_get_ptr(fa) to get a raw pointer to the",
            "+     * array is not endian safe. Since this is a struct array field,",
            "+     * fa->foo would also provide the raw pointer.",
            "+     */",
            "+    if (flatbuffers_is_native_pe()) {",
            "+        if (ns(FooBar_foo_get_ptr(fa))[1] != 2.0f) {",
            "+            printf(\"Monster buffer with fixed length arrays get_ptr has wrong content\\n\");",
            "+            return -1;",
            "+        }",
            "+    }",
            "+",
            "+    ns(FooBar_copy_from_pe(&fa2, fa));",
            "+    if (fa2.foo[0] != 1.0f || fa2.foo[1] != 2.0f || fa2.foo[15] != 16.0f ||",
            "+            fa2.bar[0] != 100 || fa2.bar[9] != 1000) {",
            "+        printf(\"Monster buffer with copied fixed length arrays has wrong content\\n\");",
            "+        return -1;",
            "+    }",
            "+    if (fa2.foo[2] != 0.0f || fa2.foo[14] != 0.0f || fa2.bar[1] != 0 || fa2.bar[8] != 0) {",
            "+        printf(\"Monster buffer with copied fixed length arrays has not been zero padded\\n\");",
            "+        return -1;",
            "+    }",
            "+",
            "+    /*",
            "+     * In-place conversion - a nop on little endian platforms.",
            "+     * Cast needed to remove const",
            "+     */",
            "+    ns(FooBar_from_pe)((ns(FooBar_t) *)fa);",
            "+    if (fa->foo[0] != 1.0f || fa->foo[1] != 2.0f || fa->foo[15] != 16.0f ||",
            "+            fa->bar[0] != 100 || fa->bar[9] != 1000) {",
            "+        printf(\"Monster buffer with in-place converted fixed length arrays has wrong content\\n\");",
            "+        return -1;",
            "+    }",
            "+    if (fa->foo[2] != 0.0f || fa->foo[14] != 0.0f || fa->bar[1] != 0 || fa->bar[8] != 0) {",
            "+        printf(\"Monster buffer with in-place converted fixed length arrays has not been zero padded\\n\");",
            "+        return -1;",
            "+    }",
            "+    return 0;",
            "+}",
            "+",
            "+int test_fixed_length_array(flatcc_builder_t *B)",
            "+{",
            "+    void *buffer = 0;",
            "+    size_t size;",
            "+    int ret = -1;",
            "+    float foo_input[16] = { 1.0f, 2.0f, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16.0f };",
            "+    int bar_input[10] = { 100, 0, 0, 0, 0, 0, 0, 0, 0, 1000 };",
            "+    ns(Color_enum_t) col_input[3] = { 0, 0, ns(Color_Red) };",
            "+    ns(Test_t) tests_input[2] = {{ 0, 4 }, { 1, 2 }};",
            "+",
            "+    ns(FooBar_t) *foobar;",
            "+",
            "+    flatcc_builder_reset(B);",
            "+",
            "+    ns(Monster_start_as_root(B));",
            "+    ns(Monster_name_create_str(B, \"Monolith\"));",
            "+    ns(Monster_test_Alt_start(B));",
            "+    foobar = ns(Alt_fixed_array_start(B));",
            "+    foobar->foo[0] = 1.0f;",
            "+    foobar->foo[1] = 2.0f;",
            "+    foobar->foo[15] = 16.0f;",
            "+    foobar->bar[0] = 100;",
            "+    foobar->bar[9] = 1000;",
            "+    foobar->col[2] = ns(Color_Red);",
            "+    foobar->tests[0].b = 4;",
            "+    foobar->tests[1].a = 1;",
            "+    foobar->tests[1].b = 2;",
            "+    strncpy(foobar->text, \"hello, world\", ns(FooBar_text_get_len()));",
            "+    // or strncopy(foobar->text, \"hello, world\", sizeof(foobar->text));",
            "+    ns(Alt_fixed_array_end(B));",
            "+    ns(Monster_test_Alt_end(B));",
            "+",
            "+    ns(Monster_end_as_root(B));",
            "+",
            "+    buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            "+    ret = verify_fixed_length_array(buffer, size);",
            "+    flatcc_builder_aligned_free(buffer);",
            "+    if (ret) return -1;",
            "+",
            "+    flatcc_builder_reset(B);",
            "+",
            "+    ns(Monster_start_as_root(B));",
            "+    ns(Monster_name_create_str(B, \"Monolith\"));",
            "+    ns(Monster_test_Alt_start(B));",
            "+    foobar = ns(Alt_fixed_array_start(B));",
            "+    ns(FooBar_assign)(foobar, foo_input, bar_input, col_input, tests_input, \"hello\");",
            "+    ns(Alt_fixed_array_end(B));",
            "+    ns(Monster_test_Alt_end(B));",
            "+",
            "+    ns(Monster_end_as_root(B));",
            "+",
            "+    buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            "+    ret = verify_fixed_length_array(buffer, size);",
            "+    flatcc_builder_aligned_free(buffer);",
            "+    if (ret) return -1;",
            "+",
            "+    return 0;",
            "+}",
            "+",
            "+#define STR(s) nsc(string_create_str(B, s))",
            "+",
            "+int test_recursive_sort(flatcc_builder_t *B)",
            "+{",
            "+    nsc(string_ref_t) name;",
            "+",
            "+    void *buffer = 0;",
            "+    size_t size = 0;",
            "+    int ret = -1;",
            "+    ns(Alt_table_t) alt;",
            "+    ns(Any_union_t) any;",
            "+    ns(Monster_table_t) monster;",
            "+    ns(MultipleKeys_vec_t) mkvec;",
            "+    ns(MultipleKeys_table_t) mk;",
            "+    size_t index;",
            "+",
            "+    flatcc_builder_reset(B);",
            "+",
            "+    ns(Monster_start_as_root(B));",
            "+",
            "+    name = STR(\"Keyed Monster\");",
            "+    ns(Alt_start(B));",
            "+    ns(Alt_multik_start(B));",
            "+    ns(Alt_multik_push_create(B, STR(\"hi\"), STR(\"there\"), 42));",
            "+    ns(Alt_multik_push_create(B, STR(\"hello\"), STR(\"anyone\"), 10));",
            "+    ns(Alt_multik_push_create(B, STR(\"hello\"), STR(\"anyone\"), 4));",
            "+    ns(Alt_multik_push_create(B, STR(\"good day\"), STR(\"sir\"), 1004));",
            "+    ns(Alt_multik_end(B));",
            "+    ns(Monster_test_add)(B, ns(Any_as_Alt(ns(Alt_end(B)))));",
            "+    ns(Monster_name_add)(B, name);",
            "+    ns(Monster_end_as_root(B));",
            "+",
            "+    buffer = flatcc_builder_finalize_aligned_buffer(B, &size);",
            "+    monster = ns(Monster_as_root)(buffer);",
            "+    ns(Monster_sort)((ns(Monster_mutable_table_t))monster);",
            "+    any = ns(Monster_test_union(monster));",
            "+    if (any.type != ns(Any_Alt)) {",
            "+        printf(\"Any type no Alt as expected\\n\");",
            "+        goto done;",
            "+    }",
            "+    alt = any.value;",
            "+    mkvec = ns(Alt_multik(alt));",
            "+    index = ns(MultipleKeys_vec_len(mkvec));",
            "+    if (index != 4) {",
            "+        printf(\"unexpected multik vec len, got %d\\n\", (int)index);",
            "+        goto done;",
            "+    }",
            "+    mk = ns(MultipleKeys_vec_at(mkvec, 0));",
            "+    if (ns(MultipleKeys_foobar(mk) != 4)) {",
            "+        printf(\"multik elem 0 not sorted, but it really should be\\n\");",
            "+    }",
            "+    mk = ns(MultipleKeys_vec_at(mkvec, 1));",
            "+    if (ns(MultipleKeys_foobar(mk) != 10)) {",
            "+        printf(\"multik elem 1 not sorted, but it really should be\\n\");",
            "+    }",
            "+    mk = ns(MultipleKeys_vec_at(mkvec, 2));",
            "+    if (ns(MultipleKeys_foobar(mk) != 42)) {",
            "+        printf(\"multik elem 2 not sorted, but it really should be\\n\");",
            "+    }",
            "+    mk = ns(MultipleKeys_vec_at(mkvec, 3));",
            "+    if (ns(MultipleKeys_foobar(mk) != 1004)) {",
            "+        printf(\"multik elem 3 not sorted, but it really should be\\n\");",
            "+    }",
            "+",
            "+    hexdump(\"MultiKeyed buffer\", buffer, size, stderr);",
            "+    if ((ret = ns(Monster_verify_as_root(buffer, size)))) {",
            "+        printf(\"Multikeyed Monster buffer failed to verify, got: %s\\n\", flatcc_verify_error_string(ret));",
            "+        goto done;",
            "+    }",
            "+",
            "+    ret = 0;",
            "+done:",
            "+    flatcc_builder_aligned_free(buffer);",
            "+    return ret;",
            " }",
            " ",
            " int test_mixed_type_union(flatcc_builder_t *B)",
            " {",
            "     void *buffer;",
            "     size_t size;",
            "-    size_t n;",
            "     int ret = -1;",
            "     /* Builder */",
            "     nsf(Character_union_ref_t) ut;",
            "     nsf(Rapunzel_ref_t) cameo_ref;",
            "     nsf(Attacker_ref_t) attacker_ref;",
            "     nsf(BookReader_ref_t) br_ref;",
            "     nsf(BookReader_t *) pbr;",
            "@@ -2397,14 +2506,16 @@",
            "     }",
            " ",
            "     return 0;",
            " }",
            " ",
            " int verify_include(void *buffer)",
            " {",
            "+    (void)buffer;",
            "+",
            "     if (MyGame_OtherNameSpace_FromInclude_Foo != 17) {",
            "         printf(\"Unexpected enum value `Foo` from included schema\\n\");",
            "         return -1;",
            "     }",
            " ",
            "     if (MyGame_OtherNameSpace_FromInclude_IncludeVal != 0) {",
            "         printf(\"Unexpected enum value `IncludeVal` from included schema\\n\");",
            "@@ -2644,20 +2755,14 @@",
            " ",
            " #ifdef NDEBUG",
            "     printf(\"running optimized monster test\\n\");",
            " #else",
            "     printf(\"running debug monster test\\n\");",
            " #endif",
            " #if 1",
            "-    if (test_table_with_emptystruct(B)) {",
            "-        printf(\"TEST FAILED\\n\");",
            "-        return -1;",
            "-    }",
            "-#endif",
            "-#if 1",
            "     if (test_enums(B)) {",
            "         printf(\"TEST FAILED\\n\");",
            "         return -1;",
            "     }",
            " #endif",
            " #if 1",
            "     if (test_empty_monster(B)) {",
            "@@ -2692,20 +2797,14 @@",
            " #if 1",
            "     if (test_typed_empty_monster(B)) {",
            "         printf(\"TEST FAILED\\n\");",
            "         return -1;",
            "     }",
            " #endif",
            " #if 1",
            "-    if (test_typed_table_with_emptystruct(B)) {",
            "-        printf(\"TEST FAILED\\n\");",
            "-        return -1;",
            "-    }",
            "-#endif",
            "-#if 1",
            "     if (test_typed_struct_buffer(B)) {",
            "         printf(\"TEST FAILED\\n\");",
            "         return -1;",
            "     }",
            " #endif",
            " #if 1",
            "     if (test_clone_slice(B)) {",
            "@@ -2787,14 +2886,27 @@",
            " #endif",
            " #if 1",
            "     if (test_mixed_type_union(B)) {",
            "         printf(\"TEST FAILED\\n\");",
            "         return -1;",
            "     }",
            " #endif",
            "+#if 1",
            "+    if (test_recursive_sort(B)) {",
            "+        printf(\"TEST FAILED\\n\");",
            "+        return -1;",
            "+    }",
            "+#endif",
            "+#if 1",
            "+    if (test_fixed_length_array(B)) {",
            "+        printf(\"TEST FAILED\\n\");",
            "+        return -1;",
            "+    }",
            "+#endif",
            "+",
            " #ifdef FLATBUFFERS_BENCHMARK",
            "     time_monster(B);",
            "     time_struct_buffer(B);",
            " #endif",
            "     flatcc_builder_clear(B);",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/monster_test_prefix/monster_test_prefix.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/monster_test_prefix/monster_test_prefix.c",
            "+++ /home/flatcc-0.6.1/test/monster_test_prefix/monster_test_prefix.c",
            "@@ -14,11 +14,11 @@",
            "     B = &builder;",
            "     flatcc_builder_init(B);",
            " ",
            "     zzz_MyGame_Example_Monster_start_as_root(B);",
            "     zzz_MyGame_Example_Monster_name_create_str(B, \"MyMonster\");",
            "     zzz_MyGame_Example_Monster_end_as_root(B);",
            "     buf = flatcc_builder_get_direct_buffer(B, &size);",
            "-    ret = zzz_MyGame_Example_Monster_verify_as_root_with_identifier(buf, size, zzz_MyGame_Example_Monster_identifier);",
            "+    ret = zzz_MyGame_Example_Monster_verify_as_root_with_identifier(buf, size, zzz_MyGame_Example_Monster_file_identifier);",
            "     flatcc_builder_clear(B);",
            "     return ret;",
            " }"
          ]
        },
        {
          "file": "/home/flatcc-0.6.1/test/reflection_test/reflection_test.c",
          "change": [
            "--- /home/flatcc-0.5.3/test/reflection_test/reflection_test.c",
            "+++ /home/flatcc-0.6.1/test/reflection_test/reflection_test.c",
            "@@ -1,25 +1,36 @@",
            " #include \"flatcc/support/readfile.h\"",
            " #include \"flatcc/reflection/reflection_reader.h\"",
            "+#include \"flatcc/portable/pcrt.h\"",
            "+",
            "+/* -DFLATCC_PORTABLE may help if inttypes.h is missing. */",
            "+#ifndef PRId64",
            "+#include <inttypes.h>",
            "+#endif",
            " ",
            "-#define lld(x) (long long int)(x)",
            " ",
            " /* This is not an exhaustive test. */",
            " int test_schema(const char *monster_bfbs)",
            " {",
            "     void *buffer;",
            "     size_t size;",
            "     int ret = -1;",
            "     reflection_Schema_table_t S;",
            "     reflection_Object_vec_t Objs;",
            "     reflection_Object_table_t Obj;",
            "     reflection_Field_vec_t Flds;",
            "     reflection_Field_table_t F;",
            "     reflection_Type_table_t T;",
            "     size_t k, monster_index;",
            "+    reflection_Service_vec_t Svcs;",
            "+    reflection_Service_table_t Svc;",
            "+    reflection_RPCCall_vec_t Calls;",
            "+    reflection_RPCCall_table_t Call;",
            "+    size_t call_index;",
            "+    const char *strval;",
            " ",
            "     buffer = readfile(monster_bfbs, 100000, &size);",
            "     if (!buffer) {",
            "         printf(\"failed to load binary schema\\n\");",
            "         goto done;",
            "     }",
            "     S = reflection_Schema_as_root(buffer);",
            "@@ -45,22 +56,26 @@",
            "         printf(\"Did not find mana field in Monster schema\\n\");",
            "         goto done;",
            "     }",
            "     F = reflection_Field_vec_at(Flds, k);",
            "     if (reflection_Field_default_integer(F) != 150) {",
            "         printf(\"mana field has wrong default value\\n\");",
            "         printf(\"field name: %s\\n\", reflection_Field_name(F));",
            "-        printf(\"%lld\\n\", lld(reflection_Field_default_integer(F)));",
            "+        printf(\"%\"PRId64\"\\n\", (int64_t)reflection_Field_default_integer(F));",
            "         goto done;",
            "     }",
            "     T = reflection_Field_type(F);",
            "     if (reflection_Type_base_type(T) != reflection_BaseType_Short) {",
            "         printf(\"mana field has wrong type\\n\");",
            "         goto done;",
            "     }",
            "+    if (reflection_Field_optional(F)) {",
            "+        printf(\"mana field is not optional\\n\");",
            "+        goto done;",
            "+    }",
            "     k = reflection_Field_vec_find(Flds, \"enemy\");",
            "     if (k == flatbuffers_not_found) {",
            "         printf(\"enemy field not found\\n\");",
            "         goto done;",
            "     }",
            "     T = reflection_Field_type(reflection_Field_vec_at(Flds, k));",
            "     if (reflection_Type_base_type(T) != reflection_BaseType_Obj) {",
            "@@ -85,15 +100,74 @@",
            "         printf(\"array of tables is not a vector of table type\\n\");",
            "         goto done;",
            "     }",
            "     if (reflection_Type_index(T) != (int32_t)monster_index) {",
            "         printf(\"array of tables is not a monster vector\\n\");",
            "         goto done;",
            "     }",
            "-",
            "+    /* list services and calls */",
            "+    Svcs = reflection_Schema_services(S);",
            "+    for (k = 0; k < reflection_Service_vec_len(Svcs); ++k) {",
            "+        Svc = reflection_Service_vec_at(Svcs, k);",
            "+        printf(\"dbg: svc #%d : %s\\n\", (int)k,",
            "+                reflection_Service_name(Svc));",
            "+        Calls = reflection_Service_calls(Svc);",
            "+        for (call_index = 0 ;",
            "+             call_index < reflection_RPCCall_vec_len(Calls) ;",
            "+             call_index++) {",
            "+            Call = reflection_RPCCall_vec_at(Calls, call_index);",
            "+            printf(\"dbg:    call %d : %s\\n\", (int)call_index,",
            "+                reflection_RPCCall_name(Call));",
            "+        }",
            "+    }",
            "+    /* Within service MyGame.Example.MonsterStorage ... */",
            "+    k = reflection_Service_vec_find(Svcs, \"MyGame.Example.MonsterStorage\");",
            "+    if (k == flatbuffers_not_found) {",
            "+        printf(\"Could not find MonsterStorage service in schema\\n\");",
            "+        goto done;",
            "+    }",
            "+    Svc = reflection_Service_vec_at(Svcs, k);",
            "+    /* ... search the RPC call Store */",
            "+    Calls = reflection_Service_calls(Svc);",
            "+    k = reflection_RPCCall_vec_find(Calls, \"Store\");",
            "+    if (k == flatbuffers_not_found) {",
            "+        printf(\"Could not find call Store in service\\n\");",
            "+        goto done;",
            "+    }",
            "+    Call = reflection_RPCCall_vec_at(Calls, k);",
            "+    /* Ensure request type is MyGame.Example.Monster */",
            "+    Obj = reflection_Object_vec_at(Objs, monster_index);",
            "+    if (Obj != reflection_RPCCall_request(Call)) {",
            "+        printf(\"Wrong request type of rpc call\\n\");",
            "+        goto done;",
            "+    }",
            "+    /* Ensure response type is MyGame.Example.Stat */",
            "+    k = reflection_Object_vec_find(Objs, \"MyGame.Example.Stat\");",
            "+    if (k == flatbuffers_not_found) {",
            "+        printf(\"Could not find Stat in schema\\n\");",
            "+        goto done;",
            "+    }",
            "+    Obj = reflection_Object_vec_at(Objs, k);",
            "+    if (Obj != reflection_RPCCall_response(Call)) {",
            "+        printf(\"Wrong response type of rpc call\\n\");",
            "+        goto done;",
            "+    }",
            "+    /* check the call has an attribute \"streaming\" */",
            "+    k = reflection_KeyValue_vec_scan(reflection_RPCCall_attributes(Call), \"streaming\");",
            "+    if (k == flatbuffers_not_found) {",
            "+        printf(\"Could not find attribute in call\\n\");",
            "+        goto done;",
            "+    }",
            "+    /* check the attribute value is \"none\" */",
            "+    strval = reflection_KeyValue_value(",
            "+                reflection_KeyValue_vec_at(reflection_RPCCall_attributes(Call), k));",
            "+    if (!strval || 0 != strcmp(\"none\", strval)) {",
            "+        printf(\"Wrong attribute value in call\\n\");",
            "+        goto done;",
            "+    }",
            "     ret = 0;",
            " done:",
            "     if (buffer) {",
            "         free(buffer);",
            "     }",
            "     return ret;",
            " }",
            "@@ -103,14 +177,17 @@",
            " \"wrong number of arguments:\\n\" \\",
            " \"usage: <program> [<output-filename>]\\n\"",
            " ",
            " const char *filename = \"generated/monster_test.bfbs\";",
            " ",
            " int main(int argc, char *argv[])",
            " {",
            "+    /* Avoid assert dialogs on Windows. */",
            "+    init_headless_crt();",
            "+",
            "     if (argc != 1 && argc != 2) {",
            "         fprintf(stderr, usage);",
            "         exit(1);",
            "     }",
            "     if (argc == 2) {",
            "         filename = argv[1];",
            "     }"
          ]
        }
      ]
    }
  }
}