{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:dd84ed13-f6cb-4e5e-88d0-a41b762cf5ed",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T12:37:15-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "c05eceabb38dc36d",
      "type": "file",
      "name": "isocline-1.0.9/"
    }
  },
  "upgrade": {
    "file_changes": {
      "old_version": "/home/isocline-1.0.1",
      "New file": [],
      "Deleted file": [],
      "Modified file": [
        {
          "file": "/home/isocline-1.0.9/include/isocline.h",
          "change": [
            "--- /home/isocline-1.0.1/include/isocline.h",
            "+++ /home/isocline-1.0.9/include/isocline.h",
            "@@ -41,15 +41,15 @@",
            " */",
            " ",
            " /// \\defgroup readline Readline",
            " /// The basic readline interface.",
            " /// \\{",
            " ",
            " /// Isocline version: 102 = 1.0.2.",
            "-#define IC_VERSION   (101)    /// 1.0.0",
            "+#define IC_VERSION   (104)  ",
            " ",
            " ",
            " /// Read input from the user using rich editing abilities.",
            " /// @param prompt_text   The prompt text, can be NULL for the default (\"\"). ",
            " ///   The displayed prompt becomes `prompt_text` followed by the `prompt_marker` (\"> \"). ",
            " /// @returns the heap allocated input on succes, which should be `free`d by the caller.  ",
            " ///   Returns NULL on error, or if the user typed ctrl+d or ctrl+c.",
            "@@ -411,21 +411,21 @@",
            " ",
            " /// Get the raw current input (and cursor position if `cursor` != NULL) for the completion.",
            " /// Usually completer functions should look at their `prefix` though as transformers",
            " /// like `ic_complete_word` may modify the prefix (for example, unescape it).",
            " const char* ic_completion_input( ic_completion_env_t* cenv, long* cursor );",
            " ",
            " /// Get the completion argument passed to `ic_set_completer`.",
            "-void* ic_completion_arg( ic_completion_env_t* cenv );",
            "+void* ic_completion_arg( const ic_completion_env_t* cenv );",
            " ",
            " /// Do we have already some completions?",
            "-bool ic_has_completions( ic_completion_env_t* cenv );",
            "+bool ic_has_completions( const ic_completion_env_t* cenv );",
            " ",
            " /// Do we already have enough completions and should we return if possible? (for improved latency)",
            "-bool ic_stop_completing(ic_completion_env_t* cenv);",
            "+bool ic_stop_completing( const ic_completion_env_t* cenv);",
            " ",
            " ",
            " /// Primitive completion, cannot be used with most transformers (like `ic_complete_word` and `ic_complete_qword`).",
            " /// When completed, `delete_before` _bytes_ are deleted before the cursor position,",
            " /// `delete_after` _bytes_ are deleted after the cursor, and finally `completion` is inserted.",
            " /// The `display` is used to display the completion in the completion menu, and `help` is displayed",
            " /// with hinting. Both `display` and `help` can be NULL."
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/bbcode.c",
          "change": [
            "--- /home/isocline-1.0.1/src/bbcode.c",
            "+++ /home/isocline-1.0.9/src/bbcode.c",
            "@@ -759,14 +759,15 @@",
            "       }",
            "     }",
            "   }  ",
            "   return (end - s);",
            " }",
            " ",
            " ic_private void bbcode_append( bbcode_t* bb, const char* s, stringbuf_t* out, attrbuf_t* attr_out ) {",
            "+  if (bb == NULL || s == NULL) return;",
            "   attr_t attr = attr_none();",
            "   const ssize_t base = bb->tags_nesting; // base; will not be popped",
            "   ssize_t i = 0;",
            "   while( s[i] != 0 ) {",
            "     // handle no tags in bulk",
            "     ssize_t nobb = 0;",
            "     char c;",
            "@@ -798,44 +799,44 @@",
            "   assert(bb->tags_nesting >= base);",
            "   while( bb->tags_nesting > base ) {",
            "     bbcode_tag_pop(bb,NULL);",
            "   };",
            " }",
            " ",
            " ic_private void bbcode_print( bbcode_t* bb, const char* s ) {",
            "-  if (bb->out == NULL || bb->out_attrs == NULL) return;",
            "+  if (bb->out == NULL || bb->out_attrs == NULL || s == NULL) return;",
            "   assert(sbuf_len(bb->out) == 0 && attrbuf_len(bb->out_attrs) == 0);",
            "   bbcode_append( bb, s, bb->out, bb->out_attrs );",
            "   term_write_formatted( bb->term, sbuf_string(bb->out), attrbuf_attrs(bb->out_attrs,sbuf_len(bb->out)) );",
            "   attrbuf_clear(bb->out_attrs);",
            "   sbuf_clear(bb->out);",
            " }",
            " ",
            " ic_private void bbcode_println( bbcode_t* bb, const char* s ) {",
            "   bbcode_print(bb,s);",
            "   term_writeln(bb->term, \"\");",
            " }",
            " ",
            " ic_private void bbcode_vprintf( bbcode_t* bb, const char* fmt, va_list args  ) {",
            "-  if (bb->vout == NULL) return;",
            "+  if (bb->vout == NULL || fmt == NULL) return;",
            "   assert(sbuf_len(bb->vout) == 0);",
            "   sbuf_append_vprintf(bb->vout,fmt,args);",
            "   bbcode_print(bb, sbuf_string(bb->vout));",
            "   sbuf_clear(bb->vout);",
            " }",
            " ",
            " ic_private void bbcode_printf( bbcode_t* bb, const char* fmt, ... ) {",
            "   va_list args;",
            "   va_start(args,fmt);",
            "   bbcode_vprintf(bb,fmt,args);",
            "   va_end(args);",
            " }",
            " ",
            " ic_private ssize_t bbcode_column_width( bbcode_t* bb, const char* s ) {",
            "-  if (s==0 || s[0] == 0) return 0;",
            "+  if (s==NULL || s[0] == 0) return 0;",
            "   if (bb->vout == NULL) { return str_column_width(s); }",
            "   assert(sbuf_len(bb->vout) == 0); ",
            "   bbcode_append( bb, s, bb->vout, NULL);",
            "   const ssize_t w = str_column_width(sbuf_string(bb->vout));",
            "   sbuf_clear(bb->vout);",
            "   return w;",
            " }"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/completions.c",
          "change": [
            "--- /home/isocline-1.0.1/src/completions.c",
            "+++ /home/isocline-1.0.9/src/completions.c",
            "@@ -90,20 +90,29 @@",
            "   cms->count++;",
            " }",
            " ",
            " ic_private ssize_t completions_count(completions_t* cms) {",
            "   return cms->count;",
            " }",
            " ",
            "+static bool completions_contains(completions_t* cms, const char* replacement) {",
            "+  for( ssize_t i = 0; i < cms->count; i++ ) {",
            "+    const completion_t* c = cms->elems + i;",
            "+    if (strcmp(replacement,c->replacement) == 0) { return true; }",
            "+  }",
            "+  return false;",
            "+} ",
            " ",
            " ic_private bool completions_add(completions_t* cms, const char* replacement, const char* display, const char* help, ssize_t delete_before, ssize_t delete_after) {",
            "   if (cms->completer_max <= 0) return false;",
            "   cms->completer_max--;",
            "   //debug_msg(\"completion: add: %d,%d, %s\\n\", delete_before, delete_after, replacement);",
            "-  completions_push(cms, replacement, display, help, delete_before, delete_after);",
            "+  if (!completions_contains(cms,replacement)) {",
            "+    completions_push(cms, replacement, display, help, delete_before, delete_after);",
            "+  }",
            "   return true;",
            " }",
            " ",
            " static completion_t* completions_get(completions_t* cms, ssize_t index) {",
            "   if (index < 0 || cms->count <= 0 || index >= cms->count) return NULL;",
            "   return &cms->elems[index];",
            " }",
            "@@ -140,20 +149,25 @@",
            " }",
            " ",
            " ic_private void completions_get_completer(completions_t* cms, ic_completer_fun_t** completer, void** arg) {",
            "   *completer = cms->completer;",
            "   *arg = cms->completer_arg;",
            " }",
            " ",
            "-ic_public bool ic_has_completions( ic_completion_env_t* cenv ) {",
            "-  return (cenv->env->completions->count > 0);",
            "+",
            "+ic_public void* ic_completion_arg( const ic_completion_env_t* cenv ) {",
            "+  return (cenv == NULL ? NULL : cenv->env->completions->completer_arg);",
            "+}",
            "+",
            "+ic_public bool ic_has_completions( const ic_completion_env_t* cenv ) {",
            "+  return (cenv == NULL ? false : cenv->env->completions->count > 0);",
            " }",
            " ",
            "-ic_public bool ic_stop_completing(ic_completion_env_t* cenv) {",
            "-  return (cenv->env->completions->completer_max <= 0);",
            "+ic_public bool ic_stop_completing( const ic_completion_env_t* cenv) {",
            "+  return (cenv == NULL ? true : cenv->env->completions->completer_max <= 0);",
            " }",
            " ",
            " ",
            " static ssize_t completion_apply( completion_t* cm, stringbuf_t* sbuf, ssize_t pos ) {",
            "   if (cm == NULL) return -1;  ",
            "   debug_msg( \"completion: apply: %s at %zd\\n\", cm->replacement, pos);",
            "   ssize_t start = pos - cm->delete_before;"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/editline.c",
          "change": [
            "--- /home/isocline-1.0.1/src/editline.c",
            "+++ /home/isocline-1.0.9/src/editline.c",
            "@@ -993,15 +993,20 @@",
            "       // navigation",
            "       case KEY_LEFT:",
            "       case KEY_CTRL_B:",
            "         edit_cursor_left(env,&eb);",
            "         break;",
            "       case KEY_RIGHT:",
            "       case KEY_CTRL_F:",
            "-        edit_cursor_right(env,&eb);",
            "+        if (eb.pos == sbuf_len(eb.input)) { ",
            "+          edit_generate_completions( env, &eb, false );",
            "+        }",
            "+        else {",
            "+          edit_cursor_right(env,&eb);",
            "+        }",
            "         break;",
            "       case KEY_UP:",
            "         edit_cursor_row_up(env,&eb);",
            "         break;",
            "       case KEY_DOWN:",
            "         edit_cursor_row_down(env,&eb);",
            "         break;                 ",
            "@@ -1017,15 +1022,20 @@",
            "       case WITH_SHIFT(KEY_LEFT):    ",
            "       case WITH_ALT('b'):",
            "         edit_cursor_prev_word(env,&eb);",
            "         break;",
            "       case KEY_CTRL_RIGHT:",
            "       case WITH_SHIFT(KEY_RIGHT):      ",
            "       case WITH_ALT('f'):",
            "-        edit_cursor_next_word(env,&eb);",
            "+        if (eb.pos == sbuf_len(eb.input)) { ",
            "+          edit_generate_completions( env, &eb, false );",
            "+        }",
            "+        else {",
            "+          edit_cursor_next_word(env,&eb);",
            "+        }",
            "         break;      ",
            "       case KEY_CTRL_HOME:",
            "       case WITH_SHIFT(KEY_HOME):      ",
            "       case KEY_PAGEUP:",
            "       case WITH_ALT('<'):",
            "         edit_cursor_to_start(env,&eb);",
            "         break;"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/history.c",
          "change": [
            "--- /home/isocline-1.0.1/src/history.c",
            "+++ /home/isocline-1.0.9/src/history.c",
            "@@ -185,18 +185,18 @@",
            " static bool history_read_entry( history_t* h, FILE* f, stringbuf_t* sbuf ) {",
            "   sbuf_clear(sbuf);",
            "   while( !feof(f)) {",
            "     int c = fgetc(f);",
            "     if (c == EOF || c == '\\n') break;",
            "     if (c == '\\\\') {",
            "       c = fgetc(f);",
            "-      if (c == 'n')       sbuf_append(sbuf,\"\\n\");",
            "-      else if (c == 'r')  sbuf_append(sbuf,\"\\r\");",
            "-      else if (c == 't')  sbuf_append(sbuf,\"\\t\");",
            "-      else if (c == '\\\\') sbuf_append(sbuf,\"\\\\\");",
            "+      if (c == 'n')       { sbuf_append(sbuf,\"\\n\"); }",
            "+      else if (c == 'r')  { /* ignore */ }  // sbuf_append(sbuf,\"\\r\");",
            "+      else if (c == 't')  { sbuf_append(sbuf,\"\\t\"); }",
            "+      else if (c == '\\\\') { sbuf_append(sbuf,\"\\\\\"); }",
            "       else if (c == 'x') {",
            "         int c1 = fgetc(f);         ",
            "         int c2 = fgetc(f);",
            "         if (ic_isxdigit(c1) && ic_isxdigit(c2)) {",
            "           char chr = from_xdigit(c1)*16 + from_xdigit(c2);",
            "           sbuf_append_char(sbuf,chr);",
            "         }",
            "@@ -213,15 +213,15 @@",
            " static bool history_write_entry( const char* entry, FILE* f, stringbuf_t* sbuf ) {",
            "   sbuf_clear(sbuf);",
            "   //debug_msg(\"history: write: %s\\n\", entry);",
            "   while( entry != NULL && *entry != 0 ) {",
            "     char c = *entry++;",
            "     if (c == '\\\\')      { sbuf_append(sbuf,\"\\\\\\\\\"); }",
            "     else if (c == '\\n') { sbuf_append(sbuf,\"\\\\n\"); }",
            "-    else if (c == '\\r') { sbuf_append(sbuf,\"\\\\r\"); }",
            "+    else if (c == '\\r') { /* ignore */ } // sbuf_append(sbuf,\"\\\\r\"); }",
            "     else if (c == '\\t') { sbuf_append(sbuf,\"\\\\t\"); }",
            "     else if (c < ' ' || c > '~' || c == '#') {",
            "       char c1 = to_xdigit( (uint8_t)c / 16 );",
            "       char c2 = to_xdigit( (uint8_t)c % 16 );",
            "       sbuf_append(sbuf,\"\\\\x\"); ",
            "       sbuf_append_char(sbuf,c1); ",
            "       sbuf_append_char(sbuf,c2);"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/isocline.c",
          "change": [
            "--- /home/isocline-1.0.1/src/isocline.c",
            "+++ /home/isocline-1.0.9/src/isocline.c",
            "@@ -6,15 +6,15 @@",
            " -----------------------------------------------------------------------------*/",
            " ",
            " //-------------------------------------------------------------",
            " // Usually we include all sources one file so no internal ",
            " // symbols are public in the libray.",
            " // ",
            " // You can compile the entire library just as: ",
            "-// $ gcc -c src/isocline.c",
            "+// $ gcc -c src/isocline.c ",
            " //-------------------------------------------------------------",
            " #if !defined(IC_SEPARATE_OBJS)",
            " # define _CRT_SECURE_NO_WARNINGS  // for msvc",
            " # define _XOPEN_SOURCE   700      // for wcwidth",
            " # define _DEFAULT_SOURCE          // ensure usleep stays visible with _XOPEN_SOURCE >= 700",
            " # include \"attr.c\"",
            " # include \"bbcode.c\"",
            "@@ -535,18 +535,18 @@",
            "     env->noedit = true;",
            "   }",
            "   env->multiline_eol = '\\\\';",
            "   ",
            "   bbcode_style_def(env->bbcode, \"ic-prompt\",    \"ansi-green\" );",
            "   bbcode_style_def(env->bbcode, \"ic-info\",      \"ansi-darkgray\" );",
            "   bbcode_style_def(env->bbcode, \"ic-diminish\",  \"ansi-lightgray\" );",
            "-  bbcode_style_def(env->bbcode, \"ic-emphasis\",  \"color=#FFFFD7\" );",
            "+  bbcode_style_def(env->bbcode, \"ic-emphasis\",  \"#ffffd7\" );",
            "   bbcode_style_def(env->bbcode, \"ic-hint\",      \"ansi-darkgray\" );",
            "-  bbcode_style_def(env->bbcode, \"ic-error\",     \"color=#D70000\" );",
            "-  bbcode_style_def(env->bbcode, \"ic-bracematch\",\"color=#F7DC6F\" );",
            "+  bbcode_style_def(env->bbcode, \"ic-error\",     \"#d70000\" );",
            "+  bbcode_style_def(env->bbcode, \"ic-bracematch\",\"ansi-white\"); //  color = #F7DC6F\" );",
            " ",
            "   bbcode_style_def(env->bbcode, \"keyword\",  \"#569cd6\" );",
            "   bbcode_style_def(env->bbcode, \"control\",  \"#c586c0\" );",
            "   bbcode_style_def(env->bbcode, \"number\",   \"#b5cea8\" );",
            "   bbcode_style_def(env->bbcode, \"string\",   \"#ce9178\" );",
            "   bbcode_style_def(env->bbcode, \"comment\",  \"#6A9955\" );",
            "   bbcode_style_def(env->bbcode, \"type\",     \"darkcyan\" );"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/stringbuf.c",
          "change": [
            "--- /home/isocline-1.0.1/src/stringbuf.c",
            "+++ /home/isocline-1.0.9/src/stringbuf.c",
            "@@ -2,25 +2,29 @@",
            "   Copyright (c) 2021, Daan Leijen",
            "   This is free software; you can redistribute it and/or modify it",
            "   under the terms of the MIT License. A copy of the license can be",
            "   found in the \"LICENSE\" file at the root of this distribution.",
            " -----------------------------------------------------------------------------*/",
            " ",
            " // get `wcwidth` for the column width of unicode characters",
            "+// note: for now the OS provided one is unused as we see quite a bit of variation ",
            "+// among platforms and including our own seems more reliable.",
            "+/* ",
            " #if defined(__linux__) || defined(__freebsd__)",
            " // use the system supplied one",
            " #if !defined(_XOPEN_SOURCE)",
            " #define  _XOPEN_SOURCE  700    // so wcwidth is visible",
            " #endif",
            " #include <wchar.h>",
            " #else",
            "+*/",
            " // use our own (also on APPLE as that fails within vscode)",
            " #define  wcwidth(c)  mk_wcwidth(c)",
            " #include \"wcwidth.c\"",
            "-#endif",
            "+// #endif",
            " ",
            " #include <stdio.h>",
            " #include <string.h>",
            " #include <inttypes.h>",
            " ",
            " #include \"common.h\"",
            " #include \"stringbuf.h\""
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/term.c",
          "change": [
            "--- /home/isocline-1.0.1/src/term.c",
            "+++ /home/isocline-1.0.9/src/term.c",
            "@@ -150,14 +150,15 @@",
            " }",
            " ",
            " ic_private attr_t term_get_attr( const term_t* term ) {",
            "   return term->attr;",
            " }",
            " ",
            " ic_private void term_set_attr( term_t* term, attr_t attr ) {",
            "+  if (term->nocolor) return;",
            "   if (attr.x.color != term->attr.x.color && attr.x.color != IC_COLOR_NONE) {",
            "     term_color(term,attr.x.color);",
            "     if (term->palette < ANSIRGB && color_is_rgb(attr.x.color)) {",
            "       term->attr.x.color = attr.x.color; // actual color may have been approximated but we keep the actual color to avoid updating every time",
            "     }",
            "   }",
            "   if (attr.x.bgcolor != term->attr.x.bgcolor && attr.x.bgcolor != IC_COLOR_NONE) {",
            "@@ -173,15 +174,15 @@",
            "     term_underline(term,attr.x.underline == IC_ON);",
            "   }",
            "   if (attr.x.reverse != term->attr.x.reverse && attr.x.reverse != IC_NONE) {",
            "     term_reverse(term,attr.x.reverse == IC_ON);",
            "   }",
            "   if (attr.x.italic != term->attr.x.italic && attr.x.italic != IC_NONE) {",
            "     term_italic(term,attr.x.italic == IC_ON);",
            "-  }",
            "+  }  ",
            "   assert(attr.x.color == term->attr.x.color || attr.x.color == IC_COLOR_NONE);",
            "   assert(attr.x.bgcolor == term->attr.x.bgcolor || attr.x.bgcolor == IC_COLOR_NONE);",
            "   assert(attr.x.bold == term->attr.x.bold || attr.x.bold == IC_NONE);",
            "   assert(attr.x.reverse == term->attr.x.reverse || attr.x.reverse == IC_NONE);",
            "   assert(attr.x.underline == term->attr.x.underline || attr.x.underline == IC_NONE);",
            "   assert(attr.x.italic == term->attr.x.italic || attr.x.italic == IC_NONE);",
            " }",
            "@@ -327,66 +328,67 @@",
            " ",
            " ic_private term_t* term_new(alloc_t* mem, tty_t* tty, bool nocolor, bool silent, int fd_out ) ",
            " {",
            "   term_t* term = mem_zalloc_tp(mem, term_t);",
            "   if (term == NULL) return NULL;",
            " ",
            "   term->fd_out  = (fd_out < 0 ? STDOUT_FILENO : fd_out);",
            "-  term->nocolor = nocolor;",
            "+  term->nocolor = nocolor || (isatty(term->fd_out) == 0);",
            "   term->silent  = silent;  ",
            "   term->mem     = mem;",
            "-  term->tty     = tty;",
            "+  term->tty     = tty;     // can be NULL",
            "   term->width   = 80;",
            "   term->height  = 25;",
            "   term->is_utf8 = tty_is_utf8(tty);",
            "   term->palette = ANSI16; // almost universally supported",
            "   term->buf     = sbuf_new(mem);  ",
            "   term->bufmode = LINEBUFFERED;",
            "   term->attr    = attr_default();",
            " ",
            "   // respect NO_COLOR",
            "   if (getenv(\"NO_COLOR\") != NULL) {",
            "     term->nocolor = true;",
            "   }",
            "-",
            "-  // detect color palette",
            "-  // COLORTERM takes precedence",
            "-  const char* colorterm = getenv(\"COLORTERM\");  ",
            "-  if (ic_contains(colorterm,\"24bit\") || ic_contains(colorterm,\"truecolor\") || ic_contains(colorterm,\"direct\")) { ",
            "-    term->palette = ANSIRGB; ",
            "-  }",
            "-  else if (ic_contains(colorterm,\"8bit\") || ic_contains(colorterm,\"256color\")) { term->palette = ANSI256; } ",
            "-  else if (ic_contains(colorterm,\"4bit\") || ic_contains(colorterm,\"16color\"))  { term->palette = ANSI16; }",
            "-  else if (ic_contains(colorterm,\"3bit\") || ic_contains(colorterm,\"8color\"))   { term->palette = ANSI8; }",
            "-  else if (ic_contains(colorterm,\"1bit\") || ic_contains(colorterm,\"nocolor\") || ic_contains(colorterm,\"monochrome\")) { ",
            "-    term->palette = MONOCHROME; ",
            "-  }",
            "-  // otherwise check for some specific terminals",
            "-  else if (getenv(\"WT_SESSION\") != NULL) { term->palette = ANSIRGB; } // Windows terminal",
            "-  else if (getenv(\"ITERM_SESSION_ID\") != NULL) { term->palette = ANSIRGB; } // iTerm2 terminal",
            "-  else if (getenv(\"VSCODE_PID\") != NULL) { term->palette = ANSIRGB; } // vscode terminal",
            "-  else {",
            "-    // and otherwise fall back to checking TERM",
            "-    const char* eterm = getenv(\"TERM\");",
            "-    if (ic_contains(eterm,\"truecolor\") || ic_contains(eterm,\"direct\") || ic_contains(colorterm,\"24bit\")) {",
            "-      term->palette = ANSIRGB;",
            "-    }",
            "-    else if (ic_contains(eterm,\"alacritty\") || ic_contains(eterm,\"kitty\")) {",
            "-      term->palette = ANSIRGB;",
            "-    }",
            "-    else if (ic_contains(eterm,\"256color\") || ic_contains(eterm,\"gnome\")) { ",
            "-      term->palette = ANSI256;",
            "-    }  ",
            "-    else if (ic_contains(eterm,\"16color\")){ term->palette = ANSI16; }",
            "-    else if (ic_contains(eterm,\"8color\")) { term->palette = ANSI8; }",
            "-    else if (ic_contains(eterm,\"monochrome\") || ic_contains(eterm,\"nocolor\") || ic_contains(eterm,\"dumb\")) { ",
            "+  if (!term->nocolor) {",
            "+    // detect color palette",
            "+    // COLORTERM takes precedence",
            "+    const char* colorterm = getenv(\"COLORTERM\");  ",
            "+    const char* eterm = getenv(\"TERM\");    ",
            "+    if (ic_contains(colorterm,\"24bit\") || ic_contains(colorterm,\"truecolor\") || ic_contains(colorterm,\"direct\")) { ",
            "+      term->palette = ANSIRGB; ",
            "+    }",
            "+    else if (ic_contains(colorterm,\"8bit\") || ic_contains(colorterm,\"256color\")) { term->palette = ANSI256; } ",
            "+    else if (ic_contains(colorterm,\"4bit\") || ic_contains(colorterm,\"16color\"))  { term->palette = ANSI16; }",
            "+    else if (ic_contains(colorterm,\"3bit\") || ic_contains(colorterm,\"8color\"))   { term->palette = ANSI8; }",
            "+    else if (ic_contains(colorterm,\"1bit\") || ic_contains(colorterm,\"nocolor\") || ic_contains(colorterm,\"monochrome\")) { ",
            "       term->palette = MONOCHROME; ",
            "     }",
            "+    // otherwise check for some specific terminals",
            "+    else if (getenv(\"WT_SESSION\") != NULL) { term->palette = ANSIRGB; } // Windows terminal",
            "+    else if (getenv(\"ITERM_SESSION_ID\") != NULL) { term->palette = ANSIRGB; } // iTerm2 terminal",
            "+    else if (getenv(\"VSCODE_PID\") != NULL) { term->palette = ANSIRGB; } // vscode terminal",
            "+    else {",
            "+      // and otherwise fall back to checking TERM",
            "+      if (ic_contains(eterm,\"truecolor\") || ic_contains(eterm,\"direct\") || ic_contains(colorterm,\"24bit\")) {",
            "+        term->palette = ANSIRGB;",
            "+      }",
            "+      else if (ic_contains(eterm,\"alacritty\") || ic_contains(eterm,\"kitty\")) {",
            "+        term->palette = ANSIRGB;",
            "+      }",
            "+      else if (ic_contains(eterm,\"256color\") || ic_contains(eterm,\"gnome\")) { ",
            "+        term->palette = ANSI256;",
            "+      }  ",
            "+      else if (ic_contains(eterm,\"16color\")){ term->palette = ANSI16; }",
            "+      else if (ic_contains(eterm,\"8color\")) { term->palette = ANSI8; }",
            "+      else if (ic_contains(eterm,\"monochrome\") || ic_contains(eterm,\"nocolor\") || ic_contains(eterm,\"dumb\")) { ",
            "+        term->palette = MONOCHROME; ",
            "+      }",
            "+    }",
            "+    debug_msg(\"term: color-bits: %d (COLORTERM=%s, TERM=%s)\\n\", term_get_color_bits(term), colorterm, eterm);",
            "   }",
            "-  debug_msg(\"term: color-bits: %d (COLORTERM=%s, TERM=%s)\\n\", term_get_color_bits(term), colorterm, term);",
            "   ",
            "   // read COLUMS/LINES from the environment for a better initial guess.",
            "   const char* env_columns = getenv(\"COLUMNS\");",
            "   if (env_columns != NULL) { ic_atoz(env_columns, &term->width); }",
            "   const char* env_lines = getenv(\"LINES\");",
            "   if (env_lines != NULL)   { ic_atoz(env_lines, &term->height); }",
            "   ",
            "@@ -551,15 +553,16 @@",
            " #if !defined(ENABLE_LVB_GRID_WORLDWIDE)",
            " #define ENABLE_LVB_GRID_WORLDWIDE (0)",
            " #endif",
            " ",
            " // direct write to the console without further processing",
            " static bool term_write_console(term_t* term, const char* s, ssize_t n ) {",
            "   DWORD written;",
            "-  WriteConsoleA(term->hcon, s, (DWORD)(to_size_t(n)), &written, NULL);",
            "+  // WriteConsoleA(term->hcon, s, (DWORD)(to_size_t(n)), &written, NULL);",
            "+  WriteFile(term->hcon, s, (DWORD)(to_size_t(n)), &written, NULL); // so it can be redirected",
            "   return (written == (DWORD)(to_size_t(n)));",
            " }",
            " ",
            " static bool term_get_cursor_pos( term_t* term, ssize_t* row, ssize_t* col) {",
            "   *row = 0;",
            "   *col = 0;",
            "   CONSOLE_SCREEN_BUFFER_INFO info;",
            "@@ -980,15 +983,18 @@",
            "     term->raw_enabled = 0;",
            "   }",
            " }",
            " ",
            " static bool term_esc_query_color_raw(term_t* term, int color_idx, uint32_t* color ) {",
            "   char buf[128+1];",
            "   snprintf(buf,128,\"\\x1B]4;%d;?\\x1B\\\\\", color_idx);",
            "-  if (!term_esc_query_raw( term, buf, buf, 128 )) return false;",
            "+  if (!term_esc_query_raw( term, buf, buf, 128 )) {",
            "+    debug_msg(\"esc query response not received\\n\");",
            "+    return false;",
            "+  }",
            "   if (buf[0] != '4') return false;",
            "   const char* rgb = strchr(buf,':');",
            "   if (rgb==NULL) return false;",
            "   rgb++; // skip ':'",
            "   unsigned int r,g,b;",
            "   if (sscanf(rgb,\"%x/%x/%x\",&r,&g,&b) != 3) return false;",
            "   if (rgb[2]!='/') { // 48-bit rgb, hexadecimal round to 24-bit     ",
            "@@ -999,14 +1005,15 @@",
            "   *color = (ic_cap8(r)<<16) | (ic_cap8(g)<<8) | ic_cap8(b);",
            "   debug_msg(\"color query: %02x,%02x,%02x: %06x\\n\", r, g, b, *color);  ",
            "   return true;",
            " }",
            " ",
            " // update ansi 16 color palette for better color approximation",
            " static void term_update_ansi16(term_t* term) {",
            "+  debug_msg(\"update ansi colors\\n\");",
            "   #if defined(GIO_CMAP)",
            "   // try ioctl first (on Linux)",
            "   uint8_t cmap[48];",
            "   memset(cmap,0,48);",
            "   if (ioctl(term->fd_out,GIO_CMAP,&cmap) >= 0) {",
            "     // success",
            "     for(ssize_t i = 0; i < 48; i+=3) {",
            "@@ -1016,23 +1023,27 @@",
            "     }",
            "     return;",
            "   }",
            "   else {",
            "     debug_msg(\"ioctl GIO_CMAP failed: entry 1: 0x%02x%02x%02x\\n\", cmap[3], cmap[4], cmap[5]);",
            "   }",
            "   #endif",
            "+  // this seems to be unreliable on some systems (Ubuntu+Gnome terminal) so only enable when known ok.",
            "+  #if __APPLE__",
            "   // otherwise use OSC 4 escape sequence query",
            "-  tty_start_raw(term->tty);",
            "-  for(ssize_t i = 0; i < 16; i++) {",
            "-    uint32_t color;",
            "-    if (!term_esc_query_color_raw(term, i, &color)) break;",
            "-    debug_msg(\"term ansi color %d: 0x%06x\\n\", i, color);",
            "-    ansi256[i] = color;",
            "-  }  ",
            "-  tty_end_raw(term->tty);  ",
            "+  if (tty_start_raw(term->tty)) {",
            "+    for(ssize_t i = 0; i < 16; i++) {",
            "+      uint32_t color;",
            "+      if (!term_esc_query_color_raw(term, i, &color)) break;",
            "+      debug_msg(\"term ansi color %d: 0x%06x\\n\", i, color);",
            "+      ansi256[i] = color;",
            "+    }  ",
            "+    tty_end_raw(term->tty);  ",
            "+  }",
            "+  #endif",
            " }",
            " ",
            " static void term_init_raw(term_t* term) {",
            "   if (term->palette < ANSIRGB) {",
            "     term_update_ansi16(term);",
            "   }",
            " }",
            "@@ -1045,15 +1056,15 @@",
            "   if (GetConsoleScreenBufferInfo(term->hcon, &info)) {",
            "     term->hcon_orig_attr = info.wAttributes;",
            "   }",
            "   term->hcon_orig_cp = GetConsoleOutputCP();",
            "   SetConsoleOutputCP(CP_UTF8);",
            "   if (term->hcon_mode == 0) {",
            "     // first time initialization",
            "-    DWORD mode = ENABLE_PROCESSED_OUTPUT | ENABLE_LVB_GRID_WORLDWIDE;   // for \\r \\n and \\b    ",
            "+    DWORD mode = ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | ENABLE_LVB_GRID_WORLDWIDE;   // for \\r \\n and \\b    ",
            "     // use escape sequence handling if available and the terminal supports it (so we can use rgb colors in Windows terminal)",
            "     // Unfortunately, in plain powershell, we can successfully enable terminal processing",
            "     // but it still fails to render correctly; so we require the palette be large enough (like in Windows Terminal)",
            "     if (term->palette >= ANSI256 && SetConsoleMode(term->hcon, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) {",
            "       term->hcon_mode = mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING;",
            "       debug_msg(\"term: console mode: virtual terminal processing enabled\\n\");",
            "     }"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/tty.c",
          "change": [
            "--- /home/isocline-1.0.1/src/tty.c",
            "+++ /home/isocline-1.0.9/src/tty.c",
            "@@ -232,15 +232,18 @@",
            " //-------------------------------------------------------------",
            " ",
            " ic_private bool tty_read_esc_response(tty_t* tty, char esc_start, bool final_st, char* buf, ssize_t buflen ) ",
            " {",
            "   buf[0] = 0;",
            "   ssize_t len = 0;",
            "   uint8_t c = 0;",
            "-  if (!tty_readc_noblock(tty, &c, tty->esc_initial_timeout) || c != '\\x1B') return false;",
            "+  if (!tty_readc_noblock(tty, &c, 2*tty->esc_initial_timeout) || c != '\\x1B') {",
            "+    debug_msg(\"initial esc response failed: 0x%02x\\n\", c);",
            "+    return false;",
            "+  }",
            "   if (!tty_readc_noblock(tty, &c, tty->esc_timeout) || (c != esc_start)) return false;",
            "   while( len < buflen ) {",
            "     if (!tty_readc_noblock(tty, &c, tty->esc_timeout)) return false;",
            "     if (final_st) {",
            "       // OSC is terminated by BELL, or ESC \\ (ST)  (and STX)",
            "       if (c=='\\x07' || c=='\\x02') {",
            "         break;",
            "@@ -640,21 +643,23 @@",
            " static void signals_restore(void) {",
            "   // nothing",
            " }",
            " ",
            " #endif",
            " ",
            " ic_private bool tty_start_raw(tty_t* tty) {",
            "+  if (tty == NULL) return false;",
            "   if (tty->raw_enabled) return true;",
            "   if (tcsetattr(tty->fd_in,TCSAFLUSH,&tty->raw_ios) < 0) return false;  ",
            "   tty->raw_enabled = true;",
            "   return true;",
            " }",
            " ",
            " ic_private void tty_end_raw(tty_t* tty) {",
            "+  if (tty == NULL) return;",
            "   if (!tty->raw_enabled) return;",
            "   tty->cpush_count = 0;",
            "   if (tcsetattr(tty->fd_in,TCSAFLUSH,&tty->orig_ios) < 0) return;",
            "   tty->raw_enabled = false;",
            " }",
            " ",
            " static bool tty_init_raw(tty_t* tty)"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/src/tty_esc.c",
          "change": [
            "--- /home/isocline-1.0.1/src/tty_esc.c",
            "+++ /home/isocline-1.0.9/src/tty_esc.c",
            "@@ -334,14 +334,34 @@",
            " ",
            "   if (code == KEY_NONE && final != 'R') { ",
            "     debug_msg(\"tty: ignore escape sequence: ESC %c %zu;%zu %c\\n\", c1, num1, num2, final); ",
            "   }",
            "   return (code != KEY_NONE ? (code | modifiers) : KEY_NONE);",
            " }",
            " ",
            "+static code_t tty_read_osc( tty_t* tty, uint8_t* ppeek, long esc_timeout ) {",
            "+  debug_msg(\"discard OSC response..\\n\");",
            "+  // keep reading until termination: OSC is terminated by BELL, or ESC \\ (ST)  (and STX)",
            "+  while (true) {",
            "+    uint8_t c = *ppeek;",
            "+    if (c <= '\\x07') {  // BELL and anything below (STX, ^C, ^D)",
            "+      if (c != '\\x07') { tty_cpush_char( tty, c ); }",
            "+      break;",
            "+    }",
            "+    else if (c=='\\x1B') {",
            "+      uint8_t c1;",
            "+      if (!tty_readc_noblock(tty, &c1, esc_timeout)) break;",
            "+      if (c1=='\\\\') break;",
            "+      tty_cpush_char(tty,c1);",
            "+    }",
            "+    if (!tty_readc_noblock(tty, ppeek, esc_timeout)) break;",
            "+  }",
            "+  return KEY_NONE;",
            "+}",
            "+",
            " ic_private code_t tty_read_esc(tty_t* tty, long esc_initial_timeout, long esc_timeout) {",
            "   code_t  mods = 0;",
            "   uint8_t peek = 0;",
            "   ",
            "   // lone ESC?",
            "   if (!tty_readc_noblock(tty, &peek, esc_initial_timeout)) return KEY_ESC;",
            " ",
            "@@ -365,11 +385,17 @@",
            "       // ETerm uses this for ctrl+<cursor>",
            "       mods |= KEY_MOD_CTRL;",
            "     }",
            "     // treat all as standard SS3 'O'",
            "     return tty_read_csi(tty,'O',peek,mods, esc_timeout);  // ESC [Oo?] ...",
            "   }",
            " ",
            "+  // OSC: we may get a delayed query response; ensure it is ignored",
            "+  if (peek == ']') {",
            "+    if (!tty_readc_noblock(tty, &peek, esc_timeout)) goto alt;",
            "+    return tty_read_osc(tty, &peek, esc_timeout);  // ESC ] ...",
            "+  }",
            "+",
            " alt:  ",
            "   // Alt+<char>",
            "   return (key_unicode(peek) | KEY_MOD_ALT);  // ESC <anychar>",
            " }"
          ]
        },
        {
          "file": "/home/isocline-1.0.9/test/example.c",
          "change": [
            "--- /home/isocline-1.0.1/test/example.c",
            "+++ /home/isocline-1.0.9/test/example.c",
            "@@ -6,25 +6,28 @@",
            " ",
            "   Example use of the Isocline API.",
            " -----------------------------------------------------------------------------*/",
            " #include <assert.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "+#include <locale.h>",
            " #include \"isocline.h\"",
            " ",
            " // completion function defined below",
            " static void completer(ic_completion_env_t* cenv, const char* prefix );",
            " ",
            " // highlighter function defined below",
            " static void highlighter(ic_highlight_env_t* henv, const char* input, void* arg);",
            " ",
            " // main example",
            " int main() ",
            " {",
            "+  setlocale(LC_ALL,\"C.UTF-8\");  // we use utf-8 in this example",
            "+",
            "   // use `ic_print` functions to use bbcode's for markup",
            "   ic_style_def(\"kbd\",\"gray underline\");     // you can define your own styles",
            "   ic_style_def(\"ic-prompt\",\"ansi-maroon\");  // or re-define system styles",
            "   ",
            "   ic_printf( \"[b]Isocline[/b] sample program:\\n\"",
            "               \"- Type 'exit' to quit. (or use [kbd]ctrl-d[/]).\\n\"",
            "               \"- Press [kbd]F1[/] for help on editing commands.\\n\"",
            "@@ -104,15 +107,15 @@",
            " ",
            " // A completer function is called by isocline to complete. The input parameter is the input up to the cursor.",
            " // We use `ic_complete_word` to only consider the final token on the input. ",
            " // (almost all user defined completers should use this)",
            " static void completer(ic_completion_env_t* cenv, const char* input ) ",
            " {",
            "   // try to complete file names from the roots \".\" and \"/usr/local\"",
            "-  ic_complete_filename(cenv, input, 0, \"/usr/local;c:\\\\Program Files\" , NULL /* any extension */);",
            "+  ic_complete_filename(cenv, input, 0, \".;/usr/local;c:\\\\Program Files\" , NULL /* any extension */);",
            " ",
            "   // and also use our custom completer  ",
            "   ic_complete_word( cenv, input, &word_completer, NULL /* from default word boundary; whitespace or separator */ );        ",
            "   ",
            "   // ic_complete_word( cenv, input, &word_completer, &ic_char_is_idletter );        ",
            "   // ic_complete_qword( cenv, input, &word_completer, &ic_char_is_idletter  );        ",
            " }"
          ]
        }
      ]
    }
  }
}