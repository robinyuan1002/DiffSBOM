{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:b1c277fe-9b22-4e1d-a8ed-2172b6eaecfd",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T11:29:39-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "2b1a0f6d75016245",
      "type": "file",
      "name": "libgit2-1.9.1/"
    }
  },
  "components": [
    {
      "bom-ref": "5dd3d7c170992471",
      "type": "library",
      "name": "./source/.github/actions/download-or-build-container",
      "version": "UNKNOWN",
      "cpe": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build-container:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build-container:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build_container:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build_container:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/experimental.yml"
        }
      ]
    },
    {
      "bom-ref": "b722221800bf27a0",
      "type": "library",
      "name": "./source/.github/actions/download-or-build-container",
      "version": "UNKNOWN",
      "cpe": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build-container:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build-container:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build_container:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build_container:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/main.yml"
        }
      ]
    },
    {
      "bom-ref": "e90a2cf99aef3a6a",
      "type": "library",
      "name": "./source/.github/actions/download-or-build-container",
      "version": "UNKNOWN",
      "cpe": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build-container:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build-container:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build_container:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build_container:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or-build:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or_build:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download-or:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download_or:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download:.\\/source\\/.github\\/actions\\/download-or-build-container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/download:.\\/source\\/.github\\/actions\\/download_or_build_container:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "00a062bfb35aec95",
      "type": "library",
      "name": "./source/.github/actions/run-build",
      "version": "UNKNOWN",
      "cpe": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run-build:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run-build:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run_build:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run_build:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/experimental.yml"
        }
      ]
    },
    {
      "bom-ref": "6b02d6b229e5c034",
      "type": "library",
      "name": "./source/.github/actions/run-build",
      "version": "UNKNOWN",
      "cpe": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run-build:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run-build:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run_build:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run_build:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/main.yml"
        }
      ]
    },
    {
      "bom-ref": "29bae3d6d82bacf2",
      "type": "library",
      "name": "./source/.github/actions/run-build",
      "version": "UNKNOWN",
      "cpe": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run-build:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run-build:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run_build:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run_build:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run:.\\/source\\/.github\\/actions\\/run-build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:.\\/source\\/.github\\/actions\\/run:.\\/source\\/.github\\/actions\\/run_build:*:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=0210012ae660b0ca",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/benchmark.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=b6937dbada06e770",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/build-containers.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=e06d62cee2adf055",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/documentation.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=388c044727cebad3",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/experimental.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=660c6bac699c1b2f",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/main.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=4781208eff77c4da",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/download-artifact@v4?package-id=456fc02c6e7921d3",
      "type": "library",
      "name": "actions/download-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/download-artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/download-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download-artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/benchmark.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/download-artifact@v4?package-id=c06d6b8945c32060",
      "type": "library",
      "name": "actions/download-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/download-artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/download-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download-artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/experimental.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/download-artifact@v4?package-id=3bf70709476d80de",
      "type": "library",
      "name": "actions/download-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/download-artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/download-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download-artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/main.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/download-artifact@v4?package-id=8f483baeff15f26b",
      "type": "library",
      "name": "actions/download-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/download-artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/download-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download-artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-artifact@v4?package-id=8f8ff2a27beb6ed0",
      "type": "library",
      "name": "actions/upload-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/benchmark.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-artifact@v4?package-id=527162e7331248b4",
      "type": "library",
      "name": "actions/upload-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/experimental.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-artifact@v4?package-id=328fd369fa06d713",
      "type": "library",
      "name": "actions/upload-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/main.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-artifact@v4?package-id=8944c2ac26f48fd2",
      "type": "library",
      "name": "actions/upload-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/argparse@2.0.1?package-id=1071130b8a872c1f",
      "type": "library",
      "name": "argparse",
      "version": "2.0.1",
      "cpe": "cpe:2.3:a:argparse:argparse:2.0.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/argparse@2.0.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/commander@12.1.0?package-id=a4c524e2ccf78819",
      "type": "library",
      "name": "commander",
      "version": "12.1.0",
      "cpe": "cpe:2.3:a:commander:commander:12.1.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/commander@12.1.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/entities@4.5.0?package-id=390900216bf6759c",
      "type": "library",
      "name": "entities",
      "version": "4.5.0",
      "cpe": "cpe:2.3:a:entities:entities:4.5.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/entities@4.5.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/github/codeql-action@v2?package-id=89385b793175cd2f#analyze",
      "type": "library",
      "name": "github/codeql-action/analyze",
      "version": "v2",
      "cpe": "cpe:2.3:a:github\\/codeql-action\\/analyze:github\\/codeql-action\\/analyze:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/github/codeql-action@v2#analyze",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql-action\\/analyze:github\\/codeql_action\\/analyze:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/analyze:github\\/codeql-action\\/analyze:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/analyze:github\\/codeql_action\\/analyze:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql-action\\/analyze:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql_action\\/analyze:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/github/codeql-action@v3?package-id=f2453f44d0afd71e#init",
      "type": "library",
      "name": "github/codeql-action/init",
      "version": "v3",
      "cpe": "cpe:2.3:a:github\\/codeql-action\\/init:github\\/codeql-action\\/init:v3:*:*:*:*:*:*:*",
      "purl": "pkg:github/github/codeql-action@v3#init",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql-action\\/init:github\\/codeql_action\\/init:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/init:github\\/codeql-action\\/init:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/init:github\\/codeql_action\\/init:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql-action\\/init:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql_action\\/init:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/linkify-it@5.0.0?package-id=5ed917d41028ad1b",
      "type": "library",
      "name": "linkify-it",
      "version": "5.0.0",
      "cpe": "cpe:2.3:a:linkify-it:linkify-it:5.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/linkify-it@5.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:linkify-it:linkify_it:5.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:linkify_it:linkify-it:5.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:linkify_it:linkify_it:5.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:linkify:linkify-it:5.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:linkify:linkify_it:5.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/markdown-it@14.1.0?package-id=3ccdadf492e68be2",
      "type": "library",
      "name": "markdown-it",
      "version": "14.1.0",
      "cpe": "cpe:2.3:a:markdown-it_project:markdown-it:14.1.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/markdown-it@14.1.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/mdurl@2.0.0?package-id=476a4d42f2cd94d1",
      "type": "library",
      "name": "mdurl",
      "version": "2.0.0",
      "cpe": "cpe:2.3:a:mdurl:mdurl:2.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/mdurl@2.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/minisearch@7.1.1?package-id=cc7e638669a2596e",
      "type": "library",
      "name": "minisearch",
      "version": "7.1.1",
      "cpe": "cpe:2.3:a:minisearch:minisearch:7.1.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/minisearch@7.1.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/punycode.js@2.3.1?package-id=09424c35fba535c6",
      "type": "library",
      "name": "punycode.js",
      "version": "2.3.1",
      "cpe": "cpe:2.3:a:punycode.js:punycode.js:2.3.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/punycode.js@2.3.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/test-summary/action@v2?package-id=80dfead4a0be2f3a",
      "type": "library",
      "name": "test-summary/action",
      "version": "v2",
      "cpe": "cpe:2.3:a:test-summary\\/action:test-summary\\/action:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/test-summary/action@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test-summary\\/action:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test_summary\\/action:test-summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test_summary\\/action:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test:test-summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/experimental.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/test-summary/action@v2?package-id=a359493be4862757",
      "type": "library",
      "name": "test-summary/action",
      "version": "v2",
      "cpe": "cpe:2.3:a:test-summary\\/action:test-summary\\/action:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/test-summary/action@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test-summary\\/action:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test_summary\\/action:test-summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test_summary\\/action:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test:test-summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/main.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/test-summary/action@v2?package-id=13b9e8fcf0c53a19",
      "type": "library",
      "name": "test-summary/action",
      "version": "v2",
      "cpe": "cpe:2.3:a:test-summary\\/action:test-summary\\/action:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/test-summary/action@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test-summary\\/action:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test_summary\\/action:test-summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test_summary\\/action:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test:test-summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:test:test_summary\\/action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/nightly.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/uc.micro@2.1.0?package-id=147378892c4b8d8f",
      "type": "library",
      "name": "uc.micro",
      "version": "2.1.0",
      "cpe": "cpe:2.3:a:uc.micro:uc.micro:2.1.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/uc.micro@2.1.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-npm-package-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/script/api-docs/package-lock.json"
        }
      ]
    },
    {
      "bom-ref": "c59585e498acb0a3",
      "type": "file",
      "name": "/home/libgit2-1.9.1/.github/workflows/benchmark.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "e75c5fbadac265fab3ee66e9f4488fd36c5b5e90"
        },
        {
          "alg": "SHA-256",
          "content": "147a93858b4c07762d32d0a230ec9036851c03775bf4c4c614154e85951961ac"
        }
      ]
    },
    {
      "bom-ref": "01019f784f58677e",
      "type": "file",
      "name": "/home/libgit2-1.9.1/.github/workflows/build-containers.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "c83166b9150130135702a893ac3e4273c1a70399"
        },
        {
          "alg": "SHA-256",
          "content": "d058546af1302728cdeaeb017d677bba0e9a699e4bce3be28f6986ce6ed45bd8"
        }
      ]
    },
    {
      "bom-ref": "aa1c2dd15a5fd5a9",
      "type": "file",
      "name": "/home/libgit2-1.9.1/.github/workflows/documentation.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "a44c8da66ad3e1b5a7e6d607a440dd0f68907fff"
        },
        {
          "alg": "SHA-256",
          "content": "44a6b5e470b4ac61fe3af8a952b3d4c23edd41bd936b63b524608c57c18d0766"
        }
      ]
    },
    {
      "bom-ref": "d572d56df29ed651",
      "type": "file",
      "name": "/home/libgit2-1.9.1/.github/workflows/experimental.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "2ecb24465a41326131a41a8c5b46bb7ecb884260"
        },
        {
          "alg": "SHA-256",
          "content": "72962ba0e85b928c0266ae28b56a725f37681bdfcb9d56536a7fb2400b66e9f3"
        }
      ]
    },
    {
      "bom-ref": "61fea7a21173e897",
      "type": "file",
      "name": "/home/libgit2-1.9.1/.github/workflows/main.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "d1748546221ea59e3331e937f233585d81753eb7"
        },
        {
          "alg": "SHA-256",
          "content": "3270fc90080bb5524d60c74bcb20653ea27ad1c78227f62f69c821200614c16b"
        }
      ]
    },
    {
      "bom-ref": "fc7da195365e54f0",
      "type": "file",
      "name": "/home/libgit2-1.9.1/.github/workflows/nightly.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "3f41c85dafd506b6058e9eaf49f7d22f37a67049"
        },
        {
          "alg": "SHA-256",
          "content": "48cce8b1905edd8bd52deeff03d82c897885c3b8d5e87face4d8c96ca8b694b4"
        }
      ]
    },
    {
      "bom-ref": "684b7704f64fd223",
      "type": "file",
      "name": "/home/libgit2-1.9.1/script/api-docs/package-lock.json",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "0aef869a0bc0ca430f48f1209891969b29d64bd9"
        },
        {
          "alg": "SHA-256",
          "content": "6e50e118eef2d19ebd0cb1086948701d46795f6360dbbd2aa10a6fc1145e1e11"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/libgit2-1.8.2-rc1",
      "New file": [
        "/home/libgit2-1.9.1/src/cli/cmd_blame.c",
        "/home/libgit2-1.9.1/src/cli/cmd_init.c",
        "/home/libgit2-1.9.1/src/libgit2/hashmap_oid.h",
        "/home/libgit2-1.9.1/src/libgit2/index_map.c",
        "/home/libgit2-1.9.1/src/libgit2/index_map.h",
        "/home/libgit2-1.9.1/src/util/hashmap.h",
        "/home/libgit2-1.9.1/src/util/hashmap_str.h",
        "/home/libgit2-1.9.1/tests/libgit2/core/version.c",
        "/home/libgit2-1.9.1/tests/libgit2/diff/header.c",
        "/home/libgit2-1.9.1/tests/libgit2/network/remote/tag.c",
        "/home/libgit2-1.9.1/tests/util/hashmap.c"
      ],
      "Deleted file": [
        "/home/libgit2-1.8.2-rc1/include/git2/sys/reflog.h",
        "/home/libgit2-1.8.2-rc1/src/libgit2/idxmap.c",
        "/home/libgit2-1.8.2-rc1/src/libgit2/idxmap.h",
        "/home/libgit2-1.8.2-rc1/src/libgit2/offmap.c",
        "/home/libgit2-1.8.2-rc1/src/libgit2/offmap.h",
        "/home/libgit2-1.8.2-rc1/src/libgit2/oidmap.c",
        "/home/libgit2-1.8.2-rc1/src/libgit2/oidmap.h",
        "/home/libgit2-1.8.2-rc1/src/util/khash.h",
        "/home/libgit2-1.8.2-rc1/src/util/strmap.c",
        "/home/libgit2-1.8.2-rc1/src/util/strmap.h",
        "/home/libgit2-1.8.2-rc1/tests/libgit2/core/oidmap.c",
        "/home/libgit2-1.8.2-rc1/tests/util/strmap.c"
      ],
      "Modified file": [
        {
          "file": "/home/libgit2-1.9.1/deps/llhttp/api.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/llhttp/api.c",
            "+++ /home/libgit2-1.9.1/deps/llhttp/api.c",
            "@@ -89,15 +89,15 @@",
            "   return parser;",
            " }",
            " ",
            " void llhttp_free(llhttp_t* parser) {",
            "   free(parser);",
            " }",
            " ",
            "-#endif  // defined(__wasm__)",
            "+#endif  /* defined(__wasm__) */",
            " ",
            " /* Some getters required to get stuff from the parser */",
            " ",
            " uint8_t llhttp_get_type(llhttp_t* parser) {",
            "   return parser->type;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/ntlmclient/crypt_openssl.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/ntlmclient/crypt_openssl.c",
            "+++ /home/libgit2-1.9.1/deps/ntlmclient/crypt_openssl.c",
            "@@ -22,37 +22,37 @@",
            " #include \"ntlm.h\"",
            " #include \"compat.h\"",
            " #include \"util.h\"",
            " #include \"crypt.h\"",
            " ",
            " #if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(CRYPT_OPENSSL_DYNAMIC)",
            " ",
            "-static inline HMAC_CTX *HMAC_CTX_new(void)",
            "+NTLM_INLINE(HMAC_CTX *) HMAC_CTX_new(void)",
            " {",
            " \treturn calloc(1, sizeof(HMAC_CTX));",
            " }",
            " ",
            "-static inline int HMAC_CTX_reset(HMAC_CTX *ctx)",
            "+NTLM_INLINE(int) HMAC_CTX_reset(HMAC_CTX *ctx)",
            " {",
            " \tntlm_memzero(ctx, sizeof(HMAC_CTX));",
            " \treturn 1;",
            " }",
            " ",
            "-static inline void HMAC_CTX_free(HMAC_CTX *ctx)",
            "+NTLM_INLINE(void) HMAC_CTX_free(HMAC_CTX *ctx)",
            " {",
            " \tfree(ctx);",
            " }",
            " ",
            " #endif",
            " ",
            " #if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)) || \\",
            " \t(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x03050000fL) || \\",
            " \tdefined(CRYPT_OPENSSL_DYNAMIC)",
            " ",
            "-static inline void HMAC_CTX_cleanup(HMAC_CTX *ctx)",
            "+NTLM_INLINE(void) HMAC_CTX_cleanup(HMAC_CTX *ctx)",
            " {",
            " \tNTLM_UNUSED(ctx);",
            " }",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/ntlmclient/ntlm.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/ntlmclient/ntlm.c",
            "+++ /home/libgit2-1.9.1/deps/ntlmclient/ntlm.c",
            "@@ -39,15 +39,15 @@",
            " ",
            " static bool supports_unicode(ntlm_client *ntlm)",
            " {",
            " \treturn (ntlm->flags & NTLM_CLIENT_DISABLE_UNICODE) ?",
            " \t\tfalse : true;",
            " }",
            " ",
            "-static inline bool increment_size(size_t *out, size_t incr)",
            "+NTLM_INLINE(bool) increment_size(size_t *out, size_t incr)",
            " {",
            " \tif (SIZE_MAX - *out < incr) {",
            " \t\t*out = (size_t)-1;",
            " \t\treturn false;",
            " \t}",
            " ",
            " \t*out = *out + incr;",
            "@@ -268,15 +268,15 @@",
            " {",
            " \tNTLM_ASSERT_ARG(ntlm);",
            " ",
            " \tntlm->timestamp = timestamp;",
            " \treturn 0;",
            " }",
            " ",
            "-static inline bool write_buf(",
            "+NTLM_INLINE(bool) write_buf(",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *out,",
            " \tconst unsigned char *buf,",
            " \tsize_t len)",
            " {",
            " \tif (!len)",
            " \t\treturn true;",
            "@@ -287,44 +287,44 @@",
            " \t}",
            " ",
            " \tmemcpy(&out->buf[out->pos], buf, len);",
            " \tout->pos += len;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool write_byte(",
            "+NTLM_INLINE(bool) write_byte(",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *out,",
            " \tuint8_t value)",
            " {",
            " \tif (out->len - out->pos < 1) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"out of buffer space\");",
            " \t\treturn false;",
            " \t}",
            " ",
            " \tout->buf[out->pos++] = value;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool write_int16(",
            "+NTLM_INLINE(bool) write_int16(",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *out,",
            " \tuint16_t value)",
            " {",
            " \tif (out->len - out->pos < 2) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"out of buffer space\");",
            " \t\treturn false;",
            " \t}",
            " ",
            " \tout->buf[out->pos++] = (value & 0x000000ff);",
            " \tout->buf[out->pos++] = (value & 0x0000ff00) >> 8;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool write_int32(",
            "+NTLM_INLINE(bool) write_int32(",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *out,",
            " \tuint32_t value)",
            " {",
            " \tif (out->len - out->pos < 2) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"out of buffer space\");",
            " \t\treturn false;",
            "@@ -333,26 +333,26 @@",
            " \tout->buf[out->pos++] = (value & 0x000000ff);",
            " \tout->buf[out->pos++] = (value & 0x0000ff00) >> 8;",
            " \tout->buf[out->pos++] = (value & 0x00ff0000) >> 16;",
            " \tout->buf[out->pos++] = (value & 0xff000000) >> 24;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool write_version(",
            "+NTLM_INLINE(bool) write_version(",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *out,",
            " \tntlm_version *version)",
            " {",
            " \treturn write_byte(ntlm, out, version->major) &&",
            " \t\twrite_byte(ntlm, out, version->minor) &&",
            " \t\twrite_int16(ntlm, out, version->build) &&",
            " \t\twrite_int32(ntlm, out, version->reserved);",
            " }",
            " ",
            "-static inline bool write_bufinfo(",
            "+NTLM_INLINE(bool) write_bufinfo(",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *out,",
            " \tsize_t len,",
            " \tsize_t offset)",
            " {",
            " \tif (len > UINT16_MAX) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"invalid string, too long\");",
            "@@ -365,15 +365,15 @@",
            " \t}",
            " ",
            " \treturn write_int16(ntlm, out, (uint16_t)len) &&",
            " \t\twrite_int16(ntlm, out, (uint16_t)len) &&",
            " \t\twrite_int32(ntlm, out, (uint32_t)offset);",
            " }",
            " ",
            "-static inline bool read_buf(",
            "+NTLM_INLINE(bool) read_buf(",
            " \tunsigned char *out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message,",
            " \tsize_t len)",
            " {",
            " \tif (message->len - message->pos < len) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"truncated message\");",
            "@@ -382,29 +382,29 @@",
            " ",
            " \tmemcpy(out, &message->buf[message->pos], len);",
            " \tmessage->pos += len;",
            " ",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool read_byte(",
            "+NTLM_INLINE(bool) read_byte(",
            " \tuint8_t *out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message)",
            " {",
            " \tif (message->len - message->pos < 1) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"truncated message\");",
            " \t\treturn false;",
            " \t}",
            " ",
            " \t*out = message->buf[message->pos++];",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool read_int16(",
            "+NTLM_INLINE(bool) read_int16(",
            " \tuint16_t *out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message)",
            " {",
            " \tif (message->len - message->pos < 2) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"truncated message\");",
            " \t\treturn false;",
            "@@ -414,15 +414,15 @@",
            " \t\t((message->buf[message->pos]   & 0xff)) |",
            " \t\t((message->buf[message->pos+1] & 0xff) << 8);",
            " ",
            " \tmessage->pos += 2;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool read_int32(",
            "+NTLM_INLINE(bool) read_int32(",
            " \tuint32_t *out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message)",
            " {",
            " \tif (message->len - message->pos < 4) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"truncated message\");",
            " \t\treturn false;",
            "@@ -434,15 +434,15 @@",
            " \t\t((message->buf[message->pos+2] & 0xff) << 16) |",
            " \t\t((message->buf[message->pos+3] & 0xff) << 24);",
            " ",
            " \tmessage->pos += 4;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool read_int64(",
            "+NTLM_INLINE(bool) read_int64(",
            " \tuint64_t *out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message)",
            " {",
            " \tif (message->len - message->pos < 8) {",
            " \t\tntlm_client_set_errmsg(ntlm, \"truncated message\");",
            " \t\treturn false;",
            "@@ -458,39 +458,39 @@",
            " \t\t((uint64_t)(message->buf[message->pos+6] & 0xff) << 48) |",
            " \t\t((uint64_t)(message->buf[message->pos+7] & 0xff) << 56);",
            " ",
            " \tmessage->pos += 8;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool read_version(",
            "+NTLM_INLINE(bool) read_version(",
            " \tntlm_version *out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message)",
            " {",
            " \treturn read_byte(&out->major, ntlm, message) &&",
            " \t\tread_byte(&out->minor, ntlm, message) &&",
            " \t\tread_int16(&out->build, ntlm, message) &&",
            " \t\tread_int32(&out->reserved, ntlm, message);",
            " }",
            " ",
            "-static inline bool read_bufinfo(",
            "+NTLM_INLINE(bool) read_bufinfo(",
            " \tuint16_t *out_len,",
            " \tuint32_t *out_offset,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message)",
            " {",
            " \tuint16_t allocated;",
            " ",
            " \treturn read_int16(out_len, ntlm, message) &&",
            " \t\tread_int16(&allocated, ntlm, message) &&",
            " \t\tread_int32(out_offset, ntlm, message);",
            " }",
            " ",
            "-static inline bool read_string_unicode(",
            "+NTLM_INLINE(bool) read_string_unicode(",
            " \tchar **out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message,",
            " \tuint8_t string_len)",
            " {",
            " \tsize_t out_len;",
            " \tint ret = ntlm_unicode_utf16_to_8(out,",
            "@@ -500,15 +500,15 @@",
            " \t\tstring_len);",
            " ",
            " \tmessage->pos += string_len;",
            " ",
            " \treturn ret;",
            " }",
            " ",
            "-static inline bool read_string_ascii(",
            "+NTLM_INLINE(bool) read_string_ascii(",
            " \tchar **out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message,",
            " \tuint8_t string_len)",
            " {",
            " \tchar *str;",
            " ",
            "@@ -522,28 +522,28 @@",
            " ",
            " \tmessage->pos += string_len;",
            " ",
            " \t*out = str;",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool read_string(",
            "+NTLM_INLINE(bool) read_string(",
            " \tchar **out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message,",
            " \tuint8_t string_len,",
            " \tbool unicode)",
            " {",
            " \tif (unicode)",
            " \t\treturn read_string_unicode(out, ntlm, message, string_len);",
            " \telse",
            " \t\treturn read_string_ascii(out, ntlm, message, string_len);",
            " }",
            " ",
            "-static inline bool read_target_info(",
            "+NTLM_INLINE(bool) read_target_info(",
            " \tchar **server_out,",
            " \tchar **domain_out,",
            " \tchar **server_dns_out,",
            " \tchar **domain_dns_out,",
            " \tntlm_client *ntlm,",
            " \tntlm_buf *message,",
            " \tbool unicode)",
            "@@ -961,15 +961,15 @@",
            " \t\t(*out)[i]   |= ((plaintext[i] & (0xff - mask)) >> i);",
            " \t\t(*out)[i+1] |= ((plaintext[i] & mask) << j);",
            " \t}",
            " ",
            " \tgenerate_odd_parity(out);",
            " }",
            " ",
            "-static inline bool generate_lm_hash(",
            "+NTLM_INLINE(bool) generate_lm_hash(",
            " \tntlm_des_block out[2],",
            " \tntlm_client *ntlm,",
            " \tconst char *password)",
            " {",
            " \t/* LM encrypts this known plaintext using the password as a key */",
            " \tntlm_des_block plaintext = NTLM_LM_PLAINTEXT;",
            " \tntlm_des_block keystr1, keystr2;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/ntlmclient/unicode_builtin.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/ntlmclient/unicode_builtin.c",
            "+++ /home/libgit2-1.9.1/deps/ntlmclient/unicode_builtin.c",
            "@@ -8,14 +8,15 @@",
            " ",
            " #include <stdlib.h>",
            " #include <stdint.h>",
            " ",
            " #include \"ntlm.h\"",
            " #include \"unicode.h\"",
            " #include \"compat.h\"",
            "+#include \"util.h\"",
            " ",
            " typedef unsigned int    UTF32;   /* at least 32 bits */",
            " typedef unsigned short  UTF16;   /* at least 16 bits */",
            " typedef unsigned char   UTF8;    /* typically 8 bits */",
            " ",
            " /* Some fundamental constants */",
            " #define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD",
            "@@ -176,15 +177,15 @@",
            "  *  length = trailingBytesForUTF8[*source]+1;",
            "  * and the sequence is illegal right away if there aren't that many bytes",
            "  * available.",
            "  * If presented with a length > 4, this returns false.  The Unicode",
            "  * definition of UTF-8 goes up to 4-byte sequences.",
            "  */",
            " ",
            "-static inline bool isLegalUTF8(const UTF8 *source, int length) {",
            "+NTLM_INLINE(bool) isLegalUTF8(const UTF8 *source, int length) {",
            "     UTF8 a;",
            "     const UTF8 *srcptr = source+length;",
            "     switch (length) {",
            "     default: return false;",
            "         /* Everything else falls through when \"true\"... */",
            "     case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;",
            "     case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;",
            "@@ -284,15 +285,15 @@",
            " }",
            " ",
            " typedef enum {",
            " \tunicode_builtin_utf8_to_16,",
            " \tunicode_builtin_utf16_to_8",
            " } unicode_builtin_encoding_direction;",
            " ",
            "-static inline bool unicode_builtin_encoding_convert(",
            "+NTLM_INLINE(bool) unicode_builtin_encoding_convert(",
            " \tchar **converted,",
            " \tsize_t *converted_len,",
            " \tntlm_client *ntlm,",
            " \tconst char *string,",
            " \tsize_t string_len,",
            " \tunicode_builtin_encoding_direction direction)",
            " {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/ntlmclient/unicode_iconv.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/ntlmclient/unicode_iconv.c",
            "+++ /home/libgit2-1.9.1/deps/ntlmclient/unicode_iconv.c",
            "@@ -10,14 +10,15 @@",
            " #include <iconv.h>",
            " #include <string.h>",
            " #include <errno.h>",
            " ",
            " #include \"ntlmclient.h\"",
            " #include \"unicode.h\"",
            " #include \"ntlm.h\"",
            "+#include \"util.h\"",
            " #include \"compat.h\"",
            " ",
            " typedef enum {",
            " \tunicode_iconv_utf8_to_16,",
            " \tunicode_iconv_utf16_to_8",
            " } unicode_iconv_encoding_direction;",
            " ",
            "@@ -36,15 +37,15 @@",
            " ",
            " \t\treturn false;",
            " \t}",
            " ",
            " \treturn true;",
            " }",
            " ",
            "-static inline bool unicode_iconv_encoding_convert(",
            "+NTLM_INLINE(bool) unicode_iconv_encoding_convert(",
            " \tchar **converted,",
            " \tsize_t *converted_len,",
            " \tntlm_client *ntlm,",
            " \tconst char *string,",
            " \tsize_t string_len,",
            " \tunicode_iconv_encoding_direction direction)",
            " {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/ntlmclient/utf8.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/ntlmclient/utf8.h",
            "+++ /home/libgit2-1.9.1/deps/ntlmclient/utf8.h",
            "@@ -1,1257 +1,1712 @@",
            "-// The latest version of this library is available on GitHub;",
            "-// https://github.com/sheredom/utf8.h",
            "+/* The latest version of this library is available on GitHub;",
            "+ * https://github.com/sheredom/utf8.h */",
            " ",
            "-// This is free and unencumbered software released into the public domain.",
            "-//",
            "-// Anyone is free to copy, modify, publish, use, compile, sell, or",
            "-// distribute this software, either in source code form or as a compiled",
            "-// binary, for any purpose, commercial or non-commercial, and by any",
            "-// means.",
            "-//",
            "-// In jurisdictions that recognize copyright laws, the author or authors",
            "-// of this software dedicate any and all copyright interest in the",
            "-// software to the public domain. We make this dedication for the benefit",
            "-// of the public at large and to the detriment of our heirs and",
            "-// successors. We intend this dedication to be an overt act of",
            "-// relinquishment in perpetuity of all present and future rights to this",
            "-// software under copyright law.",
            "-//",
            "-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
            "-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
            "-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.",
            "-// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR",
            "-// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,",
            "-// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR",
            "-// OTHER DEALINGS IN THE SOFTWARE.",
            "-//",
            "-// For more information, please refer to <http://unlicense.org/>",
            "+/* This is free and unencumbered software released into the public domain.",
            "+ *",
            "+ * Anyone is free to copy, modify, publish, use, compile, sell, or",
            "+ * distribute this software, either in source code form or as a compiled",
            "+ * binary, for any purpose, commercial or non-commercial, and by any",
            "+ * means.",
            "+ *",
            "+ * In jurisdictions that recognize copyright laws, the author or authors",
            "+ * of this software dedicate any and all copyright interest in the",
            "+ * software to the public domain. We make this dedication for the benefit",
            "+ * of the public at large and to the detriment of our heirs and",
            "+ * successors. We intend this dedication to be an overt act of",
            "+ * relinquishment in perpetuity of all present and future rights to this",
            "+ * software under copyright law.",
            "+ *",
            "+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
            "+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
            "+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.",
            "+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR",
            "+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,",
            "+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR",
            "+ * OTHER DEALINGS IN THE SOFTWARE.",
            "+ *",
            "+ * For more information, please refer to <http://unlicense.org/> */",
            " ",
            " #ifndef SHEREDOM_UTF8_H_INCLUDED",
            " #define SHEREDOM_UTF8_H_INCLUDED",
            " ",
            " #if defined(_MSC_VER)",
            " #pragma warning(push)",
            " ",
            "-// disable 'bytes padding added after construct' warning",
            "+/* disable warning: no function prototype given: converting '()' to '(void)' */",
            "+#pragma warning(disable : 4255)",
            "+",
            "+/* disable warning: '__cplusplus' is not defined as a preprocessor macro,",
            "+ * replacing with '0' for '#if/#elif' */",
            "+#pragma warning(disable : 4668)",
            "+",
            "+/* disable warning: bytes padding added after construct */",
            " #pragma warning(disable : 4820)",
            " #endif",
            " ",
            "+#if defined(__cplusplus)",
            "+#if defined(_MSC_VER)",
            "+#define utf8_cplusplus _MSVC_LANG",
            "+#else",
            "+#define utf8_cplusplus __cplusplus",
            "+#endif",
            "+#endif",
            "+",
            " #include <stddef.h>",
            " #include <stdlib.h>",
            " ",
            " #if defined(_MSC_VER)",
            " #pragma warning(pop)",
            " #endif",
            " ",
            "-#if defined(_MSC_VER)",
            "+#if defined(_MSC_VER) && (_MSC_VER < 1920)",
            " typedef __int32 utf8_int32_t;",
            " #else",
            " #include <stdint.h>",
            " typedef int32_t utf8_int32_t;",
            " #endif",
            " ",
            " #if defined(__clang__)",
            " #pragma clang diagnostic push",
            " #pragma clang diagnostic ignored \"-Wold-style-cast\"",
            " #pragma clang diagnostic ignored \"-Wcast-qual\"",
            "+",
            "+#if __has_warning(\"-Wunsafe-buffer-usage\")",
            "+#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"",
            "+#endif",
            " #endif",
            " ",
            "-#ifdef __cplusplus",
            "+#ifdef utf8_cplusplus",
            " extern \"C\" {",
            " #endif",
            " ",
            "-#if defined(__clang__) || defined(__GNUC__)",
            "-#define utf8_nonnull __attribute__((nonnull))",
            "-#define utf8_pure __attribute__((pure))",
            "-#define utf8_restrict __restrict__",
            "-#define utf8_weak __attribute__((weak))",
            "-#elif defined(_MSC_VER)",
            "+#if defined(__TINYC__)",
            "+#define UTF8_ATTRIBUTE(a) __attribute((a))",
            "+#else",
            "+#define UTF8_ATTRIBUTE(a) __attribute__((a))",
            "+#endif",
            "+",
            "+#if defined(_MSC_VER)",
            " #define utf8_nonnull",
            " #define utf8_pure",
            " #define utf8_restrict __restrict",
            " #define utf8_weak __inline",
            "+#elif defined(__clang__) || defined(__GNUC__)",
            "+#define utf8_nonnull UTF8_ATTRIBUTE(nonnull)",
            "+#define utf8_pure UTF8_ATTRIBUTE(pure)",
            "+#define utf8_restrict __restrict__",
            "+#define utf8_weak UTF8_ATTRIBUTE(weak)",
            "+#elif defined(__TINYC__)",
            "+#define utf8_nonnull UTF8_ATTRIBUTE(nonnull)",
            "+#define utf8_pure UTF8_ATTRIBUTE(pure)",
            "+#define utf8_restrict",
            "+#define utf8_weak UTF8_ATTRIBUTE(weak)",
            " #else",
            "-#error Non clang, non gcc, non MSVC compiler found!",
            "+#error Non clang, non gcc, non MSVC, non tcc compiler found!",
            " #endif",
            " ",
            "-#ifdef __cplusplus",
            "+#ifdef utf8_cplusplus",
            " #define utf8_null NULL",
            " #else",
            " #define utf8_null 0",
            " #endif",
            " ",
            "-// Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >",
            "-// src2 respectively, case insensitive.",
            "-utf8_nonnull utf8_pure utf8_weak int utf8casecmp(const void *src1,",
            "-                                                 const void *src2);",
            "-",
            "-// Append the utf8 string src onto the utf8 string dst.",
            "-utf8_nonnull utf8_weak void *utf8cat(void *utf8_restrict dst,",
            "-                                     const void *utf8_restrict src);",
            "-",
            "-// Find the first match of the utf8 codepoint chr in the utf8 string src.",
            "-utf8_nonnull utf8_pure utf8_weak void *utf8chr(const void *src,",
            "-                                               utf8_int32_t chr);",
            "-",
            "-// Return less than 0, 0, greater than 0 if src1 < src2,",
            "-// src1 == src2, src1 > src2 respectively.",
            "-utf8_nonnull utf8_pure utf8_weak int utf8cmp(const void *src1,",
            "-                                             const void *src2);",
            "-",
            "-// Copy the utf8 string src onto the memory allocated in dst.",
            "-utf8_nonnull utf8_weak void *utf8cpy(void *utf8_restrict dst,",
            "-                                     const void *utf8_restrict src);",
            "-",
            "-// Number of utf8 codepoints in the utf8 string src that consists entirely",
            "-// of utf8 codepoints not from the utf8 string reject.",
            "-utf8_nonnull utf8_pure utf8_weak size_t utf8cspn(const void *src,",
            "-                                                 const void *reject);",
            "-",
            "-// Duplicate the utf8 string src by getting its size, malloc'ing a new buffer",
            "-// copying over the data, and returning that. Or 0 if malloc failed.",
            "-utf8_nonnull utf8_weak void *utf8dup(const void *src);",
            "-",
            "-// Number of utf8 codepoints in the utf8 string str,",
            "-// excluding the null terminating byte.",
            "-utf8_nonnull utf8_pure utf8_weak size_t utf8len(const void *str);",
            "-",
            "-// Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >",
            "-// src2 respectively, case insensitive. Checking at most n bytes of each utf8",
            "-// string.",
            "-utf8_nonnull utf8_pure utf8_weak int utf8ncasecmp(const void *src1,",
            "-                                                  const void *src2, size_t n);",
            "-",
            "-// Append the utf8 string src onto the utf8 string dst,",
            "-// writing at most n+1 bytes. Can produce an invalid utf8",
            "-// string if n falls partway through a utf8 codepoint.",
            "-utf8_nonnull utf8_weak void *utf8ncat(void *utf8_restrict dst,",
            "-                                      const void *utf8_restrict src, size_t n);",
            "-",
            "-// Return less than 0, 0, greater than 0 if src1 < src2,",
            "-// src1 == src2, src1 > src2 respectively. Checking at most n",
            "-// bytes of each utf8 string.",
            "-utf8_nonnull utf8_pure utf8_weak int utf8ncmp(const void *src1,",
            "-                                              const void *src2, size_t n);",
            "-",
            "-// Copy the utf8 string src onto the memory allocated in dst.",
            "-// Copies at most n bytes. If there is no terminating null byte in",
            "-// the first n bytes of src, the string placed into dst will not be",
            "-// null-terminated. If the size (in bytes) of src is less than n,",
            "-// extra null terminating bytes are appended to dst such that at",
            "-// total of n bytes are written. Can produce an invalid utf8",
            "-// string if n falls partway through a utf8 codepoint.",
            "-utf8_nonnull utf8_weak void *utf8ncpy(void *utf8_restrict dst,",
            "-                                      const void *utf8_restrict src, size_t n);",
            "-",
            "-// Similar to utf8dup, except that at most n bytes of src are copied. If src is",
            "-// longer than n, only n bytes are copied and a null byte is added.",
            "-//",
            "-// Returns a new string if successful, 0 otherwise",
            "-utf8_nonnull utf8_weak void *utf8ndup(const void *src, size_t n);",
            "-",
            "-// Locates the first occurence in the utf8 string str of any byte in the",
            "-// utf8 string accept, or 0 if no match was found.",
            "-utf8_nonnull utf8_pure utf8_weak void *utf8pbrk(const void *str,",
            "-                                                const void *accept);",
            "-",
            "-// Find the last match of the utf8 codepoint chr in the utf8 string src.",
            "-utf8_nonnull utf8_pure utf8_weak void *utf8rchr(const void *src, int chr);",
            "-",
            "-// Number of bytes in the utf8 string str,",
            "-// including the null terminating byte.",
            "-utf8_nonnull utf8_pure utf8_weak size_t utf8size(const void *str);",
            "-",
            "-// Number of utf8 codepoints in the utf8 string src that consists entirely",
            "-// of utf8 codepoints from the utf8 string accept.",
            "-utf8_nonnull utf8_pure utf8_weak size_t utf8spn(const void *src,",
            "-                                                const void *accept);",
            "-",
            "-// The position of the utf8 string needle in the utf8 string haystack.",
            "-utf8_nonnull utf8_pure utf8_weak void *utf8str(const void *haystack,",
            "-                                               const void *needle);",
            "-",
            "-// The position of the utf8 string needle in the utf8 string haystack, case",
            "-// insensitive.",
            "-utf8_nonnull utf8_pure utf8_weak void *utf8casestr(const void *haystack,",
            "-                                                   const void *needle);",
            "-",
            "-// Return 0 on success, or the position of the invalid",
            "-// utf8 codepoint on failure.",
            "-utf8_nonnull utf8_pure utf8_weak void *utf8valid(const void *str);",
            "-",
            "-// Sets out_codepoint to the next utf8 codepoint in str, and returns the address",
            "-// of the utf8 codepoint after the current one in str.",
            "-utf8_nonnull utf8_weak void *",
            "-utf8codepoint(const void *utf8_restrict str,",
            "-              utf8_int32_t *utf8_restrict out_codepoint);",
            "-",
            "-// Returns the size of the given codepoint in bytes.",
            "-utf8_weak size_t utf8codepointsize(utf8_int32_t chr);",
            "-",
            "-// Write a codepoint to the given string, and return the address to the next",
            "-// place after the written codepoint. Pass how many bytes left in the buffer to",
            "-// n. If there is not enough space for the codepoint, this function returns",
            "-// null.",
            "-utf8_nonnull utf8_weak void *utf8catcodepoint(void *utf8_restrict str,",
            "-                                              utf8_int32_t chr, size_t n);",
            "-",
            "-// Returns 1 if the given character is lowercase, or 0 if it is not.",
            "-utf8_weak int utf8islower(utf8_int32_t chr);",
            "-",
            "-// Returns 1 if the given character is uppercase, or 0 if it is not.",
            "-utf8_weak int utf8isupper(utf8_int32_t chr);",
            "-",
            "-// Transform the given string into all lowercase codepoints.",
            "-utf8_nonnull utf8_weak void utf8lwr(void *utf8_restrict str);",
            "+#if defined(utf8_cplusplus) && utf8_cplusplus >= 201402L && (!defined(_MSC_VER) || (defined(_MSC_VER) && _MSC_VER >= 1910))",
            "+#define utf8_constexpr14 constexpr",
            "+#define utf8_constexpr14_impl constexpr",
            "+#else",
            "+/* constexpr and weak are incompatible. so only enable one of them */",
            "+#define utf8_constexpr14 utf8_weak",
            "+#define utf8_constexpr14_impl",
            "+#endif",
            " ",
            "-// Transform the given string into all uppercase codepoints.",
            "-utf8_nonnull utf8_weak void utf8upr(void *utf8_restrict str);",
            "+#if defined(utf8_cplusplus) && utf8_cplusplus >= 202002L",
            "+using utf8_int8_t = char8_t; /* Introduced in C++20 */",
            "+#else",
            "+typedef char utf8_int8_t;",
            "+#endif",
            " ",
            "-// Make a codepoint lower case if possible.",
            "-utf8_weak utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp);",
            "+/* Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >",
            "+ * src2 respectively, case insensitive. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure int",
            "+utf8casecmp(const utf8_int8_t *src1, const utf8_int8_t *src2);",
            "+",
            "+/* Append the utf8 string src onto the utf8 string dst. */",
            "+utf8_nonnull utf8_weak utf8_int8_t *",
            "+utf8cat(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src);",
            "+",
            "+/* Find the first match of the utf8 codepoint chr in the utf8 string src. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8chr(const utf8_int8_t *src, utf8_int32_t chr);",
            "+",
            "+/* Return less than 0, 0, greater than 0 if src1 < src2,",
            "+ * src1 == src2, src1 > src2 respectively. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure int utf8cmp(const utf8_int8_t *src1,",
            "+                                                    const utf8_int8_t *src2);",
            "+",
            "+/* Copy the utf8 string src onto the memory allocated in dst. */",
            "+utf8_nonnull utf8_weak utf8_int8_t *",
            "+utf8cpy(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src);",
            "+",
            "+/* Number of utf8 codepoints in the utf8 string src that consists entirely",
            "+ * of utf8 codepoints not from the utf8 string reject. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t",
            "+utf8cspn(const utf8_int8_t *src, const utf8_int8_t *reject);",
            "+",
            "+/* Duplicate the utf8 string src by getting its size, malloc'ing a new buffer",
            "+ * copying over the data, and returning that. Or 0 if malloc failed. */",
            "+utf8_weak utf8_int8_t *utf8dup(const utf8_int8_t *src);",
            "+",
            "+/* Number of utf8 codepoints in the utf8 string str,",
            "+ * excluding the null terminating byte. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t utf8len(const utf8_int8_t *str);",
            "+",
            "+/* Similar to utf8len, except that only at most n bytes of src are looked. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t utf8nlen(const utf8_int8_t *str,",
            "+                                                        size_t n);",
            "+",
            "+/* Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >",
            "+ * src2 respectively, case insensitive. Checking at most n bytes of each utf8",
            "+ * string. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure int",
            "+utf8ncasecmp(const utf8_int8_t *src1, const utf8_int8_t *src2, size_t n);",
            "+",
            "+/* Append the utf8 string src onto the utf8 string dst,",
            "+ * writing at most n+1 bytes. Can produce an invalid utf8",
            "+ * string if n falls partway through a utf8 codepoint. */",
            "+utf8_nonnull utf8_weak utf8_int8_t *",
            "+utf8ncat(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src,",
            "+         size_t n);",
            "+",
            "+/* Return less than 0, 0, greater than 0 if src1 < src2,",
            "+ * src1 == src2, src1 > src2 respectively. Checking at most n",
            "+ * bytes of each utf8 string. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure int",
            "+utf8ncmp(const utf8_int8_t *src1, const utf8_int8_t *src2, size_t n);",
            "+",
            "+/* Copy the utf8 string src onto the memory allocated in dst.",
            "+ * Copies at most n bytes. If n falls partway through a utf8",
            "+ * codepoint, or if dst doesn't have enough room for a null",
            "+ * terminator, the final string will be cut short to preserve",
            "+ * utf8 validity. */",
            "+",
            "+utf8_nonnull utf8_weak utf8_int8_t *",
            "+utf8ncpy(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src,",
            "+         size_t n);",
            "+",
            "+/* Similar to utf8dup, except that at most n bytes of src are copied. If src is",
            "+ * longer than n, only n bytes are copied and a null byte is added.",
            "+ *",
            "+ * Returns a new string if successful, 0 otherwise */",
            "+utf8_weak utf8_int8_t *utf8ndup(const utf8_int8_t *src, size_t n);",
            "+",
            "+/* Locates the first occurrence in the utf8 string str of any byte in the",
            "+ * utf8 string accept, or 0 if no match was found. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8pbrk(const utf8_int8_t *str, const utf8_int8_t *accept);",
            "+",
            "+/* Find the last match of the utf8 codepoint chr in the utf8 string src. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8rchr(const utf8_int8_t *src, int chr);",
            "+",
            "+/* Number of bytes in the utf8 string str,",
            "+ * including the null terminating byte. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t utf8size(const utf8_int8_t *str);",
            "+",
            "+/* Similar to utf8size, except that the null terminating byte is excluded. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t",
            "+utf8size_lazy(const utf8_int8_t *str);",
            "+",
            "+/* Similar to utf8size, except that only at most n bytes of src are looked and",
            "+ * the null terminating byte is excluded. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t",
            "+utf8nsize_lazy(const utf8_int8_t *str, size_t n);",
            "+",
            "+/* Number of utf8 codepoints in the utf8 string src that consists entirely",
            "+ * of utf8 codepoints from the utf8 string accept. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure size_t",
            "+utf8spn(const utf8_int8_t *src, const utf8_int8_t *accept);",
            "+",
            "+/* The position of the utf8 string needle in the utf8 string haystack. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8str(const utf8_int8_t *haystack, const utf8_int8_t *needle);",
            "+",
            "+/* The position of the utf8 string needle in the utf8 string haystack, case",
            "+ * insensitive. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8casestr(const utf8_int8_t *haystack, const utf8_int8_t *needle);",
            "+",
            "+/* Return 0 on success, or the position of the invalid",
            "+ * utf8 codepoint on failure. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8valid(const utf8_int8_t *str);",
            "+",
            "+/* Similar to utf8valid, except that only at most n bytes of src are looked. */",
            "+utf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *",
            "+utf8nvalid(const utf8_int8_t *str, size_t n);",
            "+",
            "+/* Given a null-terminated string, makes the string valid by replacing invalid",
            "+ * codepoints with a 1-byte replacement. Returns 0 on success. */",
            "+utf8_nonnull utf8_weak int utf8makevalid(utf8_int8_t *str,",
            "+                                         const utf8_int32_t replacement);",
            "+",
            "+/* Sets out_codepoint to the current utf8 codepoint in str, and returns the",
            "+ * address of the next utf8 codepoint after the current one in str. */",
            "+utf8_constexpr14 utf8_nonnull utf8_int8_t *",
            "+utf8codepoint(const utf8_int8_t *utf8_restrict str,",
            "+              utf8_int32_t *utf8_restrict out_codepoint);",
            " ",
            "-// Make a codepoint upper case if possible.",
            "-utf8_weak utf8_int32_t utf8uprcodepoint(utf8_int32_t cp);",
            "+/* Calculates the size of the next utf8 codepoint in str. */",
            "+utf8_constexpr14 utf8_nonnull size_t",
            "+utf8codepointcalcsize(const utf8_int8_t *str);",
            "+",
            "+/* Returns the size of the given codepoint in bytes. */",
            "+utf8_constexpr14 size_t utf8codepointsize(utf8_int32_t chr);",
            "+",
            "+/* Write a codepoint to the given string, and return the address to the next",
            "+ * place after the written codepoint. Pass how many bytes left in the buffer to",
            "+ * n. If there is not enough space for the codepoint, this function returns",
            "+ * null. */",
            "+utf8_nonnull utf8_weak utf8_int8_t *",
            "+utf8catcodepoint(utf8_int8_t *str, utf8_int32_t chr, size_t n);",
            "+",
            "+/* Returns 1 if the given character is lowercase, or 0 if it is not. */",
            "+utf8_constexpr14 int utf8islower(utf8_int32_t chr);",
            "+",
            "+/* Returns 1 if the given character is uppercase, or 0 if it is not. */",
            "+utf8_constexpr14 int utf8isupper(utf8_int32_t chr);",
            "+",
            "+/* Transform the given string into all lowercase codepoints. */",
            "+utf8_nonnull utf8_weak void utf8lwr(utf8_int8_t *utf8_restrict str);",
            "+",
            "+/* Transform the given string into all uppercase codepoints. */",
            "+utf8_nonnull utf8_weak void utf8upr(utf8_int8_t *utf8_restrict str);",
            "+",
            "+/* Make a codepoint lower case if possible. */",
            "+utf8_constexpr14 utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp);",
            "+",
            "+/* Make a codepoint upper case if possible. */",
            "+utf8_constexpr14 utf8_int32_t utf8uprcodepoint(utf8_int32_t cp);",
            "+",
            "+/* Sets out_codepoint to the current utf8 codepoint in str, and returns the",
            "+ * address of the previous utf8 codepoint before the current one in str. */",
            "+utf8_constexpr14 utf8_nonnull utf8_int8_t *",
            "+utf8rcodepoint(const utf8_int8_t *utf8_restrict str,",
            "+               utf8_int32_t *utf8_restrict out_codepoint);",
            "+",
            "+/* Duplicate the utf8 string src by getting its size, calling alloc_func_ptr to",
            "+ * copy over data to a new buffer, and returning that. Or 0 if alloc_func_ptr",
            "+ * returned null. */",
            "+utf8_weak utf8_int8_t *utf8dup_ex(const utf8_int8_t *src,",
            "+                                  utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *,",
            "+                                                                 size_t),",
            "+                                  utf8_int8_t *user_data);",
            "+",
            "+/* Similar to utf8dup, except that at most n bytes of src are copied. If src is",
            "+ * longer than n, only n bytes are copied and a null byte is added.",
            "+ *",
            "+ * Returns a new string if successful, 0 otherwise. */",
            "+utf8_weak utf8_int8_t *utf8ndup_ex(const utf8_int8_t *src, size_t n,",
            "+                                   utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *,",
            "+                                                                  size_t),",
            "+                                   utf8_int8_t *user_data);",
            " ",
            " #undef utf8_weak",
            " #undef utf8_pure",
            " #undef utf8_nonnull",
            " ",
            "-int utf8casecmp(const void *src1, const void *src2) {",
            "-  utf8_int32_t src1_cp, src2_cp, src1_orig_cp, src2_orig_cp;",
            "+utf8_constexpr14_impl int utf8casecmp(const utf8_int8_t *src1,",
            "+                                      const utf8_int8_t *src2) {",
            "+  utf8_int32_t src1_lwr_cp = 0, src2_lwr_cp = 0, src1_upr_cp = 0,",
            "+               src2_upr_cp = 0, src1_orig_cp = 0, src2_orig_cp = 0;",
            " ",
            "   for (;;) {",
            "-    src1 = utf8codepoint(src1, &src1_cp);",
            "-    src2 = utf8codepoint(src2, &src2_cp);",
            "+    src1 = utf8codepoint(src1, &src1_orig_cp);",
            "+    src2 = utf8codepoint(src2, &src2_orig_cp);",
            " ",
            "-    // Take a copy of src1 & src2",
            "-    src1_orig_cp = src1_cp;",
            "-    src2_orig_cp = src2_cp;",
            "-",
            "-    // Lower the srcs if required",
            "-    src1_cp = utf8lwrcodepoint(src1_cp);",
            "-    src2_cp = utf8lwrcodepoint(src2_cp);",
            "+    /* lower the srcs if required */",
            "+    src1_lwr_cp = utf8lwrcodepoint(src1_orig_cp);",
            "+    src2_lwr_cp = utf8lwrcodepoint(src2_orig_cp);",
            "+",
            "+    /* lower the srcs if required */",
            "+    src1_upr_cp = utf8uprcodepoint(src1_orig_cp);",
            "+    src2_upr_cp = utf8uprcodepoint(src2_orig_cp);",
            " ",
            "-    // Check if the lowered codepoints match",
            "+    /* check if the lowered codepoints match */",
            "     if ((0 == src1_orig_cp) && (0 == src2_orig_cp)) {",
            "       return 0;",
            "-    } else if (src1_cp == src2_cp) {",
            "+    } else if ((src1_lwr_cp == src2_lwr_cp) || (src1_upr_cp == src2_upr_cp)) {",
            "       continue;",
            "     }",
            " ",
            "-    // If they don't match, then we return which of the original's are less",
            "-    if (src1_orig_cp < src2_orig_cp) {",
            "-      return -1;",
            "-    } else if (src1_orig_cp > src2_orig_cp) {",
            "-      return 1;",
            "-    }",
            "+    /* if they don't match, then we return the difference between the characters",
            "+     */",
            "+    return src1_lwr_cp - src2_lwr_cp;",
            "   }",
            " }",
            " ",
            "-void *utf8cat(void *utf8_restrict dst, const void *utf8_restrict src) {",
            "-  char *d = (char *)dst;",
            "-  const char *s = (const char *)src;",
            "-",
            "-  // find the null terminating byte in dst",
            "+utf8_int8_t *utf8cat(utf8_int8_t *utf8_restrict dst,",
            "+                     const utf8_int8_t *utf8_restrict src) {",
            "+  utf8_int8_t *d = dst;",
            "+  /* find the null terminating byte in dst */",
            "   while ('\\0' != *d) {",
            "     d++;",
            "   }",
            " ",
            "-  // overwriting the null terminating byte in dst, append src byte-by-byte",
            "-  while ('\\0' != *s) {",
            "-    *d++ = *s++;",
            "+  /* overwriting the null terminating byte in dst, append src byte-by-byte */",
            "+  while ('\\0' != *src) {",
            "+    *d++ = *src++;",
            "   }",
            " ",
            "-  // write out a new null terminating byte into dst",
            "+  /* write out a new null terminating byte into dst */",
            "   *d = '\\0';",
            " ",
            "   return dst;",
            " }",
            " ",
            "-void *utf8chr(const void *src, utf8_int32_t chr) {",
            "-  char c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};",
            "+utf8_constexpr14_impl utf8_int8_t *utf8chr(const utf8_int8_t *src,",
            "+                                           utf8_int32_t chr) {",
            "+  utf8_int8_t c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};",
            " ",
            "   if (0 == chr) {",
            "-    // being asked to return position of null terminating byte, so",
            "-    // just run s to the end, and return!",
            "-    const char *s = (const char *)src;",
            "-    while ('\\0' != *s) {",
            "-      s++;",
            "+    /* being asked to return position of null terminating byte, so",
            "+     * just run s to the end, and return! */",
            "+    while ('\\0' != *src) {",
            "+      src++;",
            "     }",
            "-    return (void *)s;",
            "+    return (utf8_int8_t *)src;",
            "   } else if (0 == ((utf8_int32_t)0xffffff80 & chr)) {",
            "-    // 1-byte/7-bit ascii",
            "-    // (0b0xxxxxxx)",
            "-    c[0] = (char)chr;",
            "+    /* 1-byte/7-bit ascii",
            "+     * (0b0xxxxxxx) */",
            "+    c[0] = (utf8_int8_t)chr;",
            "   } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {",
            "-    // 2-byte/11-bit utf8 code point",
            "-    // (0b110xxxxx 0b10xxxxxx)",
            "-    c[0] = 0xc0 | (char)(chr >> 6);",
            "-    c[1] = 0x80 | (char)(chr & 0x3f);",
            "+    /* 2-byte/11-bit utf8 code point",
            "+     * (0b110xxxxx 0b10xxxxxx) */",
            "+    c[0] = (utf8_int8_t)(0xc0 | (utf8_int8_t)(chr >> 6));",
            "+    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "   } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {",
            "-    // 3-byte/16-bit utf8 code point",
            "-    // (0b1110xxxx 0b10xxxxxx 0b10xxxxxx)",
            "-    c[0] = 0xe0 | (char)(chr >> 12);",
            "-    c[1] = 0x80 | (char)((chr >> 6) & 0x3f);",
            "-    c[2] = 0x80 | (char)(chr & 0x3f);",
            "-  } else { // if (0 == ((int)0xffe00000 & chr)) {",
            "-    // 4-byte/21-bit utf8 code point",
            "-    // (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx)",
            "-    c[0] = 0xf0 | (char)(chr >> 18);",
            "-    c[1] = 0x80 | (char)((chr >> 12) & 0x3f);",
            "-    c[2] = 0x80 | (char)((chr >> 6) & 0x3f);",
            "-    c[3] = 0x80 | (char)(chr & 0x3f);",
            "-  }",
            "-",
            "-  // we've made c into a 2 utf8 codepoint string, one for the chr we are",
            "-  // seeking, another for the null terminating byte. Now use utf8str to",
            "-  // search",
            "+    /* 3-byte/16-bit utf8 code point",
            "+     * (0b1110xxxx 0b10xxxxxx 0b10xxxxxx) */",
            "+    c[0] = (utf8_int8_t)(0xe0 | (utf8_int8_t)(chr >> 12));",
            "+    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));",
            "+    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+  } else { /* if (0 == ((int)0xffe00000 & chr)) { */",
            "+    /* 4-byte/21-bit utf8 code point",
            "+     * (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx) */",
            "+    c[0] = (utf8_int8_t)(0xf0 | (utf8_int8_t)(chr >> 18));",
            "+    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 12) & 0x3f));",
            "+    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));",
            "+    c[3] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+  }",
            "+",
            "+  /* we've made c into a 2 utf8 codepoint string, one for the chr we are",
            "+   * seeking, another for the null terminating byte. Now use utf8str to",
            "+   * search */",
            "   return utf8str(src, c);",
            " }",
            " ",
            "-int utf8cmp(const void *src1, const void *src2) {",
            "-  const unsigned char *s1 = (const unsigned char *)src1;",
            "-  const unsigned char *s2 = (const unsigned char *)src2;",
            "-",
            "-  while (('\\0' != *s1) || ('\\0' != *s2)) {",
            "-    if (*s1 < *s2) {",
            "+utf8_constexpr14_impl int utf8cmp(const utf8_int8_t *src1,",
            "+                                  const utf8_int8_t *src2) {",
            "+  while (('\\0' != *src1) || ('\\0' != *src2)) {",
            "+    if (*src1 < *src2) {",
            "       return -1;",
            "-    } else if (*s1 > *s2) {",
            "+    } else if (*src1 > *src2) {",
            "       return 1;",
            "     }",
            " ",
            "-    s1++;",
            "-    s2++;",
            "+    src1++;",
            "+    src2++;",
            "   }",
            " ",
            "-  // both utf8 strings matched",
            "+  /* both utf8 strings matched */",
            "   return 0;",
            " }",
            " ",
            "-int utf8coll(const void *src1, const void *src2);",
            "+utf8_constexpr14_impl int utf8coll(const utf8_int8_t *src1,",
            "+                                   const utf8_int8_t *src2);",
            " ",
            "-void *utf8cpy(void *utf8_restrict dst, const void *utf8_restrict src) {",
            "-  char *d = (char *)dst;",
            "-  const char *s = (const char *)src;",
            "+utf8_int8_t *utf8cpy(utf8_int8_t *utf8_restrict dst,",
            "+                     const utf8_int8_t *utf8_restrict src) {",
            "+  utf8_int8_t *d = dst;",
            " ",
            "-  // overwriting anything previously in dst, write byte-by-byte",
            "-  // from src",
            "-  while ('\\0' != *s) {",
            "-    *d++ = *s++;",
            "+  /* overwriting anything previously in dst, write byte-by-byte",
            "+   * from src */",
            "+  while ('\\0' != *src) {",
            "+    *d++ = *src++;",
            "   }",
            " ",
            "-  // append null terminating byte",
            "+  /* append null terminating byte */",
            "   *d = '\\0';",
            " ",
            "   return dst;",
            " }",
            " ",
            "-size_t utf8cspn(const void *src, const void *reject) {",
            "-  const char *s = (const char *)src;",
            "+utf8_constexpr14_impl size_t utf8cspn(const utf8_int8_t *src,",
            "+                                      const utf8_int8_t *reject) {",
            "   size_t chars = 0;",
            " ",
            "-  while ('\\0' != *s) {",
            "-    const char *r = (const char *)reject;",
            "+  while ('\\0' != *src) {",
            "+    const utf8_int8_t *r = reject;",
            "     size_t offset = 0;",
            " ",
            "     while ('\\0' != *r) {",
            "-      // checking that if *r is the start of a utf8 codepoint",
            "-      // (it is not 0b10xxxxxx) and we have successfully matched",
            "-      // a previous character (0 < offset) - we found a match",
            "+      /* checking that if *r is the start of a utf8 codepoint",
            "+       * (it is not 0b10xxxxxx) and we have successfully matched",
            "+       * a previous character (0 < offset) - we found a match */",
            "       if ((0x80 != (0xc0 & *r)) && (0 < offset)) {",
            "         return chars;",
            "       } else {",
            "-        if (*r == s[offset]) {",
            "-          // part of a utf8 codepoint matched, so move our checking",
            "-          // onwards to the next byte",
            "+        if (*r == src[offset]) {",
            "+          /* part of a utf8 codepoint matched, so move our checking",
            "+           * onwards to the next byte */",
            "           offset++;",
            "           r++;",
            "         } else {",
            "-          // r could be in the middle of an unmatching utf8 code point,",
            "-          // so we need to march it on to the next character beginning,",
            "+          /* r could be in the middle of an unmatching utf8 code point,",
            "+           * so we need to march it on to the next character beginning, */",
            " ",
            "           do {",
            "             r++;",
            "           } while (0x80 == (0xc0 & *r));",
            " ",
            "-          // reset offset too as we found a mismatch",
            "+          /* reset offset too as we found a mismatch */",
            "           offset = 0;",
            "         }",
            "       }",
            "     }",
            " ",
            "-    // the current utf8 codepoint in src did not match reject, but src",
            "-    // could have been partway through a utf8 codepoint, so we need to",
            "-    // march it onto the next utf8 codepoint starting byte",
            "+    /* found a match at the end of *r, so didn't get a chance to test it */",
            "+    if (0 < offset) {",
            "+      return chars;",
            "+    }",
            "+",
            "+    /* the current utf8 codepoint in src did not match reject, but src",
            "+     * could have been partway through a utf8 codepoint, so we need to",
            "+     * march it onto the next utf8 codepoint starting byte */",
            "     do {",
            "-      s++;",
            "-    } while ((0x80 == (0xc0 & *s)));",
            "+      src++;",
            "+    } while ((0x80 == (0xc0 & *src)));",
            "     chars++;",
            "   }",
            " ",
            "   return chars;",
            " }",
            " ",
            "-size_t utf8size(const void *str);",
            "+utf8_int8_t *utf8dup(const utf8_int8_t *src) {",
            "+  return utf8dup_ex(src, utf8_null, utf8_null);",
            "+}",
            " ",
            "-void *utf8dup(const void *src) {",
            "-  const char *s = (const char *)src;",
            "-  char *n = utf8_null;",
            "+utf8_int8_t *utf8dup_ex(const utf8_int8_t *src,",
            "+                        utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *, size_t),",
            "+                        utf8_int8_t *user_data) {",
            "+  utf8_int8_t *n = utf8_null;",
            " ",
            "-  // figure out how many bytes (including the terminator) we need to copy first",
            "+  /* figure out how many bytes (including the terminator) we need to copy first",
            "+   */",
            "   size_t bytes = utf8size(src);",
            " ",
            "-  n = (char *)malloc(bytes);",
            "+  if (alloc_func_ptr) {",
            "+    n = alloc_func_ptr(user_data, bytes);",
            "+  } else {",
            "+#if !defined(UTF8_NO_STD_MALLOC)",
            "+    n = (utf8_int8_t *)malloc(bytes);",
            "+#else",
            "+    return utf8_null;",
            "+#endif",
            "+  }",
            " ",
            "   if (utf8_null == n) {",
            "-    // out of memory so we bail",
            "+    /* out of memory so we bail */",
            "     return utf8_null;",
            "   } else {",
            "     bytes = 0;",
            " ",
            "-    // copy src byte-by-byte into our new utf8 string",
            "-    while ('\\0' != s[bytes]) {",
            "-      n[bytes] = s[bytes];",
            "+    /* copy src byte-by-byte into our new utf8 string */",
            "+    while ('\\0' != src[bytes]) {",
            "+      n[bytes] = src[bytes];",
            "       bytes++;",
            "     }",
            " ",
            "-    // append null terminating byte",
            "+    /* append null terminating byte */",
            "     n[bytes] = '\\0';",
            "     return n;",
            "   }",
            " }",
            " ",
            "-void *utf8fry(const void *str);",
            "+utf8_constexpr14_impl utf8_int8_t *utf8fry(const utf8_int8_t *str);",
            "+",
            "+utf8_constexpr14_impl size_t utf8len(const utf8_int8_t *str) {",
            "+  return utf8nlen(str, SIZE_MAX);",
            "+}",
            " ",
            "-size_t utf8len(const void *str) {",
            "-  const unsigned char *s = (const unsigned char *)str;",
            "+utf8_constexpr14_impl size_t utf8nlen(const utf8_int8_t *str, size_t n) {",
            "+  const utf8_int8_t *t = str;",
            "   size_t length = 0;",
            " ",
            "-  while ('\\0' != *s) {",
            "-    if (0xf0 == (0xf8 & *s)) {",
            "-      // 4-byte utf8 code point (began with 0b11110xxx)",
            "-      s += 4;",
            "-    } else if (0xe0 == (0xf0 & *s)) {",
            "-      // 3-byte utf8 code point (began with 0b1110xxxx)",
            "-      s += 3;",
            "-    } else if (0xc0 == (0xe0 & *s)) {",
            "-      // 2-byte utf8 code point (began with 0b110xxxxx)",
            "-      s += 2;",
            "-    } else { // if (0x00 == (0x80 & *s)) {",
            "-      // 1-byte ascii (began with 0b0xxxxxxx)",
            "-      s += 1;",
            "+  while ((size_t)(str - t) < n && '\\0' != *str) {",
            "+    if (0xf0 == (0xf8 & *str)) {",
            "+      /* 4-byte utf8 code point (began with 0b11110xxx) */",
            "+      str += 4;",
            "+    } else if (0xe0 == (0xf0 & *str)) {",
            "+      /* 3-byte utf8 code point (began with 0b1110xxxx) */",
            "+      str += 3;",
            "+    } else if (0xc0 == (0xe0 & *str)) {",
            "+      /* 2-byte utf8 code point (began with 0b110xxxxx) */",
            "+      str += 2;",
            "+    } else { /* if (0x00 == (0x80 & *s)) { */",
            "+      /* 1-byte ascii (began with 0b0xxxxxxx) */",
            "+      str += 1;",
            "     }",
            " ",
            "-    // no matter the bytes we marched s forward by, it was",
            "-    // only 1 utf8 codepoint",
            "+    /* no matter the bytes we marched s forward by, it was",
            "+     * only 1 utf8 codepoint */",
            "     length++;",
            "   }",
            " ",
            "+  if ((size_t)(str - t) > n) {",
            "+    length--;",
            "+  }",
            "   return length;",
            " }",
            " ",
            "-int utf8ncasecmp(const void *src1, const void *src2, size_t n) {",
            "-  utf8_int32_t src1_cp, src2_cp, src1_orig_cp, src2_orig_cp;",
            "+utf8_constexpr14_impl int utf8ncasecmp(const utf8_int8_t *src1,",
            "+                                       const utf8_int8_t *src2, size_t n) {",
            "+  utf8_int32_t src1_lwr_cp = 0, src2_lwr_cp = 0, src1_upr_cp = 0,",
            "+               src2_upr_cp = 0, src1_orig_cp = 0, src2_orig_cp = 0;",
            " ",
            "   do {",
            "-    const unsigned char *const s1 = (const unsigned char *)src1;",
            "-    const unsigned char *const s2 = (const unsigned char *)src2;",
            "+    const utf8_int8_t *const s1 = src1;",
            "+    const utf8_int8_t *const s2 = src2;",
            " ",
            "-    // first check that we have enough bytes left in n to contain an entire",
            "-    // codepoint",
            "+    /* first check that we have enough bytes left in n to contain an entire",
            "+     * codepoint */",
            "     if (0 == n) {",
            "       return 0;",
            "     }",
            " ",
            "     if ((1 == n) && ((0xc0 == (0xe0 & *s1)) || (0xc0 == (0xe0 & *s2)))) {",
            "       const utf8_int32_t c1 = (0xe0 & *s1);",
            "       const utf8_int32_t c2 = (0xe0 & *s2);",
            " ",
            "-      if (c1 < c2) {",
            "-        return -1;",
            "-      } else if (c1 > c2) {",
            "-        return 1;",
            "+      if (c1 != c2) {",
            "+        return c1 - c2;",
            "       } else {",
            "         return 0;",
            "       }",
            "     }",
            " ",
            "     if ((2 >= n) && ((0xe0 == (0xf0 & *s1)) || (0xe0 == (0xf0 & *s2)))) {",
            "       const utf8_int32_t c1 = (0xf0 & *s1);",
            "       const utf8_int32_t c2 = (0xf0 & *s2);",
            " ",
            "-      if (c1 < c2) {",
            "-        return -1;",
            "-      } else if (c1 > c2) {",
            "-        return 1;",
            "+      if (c1 != c2) {",
            "+        return c1 - c2;",
            "       } else {",
            "         return 0;",
            "       }",
            "     }",
            " ",
            "     if ((3 >= n) && ((0xf0 == (0xf8 & *s1)) || (0xf0 == (0xf8 & *s2)))) {",
            "       const utf8_int32_t c1 = (0xf8 & *s1);",
            "       const utf8_int32_t c2 = (0xf8 & *s2);",
            " ",
            "-      if (c1 < c2) {",
            "-        return -1;",
            "-      } else if (c1 > c2) {",
            "-        return 1;",
            "+      if (c1 != c2) {",
            "+        return c1 - c2;",
            "       } else {",
            "         return 0;",
            "       }",
            "     }",
            " ",
            "-    src1 = utf8codepoint(src1, &src1_cp);",
            "-    src2 = utf8codepoint(src2, &src2_cp);",
            "-    n -= utf8codepointsize(src1_cp);",
            "-",
            "-    // Take a copy of src1 & src2",
            "-    src1_orig_cp = src1_cp;",
            "-    src2_orig_cp = src2_cp;",
            "-",
            "-    // Lower srcs if required",
            "-    src1_cp = utf8lwrcodepoint(src1_cp);",
            "-    src2_cp = utf8lwrcodepoint(src2_cp);",
            "+    src1 = utf8codepoint(src1, &src1_orig_cp);",
            "+    src2 = utf8codepoint(src2, &src2_orig_cp);",
            "+    n -= utf8codepointsize(src1_orig_cp);",
            "+",
            "+    src1_lwr_cp = utf8lwrcodepoint(src1_orig_cp);",
            "+    src2_lwr_cp = utf8lwrcodepoint(src2_orig_cp);",
            " ",
            "-    // Check if the lowered codepoints match",
            "+    src1_upr_cp = utf8uprcodepoint(src1_orig_cp);",
            "+    src2_upr_cp = utf8uprcodepoint(src2_orig_cp);",
            "+",
            "+    /* check if the lowered codepoints match */",
            "     if ((0 == src1_orig_cp) && (0 == src2_orig_cp)) {",
            "       return 0;",
            "-    } else if (src1_cp == src2_cp) {",
            "+    } else if ((src1_lwr_cp == src2_lwr_cp) || (src1_upr_cp == src2_upr_cp)) {",
            "       continue;",
            "     }",
            " ",
            "-    // If they don't match, then we return which of the original's are less",
            "-    if (src1_orig_cp < src2_orig_cp) {",
            "-      return -1;",
            "-    } else if (src1_orig_cp > src2_orig_cp) {",
            "-      return 1;",
            "-    }",
            "+    /* if they don't match, then we return the difference between the characters",
            "+     */",
            "+    return src1_lwr_cp - src2_lwr_cp;",
            "   } while (0 < n);",
            " ",
            "-  // both utf8 strings matched",
            "+  /* both utf8 strings matched */",
            "   return 0;",
            " }",
            " ",
            "-void *utf8ncat(void *utf8_restrict dst, const void *utf8_restrict src,",
            "-               size_t n) {",
            "-  char *d = (char *)dst;",
            "-  const char *s = (const char *)src;",
            "+utf8_int8_t *utf8ncat(utf8_int8_t *utf8_restrict dst,",
            "+                      const utf8_int8_t *utf8_restrict src, size_t n) {",
            "+  utf8_int8_t *d = dst;",
            " ",
            "-  // find the null terminating byte in dst",
            "+  /* find the null terminating byte in dst */",
            "   while ('\\0' != *d) {",
            "     d++;",
            "   }",
            " ",
            "-  // overwriting the null terminating byte in dst, append src byte-by-byte",
            "-  // stopping if we run out of space",
            "-  do {",
            "-    *d++ = *s++;",
            "-  } while (('\\0' != *s) && (0 != --n));",
            "+  /* overwriting the null terminating byte in dst, append src byte-by-byte",
            "+   * stopping if we run out of space */",
            "+  while (('\\0' != *src) && (0 != n--)) {",
            "+    *d++ = *src++;",
            "+  }",
            " ",
            "-  // write out a new null terminating byte into dst",
            "+  /* write out a new null terminating byte into dst */",
            "   *d = '\\0';",
            " ",
            "   return dst;",
            " }",
            " ",
            "-int utf8ncmp(const void *src1, const void *src2, size_t n) {",
            "-  const unsigned char *s1 = (const unsigned char *)src1;",
            "-  const unsigned char *s2 = (const unsigned char *)src2;",
            "-",
            "-  while ((('\\0' != *s1) || ('\\0' != *s2)) && (0 != n--)) {",
            "-    if (*s1 < *s2) {",
            "+utf8_constexpr14_impl int utf8ncmp(const utf8_int8_t *src1,",
            "+                                   const utf8_int8_t *src2, size_t n) {",
            "+  while ((0 != n--) && (('\\0' != *src1) || ('\\0' != *src2))) {",
            "+    if (*src1 < *src2) {",
            "       return -1;",
            "-    } else if (*s1 > *s2) {",
            "+    } else if (*src1 > *src2) {",
            "       return 1;",
            "     }",
            " ",
            "-    s1++;",
            "-    s2++;",
            "+    src1++;",
            "+    src2++;",
            "   }",
            " ",
            "-  // both utf8 strings matched",
            "+  /* both utf8 strings matched */",
            "   return 0;",
            " }",
            " ",
            "-void *utf8ncpy(void *utf8_restrict dst, const void *utf8_restrict src,",
            "-               size_t n) {",
            "-  char *d = (char *)dst;",
            "-  const char *s = (const char *)src;",
            "+utf8_int8_t *utf8ncpy(utf8_int8_t *utf8_restrict dst,",
            "+                      const utf8_int8_t *utf8_restrict src, size_t n) {",
            "+  utf8_int8_t *d = dst;",
            "+  size_t index = 0, check_index = 0;",
            " ",
            "-  // overwriting anything previously in dst, write byte-by-byte",
            "-  // from src",
            "-  do {",
            "-    *d++ = *s++;",
            "-  } while (('\\0' != *s) && (0 != --n));",
            "+  if (n == 0) {",
            "+    return dst;",
            "+  }",
            " ",
            "-  // append null terminating byte",
            "-  while (0 != n) {",
            "-    *d++ = '\\0';",
            "-    n--;",
            "+  /* overwriting anything previously in dst, write byte-by-byte",
            "+   * from src */",
            "+  for (index = 0; index < n; index++) {",
            "+    d[index] = src[index];",
            "+    if ('\\0' == src[index]) {",
            "+      break;",
            "+    }",
            "+  }",
            "+",
            "+  for (check_index = index - 1;",
            "+       check_index > 0 && 0x80 == (0xc0 & d[check_index]); check_index--) {",
            "+    /* just moving the index */",
            "+  }",
            "+",
            "+  if (check_index < index &&",
            "+      ((index - check_index) < utf8codepointcalcsize(&d[check_index]) ||",
            "+       (index - check_index) == n)) {",
            "+    index = check_index;",
            "+  }",
            "+",
            "+  /* append null terminating byte */",
            "+  for (; index < n; index++) {",
            "+    d[index] = 0;",
            "   }",
            " ",
            "   return dst;",
            " }",
            " ",
            "-void *utf8ndup(const void *src, size_t n) {",
            "-  const char *s = (const char *)src;",
            "-  char *c = utf8_null;",
            "+utf8_int8_t *utf8ndup(const utf8_int8_t *src, size_t n) {",
            "+  return utf8ndup_ex(src, n, utf8_null, utf8_null);",
            "+}",
            "+",
            "+utf8_int8_t *utf8ndup_ex(const utf8_int8_t *src, size_t n,",
            "+                         utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *, size_t),",
            "+                         utf8_int8_t *user_data) {",
            "+  utf8_int8_t *c = utf8_null;",
            "   size_t bytes = 0;",
            " ",
            "-  // Find the end of the string or stop when n is reached",
            "-  while ('\\0' != s[bytes] && bytes < n) {",
            "+  /* Find the end of the string or stop when n is reached */",
            "+  while ('\\0' != src[bytes] && bytes < n) {",
            "     bytes++;",
            "   }",
            " ",
            "-  // In case bytes is actually less than n, we need to set it",
            "-  // to be used later in the copy byte by byte.",
            "+  /* In case bytes is actually less than n, we need to set it",
            "+   * to be used later in the copy byte by byte. */",
            "   n = bytes;",
            " ",
            "-  c = (char *)malloc(bytes + 1);",
            "+  if (alloc_func_ptr) {",
            "+    c = alloc_func_ptr(user_data, bytes + 1);",
            "+  } else {",
            "+#if !defined(UTF8_NO_STD_MALLOC)",
            "+    c = (utf8_int8_t *)malloc(bytes + 1);",
            "+#else",
            "+    c = utf8_null;",
            "+#endif",
            "+  }",
            "+",
            "   if (utf8_null == c) {",
            "-    // out of memory so we bail",
            "+    /* out of memory so we bail */",
            "     return utf8_null;",
            "   }",
            " ",
            "   bytes = 0;",
            " ",
            "-  // copy src byte-by-byte into our new utf8 string",
            "-  while ('\\0' != s[bytes] && bytes < n) {",
            "-    c[bytes] = s[bytes];",
            "+  /* copy src byte-by-byte into our new utf8 string */",
            "+  while ('\\0' != src[bytes] && bytes < n) {",
            "+    c[bytes] = src[bytes];",
            "     bytes++;",
            "   }",
            " ",
            "-  // append null terminating byte",
            "+  /* append null terminating byte */",
            "   c[bytes] = '\\0';",
            "   return c;",
            " }",
            " ",
            "-void *utf8rchr(const void *src, int chr) {",
            "-  const char *s = (const char *)src;",
            "-  const char *match = utf8_null;",
            "-  char c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};",
            "+utf8_constexpr14_impl utf8_int8_t *utf8rchr(const utf8_int8_t *src, int chr) {",
            "+",
            "+  utf8_int8_t *match = utf8_null;",
            "+  utf8_int8_t c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};",
            " ",
            "   if (0 == chr) {",
            "-    // being asked to return position of null terminating byte, so",
            "-    // just run s to the end, and return!",
            "-    while ('\\0' != *s) {",
            "-      s++;",
            "+    /* being asked to return position of null terminating byte, so",
            "+     * just run s to the end, and return! */",
            "+    while ('\\0' != *src) {",
            "+      src++;",
            "     }",
            "-    return (void *)s;",
            "+    return (utf8_int8_t *)src;",
            "   } else if (0 == ((int)0xffffff80 & chr)) {",
            "-    // 1-byte/7-bit ascii",
            "-    // (0b0xxxxxxx)",
            "-    c[0] = (char)chr;",
            "+    /* 1-byte/7-bit ascii",
            "+     * (0b0xxxxxxx) */",
            "+    c[0] = (utf8_int8_t)chr;",
            "   } else if (0 == ((int)0xfffff800 & chr)) {",
            "-    // 2-byte/11-bit utf8 code point",
            "-    // (0b110xxxxx 0b10xxxxxx)",
            "-    c[0] = 0xc0 | (char)(chr >> 6);",
            "-    c[1] = 0x80 | (char)(chr & 0x3f);",
            "+    /* 2-byte/11-bit utf8 code point",
            "+     * (0b110xxxxx 0b10xxxxxx) */",
            "+    c[0] = (utf8_int8_t)(0xc0 | (utf8_int8_t)(chr >> 6));",
            "+    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "   } else if (0 == ((int)0xffff0000 & chr)) {",
            "-    // 3-byte/16-bit utf8 code point",
            "-    // (0b1110xxxx 0b10xxxxxx 0b10xxxxxx)",
            "-    c[0] = 0xe0 | (char)(chr >> 12);",
            "-    c[1] = 0x80 | (char)((chr >> 6) & 0x3f);",
            "-    c[2] = 0x80 | (char)(chr & 0x3f);",
            "-  } else { // if (0 == ((int)0xffe00000 & chr)) {",
            "-    // 4-byte/21-bit utf8 code point",
            "-    // (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx)",
            "-    c[0] = 0xf0 | (char)(chr >> 18);",
            "-    c[1] = 0x80 | (char)((chr >> 12) & 0x3f);",
            "-    c[2] = 0x80 | (char)((chr >> 6) & 0x3f);",
            "-    c[3] = 0x80 | (char)(chr & 0x3f);",
            "-  }",
            "-",
            "-  // we've created a 2 utf8 codepoint string in c that is",
            "-  // the utf8 character asked for by chr, and a null",
            "-  // terminating byte",
            "+    /* 3-byte/16-bit utf8 code point",
            "+     * (0b1110xxxx 0b10xxxxxx 0b10xxxxxx) */",
            "+    c[0] = (utf8_int8_t)(0xe0 | (utf8_int8_t)(chr >> 12));",
            "+    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));",
            "+    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+  } else { /* if (0 == ((int)0xffe00000 & chr)) { */",
            "+    /* 4-byte/21-bit utf8 code point",
            "+     * (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx) */",
            "+    c[0] = (utf8_int8_t)(0xf0 | (utf8_int8_t)(chr >> 18));",
            "+    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 12) & 0x3f));",
            "+    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));",
            "+    c[3] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+  }",
            "+",
            "+  /* we've created a 2 utf8 codepoint string in c that is",
            "+   * the utf8 character asked for by chr, and a null",
            "+   * terminating byte */",
            " ",
            "-  while ('\\0' != *s) {",
            "+  while ('\\0' != *src) {",
            "     size_t offset = 0;",
            " ",
            "-    while (s[offset] == c[offset]) {",
            "+    while ((src[offset] == c[offset]) && ('\\0' != src[offset])) {",
            "       offset++;",
            "     }",
            " ",
            "     if ('\\0' == c[offset]) {",
            "-      // we found a matching utf8 code point",
            "-      match = s;",
            "-      s += offset;",
            "+      /* we found a matching utf8 code point */",
            "+      match = (utf8_int8_t *)src;",
            "+      src += offset;",
            "+",
            "+      if ('\\0' == *src) {",
            "+        break;",
            "+      }",
            "     } else {",
            "-      s += offset;",
            "+      src += offset;",
            " ",
            "-      // need to march s along to next utf8 codepoint start",
            "-      // (the next byte that doesn't match 0b10xxxxxx)",
            "-      if ('\\0' != *s) {",
            "+      /* need to march s along to next utf8 codepoint start",
            "+       * (the next byte that doesn't match 0b10xxxxxx) */",
            "+      if ('\\0' != *src) {",
            "         do {",
            "-          s++;",
            "-        } while (0x80 == (0xc0 & *s));",
            "+          src++;",
            "+        } while (0x80 == (0xc0 & *src));",
            "       }",
            "     }",
            "   }",
            " ",
            "-  // return the last match we found (or 0 if no match was found)",
            "-  return (void *)match;",
            "+  /* return the last match we found (or 0 if no match was found) */",
            "+  return match;",
            " }",
            " ",
            "-void *utf8pbrk(const void *str, const void *accept) {",
            "-  const char *s = (const char *)str;",
            "-",
            "-  while ('\\0' != *s) {",
            "-    const char *a = (const char *)accept;",
            "+utf8_constexpr14_impl utf8_int8_t *utf8pbrk(const utf8_int8_t *str,",
            "+                                            const utf8_int8_t *accept) {",
            "+  while ('\\0' != *str) {",
            "+    const utf8_int8_t *a = accept;",
            "     size_t offset = 0;",
            " ",
            "     while ('\\0' != *a) {",
            "-      // checking that if *a is the start of a utf8 codepoint",
            "-      // (it is not 0b10xxxxxx) and we have successfully matched",
            "-      // a previous character (0 < offset) - we found a match",
            "+      /* checking that if *a is the start of a utf8 codepoint",
            "+       * (it is not 0b10xxxxxx) and we have successfully matched",
            "+       * a previous character (0 < offset) - we found a match */",
            "       if ((0x80 != (0xc0 & *a)) && (0 < offset)) {",
            "-        return (void *)s;",
            "+        return (utf8_int8_t *)str;",
            "       } else {",
            "-        if (*a == s[offset]) {",
            "-          // part of a utf8 codepoint matched, so move our checking",
            "-          // onwards to the next byte",
            "+        if (*a == str[offset]) {",
            "+          /* part of a utf8 codepoint matched, so move our checking",
            "+           * onwards to the next byte */",
            "           offset++;",
            "           a++;",
            "         } else {",
            "-          // r could be in the middle of an unmatching utf8 code point,",
            "-          // so we need to march it on to the next character beginning,",
            "+          /* r could be in the middle of an unmatching utf8 code point,",
            "+           * so we need to march it on to the next character beginning, */",
            " ",
            "           do {",
            "             a++;",
            "           } while (0x80 == (0xc0 & *a));",
            " ",
            "-          // reset offset too as we found a mismatch",
            "+          /* reset offset too as we found a mismatch */",
            "           offset = 0;",
            "         }",
            "       }",
            "     }",
            " ",
            "-    // we found a match on the last utf8 codepoint",
            "+    /* we found a match on the last utf8 codepoint */",
            "     if (0 < offset) {",
            "-      return (void *)s;",
            "+      return (utf8_int8_t *)str;",
            "     }",
            " ",
            "-    // the current utf8 codepoint in src did not match accept, but src",
            "-    // could have been partway through a utf8 codepoint, so we need to",
            "-    // march it onto the next utf8 codepoint starting byte",
            "+    /* the current utf8 codepoint in src did not match accept, but src",
            "+     * could have been partway through a utf8 codepoint, so we need to",
            "+     * march it onto the next utf8 codepoint starting byte */",
            "     do {",
            "-      s++;",
            "-    } while ((0x80 == (0xc0 & *s)));",
            "+      str++;",
            "+    } while ((0x80 == (0xc0 & *str)));",
            "   }",
            " ",
            "   return utf8_null;",
            " }",
            " ",
            "-size_t utf8size(const void *str) {",
            "-  const char *s = (const char *)str;",
            "+utf8_constexpr14_impl size_t utf8size(const utf8_int8_t *str) {",
            "+  return utf8size_lazy(str) + 1;",
            "+}",
            "+",
            "+utf8_constexpr14_impl size_t utf8size_lazy(const utf8_int8_t *str) {",
            "+  return utf8nsize_lazy(str, SIZE_MAX);",
            "+}",
            "+",
            "+utf8_constexpr14_impl size_t utf8nsize_lazy(const utf8_int8_t *str, size_t n) {",
            "   size_t size = 0;",
            "-  while ('\\0' != s[size]) {",
            "+  while (size < n && '\\0' != str[size]) {",
            "     size++;",
            "   }",
            "-",
            "-  // we are including the null terminating byte in the size calculation",
            "-  size++;",
            "   return size;",
            " }",
            " ",
            "-size_t utf8spn(const void *src, const void *accept) {",
            "-  const char *s = (const char *)src;",
            "+utf8_constexpr14_impl size_t utf8spn(const utf8_int8_t *src,",
            "+                                     const utf8_int8_t *accept) {",
            "   size_t chars = 0;",
            " ",
            "-  while ('\\0' != *s) {",
            "-    const char *a = (const char *)accept;",
            "+  while ('\\0' != *src) {",
            "+    const utf8_int8_t *a = accept;",
            "     size_t offset = 0;",
            " ",
            "     while ('\\0' != *a) {",
            "-      // checking that if *r is the start of a utf8 codepoint",
            "-      // (it is not 0b10xxxxxx) and we have successfully matched",
            "-      // a previous character (0 < offset) - we found a match",
            "+      /* checking that if *r is the start of a utf8 codepoint",
            "+       * (it is not 0b10xxxxxx) and we have successfully matched",
            "+       * a previous character (0 < offset) - we found a match */",
            "       if ((0x80 != (0xc0 & *a)) && (0 < offset)) {",
            "-        // found a match, so increment the number of utf8 codepoints",
            "-        // that have matched and stop checking whether any other utf8",
            "-        // codepoints in a match",
            "+        /* found a match, so increment the number of utf8 codepoints",
            "+         * that have matched and stop checking whether any other utf8",
            "+         * codepoints in a match */",
            "         chars++;",
            "-        s += offset;",
            "+        src += offset;",
            "+        offset = 0;",
            "         break;",
            "       } else {",
            "-        if (*a == s[offset]) {",
            "+        if (*a == src[offset]) {",
            "           offset++;",
            "           a++;",
            "         } else {",
            "-          // a could be in the middle of an unmatching utf8 codepoint,",
            "-          // so we need to march it on to the next character beginning,",
            "+          /* a could be in the middle of an unmatching utf8 codepoint,",
            "+           * so we need to march it on to the next character beginning, */",
            "           do {",
            "             a++;",
            "           } while (0x80 == (0xc0 & *a));",
            " ",
            "-          // reset offset too as we found a mismatch",
            "+          /* reset offset too as we found a mismatch */",
            "           offset = 0;",
            "         }",
            "       }",
            "     }",
            " ",
            "-    // if a got to its terminating null byte, then we didn't find a match.",
            "-    // Return the current number of matched utf8 codepoints",
            "+    /* found a match at the end of *a, so didn't get a chance to test it */",
            "+    if (0 < offset) {",
            "+      chars++;",
            "+      src += offset;",
            "+      continue;",
            "+    }",
            "+",
            "+    /* if a got to its terminating null byte, then we didn't find a match.",
            "+     * Return the current number of matched utf8 codepoints */",
            "     if ('\\0' == *a) {",
            "       return chars;",
            "     }",
            "   }",
            " ",
            "   return chars;",
            " }",
            " ",
            "-void *utf8str(const void *haystack, const void *needle) {",
            "-  const char *h = (const char *)haystack;",
            "+utf8_constexpr14_impl utf8_int8_t *utf8str(const utf8_int8_t *haystack,",
            "+                                           const utf8_int8_t *needle) {",
            "+  utf8_int32_t throwaway_codepoint = 0;",
            " ",
            "-  // if needle has no utf8 codepoints before the null terminating",
            "-  // byte then return haystack",
            "-  if ('\\0' == *((const char *)needle)) {",
            "-    return (void *)haystack;",
            "+  /* if needle has no utf8 codepoints before the null terminating",
            "+   * byte then return haystack */",
            "+  if ('\\0' == *needle) {",
            "+    return (utf8_int8_t *)haystack;",
            "   }",
            " ",
            "-  while ('\\0' != *h) {",
            "-    const char *maybeMatch = h;",
            "-    const char *n = (const char *)needle;",
            "+  while ('\\0' != *haystack) {",
            "+    const utf8_int8_t *maybeMatch = haystack;",
            "+    const utf8_int8_t *n = needle;",
            " ",
            "-    while (*h == *n && (*h != '\\0' && *n != '\\0')) {",
            "+    while (*haystack == *n && (*haystack != '\\0' && *n != '\\0')) {",
            "       n++;",
            "-      h++;",
            "+      haystack++;",
            "     }",
            " ",
            "     if ('\\0' == *n) {",
            "-      // we found the whole utf8 string for needle in haystack at",
            "-      // maybeMatch, so return it",
            "-      return (void *)maybeMatch;",
            "+      /* we found the whole utf8 string for needle in haystack at",
            "+       * maybeMatch, so return it */",
            "+      return (utf8_int8_t *)maybeMatch;",
            "     } else {",
            "-      // h could be in the middle of an unmatching utf8 codepoint,",
            "-      // so we need to march it on to the next character beginning,",
            "-      if ('\\0' != *h) {",
            "-        do {",
            "-          h++;",
            "-        } while (0x80 == (0xc0 & *h));",
            "-      }",
            "+      /* h could be in the middle of an unmatching utf8 codepoint,",
            "+       * so we need to march it on to the next character beginning",
            "+       * starting from the current character */",
            "+      haystack = utf8codepoint(maybeMatch, &throwaway_codepoint);",
            "     }",
            "   }",
            " ",
            "-  // no match",
            "+  /* no match */",
            "   return utf8_null;",
            " }",
            " ",
            "-void *utf8casestr(const void *haystack, const void *needle) {",
            "-  const void *h = haystack;",
            "-",
            "-  // if needle has no utf8 codepoints before the null terminating",
            "-  // byte then return haystack",
            "-  if ('\\0' == *((const char *)needle)) {",
            "-    return (void *)haystack;",
            "+utf8_constexpr14_impl utf8_int8_t *utf8casestr(const utf8_int8_t *haystack,",
            "+                                               const utf8_int8_t *needle) {",
            "+  /* if needle has no utf8 codepoints before the null terminating",
            "+   * byte then return haystack */",
            "+  if ('\\0' == *needle) {",
            "+    return (utf8_int8_t *)haystack;",
            "   }",
            " ",
            "   for (;;) {",
            "-    const void *maybeMatch = h;",
            "-    const void *n = needle;",
            "-    utf8_int32_t h_cp, n_cp;",
            "+    const utf8_int8_t *maybeMatch = haystack;",
            "+    const utf8_int8_t *n = needle;",
            "+    utf8_int32_t h_cp = 0, n_cp = 0;",
            " ",
            "-    h = utf8codepoint(h, &h_cp);",
            "+    /* Get the next code point and track it */",
            "+    const utf8_int8_t *nextH = haystack = utf8codepoint(haystack, &h_cp);",
            "     n = utf8codepoint(n, &n_cp);",
            " ",
            "     while ((0 != h_cp) && (0 != n_cp)) {",
            "       h_cp = utf8lwrcodepoint(h_cp);",
            "       n_cp = utf8lwrcodepoint(n_cp);",
            " ",
            "-      // if we find a mismatch, bail out!",
            "+      /* if we find a mismatch, bail out! */",
            "       if (h_cp != n_cp) {",
            "         break;",
            "       }",
            " ",
            "-      h = utf8codepoint(h, &h_cp);",
            "+      haystack = utf8codepoint(haystack, &h_cp);",
            "       n = utf8codepoint(n, &n_cp);",
            "     }",
            " ",
            "     if (0 == n_cp) {",
            "-      // we found the whole utf8 string for needle in haystack at",
            "-      // maybeMatch, so return it",
            "-      return (void *)maybeMatch;",
            "+      /* we found the whole utf8 string for needle in haystack at",
            "+       * maybeMatch, so return it */",
            "+      return (utf8_int8_t *)maybeMatch;",
            "     }",
            " ",
            "     if (0 == h_cp) {",
            "-      // no match",
            "+      /* no match */",
            "       return utf8_null;",
            "     }",
            "+",
            "+    /* Roll back to the next code point in the haystack to test */",
            "+    haystack = nextH;",
            "   }",
            " }",
            " ",
            "-void *utf8valid(const void *str) {",
            "-  const char *s = (const char *)str;",
            "+utf8_constexpr14_impl utf8_int8_t *utf8valid(const utf8_int8_t *str) {",
            "+  return utf8nvalid(str, SIZE_MAX);",
            "+}",
            "+",
            "+utf8_constexpr14_impl utf8_int8_t *utf8nvalid(const utf8_int8_t *str,",
            "+                                              size_t n) {",
            "+  const utf8_int8_t *t = str;",
            "+  size_t consumed = 0;",
            "+",
            "+  while ((void)(consumed = (size_t)(str - t)), consumed < n && '\\0' != *str) {",
            "+    const size_t remaining = n - consumed;",
            "+",
            "+    if (0xf0 == (0xf8 & *str)) {",
            "+      /* ensure that there's 4 bytes or more remaining */",
            "+      if (remaining < 4) {",
            "+        return (utf8_int8_t *)str;",
            "+      }",
            "+",
            "+      /* ensure each of the 3 following bytes in this 4-byte",
            "+       * utf8 codepoint began with 0b10xxxxxx */",
            "+      if ((0x80 != (0xc0 & str[1])) || (0x80 != (0xc0 & str[2])) ||",
            "+          (0x80 != (0xc0 & str[3]))) {",
            "+        return (utf8_int8_t *)str;",
            "+      }",
            " ",
            "-  while ('\\0' != *s) {",
            "-    if (0xf0 == (0xf8 & *s)) {",
            "-      // ensure each of the 3 following bytes in this 4-byte",
            "-      // utf8 codepoint began with 0b10xxxxxx",
            "-      if ((0x80 != (0xc0 & s[1])) || (0x80 != (0xc0 & s[2])) ||",
            "-          (0x80 != (0xc0 & s[3]))) {",
            "-        return (void *)s;",
            "+      /* ensure that our utf8 codepoint ended after 4 bytes */",
            "+      if ((remaining != 4) && (0x80 == (0xc0 & str[4]))) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // ensure that our utf8 codepoint ended after 4 bytes",
            "-      if (0x80 == (0xc0 & s[4])) {",
            "-        return (void *)s;",
            "+      /* ensure that the top 5 bits of this 4-byte utf8",
            "+       * codepoint were not 0, as then we could have used",
            "+       * one of the smaller encodings */",
            "+      if ((0 == (0x07 & str[0])) && (0 == (0x30 & str[1]))) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // ensure that the top 5 bits of this 4-byte utf8",
            "-      // codepoint were not 0, as then we could have used",
            "-      // one of the smaller encodings",
            "-      if ((0 == (0x07 & s[0])) && (0 == (0x30 & s[1]))) {",
            "-        return (void *)s;",
            "+      /* 4-byte utf8 code point (began with 0b11110xxx) */",
            "+      str += 4;",
            "+    } else if (0xe0 == (0xf0 & *str)) {",
            "+      /* ensure that there's 3 bytes or more remaining */",
            "+      if (remaining < 3) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // 4-byte utf8 code point (began with 0b11110xxx)",
            "-      s += 4;",
            "-    } else if (0xe0 == (0xf0 & *s)) {",
            "-      // ensure each of the 2 following bytes in this 3-byte",
            "-      // utf8 codepoint began with 0b10xxxxxx",
            "-      if ((0x80 != (0xc0 & s[1])) || (0x80 != (0xc0 & s[2]))) {",
            "-        return (void *)s;",
            "+      /* ensure each of the 2 following bytes in this 3-byte",
            "+       * utf8 codepoint began with 0b10xxxxxx */",
            "+      if ((0x80 != (0xc0 & str[1])) || (0x80 != (0xc0 & str[2]))) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // ensure that our utf8 codepoint ended after 3 bytes",
            "-      if (0x80 == (0xc0 & s[3])) {",
            "-        return (void *)s;",
            "+      /* ensure that our utf8 codepoint ended after 3 bytes */",
            "+      if ((remaining != 3) && (0x80 == (0xc0 & str[3]))) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // ensure that the top 5 bits of this 3-byte utf8",
            "-      // codepoint were not 0, as then we could have used",
            "-      // one of the smaller encodings",
            "-      if ((0 == (0x0f & s[0])) && (0 == (0x20 & s[1]))) {",
            "-        return (void *)s;",
            "+      /* ensure that the top 5 bits of this 3-byte utf8",
            "+       * codepoint were not 0, as then we could have used",
            "+       * one of the smaller encodings */",
            "+      if ((0 == (0x0f & str[0])) && (0 == (0x20 & str[1]))) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // 3-byte utf8 code point (began with 0b1110xxxx)",
            "-      s += 3;",
            "-    } else if (0xc0 == (0xe0 & *s)) {",
            "-      // ensure the 1 following byte in this 2-byte",
            "-      // utf8 codepoint began with 0b10xxxxxx",
            "-      if (0x80 != (0xc0 & s[1])) {",
            "-        return (void *)s;",
            "+      /* 3-byte utf8 code point (began with 0b1110xxxx) */",
            "+      str += 3;",
            "+    } else if (0xc0 == (0xe0 & *str)) {",
            "+      /* ensure that there's 2 bytes or more remaining */",
            "+      if (remaining < 2) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // ensure that our utf8 codepoint ended after 2 bytes",
            "-      if (0x80 == (0xc0 & s[2])) {",
            "-        return (void *)s;",
            "+      /* ensure the 1 following byte in this 2-byte",
            "+       * utf8 codepoint began with 0b10xxxxxx */",
            "+      if (0x80 != (0xc0 & str[1])) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // ensure that the top 4 bits of this 2-byte utf8",
            "-      // codepoint were not 0, as then we could have used",
            "-      // one of the smaller encodings",
            "-      if (0 == (0x1e & s[0])) {",
            "-        return (void *)s;",
            "+      /* ensure that our utf8 codepoint ended after 2 bytes */",
            "+      if ((remaining != 2) && (0x80 == (0xc0 & str[2]))) {",
            "+        return (utf8_int8_t *)str;",
            "       }",
            " ",
            "-      // 2-byte utf8 code point (began with 0b110xxxxx)",
            "-      s += 2;",
            "-    } else if (0x00 == (0x80 & *s)) {",
            "-      // 1-byte ascii (began with 0b0xxxxxxx)",
            "-      s += 1;",
            "+      /* ensure that the top 4 bits of this 2-byte utf8",
            "+       * codepoint were not 0, as then we could have used",
            "+       * one of the smaller encodings */",
            "+      if (0 == (0x1e & str[0])) {",
            "+        return (utf8_int8_t *)str;",
            "+      }",
            "+",
            "+      /* 2-byte utf8 code point (began with 0b110xxxxx) */",
            "+      str += 2;",
            "+    } else if (0x00 == (0x80 & *str)) {",
            "+      /* 1-byte ascii (began with 0b0xxxxxxx) */",
            "+      str += 1;",
            "     } else {",
            "-      // we have an invalid 0b1xxxxxxx utf8 code point entry",
            "-      return (void *)s;",
            "+      /* we have an invalid 0b1xxxxxxx utf8 code point entry */",
            "+      return (utf8_int8_t *)str;",
            "     }",
            "   }",
            " ",
            "   return utf8_null;",
            " }",
            " ",
            "-void *utf8codepoint(const void *utf8_restrict str,",
            "-                    utf8_int32_t *utf8_restrict out_codepoint) {",
            "-  const char *s = (const char *)str;",
            "+int utf8makevalid(utf8_int8_t *str, const utf8_int32_t replacement) {",
            "+  utf8_int8_t *read = str;",
            "+  utf8_int8_t *write = read;",
            "+  const utf8_int8_t r = (utf8_int8_t)replacement;",
            "+  utf8_int32_t codepoint = 0;",
            "+",
            "+  if (replacement > 0x7f) {",
            "+    return -1;",
            "+  }",
            "+",
            "+  while ('\\0' != *read) {",
            "+    if (0xf0 == (0xf8 & *read)) {",
            "+      /* ensure each of the 3 following bytes in this 4-byte",
            "+       * utf8 codepoint began with 0b10xxxxxx */",
            "+      if ((0x80 != (0xc0 & read[1])) || (0x80 != (0xc0 & read[2])) ||",
            "+          (0x80 != (0xc0 & read[3]))) {",
            "+        *write++ = r;",
            "+        read++;",
            "+        continue;",
            "+      }",
            " ",
            "-  if (0xf0 == (0xf8 & s[0])) {",
            "-    // 4 byte utf8 codepoint",
            "-    *out_codepoint = ((0x07 & s[0]) << 18) | ((0x3f & s[1]) << 12) |",
            "-                     ((0x3f & s[2]) << 6) | (0x3f & s[3]);",
            "-    s += 4;",
            "-  } else if (0xe0 == (0xf0 & s[0])) {",
            "-    // 3 byte utf8 codepoint",
            "+      /* 4-byte utf8 code point (began with 0b11110xxx) */",
            "+      read = utf8codepoint(read, &codepoint);",
            "+      write = utf8catcodepoint(write, codepoint, 4);",
            "+    } else if (0xe0 == (0xf0 & *read)) {",
            "+      /* ensure each of the 2 following bytes in this 3-byte",
            "+       * utf8 codepoint began with 0b10xxxxxx */",
            "+      if ((0x80 != (0xc0 & read[1])) || (0x80 != (0xc0 & read[2]))) {",
            "+        *write++ = r;",
            "+        read++;",
            "+        continue;",
            "+      }",
            "+",
            "+      /* 3-byte utf8 code point (began with 0b1110xxxx) */",
            "+      read = utf8codepoint(read, &codepoint);",
            "+      write = utf8catcodepoint(write, codepoint, 3);",
            "+    } else if (0xc0 == (0xe0 & *read)) {",
            "+      /* ensure the 1 following byte in this 2-byte",
            "+       * utf8 codepoint began with 0b10xxxxxx */",
            "+      if (0x80 != (0xc0 & read[1])) {",
            "+        *write++ = r;",
            "+        read++;",
            "+        continue;",
            "+      }",
            "+",
            "+      /* 2-byte utf8 code point (began with 0b110xxxxx) */",
            "+      read = utf8codepoint(read, &codepoint);",
            "+      write = utf8catcodepoint(write, codepoint, 2);",
            "+    } else if (0x00 == (0x80 & *read)) {",
            "+      /* 1-byte ascii (began with 0b0xxxxxxx) */",
            "+      read = utf8codepoint(read, &codepoint);",
            "+      write = utf8catcodepoint(write, codepoint, 1);",
            "+    } else {",
            "+      /* if we got here then we've got a dangling continuation (0b10xxxxxx) */",
            "+      *write++ = r;",
            "+      read++;",
            "+      continue;",
            "+    }",
            "+  }",
            "+",
            "+  *write = '\\0';",
            "+",
            "+  return 0;",
            "+}",
            "+",
            "+utf8_constexpr14_impl utf8_int8_t *",
            "+utf8codepoint(const utf8_int8_t *utf8_restrict str,",
            "+              utf8_int32_t *utf8_restrict out_codepoint) {",
            "+  if (0xf0 == (0xf8 & str[0])) {",
            "+    /* 4 byte utf8 codepoint */",
            "+    *out_codepoint = ((0x07 & str[0]) << 18) | ((0x3f & str[1]) << 12) |",
            "+                     ((0x3f & str[2]) << 6) | (0x3f & str[3]);",
            "+    str += 4;",
            "+  } else if (0xe0 == (0xf0 & str[0])) {",
            "+    /* 3 byte utf8 codepoint */",
            "     *out_codepoint =",
            "-        ((0x0f & s[0]) << 12) | ((0x3f & s[1]) << 6) | (0x3f & s[2]);",
            "-    s += 3;",
            "-  } else if (0xc0 == (0xe0 & s[0])) {",
            "-    // 2 byte utf8 codepoint",
            "-    *out_codepoint = ((0x1f & s[0]) << 6) | (0x3f & s[1]);",
            "-    s += 2;",
            "+        ((0x0f & str[0]) << 12) | ((0x3f & str[1]) << 6) | (0x3f & str[2]);",
            "+    str += 3;",
            "+  } else if (0xc0 == (0xe0 & str[0])) {",
            "+    /* 2 byte utf8 codepoint */",
            "+    *out_codepoint = ((0x1f & str[0]) << 6) | (0x3f & str[1]);",
            "+    str += 2;",
            "   } else {",
            "-    // 1 byte utf8 codepoint otherwise",
            "-    *out_codepoint = s[0];",
            "-    s += 1;",
            "+    /* 1 byte utf8 codepoint otherwise */",
            "+    *out_codepoint = str[0];",
            "+    str += 1;",
            "   }",
            " ",
            "-  return (void *)s;",
            "+  return (utf8_int8_t *)str;",
            " }",
            " ",
            "-size_t utf8codepointsize(utf8_int32_t chr) {",
            "+utf8_constexpr14_impl size_t utf8codepointcalcsize(const utf8_int8_t *str) {",
            "+  if (0xf0 == (0xf8 & str[0])) {",
            "+    /* 4 byte utf8 codepoint */",
            "+    return 4;",
            "+  } else if (0xe0 == (0xf0 & str[0])) {",
            "+    /* 3 byte utf8 codepoint */",
            "+    return 3;",
            "+  } else if (0xc0 == (0xe0 & str[0])) {",
            "+    /* 2 byte utf8 codepoint */",
            "+    return 2;",
            "+  }",
            "+",
            "+  /* 1 byte utf8 codepoint otherwise */",
            "+  return 1;",
            "+}",
            "+",
            "+utf8_constexpr14_impl size_t utf8codepointsize(utf8_int32_t chr) {",
            "   if (0 == ((utf8_int32_t)0xffffff80 & chr)) {",
            "     return 1;",
            "   } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {",
            "     return 2;",
            "   } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {",
            "     return 3;",
            "-  } else { // if (0 == ((int)0xffe00000 & chr)) {",
            "+  } else { /* if (0 == ((int)0xffe00000 & chr)) { */",
            "     return 4;",
            "   }",
            " }",
            " ",
            "-void *utf8catcodepoint(void *utf8_restrict str, utf8_int32_t chr, size_t n) {",
            "-  char *s = (char *)str;",
            "-",
            "+utf8_int8_t *utf8catcodepoint(utf8_int8_t *str, utf8_int32_t chr, size_t n) {",
            "   if (0 == ((utf8_int32_t)0xffffff80 & chr)) {",
            "-    // 1-byte/7-bit ascii",
            "-    // (0b0xxxxxxx)",
            "+    /* 1-byte/7-bit ascii",
            "+     * (0b0xxxxxxx) */",
            "     if (n < 1) {",
            "       return utf8_null;",
            "     }",
            "-    s[0] = (char)chr;",
            "-    s += 1;",
            "+    str[0] = (utf8_int8_t)chr;",
            "+    str += 1;",
            "   } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {",
            "-    // 2-byte/11-bit utf8 code point",
            "-    // (0b110xxxxx 0b10xxxxxx)",
            "+    /* 2-byte/11-bit utf8 code point",
            "+     * (0b110xxxxx 0b10xxxxxx) */",
            "     if (n < 2) {",
            "       return utf8_null;",
            "     }",
            "-    s[0] = 0xc0 | (char)(chr >> 6);",
            "-    s[1] = 0x80 | (char)(chr & 0x3f);",
            "-    s += 2;",
            "+    str[0] = (utf8_int8_t)(0xc0 | (utf8_int8_t)((chr >> 6) & 0x1f));",
            "+    str[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+    str += 2;",
            "   } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {",
            "-    // 3-byte/16-bit utf8 code point",
            "-    // (0b1110xxxx 0b10xxxxxx 0b10xxxxxx)",
            "+    /* 3-byte/16-bit utf8 code point",
            "+     * (0b1110xxxx 0b10xxxxxx 0b10xxxxxx) */",
            "     if (n < 3) {",
            "       return utf8_null;",
            "     }",
            "-    s[0] = 0xe0 | (char)(chr >> 12);",
            "-    s[1] = 0x80 | (char)((chr >> 6) & 0x3f);",
            "-    s[2] = 0x80 | (char)(chr & 0x3f);",
            "-    s += 3;",
            "-  } else { // if (0 == ((int)0xffe00000 & chr)) {",
            "-    // 4-byte/21-bit utf8 code point",
            "-    // (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx)",
            "+    str[0] = (utf8_int8_t)(0xe0 | (utf8_int8_t)((chr >> 12) & 0x0f));",
            "+    str[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));",
            "+    str[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+    str += 3;",
            "+  } else { /* if (0 == ((int)0xffe00000 & chr)) { */",
            "+    /* 4-byte/21-bit utf8 code point",
            "+     * (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx) */",
            "     if (n < 4) {",
            "       return utf8_null;",
            "     }",
            "-    s[0] = 0xf0 | (char)(chr >> 18);",
            "-    s[1] = 0x80 | (char)((chr >> 12) & 0x3f);",
            "-    s[2] = 0x80 | (char)((chr >> 6) & 0x3f);",
            "-    s[3] = 0x80 | (char)(chr & 0x3f);",
            "-    s += 4;",
            "+    str[0] = (utf8_int8_t)(0xf0 | (utf8_int8_t)((chr >> 18) & 0x07));",
            "+    str[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 12) & 0x3f));",
            "+    str[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));",
            "+    str[3] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));",
            "+    str += 4;",
            "   }",
            " ",
            "-  return s;",
            "+  return str;",
            " }",
            " ",
            "-int utf8islower(utf8_int32_t chr) { return chr != utf8uprcodepoint(chr); }",
            "-",
            "-int utf8isupper(utf8_int32_t chr) { return chr != utf8lwrcodepoint(chr); }",
            "+utf8_constexpr14_impl int utf8islower(utf8_int32_t chr) {",
            "+  return chr != utf8uprcodepoint(chr);",
            "+}",
            " ",
            "-void utf8lwr(void *utf8_restrict str) {",
            "-  void *p, *pn;",
            "-  utf8_int32_t cp;",
            "+utf8_constexpr14_impl int utf8isupper(utf8_int32_t chr) {",
            "+  return chr != utf8lwrcodepoint(chr);",
            "+}",
            " ",
            "-  p = (char *)str;",
            "-  pn = utf8codepoint(p, &cp);",
            "+void utf8lwr(utf8_int8_t *utf8_restrict str) {",
            "+  utf8_int32_t cp = 0;",
            "+  utf8_int8_t *pn = utf8codepoint(str, &cp);",
            " ",
            "   while (cp != 0) {",
            "     const utf8_int32_t lwr_cp = utf8lwrcodepoint(cp);",
            "     const size_t size = utf8codepointsize(lwr_cp);",
            " ",
            "     if (lwr_cp != cp) {",
            "-      utf8catcodepoint(p, lwr_cp, size);",
            "+      utf8catcodepoint(str, lwr_cp, size);",
            "     }",
            " ",
            "-    p = pn;",
            "-    pn = utf8codepoint(p, &cp);",
            "+    str = pn;",
            "+    pn = utf8codepoint(str, &cp);",
            "   }",
            " }",
            " ",
            "-void utf8upr(void *utf8_restrict str) {",
            "-  void *p, *pn;",
            "-  utf8_int32_t cp;",
            "-",
            "-  p = (char *)str;",
            "-  pn = utf8codepoint(p, &cp);",
            "+void utf8upr(utf8_int8_t *utf8_restrict str) {",
            "+  utf8_int32_t cp = 0;",
            "+  utf8_int8_t *pn = utf8codepoint(str, &cp);",
            " ",
            "   while (cp != 0) {",
            "     const utf8_int32_t lwr_cp = utf8uprcodepoint(cp);",
            "     const size_t size = utf8codepointsize(lwr_cp);",
            " ",
            "     if (lwr_cp != cp) {",
            "-      utf8catcodepoint(p, lwr_cp, size);",
            "+      utf8catcodepoint(str, lwr_cp, size);",
            "     }",
            " ",
            "-    p = pn;",
            "-    pn = utf8codepoint(p, &cp);",
            "+    str = pn;",
            "+    pn = utf8codepoint(str, &cp);",
            "   }",
            " }",
            " ",
            "-utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp) {",
            "+utf8_constexpr14_impl utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp) {",
            "   if (((0x0041 <= cp) && (0x005a >= cp)) ||",
            "       ((0x00c0 <= cp) && (0x00d6 >= cp)) ||",
            "       ((0x00d8 <= cp) && (0x00de >= cp)) ||",
            "       ((0x0391 <= cp) && (0x03a1 >= cp)) ||",
            "-      ((0x03a3 <= cp) && (0x03ab >= cp))) {",
            "+      ((0x03a3 <= cp) && (0x03ab >= cp)) ||",
            "+      ((0x0410 <= cp) && (0x042f >= cp))) {",
            "     cp += 32;",
            "+  } else if ((0x0400 <= cp) && (0x040f >= cp)) {",
            "+    cp += 80;",
            "   } else if (((0x0100 <= cp) && (0x012f >= cp)) ||",
            "              ((0x0132 <= cp) && (0x0137 >= cp)) ||",
            "              ((0x014a <= cp) && (0x0177 >= cp)) ||",
            "              ((0x0182 <= cp) && (0x0185 >= cp)) ||",
            "              ((0x01a0 <= cp) && (0x01a5 >= cp)) ||",
            "              ((0x01de <= cp) && (0x01ef >= cp)) ||",
            "              ((0x01f8 <= cp) && (0x021f >= cp)) ||",
            "              ((0x0222 <= cp) && (0x0233 >= cp)) ||",
            "              ((0x0246 <= cp) && (0x024f >= cp)) ||",
            "-             ((0x03d8 <= cp) && (0x03ef >= cp))) {",
            "+             ((0x03d8 <= cp) && (0x03ef >= cp)) ||",
            "+             ((0x0460 <= cp) && (0x0481 >= cp)) ||",
            "+             ((0x048a <= cp) && (0x04ff >= cp))) {",
            "     cp |= 0x1;",
            "   } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||",
            "              ((0x0179 <= cp) && (0x017e >= cp)) ||",
            "              ((0x01af <= cp) && (0x01b0 >= cp)) ||",
            "              ((0x01b3 <= cp) && (0x01b6 >= cp)) ||",
            "              ((0x01cd <= cp) && (0x01dc >= cp))) {",
            "     cp += 1;",
            "     cp &= ~0x1;",
            "   } else {",
            "     switch (cp) {",
            "-    default: break;",
            "-    case 0x0178: cp = 0x00ff; break;",
            "-    case 0x0243: cp = 0x0180; break;",
            "-    case 0x018e: cp = 0x01dd; break;",
            "-    case 0x023d: cp = 0x019a; break;",
            "-    case 0x0220: cp = 0x019e; break;",
            "-    case 0x01b7: cp = 0x0292; break;",
            "-    case 0x01c4: cp = 0x01c6; break;",
            "-    case 0x01c7: cp = 0x01c9; break;",
            "-    case 0x01ca: cp = 0x01cc; break;",
            "-    case 0x01f1: cp = 0x01f3; break;",
            "-    case 0x01f7: cp = 0x01bf; break;",
            "-    case 0x0187: cp = 0x0188; break;",
            "-    case 0x018b: cp = 0x018c; break;",
            "-    case 0x0191: cp = 0x0192; break;",
            "-    case 0x0198: cp = 0x0199; break;",
            "-    case 0x01a7: cp = 0x01a8; break;",
            "-    case 0x01ac: cp = 0x01ad; break;",
            "-    case 0x01af: cp = 0x01b0; break;",
            "-    case 0x01b8: cp = 0x01b9; break;",
            "-    case 0x01bc: cp = 0x01bd; break;",
            "-    case 0x01f4: cp = 0x01f5; break;",
            "-    case 0x023b: cp = 0x023c; break;",
            "-    case 0x0241: cp = 0x0242; break;",
            "-    case 0x03fd: cp = 0x037b; break;",
            "-    case 0x03fe: cp = 0x037c; break;",
            "-    case 0x03ff: cp = 0x037d; break;",
            "-    case 0x037f: cp = 0x03f3; break;",
            "-    case 0x0386: cp = 0x03ac; break;",
            "-    case 0x0388: cp = 0x03ad; break;",
            "-    case 0x0389: cp = 0x03ae; break;",
            "-    case 0x038a: cp = 0x03af; break;",
            "-    case 0x038c: cp = 0x03cc; break;",
            "-    case 0x038e: cp = 0x03cd; break;",
            "-    case 0x038f: cp = 0x03ce; break;",
            "-    case 0x0370: cp = 0x0371; break;",
            "-    case 0x0372: cp = 0x0373; break;",
            "-    case 0x0376: cp = 0x0377; break;",
            "-    case 0x03f4: cp = 0x03d1; break;",
            "-    case 0x03cf: cp = 0x03d7; break;",
            "-    case 0x03f9: cp = 0x03f2; break;",
            "-    case 0x03f7: cp = 0x03f8; break;",
            "-    case 0x03fa: cp = 0x03fb; break;",
            "-    };",
            "+    default:",
            "+      break;",
            "+    case 0x0178:",
            "+      cp = 0x00ff;",
            "+      break;",
            "+    case 0x0243:",
            "+      cp = 0x0180;",
            "+      break;",
            "+    case 0x018e:",
            "+      cp = 0x01dd;",
            "+      break;",
            "+    case 0x023d:",
            "+      cp = 0x019a;",
            "+      break;",
            "+    case 0x0220:",
            "+      cp = 0x019e;",
            "+      break;",
            "+    case 0x01b7:",
            "+      cp = 0x0292;",
            "+      break;",
            "+    case 0x01c4:",
            "+      cp = 0x01c6;",
            "+      break;",
            "+    case 0x01c7:",
            "+      cp = 0x01c9;",
            "+      break;",
            "+    case 0x01ca:",
            "+      cp = 0x01cc;",
            "+      break;",
            "+    case 0x01f1:",
            "+      cp = 0x01f3;",
            "+      break;",
            "+    case 0x01f7:",
            "+      cp = 0x01bf;",
            "+      break;",
            "+    case 0x0187:",
            "+      cp = 0x0188;",
            "+      break;",
            "+    case 0x018b:",
            "+      cp = 0x018c;",
            "+      break;",
            "+    case 0x0191:",
            "+      cp = 0x0192;",
            "+      break;",
            "+    case 0x0198:",
            "+      cp = 0x0199;",
            "+      break;",
            "+    case 0x01a7:",
            "+      cp = 0x01a8;",
            "+      break;",
            "+    case 0x01ac:",
            "+      cp = 0x01ad;",
            "+      break;",
            "+    case 0x01b8:",
            "+      cp = 0x01b9;",
            "+      break;",
            "+    case 0x01bc:",
            "+      cp = 0x01bd;",
            "+      break;",
            "+    case 0x01f4:",
            "+      cp = 0x01f5;",
            "+      break;",
            "+    case 0x023b:",
            "+      cp = 0x023c;",
            "+      break;",
            "+    case 0x0241:",
            "+      cp = 0x0242;",
            "+      break;",
            "+    case 0x03fd:",
            "+      cp = 0x037b;",
            "+      break;",
            "+    case 0x03fe:",
            "+      cp = 0x037c;",
            "+      break;",
            "+    case 0x03ff:",
            "+      cp = 0x037d;",
            "+      break;",
            "+    case 0x037f:",
            "+      cp = 0x03f3;",
            "+      break;",
            "+    case 0x0386:",
            "+      cp = 0x03ac;",
            "+      break;",
            "+    case 0x0388:",
            "+      cp = 0x03ad;",
            "+      break;",
            "+    case 0x0389:",
            "+      cp = 0x03ae;",
            "+      break;",
            "+    case 0x038a:",
            "+      cp = 0x03af;",
            "+      break;",
            "+    case 0x038c:",
            "+      cp = 0x03cc;",
            "+      break;",
            "+    case 0x038e:",
            "+      cp = 0x03cd;",
            "+      break;",
            "+    case 0x038f:",
            "+      cp = 0x03ce;",
            "+      break;",
            "+    case 0x0370:",
            "+      cp = 0x0371;",
            "+      break;",
            "+    case 0x0372:",
            "+      cp = 0x0373;",
            "+      break;",
            "+    case 0x0376:",
            "+      cp = 0x0377;",
            "+      break;",
            "+    case 0x03f4:",
            "+      cp = 0x03b8;",
            "+      break;",
            "+    case 0x03cf:",
            "+      cp = 0x03d7;",
            "+      break;",
            "+    case 0x03f9:",
            "+      cp = 0x03f2;",
            "+      break;",
            "+    case 0x03f7:",
            "+      cp = 0x03f8;",
            "+      break;",
            "+    case 0x03fa:",
            "+      cp = 0x03fb;",
            "+      break;",
            "+    }",
            "   }",
            " ",
            "   return cp;",
            " }",
            " ",
            "-utf8_int32_t utf8uprcodepoint(utf8_int32_t cp) {",
            "+utf8_constexpr14_impl utf8_int32_t utf8uprcodepoint(utf8_int32_t cp) {",
            "   if (((0x0061 <= cp) && (0x007a >= cp)) ||",
            "       ((0x00e0 <= cp) && (0x00f6 >= cp)) ||",
            "       ((0x00f8 <= cp) && (0x00fe >= cp)) ||",
            "       ((0x03b1 <= cp) && (0x03c1 >= cp)) ||",
            "-      ((0x03c3 <= cp) && (0x03cb >= cp))) {",
            "+      ((0x03c3 <= cp) && (0x03cb >= cp)) ||",
            "+      ((0x0430 <= cp) && (0x044f >= cp))) {",
            "     cp -= 32;",
            "+  } else if ((0x0450 <= cp) && (0x045f >= cp)) {",
            "+    cp -= 80;",
            "   } else if (((0x0100 <= cp) && (0x012f >= cp)) ||",
            "              ((0x0132 <= cp) && (0x0137 >= cp)) ||",
            "              ((0x014a <= cp) && (0x0177 >= cp)) ||",
            "              ((0x0182 <= cp) && (0x0185 >= cp)) ||",
            "              ((0x01a0 <= cp) && (0x01a5 >= cp)) ||",
            "              ((0x01de <= cp) && (0x01ef >= cp)) ||",
            "              ((0x01f8 <= cp) && (0x021f >= cp)) ||",
            "              ((0x0222 <= cp) && (0x0233 >= cp)) ||",
            "              ((0x0246 <= cp) && (0x024f >= cp)) ||",
            "-             ((0x03d8 <= cp) && (0x03ef >= cp))) {",
            "+             ((0x03d8 <= cp) && (0x03ef >= cp)) ||",
            "+             ((0x0460 <= cp) && (0x0481 >= cp)) ||",
            "+             ((0x048a <= cp) && (0x04ff >= cp))) {",
            "     cp &= ~0x1;",
            "   } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||",
            "              ((0x0179 <= cp) && (0x017e >= cp)) ||",
            "              ((0x01af <= cp) && (0x01b0 >= cp)) ||",
            "              ((0x01b3 <= cp) && (0x01b6 >= cp)) ||",
            "              ((0x01cd <= cp) && (0x01dc >= cp))) {",
            "     cp -= 1;",
            "     cp |= 0x1;",
            "   } else {",
            "     switch (cp) {",
            "-    default: break;",
            "-    case 0x00ff: cp = 0x0178; break;",
            "-    case 0x0180: cp = 0x0243; break;",
            "-    case 0x01dd: cp = 0x018e; break;",
            "-    case 0x019a: cp = 0x023d; break;",
            "-    case 0x019e: cp = 0x0220; break;",
            "-    case 0x0292: cp = 0x01b7; break;",
            "-    case 0x01c6: cp = 0x01c4; break;",
            "-    case 0x01c9: cp = 0x01c7; break;",
            "-    case 0x01cc: cp = 0x01ca; break;",
            "-    case 0x01f3: cp = 0x01f1; break;",
            "-    case 0x01bf: cp = 0x01f7; break;",
            "-    case 0x0188: cp = 0x0187; break;",
            "-    case 0x018c: cp = 0x018b; break;",
            "-    case 0x0192: cp = 0x0191; break;",
            "-    case 0x0199: cp = 0x0198; break;",
            "-    case 0x01a8: cp = 0x01a7; break;",
            "-    case 0x01ad: cp = 0x01ac; break;",
            "-    case 0x01b0: cp = 0x01af; break;",
            "-    case 0x01b9: cp = 0x01b8; break;",
            "-    case 0x01bd: cp = 0x01bc; break;",
            "-    case 0x01f5: cp = 0x01f4; break;",
            "-    case 0x023c: cp = 0x023b; break;",
            "-    case 0x0242: cp = 0x0241; break;",
            "-    case 0x037b: cp = 0x03fd; break;",
            "-    case 0x037c: cp = 0x03fe; break;",
            "-    case 0x037d: cp = 0x03ff; break;",
            "-    case 0x03f3: cp = 0x037f; break;",
            "-    case 0x03ac: cp = 0x0386; break;",
            "-    case 0x03ad: cp = 0x0388; break;",
            "-    case 0x03ae: cp = 0x0389; break;",
            "-    case 0x03af: cp = 0x038a; break;",
            "-    case 0x03cc: cp = 0x038c; break;",
            "-    case 0x03cd: cp = 0x038e; break;",
            "-    case 0x03ce: cp = 0x038f; break;",
            "-    case 0x0371: cp = 0x0370; break;",
            "-    case 0x0373: cp = 0x0372; break;",
            "-    case 0x0377: cp = 0x0376; break;",
            "-    case 0x03d1: cp = 0x03f4; break;",
            "-    case 0x03d7: cp = 0x03cf; break;",
            "-    case 0x03f2: cp = 0x03f9; break;",
            "-    case 0x03f8: cp = 0x03f7; break;",
            "-    case 0x03fb: cp = 0x03fa; break;",
            "-    };",
            "+    default:",
            "+      break;",
            "+    case 0x00ff:",
            "+      cp = 0x0178;",
            "+      break;",
            "+    case 0x0180:",
            "+      cp = 0x0243;",
            "+      break;",
            "+    case 0x01dd:",
            "+      cp = 0x018e;",
            "+      break;",
            "+    case 0x019a:",
            "+      cp = 0x023d;",
            "+      break;",
            "+    case 0x019e:",
            "+      cp = 0x0220;",
            "+      break;",
            "+    case 0x0292:",
            "+      cp = 0x01b7;",
            "+      break;",
            "+    case 0x01c6:",
            "+      cp = 0x01c4;",
            "+      break;",
            "+    case 0x01c9:",
            "+      cp = 0x01c7;",
            "+      break;",
            "+    case 0x01cc:",
            "+      cp = 0x01ca;",
            "+      break;",
            "+    case 0x01f3:",
            "+      cp = 0x01f1;",
            "+      break;",
            "+    case 0x01bf:",
            "+      cp = 0x01f7;",
            "+      break;",
            "+    case 0x0188:",
            "+      cp = 0x0187;",
            "+      break;",
            "+    case 0x018c:",
            "+      cp = 0x018b;",
            "+      break;",
            "+    case 0x0192:",
            "+      cp = 0x0191;",
            "+      break;",
            "+    case 0x0199:",
            "+      cp = 0x0198;",
            "+      break;",
            "+    case 0x01a8:",
            "+      cp = 0x01a7;",
            "+      break;",
            "+    case 0x01ad:",
            "+      cp = 0x01ac;",
            "+      break;",
            "+    case 0x01b9:",
            "+      cp = 0x01b8;",
            "+      break;",
            "+    case 0x01bd:",
            "+      cp = 0x01bc;",
            "+      break;",
            "+    case 0x01f5:",
            "+      cp = 0x01f4;",
            "+      break;",
            "+    case 0x023c:",
            "+      cp = 0x023b;",
            "+      break;",
            "+    case 0x0242:",
            "+      cp = 0x0241;",
            "+      break;",
            "+    case 0x037b:",
            "+      cp = 0x03fd;",
            "+      break;",
            "+    case 0x037c:",
            "+      cp = 0x03fe;",
            "+      break;",
            "+    case 0x037d:",
            "+      cp = 0x03ff;",
            "+      break;",
            "+    case 0x03f3:",
            "+      cp = 0x037f;",
            "+      break;",
            "+    case 0x03ac:",
            "+      cp = 0x0386;",
            "+      break;",
            "+    case 0x03ad:",
            "+      cp = 0x0388;",
            "+      break;",
            "+    case 0x03ae:",
            "+      cp = 0x0389;",
            "+      break;",
            "+    case 0x03af:",
            "+      cp = 0x038a;",
            "+      break;",
            "+    case 0x03cc:",
            "+      cp = 0x038c;",
            "+      break;",
            "+    case 0x03cd:",
            "+      cp = 0x038e;",
            "+      break;",
            "+    case 0x03ce:",
            "+      cp = 0x038f;",
            "+      break;",
            "+    case 0x0371:",
            "+      cp = 0x0370;",
            "+      break;",
            "+    case 0x0373:",
            "+      cp = 0x0372;",
            "+      break;",
            "+    case 0x0377:",
            "+      cp = 0x0376;",
            "+      break;",
            "+    case 0x03d1:",
            "+      cp = 0x0398;",
            "+      break;",
            "+    case 0x03d7:",
            "+      cp = 0x03cf;",
            "+      break;",
            "+    case 0x03f2:",
            "+      cp = 0x03f9;",
            "+      break;",
            "+    case 0x03f8:",
            "+      cp = 0x03f7;",
            "+      break;",
            "+    case 0x03fb:",
            "+      cp = 0x03fa;",
            "+      break;",
            "+    }",
            "   }",
            " ",
            "   return cp;",
            " }",
            " ",
            "+utf8_constexpr14_impl utf8_int8_t *",
            "+utf8rcodepoint(const utf8_int8_t *utf8_restrict str,",
            "+               utf8_int32_t *utf8_restrict out_codepoint) {",
            "+  const utf8_int8_t *s = (const utf8_int8_t *)str;",
            "+",
            "+  if (0xf0 == (0xf8 & s[0])) {",
            "+    /* 4 byte utf8 codepoint */",
            "+    *out_codepoint = ((0x07 & s[0]) << 18) | ((0x3f & s[1]) << 12) |",
            "+                     ((0x3f & s[2]) << 6) | (0x3f & s[3]);",
            "+  } else if (0xe0 == (0xf0 & s[0])) {",
            "+    /* 3 byte utf8 codepoint */",
            "+    *out_codepoint =",
            "+        ((0x0f & s[0]) << 12) | ((0x3f & s[1]) << 6) | (0x3f & s[2]);",
            "+  } else if (0xc0 == (0xe0 & s[0])) {",
            "+    /* 2 byte utf8 codepoint */",
            "+    *out_codepoint = ((0x1f & s[0]) << 6) | (0x3f & s[1]);",
            "+  } else {",
            "+    /* 1 byte utf8 codepoint otherwise */",
            "+    *out_codepoint = s[0];",
            "+  }",
            "+",
            "+  do {",
            "+    s--;",
            "+  } while ((0 != (0x80 & s[0])) && (0x80 == (0xc0 & s[0])));",
            "+",
            "+  return (utf8_int8_t *)s;",
            "+}",
            "+",
            " #undef utf8_restrict",
            "+#undef utf8_constexpr14",
            " #undef utf8_null",
            " ",
            "-#ifdef __cplusplus",
            "-} // extern \"C\"",
            "+#ifdef utf8_cplusplus",
            "+} /* extern \"C\" */",
            " #endif",
            " ",
            " #if defined(__clang__)",
            " #pragma clang diagnostic pop",
            " #endif",
            " ",
            "-#endif // SHEREDOM_UTF8_H_INCLUDED",
            "+#endif /* SHEREDOM_UTF8_H_INCLUDED */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/ntlmclient/util.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/ntlmclient/util.h",
            "+++ /home/libgit2-1.9.1/deps/ntlmclient/util.h",
            "@@ -5,11 +5,22 @@",
            "  * For full terms and copyright information, and for third-party",
            "  * copyright information, see the included LICENSE.txt file.",
            "  */",
            " ",
            " #ifndef PRIVATE_UTIL_H__",
            " #define PRIVATE_UTIL_H__",
            " ",
            "+#include <stddef.h>",
            "+#include <stdint.h>",
            "+",
            "+#if defined(_MSC_VER)",
            "+# define NTLM_INLINE(type) static __inline type",
            "+#elif defined(__GNUC__)",
            "+# define NTLM_INLINE(type) static __inline__ type",
            "+#else",
            "+# define NTLM_INLINE(type) static type",
            "+#endif",
            "+",
            " extern void ntlm_memzero(void *data, size_t size);",
            " extern uint64_t ntlm_htonll(uint64_t value);",
            " ",
            " #endif /* PRIVATE_UTIL_H__ */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/deflate.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/deflate.c",
            "+++ /home/libgit2-1.9.1/deps/zlib/deflate.c",
            "@@ -1,9 +1,9 @@",
            " /* deflate.c -- compress data using the deflation algorithm",
            "- * Copyright (C) 1995-2023 Jean-loup Gailly and Mark Adler",
            "+ * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " /*",
            "  *  ALGORITHM",
            "  *",
            "  *      The \"deflation\" process depends on being able to identify portions",
            "@@ -48,15 +48,15 @@",
            "  */",
            " ",
            " /* @(#) $Id$ */",
            " ",
            " #include \"deflate.h\"",
            " ",
            " const char deflate_copyright[] =",
            "-   \" deflate 1.3 Copyright 1995-2023 Jean-loup Gailly and Mark Adler \";",
            "+   \" deflate 1.3.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";",
            " /*",
            "   If you use the zlib library in a product, an acknowledgment is welcome",
            "   in the documentation of your product. If for some reason you cannot",
            "   include such an acknowledgment, I would appreciate that you keep this",
            "   copyright string in the executable of your product.",
            "  */",
            " ",
            "@@ -489,26 +489,32 @@",
            "      * blocks. A dynamic-code block will only be chosen to be emitted if it has",
            "      * fewer bits than a fixed-code block would for the same set of symbols.",
            "      * Therefore its average symbol length is assured to be less than 31. So",
            "      * the compressed data for a dynamic block also cannot overwrite the",
            "      * symbols from which it is being constructed.",
            "      */",
            " ",
            "-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);",
            "+    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);",
            "     s->pending_buf_size = (ulg)s->lit_bufsize * 4;",
            " ",
            "     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||",
            "         s->pending_buf == Z_NULL) {",
            "         s->status = FINISH_STATE;",
            "         strm->msg = ERR_MSG(Z_MEM_ERROR);",
            "         deflateEnd (strm);",
            "         return Z_MEM_ERROR;",
            "     }",
            "+#ifdef LIT_MEM",
            "+    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));",
            "+    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);",
            "+    s->sym_end = s->lit_bufsize - 1;",
            "+#else",
            "     s->sym_buf = s->pending_buf + s->lit_bufsize;",
            "     s->sym_end = (s->lit_bufsize - 1) * 3;",
            "+#endif",
            "     /* We avoid equality with lit_bufsize*3 because of wraparound at 64K",
            "      * on 16 bit machines and because stored blocks are restricted to",
            "      * 64K-1 bytes.",
            "      */",
            " ",
            "     s->level = level;",
            "     s->strategy = strategy;",
            "@@ -716,17 +722,23 @@",
            " /* ========================================================================= */",
            " int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {",
            "     deflate_state *s;",
            "     int put;",
            " ",
            "     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;",
            "     s = strm->state;",
            "+#ifdef LIT_MEM",
            "+    if (bits < 0 || bits > 16 ||",
            "+        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))",
            "+        return Z_BUF_ERROR;",
            "+#else",
            "     if (bits < 0 || bits > 16 ||",
            "         s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))",
            "         return Z_BUF_ERROR;",
            "+#endif",
            "     do {",
            "         put = Buf_size - s->bi_valid;",
            "         if (put > bits)",
            "             put = bits;",
            "         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);",
            "         s->bi_valid += put;",
            "         _tr_flush_bits(s);",
            "@@ -1290,29 +1302,34 @@",
            "     dest->state = (struct internal_state FAR *) ds;",
            "     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));",
            "     ds->strm = dest;",
            " ",
            "     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));",
            "     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));",
            "     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));",
            "-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);",
            "+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);",
            " ",
            "     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||",
            "         ds->pending_buf == Z_NULL) {",
            "         deflateEnd (dest);",
            "         return Z_MEM_ERROR;",
            "     }",
            "     /* following zmemcpy do not work for 16-bit MSDOS */",
            "     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));",
            "     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));",
            "     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));",
            "-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);",
            "+    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);",
            " ",
            "     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);",
            "+#ifdef LIT_MEM",
            "+    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));",
            "+    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);",
            "+#else",
            "     ds->sym_buf = ds->pending_buf + ds->lit_bufsize;",
            "+#endif",
            " ",
            "     ds->l_desc.dyn_tree = ds->dyn_ltree;",
            "     ds->d_desc.dyn_tree = ds->dyn_dtree;",
            "     ds->bl_desc.dyn_tree = ds->bl_tree;",
            " ",
            "     return Z_OK;",
            " #endif /* MAXSEG_64K */",
            "@@ -1535,21 +1552,29 @@",
            " /* result of memcmp for equal strings */",
            " ",
            " /* ===========================================================================",
            "  * Check that the match at match_start is indeed a match.",
            "  */",
            " local void check_match(deflate_state *s, IPos start, IPos match, int length) {",
            "     /* check that the match is indeed a match */",
            "-    if (zmemcmp(s->window + match,",
            "-                s->window + start, length) != EQUAL) {",
            "-        fprintf(stderr, \" start %u, match %u, length %d\\n\",",
            "-                start, match, length);",
            "+    Bytef *back = s->window + (int)match, *here = s->window + start;",
            "+    IPos len = length;",
            "+    if (match == (IPos)-1) {",
            "+        /* match starts one byte before the current window -- just compare the",
            "+           subsequent length-1 bytes */",
            "+        back++;",
            "+        here++;",
            "+        len--;",
            "+    }",
            "+    if (zmemcmp(back, here, len) != EQUAL) {",
            "+        fprintf(stderr, \" start %u, match %d, length %d\\n\",",
            "+                start, (int)match, length);",
            "         do {",
            "-            fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);",
            "-        } while (--length != 0);",
            "+            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);",
            "+        } while (--len != 0);",
            "         z_error(\"invalid match\");",
            "     }",
            "     if (z_verbose > 1) {",
            "         fprintf(stderr,\"\\\\[%d,%d]\", start - match, length);",
            "         do { putc(s->window[start++], stderr); } while (--length != 0);",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/deflate.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/deflate.h",
            "+++ /home/libgit2-1.9.1/deps/zlib/deflate.h",
            "@@ -1,9 +1,9 @@",
            " /* deflate.h -- internal compression state",
            "- * Copyright (C) 1995-2018 Jean-loup Gailly",
            "+ * Copyright (C) 1995-2024 Jean-loup Gailly",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " /* WARNING: this file should *not* be used by applications. It is",
            "    part of the implementation of the compression library and is",
            "    subject to change. Applications should only use zlib.h.",
            "  */",
            "@@ -19,14 +19,18 @@",
            "    trailer creation by deflate().  NO_GZIP would be used to avoid linking in",
            "    the crc code when it is not needed.  For shared libraries, gzip encoding",
            "    should be left enabled. */",
            " #ifndef NO_GZIP",
            " #  define GZIP",
            " #endif",
            " ",
            "+/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at",
            "+   the cost of a larger memory footprint */",
            "+/* #define LIT_MEM */",
            "+",
            " /* ===========================================================================",
            "  * Internal compression state.",
            "  */",
            " ",
            " #define LENGTH_CODES 29",
            " /* number of length codes, not counting the special END_BLOCK code */",
            " ",
            "@@ -213,15 +217,22 @@",
            "      * The same heap array is used to build all trees.",
            "      */",
            " ",
            "     uch depth[2*L_CODES+1];",
            "     /* Depth of each subtree used as tie breaker for trees of equal frequency",
            "      */",
            " ",
            "+#ifdef LIT_MEM",
            "+#   define LIT_BUFS 5",
            "+    ushf *d_buf;          /* buffer for distances */",
            "+    uchf *l_buf;          /* buffer for literals/lengths */",
            "+#else",
            "+#   define LIT_BUFS 4",
            "     uchf *sym_buf;        /* buffer for distances and literals/lengths */",
            "+#endif",
            " ",
            "     uInt  lit_bufsize;",
            "     /* Size of match buffer for literals/lengths.  There are 4 reasons for",
            "      * limiting lit_bufsize to 64K:",
            "      *   - frequencies can be kept in 16 bit counters",
            "      *   - if compression is not successful for the first block, all input",
            "      *     data is still in the window so we can still emit a stored block even",
            "@@ -235,15 +246,15 @@",
            "      *     example a binary file with poorly compressible code followed by",
            "      *     a highly compressible string table.) Smaller buffer sizes give",
            "      *     fast adaptation but have of course the overhead of transmitting",
            "      *     trees more frequently.",
            "      *   - I can't count above 4",
            "      */",
            " ",
            "-    uInt sym_next;      /* running index in sym_buf */",
            "+    uInt sym_next;      /* running index in symbol buffer */",
            "     uInt sym_end;       /* symbol table full when sym_next reaches this */",
            " ",
            "     ulg opt_len;        /* bit length of current block with optimal trees */",
            "     ulg static_len;     /* bit length of current block with static trees */",
            "     uInt matches;       /* number of string matches in current block */",
            "     uInt insert;        /* bytes at end of window left to insert */",
            " ",
            "@@ -314,14 +325,33 @@",
            "   extern uch ZLIB_INTERNAL _length_code[];",
            "   extern uch ZLIB_INTERNAL _dist_code[];",
            " #else",
            "   extern const uch ZLIB_INTERNAL _length_code[];",
            "   extern const uch ZLIB_INTERNAL _dist_code[];",
            " #endif",
            " ",
            "+#ifdef LIT_MEM",
            "+# define _tr_tally_lit(s, c, flush) \\",
            "+  { uch cc = (c); \\",
            "+    s->d_buf[s->sym_next] = 0; \\",
            "+    s->l_buf[s->sym_next++] = cc; \\",
            "+    s->dyn_ltree[cc].Freq++; \\",
            "+    flush = (s->sym_next == s->sym_end); \\",
            "+   }",
            "+# define _tr_tally_dist(s, distance, length, flush) \\",
            "+  { uch len = (uch)(length); \\",
            "+    ush dist = (ush)(distance); \\",
            "+    s->d_buf[s->sym_next] = dist; \\",
            "+    s->l_buf[s->sym_next++] = len; \\",
            "+    dist--; \\",
            "+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\",
            "+    s->dyn_dtree[d_code(dist)].Freq++; \\",
            "+    flush = (s->sym_next == s->sym_end); \\",
            "+  }",
            "+#else",
            " # define _tr_tally_lit(s, c, flush) \\",
            "   { uch cc = (c); \\",
            "     s->sym_buf[s->sym_next++] = 0; \\",
            "     s->sym_buf[s->sym_next++] = 0; \\",
            "     s->sym_buf[s->sym_next++] = cc; \\",
            "     s->dyn_ltree[cc].Freq++; \\",
            "     flush = (s->sym_next == s->sym_end); \\",
            "@@ -333,14 +363,15 @@",
            "     s->sym_buf[s->sym_next++] = (uch)(dist >> 8); \\",
            "     s->sym_buf[s->sym_next++] = len; \\",
            "     dist--; \\",
            "     s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\",
            "     s->dyn_dtree[d_code(dist)].Freq++; \\",
            "     flush = (s->sym_next == s->sym_end); \\",
            "   }",
            "+#endif",
            " #else",
            " # define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)",
            " # define _tr_tally_dist(s, distance, length, flush) \\",
            "               flush = _tr_tally(s, distance, length)",
            " #endif",
            " ",
            " #endif /* DEFLATE_H */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/gzguts.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/gzguts.h",
            "+++ /home/libgit2-1.9.1/deps/zlib/gzguts.h",
            "@@ -1,9 +1,9 @@",
            " /* gzguts.h -- zlib internal header definitions for gz* operations",
            "- * Copyright (C) 2004-2019 Mark Adler",
            "+ * Copyright (C) 2004-2024 Mark Adler",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " #ifdef _LARGEFILE64_SOURCE",
            " #  ifndef _LARGEFILE_SOURCE",
            " #    define _LARGEFILE_SOURCE 1",
            " #  endif",
            "@@ -206,13 +206,9 @@",
            " #if defined UNDER_CE",
            " char ZLIB_INTERNAL *gz_strwinerror(DWORD error);",
            " #endif",
            " ",
            " /* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t",
            "    value -- needed when comparing unsigned to z_off64_t, which is signed",
            "    (possible z_off64_t types off_t, off64_t, and long are all signed) */",
            "-#ifdef INT_MAX",
            "-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)",
            "-#else",
            " unsigned ZLIB_INTERNAL gz_intmax(void);",
            "-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())",
            "-#endif",
            "+#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/inflate.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/inflate.c",
            "+++ /home/libgit2-1.9.1/deps/zlib/inflate.c",
            "@@ -1383,15 +1383,15 @@",
            "     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;",
            "     state = (struct inflate_state FAR *)strm->state;",
            "     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;",
            " ",
            "     /* if first time, start search in bit buffer */",
            "     if (state->mode != SYNC) {",
            "         state->mode = SYNC;",
            "-        state->hold <<= state->bits & 7;",
            "+        state->hold >>= state->bits & 7;",
            "         state->bits -= state->bits & 7;",
            "         len = 0;",
            "         while (state->bits >= 8) {",
            "             buf[len++] = (unsigned char)(state->hold);",
            "             state->hold >>= 8;",
            "             state->bits -= 8;",
            "         }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/inftrees.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/inftrees.c",
            "+++ /home/libgit2-1.9.1/deps/zlib/inftrees.c",
            "@@ -1,19 +1,19 @@",
            " /* inftrees.c -- generate Huffman trees for efficient decoding",
            "- * Copyright (C) 1995-2023 Mark Adler",
            "+ * Copyright (C) 1995-2024 Mark Adler",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " #include \"zutil.h\"",
            " #include \"inftrees.h\"",
            " ",
            " #define MAXBITS 15",
            " ",
            " const char inflate_copyright[] =",
            "-   \" inflate 1.3 Copyright 1995-2023 Mark Adler \";",
            "+   \" inflate 1.3.1 Copyright 1995-2024 Mark Adler \";",
            " /*",
            "   If you use the zlib library in a product, an acknowledgment is welcome",
            "   in the documentation of your product. If for some reason you cannot",
            "   include such an acknowledgment, I would appreciate that you keep this",
            "   copyright string in the executable of your product.",
            "  */",
            " ",
            "@@ -53,15 +53,15 @@",
            "     unsigned short count[MAXBITS+1];    /* number of codes of each length */",
            "     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */",
            "     static const unsigned short lbase[31] = { /* Length codes 257..285 base */",
            "         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,",
            "         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};",
            "     static const unsigned short lext[31] = { /* Length codes 257..285 extra */",
            "         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,",
            "-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 198, 203};",
            "+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};",
            "     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */",
            "         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,",
            "         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,",
            "         8193, 12289, 16385, 24577, 0, 0};",
            "     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */",
            "         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,",
            "         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/inftrees.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/inftrees.h",
            "+++ /home/libgit2-1.9.1/deps/zlib/inftrees.h",
            "@@ -37,16 +37,16 @@",
            " ",
            " /* Maximum size of the dynamic table.  The maximum number of code structures is",
            "    1444, which is the sum of 852 for literal/length codes and 592 for distance",
            "    codes.  These values were found by exhaustive searches using the program",
            "    examples/enough.c found in the zlib distribution.  The arguments to that",
            "    program are the number of symbols, the initial root table size, and the",
            "    maximum bit length of a code.  \"enough 286 9 15\" for literal/length codes",
            "-   returns returns 852, and \"enough 30 6 15\" for distance codes returns 592.",
            "-   The initial root table size (9 or 6) is found in the fifth argument of the",
            "+   returns 852, and \"enough 30 6 15\" for distance codes returns 592. The",
            "+   initial root table size (9 or 6) is found in the fifth argument of the",
            "    inflate_table() calls in inflate.c and infback.c.  If the root table size is",
            "    changed, then these maximum sizes would be need to be recalculated and",
            "    updated. */",
            " #define ENOUGH_LENS 852",
            " #define ENOUGH_DISTS 592",
            " #define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/trees.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/trees.c",
            "+++ /home/libgit2-1.9.1/deps/zlib/trees.c",
            "@@ -1,9 +1,9 @@",
            " /* trees.c -- output deflated data using Huffman coding",
            "- * Copyright (C) 1995-2021 Jean-loup Gailly",
            "+ * Copyright (C) 1995-2024 Jean-loup Gailly",
            "  * detect_data_type() function provided freely by Cosmin Truta, 2006",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " /*",
            "  *  ALGORITHM",
            "  *",
            "@@ -895,22 +895,27 @@",
            " /* ===========================================================================",
            "  * Send the block data compressed using the given Huffman trees",
            "  */",
            " local void compress_block(deflate_state *s, const ct_data *ltree,",
            "                           const ct_data *dtree) {",
            "     unsigned dist;      /* distance of matched string */",
            "     int lc;             /* match length or unmatched char (if dist == 0) */",
            "-    unsigned sx = 0;    /* running index in sym_buf */",
            "+    unsigned sx = 0;    /* running index in symbol buffers */",
            "     unsigned code;      /* the code to send */",
            "     int extra;          /* number of extra bits to send */",
            " ",
            "     if (s->sym_next != 0) do {",
            "+#ifdef LIT_MEM",
            "+        dist = s->d_buf[sx];",
            "+        lc = s->l_buf[sx++];",
            "+#else",
            "         dist = s->sym_buf[sx++] & 0xff;",
            "         dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;",
            "         lc = s->sym_buf[sx++];",
            "+#endif",
            "         if (dist == 0) {",
            "             send_code(s, lc, ltree); /* send a literal byte */",
            "             Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));",
            "         } else {",
            "             /* Here, lc is the match length - MIN_MATCH */",
            "             code = _length_code[lc];",
            "             send_code(s, code + LITERALS + 1, ltree);   /* send length code */",
            "@@ -927,16 +932,20 @@",
            "             extra = extra_dbits[code];",
            "             if (extra != 0) {",
            "                 dist -= (unsigned)base_dist[code];",
            "                 send_bits(s, dist, extra);   /* send the extra distance bits */",
            "             }",
            "         } /* literal or match pair ? */",
            " ",
            "-        /* Check that the overlay between pending_buf and sym_buf is ok: */",
            "+        /* Check for no overlay of pending_buf on needed symbols */",
            "+#ifdef LIT_MEM",
            "+        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");",
            "+#else",
            "         Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");",
            "+#endif",
            " ",
            "     } while (sx < s->sym_next);",
            " ",
            "     send_code(s, END_BLOCK, ltree);",
            " }",
            " ",
            " /* ===========================================================================",
            "@@ -1078,17 +1087,22 @@",
            " }",
            " ",
            " /* ===========================================================================",
            "  * Save the match info and tally the frequency counts. Return true if",
            "  * the current block must be flushed.",
            "  */",
            " int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc) {",
            "+#ifdef LIT_MEM",
            "+    s->d_buf[s->sym_next] = (ush)dist;",
            "+    s->l_buf[s->sym_next++] = (uch)lc;",
            "+#else",
            "     s->sym_buf[s->sym_next++] = (uch)dist;",
            "     s->sym_buf[s->sym_next++] = (uch)(dist >> 8);",
            "     s->sym_buf[s->sym_next++] = (uch)lc;",
            "+#endif",
            "     if (dist == 0) {",
            "         /* lc is the unmatched char */",
            "         s->dyn_ltree[lc].Freq++;",
            "     } else {",
            "         s->matches++;",
            "         /* Here, lc is the match length - MIN_MATCH */",
            "         dist--;             /* dist = match distance - 1 */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/zconf.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/zconf.h",
            "+++ /home/libgit2-1.9.1/deps/zlib/zconf.h",
            "@@ -1,9 +1,9 @@",
            " /* zconf.h -- configuration of the zlib compression library",
            "- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler",
            "+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " /* @(#) $Id$ */",
            " ",
            " #ifndef ZCONF_H",
            " #define ZCONF_H",
            "@@ -296,22 +296,14 @@",
            " #  ifdef STDC",
            " #    define OF(args)  args",
            " #  else",
            " #    define OF(args)  ()",
            " #  endif",
            " #endif",
            " ",
            "-#ifndef Z_ARG /* function prototypes for stdarg */",
            "-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)",
            "-#    define Z_ARG(args)  args",
            "-#  else",
            "-#    define Z_ARG(args)  ()",
            "-#  endif",
            "-#endif",
            "-",
            " /* The following definitions for FAR are needed only for MSDOS mixed",
            "  * model programming (small or medium model with some far allocations).",
            "  * This was tested only with MSC; for other MSDOS compilers you may have",
            "  * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,",
            "  * just define FAR to be empty.",
            "  */",
            " #ifdef SYS16BIT"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/zlib.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/zlib.h",
            "+++ /home/libgit2-1.9.1/deps/zlib/zlib.h",
            "@@ -1,11 +1,11 @@",
            " /* zlib.h -- interface of the 'zlib' general purpose compression library",
            "-  version 1.3, August 18th, 2023",
            "+  version 1.3.1, January 22nd, 2024",
            " ",
            "-  Copyright (C) 1995-2023 Jean-loup Gailly and Mark Adler",
            "+  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler",
            " ",
            "   This software is provided 'as-is', without any express or implied",
            "   warranty.  In no event will the authors be held liable for any damages",
            "   arising from the use of this software.",
            " ",
            "   Permission is granted to anyone to use this software for any purpose,",
            "   including commercial applications, and to alter it and redistribute it",
            "@@ -33,19 +33,19 @@",
            " ",
            " #include \"zconf.h\"",
            " ",
            " #ifdef __cplusplus",
            " extern \"C\" {",
            " #endif",
            " ",
            "-#define ZLIB_VERSION \"1.3\"",
            "-#define ZLIB_VERNUM 0x1300",
            "+#define ZLIB_VERSION \"1.3.1\"",
            "+#define ZLIB_VERNUM 0x1310",
            " #define ZLIB_VER_MAJOR 1",
            " #define ZLIB_VER_MINOR 3",
            "-#define ZLIB_VER_REVISION 0",
            "+#define ZLIB_VER_REVISION 1",
            " #define ZLIB_VER_SUBREVISION 0",
            " ",
            " /*",
            "     The 'zlib' compression library provides in-memory compression and",
            "   decompression functions, including integrity checks of the uncompressed data.",
            "   This version of the library supports only one compression method (deflation)",
            "   but other algorithms will be added later and will have the same stream",
            "@@ -932,18 +932,18 @@",
            "      inflateSync searches for a 00 00 FF FF pattern in the compressed data.",
            "    All full flush points have this pattern, but not all occurrences of this",
            "    pattern are full flush points.",
            " ",
            "      inflateSync returns Z_OK if a possible full flush point has been found,",
            "    Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point",
            "    has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.",
            "-   In the success case, the application may save the current current value of",
            "-   total_in which indicates where valid compressed data was found.  In the",
            "-   error case, the application may repeatedly call inflateSync, providing more",
            "-   input each time, until success or end of the input data.",
            "+   In the success case, the application may save the current value of total_in",
            "+   which indicates where valid compressed data was found.  In the error case,",
            "+   the application may repeatedly call inflateSync, providing more input each",
            "+   time, until success or end of the input data.",
            " */",
            " ",
            " ZEXTERN int ZEXPORT inflateCopy(z_streamp dest,",
            "                                 z_streamp source);",
            " /*",
            "      Sets the destination stream as a complete copy of the source stream.",
            " ",
            "@@ -1754,22 +1754,22 @@",
            " /*",
            " ZEXTERN uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2);",
            " ",
            "      Combine two CRC-32 check values into one.  For two sequences of bytes,",
            "    seq1 and seq2 with lengths len1 and len2, CRC-32 check values were",
            "    calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32",
            "    check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and",
            "-   len2.",
            "+   len2. len2 must be non-negative.",
            " */",
            " ",
            " /*",
            " ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);",
            " ",
            "      Return the operator corresponding to length len2, to be used with",
            "-   crc32_combine_op().",
            "+   crc32_combine_op(). len2 must be non-negative.",
            " */",
            " ",
            " ZEXTERN uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op);",
            " /*",
            "      Give the same result as crc32_combine(), using op in place of len2. op is",
            "    is generated from len2 by crc32_combine_gen(). This will be faster than",
            "    crc32_combine() if the generated op is used more than once."
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/deps/zlib/zutil.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/deps/zlib/zutil.h",
            "+++ /home/libgit2-1.9.1/deps/zlib/zutil.h",
            "@@ -1,9 +1,9 @@",
            " /* zutil.h -- internal interface and configuration of the compression library",
            "- * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler",
            "+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler",
            "  * For conditions of distribution and use, see copyright notice in zlib.h",
            "  */",
            " ",
            " /* WARNING: this file should *not* be used by applications. It is",
            "    part of the implementation of the compression library and is",
            "    subject to change. Applications should only use zlib.h.",
            "  */",
            "@@ -52,15 +52,15 @@",
            " #    define Z_U8 unsigned",
            " #  endif",
            " #endif",
            " ",
            " extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */",
            " /* (size given to avoid silly warnings with Visual C++) */",
            " ",
            "-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]",
            "+#define ERR_MSG(err) z_errmsg[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]",
            " ",
            " #define ERR_RETURN(strm,err) \\",
            "   return (strm->msg = ERR_MSG(err), (err))",
            " /* To be used only when the state is known to be valid */",
            " ",
            "         /* common constants */",
            " ",
            "@@ -133,25 +133,16 @@",
            " #ifdef OS2",
            " #  define OS_CODE  6",
            " #  if defined(M_I86) && !defined(Z_SOLO)",
            " #    include <malloc.h>",
            " #  endif",
            " #endif",
            " ",
            "-#if defined(MACOS) || defined(TARGET_OS_MAC)",
            "+#if defined(MACOS)",
            " #  define OS_CODE  7",
            "-#  ifndef Z_SOLO",
            "-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os",
            "-#      include <unix.h> /* for fdopen */",
            "-#    else",
            "-#      ifndef fdopen",
            "-#        define fdopen(fd,mode) NULL /* No fdopen() */",
            "-#      endif",
            "-#    endif",
            "-#  endif",
            " #endif",
            " ",
            " #ifdef __acorn",
            " #  define OS_CODE 13",
            " #endif",
            " ",
            " #if defined(WIN32) && !defined(__CYGWIN__)",
            "@@ -166,26 +157,14 @@",
            " #  define OS_CODE 18",
            " #endif",
            " ",
            " #ifdef __APPLE__",
            " #  define OS_CODE 19",
            " #endif",
            " ",
            "-#if defined(_BEOS_) || defined(RISCOS)",
            "-#  define fdopen(fd,mode) NULL /* No fdopen() */",
            "-#endif",
            "-",
            "-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX",
            "-#  if defined(_WIN32_WCE)",
            "-#    define fdopen(fd,mode) NULL /* No fdopen() */",
            "-#  else",
            "-#    define fdopen(fd,type)  _fdopen(fd,type)",
            "-#  endif",
            "-#endif",
            "-",
            " #if defined(__BORLANDC__) && !defined(MSDOS)",
            "   #pragma warn -8004",
            "   #pragma warn -8008",
            "   #pragma warn -8066",
            " #endif",
            " ",
            " /* provide prototypes for these when building zlib without LFS */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/blame.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/blame.c",
            "+++ /home/libgit2-1.9.1/examples/blame.c",
            "@@ -93,15 +93,15 @@",
            " \t/** Produce the output. */",
            " \tline = 1;",
            " \ti = 0;",
            " \tbreak_on_null_hunk = 0;",
            " \twhile (i < rawsize) {",
            " \t\tconst char *eol = memchr(rawdata + i, '\\n', (size_t)(rawsize - i));",
            " \t\tchar oid[10] = {0};",
            "-\t\tconst git_blame_hunk *hunk = git_blame_get_hunk_byline(blame, line);",
            "+\t\tconst git_blame_hunk *hunk = git_blame_hunk_byline(blame, line);",
            " ",
            " \t\tif (break_on_null_hunk && !hunk)",
            " \t\t\tbreak;",
            " ",
            " \t\tif (hunk) {",
            " \t\t\tchar sig[128] = {0};",
            " \t\t\tbreak_on_null_hunk = 1;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/commit.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/commit.c",
            "+++ /home/libgit2-1.9.1/examples/commit.c",
            "@@ -35,15 +35,15 @@",
            " \tint error;",
            " ",
            " \tgit_oid commit_oid,tree_oid;",
            " \tgit_tree *tree;",
            " \tgit_index *index;",
            " \tgit_object *parent = NULL;",
            " \tgit_reference *ref = NULL;",
            "-\tgit_signature *signature;",
            "+\tgit_signature *author_signature, *committer_signature;",
            " ",
            " \t/* Validate args */",
            " \tif (argc < 3 || strcmp(opt, \"-m\") != 0) {",
            " \t\tprintf (\"USAGE: %s -m <comment>\\n\", argv[0]);",
            " \t\treturn -1;",
            " \t}",
            " ",
            "@@ -59,28 +59,30 @@",
            " ",
            " \tcheck_lg2(git_repository_index(&index, repo), \"Could not open repository index\", NULL);",
            " \tcheck_lg2(git_index_write_tree(&tree_oid, index), \"Could not write tree\", NULL);;",
            " \tcheck_lg2(git_index_write(index), \"Could not write index\", NULL);;",
            " ",
            " \tcheck_lg2(git_tree_lookup(&tree, repo, &tree_oid), \"Error looking up tree\", NULL);",
            " ",
            "-\tcheck_lg2(git_signature_default(&signature, repo), \"Error creating signature\", NULL);",
            "+\tcheck_lg2(git_signature_default_from_env(&author_signature, &committer_signature, repo),",
            "+\t\t\t\"Error creating signature\", NULL);",
            " ",
            " \tcheck_lg2(git_commit_create_v(",
            " \t\t&commit_oid,",
            " \t\trepo,",
            " \t\t\"HEAD\",",
            "-\t\tsignature,",
            "-\t\tsignature,",
            "+\t\tauthor_signature,",
            "+\t\tcommitter_signature,",
            " \t\tNULL,",
            " \t\tcomment,",
            " \t\ttree,",
            " \t\tparent ? 1 : 0, parent), \"Error creating commit\", NULL);",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_signature_free(signature);",
            "+\tgit_signature_free(author_signature);",
            "+\tgit_signature_free(committer_signature);",
            " \tgit_tree_free(tree);",
            " \tgit_object_free(parent);",
            " \tgit_reference_free(ref);",
            " ",
            " \treturn error;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/fetch.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/fetch.c",
            "+++ /home/libgit2-1.9.1/examples/fetch.c",
            "@@ -9,28 +9,32 @@",
            " }",
            " ",
            " /**",
            "  * This function gets called for each remote-tracking branch that gets",
            "  * updated. The message we output depends on whether it's a new one or",
            "  * an update.",
            "  */",
            "-static int update_cb(const char *refname, const git_oid *a, const git_oid *b, void *data)",
            "+static int update_cb(const char *refname, const git_oid *a, const git_oid *b, git_refspec *spec, void *data)",
            " {",
            " \tchar a_str[GIT_OID_SHA1_HEXSIZE+1], b_str[GIT_OID_SHA1_HEXSIZE+1];",
            "+\tgit_buf remote_name;",
            " \t(void)data;",
            " ",
            "+\tif (git_refspec_rtransform(&remote_name, spec, refname) < 0)",
            "+\t\treturn -1;",
            "+",
            " \tgit_oid_fmt(b_str, b);",
            " \tb_str[GIT_OID_SHA1_HEXSIZE] = '\\0';",
            " ",
            " \tif (git_oid_is_zero(a)) {",
            "-\t\tprintf(\"[new]     %.20s %s\\n\", b_str, refname);",
            "+\t\tprintf(\"[new]     %.20s %s -> %s\\n\", b_str, remote_name.ptr, refname);",
            " \t} else {",
            " \t\tgit_oid_fmt(a_str, a);",
            " \t\ta_str[GIT_OID_SHA1_HEXSIZE] = '\\0';",
            "-\t\tprintf(\"[updated] %.10s..%.10s %s\\n\", a_str, b_str, refname);",
            "+\t\tprintf(\"[updated] %.10s..%.10s %s -> %s\\n\", a_str, b_str, remote_name.ptr, refname);",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " /**",
            "  * This gets called during the download and indexing. Here we show",
            "@@ -68,15 +72,15 @@",
            " \t/* Figure out whether it's a named remote or a URL */",
            " \tprintf(\"Fetching %s for repo %p\\n\", argv[1], repo);",
            " \tif (git_remote_lookup(&remote, repo, argv[1]) < 0)",
            " \t\tif (git_remote_create_anonymous(&remote, repo, argv[1]) < 0)",
            " \t\t\tgoto on_error;",
            " ",
            " \t/* Set up the callbacks (only update_tips for now) */",
            "-\tfetch_opts.callbacks.update_tips = &update_cb;",
            "+\tfetch_opts.callbacks.update_refs = &update_cb;",
            " \tfetch_opts.callbacks.sideband_progress = &progress_cb;",
            " \tfetch_opts.callbacks.transfer_progress = transfer_progress_cb;",
            " \tfetch_opts.callbacks.credentials = cred_acquire_cb;",
            " ",
            " \t/**",
            " \t * Perform the fetch with the configured refspecs from the",
            " \t * config. Update the reflog for the updated references with"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/index-pack.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/index-pack.c",
            "+++ /home/libgit2-1.9.1/examples/index-pack.c",
            "@@ -25,15 +25,15 @@",
            " ",
            " \tif (argc < 2) {",
            " \t\tfprintf(stderr, \"usage: %s index-pack <packfile>\\n\", argv[-1]);",
            " \t\treturn EXIT_FAILURE;",
            " \t}",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\terror = git_indexer_new(&idx, \".\", git_repository_oid_type(repo), NULL);",
            "+\terror = git_indexer_new(&idx, \".\", NULL);",
            " #else",
            " \terror = git_indexer_new(&idx, \".\", 0, NULL, NULL);",
            " #endif",
            " ",
            " \tif (error < 0) {",
            " \t\tputs(\"bad idx\");",
            " \t\treturn -1;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/init.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/init.c",
            "+++ /home/libgit2-1.9.1/examples/init.c",
            "@@ -119,22 +119,22 @@",
            " /**",
            "  * Unlike regular \"git init\", this example shows how to create an initial",
            "  * empty commit in the repository.  This is the helper function that does",
            "  * that.",
            "  */",
            " static void create_initial_commit(git_repository *repo)",
            " {",
            "-\tgit_signature *sig;",
            "+\tgit_signature *author_sig = NULL, *committer_sig = NULL;",
            " \tgit_index *index;",
            " \tgit_oid tree_id, commit_id;",
            " \tgit_tree *tree;",
            " ",
            " \t/** First use the config to initialize a commit signature for the user. */",
            " ",
            "-\tif (git_signature_default(&sig, repo) < 0)",
            "+\tif ((git_signature_default_from_env(&author_sig, &committer_sig, repo) < 0))",
            " \t\tfatal(\"Unable to create a commit signature.\",",
            " \t\t      \"Perhaps 'user.name' and 'user.email' are not set\");",
            " ",
            " \t/* Now let's create an empty tree for this commit */",
            " ",
            " \tif (git_repository_index(&index, repo) < 0)",
            " \t\tfatal(\"Could not open repository index\", NULL);",
            "@@ -158,22 +158,23 @@",
            " \t *",
            " \t * Normally creating a commit would involve looking up the current",
            " \t * HEAD commit and making that be the parent of the initial commit,",
            " \t * but here this is the first commit so there will be no parent.",
            " \t */",
            " ",
            " \tif (git_commit_create_v(",
            "-\t\t\t&commit_id, repo, \"HEAD\", sig, sig,",
            "+\t\t\t&commit_id, repo, \"HEAD\", author_sig, committer_sig,",
            " \t\t\tNULL, \"Initial commit\", tree, 0) < 0)",
            " \t\tfatal(\"Could not create the initial commit\", NULL);",
            " ",
            " \t/** Clean up so we don't leak memory. */",
            " ",
            " \tgit_tree_free(tree);",
            "-\tgit_signature_free(sig);",
            "+\tgit_signature_free(author_sig);",
            "+\tgit_signature_free(committer_sig);",
            " }",
            " ",
            " static void usage(const char *error, const char *arg)",
            " {",
            " \tfprintf(stderr, \"error: %s '%s'\\n\", error, arg);",
            " \tfprintf(stderr,",
            " \t\t\t\"usage: init [-q | --quiet] [--bare] [--template=<dir>]\\n\""
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/show-index.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/show-index.c",
            "+++ /home/libgit2-1.9.1/examples/show-index.c",
            "@@ -27,15 +27,15 @@",
            " \t\tfatal(\"usage: showindex [<repo-dir>]\", NULL);",
            " \tif (argc > 1)",
            " \t\tdir = argv[1];",
            " ",
            " \tdirlen = strlen(dir);",
            " \tif (dirlen > 5 && strcmp(dir + dirlen - 5, \"index\") == 0) {",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t\tcheck_lg2(git_index_open(&index, dir, GIT_OID_SHA1), \"could not open index\", dir);",
            "+\t\tcheck_lg2(git_index_open(&index, dir, NULL), \"could not open index\", dir);",
            " #else",
            " \t\tcheck_lg2(git_index_open(&index, dir), \"could not open index\", dir);",
            " #endif",
            " \t} else {",
            " \t\tcheck_lg2(git_repository_open_ext(&repo, dir, 0, NULL), \"could not open repository\", dir);",
            " \t\tcheck_lg2(git_repository_index(&index, repo), \"could not open repository index\", NULL);",
            " \t\tgit_repository_free(repo);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/stash.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/stash.c",
            "+++ /home/libgit2-1.9.1/examples/stash.c",
            "@@ -104,15 +104,15 @@",
            " \tgit_signature *signature;",
            " \tgit_commit *stash;",
            " \tgit_oid stashid;",
            " ",
            " \tif (opts->argc)",
            " \t\tusage(\"push does not accept any parameters\");",
            " ",
            "-\tcheck_lg2(git_signature_default(&signature, repo),",
            "+\tcheck_lg2(git_signature_default_from_env(&signature, NULL, repo),",
            " \t\t  \"Unable to get signature\", NULL);",
            " \tcheck_lg2(git_stash_save(&stashid, repo, signature, NULL, GIT_STASH_DEFAULT),",
            " \t\t  \"Unable to save stash\", NULL);",
            " \tcheck_lg2(git_commit_lookup(&stash, repo, &stashid),",
            " \t\t  \"Unable to lookup stash commit\", NULL);",
            " ",
            " \tprintf(\"Saved working directory %s\\n\", git_commit_summary(stash));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/examples/tag.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/examples/tag.c",
            "+++ /home/libgit2-1.9.1/examples/tag.c",
            "@@ -222,15 +222,15 @@",
            " \tcheck(!opts->message, \"Message required\");",
            " ",
            " \tif (!opts->target) opts->target = \"HEAD\";",
            " ",
            " \tcheck_lg2(git_revparse_single(&target, repo, opts->target),",
            " \t\t\t\"Unable to resolve spec\", opts->target);",
            " ",
            "-\tcheck_lg2(git_signature_default(&tagger, repo),",
            "+\tcheck_lg2(git_signature_default_from_env(&tagger, NULL, repo),",
            " \t\t\t\"Unable to create signature\", NULL);",
            " ",
            " \tcheck_lg2(git_tag_create(&oid, repo, opts->tag_name,",
            " \t\t\t\ttarget, tagger, opts->message, opts->force), \"Unable to create tag\", NULL);",
            " ",
            " \tgit_object_free(target);",
            " \tgit_signature_free(tagger);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/fuzzers/packfile_fuzzer.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/fuzzers/packfile_fuzzer.c",
            "+++ /home/libgit2-1.9.1/fuzzers/packfile_fuzzer.c",
            "@@ -80,15 +80,15 @@",
            " ",
            " \tif (git_odb_write(&oid, odb, base_obj, base_obj_len, GIT_OBJECT_BLOB) < 0) {",
            " \t\tfprintf(stderr, \"Failed to add an object to the odb\\n\");",
            " \t\tabort();",
            " \t}",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\terror = git_indexer_new(&indexer, \".\", GIT_OID_SHA1, NULL);",
            "+\terror = git_indexer_new(&indexer, \".\", NULL);",
            " #else",
            " \terror = git_indexer_new(&indexer, \".\", 0, odb, NULL);",
            " #endif",
            " ",
            " \tif (error < 0) {",
            " \t\tfprintf(stderr, \"Failed to create the indexer: %s\\n\",",
            " \t\t\tgit_error_last()->message);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/fuzzers/standalone_driver.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/fuzzers/standalone_driver.c",
            "+++ /home/libgit2-1.9.1/fuzzers/standalone_driver.c",
            "@@ -63,11 +63,11 @@",
            " \t\t\terror = -1;",
            " \t\t\tgoto exit;",
            " \t\t}",
            " \t}",
            " \tfprintf(stderr, \"Done %d runs\\n\", i);",
            " ",
            " exit:",
            "-\tgit_vector_free_deep(&corpus_files);",
            "+\tgit_vector_dispose_deep(&corpus_files);",
            " \tgit_libgit2_shutdown();",
            " \treturn error;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/annotated_commit.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/annotated_commit.h",
            "+++ /home/libgit2-1.9.1/include/git2/annotated_commit.h",
            "@@ -9,42 +9,49 @@",
            " ",
            " #include \"common.h\"",
            " #include \"repository.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/annotated_commit.h",
            "- * @brief Git annotated commit routines",
            "+ * @brief A commit and information about how it was looked up by the user.",
            "  * @defgroup git_annotated_commit Git annotated commit routines",
            "  * @ingroup Git",
            "+ *",
            "+ * An \"annotated commit\" is a commit that contains information about",
            "+ * how the commit was resolved, which can be used for maintaining the",
            "+ * user's \"intent\" through commands like merge and rebase. For example,",
            "+ * if a user wants to \"merge HEAD\" then an annotated commit is used to",
            "+ * both contain the HEAD commit _and_ the fact that it was resolved as",
            "+ * the HEAD ref.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Creates a `git_annotated_commit` from the given reference.",
            "  * The resulting git_annotated_commit must be freed with",
            "  * `git_annotated_commit_free`.",
            "  *",
            "- * @param out pointer to store the git_annotated_commit result in",
            "+ * @param[out] out pointer to store the git_annotated_commit result in",
            "  * @param repo repository that contains the given reference",
            "  * @param ref reference to use to lookup the git_annotated_commit",
            "  * @return 0 on success or error code",
            "  */",
            " GIT_EXTERN(int) git_annotated_commit_from_ref(",
            " \tgit_annotated_commit **out,",
            " \tgit_repository *repo,",
            " \tconst git_reference *ref);",
            " ",
            " /**",
            "  * Creates a `git_annotated_commit` from the given fetch head data.",
            "  * The resulting git_annotated_commit must be freed with",
            "  * `git_annotated_commit_free`.",
            "  *",
            "- * @param out pointer to store the git_annotated_commit result in",
            "+ * @param[out] out pointer to store the git_annotated_commit result in",
            "  * @param repo repository that contains the given commit",
            "  * @param branch_name name of the (remote) branch",
            "  * @param remote_url url of the remote",
            "  * @param id the commit object id of the remote branch",
            "  * @return 0 on success or error code",
            "  */",
            " GIT_EXTERN(int) git_annotated_commit_from_fetchhead(",
            "@@ -63,15 +70,15 @@",
            "  * looked up, which may be useful for functions like merge or",
            "  * rebase to provide context to the operation.  For example,",
            "  * conflict files will include the name of the source or target",
            "  * branches being merged.  It is therefore preferable to use the",
            "  * most specific function (eg `git_annotated_commit_from_ref`)",
            "  * instead of this one when that data is known.",
            "  *",
            "- * @param out pointer to store the git_annotated_commit result in",
            "+ * @param[out] out pointer to store the git_annotated_commit result in",
            "  * @param repo repository that contains the given commit",
            "  * @param id the commit object id to lookup",
            "  * @return 0 on success or error code",
            "  */",
            " GIT_EXTERN(int) git_annotated_commit_lookup(",
            " \tgit_annotated_commit **out,",
            " \tgit_repository *repo,",
            "@@ -80,15 +87,15 @@",
            " /**",
            "  * Creates a `git_annotated_commit` from a revision string.",
            "  *",
            "  * See `man gitrevisions`, or",
            "  * http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for",
            "  * information on the syntax accepted.",
            "  *",
            "- * @param out pointer to store the git_annotated_commit result in",
            "+ * @param[out] out pointer to store the git_annotated_commit result in",
            "  * @param repo repository that contains the given commit",
            "  * @param revspec the extended sha syntax string to use to lookup the commit",
            "  * @return 0 on success or error code",
            "  */",
            " GIT_EXTERN(int) git_annotated_commit_from_revspec(",
            " \tgit_annotated_commit **out,",
            " \tgit_repository *repo,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/apply.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/apply.h",
            "+++ /home/libgit2-1.9.1/include/git2/apply.h",
            "@@ -10,17 +10,20 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"diff.h\"",
            " ",
            " /**",
            "  * @file git2/apply.h",
            "- * @brief Git patch application routines",
            "+ * @brief Apply patches to the working directory or index",
            "  * @defgroup git_apply Git patch application routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Mechanisms to apply a patch to the index, the working directory,",
            "+ * or both.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * When applying a patch, callback that will be made per delta (file).",
            "  *",
            "@@ -53,48 +56,66 @@",
            "  * @return 0 if the hunk is applied, < 0 if the apply process will be aborted",
            "  *\tor > 0 if the hunk will not be applied.",
            "  */",
            " typedef int GIT_CALLBACK(git_apply_hunk_cb)(",
            " \tconst git_diff_hunk *hunk,",
            " \tvoid *payload);",
            " ",
            "-/** Flags controlling the behavior of git_apply */",
            "+/**",
            "+ * Flags controlling the behavior of `git_apply`.",
            "+ *",
            "+ * When the callback:",
            "+ * - returns < 0, the apply process will be aborted.",
            "+ * - returns > 0, the hunk will not be applied, but the apply process",
            "+ *      continues",
            "+ * - returns 0, the hunk is applied, and the apply process continues.",
            "+ */",
            " typedef enum {",
            " \t/**",
            " \t * Don't actually make changes, just test that the patch applies.",
            " \t * This is the equivalent of `git apply --check`.",
            " \t */",
            " \tGIT_APPLY_CHECK = (1 << 0)",
            " } git_apply_flags_t;",
            " ",
            " /**",
            "- * Apply options structure",
            "+ * Apply options structure.",
            "+ *",
            "+ * When the callback:",
            "+ * - returns < 0, the apply process will be aborted.",
            "+ * - returns > 0, the hunk will not be applied, but the apply process",
            "+ *      continues",
            "+ * - returns 0, the hunk is applied, and the apply process continues.",
            "  *",
            "  * Initialize with `GIT_APPLY_OPTIONS_INIT`. Alternatively, you can",
            "  * use `git_apply_options_init`.",
            "  *",
            "- * @see git_apply_to_tree, git_apply",
            "+ * @see git_apply_to_tree",
            "+ * @see git_apply",
            "  */",
            " typedef struct {",
            " \tunsigned int version; /**< The version */",
            " ",
            " \t/** When applying a patch, callback that will be made per delta (file). */",
            " \tgit_apply_delta_cb delta_cb;",
            " ",
            " \t/** When applying a patch, callback that will be made per hunk. */",
            " \tgit_apply_hunk_cb hunk_cb;",
            " ",
            "-\t/** Payload passed to both delta_cb & hunk_cb. */",
            "+\t/** Payload passed to both `delta_cb` & `hunk_cb`. */",
            " \tvoid *payload;",
            " ",
            "-\t/** Bitmask of git_apply_flags_t */",
            "+\t/** Bitmask of `git_apply_flags_t` */",
            " \tunsigned int flags;",
            " } git_apply_options;",
            " ",
            "+/** Current version for the `git_apply_options` structure */",
            " #define GIT_APPLY_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_apply_options` */",
            " #define GIT_APPLY_OPTIONS_INIT {GIT_APPLY_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_apply_options structure",
            "  *",
            "  * Initialize a `git_apply_options` with default values. Equivalent to creating",
            "  * an instance with GIT_APPLY_OPTIONS_INIT."
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/attr.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/attr.h",
            "+++ /home/libgit2-1.9.1/include/git2/attr.h",
            "@@ -8,17 +8,21 @@",
            " #define INCLUDE_git_attr_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/attr.h",
            "- * @brief Git attribute management routines",
            "+ * @brief Attribute management routines",
            "  * @defgroup git_attr Git attribute management routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Attributes specify additional information about how git should",
            "+ * handle particular paths - for example, they may indicate whether",
            "+ * a particular filter is applied, like LFS or line ending conversions.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * GIT_ATTR_TRUE checks if an attribute is set on.  In core git",
            "  * parlance, this the value for \"Set\" attributes.",
            "@@ -110,16 +114,20 @@",
            "  * which order using the following flags.",
            "  *",
            "  * Core git usually checks the working directory then the index,",
            "  * except during a checkout when it checks the index first.  It will",
            "  * use index only for creating archives or for a bare repo (if an",
            "  * index has been specified for the bare repo).",
            "  */",
            "+",
            "+/** Examine attribute in working directory, then index */",
            " #define GIT_ATTR_CHECK_FILE_THEN_INDEX\t0",
            "+/** Examine attribute in index, then working directory */",
            " #define GIT_ATTR_CHECK_INDEX_THEN_FILE\t1",
            "+/** Examine attributes only in the index */",
            " #define GIT_ATTR_CHECK_INDEX_ONLY\t2",
            " ",
            " /**",
            "  * Check attribute flags: controlling extended attribute behavior.",
            "  *",
            "  * Normally, attribute checks include looking in the /etc (or system",
            "  * equivalent) directory for a `gitattributes` file.  Passing the",
            "@@ -128,16 +136,20 @@",
            "  *",
            "  * Passing the `GIT_ATTR_CHECK_INCLUDE_HEAD` flag will use attributes",
            "  * from a `.gitattributes` file in the repository at the HEAD revision.",
            "  *",
            "  * Passing the `GIT_ATTR_CHECK_INCLUDE_COMMIT` flag will use attributes",
            "  * from a `.gitattributes` file in a specific commit.",
            "  */",
            "+",
            "+/** Ignore system attributes */",
            " #define GIT_ATTR_CHECK_NO_SYSTEM        (1 << 2)",
            "+/** Honor `.gitattributes` in the HEAD revision */",
            " #define GIT_ATTR_CHECK_INCLUDE_HEAD     (1 << 3)",
            "+/** Honor `.gitattributes` in a specific commit */",
            " #define GIT_ATTR_CHECK_INCLUDE_COMMIT   (1 << 4)",
            " ",
            " /**",
            " * An options structure for querying attributes.",
            " */",
            " typedef struct {",
            " \tunsigned int version;",
            "@@ -154,15 +166,18 @@",
            " \t/**",
            " \t * The commit to load attributes from, when",
            " \t * `GIT_ATTR_CHECK_INCLUDE_COMMIT` is specified.",
            " \t */",
            " \tgit_oid attr_commit_id;",
            " } git_attr_options;",
            " ",
            "+/** Current version for the `git_attr_options` structure */",
            " #define GIT_ATTR_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_attr_options` */",
            " #define GIT_ATTR_OPTIONS_INIT {GIT_ATTR_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Look up the value of one git attribute for path.",
            "  *",
            "  * @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...",
            "  *             macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/blame.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/blame.h",
            "+++ /home/libgit2-1.9.1/include/git2/blame.h",
            "@@ -9,17 +9,22 @@",
            " #define INCLUDE_git_blame_h__",
            " ",
            " #include \"common.h\"",
            " #include \"oid.h\"",
            " ",
            " /**",
            "  * @file git2/blame.h",
            "- * @brief Git blame routines",
            "+ * @brief Specify a file's most recent changes per-line",
            "  * @defgroup git_blame Git blame routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Producing a \"blame\" (or \"annotated history\") decorates individual",
            "+ * lines in a file with the commit that introduced that particular line",
            "+ * of changes. This can be useful to indicate when and why a particular",
            "+ * change was made.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Flags for indicating option behavior for git_blame APIs.",
            "  */",
            "@@ -83,15 +88,15 @@",
            "  * use `git_blame_options_init`.",
            "  *",
            "  */",
            " typedef struct git_blame_options {",
            " \tunsigned int version;",
            " ",
            " \t/** A combination of `git_blame_flag_t` */",
            "-\tuint32_t flags;",
            "+\tunsigned int flags;",
            " ",
            " \t/**",
            " \t * The lower bound on the number of alphanumeric characters that",
            " \t * must be detected as moving/copying within a file for it to",
            " \t * associate those lines with the parent commit. The default value",
            " \t * is 20.",
            " \t *",
            "@@ -118,15 +123,18 @@",
            " \t/**",
            " \t * The last line in the file to blame.",
            " \t * The default is the last line of the file.",
            " \t */",
            " \tsize_t max_line;",
            " } git_blame_options;",
            " ",
            "+/** Current version for the `git_blame_options` structure */",
            " #define GIT_BLAME_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_blame_options` */",
            " #define GIT_BLAME_OPTIONS_INIT {GIT_BLAME_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_blame_options structure",
            "  *",
            "  * Initializes a `git_blame_options` with default values. Equivalent to creating",
            "  * an instance with GIT_BLAME_OPTIONS_INIT.",
            "@@ -162,14 +170,21 @@",
            " \t/**",
            " \t * The author of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been",
            " \t * specified, it will contain the canonical real name and email address.",
            " \t */",
            " \tgit_signature *final_signature;",
            " ",
            " \t/**",
            "+\t * The committer of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has",
            "+\t * been specified, it will contain the canonical real name and email",
            "+\t * address.",
            "+\t */",
            "+\tgit_signature *final_committer;",
            "+",
            "+\t/**",
            " \t * The OID of the commit where this hunk was found.",
            " \t * This will usually be the same as `final_commit_id`, except when",
            " \t * `GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES` has been specified.",
            " \t */",
            " \tgit_oid orig_commit_id;",
            " ",
            " \t/**",
            "@@ -187,94 +202,184 @@",
            " \t/**",
            " \t * The author of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been",
            " \t * specified, it will contain the canonical real name and email address.",
            " \t */",
            " \tgit_signature *orig_signature;",
            " ",
            " \t/**",
            "+\t * The committer of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has",
            "+\t * been specified, it will contain the canonical real name and email",
            "+\t * address.",
            "+\t */",
            "+\tgit_signature *orig_committer;",
            "+",
            "+\t/*",
            "+\t * The summary of the commit.",
            "+\t */",
            "+\tconst char *summary;",
            "+",
            "+\t/**",
            " \t * The 1 iff the hunk has been tracked to a boundary commit (the root,",
            " \t * or the commit specified in git_blame_options.oldest_commit)",
            " \t */",
            " \tchar boundary;",
            " } git_blame_hunk;",
            " ",
            "+/**",
            "+ * Structure that represents a line in a blamed file.",
            "+ */",
            "+typedef struct git_blame_line {",
            "+\tconst char *ptr;",
            "+\tsize_t len;",
            "+} git_blame_line;",
            " ",
            " /** Opaque structure to hold blame results */",
            " typedef struct git_blame git_blame;",
            " ",
            " /**",
            "+ * Gets the number of lines that exist in the blame structure.",
            "+ *",
            "+ * @param blame The blame structure to query.",
            "+ * @return The number of line.",
            "+ */",
            "+GIT_EXTERN(size_t) git_blame_linecount(git_blame *blame);",
            "+",
            "+/**",
            "  * Gets the number of hunks that exist in the blame structure.",
            "  *",
            "  * @param blame The blame structure to query.",
            "  * @return The number of hunks.",
            "  */",
            "+GIT_EXTERN(size_t) git_blame_hunkcount(git_blame *blame);",
            "+",
            "+/**",
            "+ * Gets the blame hunk at the given index.",
            "+ *",
            "+ * @param blame the blame structure to query",
            "+ * @param index index of the hunk to retrieve",
            "+ * @return the hunk at the given index, or NULL on error",
            "+ */",
            "+GIT_EXTERN(const git_blame_hunk *) git_blame_hunk_byindex(",
            "+\tgit_blame *blame,",
            "+\tsize_t index);",
            "+",
            "+/**",
            "+ * Gets the hunk that relates to the given line number in the newest",
            "+ * commit.",
            "+ *",
            "+ * @param blame the blame structure to query",
            "+ * @param lineno the (1-based) line number to find a hunk for",
            "+ * @return the hunk that contains the given line, or NULL on error",
            "+ */",
            "+GIT_EXTERN(const git_blame_hunk *) git_blame_hunk_byline(",
            "+\tgit_blame *blame,",
            "+\tsize_t lineno);",
            "+",
            "+/**",
            "+ * Gets the information about the line in the blame.",
            "+ *",
            "+ * @param blame the blame structure to query",
            "+ * @param idx the (1-based) line number",
            "+ * @return the blamed line, or NULL on error",
            "+ */",
            "+GIT_EXTERN(const git_blame_line *) git_blame_line_byindex(",
            "+\tgit_blame *blame,",
            "+\tsize_t idx);",
            "+",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+/**",
            "+ * Gets the number of hunks that exist in the blame structure.",
            "+ *",
            "+ * @param blame The blame structure to query.",
            "+ * @return The number of hunks.",
            "+ */",
            "+",
            " GIT_EXTERN(uint32_t) git_blame_get_hunk_count(git_blame *blame);",
            " ",
            " /**",
            "  * Gets the blame hunk at the given index.",
            "  *",
            "  * @param blame the blame structure to query",
            "  * @param index index of the hunk to retrieve",
            "  * @return the hunk at the given index, or NULL on error",
            "  */",
            "-GIT_EXTERN(const git_blame_hunk*) git_blame_get_hunk_byindex(",
            "-\t\tgit_blame *blame,",
            "-\t\tuint32_t index);",
            "+GIT_EXTERN(const git_blame_hunk *) git_blame_get_hunk_byindex(",
            "+\tgit_blame *blame,",
            "+\tuint32_t index);",
            " ",
            " /**",
            "  * Gets the hunk that relates to the given line number in the newest commit.",
            "  *",
            "  * @param blame the blame structure to query",
            "  * @param lineno the (1-based) line number to find a hunk for",
            "  * @return the hunk that contains the given line, or NULL on error",
            "  */",
            "-GIT_EXTERN(const git_blame_hunk*) git_blame_get_hunk_byline(",
            "-\t\tgit_blame *blame,",
            "-\t\tsize_t lineno);",
            "+GIT_EXTERN(const git_blame_hunk *) git_blame_get_hunk_byline(",
            "+\tgit_blame *blame,",
            "+\tsize_t lineno);",
            "+#endif",
            " ",
            " /**",
            "- * Get the blame for a single file.",
            "+ * Get the blame for a single file in the repository.",
            "  *",
            "  * @param out pointer that will receive the blame object",
            "  * @param repo repository whose history is to be walked",
            "  * @param path path to file to consider",
            "- * @param options options for the blame operation.  If NULL, this is treated as",
            "- *                though GIT_BLAME_OPTIONS_INIT were passed.",
            "- * @return 0 on success, or an error code. (use git_error_last for information",
            "- *         about the error.)",
            "+ * @param options options for the blame operation or NULL",
            "+ * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_blame_file(",
            "-\t\tgit_blame **out,",
            "-\t\tgit_repository *repo,",
            "-\t\tconst char *path,",
            "-\t\tgit_blame_options *options);",
            "-",
            "+\tgit_blame **out,",
            "+\tgit_repository *repo,",
            "+\tconst char *path,",
            "+\tgit_blame_options *options);",
            " ",
            " /**",
            "- * Get blame data for a file that has been modified in memory. The `reference`",
            "- * parameter is a pre-calculated blame for the in-odb history of the file. This",
            "- * means that once a file blame is completed (which can be expensive), updating",
            "- * the buffer blame is very fast.",
            "+ * Get the blame for a single file in the repository, using the specified",
            "+ * buffer contents as the uncommitted changes of the file (the working",
            "+ * directory contents).",
            "+ *",
            "+ * @param out pointer that will receive the blame object",
            "+ * @param repo repository whose history is to be walked",
            "+ * @param path path to file to consider",
            "+ * @param contents the uncommitted changes",
            "+ * @param contents_len the length of the changes buffer",
            "+ * @param options options for the blame operation or NULL",
            "+ * @return 0 on success, or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_blame_file_from_buffer(",
            "+\tgit_blame **out,",
            "+\tgit_repository *repo,",
            "+\tconst char *path,",
            "+\tconst char *contents,",
            "+\tsize_t contents_len,",
            "+\tgit_blame_options *options);",
            "+",
            "+/**",
            "+ * Get blame data for a file that has been modified in memory. The `blame`",
            "+ * parameter is a pre-calculated blame for the in-odb history of the file.",
            "+ * This means that once a file blame is completed (which can be expensive),",
            "+ * updating the buffer blame is very fast.",
            "  *",
            "- * Lines that differ between the buffer and the committed version are marked as",
            "- * having a zero OID for their final_commit_id.",
            "+ * Lines that differ between the buffer and the committed version are",
            "+ * marked as having a zero OID for their final_commit_id.",
            "  *",
            "  * @param out pointer that will receive the resulting blame data",
            "- * @param reference cached blame from the history of the file (usually the output",
            "+ * @param base cached blame from the history of the file (usually the output",
            "  *                  from git_blame_file)",
            "  * @param buffer the (possibly) modified contents of the file",
            "  * @param buffer_len number of valid bytes in the buffer",
            "  * @return 0 on success, or an error code. (use git_error_last for information",
            "  *         about the error)",
            "  */",
            " GIT_EXTERN(int) git_blame_buffer(",
            "-\t\tgit_blame **out,",
            "-\t\tgit_blame *reference,",
            "-\t\tconst char *buffer,",
            "-\t\tsize_t buffer_len);",
            "+\tgit_blame **out,",
            "+\tgit_blame *base,",
            "+\tconst char *buffer,",
            "+\tsize_t buffer_len);",
            " ",
            " /**",
            "  * Free memory allocated by git_blame_file or git_blame_buffer.",
            "  *",
            "  * @param blame the blame structure to free",
            "  */",
            " GIT_EXTERN(void) git_blame_free(git_blame *blame);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/blob.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/blob.h",
            "+++ /home/libgit2-1.9.1/include/git2/blob.h",
            "@@ -11,38 +11,45 @@",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"object.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/blob.h",
            "- * @brief Git blob load and write routines",
            "+ * @brief A blob represents a file in a git repository.",
            "  * @defgroup git_blob Git blob load and write routines",
            "  * @ingroup Git",
            "+ *",
            "+ * A blob represents a file in a git repository. This is the raw data",
            "+ * as it is stored in the repository itself. Blobs may be \"filtered\"",
            "+ * to produce the on-disk content.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Lookup a blob object from a repository.",
            "  *",
            "- * @param blob pointer to the looked up blob",
            "+ * @param[out] blob pointer to the looked up blob",
            "  * @param repo the repo to use when locating the blob.",
            "  * @param id identity of the blob to locate.",
            "  * @return 0 or an error code",
            "  */",
            "-GIT_EXTERN(int) git_blob_lookup(git_blob **blob, git_repository *repo, const git_oid *id);",
            "+GIT_EXTERN(int) git_blob_lookup(",
            "+\tgit_blob **blob,",
            "+\tgit_repository *repo,",
            "+\tconst git_oid *id);",
            " ",
            " /**",
            "  * Lookup a blob object from a repository,",
            "  * given a prefix of its identifier (short id).",
            "  *",
            "  * @see git_object_lookup_prefix",
            "  *",
            "- * @param blob pointer to the looked up blob",
            "+ * @param[out] blob pointer to the looked up blob",
            "  * @param repo the repo to use when locating the blob.",
            "  * @param id identity of the blob to locate.",
            "  * @param len the length of the short identifier",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_blob_lookup_prefix(git_blob **blob, git_repository *repo, const git_oid *id, size_t len);",
            " ",
            "@@ -80,28 +87,30 @@",
            "  *",
            "  * A pointer to the raw content of a blob is returned;",
            "  * this pointer is owned internally by the object and shall",
            "  * not be free'd. The pointer may be invalidated at a later",
            "  * time.",
            "  *",
            "  * @param blob pointer to the blob",
            "- * @return the pointer, or NULL on error",
            "+ * @return @type `unsigned char *` the pointer, or NULL on error",
            "  */",
            " GIT_EXTERN(const void *) git_blob_rawcontent(const git_blob *blob);",
            " ",
            " /**",
            "  * Get the size in bytes of the contents of a blob",
            "  *",
            "  * @param blob pointer to the blob",
            "- * @return size on bytes",
            "+ * @return size in bytes",
            "  */",
            " GIT_EXTERN(git_object_size_t) git_blob_rawsize(const git_blob *blob);",
            " ",
            " /**",
            "  * Flags to control the functionality of `git_blob_filter`.",
            "+ *",
            "+ * @flags",
            "  */",
            " typedef enum {",
            " \t/** When set, filters will not be applied to binary files. */",
            " \tGIT_BLOB_FILTER_CHECK_FOR_BINARY = (1 << 0),",
            " ",
            " \t/**",
            " \t * When set, filters will not load configuration from the",
            "@@ -124,104 +133,138 @@",
            " ",
            " /**",
            "  * The options used when applying filter options to a file.",
            "  *",
            "  * Initialize with `GIT_BLOB_FILTER_OPTIONS_INIT`. Alternatively, you can",
            "  * use `git_blob_filter_options_init`.",
            "  *",
            "+ * @options[version] GIT_BLOB_FILTER_OPTIONS_VERSION",
            "+ * @options[init_macro] GIT_BLOB_FILTER_OPTIONS_INIT",
            "+ * @options[init_function] git_blob_filter_options_init",
            "  */",
            " typedef struct {",
            "+\t/** Version number of the options structure. */",
            " \tint version;",
            " ",
            "-\t/** Flags to control the filtering process, see `git_blob_filter_flag_t` above */",
            "+\t/**",
            "+\t * Flags to control the filtering process, see `git_blob_filter_flag_t` above.",
            "+\t *",
            "+\t * @type[flags] git_blob_filter_flag_t",
            "+\t */",
            " \tuint32_t flags;",
            " ",
            " #ifdef GIT_DEPRECATE_HARD",
            "+\t/**",
            "+\t * Unused and reserved for ABI compatibility.",
            "+\t *",
            "+\t * @deprecated this value should not be set",
            "+\t */",
            " \tvoid *reserved;",
            " #else",
            "+\t/**",
            "+\t * This value is unused and reserved for API compatibility.",
            "+\t *",
            "+\t * @deprecated this value should not be set",
            "+\t */",
            " \tgit_oid *commit_id;",
            " #endif",
            " ",
            " \t/**",
            " \t * The commit to load attributes from, when",
            " \t * `GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.",
            " \t */",
            " \tgit_oid attr_commit_id;",
            " } git_blob_filter_options;",
            " ",
            "+/**",
            "+ * The current version number for the `git_blob_filter_options` structure ABI.",
            "+ */",
            " #define GIT_BLOB_FILTER_OPTIONS_VERSION 1",
            "-#define GIT_BLOB_FILTER_OPTIONS_INIT {GIT_BLOB_FILTER_OPTIONS_VERSION, GIT_BLOB_FILTER_CHECK_FOR_BINARY}",
            "+",
            "+/**",
            "+ * The default values for `git_blob_filter_options`.",
            "+ */",
            "+#define GIT_BLOB_FILTER_OPTIONS_INIT { \\",
            "+\t\tGIT_BLOB_FILTER_OPTIONS_VERSION, \\",
            "+\t\tGIT_BLOB_FILTER_CHECK_FOR_BINARY \\",
            "+\t}",
            " ",
            " /**",
            "  * Initialize git_blob_filter_options structure",
            "  *",
            "  * Initializes a `git_blob_filter_options` with default values. Equivalent",
            "  * to creating an instance with `GIT_BLOB_FILTER_OPTIONS_INIT`.",
            "  *",
            "  * @param opts The `git_blob_filter_options` struct to initialize.",
            "- * @param version The struct version; pass `GIT_BLOB_FILTER_OPTIONS_VERSION`.",
            "+ * @param version The struct version; pass GIT_BLOB_FILTER_OPTIONS_VERSION",
            "  * @return Zero on success; -1 on failure.",
            "  */",
            "-GIT_EXTERN(int) git_blob_filter_options_init(git_blob_filter_options *opts, unsigned int version);",
            "+GIT_EXTERN(int) git_blob_filter_options_init(",
            "+\tgit_blob_filter_options *opts,",
            "+\tunsigned int version);",
            " ",
            " /**",
            "  * Get a buffer with the filtered content of a blob.",
            "  *",
            "  * This applies filters as if the blob was being checked out to the",
            "  * working directory under the specified filename.  This may apply",
            "  * CRLF filtering or other types of changes depending on the file",
            "  * attributes set for the blob and the content detected in it.",
            "  *",
            "- * The output is written into a `git_buf` which the caller must free",
            "+ * The output is written into a `git_buf` which the caller must dispose",
            "  * when done (via `git_buf_dispose`).",
            "  *",
            "  * If no filters need to be applied, then the `out` buffer will just",
            "  * be populated with a pointer to the raw content of the blob.  In",
            "  * that case, be careful to *not* free the blob until done with the",
            "  * buffer or copy it into memory you own.",
            "  *",
            "  * @param out The git_buf to be filled in",
            "  * @param blob Pointer to the blob",
            "  * @param as_path Path used for file attribute lookups, etc.",
            "  * @param opts Options to use for filtering the blob",
            "- * @return 0 on success or an error code",
            "+ * @return @type[enum] git_error_code 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_blob_filter(",
            " \tgit_buf *out,",
            " \tgit_blob *blob,",
            " \tconst char *as_path,",
            " \tgit_blob_filter_options *opts);",
            " ",
            " /**",
            "- * Read a file from the working folder of a repository",
            "- * and write it to the Object Database as a loose blob",
            "+ * Read a file from the working folder of a repository and write it",
            "+ * to the object database.",
            "  *",
            "- * @param id return the id of the written blob",
            "+ * @param[out] id return the id of the written blob",
            "  * @param repo repository where the blob will be written.",
            "  *\tthis repository cannot be bare",
            "  * @param relative_path file from which the blob will be created,",
            "  *\trelative to the repository's working dir",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_blob_create_from_workdir(git_oid *id, git_repository *repo, const char *relative_path);",
            " ",
            " /**",
            "- * Read a file from the filesystem and write its content",
            "- * to the Object Database as a loose blob",
            "+ * Read a file from the filesystem (not necessarily inside the",
            "+ * working folder of the repository) and write it to the object",
            "+ * database.",
            "  *",
            "- * @param id return the id of the written blob",
            "+ * @param[out] id return the id of the written blob",
            "  * @param repo repository where the blob will be written.",
            "  *\tthis repository can be bare or not",
            "  * @param path file from which the blob will be created",
            "  * @return 0 or an error code",
            "  */",
            "-GIT_EXTERN(int) git_blob_create_from_disk(git_oid *id, git_repository *repo, const char *path);",
            "+GIT_EXTERN(int) git_blob_create_from_disk(",
            "+\tgit_oid *id,",
            "+\tgit_repository *repo,",
            "+\tconst char *path);",
            " ",
            " /**",
            "- * Create a stream to write a new blob into the object db",
            "+ * Create a stream to write a new blob into the object database.",
            "  *",
            "  * This function may need to buffer the data on disk and will in",
            "  * general not be the right choice if you know the size of the data",
            "  * to write. If you have data in memory, use",
            "  * `git_blob_create_from_buffer()`. If you do not, but know the size of",
            "  * the contents (and don't want/need to perform filtering), use",
            "  * `git_odb_open_wstream()`.",
            "@@ -230,60 +273,60 @@",
            "  * `git_blob_create_from_stream_commit()` to commit the write to the",
            "  * object db and get the object id.",
            "  *",
            "  * If the `hintpath` parameter is filled, it will be used to determine",
            "  * what git filters should be applied to the object before it is written",
            "  * to the object database.",
            "  *",
            "- * @param out the stream into which to write",
            "+ * @param[out] out the stream into which to write",
            "  * @param repo Repository where the blob will be written.",
            "  *        This repository can be bare or not.",
            "  * @param hintpath If not NULL, will be used to select data filters",
            "  *        to apply onto the content of the blob to be created.",
            "  * @return 0 or error code",
            "  */",
            " GIT_EXTERN(int) git_blob_create_from_stream(",
            " \tgit_writestream **out,",
            " \tgit_repository *repo,",
            " \tconst char *hintpath);",
            " ",
            " /**",
            "- * Close the stream and write the blob to the object db",
            "+ * Close the stream and finalize writing the blob to the object database.",
            "  *",
            "  * The stream will be closed and freed.",
            "  *",
            "- * @param out the id of the new blob",
            "+ * @param[out] out the id of the new blob",
            "  * @param stream the stream to close",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_blob_create_from_stream_commit(",
            " \tgit_oid *out,",
            " \tgit_writestream *stream);",
            " ",
            " /**",
            "- * Write an in-memory buffer to the ODB as a blob",
            "+ * Write an in-memory buffer to the object database as a blob.",
            "  *",
            "- * @param id return the id of the written blob",
            "+ * @param[out] id return the id of the written blob",
            "  * @param repo repository where the blob will be written",
            "  * @param buffer data to be written into the blob",
            "  * @param len length of the data",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_blob_create_from_buffer(",
            " \tgit_oid *id, git_repository *repo, const void *buffer, size_t len);",
            " ",
            " /**",
            "- * Determine if the blob content is most certainly binary or not.",
            "+ * Determine if the blob content is most likely binary or not.",
            "  *",
            "  * The heuristic used to guess if a file is binary is taken from core git:",
            "  * Searching for NUL bytes and looking for a reasonable ratio of printable",
            "  * to non-printable characters among the first 8000 bytes.",
            "  *",
            "  * @param blob The blob which content should be analyzed",
            "- * @return 1 if the content of the blob is detected",
            "+ * @return @type bool 1 if the content of the blob is detected",
            "  * as binary; 0 otherwise.",
            "  */",
            " GIT_EXTERN(int) git_blob_is_binary(const git_blob *blob);",
            " ",
            " /**",
            "  * Determine if the given content is most certainly binary or not;",
            "  * this is the same mechanism used by `git_blob_is_binary` but only",
            "@@ -296,15 +339,15 @@",
            "  */",
            " GIT_EXTERN(int) git_blob_data_is_binary(const char *data, size_t len);",
            " ",
            " /**",
            "  * Create an in-memory copy of a blob. The copy must be explicitly",
            "  * free'd or it will leak.",
            "  *",
            "- * @param out Pointer to store the copy of the object",
            "+ * @param[out] out Pointer to store the copy of the object",
            "  * @param source Original object to copy",
            "  * @return 0.",
            "  */",
            " GIT_EXTERN(int) git_blob_dup(git_blob **out, git_blob *source);",
            " ",
            " /** @} */",
            " GIT_END_DECL"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/branch.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/branch.h",
            "+++ /home/libgit2-1.9.1/include/git2/branch.h",
            "@@ -9,17 +9,23 @@",
            " ",
            " #include \"common.h\"",
            " #include \"oid.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/branch.h",
            "- * @brief Git branch parsing routines",
            "+ * @brief Branch creation and handling",
            "  * @defgroup git_branch Git branch management",
            "  * @ingroup Git",
            "+ *",
            "+ * A branch is a specific type of reference, at any particular time,",
            "+ * a git working directory typically is said to have a branch \"checked out\",",
            "+ * meaning that commits that are created will be made \"on\" a branch.",
            "+ * This occurs by updating the branch reference to point to the new",
            "+ * commit. The checked out branch is indicated by the `HEAD` meta-ref.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Create a new branch pointing at a target commit",
            "  *",
            "@@ -29,26 +35,21 @@",
            "  *",
            "  * The returned reference must be freed by the user.",
            "  *",
            "  * The branch name will be checked for validity.",
            "  * See `git_tag_create()` for rules about valid names.",
            "  *",
            "  * @param out Pointer where to store the underlying reference.",
            "- *",
            "  * @param repo the repository to create the branch in.",
            "- *",
            "  * @param branch_name Name for the branch; this name is",
            "- * validated for consistency. It should also not conflict with",
            "- * an already existing branch name.",
            "- *",
            "+ *   validated for consistency. It should also not conflict with",
            "+ *   an already existing branch name.",
            "  * @param target Commit to which this branch should point. This object",
            "- * must belong to the given `repo`.",
            "- *",
            "+ *   must belong to the given `repo`.",
            "  * @param force Overwrite existing branch.",
            "- *",
            "  * @return 0, GIT_EINVALIDSPEC or an error code.",
            "  * A proper reference is written in the refs/heads namespace",
            "  * pointing to the provided target commit.",
            "  */",
            " GIT_EXTERN(int) git_branch_create(",
            " \tgit_reference **out,",
            " \tgit_repository *repo,",
            "@@ -59,23 +60,29 @@",
            " /**",
            "  * Create a new branch pointing at a target commit",
            "  *",
            "  * This behaves like `git_branch_create()` but takes an annotated",
            "  * commit, which lets you specify which extended sha syntax string was",
            "  * specified by a user, allowing for more exact reflog messages.",
            "  *",
            "- * See the documentation for `git_branch_create()`.",
            "- *",
            "- * @see git_branch_create",
            "+ * @param ref_out Pointer where to store the underlying reference.",
            "+ * @param repo the repository to create the branch in.",
            "+ * @param branch_name Name for the branch; this name is",
            "+ *   validated for consistency. It should also not conflict with",
            "+ *   an already existing branch name.",
            "+ * @param target Annotated commit to which this branch should point. This",
            "+ *   object must belong to the given `repo`.",
            "+ * @param force Overwrite existing branch.",
            "+ * @return 0, GIT_EINVALIDSPEC or an error code.",
            "  */",
            " GIT_EXTERN(int) git_branch_create_from_annotated(",
            " \tgit_reference **ref_out,",
            "-\tgit_repository *repository,",
            "+\tgit_repository *repo,",
            " \tconst char *branch_name,",
            "-\tconst git_annotated_commit *commit,",
            "+\tconst git_annotated_commit *target,",
            " \tint force);",
            " ",
            " /**",
            "  * Delete an existing branch reference.",
            "  *",
            "  * Note that if the deletion succeeds, the reference object will not",
            "  * be valid anymore, and should be freed immediately by the user using",
            "@@ -218,15 +225,15 @@",
            "  *",
            "  * @note the actual tracking reference must have been already created for the",
            "  * operation to succeed.",
            "  *",
            "  * @param branch the branch to configure",
            "  * @param branch_name remote-tracking or local branch to set as upstream.",
            "  *",
            "- * @return 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`",
            "+ * @return @type git_error_t 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`",
            "  *         or an error code",
            "  */",
            " GIT_EXTERN(int) git_branch_set_upstream(",
            " \tgit_reference *branch,",
            " \tconst char *branch_name);",
            " ",
            " /**"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/buffer.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/buffer.h",
            "+++ /home/libgit2-1.9.1/include/git2/buffer.h",
            "@@ -7,17 +7,20 @@",
            " #ifndef INCLUDE_git_buf_h__",
            " #define INCLUDE_git_buf_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " /**",
            "  * @file git2/buffer.h",
            "- * @brief Buffer export structure",
            "- *",
            "+ * @brief A data structure to return data to callers",
            "  * @ingroup Git",
            "+ *",
            "+ * The `git_buf` buffer is used to return arbitrary data - typically",
            "+ * strings - to callers. Callers are responsible for freeing the memory",
            "+ * in a buffer with the `git_buf_dispose` function.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * A data buffer for exporting data from libgit2",
            "  *",
            "@@ -63,12 +66,11 @@",
            "  * Note that this does not free the `git_buf` itself, just the memory",
            "  * pointed to by `buffer->ptr`.",
            "  *",
            "  * @param buffer The buffer to deallocate",
            "  */",
            " GIT_EXTERN(void) git_buf_dispose(git_buf *buffer);",
            " ",
            "-GIT_END_DECL",
            "-",
            " /** @} */",
            "+GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/cert.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/cert.h",
            "+++ /home/libgit2-1.9.1/include/git2/cert.h",
            "@@ -8,15 +8,15 @@",
            " #define INCLUDE_git_cert_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/cert.h",
            "- * @brief Git certificate objects",
            "+ * @brief TLS and SSH certificate handling",
            "  * @defgroup git_cert Certificate objects",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "@@ -165,8 +165,9 @@",
            " \t * Length of the memory block pointed to by `data`.",
            " \t */",
            " \tsize_t len;",
            " } git_cert_x509;",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/checkout.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/checkout.h",
            "+++ /home/libgit2-1.9.1/include/git2/checkout.h",
            "@@ -9,17 +9,21 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"diff.h\"",
            " ",
            " /**",
            "  * @file git2/checkout.h",
            "- * @brief Git checkout routines",
            "+ * @brief Update the contents of the working directory",
            "  * @defgroup git_checkout Git checkout routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Update the contents of the working directory, or a subset of the",
            "+ * files in the working directory, to point to the data in the index",
            "+ * or a specific commit.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Checkout behavior flags",
            "  *",
            "@@ -27,52 +31,53 @@",
            "  * to match a target tree.  Unlike git checkout, it does not move the HEAD",
            "  * commit for you - use `git_repository_set_head` or the like to do that.",
            "  *",
            "  * Checkout looks at (up to) four things: the \"target\" tree you want to",
            "  * check out, the \"baseline\" tree of what was checked out previously, the",
            "  * working directory for actual files, and the index for staged changes.",
            "  *",
            "- * You give checkout one of three strategies for update:",
            "- *",
            "- * - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,",
            "- *   etc., but doesn't make any actual changes.",
            "+ * You give checkout one of two strategies for update:",
            "  *",
            "- * - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to",
            "- *   make the working directory match the target (including potentially",
            "- *   discarding modified files).",
            "- *",
            "- * - `GIT_CHECKOUT_SAFE` is between these two options, it will only make",
            "- *   modifications that will not lose changes.",
            "+ * - `GIT_CHECKOUT_SAFE` is the default, and similar to git's default,",
            "+ *   which will make modifications that will not lose changes in the",
            "+ *   working directory.",
            "  *",
            "  *                         |  target == baseline   |  target != baseline  |",
            "  *    ---------------------|-----------------------|----------------------|",
            "  *     workdir == baseline |       no action       |  create, update, or  |",
            "  *                         |                       |     delete file      |",
            "  *    ---------------------|-----------------------|----------------------|",
            "  *     workdir exists and  |       no action       |   conflict (notify   |",
            "  *       is != baseline    | notify dirty MODIFIED | and cancel checkout) |",
            "  *    ---------------------|-----------------------|----------------------|",
            "  *      workdir missing,   | notify dirty DELETED  |     create file      |",
            "  *      baseline present   |                       |                      |",
            "  *    ---------------------|-----------------------|----------------------|",
            "  *",
            "+ * - `GIT_CHECKOUT_FORCE` will take any action to make the working",
            "+ *   directory match the target (including potentially discarding",
            "+ *   modified files).",
            "+ *",
            "  * To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout",
            "  * notification callback (see below) that displays information about dirty",
            "  * files.  The default behavior will cancel checkout on conflicts.",
            "  *",
            "  * To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a",
            "  * notification callback that cancels the operation if a dirty-but-existing",
            "  * file is found in the working directory.  This core git command isn't",
            "  * quite \"force\" but is sensitive about some types of changes.",
            "  *",
            "  * To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.",
            "  *",
            "  *",
            "  * There are some additional flags to modify the behavior of checkout:",
            "  *",
            "+ * - `GIT_CHECKOUT_DRY_RUN` is a dry-run strategy that checks for conflicts,",
            "+ *   etc., but doesn't make any actual changes.",
            "+ *",
            "  * - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates",
            "  *   even if there are conflicts (instead of cancelling the checkout).",
            "  *",
            "  * - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not",
            "  *   in target, baseline, or index, and not ignored) from the working dir.",
            "  *",
            "  * - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also",
            "@@ -98,37 +103,32 @@",
            "  *   are not considered \"precious\" and may be overwritten if the checkout",
            "  *   target contains that file.",
            "  *",
            "  * - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing",
            "  *   files or folders that fold to the same name on case insensitive",
            "  *   filesystems.  This can cause files to retain their existing names",
            "  *   and write through existing symbolic links.",
            "+ *",
            "+ * @flags",
            "  */",
            " typedef enum {",
            "-\tGIT_CHECKOUT_NONE = 0, /**< default is a dry run, no actual updates */",
            "-",
            " \t/**",
            " \t * Allow safe updates that cannot overwrite uncommitted data.",
            "-\t * If the uncommitted changes don't conflict with the checked out files,",
            "-\t * the checkout will still proceed, leaving the changes intact.",
            "-\t *",
            "-\t * Mutually exclusive with GIT_CHECKOUT_FORCE.",
            "-\t * GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.",
            "+\t * If the uncommitted changes don't conflict with the checked",
            "+\t * out files, the checkout will still proceed, leaving the",
            "+\t * changes intact.",
            " \t */",
            "-\tGIT_CHECKOUT_SAFE = (1u << 0),",
            "+\tGIT_CHECKOUT_SAFE = 0,",
            " ",
            " \t/**",
            "-\t * Allow all updates to force working directory to look like index.",
            "-\t *",
            "-\t * Mutually exclusive with GIT_CHECKOUT_SAFE.",
            "-\t * GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.",
            "+\t * Allow all updates to force working directory to look like",
            "+\t * the index, potentially losing data in the process.",
            " \t */",
            " \tGIT_CHECKOUT_FORCE = (1u << 1),",
            " ",
            "-",
            " \t/** Allow checkout to recreate missing files */",
            " \tGIT_CHECKOUT_RECREATE_MISSING = (1u << 2),",
            " ",
            " \t/** Allow checkout to make safe updates even if conflicts are found */",
            " \tGIT_CHECKOUT_ALLOW_CONFLICTS = (1u << 4),",
            " ",
            " \t/** Remove untracked files not in index (that are not ignored) */",
            "@@ -174,31 +174,39 @@",
            " \t/** Don't overwrite existing files or folders */",
            " \tGIT_CHECKOUT_DONT_REMOVE_EXISTING = (1u << 22),",
            " ",
            " \t/** Normally checkout writes the index upon completion; this prevents that. */",
            " \tGIT_CHECKOUT_DONT_WRITE_INDEX = (1u << 23),",
            " ",
            " \t/**",
            "-\t * Show what would be done by a checkout.  Stop after sending",
            "-\t * notifications; don't update the working directory or index.",
            "+\t * Perform a \"dry run\", reporting what _would_ be done but",
            "+\t * without actually making changes in the working directory",
            "+\t * or the index.",
            " \t */",
            " \tGIT_CHECKOUT_DRY_RUN = (1u << 24),",
            " ",
            " \t/** Include common ancestor data in zdiff3 format for conflicts */",
            " \tGIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3 = (1u << 25),",
            " ",
            " \t/**",
            "+\t * Do not do a checkout and do not fire callbacks; this is primarily",
            "+\t * useful only for internal functions that will perform the",
            "+\t * checkout themselves but need to pass checkout options into",
            "+\t * another function, for example, `git_clone`.",
            "+\t*/",
            "+\tGIT_CHECKOUT_NONE = (1u << 30),",
            "+",
            "+\t/*",
            " \t * THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED",
            " \t */",
            " ",
            " \t/** Recursively checkout submodules with same options (NOT IMPLEMENTED) */",
            " \tGIT_CHECKOUT_UPDATE_SUBMODULES = (1u << 16),",
            " \t/** Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED) */",
            " \tGIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = (1u << 17)",
            "-",
            " } git_checkout_strategy_t;",
            " ",
            " /**",
            "  * Checkout notification flags",
            "  *",
            "  * Checkout will invoke an options notification callback (`notify_cb`) for",
            "  * certain cases - you pick which ones via `notify_flags`:",
            "@@ -206,14 +214,16 @@",
            "  * Returning a non-zero value from this callback will cancel the checkout.",
            "  * The non-zero return value will be propagated back and returned by the",
            "  * git_checkout_... call.",
            "  *",
            "  * Notification callbacks are made prior to modifying any files on disk,",
            "  * so canceling on any notification will still happen prior to any files",
            "  * being modified.",
            "+ *",
            "+ * @flags",
            "  */",
            " typedef enum {",
            " \tGIT_CHECKOUT_NOTIFY_NONE      = 0,",
            " ",
            " \t/**",
            " \t * Invokes checkout on conflicting paths.",
            " \t */",
            "@@ -247,53 +257,89 @@",
            " /** Checkout performance-reporting structure */",
            " typedef struct {",
            " \tsize_t mkdir_calls;",
            " \tsize_t stat_calls;",
            " \tsize_t chmod_calls;",
            " } git_checkout_perfdata;",
            " ",
            "-/** Checkout notification callback function */",
            "+/**",
            "+ * Checkout notification callback function.",
            "+ *",
            "+ * @param why the notification reason",
            "+ * @param path the path to the file being checked out",
            "+ * @param baseline the baseline's diff file information",
            "+ * @param target the checkout target diff file information",
            "+ * @param workdir the working directory diff file information",
            "+ * @param payload the user-supplied callback payload",
            "+ * @return 0 on success, or an error code",
            "+ */",
            " typedef int GIT_CALLBACK(git_checkout_notify_cb)(",
            " \tgit_checkout_notify_t why,",
            " \tconst char *path,",
            " \tconst git_diff_file *baseline,",
            " \tconst git_diff_file *target,",
            " \tconst git_diff_file *workdir,",
            " \tvoid *payload);",
            " ",
            "-/** Checkout progress notification function */",
            "+/**",
            "+ * Checkout progress notification function.",
            "+ *",
            "+ * @param path the path to the file being checked out",
            "+ * @param completed_steps number of checkout steps completed",
            "+ * @param total_steps number of total steps in the checkout process",
            "+ * @param payload the user-supplied callback payload",
            "+ */",
            " typedef void GIT_CALLBACK(git_checkout_progress_cb)(",
            " \tconst char *path,",
            " \tsize_t completed_steps,",
            " \tsize_t total_steps,",
            " \tvoid *payload);",
            " ",
            "-/** Checkout perfdata notification function */",
            "+/**",
            "+ * Checkout performance data reporting function.",
            "+ *",
            "+ * @param perfdata the performance data for the checkout",
            "+ * @param payload the user-supplied callback payload",
            "+ */",
            " typedef void GIT_CALLBACK(git_checkout_perfdata_cb)(",
            " \tconst git_checkout_perfdata *perfdata,",
            " \tvoid *payload);",
            " ",
            " /**",
            "  * Checkout options structure",
            "  *",
            "  * Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can",
            "  * use `git_checkout_options_init`.",
            "  *",
            "+ * @options[version] GIT_CHECKOUT_OPTIONS_VERSION",
            "+ * @options[init_macro] GIT_CHECKOUT_OPTIONS_INIT",
            "+ * @options[init_function] git_checkout_options_init",
            "  */",
            " typedef struct git_checkout_options {",
            " \tunsigned int version; /**< The version */",
            " ",
            "+\t/**",
            "+\t * Checkout strategy. Default is a safe checkout.",
            "+\t *",
            "+\t * @type[flags] git_checkout_strategy_t",
            "+\t */",
            " \tunsigned int checkout_strategy; /**< default will be a safe checkout */",
            " ",
            " \tint disable_filters;    /**< don't apply filters like CRLF conversion */",
            " \tunsigned int dir_mode;  /**< default is 0755 */",
            " \tunsigned int file_mode; /**< default is 0644 or 0755 as dictated by blob */",
            " \tint file_open_flags;    /**< default is O_CREAT | O_TRUNC | O_WRONLY */",
            " ",
            "-\tunsigned int notify_flags; /**< see `git_checkout_notify_t` above */",
            "+\t/**",
            "+\t * Checkout notification flags specify what operations the notify",
            "+\t * callback is invoked for.",
            "+\t *",
            "+\t * @type[flags] git_checkout_notify_t",
            "+\t */",
            "+\tunsigned int notify_flags;",
            " ",
            " \t/**",
            " \t * Optional callback to get notifications on specific file states.",
            " \t * @see git_checkout_notify_t",
            " \t */",
            " \tgit_checkout_notify_cb notify_cb;",
            " ",
            "@@ -340,16 +386,20 @@",
            " \t/** Optional callback to notify the consumer of performance data. */",
            " \tgit_checkout_perfdata_cb perfdata_cb;",
            " ",
            " \t/** Payload passed to perfdata_cb */",
            " \tvoid *perfdata_payload;",
            " } git_checkout_options;",
            " ",
            "+",
            "+/** Current version for the `git_checkout_options` structure */",
            " #define GIT_CHECKOUT_OPTIONS_VERSION 1",
            "-#define GIT_CHECKOUT_OPTIONS_INIT {GIT_CHECKOUT_OPTIONS_VERSION, GIT_CHECKOUT_SAFE}",
            "+",
            "+/** Static constructor for `git_checkout_options` */",
            "+#define GIT_CHECKOUT_OPTIONS_INIT { GIT_CHECKOUT_OPTIONS_VERSION }",
            " ",
            " /**",
            "  * Initialize git_checkout_options structure",
            "  *",
            "  * Initializes a `git_checkout_options` with default values. Equivalent to creating",
            "  * an instance with GIT_CHECKOUT_OPTIONS_INIT.",
            "  *",
            "@@ -410,8 +460,9 @@",
            " GIT_EXTERN(int) git_checkout_tree(",
            " \tgit_repository *repo,",
            " \tconst git_object *treeish,",
            " \tconst git_checkout_options *opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/cherrypick.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/cherrypick.h",
            "+++ /home/libgit2-1.9.1/include/git2/cherrypick.h",
            "@@ -9,17 +9,20 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"merge.h\"",
            " ",
            " /**",
            "  * @file git2/cherrypick.h",
            "- * @brief Git cherry-pick routines",
            "+ * @brief Cherry-pick the contents of an individual commit",
            "  * @defgroup git_cherrypick Git cherry-pick routines",
            "  * @ingroup Git",
            "+ *",
            "+ * \"Cherry-pick\" will attempts to re-apply the changes in an",
            "+ * individual commit to the current index and working directory.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Cherry-pick options",
            "  */",
            "@@ -29,16 +32,21 @@",
            " \t/** For merge commits, the \"mainline\" is treated as the parent. */",
            " \tunsigned int mainline;",
            " ",
            " \tgit_merge_options merge_opts; /**< Options for the merging */",
            " \tgit_checkout_options checkout_opts; /**< Options for the checkout */",
            " } git_cherrypick_options;",
            " ",
            "+/** Current version for the `git_cherrypick_options` structure */",
            " #define GIT_CHERRYPICK_OPTIONS_VERSION 1",
            "-#define GIT_CHERRYPICK_OPTIONS_INIT {GIT_CHERRYPICK_OPTIONS_VERSION, 0, GIT_MERGE_OPTIONS_INIT, GIT_CHECKOUT_OPTIONS_INIT}",
            "+",
            "+/** Static constructor for `git_cherrypick_options` */",
            "+#define GIT_CHERRYPICK_OPTIONS_INIT { \\",
            "+\tGIT_CHERRYPICK_OPTIONS_VERSION, 0, \\",
            "+\tGIT_MERGE_OPTIONS_INIT, GIT_CHECKOUT_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_cherrypick_options structure",
            "  *",
            "  * Initializes a `git_cherrypick_options` with default values. Equivalent to creating",
            "  * an instance with GIT_CHERRYPICK_OPTIONS_INIT.",
            "  *",
            "@@ -85,8 +93,7 @@",
            " \tgit_commit *commit,",
            " \tconst git_cherrypick_options *cherrypick_options);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            " ",
            " #endif",
            "-"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/clone.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/clone.h",
            "+++ /home/libgit2-1.9.1/include/git2/clone.h",
            "@@ -13,17 +13,21 @@",
            " #include \"checkout.h\"",
            " #include \"remote.h\"",
            " #include \"transport.h\"",
            " ",
            " ",
            " /**",
            "  * @file git2/clone.h",
            "- * @brief Git cloning routines",
            "+ * @brief Clone a remote repository to the local disk",
            "  * @defgroup git_clone Git cloning routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Clone will take a remote repository - located on a remote server",
            "+ * accessible by HTTPS or SSH, or a repository located elsewhere on",
            "+ * the local disk - and place a copy in the given local path.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Options for bypassing the git-aware transport on clone. Bypassing",
            "  * it means that instead of a fetch, libgit2 will copy the object",
            "@@ -55,15 +59,15 @@",
            " /**",
            "  * The signature of a function matching git_remote_create, with an additional",
            "  * void* as a callback payload.",
            "  *",
            "  * Callers of git_clone may provide a function matching this signature to override",
            "  * the remote creation and customization process during a clone operation.",
            "  *",
            "- * @param out the resulting remote",
            "+ * @param[out] out the resulting remote",
            "  * @param repo the repository in which to create the remote",
            "  * @param name the remote's name",
            "  * @param url the remote's url",
            "  * @param payload an opaque payload",
            "  * @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_remote_create_cb)(",
            "@@ -77,15 +81,15 @@",
            "  * The signature of a function matching git_repository_init, with an",
            "  * additional void * as callback payload.",
            "  *",
            "  * Callers of git_clone my provide a function matching this signature",
            "  * to override the repository creation and customization process",
            "  * during a clone operation.",
            "  *",
            "- * @param out the resulting repository",
            "+ * @param[out] out the resulting repository",
            "  * @param path path in which to create the repository",
            "  * @param bare whether the repository is bare. This is the value from the clone options",
            "  * @param payload payload specified by the options",
            "  * @return 0, or a negative value to indicate error",
            "  */",
            " typedef int GIT_CALLBACK(git_repository_create_cb)(",
            " \tgit_repository **out,",
            "@@ -95,22 +99,25 @@",
            " ",
            " /**",
            "  * Clone options structure",
            "  *",
            "  * Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can",
            "  * use `git_clone_options_init`.",
            "  *",
            "+ * @options[version] GIT_CLONE_OPTIONS_VERSION",
            "+ * @options[init_macro] GIT_CLONE_OPTIONS_INIT",
            "+ * @options[init_function] git_clone_options_init",
            "  */",
            " typedef struct git_clone_options {",
            " \tunsigned int version;",
            " ",
            " \t/**",
            " \t * These options are passed to the checkout step. To disable",
            "-\t * checkout, set the `checkout_strategy` to",
            "-\t * `GIT_CHECKOUT_NONE`.",
            "+\t * checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`",
            "+\t * or `GIT_CHECKOUT_DRY_RUN`.",
            " \t */",
            " \tgit_checkout_options checkout_opts;",
            " ",
            " \t/**",
            " \t * Options which control the fetch, including callbacks.",
            " \t *",
            " \t * The callbacks are used for reporting fetch progress, and for acquiring",
            "@@ -159,18 +166,22 @@",
            " \t/**",
            " \t * An opaque payload to pass to the git_remote creation callback.",
            " \t * This parameter is ignored unless remote_cb is non-NULL.",
            " \t */",
            " \tvoid *remote_cb_payload;",
            " } git_clone_options;",
            " ",
            "+/** Current version for the `git_clone_options` structure */",
            " #define GIT_CLONE_OPTIONS_VERSION 1",
            "-#define GIT_CLONE_OPTIONS_INIT { GIT_CLONE_OPTIONS_VERSION, \\",
            "-\t{ GIT_CHECKOUT_OPTIONS_VERSION, GIT_CHECKOUT_SAFE }, \\",
            "-\tGIT_FETCH_OPTIONS_INIT }",
            "+",
            "+/** Static constructor for `git_clone_options` */",
            "+#define GIT_CLONE_OPTIONS_INIT \\",
            "+\t{ GIT_CLONE_OPTIONS_VERSION, \\",
            "+\t  GIT_CHECKOUT_OPTIONS_INIT, \\",
            "+\t  GIT_FETCH_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_clone_options structure",
            "  *",
            "  * Initializes a `git_clone_options` with default values. Equivalent to creating",
            "  * an instance with GIT_CLONE_OPTIONS_INIT.",
            "  *",
            "@@ -185,15 +196,19 @@",
            " /**",
            "  * Clone a remote repository.",
            "  *",
            "  * By default this creates its repository and initial remote to match",
            "  * git's defaults. You can use the options in the callback to",
            "  * customize how these are created.",
            "  *",
            "- * @param out pointer that will receive the resulting repository object",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "+ * @param[out] out pointer that will receive the resulting repository object",
            "  * @param url the remote repository to clone",
            "  * @param local_path local directory to clone to",
            "  * @param options configuration options for the clone.  If NULL, the",
            "  *        function works as though GIT_OPTIONS_INIT were passed.",
            "  * @return 0 on success, any non-zero return value from a callback",
            "  *         function, or a negative value to indicate an error (use",
            "  *         `git_error_last` for a detailed error message)",
            "@@ -202,8 +217,9 @@",
            " \tgit_repository **out,",
            " \tconst char *url,",
            " \tconst char *local_path,",
            " \tconst git_clone_options *options);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/commit.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/commit.h",
            "+++ /home/libgit2-1.9.1/include/git2/commit.h",
            "@@ -10,17 +10,21 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"object.h\"",
            " ",
            " /**",
            "  * @file git2/commit.h",
            "- * @brief Git commit parsing, formatting routines",
            "+ * @brief A representation of a set of changes in the repository",
            "  * @defgroup git_commit Git commit parsing, formatting routines",
            "  * @ingroup Git",
            "+ *",
            "+ * A commit represents a set of changes made to the files within a",
            "+ * repository, and metadata about who made the changes, and when the",
            "+ * changes were made.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Lookup a commit object from a repository.",
            "  *",
            "@@ -376,15 +380,46 @@",
            "  *",
            "  * The parents for the commit are specified as a variable list of pointers",
            "  * to `const git_commit *`. Note that this is a convenience method which may",
            "  * not be safe to export for certain languages or compilers",
            "  *",
            "  * All other parameters remain the same as `git_commit_create()`.",
            "  *",
            "- * @see git_commit_create",
            "+ * @param id Pointer in which to store the OID of the newly created commit",
            "+ *",
            "+ * @param repo Repository where to store the commit",
            "+ *",
            "+ * @param update_ref If not NULL, name of the reference that",
            "+ *\twill be updated to point to this commit. If the reference",
            "+ *\tis not direct, it will be resolved to a direct reference.",
            "+ *\tUse \"HEAD\" to update the HEAD of the current branch and",
            "+ *\tmake it point to this commit. If the reference doesn't",
            "+ *\texist yet, it will be created. If it does exist, the first",
            "+ *\tparent must be the tip of this branch.",
            "+ *",
            "+ * @param author Signature with author and author time of commit",
            "+ *",
            "+ * @param committer Signature with committer and * commit time of commit",
            "+ *",
            "+ * @param message_encoding The encoding for the message in the",
            "+ *  commit, represented with a standard encoding name.",
            "+ *  E.g. \"UTF-8\". If NULL, no encoding header is written and",
            "+ *  UTF-8 is assumed.",
            "+ *",
            "+ * @param message Full message for this commit",
            "+ *",
            "+ * @param tree An instance of a `git_tree` object that will",
            "+ *  be used as the tree for the commit. This tree object must",
            "+ *  also be owned by the given `repo`.",
            "+ *",
            "+ * @param parent_count Number of parents for this commit",
            "+ *",
            "+ * @return 0 or an error code",
            "+ *\tThe created commit will be written to the Object Database and",
            "+ *\tthe given reference will be updated to point to it",
            "  */",
            " GIT_EXTERN(int) git_commit_create_v(",
            " \tgit_oid *id,",
            " \tgit_repository *repo,",
            " \tconst char *update_ref,",
            " \tconst git_signature *author,",
            " \tconst git_signature *committer,",
            "@@ -412,15 +447,18 @@",
            " \t/** The committer, or NULL for the default. */",
            " \tconst git_signature *committer;",
            " ",
            " \t/** Encoding for the commit message; leave NULL for default. */",
            " \tconst char *message_encoding;",
            " } git_commit_create_options;",
            " ",
            "+/** Current version for the `git_commit_create_options` structure */",
            " #define GIT_COMMIT_CREATE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_commit_create_options` */",
            " #define GIT_COMMIT_CREATE_OPTIONS_INIT { GIT_COMMIT_CREATE_OPTIONS_VERSION }",
            " ",
            " /**",
            "  * Commits the staged changes in the repository; this is a near analog to",
            "  * `git commit -m message`.",
            "  *",
            "  * By default, empty commits are not allowed.",
            "@@ -452,15 +490,44 @@",
            "  *",
            "  * Unlike `git_commit_create()`, the `author`, `committer`, `message`,",
            "  * `message_encoding`, and `tree` parameters can be NULL in which case this",
            "  * will use the values from the original `commit_to_amend`.",
            "  *",
            "  * All parameters have the same meanings as in `git_commit_create()`.",
            "  *",
            "- * @see git_commit_create",
            "+ * @param id Pointer in which to store the OID of the newly created commit",
            "+ *",
            "+ * @param commit_to_amend The commit to amend",
            "+ *",
            "+ * @param update_ref If not NULL, name of the reference that",
            "+ *\twill be updated to point to this commit. If the reference",
            "+ *\tis not direct, it will be resolved to a direct reference.",
            "+ *\tUse \"HEAD\" to update the HEAD of the current branch and",
            "+ *\tmake it point to this commit. If the reference doesn't",
            "+ *\texist yet, it will be created. If it does exist, the first",
            "+ *\tparent must be the tip of this branch.",
            "+ *",
            "+ * @param author Signature with author and author time of commit",
            "+ *",
            "+ * @param committer Signature with committer and * commit time of commit",
            "+ *",
            "+ * @param message_encoding The encoding for the message in the",
            "+ *  commit, represented with a standard encoding name.",
            "+ *  E.g. \"UTF-8\". If NULL, no encoding header is written and",
            "+ *  UTF-8 is assumed.",
            "+ *",
            "+ * @param message Full message for this commit",
            "+ *",
            "+ * @param tree An instance of a `git_tree` object that will",
            "+ *  be used as the tree for the commit. This tree object must",
            "+ *  also be owned by the given `repo`.",
            "+ *",
            "+ * @return 0 or an error code",
            "+ *\tThe created commit will be written to the Object Database and",
            "+ *\tthe given reference will be updated to point to it",
            "  */",
            " GIT_EXTERN(int) git_commit_amend(",
            " \tgit_oid *id,",
            " \tconst git_commit *commit_to_amend,",
            " \tconst char *update_ref,",
            " \tconst git_signature *author,",
            " \tconst git_signature *committer,",
            "@@ -600,8 +667,9 @@",
            "  *",
            "  * @param array The git_commitarray that contains commits to free",
            "  */",
            " GIT_EXTERN(void) git_commitarray_dispose(git_commitarray *array);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/common.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/common.h",
            "+++ /home/libgit2-1.9.1/include/git2/common.h",
            "@@ -7,15 +7,17 @@",
            " #ifndef INCLUDE_git_common_h__",
            " #define INCLUDE_git_common_h__",
            " ",
            " #include <time.h>",
            " #include <stdlib.h>",
            " ",
            " #ifdef __cplusplus",
            "+ /** Start declarations in C mode for C++ compatibility */",
            " # define GIT_BEGIN_DECL extern \"C\" {",
            "+ /** End declarations in C mode */",
            " # define GIT_END_DECL\t}",
            " #else",
            "  /** Start declarations in C mode */",
            " # define GIT_BEGIN_DECL /* empty */",
            "  /** End declarations in C mode */",
            " # define GIT_END_DECL\t/* empty */",
            " #endif",
            "@@ -67,41 +69,41 @@",
            " /** Declare a function's takes printf style arguments. */",
            " #ifdef __GNUC__",
            " # define GIT_FORMAT_PRINTF(a,b) __attribute__((format (printf, a, b)))",
            " #else",
            " # define GIT_FORMAT_PRINTF(a,b) /* empty */",
            " #endif",
            " ",
            "-#if (defined(_WIN32)) && !defined(__CYGWIN__)",
            "-#define GIT_WIN32 1",
            "-#endif",
            "-",
            " #ifdef __amigaos4__",
            " #include <netinet/in.h>",
            " #endif",
            " ",
            " /**",
            "  * @file git2/common.h",
            "- * @brief Git common platform definitions",
            "+ * @brief Base platform functionality",
            "  * @defgroup git_common Git common platform definitions",
            "  * @ingroup Git",
            "+ *",
            "+ * Common platform functionality including introspecting libgit2",
            "+ * itself - information like how it was built, and the current",
            "+ * running version.",
            "  * @{",
            "  */",
            " ",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * The separator used in path list strings (ie like in the PATH",
            "  * environment variable). A semi-colon \";\" is used on Windows and",
            "  * AmigaOS, and a colon \":\" for all other systems.",
            "  */",
            "-#if defined(GIT_WIN32) || defined(AMIGA)",
            "-#define GIT_PATH_LIST_SEPARATOR ';'",
            "+#if (defined(_WIN32) && !defined(__CYGWIN__)) || defined(AMIGA)",
            "+# define GIT_PATH_LIST_SEPARATOR ';'",
            " #else",
            "-#define GIT_PATH_LIST_SEPARATOR ':'",
            "+# define GIT_PATH_LIST_SEPARATOR ':'",
            " #endif",
            " ",
            " /**",
            "  * The maximum length of a valid git path.",
            "  */",
            " #define GIT_PATH_MAX 4096",
            " ",
            "@@ -124,64 +126,88 @@",
            "  * NULL.",
            "  *",
            "  * @return the name of the prerelease state or NULL",
            "  */",
            " GIT_EXTERN(const char *) git_libgit2_prerelease(void);",
            " ",
            " /**",
            "- * Combinations of these values describe the features with which libgit2",
            "- * was compiled",
            "+ * Configurable features of libgit2; either optional settings (like",
            "+ * threading), or features that can be enabled by one of a number of",
            "+ * different backend \"providers\" (like HTTPS, which can be provided by",
            "+ * OpenSSL, mbedTLS, or system libraries).",
            "  */",
            " typedef enum {",
            "-  /**",
            "-   * If set, libgit2 was built thread-aware and can be safely used from multiple",
            "-   * threads.",
            "-   */",
            "-\tGIT_FEATURE_THREADS\t= (1 << 0),",
            "-  /**",
            "-   * If set, libgit2 was built with and linked against a TLS implementation.",
            "-   * Custom TLS streams may still be added by the user to support HTTPS",
            "-   * regardless of this.",
            "-   */",
            "-\tGIT_FEATURE_HTTPS\t= (1 << 1),",
            "-  /**",
            "-   * If set, libgit2 was built with and linked against libssh2. A custom",
            "-   * transport may still be added by the user to support libssh2 regardless of",
            "-   * this.",
            "-   */",
            "-\tGIT_FEATURE_SSH\t\t= (1 << 2),",
            "-  /**",
            "-   * If set, libgit2 was built with support for sub-second resolution in file",
            "-   * modification times.",
            "-   */",
            "-\tGIT_FEATURE_NSEC\t= (1 << 3)",
            "+\t/**",
            "+\t * libgit2 is thread-aware and can be used from multiple threads",
            "+\t * (as described in the documentation).",
            "+\t */",
            "+\tGIT_FEATURE_THREADS        = (1 << 0),",
            "+",
            "+\t/** HTTPS remotes */",
            "+\tGIT_FEATURE_HTTPS          = (1 << 1),",
            "+",
            "+\t/** SSH remotes */",
            "+\tGIT_FEATURE_SSH\t           = (1 << 2),",
            "+",
            "+\t/** Sub-second resolution in index timestamps */",
            "+\tGIT_FEATURE_NSEC           = (1 << 3),",
            "+",
            "+\t/** HTTP parsing; always available */",
            "+\tGIT_FEATURE_HTTP_PARSER    = (1 << 4),",
            "+",
            "+\t/** Regular expression support; always available */",
            "+\tGIT_FEATURE_REGEX          = (1 << 5),",
            "+",
            "+\t/** Internationalization support for filename translation */",
            "+\tGIT_FEATURE_I18N           = (1 << 6),",
            "+",
            "+\t/** NTLM support over HTTPS */",
            "+\tGIT_FEATURE_AUTH_NTLM      = (1 << 7),",
            "+",
            "+\t/** Kerberos (SPNEGO) authentication support over HTTPS */",
            "+\tGIT_FEATURE_AUTH_NEGOTIATE = (1 << 8),",
            "+",
            "+\t/** zlib support; always available */",
            "+\tGIT_FEATURE_COMPRESSION    = (1 << 9),",
            "+",
            "+\t/** SHA1 object support; always available */",
            "+\tGIT_FEATURE_SHA1           = (1 << 10),",
            "+",
            "+\t/** SHA256 object support */",
            "+\tGIT_FEATURE_SHA256         = (1 << 11)",
            " } git_feature_t;",
            " ",
            " /**",
            "  * Query compile time options for libgit2.",
            "  *",
            "  * @return A combination of GIT_FEATURE_* values.",
            "+ */",
            "+GIT_EXTERN(int) git_libgit2_features(void);",
            "+",
            "+/**",
            "+ * Query the backend details for the compile-time feature in libgit2.",
            "  *",
            "- * - GIT_FEATURE_THREADS",
            "- *   Libgit2 was compiled with thread support. Note that thread support is",
            "- *   still to be seen as a 'work in progress' - basic object lookups are",
            "- *   believed to be threadsafe, but other operations may not be.",
            "- *",
            "- * - GIT_FEATURE_HTTPS",
            "- *   Libgit2 supports the https:// protocol. This requires the openssl",
            "- *   library to be found when compiling libgit2.",
            "- *",
            "- * - GIT_FEATURE_SSH",
            "- *   Libgit2 supports the SSH protocol for network operations. This requires",
            "- *   the libssh2 library to be found when compiling libgit2",
            "+ * This will return the \"backend\" for the feature, which is useful for",
            "+ * things like HTTPS or SSH support, that can have multiple backends",
            "+ * that could be compiled in.",
            "+ *",
            "+ * For example, when libgit2 is compiled with dynamic OpenSSL support,",
            "+ * the feature backend will be `openssl-dynamic`. The feature backend",
            "+ * names reflect the compilation options specified to the build system",
            "+ * (though in all lower case). The backend _may_ be \"builtin\" for",
            "+ * features that are provided by libgit2 itself.",
            "  *",
            "- * - GIT_FEATURE_NSEC",
            "- *   Libgit2 supports the sub-second resolution in file modification times.",
            "+ * If the feature is not supported by the library, this API returns",
            "+ * `NULL`.",
            "+ *",
            "+ * @param feature the feature to query details for",
            "+ * @return the provider details, or NULL if the feature is not supported",
            "  */",
            "-GIT_EXTERN(int) git_libgit2_features(void);",
            "+GIT_EXTERN(const char *) git_libgit2_feature_backend(",
            "+\tgit_feature_t feature);",
            " ",
            " /**",
            "  * Global library options",
            "  *",
            "  * These are used to select which global option to set or get and are",
            "  * used in `git_libgit2_opts()`.",
            "  */",
            "@@ -226,15 +252,16 @@",
            " \tGIT_OPT_GET_HOMEDIR,",
            " \tGIT_OPT_SET_HOMEDIR,",
            " \tGIT_OPT_SET_SERVER_CONNECT_TIMEOUT,",
            " \tGIT_OPT_GET_SERVER_CONNECT_TIMEOUT,",
            " \tGIT_OPT_SET_SERVER_TIMEOUT,",
            " \tGIT_OPT_GET_SERVER_TIMEOUT,",
            " \tGIT_OPT_SET_USER_AGENT_PRODUCT,",
            "-\tGIT_OPT_GET_USER_AGENT_PRODUCT",
            "+\tGIT_OPT_GET_USER_AGENT_PRODUCT,",
            "+\tGIT_OPT_ADD_SSL_X509_CERT",
            " } git_libgit2_opt_t;",
            " ",
            " /**",
            "  * Set or query a library global option",
            "  *",
            "  * Available options:",
            "  *",
            "@@ -331,16 +358,29 @@",
            "  *\t\t> Set the SSL certificate-authority locations.",
            "  *\t\t>",
            "  *\t\t> - `file` is the location of a file containing several",
            "  *\t\t>   certificates concatenated together.",
            "  *\t\t> - `path` is the location of a directory holding several",
            "  *\t\t>   certificates, one per file.",
            "  *\t\t>",
            "+ *\t\t> Calling `GIT_OPT_ADD_SSL_X509_CERT` may override the",
            "+ *\t\t> data in `path`.",
            "+ *\t\t>",
            "  * \t\t> Either parameter may be `NULL`, but not both.",
            "  *",
            "+ *  * opts(GIT_OPT_ADD_SSL_X509_CERT, const X509 *cert)",
            "+ *",
            "+ *\t\t> Add a raw X509 certificate into the SSL certs store.",
            "+ *\t\t> This certificate is only used by libgit2 invocations",
            "+ *\t\t> during the application lifetime and is not persisted",
            "+ *\t\t> to disk. This certificate cannot be removed from the",
            "+ *\t\t> application once is has been added.",
            "+ *\t\t>",
            "+ *\t\t> - `cert` is the raw X509 cert will be added to cert store.",
            "+ *",
            "  *\t* opts(GIT_OPT_SET_USER_AGENT, const char *user_agent)",
            "  *",
            "  *\t\t> Set the value of the comment section of the User-Agent header.",
            "  *\t\t> This can be information about your product and its version.",
            "  *\t\t> By default this is \"libgit2\" followed by the libgit2 version.",
            "  *\t\t>",
            "  *\t\t> This value will be appended to User-Agent _product_, which",
            "@@ -520,15 +560,14 @@",
            "  *      > to a remote server.",
            "  *",
            "  *   opts(GIT_OPT_SET_SERVER_TIMEOUT, int timeout)",
            "  *      > Sets the timeout (in milliseconds) for reading from and writing",
            "  *      > to a remote server. Set to 0 to use the system default.",
            "  *",
            "  * @param option Option key",
            "- * @param ... value to set the option",
            "  * @return 0 on success, <0 on failure",
            "  */",
            " GIT_EXTERN(int) git_libgit2_opts(int option, ...);",
            " ",
            " /** @} */",
            " GIT_END_DECL"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/config.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/config.h",
            "+++ /home/libgit2-1.9.1/include/git2/config.h",
            "@@ -9,17 +9,21 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/config.h",
            "- * @brief Git config management routines",
            "+ * @brief Per-repository, per-user or per-system configuration",
            "  * @defgroup git_config Git config management routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Git configuration affects the operation of the version control",
            "+ * system, and can be specified on a per-repository basis, in user",
            "+ * settings, or at the system level.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Priority level of a config file.",
            "  *",
            "@@ -34,99 +38,113 @@",
            "  *",
            "  * Writes, by default, occur in the highest priority level backend",
            "  * that is writable. This ordering can be overridden with",
            "  * `git_config_set_writeorder`.",
            "  *",
            "  * git_config_open_default() and git_repository_config() honor those",
            "  * priority levels as well.",
            "+ *",
            "+ * @see git_config_open_default",
            "+ * @see git_repository_config",
            "  */",
            " typedef enum {",
            "-\t/** System-wide on Windows, for compatibility with portable git */",
            "+\t/**",
            "+\t * System-wide on Windows, for compatibility with \"Portable Git\".",
            "+\t */",
            " \tGIT_CONFIG_LEVEL_PROGRAMDATA = 1,",
            " ",
            "-\t/** System-wide configuration file; /etc/gitconfig on Linux systems */",
            "+\t/**",
            "+\t * System-wide configuration file; `/etc/gitconfig` on Linux.",
            "+\t */",
            " \tGIT_CONFIG_LEVEL_SYSTEM = 2,",
            " ",
            "-\t/** XDG compatible configuration file; typically ~/.config/git/config */",
            "+\t/**",
            "+\t * XDG compatible configuration file; typically",
            "+\t * `~/.config/git/config`.",
            "+\t */",
            " \tGIT_CONFIG_LEVEL_XDG = 3,",
            " ",
            "-\t/** User-specific configuration file (also called Global configuration",
            "-\t * file); typically ~/.gitconfig",
            "+\t/**",
            "+\t * Global configuration file is the user-specific configuration;",
            "+\t * typically `~/.gitconfig`.",
            " \t */",
            " \tGIT_CONFIG_LEVEL_GLOBAL = 4,",
            " ",
            "-\t/** Repository specific configuration file; $WORK_DIR/.git/config on",
            "-\t * non-bare repos",
            "+\t/**",
            "+\t * Local configuration, the repository-specific configuration file;",
            "+\t * typically `$GIT_DIR/config`.",
            " \t */",
            " \tGIT_CONFIG_LEVEL_LOCAL = 5,",
            " ",
            "-\t/** Worktree specific configuration file; $GIT_DIR/config.worktree",
            "+\t/**",
            "+\t * Worktree-specific configuration; typically",
            "+\t * `$GIT_DIR/config.worktree`.",
            " \t */",
            " \tGIT_CONFIG_LEVEL_WORKTREE = 6,",
            " ",
            "-\t/** Application specific configuration file; freely defined by applications",
            "+\t/**",
            "+\t * Application-specific configuration file. Callers into libgit2",
            "+\t * can add their own configuration beginning at this level.",
            " \t */",
            " \tGIT_CONFIG_LEVEL_APP = 7,",
            " ",
            "-\t/** Represents the highest level available config file (i.e. the most",
            "-\t * specific config file available that actually is loaded)",
            "+\t/**",
            "+\t * Not a configuration level; callers can use this value when",
            "+\t * querying configuration levels to specify that they want to",
            "+\t * have data from the highest-level currently configuration.",
            "+\t * This can be used to indicate that callers want the most",
            "+\t * specific config file available that actually is loaded.",
            " \t */",
            " \tGIT_CONFIG_HIGHEST_LEVEL = -1",
            " } git_config_level_t;",
            " ",
            " /**",
            "  * An entry in a configuration file",
            "  */",
            " typedef struct git_config_entry {",
            "-\t/** Name of the configuration entry (normalized) */",
            "+\t/** Name of the configuration entry (normalized). */",
            " \tconst char *name;",
            " ",
            "-\t/** Literal (string) value of the entry */",
            "+\t/** Literal (string) value of the entry. */",
            " \tconst char *value;",
            " ",
            "-\t/** The type of backend that this entry exists in (eg, \"file\") */",
            "+\t/** The type of backend that this entry exists in (eg, \"file\"). */",
            " \tconst char *backend_type;",
            " ",
            " \t/**",
            " \t * The path to the origin of this entry. For config files, this is",
            " \t * the path to the file.",
            " \t */",
            " \tconst char *origin_path;",
            " ",
            "-\t/** Depth of includes where this variable was found */",
            "+\t/** Depth of includes where this variable was found. */",
            " \tunsigned int include_depth;",
            " ",
            "-\t/** Configuration level for the file this was found in */",
            "+\t/** Configuration level for the file this was found in. */",
            " \tgit_config_level_t level;",
            "-",
            "-\t/**",
            "-\t * Free function for this entry; for internal purposes. Callers",
            "-\t * should call `git_config_entry_free` to free data.",
            "-\t */",
            "-\tvoid GIT_CALLBACK(free)(struct git_config_entry *entry);",
            " } git_config_entry;",
            " ",
            " /**",
            "- * Free a config entry",
            "+ * Free a config entry.",
            "  *",
            "  * @param entry The entry to free.",
            "  */",
            " GIT_EXTERN(void) git_config_entry_free(git_config_entry *entry);",
            " ",
            " /**",
            "- * A config enumeration callback",
            "+ * A config enumeration callback.",
            "  *",
            "  * @param entry the entry currently being enumerated",
            "  * @param payload a user-specified pointer",
            "  * @return non-zero to terminate the iteration.",
            "  */",
            " typedef int GIT_CALLBACK(git_config_foreach_cb)(const git_config_entry *entry, void *payload);",
            " ",
            " /**",
            "- * An opaque structure for a configuration iterator",
            "+ * An opaque structure for a configuration iterator.",
            "  */",
            " typedef struct git_config_iterator git_config_iterator;",
            " ",
            " /**",
            "  * Config var type",
            "  */",
            " typedef enum {",
            "@@ -243,17 +261,17 @@",
            "  * Further queries on this config object will access each",
            "  * of the config file instances in order (instances with",
            "  * a higher priority level will be accessed first).",
            "  *",
            "  * @param cfg the configuration to add the file to",
            "  * @param path path to the configuration file to add",
            "  * @param level the priority level of the backend",
            "- * @param force replace config file at the given priority level",
            "  * @param repo optional repository to allow parsing of",
            "  *  conditional includes",
            "+ * @param force replace config file at the given priority level",
            "  * @return 0 on success, GIT_EEXISTS when adding more than one file",
            "  *  for a given priority level (and force_replace set to 0),",
            "  *  GIT_ENOTFOUND when the file doesn't exist or error code",
            "  */",
            " GIT_EXTERN(int) git_config_add_file_ondisk(",
            " \tgit_config *cfg,",
            " \tconst char *path,",
            "@@ -307,14 +325,25 @@",
            "  *",
            "  * @param out pointer in which to store the config object",
            "  * @param config the config object in which to look",
            "  * @return 0 or an error code.",
            "  */",
            " GIT_EXTERN(int) git_config_open_global(git_config **out, git_config *config);",
            " ",
            "+/**",
            "+ * Set the write order for configuration backends. By default, the",
            "+ * write ordering does not match the read ordering; for example, the",
            "+ * worktree configuration is a high-priority for reading, but is not",
            "+ * written to unless explicitly chosen.",
            "+ *",
            "+ * @param cfg the configuration to change write order of",
            "+ * @param levels the ordering of levels for writing",
            "+ * @param len the length of the levels array",
            "+ * @return 0 or an error code",
            "+ */",
            " GIT_EXTERN(int) git_config_set_writeorder(",
            " \tgit_config *cfg,",
            " \tgit_config_level_t *levels,",
            " \tsize_t len);",
            " ",
            " /**",
            "  * Create a snapshot of the configuration",
            "@@ -815,8 +844,9 @@",
            "  * @param cfg the configuration in which to lock",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_config_lock(git_transaction **tx, git_config *cfg);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/credential.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/credential.h",
            "+++ /home/libgit2-1.9.1/include/git2/credential.h",
            "@@ -7,17 +7,20 @@",
            " #ifndef INCLUDE_git_credential_h__",
            " #define INCLUDE_git_credential_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " /**",
            "  * @file git2/credential.h",
            "- * @brief Git authentication & credential management",
            "+ * @brief Authentication and credential management",
            "  * @defgroup git_credential Authentication & credential management",
            "  * @ingroup Git",
            "+ *",
            "+ * Credentials specify how to authenticate to a remote system",
            "+ * over HTTPS or SSH.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Supported credential types",
            "  *",
            "@@ -115,15 +118,15 @@",
            "  * git_credential_t bitmask).",
            "  *",
            "  * Note that most authentication details are your responsibility - this",
            "  * callback will be called until the authentication succeeds, or you report",
            "  * an error. As such, it's easy to get in a loop if you fail to stop providing",
            "  * the same incorrect credentials.",
            "  *",
            "- * @param out The newly created credential object.",
            "+ * @param[out] out The newly created credential object.",
            "  * @param url The resource for which we are demanding a credential.",
            "  * @param username_from_url The username that was embedded in a \"user\\@host\"",
            "  *                          remote url, or NULL if not included.",
            "  * @param allowed_types A bitmask stating which credential types are OK to return.",
            "  * @param payload The payload provided when specifying this callback.",
            "  * @return 0 for success, < 0 to indicate an error, > 0 to indicate",
            "  *       no credential was acquired",
            "@@ -237,14 +240,26 @@",
            "  */",
            " #ifndef LIBSSH2_VERSION",
            " typedef struct _LIBSSH2_SESSION LIBSSH2_SESSION;",
            " typedef struct _LIBSSH2_USERAUTH_KBDINT_PROMPT LIBSSH2_USERAUTH_KBDINT_PROMPT;",
            " typedef struct _LIBSSH2_USERAUTH_KBDINT_RESPONSE LIBSSH2_USERAUTH_KBDINT_RESPONSE;",
            " #endif",
            " ",
            "+/**",
            "+ * Callback for interactive SSH credentials.",
            "+ *",
            "+ * @param name the name",
            "+ * @param name_len the length of the name",
            "+ * @param instruction the authentication instruction",
            "+ * @param instruction_len the length of the instruction",
            "+ * @param num_prompts the number of prompts",
            "+ * @param prompts the prompts",
            "+ * @param responses the responses",
            "+ * @param abstract the abstract",
            "+ */",
            " typedef void GIT_CALLBACK(git_credential_ssh_interactive_cb)(",
            " \tconst char *name,",
            " \tint name_len,",
            " \tconst char *instruction, int instruction_len,",
            " \tint num_prompts, const LIBSSH2_USERAUTH_KBDINT_PROMPT *prompts,",
            " \tLIBSSH2_USERAUTH_KBDINT_RESPONSE *responses,",
            " \tvoid **abstract);",
            "@@ -274,14 +289,26 @@",
            "  * @param username username to use to authenticate",
            "  * @return 0 for success or an error code for failure",
            "  */",
            " GIT_EXTERN(int) git_credential_ssh_key_from_agent(",
            " \tgit_credential **out,",
            " \tconst char *username);",
            " ",
            "+/**",
            "+ * Callback for credential signing.",
            "+ *",
            "+ * @param session the libssh2 session",
            "+ * @param sig the signature",
            "+ * @param sig_len the length of the signature",
            "+ * @param data the data",
            "+ * @param data_len the length of the data",
            "+ * @param abstract the abstract",
            "+ * @return 0 for success, < 0 to indicate an error, > 0 to indicate",
            "+ *       no credential was acquired",
            "+ */",
            " typedef int GIT_CALLBACK(git_credential_sign_cb)(",
            " \tLIBSSH2_SESSION *session,",
            " \tunsigned char **sig, size_t *sig_len,",
            " \tconst unsigned char *data, size_t data_len,",
            " \tvoid **abstract);",
            " ",
            " /**",
            "@@ -308,8 +335,9 @@",
            " \tconst char *publickey,",
            " \tsize_t publickey_len,",
            " \tgit_credential_sign_cb sign_callback,",
            " \tvoid *payload);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/credential_helpers.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/credential_helpers.h",
            "+++ /home/libgit2-1.9.1/include/git2/credential_helpers.h",
            "@@ -46,8 +46,9 @@",
            " \t\tconst char *url,",
            " \t\tconst char *user_from_url,",
            " \t\tunsigned int allowed_types,",
            " \t\tvoid *payload);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/deprecated.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/deprecated.h",
            "+++ /home/libgit2-1.9.1/include/git2/deprecated.h",
            "@@ -48,15 +48,15 @@",
            "  * definition has moved into the `sys/credential.h` header; include",
            "  * them here for backward compatibility.",
            "  */",
            " #include \"sys/credential.h\"",
            " ",
            " /**",
            "  * @file git2/deprecated.h",
            "- * @brief libgit2 deprecated functions and values",
            "+ * @brief Deprecated functions and values",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** @name Deprecated Attribute Constants",
            "  *",
            "@@ -65,23 +65,31 @@",
            "  * new code.",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            "+/** @deprecated use GIT_ATTR_VALUE_UNSPECIFIED */",
            " #define GIT_ATTR_UNSPECIFIED_T GIT_ATTR_VALUE_UNSPECIFIED",
            "+/** @deprecated use GIT_ATTR_VALUE_TRUE */",
            " #define GIT_ATTR_TRUE_T GIT_ATTR_VALUE_TRUE",
            "+/** @deprecated use GIT_ATTR_VALUE_FALSE */",
            " #define GIT_ATTR_FALSE_T GIT_ATTR_VALUE_FALSE",
            "+/** @deprecated use GIT_ATTR_VALUE_STRING */",
            " #define GIT_ATTR_VALUE_T GIT_ATTR_VALUE_STRING",
            " ",
            "+/** @deprecated use GIT_ATTR_IS_TRUE */",
            " #define GIT_ATTR_TRUE(attr) GIT_ATTR_IS_TRUE(attr)",
            "+/** @deprecated use GIT_ATTR_IS_FALSE */",
            " #define GIT_ATTR_FALSE(attr) GIT_ATTR_IS_FALSE(attr)",
            "+/** @deprecated use GIT_ATTR_IS_UNSPECIFIED */",
            " #define GIT_ATTR_UNSPECIFIED(attr) GIT_ATTR_IS_UNSPECIFIED(attr)",
            " ",
            "+/** @deprecated use git_attr_value_t */",
            " typedef git_attr_value_t git_attr_t;",
            " ",
            " /**@}*/",
            " ",
            " /** @name Deprecated Blob Functions and Constants",
            "  *",
            "  * These functions and enumeration values are retained for backward",
            "@@ -89,14 +97,15 @@",
            "  * should be preferred in all new code.",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            "+/** @deprecated use GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD */",
            " #define GIT_BLOB_FILTER_ATTTRIBUTES_FROM_HEAD GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD",
            " ",
            " GIT_EXTERN(int) git_blob_create_fromworkdir(git_oid *id, git_repository *repo, const char *relative_path);",
            " GIT_EXTERN(int) git_blob_create_fromdisk(git_oid *id, git_repository *repo, const char *path);",
            " GIT_EXTERN(int) git_blob_create_fromstream(",
            " \tgit_writestream **out,",
            " \tgit_repository *repo,",
            "@@ -281,19 +290,24 @@",
            " ",
            " /**@}*/",
            " ",
            " /** @name Deprecated Config Functions and Constants",
            "  */",
            " /**@{*/",
            " ",
            "+/** @deprecated use GIT_CONFIGMAP_FALSE */",
            " #define GIT_CVAR_FALSE  GIT_CONFIGMAP_FALSE",
            "+/** @deprecated use GIT_CONFIGMAP_TRUE */",
            " #define GIT_CVAR_TRUE   GIT_CONFIGMAP_TRUE",
            "+/** @deprecated use GIT_CONFIGMAP_INT32 */",
            " #define GIT_CVAR_INT32  GIT_CONFIGMAP_INT32",
            "+/** @deprecated use GIT_CONFIGMAP_STRING */",
            " #define GIT_CVAR_STRING GIT_CONFIGMAP_STRING",
            " ",
            "+/** @deprecated use git_cvar_map */",
            " typedef git_configmap git_cvar_map;",
            " ",
            " /**@}*/",
            " ",
            " /** @name Deprecated Diff Functions and Constants",
            "  *",
            "  * These functions and enumeration values are retained for backward",
            "@@ -310,19 +324,20 @@",
            "  */",
            " typedef enum {",
            " \t/** Normal patch, the default */",
            " \tGIT_DIFF_FORMAT_EMAIL_NONE = 0,",
            " ",
            " \t/** Don't insert \"[PATCH]\" in the subject header*/",
            " \tGIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER = (1 << 0)",
            "-",
            " } git_diff_format_email_flags_t;",
            " ",
            " /**",
            "  * Options for controlling the formatting of the generated e-mail.",
            "+ *",
            "+ * @deprecated use `git_email_create_options`",
            "  */",
            " typedef struct {",
            " \tunsigned int version;",
            " ",
            " \t/** see `git_diff_format_email_flags_t` above */",
            " \tuint32_t flags;",
            " ",
            "@@ -341,15 +356,17 @@",
            " \t/** Commit message's body */",
            " \tconst char *body;",
            " ",
            " \t/** Author of the change */",
            " \tconst git_signature *author;",
            " } git_diff_format_email_options;",
            " ",
            "+/** @deprecated use `git_email_create_options` */",
            " #define GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION 1",
            "+/** @deprecated use `git_email_create_options` */",
            " #define GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT {GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION, 0, 1, 1, NULL, NULL, NULL, NULL}",
            " ",
            " /**",
            "  * Create an e-mail ready patch from a diff.",
            "  *",
            "  * @deprecated git_email_create_from_diff",
            "  * @see git_email_create_from_diff",
            "@@ -397,49 +414,83 @@",
            "  * should be preferred in all new code.",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            "+/** @deprecated use `GIT_ERROR_NONE` */",
            " #define GITERR_NONE GIT_ERROR_NONE",
            "+/** @deprecated use `GIT_ERROR_NOMEMORY` */",
            " #define GITERR_NOMEMORY GIT_ERROR_NOMEMORY",
            "+/** @deprecated use `GIT_ERROR_OS` */",
            " #define GITERR_OS GIT_ERROR_OS",
            "+/** @deprecated use `GIT_ERROR_INVALID` */",
            " #define GITERR_INVALID GIT_ERROR_INVALID",
            "+/** @deprecated use `GIT_ERROR_REFERENCE` */",
            " #define GITERR_REFERENCE GIT_ERROR_REFERENCE",
            "+/** @deprecated use `GIT_ERROR_ZLIB` */",
            " #define GITERR_ZLIB GIT_ERROR_ZLIB",
            "+/** @deprecated use `GIT_ERROR_REPOSITORY` */",
            " #define GITERR_REPOSITORY GIT_ERROR_REPOSITORY",
            "+/** @deprecated use `GIT_ERROR_CONFIG` */",
            " #define GITERR_CONFIG GIT_ERROR_CONFIG",
            "+/** @deprecated use `GIT_ERROR_REGEX` */",
            " #define GITERR_REGEX GIT_ERROR_REGEX",
            "+/** @deprecated use `GIT_ERROR_ODB` */",
            " #define GITERR_ODB GIT_ERROR_ODB",
            "+/** @deprecated use `GIT_ERROR_INDEX` */",
            " #define GITERR_INDEX GIT_ERROR_INDEX",
            "+/** @deprecated use `GIT_ERROR_OBJECT` */",
            " #define GITERR_OBJECT GIT_ERROR_OBJECT",
            "+/** @deprecated use `GIT_ERROR_NET` */",
            " #define GITERR_NET GIT_ERROR_NET",
            "+/** @deprecated use `GIT_ERROR_TAG` */",
            " #define GITERR_TAG GIT_ERROR_TAG",
            "+/** @deprecated use `GIT_ERROR_TREE` */",
            " #define GITERR_TREE GIT_ERROR_TREE",
            "+/** @deprecated use `GIT_ERROR_INDEXER` */",
            " #define GITERR_INDEXER GIT_ERROR_INDEXER",
            "+/** @deprecated use `GIT_ERROR_SSL` */",
            " #define GITERR_SSL GIT_ERROR_SSL",
            "+/** @deprecated use `GIT_ERROR_SUBMODULE` */",
            " #define GITERR_SUBMODULE GIT_ERROR_SUBMODULE",
            "+/** @deprecated use `GIT_ERROR_THREAD` */",
            " #define GITERR_THREAD GIT_ERROR_THREAD",
            "+/** @deprecated use `GIT_ERROR_STASH` */",
            " #define GITERR_STASH GIT_ERROR_STASH",
            "+/** @deprecated use `GIT_ERROR_CHECKOUT` */",
            " #define GITERR_CHECKOUT GIT_ERROR_CHECKOUT",
            "+/** @deprecated use `GIT_ERROR_FETCHHEAD` */",
            " #define GITERR_FETCHHEAD GIT_ERROR_FETCHHEAD",
            "+/** @deprecated use `GIT_ERROR_MERGE` */",
            " #define GITERR_MERGE GIT_ERROR_MERGE",
            "+/** @deprecated use `GIT_ERROR_SSH` */",
            " #define GITERR_SSH GIT_ERROR_SSH",
            "+/** @deprecated use `GIT_ERROR_FILTER` */",
            " #define GITERR_FILTER GIT_ERROR_FILTER",
            "+/** @deprecated use `GIT_ERROR_REVERT` */",
            " #define GITERR_REVERT GIT_ERROR_REVERT",
            "+/** @deprecated use `GIT_ERROR_CALLBACK` */",
            " #define GITERR_CALLBACK GIT_ERROR_CALLBACK",
            "+/** @deprecated use `GIT_ERROR_CHERRYPICK` */",
            " #define GITERR_CHERRYPICK GIT_ERROR_CHERRYPICK",
            "+/** @deprecated use `GIT_ERROR_DESCRIBE` */",
            " #define GITERR_DESCRIBE GIT_ERROR_DESCRIBE",
            "+/** @deprecated use `GIT_ERROR_REBASE` */",
            " #define GITERR_REBASE GIT_ERROR_REBASE",
            "+/** @deprecated use `GIT_ERROR_FILESYSTEM` */",
            " #define GITERR_FILESYSTEM GIT_ERROR_FILESYSTEM",
            "+/** @deprecated use `GIT_ERROR_PATCH` */",
            " #define GITERR_PATCH GIT_ERROR_PATCH",
            "+/** @deprecated use `GIT_ERROR_WORKTREE` */",
            " #define GITERR_WORKTREE GIT_ERROR_WORKTREE",
            "+/** @deprecated use `GIT_ERROR_SHA1` */",
            " #define GITERR_SHA1 GIT_ERROR_SHA1",
            "-",
            "+/** @deprecated use `GIT_ERROR_SHA` */",
            " #define GIT_ERROR_SHA1 GIT_ERROR_SHA",
            " ",
            " /**",
            "  * Return the last `git_error` object that was generated for the",
            "  * current thread.  This is an alias of `git_error_last` and is",
            "  * preserved for backward compatibility.",
            "  *",
            "@@ -496,45 +547,71 @@",
            "  * preferred in all new code.",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            "+/* The git_idxentry_extended_flag_t enum */",
            "+/** @deprecated use `GIT_INDEX_ENTRY_NAMEMASK` */",
            " #define GIT_IDXENTRY_NAMEMASK          GIT_INDEX_ENTRY_NAMEMASK",
            "+/** @deprecated use `GIT_INDEX_ENTRY_STAGEMASK` */",
            " #define GIT_IDXENTRY_STAGEMASK         GIT_INDEX_ENTRY_STAGEMASK",
            "+/** @deprecated use `GIT_INDEX_ENTRY_STAGESHIFT` */",
            " #define GIT_IDXENTRY_STAGESHIFT        GIT_INDEX_ENTRY_STAGESHIFT",
            " ",
            " /* The git_indxentry_flag_t enum */",
            "+/** @deprecated use `GIT_INDEX_ENTRY_EXTENDED` */",
            " #define GIT_IDXENTRY_EXTENDED          GIT_INDEX_ENTRY_EXTENDED",
            "+/** @deprecated use `GIT_INDEX_ENTRY_VALID` */",
            " #define GIT_IDXENTRY_VALID             GIT_INDEX_ENTRY_VALID",
            " ",
            "+/** @deprecated use `GIT_INDEX_ENTRY_STAGE` */",
            " #define GIT_IDXENTRY_STAGE(E)          GIT_INDEX_ENTRY_STAGE(E)",
            "+/** @deprecated use `GIT_INDEX_ENTRY_STAGE_SET` */",
            " #define GIT_IDXENTRY_STAGE_SET(E,S)    GIT_INDEX_ENTRY_STAGE_SET(E,S)",
            " ",
            " /* The git_idxentry_extended_flag_t enum */",
            "+/** @deprecated use `GIT_INDEX_ENTRY_INTENT_TO_ADD` */",
            " #define GIT_IDXENTRY_INTENT_TO_ADD     GIT_INDEX_ENTRY_INTENT_TO_ADD",
            "+/** @deprecated use `GIT_INDEX_ENTRY_SKIP_WORKTREE` */",
            " #define GIT_IDXENTRY_SKIP_WORKTREE     GIT_INDEX_ENTRY_SKIP_WORKTREE",
            "+/** @deprecated use `GIT_INDEX_ENTRY_INTENT_TO_ADD | GIT_INDEX_ENTRY_SKIP_WORKTREE` */",
            " #define GIT_IDXENTRY_EXTENDED_FLAGS    (GIT_INDEX_ENTRY_INTENT_TO_ADD | GIT_INDEX_ENTRY_SKIP_WORKTREE)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_EXTENDED2         (1 << 15)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_UPDATE            (1 << 0)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_REMOVE            (1 << 1)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_UPTODATE          (1 << 2)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_ADDED             (1 << 3)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_HASHED            (1 << 4)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_UNHASHED          (1 << 5)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_WT_REMOVE         (1 << 6)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_CONFLICTED        (1 << 7)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_UNPACKED          (1 << 8)",
            "+/** @deprecated this value is not public */",
            " #define GIT_IDXENTRY_NEW_SKIP_WORKTREE (1 << 9)",
            " ",
            " /* The git_index_capability_t enum */",
            "+/** @deprecated use `GIT_INDEX_CAPABILITY_IGNORE_CASE` */",
            " #define GIT_INDEXCAP_IGNORE_CASE       GIT_INDEX_CAPABILITY_IGNORE_CASE",
            "+/** @deprecated use `GIT_INDEX_CAPABILITY_NO_FILEMODE` */",
            " #define GIT_INDEXCAP_NO_FILEMODE       GIT_INDEX_CAPABILITY_NO_FILEMODE",
            "+/** @deprecated use `GIT_INDEX_CAPABILITY_NO_SYMLINKS` */",
            " #define GIT_INDEXCAP_NO_SYMLINKS       GIT_INDEX_CAPABILITY_NO_SYMLINKS",
            "+/** @deprecated use `GIT_INDEX_CAPABILITY_FROM_OWNER` */",
            " #define GIT_INDEXCAP_FROM_OWNER        GIT_INDEX_CAPABILITY_FROM_OWNER",
            " ",
            " GIT_EXTERN(int) git_index_add_frombuffer(",
            " \tgit_index *index,",
            " \tconst git_index_entry *entry,",
            " \tconst void *buffer, size_t len);",
            " ",
            "@@ -546,25 +623,36 @@",
            "  * newer versions of these values should be preferred in all new code.",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            "+/** @deprecate use `git_object_t` */",
            " #define git_otype git_object_t",
            " ",
            "+/** @deprecate use `GIT_OBJECT_ANY` */",
            " #define GIT_OBJ_ANY GIT_OBJECT_ANY",
            "+/** @deprecate use `GIT_OBJECT_INVALID` */",
            " #define GIT_OBJ_BAD GIT_OBJECT_INVALID",
            "+/** @deprecated this value is not public */",
            " #define GIT_OBJ__EXT1 0",
            "+/** @deprecate use `GIT_OBJECT_COMMIT` */",
            " #define GIT_OBJ_COMMIT GIT_OBJECT_COMMIT",
            "+/** @deprecate use `GIT_OBJECT_TREE` */",
            " #define GIT_OBJ_TREE GIT_OBJECT_TREE",
            "+/** @deprecate use `GIT_OBJECT_BLOB` */",
            " #define GIT_OBJ_BLOB GIT_OBJECT_BLOB",
            "+/** @deprecate use `GIT_OBJECT_TAG` */",
            " #define GIT_OBJ_TAG GIT_OBJECT_TAG",
            "+/** @deprecated this value is not public */",
            " #define GIT_OBJ__EXT2 5",
            "+/** @deprecate use `GIT_OBJECT_OFS_DELTA` */",
            " #define GIT_OBJ_OFS_DELTA GIT_OBJECT_OFS_DELTA",
            "+/** @deprecate use `GIT_OBJECT_REF_DELTA` */",
            " #define GIT_OBJ_REF_DELTA GIT_OBJECT_REF_DELTA",
            " ",
            " /**",
            "  * Get the size in bytes for the structure which",
            "  * acts as an in-memory representation of any given",
            "  * object type.",
            "  *",
            "@@ -608,25 +696,35 @@",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            "  /** Basic type of any Git reference. */",
            "+/** @deprecate use `git_reference_t` */",
            " #define git_ref_t git_reference_t",
            "+/** @deprecate use `git_reference_format_t` */",
            " #define git_reference_normalize_t git_reference_format_t",
            " ",
            "+/** @deprecate use `GIT_REFERENCE_INVALID` */",
            " #define GIT_REF_INVALID GIT_REFERENCE_INVALID",
            "+/** @deprecate use `GIT_REFERENCE_DIRECT` */",
            " #define GIT_REF_OID GIT_REFERENCE_DIRECT",
            "+/** @deprecate use `GIT_REFERENCE_SYMBOLIC` */",
            " #define GIT_REF_SYMBOLIC GIT_REFERENCE_SYMBOLIC",
            "+/** @deprecate use `GIT_REFERENCE_ALL` */",
            " #define GIT_REF_LISTALL GIT_REFERENCE_ALL",
            " ",
            "+/** @deprecate use `GIT_REFERENCE_FORMAT_NORMAL` */",
            " #define GIT_REF_FORMAT_NORMAL GIT_REFERENCE_FORMAT_NORMAL",
            "+/** @deprecate use `GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL` */",
            " #define GIT_REF_FORMAT_ALLOW_ONELEVEL GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL",
            "+/** @deprecate use `GIT_REFERENCE_FORMAT_REFSPEC_PATTERN` */",
            " #define GIT_REF_FORMAT_REFSPEC_PATTERN GIT_REFERENCE_FORMAT_REFSPEC_PATTERN",
            "+/** @deprecate use `GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND` */",
            " #define GIT_REF_FORMAT_REFSPEC_SHORTHAND GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND",
            " ",
            " /**",
            "  * Ensure the reference name is well-formed.",
            "  *",
            "  * Valid reference names must follow one of two patterns:",
            "  *",
            "@@ -659,16 +757,19 @@",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            " typedef git_revspec_t git_revparse_mode_t;",
            " ",
            "+/** @deprecated use `GIT_REVSPEC_SINGLE` */",
            " #define GIT_REVPARSE_SINGLE GIT_REVSPEC_SINGLE",
            "+/** @deprecated use `GIT_REVSPEC_RANGE` */",
            " #define GIT_REVPARSE_RANGE GIT_REVSPEC_RANGE",
            "+/** @deprecated use `GIT_REVSPEC_MERGE_BASE` */",
            " #define GIT_REVPARSE_MERGE_BASE GIT_REVSPEC_MERGE_BASE",
            " ",
            " /**@}*/",
            " ",
            " /** @name Deprecated Credential Types",
            "  *",
            "  * These types are retained for backward compatibility.  The newer",
            "@@ -689,22 +790,30 @@",
            " ",
            " typedef git_credential_acquire_cb git_cred_acquire_cb;",
            " typedef git_credential_sign_cb git_cred_sign_callback;",
            " typedef git_credential_sign_cb git_cred_sign_cb;",
            " typedef git_credential_ssh_interactive_cb git_cred_ssh_interactive_callback;",
            " typedef git_credential_ssh_interactive_cb git_cred_ssh_interactive_cb;",
            " ",
            "+/** @deprecated use `git_credential_t` */",
            " #define git_credtype_t git_credential_t",
            " ",
            "+/** @deprecated use `GIT_CREDENTIAL_USERPASS_PLAINTEXT` */",
            " #define GIT_CREDTYPE_USERPASS_PLAINTEXT GIT_CREDENTIAL_USERPASS_PLAINTEXT",
            "+/** @deprecated use `GIT_CREDENTIAL_SSH_KEY` */",
            " #define GIT_CREDTYPE_SSH_KEY GIT_CREDENTIAL_SSH_KEY",
            "+/** @deprecated use `GIT_CREDENTIAL_SSH_CUSTOM` */",
            " #define GIT_CREDTYPE_SSH_CUSTOM GIT_CREDENTIAL_SSH_CUSTOM",
            "+/** @deprecated use `GIT_CREDENTIAL_DEFAULT` */",
            " #define GIT_CREDTYPE_DEFAULT GIT_CREDENTIAL_DEFAULT",
            "+/** @deprecated use `GIT_CREDENTIAL_SSH_INTERACTIVE` */",
            " #define GIT_CREDTYPE_SSH_INTERACTIVE GIT_CREDENTIAL_SSH_INTERACTIVE",
            "+/** @deprecated use `GIT_CREDENTIAL_USERNAME` */",
            " #define GIT_CREDTYPE_USERNAME GIT_CREDENTIAL_USERNAME",
            "+/** @deprecated use `GIT_CREDENTIAL_SSH_MEMORY` */",
            " #define GIT_CREDTYPE_SSH_MEMORY GIT_CREDENTIAL_SSH_MEMORY",
            " ",
            " GIT_EXTERN(void) git_cred_free(git_credential *cred);",
            " GIT_EXTERN(int) git_cred_has_username(git_credential *cred);",
            " GIT_EXTERN(const char *) git_cred_get_username(git_credential *cred);",
            " GIT_EXTERN(int) git_cred_userpass_plaintext_new(",
            " \tgit_credential **out,",
            "@@ -774,16 +883,19 @@",
            "  *",
            "  * There is no plan to remove these backward compatibility values at",
            "  * this time.",
            "  */",
            " /**@{*/",
            " ",
            " #ifndef GIT_EXPERIMENTAL_SHA256",
            "+/** Deprecated OID \"raw size\" definition */",
            " # define GIT_OID_RAWSZ    GIT_OID_SHA1_SIZE",
            "+/** Deprecated OID \"hex size\" definition */",
            " # define GIT_OID_HEXSZ    GIT_OID_SHA1_HEXSIZE",
            "+/** Deprecated OID \"hex zero\" definition */",
            " # define GIT_OID_HEX_ZERO GIT_OID_SHA1_HEXZERO",
            " #endif",
            " ",
            " GIT_EXTERN(int) git_oid_iszero(const git_oid *id);",
            " ",
            " /**@}*/",
            " ",
            "@@ -888,14 +1000,32 @@",
            "  * @deprecated Use git_strarray_dispose",
            "  * @see git_strarray_dispose",
            "  */",
            " GIT_EXTERN(void) git_strarray_free(git_strarray *array);",
            " ",
            " /**@}*/",
            " ",
            "+/** @name Deprecated Version Constants",
            "+ *",
            "+ * These constants are retained for backward compatibility.  The newer",
            "+ * versions of these constants should be preferred in all new code.",
            "+ *",
            "+ * There is no plan to remove these backward compatibility constants at",
            "+ * this time.",
            "+ */",
            "+/**@{*/",
            "+",
            "+#define LIBGIT2_VER_MAJOR      LIBGIT2_VERSION_MAJOR",
            "+#define LIBGIT2_VER_MINOR      LIBGIT2_VERSION_MINOR",
            "+#define LIBGIT2_VER_REVISION   LIBGIT2_VERSION_REVISION",
            "+#define LIBGIT2_VER_PATCH      LIBGIT2_VERSION_PATCH",
            "+#define LIBGIT2_VER_PRERELEASE LIBGIT2_VERSION_PRERELEASE",
            "+",
            "+/**@}*/",
            "+",
            " /** @name Deprecated Options Initialization Functions",
            "  *",
            "  * These functions are retained for backward compatibility.  The newer",
            "  * versions of these functions should be preferred in all new code.",
            "  *",
            "  * There is no plan to remove these backward compatibility functions at",
            "  * this time."
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/describe.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/describe.h",
            "+++ /home/libgit2-1.9.1/include/git2/describe.h",
            "@@ -9,18 +9,22 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/describe.h",
            "- * @brief Git describing routines",
            "+ * @brief Describe a commit in reference to tags",
            "  * @defgroup git_describe Git describing routines",
            "  * @ingroup Git",
            "  * @{",
            "+ *",
            "+ * Describe a commit, showing information about how the current commit",
            "+ * relates to the tags. This can be useful for showing how the current",
            "+ * commit has changed from a particular tagged version of the repository.",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Reference lookup strategy",
            "  *",
            "  * These behave like the --tags and --all options to git-describe,",
            "@@ -56,18 +60,23 @@",
            " \t * operation would normally fail. If this option is set, it",
            " \t * will instead fall back to showing the full id of the",
            " \t * commit.",
            " \t */",
            " \tint show_commit_oid_as_fallback;",
            " } git_describe_options;",
            " ",
            "+/** Default maximum candidate tags */",
            " #define GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS 10",
            "+/** Default abbreviated size */",
            " #define GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE 7",
            " ",
            "+/** Current version for the `git_describe_options` structure */",
            " #define GIT_DESCRIBE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_describe_options` */",
            " #define GIT_DESCRIBE_OPTIONS_INIT { \\",
            " \tGIT_DESCRIBE_OPTIONS_VERSION, \\",
            " \tGIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS, \\",
            " }",
            " ",
            " /**",
            "  * Initialize git_describe_options structure",
            "@@ -106,15 +115,18 @@",
            " \t/**",
            " \t * If the workdir is dirty and this is set, this string will",
            " \t * be appended to the description string.",
            " \t */",
            " \tconst char *dirty_suffix;",
            " } git_describe_format_options;",
            " ",
            "+/** Current version for the `git_describe_format_options` structure */",
            " #define GIT_DESCRIBE_FORMAT_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_describe_format_options` */",
            " #define GIT_DESCRIBE_FORMAT_OPTIONS_INIT { \\",
            " \t\tGIT_DESCRIBE_FORMAT_OPTIONS_VERSION,   \\",
            " \t\tGIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE, \\",
            "  }",
            " ",
            " /**",
            "  * Initialize git_describe_format_options structure"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/diff.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/diff.h",
            "+++ /home/libgit2-1.9.1/include/git2/diff.h",
            "@@ -11,15 +11,15 @@",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"tree.h\"",
            " #include \"refs.h\"",
            " ",
            " /**",
            "  * @file git2/diff.h",
            "- * @brief Git tree and file differencing routines.",
            "+ * @brief Indicate the differences between two versions of the repository",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Flags for diff options.  A combination of these flags can be passed",
            "@@ -338,14 +338,20 @@",
            "  *",
            "  * When the callback:",
            "  * - returns < 0, the diff process will be aborted.",
            "  * - returns > 0, the delta will not be inserted into the diff, but the",
            "  *\t\tdiff process continues.",
            "  * - returns 0, the delta is inserted into the diff, and the diff process",
            "  *\t\tcontinues.",
            "+ *",
            "+ * @param diff_so_far the diff structure as it currently exists",
            "+ * @param delta_to_add the delta that is to be added",
            "+ * @param matched_pathspec the pathspec",
            "+ * @param payload the user-specified callback payload",
            "+ * @return 0 on success, 1 to skip this delta, or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_diff_notify_cb)(",
            " \tconst git_diff *diff_so_far,",
            " \tconst git_diff_delta *delta_to_add,",
            " \tconst char *matched_pathspec,",
            " \tvoid *payload);",
            " ",
            "@@ -353,15 +359,16 @@",
            "  * Diff progress callback.",
            "  *",
            "  * Called before each file comparison.",
            "  *",
            "  * @param diff_so_far The diff being generated.",
            "  * @param old_path The path to the old file or NULL.",
            "  * @param new_path The path to the new file or NULL.",
            "- * @return Non-zero to abort the diff.",
            "+ * @param payload the user-specified callback payload",
            "+ * @return 0 or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_diff_progress_cb)(",
            " \tconst git_diff *diff_so_far,",
            " \tconst char *old_path,",
            " \tconst char *new_path,",
            " \tvoid *payload);",
            " ",
            "@@ -459,18 +466,18 @@",
            " \t/**",
            " \t * The virtual \"directory\" prefix for new file names in hunk headers.",
            " \t * Defaults to \"b\".",
            " \t */",
            " \tconst char *new_prefix;",
            " } git_diff_options;",
            " ",
            "-/* The current version of the diff options structure */",
            "+/** The current version of the diff options structure */",
            " #define GIT_DIFF_OPTIONS_VERSION 1",
            " ",
            "-/* Stack initializer for diff options.  Alternatively use",
            "+/** Stack initializer for diff options.  Alternatively use",
            "  * `git_diff_options_init` programmatic initialization.",
            "  */",
            " #define GIT_DIFF_OPTIONS_INIT \\",
            " \t{GIT_DIFF_OPTIONS_VERSION, 0, GIT_SUBMODULE_IGNORE_UNSPECIFIED, {NULL,0}, NULL, NULL, NULL, 3}",
            " ",
            " /**",
            "  * Initialize git_diff_options structure",
            "@@ -488,20 +495,22 @@",
            " ",
            " /**",
            "  * When iterating over a diff, callback that will be made per file.",
            "  *",
            "  * @param delta A pointer to the delta data for the file",
            "  * @param progress Goes from 0 to 1 over the diff",
            "  * @param payload User-specified pointer from foreach function",
            "+ * @return 0 or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_diff_file_cb)(",
            " \tconst git_diff_delta *delta,",
            " \tfloat progress,",
            " \tvoid *payload);",
            " ",
            "+/** Maximum size of the hunk header */",
            " #define GIT_DIFF_HUNK_HEADER_SIZE\t128",
            " ",
            " /**",
            "  * When producing a binary diff, the binary data returned will be",
            "  * either the deflated full (\"literal\") contents of the file, or",
            "  * the deflated binary delta between the two sides (whichever is",
            "  * smaller).",
            "@@ -554,14 +563,19 @@",
            " \tgit_diff_binary_file old_file; /**< The contents of the old file. */",
            " \tgit_diff_binary_file new_file; /**< The contents of the new file. */",
            " } git_diff_binary;",
            " ",
            " /**",
            "  * When iterating over a diff, callback that will be made for",
            "  * binary content within the diff.",
            "+ *",
            "+ * @param delta the delta",
            "+ * @param binary the binary content",
            "+ * @param payload the user-specified callback payload",
            "+ * @return 0 or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_diff_binary_cb)(",
            " \tconst git_diff_delta *delta,",
            " \tconst git_diff_binary *binary,",
            " \tvoid *payload);",
            " ",
            " /**",
            "@@ -580,14 +594,19 @@",
            " \tint    new_lines;     /**< Number of lines in new_file */",
            " \tsize_t header_len;    /**< Number of bytes in header text */",
            " \tchar   header[GIT_DIFF_HUNK_HEADER_SIZE];   /**< Header text, NUL-byte terminated */",
            " } git_diff_hunk;",
            " ",
            " /**",
            "  * When iterating over a diff, callback that will be made per hunk.",
            "+ *",
            "+ * @param delta the delta",
            "+ * @param hunk the hunk",
            "+ * @param payload the user-specified callback payload",
            "+ * @return 0 or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_diff_hunk_cb)(",
            " \tconst git_diff_delta *delta,",
            " \tconst git_diff_hunk *hunk,",
            " \tvoid *payload);",
            " ",
            " /**",
            "@@ -641,14 +660,20 @@",
            " /**",
            "  * When iterating over a diff, callback that will be made per text diff",
            "  * line. In this context, the provided range will be NULL.",
            "  *",
            "  * When printing a diff, callback that will be made to output each line",
            "  * of text.  This uses some extra GIT_DIFF_LINE_... constants for output",
            "  * of lines of file and hunk headers.",
            "+ *",
            "+ * @param delta the delta that contains the line",
            "+ * @param hunk the hunk that contains the line",
            "+ * @param line the line in the diff",
            "+ * @param payload the user-specified callback payload",
            "+ * @return 0 or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_diff_line_cb)(",
            " \tconst git_diff_delta *delta, /**< delta that contains this data */",
            " \tconst git_diff_hunk *hunk,   /**< hunk containing this data */",
            " \tconst git_diff_line *line,   /**< line data */",
            " \tvoid *payload);              /**< user reference data */",
            " ",
            "@@ -798,15 +823,18 @@",
            " \t * the file, which is a pretty good similarity approximation that should",
            " \t * work fairly well for both text and binary data while still being",
            " \t * pretty fast with a fixed memory overhead.",
            " \t */",
            " \tgit_diff_similarity_metric *metric;",
            " } git_diff_find_options;",
            " ",
            "+/** Current version for the `git_diff_find_options` structure */",
            " #define GIT_DIFF_FIND_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_diff_find_options` */",
            " #define GIT_DIFF_FIND_OPTIONS_INIT {GIT_DIFF_FIND_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_diff_find_options structure",
            "  *",
            "  * Initializes a `git_diff_find_options` with default values. Equivalent to creating",
            "  * an instance with GIT_DIFF_FIND_OPTIONS_INIT.",
            "@@ -1292,18 +1320,18 @@",
            "  * Options for parsing a diff / patch file.",
            "  */",
            " typedef struct {",
            " \tunsigned int version;",
            " \tgit_oid_t oid_type;",
            " } git_diff_parse_options;",
            " ",
            "-/* The current version of the diff parse options structure */",
            "+/** The current version of the diff parse options structure */",
            " #define GIT_DIFF_PARSE_OPTIONS_VERSION 1",
            " ",
            "-/* Stack initializer for diff parse options.  Alternatively use",
            "+/** Stack initializer for diff parse options.  Alternatively use",
            "  * `git_diff_parse_options_init` programmatic initialization.",
            "  */",
            " #define GIT_DIFF_PARSE_OPTIONS_INIT \\",
            " \t{ GIT_DIFF_PARSE_OPTIONS_VERSION, GIT_OID_DEFAULT }",
            " ",
            " /**",
            "  * Read the contents of a git patch file into a `git_diff` object.",
            "@@ -1428,15 +1456,18 @@",
            "  * use `git_diff_patchid_options_init`.",
            "  *",
            "  */",
            " typedef struct git_diff_patchid_options {",
            " \tunsigned int version;",
            " } git_diff_patchid_options;",
            " ",
            "+/** Current version for the `git_diff_patchid_options` structure */",
            " #define GIT_DIFF_PATCHID_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_diff_patchid_options` */",
            " #define GIT_DIFF_PATCHID_OPTIONS_INIT { GIT_DIFF_PATCHID_OPTIONS_VERSION }",
            " ",
            " /**",
            "  * Initialize git_diff_patchid_options structure",
            "  *",
            "  * Initializes a `git_diff_patchid_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_DIFF_PATCHID_OPTIONS_INIT`.",
            "@@ -1466,12 +1497,11 @@",
            "  * @param opts Options for how to calculate the patch ID. This is",
            "  *  intended for future changes, as currently no options are",
            "  *  available.",
            "  * @return 0 on success, an error code otherwise.",
            "  */",
            " GIT_EXTERN(int) git_diff_patchid(git_oid *out, git_diff *diff, git_diff_patchid_options *opts);",
            " ",
            "-GIT_END_DECL",
            "-",
            " /** @} */",
            "+GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/email.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/email.h",
            "+++ /home/libgit2-1.9.1/include/git2/email.h",
            "@@ -8,15 +8,15 @@",
            " #define INCLUDE_git_email_h__",
            " ",
            " #include \"common.h\"",
            " #include \"diff.h\"",
            " ",
            " /**",
            "  * @file git2/email.h",
            "- * @brief Git email formatting and application routines.",
            "+ * @brief Produce email-ready patches",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Formatting options for diff e-mail generation",
            "@@ -67,62 +67,41 @@",
            " \t */",
            " \tsize_t start_number;",
            " ",
            " \t/** The \"re-roll\" number.  By default, there is no re-roll. */",
            " \tsize_t reroll_number;",
            " } git_email_create_options;",
            " ",
            "-/*",
            "+/** Current version for the `git_email_create_options` structure */",
            "+#define GIT_EMAIL_CREATE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_email_create_options`",
            "+ *",
            "  * By default, our options include rename detection and binary",
            "  * diffs to match `git format-patch`.",
            "  */",
            "-#define GIT_EMAIL_CREATE_OPTIONS_VERSION 1",
            " #define GIT_EMAIL_CREATE_OPTIONS_INIT \\",
            " { \\",
            " \tGIT_EMAIL_CREATE_OPTIONS_VERSION, \\",
            " \tGIT_EMAIL_CREATE_DEFAULT, \\",
            " \t{ GIT_DIFF_OPTIONS_VERSION, GIT_DIFF_SHOW_BINARY, GIT_SUBMODULE_IGNORE_UNSPECIFIED, {NULL,0}, NULL, NULL, NULL, 3 }, \\",
            " \tGIT_DIFF_FIND_OPTIONS_INIT \\",
            " }",
            " ",
            " /**",
            "  * Create a diff for a commit in mbox format for sending via email.",
            "- *",
            "- * @param out buffer to store the e-mail patch in",
            "- * @param diff the changes to include in the email",
            "- * @param patch_idx the patch index",
            "- * @param patch_count the total number of patches that will be included",
            "- * @param commit_id the commit id for this change",
            "- * @param summary the commit message for this change",
            "- * @param body optional text to include above the diffstat",
            "- * @param author the person who authored this commit",
            "- * @param opts email creation options",
            "- */",
            "-GIT_EXTERN(int) git_email_create_from_diff(",
            "-\tgit_buf *out,",
            "-\tgit_diff *diff,",
            "-\tsize_t patch_idx,",
            "-\tsize_t patch_count,",
            "-\tconst git_oid *commit_id,",
            "-\tconst char *summary,",
            "-\tconst char *body,",
            "-\tconst git_signature *author,",
            "-\tconst git_email_create_options *opts);",
            "-",
            "-/**",
            "- * Create a diff for a commit in mbox format for sending via email.",
            "  * The commit must not be a merge commit.",
            "  *",
            "  * @param out buffer to store the e-mail patch in",
            "  * @param commit commit to create a patch for",
            "  * @param opts email creation options",
            "+ * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_email_create_from_commit(",
            " \tgit_buf *out,",
            " \tgit_commit *commit,",
            " \tconst git_email_create_options *opts);",
            " ",
            "-GIT_END_DECL",
            "-",
            " /** @} */",
            "+GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/errors.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/errors.h",
            "+++ /home/libgit2-1.9.1/include/git2/errors.h",
            "@@ -7,41 +7,48 @@",
            " #ifndef INCLUDE_git_errors_h__",
            " #define INCLUDE_git_errors_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " /**",
            "  * @file git2/errors.h",
            "- * @brief Git error handling routines and variables",
            "+ * @brief Error handling routines and variables",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** Generic return codes */",
            " typedef enum {",
            "-\tGIT_OK              =  0,\t\t/**< No error */",
            "+\t/**",
            "+\t * No error occurred; the call was successful.",
            "+\t */",
            "+\tGIT_OK              =  0,",
            "+",
            "+\t/**",
            "+\t * An error occurred; call `git_error_last` for more information.",
            "+\t */",
            "+\tGIT_ERROR           = -1,",
            " ",
            "-\tGIT_ERROR           = -1,\t\t/**< Generic error */",
            "-\tGIT_ENOTFOUND       = -3,\t\t/**< Requested object could not be found */",
            "-\tGIT_EEXISTS         = -4,\t\t/**< Object exists preventing operation */",
            "-\tGIT_EAMBIGUOUS      = -5,\t\t/**< More than one object matches */",
            "-\tGIT_EBUFS           = -6,\t\t/**< Output buffer too short to hold data */",
            "+\tGIT_ENOTFOUND       = -3,   /**< Requested object could not be found. */",
            "+\tGIT_EEXISTS         = -4,   /**< Object exists preventing operation. */",
            "+\tGIT_EAMBIGUOUS      = -5,   /**< More than one object matches. */",
            "+\tGIT_EBUFS           = -6,   /**< Output buffer too short to hold data. */",
            " ",
            " \t/**",
            " \t * GIT_EUSER is a special error that is never generated by libgit2",
            " \t * code.  You can return it from a callback (e.g to stop an iteration)",
            " \t * to know that it was generated by the callback and not by libgit2.",
            " \t */",
            " \tGIT_EUSER           = -7,",
            " ",
            "-\tGIT_EBAREREPO       =  -8,\t/**< Operation not allowed on bare repository */",
            "-\tGIT_EUNBORNBRANCH   =  -9,\t/**< HEAD refers to branch with no commits */",
            "-\tGIT_EUNMERGED       = -10,\t/**< Merge in progress prevented operation */",
            "-\tGIT_ENONFASTFORWARD = -11,\t/**< Reference was not fast-forwardable */",
            "+\tGIT_EBAREREPO       = -8,   /**< Operation not allowed on bare repository. */",
            "+\tGIT_EUNBORNBRANCH   = -9,   /**< HEAD refers to branch with no commits. */",
            "+\tGIT_EUNMERGED       = -10,  /**< Merge in progress prevented operation */",
            "+\tGIT_ENONFASTFORWARD = -11,  /**< Reference was not fast-forwardable */",
            " \tGIT_EINVALIDSPEC    = -12,\t/**< Name/ref spec was not in a valid format */",
            " \tGIT_ECONFLICT       = -13,\t/**< Checkout conflicts prevented operation */",
            " \tGIT_ELOCKED         = -14,\t/**< Lock file prevented operation */",
            " \tGIT_EMODIFIED       = -15,\t/**< Reference value does not match expected */",
            " \tGIT_EAUTH           = -16,\t/**< Authentication error */",
            " \tGIT_ECERTIFICATE    = -17,\t/**< Server certificate is invalid */",
            " \tGIT_EAPPLIED        = -18,\t/**< Patch/merge has already been applied */",
            "@@ -62,25 +69,17 @@",
            " \tGIT_TIMEOUT         = -37,\t/**< The operation timed out */",
            " \tGIT_EUNCHANGED      = -38,\t/**< There were no changes */",
            " \tGIT_ENOTSUPPORTED   = -39,\t/**< An option is not supported */",
            " \tGIT_EREADONLY       = -40\t/**< The subject is read-only */",
            " } git_error_code;",
            " ",
            " /**",
            "- * Structure to store extra details of the last error that occurred.",
            "- *",
            "- * This is kept on a per-thread basis if GIT_THREADS was defined when the",
            "- * library was build, otherwise one is kept globally for the library",
            "+ * Error classes are the category of error. They reflect the area of the",
            "+ * code where an error occurred.",
            "  */",
            "-typedef struct {",
            "-\tchar *message;",
            "-\tint klass;",
            "-} git_error;",
            "-",
            "-/** Error classes */",
            " typedef enum {",
            " \tGIT_ERROR_NONE = 0,",
            " \tGIT_ERROR_NOMEMORY,",
            " \tGIT_ERROR_OS,",
            " \tGIT_ERROR_INVALID,",
            " \tGIT_ERROR_REFERENCE,",
            " \tGIT_ERROR_ZLIB,",
            "@@ -114,14 +113,25 @@",
            " \tGIT_ERROR_SHA,",
            " \tGIT_ERROR_HTTP,",
            " \tGIT_ERROR_INTERNAL,",
            " \tGIT_ERROR_GRAFTS",
            " } git_error_t;",
            " ",
            " /**",
            "+ * Structure to store extra details of the last error that occurred.",
            "+ *",
            "+ * This is kept on a per-thread basis if GIT_THREADS was defined when the",
            "+ * library was build, otherwise one is kept globally for the library",
            "+ */",
            "+typedef struct {",
            "+\tchar *message;  /**< The error message for the last error. */",
            "+\tint klass;      /**< The category of the last error. @type git_error_t */",
            "+} git_error;",
            "+",
            "+/**",
            "  * Return the last `git_error` object that was generated for the",
            "  * current thread.",
            "  *",
            "  * This function will never return NULL.",
            "  *",
            "  * Callers should not rely on this to determine whether an error has",
            "  * occurred. For error checking, callers should examine the return",
            "@@ -130,14 +140,15 @@",
            "  * This call can only reliably report error messages when an error",
            "  * has occurred. (It may contain stale information if it is called",
            "  * after a different function that succeeds.)",
            "  *",
            "  * The memory for this object is managed by libgit2. It should not",
            "  * be freed.",
            "  *",
            "- * @return A git_error object.",
            "+ * @return A pointer to a `git_error` object that describes the error.",
            "  */",
            " GIT_EXTERN(const git_error *) git_error_last(void);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/filter.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/filter.h",
            "+++ /home/libgit2-1.9.1/include/git2/filter.h",
            "@@ -10,17 +10,23 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/filter.h",
            "- * @brief Git filter APIs",
            "- *",
            "+ * @brief Filters modify files during checkout or commit",
            "  * @ingroup Git",
            "+ *",
            "+ * During checkout, filters update a file from a \"canonical\" state to",
            "+ * a format appropriate for the local filesystem; during commit, filters",
            "+ * produce the canonical state. For example, on Windows, the line ending",
            "+ * filters _may_ take a canonical state (with Unix-style newlines) in",
            "+ * the repository, and place the contents on-disk with Windows-style",
            "+ * `\\r\\n` line endings.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Filters are applied in one of two directions: smudging - which is",
            "  * exporting a file from the Git object database to the working directory,",
            "@@ -75,16 +81,19 @@",
            " \t/**",
            " \t * The commit to load attributes from, when",
            " \t * `GIT_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.",
            " \t */",
            " \tgit_oid attr_commit_id;",
            " } git_filter_options;",
            " ",
            "- #define GIT_FILTER_OPTIONS_VERSION 1",
            "- #define GIT_FILTER_OPTIONS_INIT {GIT_FILTER_OPTIONS_VERSION}",
            "+/** Current version for the `git_filter_options` structure */",
            "+#define GIT_FILTER_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_filter_options` */",
            "+#define GIT_FILTER_OPTIONS_INIT {GIT_FILTER_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * A filter that can transform file data",
            "  *",
            "  * This represents a filter that can be used to transform or even replace",
            "  * file data.  Libgit2 includes one built in filter and it is possible to",
            "  * write your own (see git2/sys/filter.h for information on that).",
            "@@ -264,13 +273,11 @@",
            " /**",
            "  * Free a git_filter_list",
            "  *",
            "  * @param filters A git_filter_list created by `git_filter_list_load`",
            "  */",
            " GIT_EXTERN(void) git_filter_list_free(git_filter_list *filters);",
            " ",
            "-",
            "-GIT_END_DECL",
            "-",
            " /** @} */",
            "+GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/global.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/global.h",
            "+++ /home/libgit2-1.9.1/include/git2/global.h",
            "@@ -5,14 +5,20 @@",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_git_global_h__",
            " #define INCLUDE_git_global_h__",
            " ",
            " #include \"common.h\"",
            " ",
            "+/**",
            "+ * @file git2/global.h",
            "+ * @brief libgit2 library initializer and shutdown functionality",
            "+ * @ingroup Git",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Init the global state",
            "  *",
            "  * This function must be called before any other libgit2 function in",
            "  * order to set up global state and threading.",
            "@@ -28,17 +34,18 @@",
            " /**",
            "  * Shutdown the global state",
            "  *",
            "  * Clean up the global state and threading context after calling it as",
            "  * many times as `git_libgit2_init()` was called - it will return the",
            "  * number of remainining initializations that have not been shutdown",
            "  * (after this one).",
            "- * ",
            "+ *",
            "  * @return the number of remaining initializations of the library, or an",
            "  * error code.",
            "  */",
            " GIT_EXTERN(int) git_libgit2_shutdown(void);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/graph.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/graph.h",
            "+++ /home/libgit2-1.9.1/include/git2/graph.h",
            "@@ -9,15 +9,15 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " ",
            " /**",
            "  * @file git2/graph.h",
            "- * @brief Git graph traversal routines",
            "+ * @brief Graph traversal routines",
            "  * @defgroup git_revwalk Git graph traversal routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "@@ -57,21 +57,22 @@",
            " ",
            " /**",
            "  * Determine if a commit is reachable from any of a list of commits by",
            "  * following parent edges.",
            "  *",
            "  * @param repo the repository where the commits exist",
            "  * @param commit a previously loaded commit",
            "- * @param length the number of commits in the provided `descendant_array`",
            "  * @param descendant_array oids of the commits",
            "+ * @param length the number of commits in the provided `descendant_array`",
            "  * @return 1 if the given commit is an ancestor of any of the given potential",
            "  * descendants, 0 if not, error code otherwise.",
            "  */",
            " GIT_EXTERN(int) git_graph_reachable_from_any(",
            " \tgit_repository *repo,",
            " \tconst git_oid *commit,",
            " \tconst git_oid descendant_array[],",
            " \tsize_t length);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/ignore.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/ignore.h",
            "+++ /home/libgit2-1.9.1/include/git2/ignore.h",
            "@@ -6,14 +6,23 @@",
            "  */",
            " #ifndef INCLUDE_git_ignore_h__",
            " #define INCLUDE_git_ignore_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            "+/**",
            "+ * @file git2/ignore.h",
            "+ * @brief Ignore particular untracked files",
            "+ * @ingroup Git",
            "+ * @{",
            "+ *",
            "+ * When examining the repository status, git can optionally ignore",
            "+ * specified untracked files.",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Add ignore rules for a repository.",
            "  *",
            "  * Excludesfile rules (i.e. .gitignore rules) are generally read from",
            "  * .gitignore files in the repository tree or from a shared system file",
            "@@ -69,10 +78,11 @@",
            "  *         of whether it exists or not), or an error < 0 if they could not.",
            "  */",
            " GIT_EXTERN(int) git_ignore_path_is_ignored(",
            " \tint *ignored,",
            " \tgit_repository *repo,",
            " \tconst char *path);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/index.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/index.h",
            "+++ /home/libgit2-1.9.1/include/git2/index.h",
            "@@ -11,17 +11,22 @@",
            " #include \"indexer.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"strarray.h\"",
            " ",
            " /**",
            "  * @file git2/index.h",
            "- * @brief Git index parsing and manipulation routines",
            "+ * @brief Index (aka \"cache\" aka \"staging area\")",
            "  * @defgroup git_index Git index parsing and manipulation routines",
            "  * @ingroup Git",
            "+ *",
            "+ * The index (or \"cache\", or \"staging area\") is the contents of the",
            "+ * next commit. In addition, the index stores other data, such as",
            "+ * conflicts that occurred during the last merge operation, and",
            "+ * the \"treecache\" to speed up various on-disk operations.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** Time structure used in a git index entry */",
            " typedef struct {",
            " \tint32_t seconds;",
            "@@ -73,29 +78,40 @@",
            "  * Bitmasks for on-disk fields of `git_index_entry`'s `flags`",
            "  *",
            "  * These bitmasks match the four fields in the `git_index_entry` `flags`",
            "  * value both in memory and on disk.  You can use them to interpret the",
            "  * data in the `flags`.",
            "  */",
            " ",
            "+/** Mask for name length */",
            " #define GIT_INDEX_ENTRY_NAMEMASK  (0x0fff)",
            "+/** Mask for index entry stage */",
            " #define GIT_INDEX_ENTRY_STAGEMASK (0x3000)",
            "+/** Shift bits for index entry */",
            " #define GIT_INDEX_ENTRY_STAGESHIFT 12",
            " ",
            " /**",
            "  * Flags for index entries",
            "  */",
            " typedef enum {",
            " \tGIT_INDEX_ENTRY_EXTENDED  = (0x4000),",
            " \tGIT_INDEX_ENTRY_VALID     = (0x8000)",
            " } git_index_entry_flag_t;",
            " ",
            "+/**",
            "+ * Macro to get the stage value (0 for the \"main index\", or a conflict",
            "+ * value) from an index entry.",
            "+ */",
            " #define GIT_INDEX_ENTRY_STAGE(E) \\",
            " \t(((E)->flags & GIT_INDEX_ENTRY_STAGEMASK) >> GIT_INDEX_ENTRY_STAGESHIFT)",
            " ",
            "+/**",
            "+ * Macro to set the stage value (0 for the \"main index\", or a conflict",
            "+ * value) for an index entry.",
            "+ */",
            " #define GIT_INDEX_ENTRY_STAGE_SET(E,S) do { \\",
            " \t(E)->flags = ((E)->flags & ~GIT_INDEX_ENTRY_STAGEMASK) | \\",
            " \t\t(((S) & 0x03) << GIT_INDEX_ENTRY_STAGESHIFT); } while (0)",
            " ",
            " /**",
            "  * Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`",
            "  *",
            "@@ -127,15 +143,22 @@",
            " \tGIT_INDEX_CAPABILITY_IGNORE_CASE = 1,",
            " \tGIT_INDEX_CAPABILITY_NO_FILEMODE = 2,",
            " \tGIT_INDEX_CAPABILITY_NO_SYMLINKS = 4,",
            " \tGIT_INDEX_CAPABILITY_FROM_OWNER  = -1",
            " } git_index_capability_t;",
            " ",
            " ",
            "-/** Callback for APIs that add/remove/update files matching pathspec */",
            "+/**",
            "+ * Callback for APIs that add/remove/update files matching pathspec",
            "+ *",
            "+ * @param path the path",
            "+ * @param matched_pathspec the given pathspec",
            "+ * @param payload the user-specified payload",
            "+ * @return 0 to continue with the index operation, positive number to         skip this file for the index operation, negative number on failure",
            "+ */",
            " typedef int GIT_CALLBACK(git_index_matched_path_cb)(",
            " \tconst char *path, const char *matched_pathspec, void *payload);",
            " ",
            " /** Flags for APIs that add files matching pathspec */",
            " typedef enum {",
            " \tGIT_INDEX_ADD_DEFAULT = 0,",
            " \tGIT_INDEX_ADD_FORCE = (1u << 0),",
            "@@ -162,54 +185,115 @@",
            " \t/** The \"ours\" side of a conflict. */",
            " \tGIT_INDEX_STAGE_OURS = 2,",
            " ",
            " \t/** The \"theirs\" side of a conflict. */",
            " \tGIT_INDEX_STAGE_THEIRS = 3",
            " } git_index_stage_t;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+",
            "+/**",
            "+ * The options for opening or creating an index.",
            "+ *",
            "+ * Initialize with `GIT_INDEX_OPTIONS_INIT`. Alternatively, you can",
            "+ * use `git_index_options_init`.",
            "+ *",
            "+ * @options[version] GIT_INDEX_OPTIONS_VERSION",
            "+ * @options[init_macro] GIT_INDEX_OPTIONS_INIT",
            "+ * @options[init_function] git_index_options_init",
            "+ */",
            "+typedef struct git_index_options {",
            "+\tunsigned int version; /**< The version */",
            "+",
            "+\t/**",
            "+\t * The object ID type for the object IDs that exist in the index.",
            "+\t *",
            "+\t * If this is not specified, this defaults to `GIT_OID_SHA1`.",
            "+\t */",
            "+\tgit_oid_t oid_type;",
            "+} git_index_options;",
            "+",
            "+/** Current version for the `git_index_options` structure */",
            "+#define GIT_INDEX_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_index_options` */",
            "+#define GIT_INDEX_OPTIONS_INIT { GIT_INDEX_OPTIONS_VERSION }",
            "+",
            "+/**",
            "+ * Initialize git_index_options structure",
            "+ *",
            "+ * Initializes a `git_index_options` with default values. Equivalent to creating",
            "+ * an instance with GIT_INDEX_OPTIONS_INIT.",
            "+ *",
            "+ * @param opts The `git_index_options` struct to initialize.",
            "+ * @param version The struct version; pass `GIT_INDEX_OPTIONS_VERSION`.",
            "+ * @return Zero on success; -1 on failure.",
            "+ */",
            "+GIT_EXTERN(int) git_index_options_init(",
            "+\tgit_index_options *opts,",
            "+\tunsigned int version);",
            "+",
            "+/**",
            "+ * Creates a new bare Git index object, without a repository to back",
            "+ * it. This index object is capable of storing SHA256 objects.",
            "+ *",
            "+ * @param index_out the pointer for the new index",
            "+ * @param index_path the path to the index file in disk",
            "+ * @param opts the options for opening the index, or NULL",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_index_open(",
            "+\tgit_index **index_out,",
            "+\tconst char *index_path,",
            "+\tconst git_index_options *opts);",
            "+",
            "+/**",
            "+ * Create an in-memory index object.",
            "+ *",
            "+ * @param index_out the pointer for the new index",
            "+ * @param opts the options for opening the index, or NULL",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_index_new(git_index **index_out, const git_index_options *opts);",
            "+",
            "+#else",
            "+",
            " /**",
            "  * Create a new bare Git index object as a memory representation",
            "  * of the Git index file in 'index_path', without a repository",
            "  * to back it.",
            "  *",
            "  * Since there is no ODB or working directory behind this index,",
            "  * any Index methods which rely on these (e.g. index_add_bypath)",
            "  * will fail with the GIT_ERROR error code.",
            "  *",
            "  * If you need to access the index of an actual repository,",
            "  * use the `git_repository_index` wrapper.",
            "  *",
            "  * The index must be freed once it's no longer in use.",
            "  *",
            "- * @param out the pointer for the new index",
            "+ * @param index_out the pointer for the new index",
            "  * @param index_path the path to the index file in disk",
            "  * @return 0 or an error code",
            "  */",
            "-",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_index_open(git_index **out, const char *index_path, git_oid_t oid_type);",
            "-#else",
            "-GIT_EXTERN(int) git_index_open(git_index **out, const char *index_path);",
            "-#endif",
            "+GIT_EXTERN(int) git_index_open(git_index **index_out, const char *index_path);",
            " ",
            " /**",
            "  * Create an in-memory index object.",
            "  *",
            "  * This index object cannot be read/written to the filesystem,",
            "  * but may be used to perform in-memory index operations.",
            "  *",
            "  * The index must be freed once it's no longer in use.",
            "  *",
            "- * @param out the pointer for the new index",
            "+ * @param index_out the pointer for the new index",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_index_new(git_index **out, git_oid_t oid_type);",
            "-#else",
            "-GIT_EXTERN(int) git_index_new(git_index **out);",
            "+GIT_EXTERN(int) git_index_new(git_index **index_out);",
            "+",
            " #endif",
            " ",
            " /**",
            "  * Free an existing index object.",
            "  *",
            "  * @param index an existing index object",
            "  */",
            "@@ -841,8 +925,9 @@",
            "  * @param iterator pointer to the iterator",
            "  */",
            " GIT_EXTERN(void) git_index_conflict_iterator_free(",
            " \tgit_index_conflict_iterator *iterator);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/indexer.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/indexer.h",
            "+++ /home/libgit2-1.9.1/include/git2/indexer.h",
            "@@ -1,20 +1,30 @@",
            " /*",
            "  * Copyright (C) the libgit2 contributors. All rights reserved.",
            "  *",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            "-#ifndef _INCLUDE_git_indexer_h__",
            "-#define _INCLUDE_git_indexer_h__",
            "+#ifndef INCLUDE_git_indexer_h__",
            "+#define INCLUDE_git_indexer_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " ",
            "+/**",
            "+ * @file git2/indexer.h",
            "+ * @brief Packfile indexing",
            "+ * @ingroup Git",
            "+ * @{",
            "+ *",
            "+ * Indexing is the operation of taking a packfile - which is simply a",
            "+ * collection of unordered commits - and producing an \"index\" so that",
            "+ * one can lookup a commit in the packfile by object ID.",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /** A git indexer object */",
            " typedef struct git_indexer git_indexer;",
            " ",
            " /**",
            "  * This structure is used to provide callers information about the",
            "@@ -49,27 +59,31 @@",
            " ",
            " /**",
            "  * Type for progress callbacks during indexing.  Return a value less",
            "  * than zero to cancel the indexing or download.",
            "  *",
            "  * @param stats Structure containing information about the state of the transfer",
            "  * @param payload Payload provided by caller",
            "+ * @return 0 on success or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_indexer_progress_cb)(const git_indexer_progress *stats, void *payload);",
            " ",
            " /**",
            "  * Options for indexer configuration",
            "  */",
            " typedef struct git_indexer_options {",
            " \tunsigned int version;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " \t/** permissions to use creating packfile or 0 for defaults */",
            " \tunsigned int mode;",
            " ",
            "+\t/** the type of object ids in the packfile or 0 for SHA1 */",
            "+\tgit_oid_t oid_type;",
            "+",
            " \t/**",
            " \t * object database from which to read base objects when",
            " \t * fixing thin packs. This can be NULL if there are no thin",
            " \t * packs; if a thin pack is encountered, an error will be",
            " \t * returned if there are bases missing.",
            " \t */",
            " \tgit_odb *odb;",
            "@@ -81,15 +95,18 @@",
            " \t/** progress_cb_payload payload for the progress callback */",
            " \tvoid *progress_cb_payload;",
            " ",
            " \t/** Do connectivity checks for the received pack */",
            " \tunsigned char verify;",
            " } git_indexer_options;",
            " ",
            "+/** Current version for the `git_indexer_options` structure */",
            " #define GIT_INDEXER_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_indexer_options` */",
            " #define GIT_INDEXER_OPTIONS_INIT { GIT_INDEXER_OPTIONS_VERSION }",
            " ",
            " /**",
            "  * Initializes a `git_indexer_options` with default values. Equivalent to",
            "  * creating an instance with GIT_INDEXER_OPTIONS_INIT.",
            "  *",
            "  * @param opts the `git_indexer_options` struct to initialize.",
            "@@ -102,21 +119,20 @@",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " /**",
            "  * Create a new indexer instance",
            "  *",
            "  * @param out where to store the indexer instance",
            "  * @param path to the directory where the packfile should be stored",
            "- * @param oid_type the oid type to use for objects",
            "+ * @param opts the options to create the indexer with",
            "  * @return 0 or an error code.",
            "  */",
            " GIT_EXTERN(int) git_indexer_new(",
            " \t\tgit_indexer **out,",
            " \t\tconst char *path,",
            "-\t\tgit_oid_t oid_type,",
            " \t\tgit_indexer_options *opts);",
            " #else",
            " /**",
            "  * Create a new indexer instance",
            "  *",
            "  * @param out where to store the indexer instance",
            "  * @param path to the directory where the packfile should be stored",
            "@@ -186,10 +202,11 @@",
            " /**",
            "  * Free the indexer and its resources",
            "  *",
            "  * @param idx the indexer to free",
            "  */",
            " GIT_EXTERN(void) git_indexer_free(git_indexer *idx);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/mailmap.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/mailmap.h",
            "+++ /home/libgit2-1.9.1/include/git2/mailmap.h",
            "@@ -9,18 +9,23 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/mailmap.h",
            "- * @brief Mailmap parsing routines",
            "+ * @brief Mailmaps provide alternate email addresses for users",
            "  * @defgroup git_mailmap Git mailmap routines",
            "  * @ingroup Git",
            "  * @{",
            "+ *",
            "+ * A mailmap can be used to specify alternate email addresses for",
            "+ * repository committers or authors. This allows systems to map",
            "+ * commits made using different email addresses to the same logical",
            "+ * person.",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Allocate a new mailmap object.",
            "  *",
            "  * This object is empty, so you'll have to add a mailmap file before you can do",
            "@@ -108,8 +113,9 @@",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_mailmap_resolve_signature(",
            " \tgit_signature **out, const git_mailmap *mm, const git_signature *sig);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/merge.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/merge.h",
            "+++ /home/libgit2-1.9.1/include/git2/merge.h",
            "@@ -13,17 +13,20 @@",
            " #include \"oidarray.h\"",
            " #include \"checkout.h\"",
            " #include \"index.h\"",
            " #include \"annotated_commit.h\"",
            " ",
            " /**",
            "  * @file git2/merge.h",
            "- * @brief Git merge routines",
            "+ * @brief Merge re-joins diverging branches of history",
            "  * @defgroup git_merge Git merge routines",
            "  * @ingroup Git",
            "+ *",
            "+ * Merge will take two commits and attempt to produce a commit that",
            "+ * includes the changes that were made in both branches.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * The file inputs to `git_merge_file`.  Callers should populate the",
            "  * `git_merge_file_input` structure with descriptions of the files in",
            "@@ -41,15 +44,18 @@",
            " \t/** File name of the conflicted file, or `NULL` to not merge the path. */",
            " \tconst char *path;",
            " ",
            " \t/** File mode of the conflicted file, or `0` to not merge the mode. */",
            " \tunsigned int mode;",
            " } git_merge_file_input;",
            " ",
            "+/** Current version for the `git_merge_file_input_options` structure */",
            " #define GIT_MERGE_FILE_INPUT_VERSION 1",
            "+",
            "+/** Static constructor for `git_merge_file_input_options` */",
            " #define GIT_MERGE_FILE_INPUT_INIT {GIT_MERGE_FILE_INPUT_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_merge_file_input` with default values. Equivalent to",
            "  * creating an instance with GIT_MERGE_FILE_INPUT_INIT.",
            "  *",
            "  * @param opts the `git_merge_file_input` instance to initialize.",
            "@@ -176,14 +182,15 @@",
            " \t * Do not produce file conflicts when common regions have",
            " \t * changed; keep the conflict markers in the file and accept",
            " \t * that as the merge result.",
            " \t */",
            " \tGIT_MERGE_FILE_ACCEPT_CONFLICTS = (1 << 9)",
            " } git_merge_file_flag_t;",
            " ",
            "+/** Default size for conflict markers */",
            " #define GIT_MERGE_CONFLICT_MARKER_SIZE\t7",
            " ",
            " /**",
            "  * Options for merging a file",
            "  */",
            " typedef struct {",
            " \tunsigned int version;",
            "@@ -213,15 +220,18 @@",
            " \tuint32_t flags;",
            " ",
            " \t/** The size of conflict markers (eg, \"<<<<<<<\").  Default is",
            " \t * GIT_MERGE_CONFLICT_MARKER_SIZE. */",
            " \tunsigned short marker_size;",
            " } git_merge_file_options;",
            " ",
            "+/** Current version for the `git_merge_file_options` structure */",
            " #define GIT_MERGE_FILE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_merge_file_options` */",
            " #define GIT_MERGE_FILE_OPTIONS_INIT {GIT_MERGE_FILE_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_merge_file_options structure",
            "  *",
            "  * Initializes a `git_merge_file_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_MERGE_FILE_OPTIONS_INIT`.",
            "@@ -308,15 +318,18 @@",
            " \t */",
            " \tgit_merge_file_favor_t file_favor;",
            " ",
            " \t/** see `git_merge_file_flag_t` above */",
            " \tuint32_t file_flags;",
            " } git_merge_options;",
            " ",
            "+/** Current version for the `git_merge_options` structure */",
            " #define GIT_MERGE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_merge_options` */",
            " #define GIT_MERGE_OPTIONS_INIT { \\",
            " \tGIT_MERGE_OPTIONS_VERSION, GIT_MERGE_FIND_RENAMES }",
            " ",
            " /**",
            "  * Initialize git_merge_options structure",
            "  *",
            "  * Initializes a `git_merge_options` with default values. Equivalent to",
            "@@ -467,14 +480,45 @@",
            " \tgit_repository *repo,",
            " \tsize_t length,",
            " \tconst git_oid input_array[]);",
            " ",
            " /**",
            "  * Find all merge bases given a list of commits",
            "  *",
            "+ * This behaves similar to [`git merge-base`](https://git-scm.com/docs/git-merge-base#_discussion).",
            "+ *",
            "+ * Given three commits `a`, `b`, and `c`, `merge_base_many`",
            "+ * will compute a hypothetical commit `m`, which is a merge between `b`",
            "+ * and `c`.",
            "+",
            "+ * For example, with the following topology:",
            "+ * ```text",
            "+ *        o---o---o---o---C",
            "+ *       /",
            "+ *      /   o---o---o---B",
            "+ *     /   /",
            "+ * ---2---1---o---o---o---A",
            "+ * ```",
            "+ *",
            "+ * the result of `merge_base_many` given `a`, `b`, and `c` is 1. This is",
            "+ * because the equivalent topology with the imaginary merge commit `m`",
            "+ * between `b` and `c` is:",
            "+ * ```text",
            "+ *        o---o---o---o---o",
            "+ *       /                 \\",
            "+ *      /   o---o---o---o---M",
            "+ *     /   /",
            "+ * ---2---1---o---o---o---A",
            "+ * ```",
            "+ *",
            "+ * and the result of `merge_base_many` given `a` and `m` is 1.",
            "+ *",
            "+ * If you're looking to recieve the common ancestor between all the",
            "+ * given commits, use `merge_base_octopus`.",
            "+ *",
            "  * @param out array in which to store the resulting ids",
            "  * @param repo the repository where the commits exist",
            "  * @param length The number of commits in the provided `input_array`",
            "  * @param input_array oids of the commits",
            "  * @return Zero on success; GIT_ENOTFOUND or -1 on failure.",
            "  */",
            " GIT_EXTERN(int) git_merge_bases_many(",
            "@@ -619,8 +663,9 @@",
            " \tconst git_annotated_commit **their_heads,",
            " \tsize_t their_heads_len,",
            " \tconst git_merge_options *merge_opts,",
            " \tconst git_checkout_options *checkout_opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/message.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/message.h",
            "+++ /home/libgit2-1.9.1/include/git2/message.h",
            "@@ -8,15 +8,15 @@",
            " #define INCLUDE_git_message_h__",
            " ",
            " #include \"common.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/message.h",
            "- * @brief Git message management routines",
            "+ * @brief Commit messages",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Clean up excess whitespace and make sure there is a trailing newline in the message.",
            "@@ -79,8 +79,8 @@",
            "  * @param arr The trailer to free.",
            "  */",
            " GIT_EXTERN(void) git_message_trailer_array_free(git_message_trailer_array *arr);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            " ",
            "-#endif /* INCLUDE_git_message_h__ */",
            "+#endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/net.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/net.h",
            "+++ /home/libgit2-1.9.1/include/git2/net.h",
            "@@ -9,20 +9,21 @@",
            " ",
            " #include \"common.h\"",
            " #include \"oid.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/net.h",
            "- * @brief Git networking declarations",
            "+ * @brief Low-level networking functionality",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            "+/** Default git protocol port number */",
            " #define GIT_DEFAULT_PORT \"9418\"",
            " ",
            " /**",
            "  * Direction of the connection.",
            "  *",
            "  * We need this because we need to know whether we should call",
            "  * git-upload-pack or git-receive-pack on the remote end when get_refs",
            "@@ -47,8 +48,9 @@",
            " \t * point to the target.",
            " \t */",
            " \tchar *symref_target;",
            " };",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/notes.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/notes.h",
            "+++ /home/libgit2-1.9.1/include/git2/notes.h",
            "@@ -7,31 +7,33 @@",
            " #ifndef INCLUDE_git_note_h__",
            " #define INCLUDE_git_note_h__",
            " ",
            " #include \"oid.h\"",
            " ",
            " /**",
            "  * @file git2/notes.h",
            "- * @brief Git notes management routines",
            "+ * @brief Notes are metadata attached to an object",
            "  * @defgroup git_note Git notes management routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Callback for git_note_foreach.",
            "  *",
            "- * Receives:",
            "- * - blob_id: Oid of the blob containing the message",
            "- * - annotated_object_id: Oid of the git object being annotated",
            "- * - payload: Payload data passed to `git_note_foreach`",
            "+ * @param blob_id object id of the blob containing the message",
            "+ * @param annotated_object_id the id of the object being annotated",
            "+ * @param payload user-specified data to the foreach function",
            "+ * @return 0 on success, or a negative number on failure",
            "  */",
            " typedef int GIT_CALLBACK(git_note_foreach_cb)(",
            "-\tconst git_oid *blob_id, const git_oid *annotated_object_id, void *payload);",
            "+\tconst git_oid *blob_id,",
            "+\tconst git_oid *annotated_object_id,",
            "+\tvoid *payload);",
            " ",
            " /**",
            "  * note iterator",
            "  */",
            " typedef struct git_iterator git_note_iterator;",
            " ",
            " /**",
            "@@ -299,8 +301,9 @@",
            " \tgit_repository *repo,",
            " \tconst char *notes_ref,",
            " \tgit_note_foreach_cb note_cb,",
            " \tvoid *payload);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/object.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/object.h",
            "+++ /home/libgit2-1.9.1/include/git2/object.h",
            "@@ -10,21 +10,22 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/object.h",
            "- * @brief Git revision object management routines",
            "+ * @brief Objects are blobs (files), trees (directories), commits, and annotated tags",
            "  * @defgroup git_object Git revision object management routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            "+/** Maximum size of a git object */",
            " #define GIT_OBJECT_SIZE_MAX UINT64_MAX",
            " ",
            " /**",
            "  * Lookup a reference to one of the objects in a repository.",
            "  *",
            "  * The generated reference is owned by the repository and",
            "  * should be closed with the `git_object_free` method",
            "@@ -49,26 +50,26 @@",
            " ",
            " /**",
            "  * Lookup a reference to one of the objects in a repository,",
            "  * given a prefix of its identifier (short id).",
            "  *",
            "  * The object obtained will be so that its identifier",
            "  * matches the first 'len' hexadecimal characters",
            "- * (packets of 4 bits) of the given 'id'.",
            "- * 'len' must be at least GIT_OID_MINPREFIXLEN, and",
            "- * long enough to identify a unique object matching",
            "- * the prefix; otherwise the method will fail.",
            "+ * (packets of 4 bits) of the given `id`. `len` must be",
            "+ * at least `GIT_OID_MINPREFIXLEN`, and long enough to",
            "+ * identify a unique object matching the prefix; otherwise",
            "+ * the method will fail.",
            "  *",
            "  * The generated reference is owned by the repository and",
            "  * should be closed with the `git_object_free` method",
            "  * instead of free'd manually.",
            "  *",
            "- * The 'type' parameter must match the type of the object",
            "+ * The `type` parameter must match the type of the object",
            "  * in the odb; the method will fail otherwise.",
            "- * The special value 'GIT_OBJECT_ANY' may be passed to let",
            "+ * The special value `GIT_OBJECT_ANY` may be passed to let",
            "  * the method guess the object's type.",
            "  *",
            "  * @param object_out pointer where to store the looked-up object",
            "  * @param repo the repository to look up the object",
            "  * @param id a short identifier for the object",
            "  * @param len the length of the short identifier",
            "  * @param type the type of the object",
            "@@ -256,15 +257,15 @@",
            "  * are valid, parseable content.  (Blobs are always valid by definition.)",
            "  * An error message will be set with an informative message if the object",
            "  * is not valid.",
            "  *",
            "  * @warning This function is experimental and its signature may change in",
            "  * the future.",
            "  *",
            "- * @param valid Output pointer to set with validity of the object content",
            "+ * @param[out] valid Output pointer to set with validity of the object content",
            "  * @param buf The contents to validate",
            "  * @param len The length of the buffer",
            "  * @param object_type The type of the object in the buffer",
            "  * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_object_rawcontent_is_valid(",
            " \tint *valid,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/odb.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/odb.h",
            "+++ /home/libgit2-1.9.1/include/git2/odb.h",
            "@@ -11,15 +11,15 @@",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"oidarray.h\"",
            " #include \"indexer.h\"",
            " ",
            " /**",
            "  * @file git2/odb.h",
            "- * @brief Git object database routines",
            "+ * @brief An object database manages the storage of git objects",
            "  * @defgroup git_odb Git object database routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** Flags controlling the behavior of ODB lookup operations */",
            "@@ -31,77 +31,97 @@",
            " \t * `git_odb_refresh` before processing a batch of objects.",
            " \t */",
            " \tGIT_ODB_LOOKUP_NO_REFRESH = (1 << 0)",
            " } git_odb_lookup_flags_t;",
            " ",
            " /**",
            "  * Function type for callbacks from git_odb_foreach.",
            "+ *",
            "+ * @param id an id of an object in the object database",
            "+ * @param payload the payload from the initial call to git_odb_foreach",
            "+ * @return 0 on success, or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_odb_foreach_cb)(const git_oid *id, void *payload);",
            " ",
            " /** Options for configuring a loose object backend. */",
            " typedef struct {",
            " \tunsigned int version; /**< version for the struct */",
            " ",
            " \t/**",
            " \t * Type of object IDs to use for this object database, or",
            " \t * 0 for default (currently SHA1).",
            " \t */",
            " \tgit_oid_t oid_type;",
            " } git_odb_options;",
            " ",
            "-/* The current version of the diff options structure */",
            "+/** The current version of the diff options structure */",
            " #define GIT_ODB_OPTIONS_VERSION 1",
            " ",
            "-/* Stack initializer for odb options.  Alternatively use",
            "+/**",
            "+ * Stack initializer for odb options.  Alternatively use",
            "  * `git_odb_options_init` programmatic initialization.",
            "  */",
            " #define GIT_ODB_OPTIONS_INIT { GIT_ODB_OPTIONS_VERSION }",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+",
            " /**",
            "  * Create a new object database with no backends.",
            "  *",
            "- * Before the ODB can be used for read/writing, a custom database",
            "- * backend must be manually added using `git_odb_add_backend()`",
            "+ * @param[out] odb location to store the database pointer, if opened.",
            "+ * @param opts the options for this object database or NULL for defaults",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_new(git_odb **odb, const git_odb_options *opts);",
            "+",
            "+/**",
            "+ * Create a new object database and automatically add loose and packed",
            "+ * backends.",
            "  *",
            "- * @param out location to store the database pointer, if opened.",
            "+ * @param[out] odb_out location to store the database pointer, if opened.",
            "  *\t\t\tSet to NULL if the open failed.",
            "+ * @param objects_dir path of the backends' \"objects\" directory.",
            "  * @param opts the options for this object database or NULL for defaults",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_odb_new(git_odb **out, const git_odb_options *opts);",
            "+GIT_EXTERN(int) git_odb_open(",
            "+\tgit_odb **odb_out,",
            "+\tconst char *objects_dir,",
            "+\tconst git_odb_options *opts);",
            "+",
            " #else",
            "-GIT_EXTERN(int) git_odb_new(git_odb **out);",
            "-#endif",
            "+",
            "+/**",
            "+ * Create a new object database with no backends.",
            "+ *",
            "+ * Before the ODB can be used for read/writing, a custom database",
            "+ * backend must be manually added using `git_odb_add_backend()`",
            "+ *",
            "+ * @param[out] odb location to store the database pointer, if opened.",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_new(git_odb **odb);",
            " ",
            " /**",
            "  * Create a new object database and automatically add",
            "  * the two default backends:",
            "  *",
            "  *\t- git_odb_backend_loose: read and write loose object files",
            "  *\t\tfrom disk, assuming `objects_dir` as the Objects folder",
            "  *",
            "  *\t- git_odb_backend_pack: read objects from packfiles,",
            "  *\t\tassuming `objects_dir` as the Objects folder which",
            "  *\t\tcontains a 'pack/' folder with the corresponding data",
            "  *",
            "- * @param out location to store the database pointer, if opened.",
            "+ * @param[out] odb_out location to store the database pointer, if opened.",
            "  *\t\t\tSet to NULL if the open failed.",
            "  * @param objects_dir path of the backends' \"objects\" directory.",
            "- * @param opts the options for this object database or NULL for defaults",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_odb_open(",
            "-\tgit_odb **out,",
            "-\tconst char *objects_dir,",
            "-\tconst git_odb_options *opts);",
            "-#else",
            "-GIT_EXTERN(int) git_odb_open(git_odb **out, const char *objects_dir);",
            "+GIT_EXTERN(int) git_odb_open(git_odb **odb_out, const char *objects_dir);",
            " #endif",
            " ",
            " /**",
            "  * Add an on-disk alternate to an existing Object DB.",
            "  *",
            "  * Note that the added path must point to an `objects`, not",
            "  * to a full repository, to use it as an alternate store.",
            "@@ -130,21 +150,21 @@",
            "  * This method queries all available ODB backends",
            "  * trying to read the given OID.",
            "  *",
            "  * The returned object is reference counted and",
            "  * internally cached, so it should be closed",
            "  * by the user once it's no longer in use.",
            "  *",
            "- * @param out pointer where to store the read object",
            "+ * @param[out] obj pointer where to store the read object",
            "  * @param db database to search for the object in.",
            "  * @param id identity of the object to read.",
            "  * @return 0 if the object was read, GIT_ENOTFOUND if the object is",
            "  *         not in the database.",
            "  */",
            "-GIT_EXTERN(int) git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id);",
            "+GIT_EXTERN(int) git_odb_read(git_odb_object **obj, git_odb *db, const git_oid *id);",
            " ",
            " /**",
            "  * Read an object from the database, given a prefix",
            "  * of its identifier.",
            "  *",
            "  * This method queries all available ODB backends",
            "  * trying to match the 'len' first hexadecimal",
            "@@ -156,36 +176,36 @@",
            "  * a unique object in all the backends; the",
            "  * method will fail otherwise.",
            "  *",
            "  * The returned object is reference counted and",
            "  * internally cached, so it should be closed",
            "  * by the user once it's no longer in use.",
            "  *",
            "- * @param out pointer where to store the read object",
            "+ * @param[out] obj pointer where to store the read object",
            "  * @param db database to search for the object in.",
            "  * @param short_id a prefix of the id of the object to read.",
            "  * @param len the length of the prefix",
            "  * @return 0 if the object was read, GIT_ENOTFOUND if the object is not in the",
            "  *         database. GIT_EAMBIGUOUS if the prefix is ambiguous",
            "  *         (several objects match the prefix)",
            "  */",
            "-GIT_EXTERN(int) git_odb_read_prefix(git_odb_object **out, git_odb *db, const git_oid *short_id, size_t len);",
            "+GIT_EXTERN(int) git_odb_read_prefix(git_odb_object **obj, git_odb *db, const git_oid *short_id, size_t len);",
            " ",
            " /**",
            "  * Read the header of an object from the database, without",
            "  * reading its full contents.",
            "  *",
            "  * The header includes the length and the type of an object.",
            "  *",
            "  * Note that most backends do not support reading only the header",
            "  * of an object, so the whole object will be read and then the",
            "  * header will be returned.",
            "  *",
            "- * @param len_out pointer where to store the length",
            "- * @param type_out pointer where to store the type",
            "+ * @param[out] len_out pointer where to store the length",
            "+ * @param[out] type_out pointer where to store the type",
            "  * @param db database to search for the object in.",
            "  * @param id identity of the object to read.",
            "  * @return 0 if the object was read, GIT_ENOTFOUND if the object is not",
            "  *         in the database.",
            "  */",
            " GIT_EXTERN(int) git_odb_read_header(size_t *len_out, git_object_t *type_out, git_odb *db, const git_oid *id);",
            " ",
            "@@ -282,45 +302,48 @@",
            "  * library will automatically attempt to refresh the ODB",
            "  * when a lookup fails, to see if the looked up object exists",
            "  * on disk but hasn't been loaded yet.",
            "  *",
            "  * @param db database to refresh",
            "  * @return 0 on success, error code otherwise",
            "  */",
            "-GIT_EXTERN(int) git_odb_refresh(struct git_odb *db);",
            "+GIT_EXTERN(int) git_odb_refresh(git_odb *db);",
            " ",
            " /**",
            "  * List all objects available in the database",
            "  *",
            "  * The callback will be called for each object available in the",
            "  * database. Note that the objects are likely to be returned in the index",
            "  * order, which would make accessing the objects in that order inefficient.",
            "  * Return a non-zero value from the callback to stop looping.",
            "  *",
            "  * @param db database to use",
            "  * @param cb the callback to call for each object",
            "  * @param payload data to pass to the callback",
            "  * @return 0 on success, non-zero callback return value, or error code",
            "  */",
            "-GIT_EXTERN(int) git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *payload);",
            "+GIT_EXTERN(int) git_odb_foreach(",
            "+\tgit_odb *db,",
            "+\tgit_odb_foreach_cb cb,",
            "+\tvoid *payload);",
            " ",
            " /**",
            "  * Write an object directly into the ODB",
            "  *",
            "  * This method writes a full object straight into the ODB.",
            "  * For most cases, it is preferred to write objects through a write",
            "  * stream, which is both faster and less memory intensive, specially",
            "  * for big objects.",
            "  *",
            "  * This method is provided for compatibility with custom backends",
            "  * which are not able to support streaming writes",
            "  *",
            "  * @param out pointer to store the OID result of the write",
            "  * @param odb object database where to store the object",
            "- * @param data buffer with the data to store",
            "+ * @param data @type `const unsigned char *` buffer with the data to store",
            "  * @param len size of the buffer",
            "  * @param type type of the data to store",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_odb_write(git_oid *out, git_odb *odb, const void *data, size_t len, git_object_t type);",
            " ",
            " /**",
            "@@ -378,15 +401,15 @@",
            "  * Read from an odb stream",
            "  *",
            "  * Most backends don't implement streaming reads",
            "  *",
            "  * @param stream the stream",
            "  * @param buffer a user-allocated buffer to store the data in.",
            "  * @param len the buffer's length",
            "- * @return 0 if the read succeeded, error code otherwise",
            "+ * @return the number of bytes read if succeeded, error code otherwise",
            "  */",
            " GIT_EXTERN(int) git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t len);",
            " ",
            " /**",
            "  * Free an odb stream",
            "  *",
            "  * @param stream the stream to free",
            "@@ -462,60 +485,78 @@",
            "  *",
            "  * @param db object database where the `multi-pack-index` file will be written.",
            "  * @return 0 or an error code.",
            "  */",
            " GIT_EXTERN(int) git_odb_write_multi_pack_index(",
            " \tgit_odb *db);",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+",
            " /**",
            "- * Determine the object-ID (sha1 or sha256 hash) of a data buffer",
            "+ * Generate the object ID (in SHA1 or SHA256 format) for a given data buffer.",
            "  *",
            "- * The resulting OID will be the identifier for the data buffer as if",
            "- * the data buffer it were to written to the ODB.",
            "- *",
            "- * @param out the resulting object-ID.",
            "+ * @param[out] oid the resulting object ID.",
            "  * @param data data to hash",
            "  * @param len size of the data",
            "  * @param object_type of the data to hash",
            "  * @param oid_type the oid type to hash to",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            " GIT_EXTERN(int) git_odb_hash(",
            "-\tgit_oid *out,",
            "+\tgit_oid *oid,",
            " \tconst void *data,",
            " \tsize_t len,",
            " \tgit_object_t object_type,",
            " \tgit_oid_t oid_type);",
            "+",
            "+/**",
            "+ * Determine the object ID of a file on disk.",
            "+ *",
            "+ * @param[out] oid oid structure the result is written into.",
            "+ * @param path file to read and determine object id for",
            "+ * @param object_type of the data to hash",
            "+ * @param oid_type the oid type to hash to",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_hashfile(",
            "+\tgit_oid *oid,",
            "+\tconst char *path,",
            "+\tgit_object_t object_type,",
            "+\tgit_oid_t oid_type);",
            " #else",
            "-GIT_EXTERN(int) git_odb_hash(git_oid *out, const void *data, size_t len, git_object_t type);",
            "-#endif",
            "+",
            "+/**",
            "+ * Determine the object-ID (sha1 or sha256 hash) of a data buffer",
            "+ *",
            "+ * The resulting OID will be the identifier for the data buffer as if",
            "+ * the data buffer it were to written to the ODB.",
            "+ *",
            "+ * @param[out] oid the resulting object-ID.",
            "+ * @param data data to hash",
            "+ * @param len size of the data",
            "+ * @param object_type of the data to hash",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_hash(git_oid *oid, const void *data, size_t len, git_object_t object_type);",
            " ",
            " /**",
            "  * Read a file from disk and fill a git_oid with the object id",
            "  * that the file would have if it were written to the Object",
            "  * Database as an object of the given type (w/o applying filters).",
            "  * Similar functionality to git.git's `git hash-object` without",
            "  * the `-w` flag, however, with the --no-filters flag.",
            "  * If you need filters, see git_repository_hashfile.",
            "  *",
            "- * @param out oid structure the result is written into.",
            "+ * @param[out] oid oid structure the result is written into.",
            "  * @param path file to read and determine object id for",
            "  * @param object_type of the data to hash",
            "- * @param oid_type the oid type to hash to",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_odb_hashfile(",
            "-\tgit_oid *out,",
            "-\tconst char *path,",
            "-\tgit_object_t object_type,",
            "-\tgit_oid_t oid_type);",
            "-#else",
            "-GIT_EXTERN(int) git_odb_hashfile(git_oid *out, const char *path, git_object_t type);",
            "+GIT_EXTERN(int) git_odb_hashfile(git_oid *oid, const char *path, git_object_t object_type);",
            "+",
            " #endif",
            " ",
            " /**",
            "  * Create a copy of an odb_object",
            "  *",
            "  * The returned copy must be manually freed with `git_odb_object_free`.",
            "  * Note that because of an implementation detail, the returned copy will be",
            "@@ -553,15 +594,15 @@",
            "  *",
            "  * This is the uncompressed, raw data as read from the ODB,",
            "  * without the leading header.",
            "  *",
            "  * This pointer is owned by the object and shall not be free'd.",
            "  *",
            "  * @param object the object",
            "- * @return a pointer to the data",
            "+ * @return @type `const unsigned char *` a pointer to the data",
            "  */",
            " GIT_EXTERN(const void *) git_odb_object_data(git_odb_object *object);",
            " ",
            " /**",
            "  * Return the size of an ODB object",
            "  *",
            "  * This is the real size of the `data` buffer, not the",
            "@@ -647,8 +688,9 @@",
            "  * @param cgraph the git commit-graph",
            "  * @return 0 on success; error code otherwise",
            "  */",
            " GIT_EXTERN(int) git_odb_set_commit_graph(git_odb *odb, git_commit_graph *cgraph);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/odb_backend.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/odb_backend.h",
            "+++ /home/libgit2-1.9.1/include/git2/odb_backend.h",
            "@@ -9,86 +9,42 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"indexer.h\"",
            " ",
            " /**",
            "  * @file git2/backend.h",
            "- * @brief Git custom backend functions",
            "+ * @brief Object database backends manage the storage of git objects",
            "  * @defgroup git_odb Git object database routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            "-/*",
            "- * Constructors for in-box ODB backends.",
            "- */",
            "-",
            " /** Options for configuring a packfile object backend. */",
            " typedef struct {",
            " \tunsigned int version; /**< version for the struct */",
            " ",
            " \t/**",
            " \t * Type of object IDs to use for this object database, or",
            " \t * 0 for default (currently SHA1).",
            " \t */",
            " \tgit_oid_t oid_type;",
            " } git_odb_backend_pack_options;",
            " ",
            "-/* The current version of the diff options structure */",
            "+/** The current version of the diff options structure */",
            " #define GIT_ODB_BACKEND_PACK_OPTIONS_VERSION 1",
            " ",
            "-/* Stack initializer for odb pack backend options.  Alternatively use",
            "+/**",
            "+ * Stack initializer for odb pack backend options.  Alternatively use",
            "  * `git_odb_backend_pack_options_init` programmatic initialization.",
            "  */",
            " #define GIT_ODB_BACKEND_PACK_OPTIONS_INIT \\",
            " \t{ GIT_ODB_BACKEND_PACK_OPTIONS_VERSION }",
            " ",
            "-/**",
            "- * Create a backend for the packfiles.",
            "- *",
            "- * @param out location to store the odb backend pointer",
            "- * @param objects_dir the Git repository's objects directory",
            "- *",
            "- * @return 0 or an error code",
            "- */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_odb_backend_pack(",
            "-\tgit_odb_backend **out,",
            "-\tconst char *objects_dir,",
            "-\tconst git_odb_backend_pack_options *opts);",
            "-#else",
            "-GIT_EXTERN(int) git_odb_backend_pack(",
            "-\tgit_odb_backend **out,",
            "-\tconst char *objects_dir);",
            "-#endif",
            "-",
            "-/**",
            "- * Create a backend out of a single packfile",
            "- *",
            "- * This can be useful for inspecting the contents of a single",
            "- * packfile.",
            "- *",
            "- * @param out location to store the odb backend pointer",
            "- * @param index_file path to the packfile's .idx file",
            "- *",
            "- * @return 0 or an error code",
            "- */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_odb_backend_one_pack(",
            "-\tgit_odb_backend **out,",
            "-\tconst char *index_file,",
            "-\tconst git_odb_backend_pack_options *opts);",
            "-#else",
            "-GIT_EXTERN(int) git_odb_backend_one_pack(",
            "-\tgit_odb_backend **out,",
            "-\tconst char *index_file);",
            "-#endif",
            "-",
            " typedef enum {",
            " \tGIT_ODB_BACKEND_LOOSE_FSYNC = (1 << 0)",
            " } git_odb_backend_loose_flag_t;",
            " ",
            " /** Options for configuring a loose object backend. */",
            " typedef struct {",
            " \tunsigned int version; /**< version for the struct */",
            "@@ -114,45 +70,116 @@",
            " \t/**",
            " \t * Type of object IDs to use for this object database, or",
            " \t * 0 for default (currently SHA1).",
            " \t */",
            " \tgit_oid_t oid_type;",
            " } git_odb_backend_loose_options;",
            " ",
            "-/* The current version of the diff options structure */",
            "+/** The current version of the diff options structure */",
            " #define GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION 1",
            " ",
            "-/* Stack initializer for odb loose backend options.  Alternatively use",
            "+/**",
            "+ * Stack initializer for odb loose backend options.  Alternatively use",
            "  * `git_odb_backend_loose_options_init` programmatic initialization.",
            "  */",
            " #define GIT_ODB_BACKEND_LOOSE_OPTIONS_INIT \\",
            " \t{ GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION, 0, -1 }",
            " ",
            "+/*",
            "+ * Constructors for in-box ODB backends.",
            "+ */",
            "+",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+",
            "+/**",
            "+ * Create a backend for a directory containing packfiles.",
            "+ *",
            "+ * @param[out] out location to store the odb backend pointer",
            "+ * @param objects_dir the Git repository's objects directory",
            "+ * @param opts the options to use when creating the pack backend",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_backend_pack(",
            "+\tgit_odb_backend **out,",
            "+\tconst char *objects_dir,",
            "+\tconst git_odb_backend_pack_options *opts);",
            "+",
            "+/**",
            "+ * Create a backend for a single packfile.",
            "+ *",
            "+ * @param[out] out location to store the odb backend pointer",
            "+ * @param index_file path to the packfile's .idx file",
            "+ * @param opts the options to use when creating the pack backend",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_backend_one_pack(",
            "+\tgit_odb_backend **out,",
            "+\tconst char *index_file,",
            "+\tconst git_odb_backend_pack_options *opts);",
            "+",
            " /**",
            "  * Create a backend for loose objects",
            "  *",
            "- * @param out location to store the odb backend pointer",
            "+ * @param[out] out location to store the odb backend pointer",
            "  * @param objects_dir the Git repository's objects directory",
            "  * @param opts options for the loose object backend or NULL",
            "  *",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            " GIT_EXTERN(int) git_odb_backend_loose(",
            " \tgit_odb_backend **out,",
            " \tconst char *objects_dir,",
            " \tgit_odb_backend_loose_options *opts);",
            "+",
            " #else",
            "+",
            "+/**",
            "+ * Create a backend for a directory containing packfiles.",
            "+ *",
            "+ * @param[out] out location to store the odb backend pointer",
            "+ * @param objects_dir the Git repository's objects directory",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_backend_pack(",
            "+\tgit_odb_backend **out,",
            "+\tconst char *objects_dir);",
            "+",
            "+/**",
            "+ * Create a backend out of a single packfile",
            "+ *",
            "+ * This can be useful for inspecting the contents of a single",
            "+ * packfile.",
            "+ *",
            "+ * @param[out] out location to store the odb backend pointer",
            "+ * @param index_file path to the packfile's .idx file",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_odb_backend_one_pack(",
            "+\tgit_odb_backend **out,",
            "+\tconst char *index_file);",
            "+",
            "+/**",
            "+ * Create a backend for loose objects",
            "+ *",
            "+ * @param[out] out location to store the odb backend pointer",
            "+ * @param objects_dir the Git repository's objects directory",
            "+ * @param compression_level zlib compression level (0-9), or -1 for the default",
            "+ * @param do_fsync if non-zero, perform an fsync on write",
            "+ * @param dir_mode permission to use when creating directories, or 0 for default",
            "+ * @param file_mode permission to use when creating directories, or 0 for default",
            "+ * @return 0 or an error code",
            "+ */",
            " GIT_EXTERN(int) git_odb_backend_loose(",
            " \tgit_odb_backend **out,",
            " \tconst char *objects_dir,",
            " \tint compression_level,",
            " \tint do_fsync,",
            " \tunsigned int dir_mode,",
            " \tunsigned int file_mode);",
            "+",
            " #endif",
            " ",
            " /** Streaming mode */",
            " typedef enum {",
            " \tGIT_STREAM_RDONLY = (1 << 1),",
            " \tGIT_STREAM_WRONLY = (1 << 2),",
            " \tGIT_STREAM_RW = (GIT_STREAM_RDONLY | GIT_STREAM_WRONLY)",
            "@@ -214,10 +241,11 @@",
            " \tgit_odb_backend *backend;",
            " ",
            " \tint GIT_CALLBACK(append)(git_odb_writepack *writepack, const void *data, size_t size, git_indexer_progress *stats);",
            " \tint GIT_CALLBACK(commit)(git_odb_writepack *writepack, git_indexer_progress *stats);",
            " \tvoid GIT_CALLBACK(free)(git_odb_writepack *writepack);",
            " };",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/oid.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/oid.h",
            "+++ /home/libgit2-1.9.1/include/git2/oid.h",
            "@@ -4,20 +4,19 @@",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_git_oid_h__",
            " #define INCLUDE_git_oid_h__",
            " ",
            " #include \"common.h\"",
            "-#include \"types.h\"",
            " #include \"experimental.h\"",
            " ",
            " /**",
            "  * @file git2/oid.h",
            "- * @brief Git object id routines",
            "+ * @brief Object IDs",
            "  * @defgroup git_oid Git object id routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** The type of object id. */",
            "@@ -78,21 +77,26 @@",
            " /**",
            "  * The string representation of the null sha256 object ID.",
            "  */",
            " # define GIT_OID_SHA256_HEXZERO \"0000000000000000000000000000000000000000000000000000000000000000\"",
            " ",
            " #endif",
            " ",
            "-/* Maximum possible object ID size in raw / hex string format. */",
            "-#ifndef GIT_EXPERIMENTAL_SHA256",
            "-# define GIT_OID_MAX_SIZE        GIT_OID_SHA1_SIZE",
            "-# define GIT_OID_MAX_HEXSIZE     GIT_OID_SHA1_HEXSIZE",
            "-#else",
            "+/** Maximum possible object ID size in raw format */",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            " # define GIT_OID_MAX_SIZE        GIT_OID_SHA256_SIZE",
            "+#else",
            "+# define GIT_OID_MAX_SIZE        GIT_OID_SHA1_SIZE",
            "+#endif",
            "+",
            "+/** Maximum possible object ID size in hex format */",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            " # define GIT_OID_MAX_HEXSIZE     GIT_OID_SHA256_HEXSIZE",
            "+#else",
            "+# define GIT_OID_MAX_HEXSIZE     GIT_OID_SHA1_HEXSIZE",
            " #endif",
            " ",
            " /** Minimum length (in number of hex characters,",
            "  * i.e. packets of 4 bits) of an oid prefix */",
            " #define GIT_OID_MINPREFIXLEN 4",
            " ",
            " /** Unique identity of any object (commit, tree, blob, tag). */",
            "@@ -103,78 +107,70 @@",
            " \tunsigned char type;",
            " #endif",
            " ",
            " \t/** raw binary formatted id */",
            " \tunsigned char id[GIT_OID_MAX_SIZE];",
            " } git_oid;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+",
            "+GIT_EXTERN(int) git_oid_fromstr(git_oid *out, const char *str, git_oid_t type);",
            "+GIT_EXTERN(int) git_oid_fromstrp(git_oid *out, const char *str, git_oid_t type);",
            "+GIT_EXTERN(int) git_oid_fromstrn(git_oid *out, const char *str, size_t length, git_oid_t type);",
            "+GIT_EXTERN(int) git_oid_fromraw(git_oid *out, const unsigned char *raw, git_oid_t type);",
            "+",
            "+#else",
            "+",
            " /**",
            "  * Parse a hex formatted object id into a git_oid.",
            "  *",
            "  * The appropriate number of bytes for the given object ID type will",
            "  * be read from the string - 40 bytes for SHA1, 64 bytes for SHA256.",
            "  * The given string need not be NUL terminated.",
            "  *",
            "  * @param out oid structure the result is written into.",
            "  * @param str input hex string; must be pointing at the start of",
            "  *\t\tthe hex sequence and have at least the number of bytes",
            "  *\t\tneeded for an oid encoded in hex (40 bytes for sha1,",
            "  *\t\t256 bytes for sha256).",
            "- * @param type the type of object id",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_oid_fromstr(git_oid *out, const char *str, git_oid_t type);",
            "-#else",
            " GIT_EXTERN(int) git_oid_fromstr(git_oid *out, const char *str);",
            "-#endif",
            " ",
            " /**",
            "  * Parse a hex formatted NUL-terminated string into a git_oid.",
            "  *",
            "  * @param out oid structure the result is written into.",
            "  * @param str input hex string; must be null-terminated.",
            "- * @param type the type of object id",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_oid_fromstrp(git_oid *out, const char *str, git_oid_t type);",
            "-#else",
            " GIT_EXTERN(int) git_oid_fromstrp(git_oid *out, const char *str);",
            "-#endif",
            " ",
            " /**",
            "  * Parse N characters of a hex formatted object id into a git_oid.",
            "  *",
            "  * If N is odd, the last byte's high nibble will be read in and the",
            "  * low nibble set to zero.",
            "  *",
            "  * @param out oid structure the result is written into.",
            "  * @param str input hex string of at least size `length`",
            "  * @param length length of the input string",
            "- * @param type the type of object id",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_oid_fromstrn(git_oid *out, const char *str, size_t length, git_oid_t type);",
            "-#else",
            " GIT_EXTERN(int) git_oid_fromstrn(git_oid *out, const char *str, size_t length);",
            "-#endif",
            " ",
            " /**",
            "  * Copy an already raw oid into a git_oid structure.",
            "  *",
            "  * @param out oid structure the result is written into.",
            "  * @param raw the raw input bytes to be copied.",
            "  * @return 0 on success or error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_oid_fromraw(git_oid *out, const unsigned char *raw, git_oid_t type);",
            "-#else",
            " GIT_EXTERN(int) git_oid_fromraw(git_oid *out, const unsigned char *raw);",
            "+",
            " #endif",
            " ",
            " /**",
            "  * Format a git_oid into a hex string.",
            "  *",
            "  * @param out output hex string; must be pointing at the start of",
            "  *\t\tthe hex sequence and have at least the number of bytes",
            "@@ -306,14 +302,15 @@",
            "  *         0 if id matches str, >0 if id sorts after str.",
            "  */",
            " GIT_EXTERN(int) git_oid_strcmp(const git_oid *id, const char *str);",
            " ",
            " /**",
            "  * Check is an oid is all zeros.",
            "  *",
            "+ * @param id the object ID to check",
            "  * @return 1 if all zeros, 0 otherwise.",
            "  */",
            " GIT_EXTERN(int) git_oid_is_zero(const git_oid *id);",
            " ",
            " /**",
            "  * OID Shortener object",
            "  */",
            "@@ -366,8 +363,9 @@",
            "  *",
            "  * @param os a `git_oid_shorten` instance",
            "  */",
            " GIT_EXTERN(void) git_oid_shorten_free(git_oid_shorten *os);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/oidarray.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/oidarray.h",
            "+++ /home/libgit2-1.9.1/include/git2/oidarray.h",
            "@@ -6,14 +6,21 @@",
            "  */",
            " #ifndef INCLUDE_git_oidarray_h__",
            " #define INCLUDE_git_oidarray_h__",
            " ",
            " #include \"common.h\"",
            " #include \"oid.h\"",
            " ",
            "+/**",
            "+ * @file git2/oidarray.h",
            "+ * @brief An array of object IDs",
            "+ * @defgroup git_oidarray Arrays of object IDs",
            "+ * @ingroup Git",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /** Array of object ids */",
            " typedef struct git_oidarray {",
            " \tgit_oid *ids;",
            " \tsize_t count;",
            " } git_oidarray;",
            "@@ -30,8 +37,7 @@",
            "  */",
            " GIT_EXTERN(void) git_oidarray_dispose(git_oidarray *array);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            " ",
            " #endif",
            "-"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/pack.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/pack.h",
            "+++ /home/libgit2-1.9.1/include/git2/pack.h",
            "@@ -229,28 +229,39 @@",
            "  * Get the number of objects the packbuilder has already written out",
            "  *",
            "  * @param pb the packbuilder",
            "  * @return the number of objects which have already been written",
            "  */",
            " GIT_EXTERN(size_t) git_packbuilder_written(git_packbuilder *pb);",
            " ",
            "-/** Packbuilder progress notification function */",
            "+/**",
            "+ * Packbuilder progress notification function.",
            "+ *",
            "+ * @param stage the stage of the packbuilder",
            "+ * @param current the current object",
            "+ * @param total the total number of objects",
            "+ * @param payload the callback payload",
            "+ * @return 0 on success or an error code",
            "+ */",
            " typedef int GIT_CALLBACK(git_packbuilder_progress)(",
            " \tint stage,",
            " \tuint32_t current,",
            " \tuint32_t total,",
            " \tvoid *payload);",
            " ",
            " /**",
            "  * Set the callbacks for a packbuilder",
            "  *",
            "  * @param pb The packbuilder object",
            "  * @param progress_cb Function to call with progress information during",
            "  * pack building. Be aware that this is called inline with pack building",
            "  * operations, so performance may be affected.",
            "+ * When progress_cb returns an error, the pack building process will be",
            "+ * aborted and the error will be returned from the invoked function.",
            "+ * `pb` must then be freed.",
            "  * @param progress_cb_payload Payload for progress callback.",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_packbuilder_set_callbacks(",
            " \tgit_packbuilder *pb,",
            " \tgit_packbuilder_progress progress_cb,",
            " \tvoid *progress_cb_payload);",
            "@@ -260,8 +271,9 @@",
            "  *",
            "  * @param pb The packbuilder",
            "  */",
            " GIT_EXTERN(void) git_packbuilder_free(git_packbuilder *pb);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/patch.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/patch.h",
            "+++ /home/libgit2-1.9.1/include/git2/patch.h",
            "@@ -10,15 +10,15 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"diff.h\"",
            " ",
            " /**",
            "  * @file git2/patch.h",
            "- * @brief Patch handling routines.",
            "+ * @brief Patches store the textual diffs in a delta",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * The diff patch is used to store all the text diffs for a delta.",
            "@@ -279,12 +279,11 @@",
            "  * @param patch A git_patch representing changes to one file",
            "  * @return 0 on success, <0 on failure.",
            "  */",
            " GIT_EXTERN(int) git_patch_to_buf(",
            " \tgit_buf *out,",
            " \tgit_patch *patch);",
            " ",
            "-GIT_END_DECL",
            "-",
            " /**@}*/",
            "+GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/pathspec.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/pathspec.h",
            "+++ /home/libgit2-1.9.1/include/git2/pathspec.h",
            "@@ -8,14 +8,21 @@",
            " #define INCLUDE_git_pathspec_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"strarray.h\"",
            " #include \"diff.h\"",
            " ",
            "+/**",
            "+ * @file git2/pathspec.h",
            "+ * @brief Specifiers for path matching",
            "+ * @defgroup git_pathspec Specifiers for path matching",
            "+ * @ingroup Git",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Compiled pathspec",
            "  */",
            " typedef struct git_pathspec git_pathspec;",
            " ",
            "@@ -272,9 +279,11 @@",
            "  * @param m The git_pathspec_match_list object",
            "  * @param pos The index into the failed items",
            "  * @return The pathspec pattern that didn't match anything",
            "  */",
            " GIT_EXTERN(const char *) git_pathspec_match_list_failed_entry(",
            " \tconst git_pathspec_match_list *m, size_t pos);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/proxy.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/proxy.h",
            "+++ /home/libgit2-1.9.1/include/git2/proxy.h",
            "@@ -8,14 +8,20 @@",
            " #define INCLUDE_git_proxy_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"cert.h\"",
            " #include \"credential.h\"",
            " ",
            "+/**",
            "+ * @file git2/proxy.h",
            "+ * @brief TLS proxies",
            "+ * @ingroup Git",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * The type of proxy to use.",
            "  */",
            " typedef enum {",
            " \t/**",
            "@@ -74,25 +80,29 @@",
            " \t/**",
            " \t * Payload to be provided to the credentials and certificate",
            " \t * check callbacks.",
            " \t */",
            " \tvoid *payload;",
            " } git_proxy_options;",
            " ",
            "+/** Current version for the `git_proxy_options` structure */",
            " #define GIT_PROXY_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_proxy_options` */",
            " #define GIT_PROXY_OPTIONS_INIT {GIT_PROXY_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_proxy_options structure",
            "  *",
            "  * Initializes a `git_proxy_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_PROXY_OPTIONS_INIT`.",
            "  *",
            "  * @param opts The `git_proxy_options` struct to initialize.",
            "  * @param version The struct version; pass `GIT_PROXY_OPTIONS_VERSION`.",
            "  * @return Zero on success; -1 on failure.",
            "  */",
            " GIT_EXTERN(int) git_proxy_options_init(git_proxy_options *opts, unsigned int version);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/rebase.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/rebase.h",
            "+++ /home/libgit2-1.9.1/include/git2/rebase.h",
            "@@ -13,16 +13,16 @@",
            " #include \"annotated_commit.h\"",
            " #include \"merge.h\"",
            " #include \"checkout.h\"",
            " #include \"commit.h\"",
            " ",
            " /**",
            "  * @file git2/rebase.h",
            "- * @brief Git rebase routines",
            "- * @defgroup git_rebase Git merge routines",
            "+ * @brief Rebase manipulates commits, placing them on a new parent",
            "+ * @defgroup git_rebase Rebase manipulates commits, placing them on a new parent",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Rebase options",
            "@@ -63,18 +63,17 @@",
            " \t/**",
            " \t * Options to control how trees are merged during `git_rebase_next`.",
            " \t */",
            " \tgit_merge_options merge_options;",
            " ",
            " \t/**",
            " \t * Options to control how files are written during `git_rebase_init`,",
            "-\t * `git_rebase_next` and `git_rebase_abort`.  Note that a minimum",
            "-\t * strategy of `GIT_CHECKOUT_SAFE` is defaulted in `init` and `next`,",
            "-\t * and a minimum strategy of `GIT_CHECKOUT_FORCE` is defaulted in",
            "-\t * `abort` to match git semantics.",
            "+\t * `git_rebase_next` and `git_rebase_abort`.  Note that during",
            "+\t * `abort`, these options will add an implied `GIT_CHECKOUT_FORCE`",
            "+\t * to match git semantics.",
            " \t */",
            " \tgit_checkout_options checkout_options;",
            " ",
            " \t/**",
            " \t * Optional callback that allows users to override commit",
            " \t * creation in `git_rebase_commit`.  If specified, users can",
            " \t * create their own commit and provide the commit ID, which",
            "@@ -151,15 +150,18 @@",
            " \t/**",
            " \t * No commit will be cherry-picked.  The client should run the given",
            " \t * command and (if successful) continue.",
            " \t */",
            " \tGIT_REBASE_OPERATION_EXEC",
            " } git_rebase_operation_t;",
            " ",
            "+/** Current version for the `git_rebase_options` structure */",
            " #define GIT_REBASE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_rebase_options` */",
            " #define GIT_REBASE_OPTIONS_INIT \\",
            " \t{ GIT_REBASE_OPTIONS_VERSION, 0, 0, NULL, GIT_MERGE_OPTIONS_INIT, \\",
            " \t  GIT_CHECKOUT_OPTIONS_INIT, NULL, NULL }",
            " ",
            " /** Indicates that a rebase operation is not (yet) in progress. */",
            " #define GIT_REBASE_NO_OPERATION SIZE_MAX",
            " ",
            "@@ -392,8 +394,9 @@",
            "  *",
            "  * @param rebase The rebase object",
            "  */",
            " GIT_EXTERN(void) git_rebase_free(git_rebase *rebase);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/refdb.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/refdb.h",
            "+++ /home/libgit2-1.9.1/include/git2/refdb.h",
            "@@ -10,16 +10,16 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"refs.h\"",
            " ",
            " /**",
            "  * @file git2/refdb.h",
            "- * @brief Git custom refs backend functions",
            "- * @defgroup git_refdb Git custom refs backend API",
            "+ * @brief A database for references (branches and tags)",
            "+ * @defgroup git_refdb A database for references (branches and tags)",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Create a new reference database with no backends."
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/reflog.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/reflog.h",
            "+++ /home/libgit2-1.9.1/include/git2/reflog.h",
            "@@ -9,16 +9,16 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " ",
            " /**",
            "  * @file git2/reflog.h",
            "- * @brief Git reflog management routines",
            "- * @defgroup git_reflog Git reflog management routines",
            "+ * @brief Reference logs store how references change",
            "+ * @defgroup git_reflog Reference logs store how references change",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Read the reflog for the given reference",
            "@@ -163,8 +163,9 @@",
            "  *",
            "  * @param reflog reflog to free",
            "  */",
            " GIT_EXTERN(void) git_reflog_free(git_reflog *reflog);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/refs.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/refs.h",
            "+++ /home/libgit2-1.9.1/include/git2/refs.h",
            "@@ -10,30 +10,30 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"strarray.h\"",
            " ",
            " /**",
            "  * @file git2/refs.h",
            "- * @brief Git reference management routines",
            "- * @defgroup git_reference Git reference management routines",
            "+ * @brief References point to a commit; generally these are branches and tags",
            "+ * @defgroup git_reference References point to a commit; generally these are branches and tags",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Lookup a reference by name in a repository.",
            "  *",
            "  * The returned reference must be freed by the user.",
            "  *",
            "  * The name will be checked for validity.",
            "  * See `git_reference_symbolic_create()` for rules about valid names.",
            "  *",
            "- * @param out pointer to the looked-up reference",
            "+ * @param[out] out pointer to the looked-up reference",
            "  * @param repo the repository to look up the reference",
            "  * @param name the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)",
            "  * @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.",
            "  */",
            " GIT_EXTERN(int) git_reference_lookup(git_reference **out, git_repository *repo, const char *name);",
            " ",
            " /**",
            "@@ -367,14 +367,15 @@",
            "  * a reference with the given name, the renaming will fail.",
            "  *",
            "  * IMPORTANT:",
            "  * The user needs to write a proper reflog entry if the",
            "  * reflog is enabled for the repository. We only rename",
            "  * the reflog if it exists.",
            "  *",
            "+ * @param[out] new_ref The new reference",
            "  * @param ref The reference to rename",
            "  * @param new_name The new name for the reference",
            "  * @param force Overwrite an existing reference",
            "  * @param log_message The one line long message to be appended to the reflog",
            "  * @return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code",
            "  *",
            "  */",
            "@@ -402,14 +403,15 @@",
            " ",
            " /**",
            "  * Delete an existing reference by name",
            "  *",
            "  * This method removes the named reference from the repository without",
            "  * looking at its old value.",
            "  *",
            "+ * @param repo The repository to remove the reference from",
            "  * @param name The reference to remove",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_reference_remove(git_repository *repo, const char *name);",
            " ",
            " /**",
            "  * Fill a list with all the references that can be found in a repository.",
            "@@ -514,15 +516,15 @@",
            " GIT_EXTERN(int) git_reference_cmp(",
            " \tconst git_reference *ref1,",
            " \tconst git_reference *ref2);",
            " ",
            " /**",
            "  * Create an iterator for the repo's references",
            "  *",
            "- * @param out pointer in which to store the iterator",
            "+ * @param[out] out pointer in which to store the iterator",
            "  * @param repo the repository",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_reference_iterator_new(",
            " \tgit_reference_iterator **out,",
            " \tgit_repository *repo);",
            " ",
            "@@ -539,15 +541,15 @@",
            " \tgit_reference_iterator **out,",
            " \tgit_repository *repo,",
            " \tconst char *glob);",
            " ",
            " /**",
            "  * Get the next reference",
            "  *",
            "- * @param out pointer in which to store the reference",
            "+ * @param[out] out pointer in which to store the reference",
            "  * @param iter the iterator",
            "  * @return 0, GIT_ITEROVER if there are no more; or an error code",
            "  */",
            " GIT_EXTERN(int) git_reference_next(git_reference **out, git_reference_iterator *iter);",
            " ",
            " /**",
            "  * Get the next reference's name",
            "@@ -720,15 +722,15 @@",
            "  *",
            "  * The retrieved `peeled` object is owned by the repository",
            "  * and should be closed with the `git_object_free` method.",
            "  *",
            "  * If you pass `GIT_OBJECT_ANY` as the target type, then the object",
            "  * will be peeled until a non-tag object is met.",
            "  *",
            "- * @param out Pointer to the peeled git_object",
            "+ * @param[out] out Pointer to the peeled git_object",
            "  * @param ref The reference to be processed",
            "  * @param type The type of the requested object (GIT_OBJECT_COMMIT,",
            "  * GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).",
            "  * @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code",
            "  */",
            " GIT_EXTERN(int) git_reference_peel(",
            " \tgit_object **out,",
            "@@ -764,8 +766,9 @@",
            "  * @param ref a reference",
            "  * @return the human-readable version of the name",
            "  */",
            " GIT_EXTERN(const char *) git_reference_shorthand(const git_reference *ref);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/refspec.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/refspec.h",
            "+++ /home/libgit2-1.9.1/include/git2/refspec.h",
            "@@ -10,16 +10,16 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"net.h\"",
            " #include \"buffer.h\"",
            " ",
            " /**",
            "  * @file git2/refspec.h",
            "- * @brief Git refspec attributes",
            "- * @defgroup git_refspec Git refspec attributes",
            "+ * @brief Refspecs map local references to remote references",
            "+ * @defgroup git_refspec Refspecs map local references to remote references",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Parse a given refspec string",
            "@@ -75,15 +75,24 @@",
            "  *",
            "  * @param spec refspec",
            "  * @return GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH",
            "  */",
            " GIT_EXTERN(git_direction) git_refspec_direction(const git_refspec *spec);",
            " ",
            " /**",
            "- * Check if a refspec's source descriptor matches a reference ",
            "+ * Check if a refspec's source descriptor matches a negative reference",
            "+ *",
            "+ * @param refspec the refspec",
            "+ * @param refname the name of the reference to check",
            "+ * @return 1 if the refspec matches, 0 otherwise",
            "+ */",
            "+GIT_EXTERN(int) git_refspec_src_matches_negative(const git_refspec *refspec, const char *refname);",
            "+",
            "+/**",
            "+ * Check if a refspec's source descriptor matches a reference",
            "  *",
            "  * @param refspec the refspec",
            "  * @param refname the name of the reference to check",
            "  * @return 1 if the refspec matches, 0 otherwise",
            "  */",
            " GIT_EXTERN(int) git_refspec_src_matches(const git_refspec *refspec, const char *refname);",
            " ",
            "@@ -112,10 +121,11 @@",
            "  * @param out where to store the source reference name",
            "  * @param spec the refspec",
            "  * @param name the name of the reference to transform",
            "  * @return 0, GIT_EBUFS or another error",
            "  */",
            " GIT_EXTERN(int) git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/remote.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/remote.h",
            "+++ /home/libgit2-1.9.1/include/git2/remote.h",
            "@@ -15,16 +15,16 @@",
            " #include \"strarray.h\"",
            " #include \"transport.h\"",
            " #include \"pack.h\"",
            " #include \"proxy.h\"",
            " ",
            " /**",
            "  * @file git2/remote.h",
            "- * @brief Git remote management functions",
            "- * @defgroup git_remote remote management functions",
            "+ * @brief Remotes are where local repositories fetch from and push to",
            "+ * @defgroup git_remote Remotes are where local repositories fetch from and push to",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Add a remote with the default fetch refspec to the repository's configuration.",
            "@@ -79,15 +79,15 @@",
            " /**",
            "  * How to handle reference updates.",
            "  */",
            " typedef enum {",
            " \t/* Write the fetch results to FETCH_HEAD. */",
            " \tGIT_REMOTE_UPDATE_FETCHHEAD = (1 << 0),",
            " ",
            "-\t/* Report unchanged tips in the update_tips callback. */",
            "+\t/* Report unchanged tips in the update_refs callback. */",
            " \tGIT_REMOTE_UPDATE_REPORT_UNCHANGED = (1 << 1)",
            " } git_remote_update_flags;",
            " ",
            " /**",
            "  * Remote creation options structure",
            "  *",
            "  * Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can",
            "@@ -112,15 +112,18 @@",
            " \t/** The fetchspec the remote should use. */",
            " \tconst char *fetchspec;",
            " ",
            " \t/** Additional flags for the remote. See git_remote_create_flags. */",
            " \tunsigned int flags;",
            " } git_remote_create_options;",
            " ",
            "+/** Current version for the `git_remote_create_options` structure */",
            " #define GIT_REMOTE_CREATE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_remote_create_options` */",
            " #define GIT_REMOTE_CREATE_OPTIONS_INIT {GIT_REMOTE_CREATE_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_remote_create_options structure",
            "  *",
            "  * Initializes a `git_remote_create_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.",
            "@@ -242,17 +245,17 @@",
            "  * @return a pointer to the name or NULL for in-memory remotes",
            "  */",
            " GIT_EXTERN(const char *) git_remote_name(const git_remote *remote);",
            " ",
            " /**",
            "  * Get the remote's url",
            "  *",
            "- * If url.*.insteadOf has been configured for this URL, it will",
            "- * return the modified URL.  If `git_remote_set_instance_pushurl`",
            "- * has been called for this remote, then that URL will be returned.",
            "+ * If url.*.insteadOf has been configured for this URL, it will return",
            "+ * the modified URL. This function does not consider if a push url has",
            "+ * been configured for this remote (use `git_remote_pushurl` if needed).",
            "  *",
            "  * @param remote the remote",
            "  * @return a pointer to the url",
            "  */",
            " GIT_EXTERN(const char *) git_remote_url(const git_remote *remote);",
            " ",
            " /**",
            "@@ -462,15 +465,23 @@",
            "  */",
            " typedef enum git_remote_completion_t {",
            " \tGIT_REMOTE_COMPLETION_DOWNLOAD,",
            " \tGIT_REMOTE_COMPLETION_INDEXING,",
            " \tGIT_REMOTE_COMPLETION_ERROR",
            " } git_remote_completion_t;",
            " ",
            "-/** Push network progress notification function */",
            "+/**",
            "+ * Push network progress notification callback.",
            "+ *",
            "+ * @param current The number of objects pushed so far",
            "+ * @param total The total number of objects to push",
            "+ * @param bytes The number of bytes pushed",
            "+ * @param payload The user-specified payload callback",
            "+ * @return 0 or an error code to stop the transfer",
            "+ */",
            " typedef int GIT_CALLBACK(git_push_transfer_progress_cb)(",
            " \tunsigned int current,",
            " \tunsigned int total,",
            " \tsize_t bytes,",
            " \tvoid *payload);",
            " ",
            " /**",
            "@@ -498,16 +509,20 @@",
            " /**",
            "  * Callback used to inform of upcoming updates.",
            "  *",
            "  * @param updates an array containing the updates which will be sent",
            "  * as commands to the destination.",
            "  * @param len number of elements in `updates`",
            "  * @param payload Payload provided by the caller",
            "+ * @return 0 or an error code to stop the push",
            "  */",
            "-typedef int GIT_CALLBACK(git_push_negotiation)(const git_push_update **updates, size_t len, void *payload);",
            "+typedef int GIT_CALLBACK(git_push_negotiation)(",
            "+\tconst git_push_update **updates,",
            "+\tsize_t len,",
            "+\tvoid *payload);",
            " ",
            " /**",
            "  * Callback used to inform of the update status from the remote.",
            "  *",
            "  * Called for each updated reference on push. If `status` is",
            "  * not `NULL`, the update was rejected by the remote server",
            "  * and `status` contains the reason given.",
            "@@ -564,15 +579,16 @@",
            " \t */",
            " \tgit_transport_message_cb sideband_progress;",
            " ",
            " \t/**",
            " \t * Completion is called when different parts of the download",
            " \t * process are done (currently unused).",
            " \t */",
            "-\tint GIT_CALLBACK(completion)(git_remote_completion_t type, void *data);",
            "+\tint GIT_CALLBACK(completion)(git_remote_completion_t type,",
            "+\t\tvoid *data);",
            " ",
            " \t/**",
            " \t * This will be called if the remote host requires",
            " \t * authentication in order to connect to it.",
            " \t *",
            " \t * Returning GIT_PASSTHROUGH will make libgit2 behave as",
            " \t * though this field isn't set.",
            "@@ -590,19 +606,30 @@",
            " \t/**",
            " \t * During the download of new data, this will be regularly",
            " \t * called with the current count of progress done by the",
            " \t * indexer.",
            " \t */",
            " \tgit_indexer_progress_cb transfer_progress;",
            " ",
            "+#ifdef GIT_DEPRECATE_HARD",
            "+\tvoid *reserved_update_tips;",
            "+#else",
            " \t/**",
            "-\t * Each time a reference is updated locally, this function",
            "-\t * will be called with information about it.",
            "+\t * Deprecated callback for reference updates, callers should",
            "+\t * set `update_refs` instead. This is retained for backward",
            "+\t * compatibility; if you specify both `update_refs` and",
            "+\t * `update_tips`, then only the `update_refs` function will",
            "+\t * be called.",
            "+\t *",
            "+\t * @deprecated the `update_refs` callback in this structure",
            "+\t * should be preferred",
            " \t */",
            "-\tint GIT_CALLBACK(update_tips)(const char *refname, const git_oid *a, const git_oid *b, void *data);",
            "+\tint GIT_CALLBACK(update_tips)(const char *refname,",
            "+\t\tconst git_oid *a, const git_oid *b, void *data);",
            "+#endif",
            " ",
            " \t/**",
            " \t * Function to call with progress information during pack",
            " \t * building. Be aware that this is called inline with pack",
            " \t * building operations, so performance may be affected.",
            " \t */",
            " \tgit_packbuilder_progress pack_progress;",
            "@@ -651,17 +678,33 @@",
            " \t * The returned URL will be used to connect to the remote instead.",
            " \t *",
            " \t * This callback is deprecated; users should use",
            " \t * git_remote_ready_cb and configure the instance URL instead.",
            " \t */",
            " \tgit_url_resolve_cb resolve_url;",
            " #endif",
            "+",
            "+\t/**",
            "+\t * Each time a reference is updated locally, this function",
            "+\t * will be called with information about it. This should be",
            "+\t * preferred over the `update_tips` callback in this",
            "+\t * structure.",
            "+\t */",
            "+\tint GIT_CALLBACK(update_refs)(",
            "+\t\tconst char *refname,",
            "+\t\tconst git_oid *a,",
            "+\t\tconst git_oid *b,",
            "+\t\tgit_refspec *spec,",
            "+\t\tvoid *data);",
            " };",
            " ",
            "+/** Current version for the `git_remote_callbacks_options` structure */",
            " #define GIT_REMOTE_CALLBACKS_VERSION 1",
            "+",
            "+/** Static constructor for `git_remote_callbacks_options` */",
            " #define GIT_REMOTE_CALLBACKS_INIT {GIT_REMOTE_CALLBACKS_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_remote_callbacks` with default values. Equivalent to",
            "  * creating an instance with GIT_REMOTE_CALLBACKS_INIT.",
            "  *",
            "  * @param opts the `git_remote_callbacks` struct to initialize",
            "@@ -780,15 +823,18 @@",
            " ",
            " \t/**",
            " \t * Extra headers for this fetch operation",
            " \t */",
            " \tgit_strarray custom_headers;",
            " } git_fetch_options;",
            " ",
            "+/** Current version for the `git_fetch_options` structure */",
            " #define GIT_FETCH_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_fetch_options` */",
            " #define GIT_FETCH_OPTIONS_INIT { \\",
            " \tGIT_FETCH_OPTIONS_VERSION, \\",
            " \tGIT_REMOTE_CALLBACKS_INIT, \\",
            " \tGIT_FETCH_PRUNE_UNSPECIFIED, \\",
            " \tGIT_REMOTE_UPDATE_FETCHHEAD, \\",
            " \tGIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED, \\",
            " \tGIT_PROXY_OPTIONS_INIT }",
            "@@ -848,15 +894,18 @@",
            " ",
            " \t/**",
            " \t * \"Push options\" to deliver to the remote.",
            " \t */",
            " \tgit_strarray remote_push_options;",
            " } git_push_options;",
            " ",
            "+/** Current version for the `git_push_options` structure */",
            " #define GIT_PUSH_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_push_options` */",
            " #define GIT_PUSH_OPTIONS_INIT { GIT_PUSH_OPTIONS_VERSION, 1, GIT_REMOTE_CALLBACKS_INIT, GIT_PROXY_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_push_options structure",
            "  *",
            "  * Initializes a `git_push_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_PUSH_OPTIONS_INIT`.",
            "@@ -892,15 +941,18 @@",
            " \t */",
            " \tgit_remote_redirect_t follow_redirects;",
            " ",
            " \t/** Extra HTTP headers to use in this connection */",
            " \tgit_strarray custom_headers;",
            " } git_remote_connect_options;",
            " ",
            "+/** Current version for the `git_remote_connect_options` structure */",
            " #define GIT_REMOTE_CONNECT_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_remote_connect_options` */",
            " #define GIT_REMOTE_CONNECT_OPTIONS_INIT { \\",
            " \tGIT_REMOTE_CONNECT_OPTIONS_VERSION, \\",
            " \tGIT_REMOTE_CALLBACKS_INIT, \\",
            " \tGIT_PROXY_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_remote_connect_options structure.",
            "@@ -1012,22 +1064,22 @@",
            " /**",
            "  * Update the tips to the new state.",
            "  *",
            "  * If callbacks are not specified then the callbacks specified to",
            "  * `git_remote_connect` will be used (if it was called).",
            "  *",
            "  * @param remote the remote to update",
            "- * @param reflog_message The message to insert into the reflogs. If",
            "- * NULL and fetching, the default is \"fetch <name>\", where <name> is",
            "- * the name of the remote (or its url, for in-memory remotes). This",
            "- * parameter is ignored when pushing.",
            "  * @param callbacks  pointer to the callback structure to use or NULL",
            "  * @param update_flags the git_remote_update_flags for these tips.",
            "  * @param download_tags what the behaviour for downloading tags is for this fetch. This is",
            "  * ignored for push. This must be the same value passed to `git_remote_download()`.",
            "+ * @param reflog_message The message to insert into the reflogs. If",
            "+ * NULL and fetching, the default is \"fetch <name>\", where <name> is",
            "+ * the name of the remote (or its url, for in-memory remotes). This",
            "+ * parameter is ignored when pushing.",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_remote_update_tips(",
            " \t\tgit_remote *remote,",
            " \t\tconst git_remote_callbacks *callbacks,",
            " \t\tunsigned int update_flags,",
            " \t\tgit_remote_autotag_option_t download_tags,",
            "@@ -1087,14 +1139,17 @@",
            " GIT_EXTERN(int) git_remote_push(",
            " \tgit_remote *remote,",
            " \tconst git_strarray *refspecs,",
            " \tconst git_push_options *opts);",
            " ",
            " /**",
            "  * Get the statistics structure that is filled in by the fetch operation.",
            "+ *",
            "+ * @param remote the remote to get statistics for",
            "+ * @return the git_indexer_progress for the remote",
            "  */",
            " GIT_EXTERN(const git_indexer_progress *) git_remote_stats(git_remote *remote);",
            " ",
            " /**",
            "  * Retrieve the tag auto-follow setting",
            "  *",
            "  * @param remote the remote to query",
            "@@ -1186,8 +1241,9 @@",
            "  * @return 0, GIT_ENOTFOUND if the remote does not have any references",
            "  * or none of them point to HEAD's commit, or an error message.",
            "  */",
            " GIT_EXTERN(int) git_remote_default_branch(git_buf *out, git_remote *remote);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/repository.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/repository.h",
            "+++ /home/libgit2-1.9.1/include/git2/repository.h",
            "@@ -6,36 +6,41 @@",
            "  */",
            " #ifndef INCLUDE_git_repository_h__",
            " #define INCLUDE_git_repository_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            "+#include \"odb.h\"",
            " #include \"buffer.h\"",
            " #include \"commit.h\"",
            " ",
            " /**",
            "  * @file git2/repository.h",
            "- * @brief Git repository management routines",
            "- * @defgroup git_repository Git repository management routines",
            "+ * @brief The repository stores revisions for a source tree",
            "+ * @defgroup git_repository The repository stores revisions for a source tree",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Open a git repository.",
            "  *",
            "  * The 'path' argument must point to either a git repository",
            "  * folder, or an existing work dir.",
            "  *",
            "  * The method will automatically detect if 'path' is a normal",
            "  * or bare repository or fail is 'path' is neither.",
            "  *",
            "- * @param out pointer to the repo which will be opened",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "+ * @param[out] out pointer to the repo which will be opened",
            "  * @param path the path to the repository",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_open(git_repository **out, const char *path);",
            " /**",
            "  * Open working tree as a repository",
            "  *",
            "@@ -53,38 +58,34 @@",
            "  *",
            "  * Create a repository object to wrap an object database to be used",
            "  * with the API when all you have is an object database. This doesn't",
            "  * have any paths associated with it, so use with care.",
            "  *",
            "  * @param out pointer to the repo",
            "  * @param odb the object database to wrap",
            "- * @param oid_type the oid type of the object database",
            "  * @return 0 or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_repository_wrap_odb(",
            "-\tgit_repository **out,",
            "-\tgit_odb *odb,",
            "-\tgit_oid_t oid_type);",
            "-#else",
            " GIT_EXTERN(int) git_repository_wrap_odb(",
            " \tgit_repository **out,",
            " \tgit_odb *odb);",
            "-#endif",
            " ",
            " /**",
            "  * Look for a git repository and copy its path in the given buffer.",
            "  * The lookup start from base_path and walk across parent directories",
            "  * if nothing has been found. The lookup ends when the first repository",
            "  * is found, or when reaching a directory referenced in ceiling_dirs",
            "  * or when the filesystem changes (in case across_fs is true).",
            "  *",
            "  * The method will automatically detect if the repository is bare",
            "  * (if there is a repository).",
            "  *",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "  * @param out A pointer to a user-allocated git_buf which will contain",
            "  * the found path.",
            "  *",
            "  * @param start_path The base path where the lookup starts.",
            "  *",
            "  * @param across_fs If true, then the lookup will not stop when a",
            "  * filesystem device change is detected while exploring parent directories.",
            "@@ -154,15 +155,19 @@",
            " \t */",
            " \tGIT_REPOSITORY_OPEN_FROM_ENV  = (1 << 4)",
            " } git_repository_open_flag_t;",
            " ",
            " /**",
            "  * Find and open a repository with extended controls.",
            "  *",
            "- * @param out Pointer to the repo which will be opened.  This can",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "+ * @param[out] out Pointer to the repo which will be opened.  This can",
            "  *        actually be NULL if you only want to use the error code to",
            "  *        see if a repo at this path could be opened.",
            "  * @param path Path to open as git repository.  If the flags",
            "  *        permit \"searching\", then this can be a path to a subdirectory",
            "  *        inside the working directory of the repository. May be NULL if",
            "  *        flags is GIT_REPOSITORY_OPEN_FROM_ENV.",
            "  * @param flags A combination of the GIT_REPOSITORY_OPEN flags above.",
            "@@ -182,15 +187,19 @@",
            " /**",
            "  * Open a bare repository on the serverside.",
            "  *",
            "  * This is a fast open for bare repositories that will come in handy",
            "  * if you're e.g. hosting git repositories and need to access them",
            "  * efficiently",
            "  *",
            "- * @param out Pointer to the repo which will be opened.",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "+ * @param[out] out Pointer to the repo which will be opened.",
            "  * @param bare_path Direct path to the bare repository",
            "  * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_open_bare(git_repository **out, const char *bare_path);",
            " ",
            " /**",
            "  * Free a previously allocated repository",
            "@@ -207,15 +216,19 @@",
            " ",
            " /**",
            "  * Creates a new Git repository in the given folder.",
            "  *",
            "  * TODO:",
            "  *\t- Reinit the repository",
            "  *",
            "- * @param out pointer to the repo which will be created or reinitialized",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "+ * @param[out] out pointer to the repo which will be created or reinitialized",
            "  * @param path the path to the repository",
            "  * @param is_bare if true, a Git repository without a working directory is",
            "  *\t\tcreated at the pointed path. If false, provided path will be",
            "  *\t\tconsidered as the working directory into which the .git directory",
            "  *\t\twill be created.",
            "  *",
            "  * @return 0 or an error code",
            "@@ -369,15 +382,18 @@",
            " \t * Type of object IDs to use for this repository, or 0 for",
            " \t * default (currently SHA1).",
            " \t */",
            " \tgit_oid_t oid_type;",
            " #endif",
            " } git_repository_init_options;",
            " ",
            "+/** Current version for the `git_repository_init_options` structure */",
            " #define GIT_REPOSITORY_INIT_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_repository_init_options` */",
            " #define GIT_REPOSITORY_INIT_OPTIONS_INIT {GIT_REPOSITORY_INIT_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_repository_init_options structure",
            "  *",
            "  * Initializes a `git_repository_init_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.",
            "@@ -394,14 +410,18 @@",
            "  * Create a new Git repository in the given folder with extended controls.",
            "  *",
            "  * This will initialize a new git repository (creating the repo_path",
            "  * if requested by flags) and working directory as needed.  It will",
            "  * auto-detect the case sensitivity of the file system and if the",
            "  * file system supports file mode bits correctly.",
            "  *",
            "+ * Note that the libgit2 library _must_ be initialized using",
            "+ * `git_libgit2_init` before any APIs can be called, including",
            "+ * this one.",
            "+ *",
            "  * @param out Pointer to the repo which will be created or reinitialized.",
            "  * @param repo_path The path to the repository.",
            "  * @param opts Pointer to git_repository_init_options struct.",
            "  * @return 0 or an error code on failure.",
            "  */",
            " GIT_EXTERN(int) git_repository_init_ext(",
            " \tgit_repository **out,",
            "@@ -411,15 +431,15 @@",
            " /**",
            "  * Retrieve and resolve the reference pointed at by HEAD.",
            "  *",
            "  * The returned `git_reference` will be owned by caller and",
            "  * `git_reference_free()` must be called when done with it to release the",
            "  * allocated memory and prevent a leak.",
            "  *",
            "- * @param out pointer to the reference which will be retrieved",
            "+ * @param[out] out pointer to the reference which will be retrieved",
            "  * @param repo a repository object",
            "  *",
            "  * @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing",
            "  * branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise",
            "  */",
            " GIT_EXTERN(int) git_repository_head(git_reference **out, git_repository *repo);",
            " ",
            "@@ -632,15 +652,15 @@",
            "  * If a custom ODB has not been set, the default",
            "  * database for the repository will be returned (the one",
            "  * located in `.git/objects`).",
            "  *",
            "  * The ODB must be freed once it's no longer being used by",
            "  * the user.",
            "  *",
            "- * @param out Pointer to store the loaded ODB",
            "+ * @param[out] out Pointer to store the loaded ODB",
            "  * @param repo A repository object",
            "  * @return 0, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_odb(git_odb **out, git_repository *repo);",
            " ",
            " /**",
            "  * Get the Reference Database Backend for this repository.",
            "@@ -648,15 +668,15 @@",
            "  * If a custom refsdb has not been set, the default database for",
            "  * the repository will be returned (the one that manipulates loose",
            "  * and packed references in the `.git` directory).",
            "  *",
            "  * The refdb must be freed once it's no longer being used by",
            "  * the user.",
            "  *",
            "- * @param out Pointer to store the loaded refdb",
            "+ * @param[out] out Pointer to store the loaded refdb",
            "  * @param repo A repository object",
            "  * @return 0, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_refdb(git_refdb **out, git_repository *repo);",
            " ",
            " /**",
            "  * Get the Index file for this repository.",
            "@@ -664,15 +684,15 @@",
            "  * If a custom index has not been set, the default",
            "  * index for the repository will be returned (the one",
            "  * located in `.git/index`).",
            "  *",
            "  * The index must be freed once it's no longer being used by",
            "  * the user.",
            "  *",
            "- * @param out Pointer to store the loaded index",
            "+ * @param[out] out Pointer to store the loaded index",
            "  * @param repo A repository object",
            "  * @return 0, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_index(git_index **out, git_repository *repo);",
            " ",
            " /**",
            "  * Retrieve git's prepared message",
            "@@ -854,15 +874,17 @@",
            "  * This behaves like `git_repository_set_head_detached()` but takes an",
            "  * annotated commit, which lets you specify which extended sha syntax",
            "  * string was specified by a user, allowing for more exact reflog",
            "  * messages.",
            "  *",
            "  * See the documentation for `git_repository_set_head_detached()`.",
            "  *",
            "- * @see git_repository_set_head_detached",
            "+ * @param repo Repository pointer",
            "+ * @param committish annotated commit to point HEAD to",
            "+ * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_set_head_detached_from_annotated(",
            " \tgit_repository *repo,",
            " \tconst git_annotated_commit *committish);",
            " ",
            " /**",
            "  * Detach the HEAD.",
            "@@ -947,16 +969,16 @@",
            " ",
            " /**",
            "  * Retrieve the configured identity to use for reflogs",
            "  *",
            "  * The memory is owned by the repository and must not be freed by the",
            "  * user.",
            "  *",
            "- * @param name where to store the pointer to the name",
            "- * @param email where to store the pointer to the email",
            "+ * @param[out] name where to store the pointer to the name",
            "+ * @param[out] email where to store the pointer to the email",
            "  * @param repo the repository",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_ident(const char **name, const char **email, const git_repository *repo);",
            " ",
            " /**",
            "  * Set the identity to be used for writing reflogs",
            "@@ -989,8 +1011,9 @@",
            "  * @param repo the repository",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_commit_parents(git_commitarray *commits, git_repository *repo);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/reset.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/reset.h",
            "+++ /home/libgit2-1.9.1/include/git2/reset.h",
            "@@ -10,15 +10,15 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"strarray.h\"",
            " #include \"checkout.h\"",
            " ",
            " /**",
            "  * @file git2/reset.h",
            "- * @brief Git reset management routines",
            "+ * @brief Reset will update the local repository to a prior state",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Kinds of reset operation",
            "@@ -71,19 +71,31 @@",
            "  *",
            "  * This behaves like `git_reset()` but takes an annotated commit,",
            "  * which lets you specify which extended sha syntax string was",
            "  * specified by a user, allowing for more exact reflog messages.",
            "  *",
            "  * See the documentation for `git_reset()`.",
            "  *",
            "- * @see git_reset",
            "+ * @param repo Repository where to perform the reset operation.",
            "+ *",
            "+ * @param target Annotated commit to which the Head should be moved to.",
            "+ * This object must belong to the given `repo`, it will be dereferenced",
            "+ * to a git_commit which oid will be used as the target of the branch.",
            "+ *",
            "+ * @param reset_type Kind of reset operation to perform.",
            "+ *",
            "+ * @param checkout_opts Optional checkout options to be used for a HARD reset.",
            "+ * The checkout_strategy field will be overridden (based on reset_type).",
            "+ * This parameter can be used to propagate notify and progress callbacks.",
            "+ *",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_reset_from_annotated(",
            " \tgit_repository *repo,",
            "-\tconst git_annotated_commit *commit,",
            "+\tconst git_annotated_commit *target,",
            " \tgit_reset_t reset_type,",
            " \tconst git_checkout_options *checkout_opts);",
            " ",
            " /**",
            "  * Updates some entries in the index from the target commit tree.",
            "  *",
            "  * The scope of the updated entries is determined by the paths",
            "@@ -104,8 +116,9 @@",
            " GIT_EXTERN(int) git_reset_default(",
            " \tgit_repository *repo,",
            " \tconst git_object *target,",
            " \tconst git_strarray* pathspecs);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/revert.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/revert.h",
            "+++ /home/libgit2-1.9.1/include/git2/revert.h",
            "@@ -9,16 +9,16 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"merge.h\"",
            " ",
            " /**",
            "  * @file git2/revert.h",
            "- * @brief Git revert routines",
            "- * @defgroup git_revert Git revert routines",
            "+ * @brief Cherry-pick the inverse of a change to \"undo\" its effects",
            "+ * @defgroup git_revert Cherry-pick the inverse of a change to \"undo\" its effects",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Options for revert",
            "@@ -29,16 +29,21 @@",
            " \t/** For merge commits, the \"mainline\" is treated as the parent. */",
            " \tunsigned int mainline;",
            " ",
            " \tgit_merge_options merge_opts; /**< Options for the merging */",
            " \tgit_checkout_options checkout_opts; /**< Options for the checkout */",
            " } git_revert_options;",
            " ",
            "+/** Current version for the `git_revert_options` structure */",
            " #define GIT_REVERT_OPTIONS_VERSION 1",
            "-#define GIT_REVERT_OPTIONS_INIT {GIT_REVERT_OPTIONS_VERSION, 0, GIT_MERGE_OPTIONS_INIT, GIT_CHECKOUT_OPTIONS_INIT}",
            "+",
            "+/** Static constructor for `git_revert_options` */",
            "+#define GIT_REVERT_OPTIONS_INIT { \\",
            "+\tGIT_REVERT_OPTIONS_VERSION, 0, \\",
            "+\tGIT_MERGE_OPTIONS_INIT, GIT_CHECKOUT_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_revert_options structure",
            "  *",
            "  * Initializes a `git_revert_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_REVERT_OPTIONS_INIT`.",
            "  *",
            "@@ -83,9 +88,9 @@",
            " GIT_EXTERN(int) git_revert(",
            " \tgit_repository *repo,",
            " \tgit_commit *commit,",
            " \tconst git_revert_options *given_opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "-#endif",
            " ",
            "+#endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/revparse.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/revparse.h",
            "+++ /home/libgit2-1.9.1/include/git2/revparse.h",
            "@@ -8,16 +8,16 @@",
            " #define INCLUDE_git_revparse_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/revparse.h",
            "- * @brief Git revision parsing routines",
            "- * @defgroup git_revparse Git revision parsing routines",
            "+ * @brief Parse the textual revision information",
            "+ * @defgroup git_revparse Parse the textual revision information",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Find a single object, as specified by a revision string.",
            "@@ -103,11 +103,11 @@",
            "  * @return 0 on success, GIT_INVALIDSPEC, GIT_ENOTFOUND, GIT_EAMBIGUOUS or an error code",
            "  */",
            " GIT_EXTERN(int) git_revparse(",
            " \tgit_revspec *revspec,",
            " \tgit_repository *repo,",
            " \tconst char *spec);",
            " ",
            "-",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/revwalk.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/revwalk.h",
            "+++ /home/libgit2-1.9.1/include/git2/revwalk.h",
            "@@ -9,16 +9,16 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " ",
            " /**",
            "  * @file git2/revwalk.h",
            "- * @brief Git revision traversal routines",
            "- * @defgroup git_revwalk Git revision traversal routines",
            "+ * @brief Traverse (walk) the commit graph (revision history)",
            "+ * @defgroup git_revwalk Traverse (walk) the commit graph (revision history)",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Flags to specify the sorting which a revwalk should perform.",
            "@@ -295,8 +295,9 @@",
            " GIT_EXTERN(int) git_revwalk_add_hide_cb(",
            " \tgit_revwalk *walk,",
            " \tgit_revwalk_hide_cb hide_cb,",
            " \tvoid *payload);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/signature.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/signature.h",
            "+++ /home/libgit2-1.9.1/include/git2/signature.h",
            "@@ -8,17 +8,21 @@",
            " #define INCLUDE_git_signature_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/signature.h",
            "- * @brief Git signature creation",
            "+ * @brief Signatures are the actor in a repository and when they acted",
            "  * @defgroup git_signature Git signature creation",
            "  * @ingroup Git",
            "+ *",
            "+ * Signatures contain the information about the actor (committer or",
            "+ * author) in a repository, and the time that they performed the",
            "+ * commit, or authoring.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Create a new action signature.",
            "  *",
            "@@ -45,21 +49,61 @@",
            "  * @param name name of the person",
            "  * @param email email of the person",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_signature_now(git_signature **out, const char *name, const char *email);",
            " ",
            " /**",
            "+ * Create a new author and/or committer signatures with default",
            "+ * information based on the configuration and environment variables.",
            "+ *",
            "+ * If `author_out` is set, it will be populated with the author",
            "+ * information. The `GIT_AUTHOR_NAME` and `GIT_AUTHOR_EMAIL`",
            "+ * environment variables will be honored, and `user.name` and",
            "+ * `user.email` configuration options will be honored if the",
            "+ * environment variables are unset. For timestamps, `GIT_AUTHOR_DATE`",
            "+ * will be used, otherwise the current time will be used.",
            "+ *",
            "+ * If `committer_out` is set, it will be populated with the",
            "+ * committer information. The `GIT_COMMITTER_NAME` and",
            "+ * `GIT_COMMITTER_EMAIL` environment variables will be honored,",
            "+ * and `user.name` and `user.email` configuration options will",
            "+ * be honored if the environment variables are unset. For timestamps,",
            "+ * `GIT_COMMITTER_DATE` will be used, otherwise the current time will",
            "+ * be used.",
            "+ *",
            "+ * If neither `GIT_AUTHOR_DATE` nor `GIT_COMMITTER_DATE` are set,",
            "+ * both timestamps will be set to the same time.",
            "+ *",
            "+ * It will return `GIT_ENOTFOUND` if either the `user.name` or",
            "+ * `user.email` are not set and there is no fallback from an environment",
            "+ * variable. One of `author_out` or `committer_out` must be set.",
            "+ *",
            "+ * @param author_out pointer to set the author signature, or NULL",
            "+ * @param committer_out pointer to set the committer signature, or NULL",
            "+ * @param repo repository pointer",
            "+ * @return 0 on success, GIT_ENOTFOUND if config is missing, or error code",
            "+ */",
            "+GIT_EXTERN(int) git_signature_default_from_env(",
            "+\tgit_signature **author_out,",
            "+\tgit_signature **committer_out,",
            "+\tgit_repository *repo);",
            "+",
            "+/**",
            "  * Create a new action signature with default user and now timestamp.",
            "  *",
            "  * This looks up the user.name and user.email from the configuration and",
            "  * uses the current time as the timestamp, and creates a new signature",
            "  * based on that information.  It will return GIT_ENOTFOUND if either the",
            "  * user.name or user.email are not set.",
            "  *",
            "+ * Note that these do not examine environment variables, only the",
            "+ * configuration files. Use `git_signature_default_from_env` to",
            "+ * consider the environment variables.",
            "+ *",
            "  * @param out new signature",
            "  * @param repo repository pointer",
            "  * @return 0 on success, GIT_ENOTFOUND if config is missing, or error code",
            "  */",
            " GIT_EXTERN(int) git_signature_default(git_signature **out, git_repository *repo);",
            " ",
            " /**",
            "@@ -96,8 +140,9 @@",
            "  *",
            "  * @param sig signature to free",
            "  */",
            " GIT_EXTERN(void) git_signature_free(git_signature *sig);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/stash.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/stash.h",
            "+++ /home/libgit2-1.9.1/include/git2/stash.h",
            "@@ -9,16 +9,21 @@",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"checkout.h\"",
            " ",
            " /**",
            "  * @file git2/stash.h",
            "- * @brief Git stash management routines",
            "+ * @brief Stashes stores some uncommitted state in the repository",
            "  * @ingroup Git",
            "+ *",
            "+ * Stashes stores some uncommitted state in the repository; generally",
            "+ * this allows a user to stash some changes so that they can restore",
            "+ * the working directory to an unmodified state. This can allow a",
            "+ * developer to work on two different changes in parallel.",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Stash flags",
            "  */",
            "@@ -90,15 +95,18 @@",
            " \t/** Optional description along with the stashed state. */",
            " \tconst char *message;",
            " ",
            " \t/** Optional paths that control which files are stashed. */",
            " \tgit_strarray paths;",
            " } git_stash_save_options;",
            " ",
            "+/** Current version for the `git_stash_save_options` structure */",
            " #define GIT_STASH_SAVE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_stash_save_options` */",
            " #define GIT_STASH_SAVE_OPTIONS_INIT { GIT_STASH_SAVE_OPTIONS_VERSION }",
            " ",
            " /**",
            "  * Initialize git_stash_save_options structure",
            "  *",
            "  * Initializes a `git_stash_save_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_STASH_SAVE_OPTIONS_INIT`.",
            "@@ -161,14 +169,18 @@",
            " \tGIT_STASH_APPLY_PROGRESS_DONE",
            " } git_stash_apply_progress_t;",
            " ",
            " /**",
            "  * Stash application progress notification function.",
            "  * Return 0 to continue processing, or a negative value to",
            "  * abort the stash application.",
            "+ *",
            "+ * @param progress the progress information",
            "+ * @param payload the user-specified payload to the apply function",
            "+ * @return 0 on success, -1 on error",
            "  */",
            " typedef int GIT_CALLBACK(git_stash_apply_progress_cb)(",
            " \tgit_stash_apply_progress_t progress,",
            " \tvoid *payload);",
            " ",
            " /**",
            "  * Stash application options structure",
            "@@ -187,15 +199,18 @@",
            " \tgit_checkout_options checkout_options;",
            " ",
            " \t/** Optional callback to notify the consumer of application progress. */",
            " \tgit_stash_apply_progress_cb progress_cb;",
            " \tvoid *progress_payload;",
            " } git_stash_apply_options;",
            " ",
            "+/** Current version for the `git_stash_apply_options` structure */",
            " #define GIT_STASH_APPLY_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_stash_apply_options` */",
            " #define GIT_STASH_APPLY_OPTIONS_INIT { \\",
            " \tGIT_STASH_APPLY_OPTIONS_VERSION, \\",
            " \tGIT_STASH_APPLY_DEFAULT, \\",
            " \tGIT_CHECKOUT_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_stash_apply_options structure",
            "@@ -221,16 +236,14 @@",
            "  * then those files will remain in the working directory.",
            "  *",
            "  * If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be",
            "  * conflicts when reinstating the index, the function will return",
            "  * GIT_EMERGECONFLICT and both the working directory and index will be left",
            "  * unmodified.",
            "  *",
            "- * Note that a minimum checkout strategy of `GIT_CHECKOUT_SAFE` is implied.",
            "- *",
            "  * @param repo The owning repository.",
            "  * @param index The position within the stash list. 0 points to the",
            "  *              most recent stashed state.",
            "  * @param options Optional options to control how stashes are applied.",
            "  *",
            "  * @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the",
            "  *         given index, GIT_EMERGECONFLICT if changes exist in the working",
            "@@ -307,8 +320,9 @@",
            " GIT_EXTERN(int) git_stash_pop(",
            " \tgit_repository *repo,",
            " \tsize_t index,",
            " \tconst git_stash_apply_options *options);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/status.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/status.h",
            "+++ /home/libgit2-1.9.1/include/git2/status.h",
            "@@ -10,15 +10,15 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"strarray.h\"",
            " #include \"diff.h\"",
            " ",
            " /**",
            "  * @file git2/status.h",
            "- * @brief Git file status routines",
            "+ * @brief Status indicates how a user has changed the working directory and index",
            "  * @defgroup git_status Git file status routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "@@ -50,19 +50,18 @@",
            " \tGIT_STATUS_IGNORED          = (1u << 14),",
            " \tGIT_STATUS_CONFLICTED       = (1u << 15)",
            " } git_status_t;",
            " ",
            " /**",
            "  * Function pointer to receive status on individual files",
            "  *",
            "- * `path` is the relative path to the file from the root of the repository.",
            "- *",
            "- * `status_flags` is a combination of `git_status_t` values that apply.",
            "- *",
            "- * `payload` is the value you passed to the foreach function as payload.",
            "+ * @param path is the path to the file",
            "+ * @param status_flags the `git_status_t` values for file's status",
            "+ * @param payload the user-specified payload to the foreach function",
            "+ * @return 0 on success, or a negative number on failure",
            "  */",
            " typedef int GIT_CALLBACK(git_status_cb)(",
            " \tconst char *path, unsigned int status_flags, void *payload);",
            " ",
            " /**",
            "  * Select the files on which to report status.",
            "  *",
            "@@ -203,14 +202,15 @@",
            " \t/**",
            " \t * Unreadable files will be detected and given the status",
            " \t * untracked instead of unreadable.",
            " \t */",
            " \tGIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED  = (1u << 15)",
            " } git_status_opt_t;",
            " ",
            "+/** Default `git_status_opt_t` values */",
            " #define GIT_STATUS_OPT_DEFAULTS \\",
            " \t(GIT_STATUS_OPT_INCLUDE_IGNORED | \\",
            " \tGIT_STATUS_OPT_INCLUDE_UNTRACKED | \\",
            " \tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS)",
            " ",
            " /**",
            "  * Options to control how `git_status_foreach_ext()` will issue callbacks.",
            "@@ -257,15 +257,18 @@",
            " \t/**",
            " \t * Threshold above which similar files will be considered renames.",
            " \t * This is equivalent to the -M option. Defaults to 50.",
            " \t */",
            " \tuint16_t          rename_threshold;",
            " } git_status_options;",
            " ",
            "+/** Current version for the `git_status_options` structure */",
            " #define GIT_STATUS_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_status_options` */",
            " #define GIT_STATUS_OPTIONS_INIT {GIT_STATUS_OPTIONS_VERSION}",
            " ",
            " /**",
            "  * Initialize git_status_options structure",
            "  *",
            "  * Initializes a `git_status_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_STATUS_OPTIONS_INIT`.",
            "@@ -445,8 +448,9 @@",
            " GIT_EXTERN(int) git_status_should_ignore(",
            " \tint *ignored,",
            " \tgit_repository *repo,",
            " \tconst char *path);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/stdint.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/stdint.h",
            "+++ /home/libgit2-1.9.1/include/git2/stdint.h",
            "@@ -1,78 +1,80 @@",
            "-// ISO C9x  compliant stdint.h for Microsoft Visual Studio",
            "-// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124",
            "-//",
            "-//  Copyright (c) 2006-2008 Alexander Chemeris",
            "-//",
            "-// Redistribution and use in source and binary forms, with or without",
            "-// modification, are permitted provided that the following conditions are met:",
            "-//",
            "-//   1. Redistributions of source code must retain the above copyright notice,",
            "-//      this list of conditions and the following disclaimer.",
            "-//",
            "-//   2. Redistributions in binary form must reproduce the above copyright",
            "-//      notice, this list of conditions and the following disclaimer in the",
            "-//      documentation and/or other materials provided with the distribution.",
            "-//",
            "-//   3. The name of the author may be used to endorse or promote products",
            "-//      derived from this software without specific prior written permission.",
            "-//",
            "-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED",
            "-// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF",
            "-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO",
            "-// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,",
            "-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
            "-// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;",
            "-// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,",
            "-// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR",
            "-// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF",
            "-// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "-//",
            "-///////////////////////////////////////////////////////////////////////////////",
            "+/* ISO C9x  compliant stdint.h for Microsoft Visual Studio",
            "+ * Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124",
            "+ *",
            "+ *  Copyright (c) 2006-2008 Alexander Chemeris",
            "+ *",
            "+ * Redistribution and use in source and binary forms, with or without",
            "+ * modification, are permitted provided that the following conditions are met:",
            "+ *",
            "+ *   1. Redistributions of source code must retain the above copyright notice,",
            "+ *      this list of conditions and the following disclaimer.",
            "+ *",
            "+ *   2. Redistributions in binary form must reproduce the above copyright",
            "+ *      notice, this list of conditions and the following disclaimer in the",
            "+ *      documentation and/or other materials provided with the distribution.",
            "+ *",
            "+ *   3. The name of the author may be used to endorse or promote products",
            "+ *      derived from this software without specific prior written permission.",
            "+ *",
            "+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED",
            "+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF",
            "+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO",
            "+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,",
            "+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
            "+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;",
            "+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,",
            "+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR",
            "+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF",
            "+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
            "+ *",
            "+ *******************************************************************************/",
            " ",
            "-#ifdef _MSC_VER // [",
            "+#ifdef _MSC_VER /* [ */",
            " ",
            "-#ifndef _MSC_STDINT_H_ // [",
            "+#ifndef _MSC_STDINT_H_ /* [ */",
            " #define _MSC_STDINT_H_",
            " ",
            " #if _MSC_VER > 1000",
            " #pragma once",
            " #endif",
            " ",
            " #include <limits.h>",
            " ",
            "-// For Visual Studio 6 in C++ mode and for many Visual Studio versions when",
            "-// compiling for ARM we should wrap <wchar.h> include with 'extern \"C++\" {}'",
            "-// or compiler give many errors like this:",
            "-//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed",
            "+/* For Visual Studio 6 in C++ mode and for many Visual Studio versions when",
            "+ * compiling for ARM we should wrap <wchar.h> include with 'extern \"C++\" {}'",
            "+ * or compiler give many errors like this:",
            "+ *   error C2733: second C linkage of overloaded function 'wmemchr' not allowed",
            "+*/",
            " #ifdef __cplusplus",
            " extern \"C\" {",
            " #endif",
            " #  include <wchar.h>",
            " #ifdef __cplusplus",
            " }",
            " #endif",
            " ",
            "-// Define _W64 macros to mark types changing their size, like intptr_t.",
            "+/* Define _W64 macros to mark types changing their size, like intptr_t. */",
            " #ifndef _W64",
            " #  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300",
            " #     define _W64 __w64",
            " #  else",
            " #     define _W64",
            " #  endif",
            " #endif",
            " ",
            " ",
            "-// 7.18.1 Integer types",
            "-",
            "-// 7.18.1.1 Exact-width integer types",
            "-",
            "-// Visual Studio 6 and Embedded Visual C++ 4 doesn't",
            "-// realize that, e.g. char has the same size as __int8",
            "-// so we give up on __intX for them.",
            "+/* 7.18.1 Integer types",
            "+ *",
            "+ * 7.18.1.1 Exact-width integer types",
            "+ *",
            "+ * Visual Studio 6 and Embedded Visual C++ 4 doesn't",
            "+ * realize that, e.g. char has the same size as __int8",
            "+ * so we give up on __intX for them.",
            "+ */",
            " #if (_MSC_VER < 1300)",
            "    typedef signed char       int8_t;",
            "    typedef signed short      int16_t;",
            "    typedef signed int        int32_t;",
            "    typedef unsigned char     uint8_t;",
            "    typedef unsigned short    uint16_t;",
            "    typedef unsigned int      uint32_t;",
            "@@ -84,164 +86,164 @@",
            "    typedef unsigned __int16  uint16_t;",
            "    typedef unsigned __int32  uint32_t;",
            " #endif",
            " typedef signed __int64       int64_t;",
            " typedef unsigned __int64     uint64_t;",
            " ",
            " ",
            "-// 7.18.1.2 Minimum-width integer types",
            "+/* 7.18.1.2 Minimum-width integer types */",
            " typedef int8_t    int_least8_t;",
            " typedef int16_t   int_least16_t;",
            " typedef int32_t   int_least32_t;",
            " typedef int64_t   int_least64_t;",
            " typedef uint8_t   uint_least8_t;",
            " typedef uint16_t  uint_least16_t;",
            " typedef uint32_t  uint_least32_t;",
            " typedef uint64_t  uint_least64_t;",
            " ",
            "-// 7.18.1.3 Fastest minimum-width integer types",
            "+/* 7.18.1.3 Fastest minimum-width integer types */",
            " typedef int8_t    int_fast8_t;",
            " typedef int16_t   int_fast16_t;",
            " typedef int32_t   int_fast32_t;",
            " typedef int64_t   int_fast64_t;",
            " typedef uint8_t   uint_fast8_t;",
            " typedef uint16_t  uint_fast16_t;",
            " typedef uint32_t  uint_fast32_t;",
            " typedef uint64_t  uint_fast64_t;",
            " ",
            "-// 7.18.1.4 Integer types capable of holding object pointers",
            "-#ifdef _WIN64 // [",
            "+/* 7.18.1.4 Integer types capable of holding object pointers */",
            "+#ifdef _WIN64 /* [ */",
            "    typedef signed __int64    intptr_t;",
            "    typedef unsigned __int64  uintptr_t;",
            "-#else // _WIN64 ][",
            "+#else /* _WIN64 ][ */",
            "    typedef _W64 signed int   intptr_t;",
            "    typedef _W64 unsigned int uintptr_t;",
            "-#endif // _WIN64 ]",
            "+#endif /* _WIN64 ] */",
            " ",
            "-// 7.18.1.5 Greatest-width integer types",
            "+/* 7.18.1.5 Greatest-width integer types */",
            " typedef int64_t   intmax_t;",
            " typedef uint64_t  uintmax_t;",
            " ",
            " ",
            "-// 7.18.2 Limits of specified-width integer types",
            "+/* 7.18.2 Limits of specified-width integer types */",
            " ",
            "-#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259",
            "+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) /* [   See footnote 220 at page 257 and footnote 221 at page 259 */",
            " ",
            "-// 7.18.2.1 Limits of exact-width integer types",
            "+/* 7.18.2.1 Limits of exact-width integer types */",
            " #define INT8_MIN     ((int8_t)_I8_MIN)",
            " #define INT8_MAX     _I8_MAX",
            " #define INT16_MIN    ((int16_t)_I16_MIN)",
            " #define INT16_MAX    _I16_MAX",
            " #define INT32_MIN    ((int32_t)_I32_MIN)",
            " #define INT32_MAX    _I32_MAX",
            " #define INT64_MIN    ((int64_t)_I64_MIN)",
            " #define INT64_MAX    _I64_MAX",
            " #define UINT8_MAX    _UI8_MAX",
            " #define UINT16_MAX   _UI16_MAX",
            " #define UINT32_MAX   _UI32_MAX",
            " #define UINT64_MAX   _UI64_MAX",
            " ",
            "-// 7.18.2.2 Limits of minimum-width integer types",
            "+/* 7.18.2.2 Limits of minimum-width integer types */",
            " #define INT_LEAST8_MIN    INT8_MIN",
            " #define INT_LEAST8_MAX    INT8_MAX",
            " #define INT_LEAST16_MIN   INT16_MIN",
            " #define INT_LEAST16_MAX   INT16_MAX",
            " #define INT_LEAST32_MIN   INT32_MIN",
            " #define INT_LEAST32_MAX   INT32_MAX",
            " #define INT_LEAST64_MIN   INT64_MIN",
            " #define INT_LEAST64_MAX   INT64_MAX",
            " #define UINT_LEAST8_MAX   UINT8_MAX",
            " #define UINT_LEAST16_MAX  UINT16_MAX",
            " #define UINT_LEAST32_MAX  UINT32_MAX",
            " #define UINT_LEAST64_MAX  UINT64_MAX",
            " ",
            "-// 7.18.2.3 Limits of fastest minimum-width integer types",
            "+/* 7.18.2.3 Limits of fastest minimum-width integer types */",
            " #define INT_FAST8_MIN    INT8_MIN",
            " #define INT_FAST8_MAX    INT8_MAX",
            " #define INT_FAST16_MIN   INT16_MIN",
            " #define INT_FAST16_MAX   INT16_MAX",
            " #define INT_FAST32_MIN   INT32_MIN",
            " #define INT_FAST32_MAX   INT32_MAX",
            " #define INT_FAST64_MIN   INT64_MIN",
            " #define INT_FAST64_MAX   INT64_MAX",
            " #define UINT_FAST8_MAX   UINT8_MAX",
            " #define UINT_FAST16_MAX  UINT16_MAX",
            " #define UINT_FAST32_MAX  UINT32_MAX",
            " #define UINT_FAST64_MAX  UINT64_MAX",
            " ",
            "-// 7.18.2.4 Limits of integer types capable of holding object pointers",
            "-#ifdef _WIN64 // [",
            "+/* 7.18.2.4 Limits of integer types capable of holding object pointers */",
            "+#ifdef _WIN64 /* [ */",
            " #  define INTPTR_MIN   INT64_MIN",
            " #  define INTPTR_MAX   INT64_MAX",
            " #  define UINTPTR_MAX  UINT64_MAX",
            "-#else // _WIN64 ][",
            "+#else /* _WIN64 ][ */",
            " #  define INTPTR_MIN   INT32_MIN",
            " #  define INTPTR_MAX   INT32_MAX",
            " #  define UINTPTR_MAX  UINT32_MAX",
            "-#endif // _WIN64 ]",
            "+#endif /* _WIN64 ] */",
            " ",
            "-// 7.18.2.5 Limits of greatest-width integer types",
            "+/* 7.18.2.5 Limits of greatest-width integer types */",
            " #define INTMAX_MIN   INT64_MIN",
            " #define INTMAX_MAX   INT64_MAX",
            " #define UINTMAX_MAX  UINT64_MAX",
            " ",
            "-// 7.18.3 Limits of other integer types",
            "+/* 7.18.3 Limits of other integer types */",
            " ",
            "-#ifdef _WIN64 // [",
            "+#ifdef _WIN64 /* [ */",
            " #  define PTRDIFF_MIN  _I64_MIN",
            " #  define PTRDIFF_MAX  _I64_MAX",
            "-#else  // _WIN64 ][",
            "+#else  /* _WIN64 ][ */",
            " #  define PTRDIFF_MIN  _I32_MIN",
            " #  define PTRDIFF_MAX  _I32_MAX",
            "-#endif  // _WIN64 ]",
            "+#endif  /* _WIN64 ] */",
            " ",
            " #define SIG_ATOMIC_MIN  INT_MIN",
            " #define SIG_ATOMIC_MAX  INT_MAX",
            " ",
            "-#ifndef SIZE_MAX // [",
            "-#  ifdef _WIN64 // [",
            "+#ifndef SIZE_MAX /* [ */",
            "+#  ifdef _WIN64 /* [ */",
            " #     define SIZE_MAX  _UI64_MAX",
            "-#  else // _WIN64 ][",
            "+#  else /* _WIN64 ][  */",
            " #     define SIZE_MAX  _UI32_MAX",
            "-#  endif // _WIN64 ]",
            "-#endif // SIZE_MAX ]",
            "+#  endif /* _WIN64 ] */",
            "+#endif /* SIZE_MAX ] */",
            " ",
            "-// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>",
            "-#ifndef WCHAR_MIN // [",
            "+/* WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h> */",
            "+#ifndef WCHAR_MIN /* [ */",
            " #  define WCHAR_MIN  0",
            "-#endif  // WCHAR_MIN ]",
            "-#ifndef WCHAR_MAX // [",
            "+#endif  /* WCHAR_MIN ] */",
            "+#ifndef WCHAR_MAX /* [ */",
            " #  define WCHAR_MAX  _UI16_MAX",
            "-#endif  // WCHAR_MAX ]",
            "+#endif  /* WCHAR_MAX ] */",
            " ",
            " #define WINT_MIN  0",
            " #define WINT_MAX  _UI16_MAX",
            " ",
            "-#endif // __STDC_LIMIT_MACROS ]",
            "+#endif /* __STDC_LIMIT_MACROS ] */",
            " ",
            " ",
            "-// 7.18.4 Limits of other integer types",
            "+/* 7.18.4 Limits of other integer types */",
            " ",
            "-#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260",
            "+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) /* [    See footnote 224 at page 260 */",
            " ",
            "-// 7.18.4.1 Macros for minimum-width integer constants",
            "+/* 7.18.4.1 Macros for minimum-width integer constants */",
            " ",
            " #define INT8_C(val)  val##i8",
            " #define INT16_C(val) val##i16",
            " #define INT32_C(val) val##i32",
            " #define INT64_C(val) val##i64",
            " ",
            " #define UINT8_C(val)  val##ui8",
            " #define UINT16_C(val) val##ui16",
            " #define UINT32_C(val) val##ui32",
            " #define UINT64_C(val) val##ui64",
            " ",
            "-// 7.18.4.2 Macros for greatest-width integer constants",
            "+/* 7.18.4.2 Macros for greatest-width integer constants */",
            " #define INTMAX_C   INT64_C",
            " #define UINTMAX_C  UINT64_C",
            " ",
            "-#endif // __STDC_CONSTANT_MACROS ]",
            "+#endif /* __STDC_CONSTANT_MACROS ] */",
            " ",
            " ",
            "-#endif // _MSC_STDINT_H_ ]",
            "+#endif /* _MSC_STDINT_H_ ] */",
            " ",
            "-#endif // _MSC_VER ]",
            "+#endif /* _MSC_VER ] */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/strarray.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/strarray.h",
            "+++ /home/libgit2-1.9.1/include/git2/strarray.h",
            "@@ -7,16 +7,16 @@",
            " #ifndef INCLUDE_git_strarray_h__",
            " #define INCLUDE_git_strarray_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " /**",
            "  * @file git2/strarray.h",
            "- * @brief Git string array routines",
            "- * @defgroup git_strarray Git string array routines",
            "+ * @brief An array of strings for the user to free",
            "+ * @defgroup git_strarray An array of strings for the user to free",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** Array of strings */",
            " typedef struct git_strarray {",
            "@@ -36,8 +36,7 @@",
            "  */",
            " GIT_EXTERN(void) git_strarray_dispose(git_strarray *array);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            " ",
            " #endif",
            "-"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/submodule.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/submodule.h",
            "+++ /home/libgit2-1.9.1/include/git2/submodule.h",
            "@@ -11,15 +11,15 @@",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"remote.h\"",
            " #include \"checkout.h\"",
            " ",
            " /**",
            "  * @file git2/submodule.h",
            "- * @brief Git submodule management utilities",
            "+ * @brief Submodules place another repository's contents within this one",
            "  *",
            "  * Submodule support in libgit2 builds a list of known submodules and keeps",
            "  * it in the repository.  The list is built from the .gitmodules file, the",
            "  * .git/config file, the index, and the HEAD tree.  Items in the working",
            "  * directory that look like submodules (i.e. a git repo) but are not",
            "  * mentioned in those places won't be tracked.",
            "  *",
            "@@ -84,28 +84,35 @@",
            " \tGIT_SUBMODULE_STATUS_WD_DELETED        = (1u << 9),",
            " \tGIT_SUBMODULE_STATUS_WD_MODIFIED       = (1u << 10),",
            " \tGIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = (1u << 11),",
            " \tGIT_SUBMODULE_STATUS_WD_WD_MODIFIED    = (1u << 12),",
            " \tGIT_SUBMODULE_STATUS_WD_UNTRACKED      = (1u << 13)",
            " } git_submodule_status_t;",
            " ",
            "+/** Submodule source bits */",
            " #define GIT_SUBMODULE_STATUS__IN_FLAGS\t\t0x000Fu",
            "+/** Submodule index status */",
            " #define GIT_SUBMODULE_STATUS__INDEX_FLAGS\t0x0070u",
            "+/** Submodule working directory status */",
            " #define GIT_SUBMODULE_STATUS__WD_FLAGS\t\t0x3F80u",
            " ",
            "+/** Whether the submodule is modified */",
            " #define GIT_SUBMODULE_STATUS_IS_UNMODIFIED(S) \\",
            " \t(((S) & ~GIT_SUBMODULE_STATUS__IN_FLAGS) == 0)",
            " ",
            "+/** Whether the submodule is modified (in the index) */",
            " #define GIT_SUBMODULE_STATUS_IS_INDEX_UNMODIFIED(S) \\",
            " \t(((S) & GIT_SUBMODULE_STATUS__INDEX_FLAGS) == 0)",
            " ",
            "+/** Whether the submodule is modified (in the working directory) */",
            " #define GIT_SUBMODULE_STATUS_IS_WD_UNMODIFIED(S) \\",
            " \t(((S) & (GIT_SUBMODULE_STATUS__WD_FLAGS & \\",
            " \t~GIT_SUBMODULE_STATUS_WD_UNINITIALIZED)) == 0)",
            " ",
            "+/** Whether the submodule working directory is dirty */",
            " #define GIT_SUBMODULE_STATUS_IS_WD_DIRTY(S) \\",
            " \t(((S) & (GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED | \\",
            " \tGIT_SUBMODULE_STATUS_WD_WD_MODIFIED | \\",
            " \tGIT_SUBMODULE_STATUS_WD_UNTRACKED)) != 0)",
            " ",
            " /**",
            "  * Function pointer to receive each submodule",
            "@@ -126,18 +133,16 @@",
            "  *",
            "  */",
            " typedef struct git_submodule_update_options {",
            " \tunsigned int version;",
            " ",
            " \t/**",
            " \t * These options are passed to the checkout step. To disable",
            "-\t * checkout, set the `checkout_strategy` to",
            "-\t * `GIT_CHECKOUT_NONE`. Generally you will want the use",
            "-\t * GIT_CHECKOUT_SAFE to update files in the working",
            "-\t * directory.",
            "+\t * checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`",
            "+\t * or `GIT_CHECKOUT_DRY_RUN`.",
            " \t */",
            " \tgit_checkout_options checkout_opts;",
            " ",
            " \t/**",
            " \t * Options which control the fetch, including callbacks.",
            " \t *",
            " \t * The callbacks to use for reporting fetch progress, and for acquiring",
            "@@ -148,19 +153,23 @@",
            " \t/**",
            " \t * Allow fetching from the submodule's default remote if the target",
            " \t * commit isn't found. Enabled by default.",
            " \t */",
            " \tint allow_fetch;",
            " } git_submodule_update_options;",
            " ",
            "+/** Current version for the `git_submodule_update_options` structure */",
            " #define GIT_SUBMODULE_UPDATE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_submodule_update_options` */",
            " #define GIT_SUBMODULE_UPDATE_OPTIONS_INIT \\",
            " \t{ GIT_SUBMODULE_UPDATE_OPTIONS_VERSION, \\",
            "-\t\t{ GIT_CHECKOUT_OPTIONS_VERSION, GIT_CHECKOUT_SAFE }, \\",
            "-\tGIT_FETCH_OPTIONS_INIT, 1 }",
            "+\t  GIT_CHECKOUT_OPTIONS_INIT, \\",
            "+\t  GIT_FETCH_OPTIONS_INIT, \\",
            "+\t  1 }",
            " ",
            " /**",
            "  * Initialize git_submodule_update_options structure",
            "  *",
            "  * Initializes a `git_submodule_update_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`.",
            "  *",
            "@@ -527,27 +536,28 @@",
            "  *",
            "  * This accesses the submodule.<name>.fetchRecurseSubmodules value for",
            "  * the submodule that controls fetching behavior for the submodule.",
            "  *",
            "  * Note that at this time, libgit2 does not honor this setting and the",
            "  * fetch functionality current ignores submodules.",
            "  *",
            "- * @return 0 if fetchRecurseSubmodules is false, 1 if true",
            "+ * @param submodule the submodule to examine",
            "+ * @return the submodule recursion configuration",
            "  */",
            " GIT_EXTERN(git_submodule_recurse_t) git_submodule_fetch_recurse_submodules(",
            " \tgit_submodule *submodule);",
            " ",
            " /**",
            "  * Set the fetchRecurseSubmodules rule for a submodule in the configuration",
            "  *",
            "  * This setting won't affect any existing instances.",
            "  *",
            "  * @param repo the repository to affect",
            "  * @param name the submodule to configure",
            "- * @param fetch_recurse_submodules Boolean value",
            "+ * @param fetch_recurse_submodules the submodule recursion configuration",
            "  * @return old value for fetchRecurseSubmodules",
            "  */",
            " GIT_EXTERN(int) git_submodule_set_fetch_recurse_submodules(",
            " \tgit_repository *repo,",
            " \tconst char *name,",
            " \tgit_submodule_recurse_t fetch_recurse_submodules);",
            " ",
            "@@ -661,8 +671,9 @@",
            "  */",
            " GIT_EXTERN(int) git_submodule_location(",
            " \tunsigned int *location_status,",
            " \tgit_submodule *submodule);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/alloc.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/alloc.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/alloc.h",
            "@@ -6,14 +6,25 @@",
            "  */",
            " ",
            " #ifndef INCLUDE_sys_git_alloc_h__",
            " #define INCLUDE_sys_git_alloc_h__",
            " ",
            " #include \"git2/common.h\"",
            " ",
            "+/**",
            "+ * @file git2/sys/alloc.h",
            "+ * @brief Custom memory allocators",
            "+ * @defgroup git_merge Git merge routines",
            "+ * @ingroup Git",
            "+ *",
            "+ * Users can configure custom allocators; this is particularly",
            "+ * interesting when running in constrained environments, when calling",
            "+ * from another language, or during testing.",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * An instance for a custom memory allocator",
            "  *",
            "  * Setting the pointers of this structure allows the developer to implement",
            "  * custom memory allocators. The global memory allocator can be set by using",
            "@@ -58,10 +69,11 @@",
            "  * platforms and only if libgit2 is being compiled with \"-DMSVC_CRTDBG\".",
            "  *",
            "  * @param allocator The allocator that is to be initialized.",
            "  * @return An error code or 0.",
            "  */",
            " int git_win32_crtdbg_init_allocator(git_allocator *allocator);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/commit.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/commit.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/commit.h",
            "@@ -10,30 +10,66 @@",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " ",
            " /**",
            "  * @file git2/sys/commit.h",
            "  * @brief Low-level Git commit creation",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @defgroup git_commit Low-level Git commit creation",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Create new commit in the repository from a list of `git_oid` values.",
            "  *",
            "  * See documentation for `git_commit_create()` for information about the",
            "  * parameters, as the meaning is identical excepting that `tree` and",
            "  * `parents` now take `git_oid`.  This is a dangerous API in that nor",
            "  * the `tree`, neither the `parents` list of `git_oid`s are checked for",
            "  * validity.",
            "  *",
            "- * @see git_commit_create",
            "+ * @param id Pointer in which to store the OID of the newly created commit",
            "+ *",
            "+ * @param repo Repository where to store the commit",
            "+ *",
            "+ * @param update_ref If not NULL, name of the reference that",
            "+ *\twill be updated to point to this commit. If the reference",
            "+ *\tis not direct, it will be resolved to a direct reference.",
            "+ *\tUse \"HEAD\" to update the HEAD of the current branch and",
            "+ *\tmake it point to this commit. If the reference doesn't",
            "+ *\texist yet, it will be created. If it does exist, the first",
            "+ *\tparent must be the tip of this branch.",
            "+ *",
            "+ * @param author Signature with author and author time of commit",
            "+ *",
            "+ * @param committer Signature with committer and * commit time of commit",
            "+ *",
            "+ * @param message_encoding The encoding for the message in the",
            "+ *  commit, represented with a standard encoding name.",
            "+ *  E.g. \"UTF-8\". If NULL, no encoding header is written and",
            "+ *  UTF-8 is assumed.",
            "+ *",
            "+ * @param message Full message for this commit",
            "+ *",
            "+ * @param tree An instance of a `git_tree` object that will",
            "+ *  be used as the tree for the commit. This tree object must",
            "+ *  also be owned by the given `repo`.",
            "+ *",
            "+ * @param parent_count Number of parents for this commit",
            "+ *",
            "+ * @param parents Array of `parent_count` pointers to `git_commit`",
            "+ *  objects that will be used as the parents for this commit. This",
            "+ *  array may be NULL if `parent_count` is 0 (root commit). All the",
            "+ *  given commits must be owned by the `repo`.",
            "+ *",
            "+ * @return 0 or an error code",
            "+ *\tThe created commit will be written to the Object Database and",
            "+ *\tthe given reference will be updated to point to it",
            "  */",
            " GIT_EXTERN(int) git_commit_create_from_ids(",
            " \tgit_oid *id,",
            " \tgit_repository *repo,",
            " \tconst char *update_ref,",
            " \tconst git_signature *author,",
            " \tconst git_signature *committer,",
            "@@ -45,27 +81,64 @@",
            " ",
            " /**",
            "  * Callback function to return parents for commit.",
            "  *",
            "  * This is invoked with the count of the number of parents processed so far",
            "  * along with the user supplied payload.  This should return a git_oid of",
            "  * the next parent or NULL if all parents have been provided.",
            "+ *",
            "+ * @param idx the index of the parent",
            "+ * @param payload the user-specified payload",
            "+ * @return the object id of the parent, or NULL if there are no further parents",
            "  */",
            " typedef const git_oid * GIT_CALLBACK(git_commit_parent_callback)(size_t idx, void *payload);",
            " ",
            " /**",
            "  * Create a new commit in the repository with an callback to supply parents.",
            "  *",
            "  * See documentation for `git_commit_create()` for information about the",
            "  * parameters, as the meaning is identical excepting that `tree` takes a",
            "  * `git_oid` and doesn't check for validity, and `parent_cb` is invoked",
            "  * with `parent_payload` and should return `git_oid` values or NULL to",
            "  * indicate that all parents are accounted for.",
            "  *",
            "- * @see git_commit_create",
            "+ * @param id Pointer in which to store the OID of the newly created commit",
            "+ *",
            "+ * @param repo Repository where to store the commit",
            "+ *",
            "+ * @param update_ref If not NULL, name of the reference that",
            "+ *\twill be updated to point to this commit. If the reference",
            "+ *\tis not direct, it will be resolved to a direct reference.",
            "+ *\tUse \"HEAD\" to update the HEAD of the current branch and",
            "+ *\tmake it point to this commit. If the reference doesn't",
            "+ *\texist yet, it will be created. If it does exist, the first",
            "+ *\tparent must be the tip of this branch.",
            "+ *",
            "+ * @param author Signature with author and author time of commit",
            "+ *",
            "+ * @param committer Signature with committer and * commit time of commit",
            "+ *",
            "+ * @param message_encoding The encoding for the message in the",
            "+ *  commit, represented with a standard encoding name.",
            "+ *  E.g. \"UTF-8\". If NULL, no encoding header is written and",
            "+ *  UTF-8 is assumed.",
            "+ *",
            "+ * @param message Full message for this commit",
            "+ *",
            "+ * @param tree An instance of a `git_tree` object that will",
            "+ *  be used as the tree for the commit. This tree object must",
            "+ *  also be owned by the given `repo`.",
            "+ *",
            "+ * @param parent_cb Callback to invoke to obtain parent information",
            "+ *",
            "+ * @param parent_payload User-specified payload to provide to the callback",
            "+ *",
            "+ * @return 0 or an error code",
            "+ *\tThe created commit will be written to the Object Database and",
            "+ *\tthe given reference will be updated to point to it",
            "  */",
            " GIT_EXTERN(int) git_commit_create_from_callback(",
            " \tgit_oid *id,",
            " \tgit_repository *repo,",
            " \tconst char *update_ref,",
            " \tconst git_signature *author,",
            " \tconst git_signature *committer,",
            "@@ -73,8 +146,9 @@",
            " \tconst char *message,",
            " \tconst git_oid *tree,",
            " \tgit_commit_parent_callback parent_cb,",
            " \tvoid *parent_payload);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/commit_graph.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/commit_graph.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/commit_graph.h",
            "@@ -8,119 +8,114 @@",
            " #define INCLUDE_sys_git_commit_graph_h__",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " ",
            " /**",
            "  * @file git2/sys/commit_graph.h",
            "- * @brief Git commit-graph",
            "- * @defgroup git_commit_graph Git commit-graph APIs",
            "+ * @brief Commit graphs store information about commit relationships",
            "+ * @defgroup git_commit_graph Commit graphs",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "+ * Options structure for `git_commit_graph_open_new`.",
            "+ *",
            "+ * Initialize with `GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT`. Alternatively,",
            "+ * you can use `git_commit_graph_open_options_init`.",
            "+ */",
            "+typedef struct {",
            "+\tunsigned int version;",
            "+",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\t/** The object ID type that this commit graph contains. */",
            "+\tgit_oid_t oid_type;",
            "+#endif",
            "+} git_commit_graph_open_options;",
            "+",
            "+/** Current version for the `git_commit_graph_open_options` structure */",
            "+#define GIT_COMMIT_GRAPH_OPEN_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_commit_graph_open_options` */",
            "+#define GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT { \\",
            "+\t\tGIT_COMMIT_GRAPH_OPEN_OPTIONS_VERSION \\",
            "+\t}",
            "+",
            "+/**",
            "+ * Initialize git_commit_graph_open_options structure",
            "+ *",
            "+ * Initializes a `git_commit_graph_open_options` with default values.",
            "+ * Equivalent to creating an instance with",
            "+ * `GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT`.",
            "+ *",
            "+ * @param opts The `git_commit_graph_open_options` struct to initialize.",
            "+ * @param version The struct version; pass `GIT_COMMIT_GRAPH_OPEN_OPTIONS_VERSION`.",
            "+ * @return Zero on success; -1 on failure.",
            "+ */",
            "+GIT_EXTERN(int) git_commit_graph_open_options_init(",
            "+\tgit_commit_graph_open_options *opts,",
            "+\tunsigned int version);",
            "+",
            "+",
            "+/**",
            "  * Opens a `git_commit_graph` from a path to an objects directory.",
            "  *",
            "  * This finds, opens, and validates the `commit-graph` file.",
            "  *",
            "  * @param cgraph_out the `git_commit_graph` struct to initialize.",
            "  * @param objects_dir the path to a git objects directory.",
            "  * @return Zero on success; -1 on failure.",
            "  */",
            " GIT_EXTERN(int) git_commit_graph_open(",
            " \tgit_commit_graph **cgraph_out,",
            " \tconst char *objects_dir",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t, git_oid_t oid_type",
            "+\t, const git_commit_graph_open_options *options",
            " #endif",
            " \t);",
            " ",
            " /**",
            "  * Frees commit-graph data. This should only be called when memory allocated",
            "  * using `git_commit_graph_open` is not returned to libgit2 because it was not",
            "  * associated with the ODB through a successful call to",
            "  * `git_odb_set_commit_graph`.",
            "  *",
            "  * @param cgraph the commit-graph object to free. If NULL, no action is taken.",
            "  */",
            " GIT_EXTERN(void) git_commit_graph_free(git_commit_graph *cgraph);",
            " ",
            "-/**",
            "- * Create a new writer for `commit-graph` files.",
            "- *",
            "- * @param out Location to store the writer pointer.",
            "- * @param objects_info_dir The `objects/info` directory.",
            "- * The `commit-graph` file will be written in this directory.",
            "- * @return 0 or an error code",
            "- */",
            "-GIT_EXTERN(int) git_commit_graph_writer_new(",
            "-\t\tgit_commit_graph_writer **out,",
            "-\t\tconst char *objects_info_dir",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t, git_oid_t oid_type",
            "-#endif",
            "-\t\t);",
            "-",
            "-/**",
            "- * Free the commit-graph writer and its resources.",
            "- *",
            "- * @param w The writer to free. If NULL no action is taken.",
            "- */",
            "-GIT_EXTERN(void) git_commit_graph_writer_free(git_commit_graph_writer *w);",
            "-",
            "-/**",
            "- * Add an `.idx` file (associated to a packfile) to the writer.",
            "- *",
            "- * @param w The writer.",
            "- * @param repo The repository that owns the `.idx` file.",
            "- * @param idx_path The path of an `.idx` file.",
            "- * @return 0 or an error code",
            "- */",
            "-GIT_EXTERN(int) git_commit_graph_writer_add_index_file(",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tgit_repository *repo,",
            "-\t\tconst char *idx_path);",
            "-",
            "-/**",
            "- * Add a revwalk to the writer. This will add all the commits from the revwalk",
            "- * to the commit-graph.",
            "- *",
            "- * @param w The writer.",
            "- * @param walk The git_revwalk.",
            "- * @return 0 or an error code",
            "- */",
            "-GIT_EXTERN(int) git_commit_graph_writer_add_revwalk(",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tgit_revwalk *walk);",
            "-",
            " ",
            " /**",
            "  * The strategy to use when adding a new set of commits to a pre-existing",
            "  * commit-graph chain.",
            "  */",
            " typedef enum {",
            " \t/**",
            " \t * Do not split commit-graph files. The other split strategy-related option",
            " \t * fields are ignored.",
            " \t */",
            " \tGIT_COMMIT_GRAPH_SPLIT_STRATEGY_SINGLE_FILE = 0",
            " } git_commit_graph_split_strategy_t;",
            " ",
            " /**",
            "- * Options structure for",
            "- * `git_commit_graph_writer_commit`/`git_commit_graph_writer_dump`.",
            "+ * Options structure for `git_commit_graph_writer_new`.",
            "  *",
            "- * Initialize with `GIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT`. Alternatively, you",
            "- * can use `git_commit_graph_writer_options_init`.",
            "+ * Initialize with `GIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT`. Alternatively,",
            "+ * you can use `git_commit_graph_writer_options_init`.",
            "  */",
            " typedef struct {",
            " \tunsigned int version;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\t/** The object ID type that this commit graph contains. */",
            "+\tgit_oid_t oid_type;",
            "+#endif",
            "+",
            " \t/**",
            " \t * The strategy to use when adding new commits to a pre-existing commit-graph",
            " \t * chain.",
            " \t */",
            " \tgit_commit_graph_split_strategy_t split_strategy;",
            " ",
            " \t/**",
            "@@ -132,15 +127,18 @@",
            " \t/**",
            " \t * The number of commits in level N + 1 is more than C commits.",
            " \t * Default is 64000.",
            " \t */",
            " \tsize_t max_commits;",
            " } git_commit_graph_writer_options;",
            " ",
            "+/** Current version for the `git_commit_graph_writer_options` structure */",
            " #define GIT_COMMIT_GRAPH_WRITER_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_commit_graph_writer_options` */",
            " #define GIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT { \\",
            " \t\tGIT_COMMIT_GRAPH_WRITER_OPTIONS_VERSION \\",
            " \t}",
            " ",
            " /**",
            "  * Initialize git_commit_graph_writer_options structure",
            "  *",
            "@@ -152,33 +150,76 @@",
            "  * @return Zero on success; -1 on failure.",
            "  */",
            " GIT_EXTERN(int) git_commit_graph_writer_options_init(",
            " \tgit_commit_graph_writer_options *opts,",
            " \tunsigned int version);",
            " ",
            " /**",
            "+ * Create a new writer for `commit-graph` files.",
            "+ *",
            "+ * @param out Location to store the writer pointer.",
            "+ * @param objects_info_dir The `objects/info` directory.",
            "+ * The `commit-graph` file will be written in this directory.",
            "+ * @param options The options for the commit graph writer.",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_commit_graph_writer_new(",
            "+\t\tgit_commit_graph_writer **out,",
            "+\t\tconst char *objects_info_dir,",
            "+\t\tconst git_commit_graph_writer_options *options);",
            "+",
            "+/**",
            "+ * Free the commit-graph writer and its resources.",
            "+ *",
            "+ * @param w The writer to free. If NULL no action is taken.",
            "+ */",
            "+GIT_EXTERN(void) git_commit_graph_writer_free(git_commit_graph_writer *w);",
            "+",
            "+/**",
            "+ * Add an `.idx` file (associated to a packfile) to the writer.",
            "+ *",
            "+ * @param w The writer.",
            "+ * @param repo The repository that owns the `.idx` file.",
            "+ * @param idx_path The path of an `.idx` file.",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_commit_graph_writer_add_index_file(",
            "+\t\tgit_commit_graph_writer *w,",
            "+\t\tgit_repository *repo,",
            "+\t\tconst char *idx_path);",
            "+",
            "+/**",
            "+ * Add a revwalk to the writer. This will add all the commits from the revwalk",
            "+ * to the commit-graph.",
            "+ *",
            "+ * @param w The writer.",
            "+ * @param walk The git_revwalk.",
            "+ * @return 0 or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_commit_graph_writer_add_revwalk(",
            "+\t\tgit_commit_graph_writer *w,",
            "+\t\tgit_revwalk *walk);",
            "+",
            "+/**",
            "  * Write a `commit-graph` file to a file.",
            "  *",
            "  * @param w The writer",
            "- * @param opts Pointer to git_commit_graph_writer_options struct.",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_commit_graph_writer_commit(",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tgit_commit_graph_writer_options *opts);",
            "+\t\tgit_commit_graph_writer *w);",
            " ",
            " /**",
            "  * Dump the contents of the `commit-graph` to an in-memory buffer.",
            "  *",
            "- * @param buffer Buffer where to store the contents of the `commit-graph`.",
            "+ * @param[out] buffer Buffer where to store the contents of the `commit-graph`.",
            "  * @param w The writer.",
            "- * @param opts Pointer to git_commit_graph_writer_options struct.",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_commit_graph_writer_dump(",
            " \t\tgit_buf *buffer,",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tgit_commit_graph_writer_options *opts);",
            "+\t\tgit_commit_graph_writer *w);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/config.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/config.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/config.h",
            "@@ -9,22 +9,37 @@",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/config.h\"",
            " ",
            " /**",
            "  * @file git2/sys/config.h",
            "- * @brief Git config backend routines",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @brief Custom configuration database backends",
            "+ * @defgroup git_backend Custom configuration database backends",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "+ * An entry in a configuration backend. This is provided so that",
            "+ * backend implementors can have a mechanism to free their data.",
            "+ */",
            "+typedef struct git_config_backend_entry {",
            "+\t/** The base configuration entry */",
            "+\tstruct git_config_entry entry;",
            "+",
            "+\t/**",
            "+\t * Free function for this entry; for internal purposes. Callers",
            "+\t * should call `git_config_entry_free` to free data.",
            "+\t */",
            "+\tvoid GIT_CALLBACK(free)(struct git_config_backend_entry *entry);",
            "+} git_config_backend_entry;",
            "+",
            "+/**",
            "  * Every iterator must have this struct as its first element, so the",
            "  * API can talk to it. You'd define your iterator as",
            "  *",
            "  *     struct my_iterator {",
            "  *             git_config_iterator parent;",
            "  *             ...",
            "  *     }",
            "@@ -35,15 +50,15 @@",
            " \tgit_config_backend *backend;",
            " \tunsigned int flags;",
            " ",
            " \t/**",
            " \t * Return the current entry and advance the iterator. The",
            " \t * memory belongs to the library.",
            " \t */",
            "-\tint GIT_CALLBACK(next)(git_config_entry **entry, git_config_iterator *iter);",
            "+\tint GIT_CALLBACK(next)(git_config_backend_entry **entry, git_config_iterator *iter);",
            " ",
            " \t/**",
            " \t * Free the iterator",
            " \t */",
            " \tvoid GIT_CALLBACK(free)(git_config_iterator *iter);",
            " };",
            " ",
            "@@ -55,15 +70,15 @@",
            " \tunsigned int version;",
            " \t/** True if this backend is for a snapshot */",
            " \tint readonly;",
            " \tstruct git_config *cfg;",
            " ",
            " \t/* Open means open the file/database and parse if necessary */",
            " \tint GIT_CALLBACK(open)(struct git_config_backend *, git_config_level_t level, const git_repository *repo);",
            "-\tint GIT_CALLBACK(get)(struct git_config_backend *, const char *key, git_config_entry **entry);",
            "+\tint GIT_CALLBACK(get)(struct git_config_backend *, const char *key, git_config_backend_entry **entry);",
            " \tint GIT_CALLBACK(set)(struct git_config_backend *, const char *key, const char *value);",
            " \tint GIT_CALLBACK(set_multivar)(git_config_backend *cfg, const char *name, const char *regexp, const char *value);",
            " \tint GIT_CALLBACK(del)(struct git_config_backend *, const char *key);",
            " \tint GIT_CALLBACK(del_multivar)(struct git_config_backend *, const char *key, const char *regexp);",
            " \tint GIT_CALLBACK(iterator)(git_config_iterator **, struct git_config_backend *);",
            " \t/** Produce a read-only version of this backend */",
            " \tint GIT_CALLBACK(snapshot)(struct git_config_backend **, struct git_config_backend *);",
            "@@ -79,15 +94,19 @@",
            " \t * Unlock the data store backing this backend. If success is",
            " \t * true, the changes should be committed, otherwise rolled",
            " \t * back.",
            " \t */",
            " \tint GIT_CALLBACK(unlock)(struct git_config_backend *, int success);",
            " \tvoid GIT_CALLBACK(free)(struct git_config_backend *);",
            " };",
            "+",
            "+/** Current version for the `git_config_backend_options` structure */",
            " #define GIT_CONFIG_BACKEND_VERSION 1",
            "+",
            "+/** Static constructor for `git_config_backend_options` */",
            " #define GIT_CONFIG_BACKEND_INIT {GIT_CONFIG_BACKEND_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_config_backend` with default values. Equivalent to",
            "  * creating an instance with GIT_CONFIG_BACKEND_INIT.",
            "  *",
            "  * @param backend the `git_config_backend` struct to initialize.",
            "@@ -138,26 +157,30 @@",
            " \t/**",
            " \t * The path to the origin; if this is NULL then it will be",
            " \t * left unset in the resulting configuration entries.",
            " \t */",
            " \tconst char *origin_path;",
            " } git_config_backend_memory_options;",
            " ",
            "+/** Current version for the `git_config_backend_memory_options` structure */",
            " #define GIT_CONFIG_BACKEND_MEMORY_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_config_backend_memory_options` */",
            " #define GIT_CONFIG_BACKEND_MEMORY_OPTIONS_INIT { GIT_CONFIG_BACKEND_MEMORY_OPTIONS_VERSION }",
            " ",
            " ",
            " /**",
            "  * Create an in-memory configuration backend from a string in standard",
            "  * git configuration file format.",
            "  *",
            "  * @param out the new backend",
            "  * @param cfg the configuration that is to be parsed",
            "  * @param len the length of the string pointed to by `cfg`",
            "  * @param opts the options to initialize this backend with, or NULL",
            "+ * @return 0 on success or an error code",
            "  */",
            " extern int git_config_backend_from_string(",
            " \tgit_config_backend **out,",
            " \tconst char *cfg,",
            " \tsize_t len,",
            " \tgit_config_backend_memory_options *opts);",
            " ",
            "@@ -165,17 +188,19 @@",
            "  * Create an in-memory configuration backend from a list of name/value",
            "  * pairs.",
            "  *",
            "  * @param out the new backend",
            "  * @param values the configuration values to set (in \"key=value\" format)",
            "  * @param len the length of the values array",
            "  * @param opts the options to initialize this backend with, or NULL",
            "+ * @return 0 on success or an error code",
            "  */",
            " extern int git_config_backend_from_values(",
            " \tgit_config_backend **out,",
            " \tconst char **values,",
            " \tsize_t len,",
            " \tgit_config_backend_memory_options *opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/credential.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/credential.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/credential.h",
            "@@ -7,17 +7,17 @@",
            " #ifndef INCLUDE_sys_git_credential_h__",
            " #define INCLUDE_sys_git_credential_h__",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/credential.h\"",
            " ",
            " /**",
            "- * @file git2/sys/cred.h",
            "- * @brief Git credentials low-level implementation",
            "- * @defgroup git_credential Git credentials low-level implementation",
            "+ * @file git2/sys/credential.h",
            "+ * @brief Low-level credentials implementation",
            "+ * @defgroup git_credential Low-level credentials implementation",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * The base structure for all credential types",
            "@@ -81,10 +81,11 @@",
            " \t * Callback used to sign the data.",
            " \t */",
            " \tgit_credential_sign_cb sign_callback;",
            " ",
            " \tvoid *payload;         /**< Payload passed to prompt_callback */",
            " };",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/diff.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/diff.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/diff.h",
            "@@ -11,15 +11,15 @@",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " #include \"git2/diff.h\"",
            " #include \"git2/status.h\"",
            " ",
            " /**",
            "  * @file git2/sys/diff.h",
            "- * @brief Low-level Git diff utilities",
            "+ * @brief Low-level diff utilities",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Diff print callback that writes to a git_buf.",
            "@@ -29,14 +29,20 @@",
            "  * `git_patch_print` APIs.  When using those APIs, you specify a callback",
            "  * to actually handle the diff and/or patch data.",
            "  *",
            "  * Use this callback to easily write that data to a `git_buf` buffer.  You",
            "  * must pass a `git_buf *` value as the payload to the `git_diff_print`",
            "  * and/or `git_patch_print` function.  The data will be appended to the",
            "  * buffer (after any existing content).",
            "+ *",
            "+ * @param delta the delta being processed",
            "+ * @param hunk the hunk being processed",
            "+ * @param line the line being processed",
            "+ * @param payload the payload provided by the diff generator",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_diff_print_callback__to_buf(",
            " \tconst git_diff_delta *delta,",
            " \tconst git_diff_hunk *hunk,",
            " \tconst git_diff_line *line,",
            " \tvoid *payload); /**< payload must be a `git_buf *` */",
            " ",
            "@@ -49,14 +55,20 @@",
            "  * to actually handle the diff and/or patch data.",
            "  *",
            "  * Use this callback to easily write that data to a stdio FILE handle.  You",
            "  * must pass a `FILE *` value (such as `stdout` or `stderr` or the return",
            "  * value from `fopen()`) as the payload to the `git_diff_print`",
            "  * and/or `git_patch_print` function.  If you pass NULL, this will write",
            "  * data to `stdout`.",
            "+ *",
            "+ * @param delta the delta being processed",
            "+ * @param hunk the hunk being processed",
            "+ * @param line the line being processed",
            "+ * @param payload the payload provided by the diff generator",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_diff_print_callback__to_file_handle(",
            " \tconst git_diff_delta *delta,",
            " \tconst git_diff_hunk *hunk,",
            " \tconst git_diff_line *line,",
            " \tvoid *payload); /**< payload must be a `FILE *` */",
            " ",
            "@@ -66,29 +78,37 @@",
            "  */",
            " typedef struct {",
            " \tunsigned int version;",
            " \tsize_t stat_calls; /**< Number of stat() calls performed */",
            " \tsize_t oid_calculations; /**< Number of ID calculations */",
            " } git_diff_perfdata;",
            " ",
            "+/** Current version for the `git_diff_perfdata_options` structure */",
            " #define GIT_DIFF_PERFDATA_VERSION 1",
            "+",
            "+/** Static constructor for `git_diff_perfdata_options` */",
            " #define GIT_DIFF_PERFDATA_INIT {GIT_DIFF_PERFDATA_VERSION,0,0}",
            " ",
            " /**",
            "  * Get performance data for a diff object.",
            "  *",
            "  * @param out Structure to be filled with diff performance data",
            "  * @param diff Diff to read performance data from",
            "  * @return 0 for success, <0 for error",
            "  */",
            " GIT_EXTERN(int) git_diff_get_perfdata(",
            " \tgit_diff_perfdata *out, const git_diff *diff);",
            " ",
            " /**",
            "  * Get performance data for diffs from a git_status_list",
            "+ *",
            "+ * @param out Structure to be filled with diff performance data",
            "+ * @param status Diff to read performance data from",
            "+ * @return 0 for success, <0 for error",
            "  */",
            " GIT_EXTERN(int) git_status_list_get_perfdata(",
            " \tgit_diff_perfdata *out, const git_status_list *status);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/email.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/email.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/email.h",
            "@@ -29,22 +29,24 @@",
            "  * @param patch_idx the patch index",
            "  * @param patch_count the total number of patches that will be included",
            "  * @param commit_id the commit id for this change",
            "  * @param summary the commit message for this change",
            "  * @param body optional text to include above the diffstat",
            "  * @param author the person who authored this commit",
            "  * @param opts email creation options",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_email_create_from_diff(",
            " \tgit_buf *out,",
            " \tgit_diff *diff,",
            " \tsize_t patch_idx,",
            " \tsize_t patch_count,",
            " \tconst git_oid *commit_id,",
            " \tconst char *summary,",
            " \tconst char *body,",
            " \tconst git_signature *author,",
            " \tconst git_email_create_options *opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/errors.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/errors.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/errors.h",
            "@@ -6,14 +6,23 @@",
            "  */",
            " ",
            " #ifndef INCLUDE_sys_git_errors_h__",
            " #define INCLUDE_sys_git_errors_h__",
            " ",
            " #include \"git2/common.h\"",
            " ",
            "+/**",
            "+ * @file git2/sys/errors.h",
            "+ * @brief Advanced error handling",
            "+ * @ingroup Git",
            "+ *",
            "+ * Error handling for advanced consumers; those who use callbacks",
            "+ * or those who create custom databases.",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Clear the last library error that occurred for this thread.",
            "  */",
            " GIT_EXTERN(void) git_error_clear(void);",
            " ",
            "@@ -57,10 +66,11 @@",
            "  * string that is passed in.  This is not a good idea when the error in",
            "  * question is a memory allocation failure.  That circumstance has a",
            "  * special setter function that sets the error string to a known and",
            "  * statically allocated internal value.",
            "  */",
            " GIT_EXTERN(void) git_error_set_oom(void);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/filter.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/filter.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/filter.h",
            "@@ -7,30 +7,33 @@",
            " #ifndef INCLUDE_sys_git_filter_h__",
            " #define INCLUDE_sys_git_filter_h__",
            " ",
            " #include \"git2/filter.h\"",
            " ",
            " /**",
            "  * @file git2/sys/filter.h",
            "- * @brief Git filter backend and plugin routines",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @brief Custom filter backends and plugins",
            "+ * @defgroup git_backend Custom filter backends and plugins",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Look up a filter by name",
            "  *",
            "  * @param name The name of the filter",
            "  * @return Pointer to the filter object or NULL if not found",
            "  */",
            " GIT_EXTERN(git_filter *) git_filter_lookup(const char *name);",
            " ",
            "+/** The \"crlf\" filter */",
            " #define GIT_FILTER_CRLF  \"crlf\"",
            "+",
            "+/** The \"ident\" filter */",
            " #define GIT_FILTER_IDENT \"ident\"",
            " ",
            " /**",
            "  * This is priority that the internal CRLF filter will be registered with",
            "  */",
            " #define GIT_FILTER_CRLF_PRIORITY 0",
            " ",
            "@@ -49,14 +52,20 @@",
            " /**",
            "  * Create a new empty filter list",
            "  *",
            "  * Normally you won't use this because `git_filter_list_load` will create",
            "  * the filter list for you, but you can use this in combination with the",
            "  * `git_filter_lookup` and `git_filter_list_push` functions to assemble",
            "  * your own chains of filters.",
            "+ *",
            "+ * @param out the filter list",
            "+ * @param repo the repository to use for configuration",
            "+ * @param mode the filter mode (direction)",
            "+ * @param options the options",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_filter_list_new(",
            " \tgit_filter_list **out,",
            " \tgit_repository *repo,",
            " \tgit_filter_mode_t mode,",
            " \tuint32_t options);",
            " ",
            "@@ -68,14 +77,19 @@",
            "  * attributes are set, but this does allow more direct manipulation of",
            "  * filter lists when desired.",
            "  *",
            "  * Note that normally the \"check\" function can set up a payload for the",
            "  * filter.  Using this function, you can either pass in a payload if you",
            "  * know the expected payload format, or you can pass NULL.  Some filters",
            "  * may fail with a NULL payload.  Good luck!",
            "+ *",
            "+ * @param fl the filter list",
            "+ * @param filter the filter to push",
            "+ * @param payload the payload for the filter",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_filter_list_push(",
            " \tgit_filter_list *fl, git_filter *filter, void *payload);",
            " ",
            " /**",
            "  * Look up how many filters are in the list",
            "  *",
            "@@ -92,67 +106,90 @@",
            " /**",
            "  * A filter source represents a file/blob to be processed",
            "  */",
            " typedef struct git_filter_source git_filter_source;",
            " ",
            " /**",
            "  * Get the repository that the source data is coming from.",
            "+ *",
            "+ * @param src the filter source",
            "+ * @return the repository for the filter information",
            "  */",
            " GIT_EXTERN(git_repository *) git_filter_source_repo(const git_filter_source *src);",
            " ",
            " /**",
            "  * Get the path that the source data is coming from.",
            "+ *",
            "+ * @param src the filter source",
            "+ * @return the path that is being filtered",
            "  */",
            " GIT_EXTERN(const char *) git_filter_source_path(const git_filter_source *src);",
            " ",
            " /**",
            "  * Get the file mode of the source file",
            "  * If the mode is unknown, this will return 0",
            "+ *",
            "+ * @param src the filter source",
            "+ * @return the file mode for the file being filtered",
            "  */",
            " GIT_EXTERN(uint16_t) git_filter_source_filemode(const git_filter_source *src);",
            " ",
            " /**",
            "  * Get the OID of the source",
            "  * If the OID is unknown (often the case with GIT_FILTER_CLEAN) then",
            "  * this will return NULL.",
            "+ *",
            "+ * @param src the filter source",
            "+ * @return the object id of the file being filtered",
            "  */",
            " GIT_EXTERN(const git_oid *) git_filter_source_id(const git_filter_source *src);",
            " ",
            " /**",
            "  * Get the git_filter_mode_t to be used",
            "+ *",
            "+ * @param src the filter source",
            "+ * @return the mode (direction) of the filter",
            "  */",
            " GIT_EXTERN(git_filter_mode_t) git_filter_source_mode(const git_filter_source *src);",
            " ",
            " /**",
            "  * Get the combination git_filter_flag_t options to be applied",
            "+ *",
            "+ * @param src the filter source",
            "+ * @return the flags of the filter",
            "  */",
            " GIT_EXTERN(uint32_t) git_filter_source_flags(const git_filter_source *src);",
            " ",
            " /**",
            "  * Initialize callback on filter",
            "  *",
            "  * Specified as `filter.initialize`, this is an optional callback invoked",
            "  * before a filter is first used.  It will be called once at most.",
            "  *",
            "  * If non-NULL, the filter's `initialize` callback will be invoked right",
            "  * before the first use of the filter, so you can defer expensive",
            "  * initialization operations (in case libgit2 is being used in a way that",
            "  * doesn't need the filter).",
            "+ *",
            "+ * @param self the filter to initialize",
            "+ * @return 0 on success, negative number on failure",
            "  */",
            " typedef int GIT_CALLBACK(git_filter_init_fn)(git_filter *self);",
            " ",
            " /**",
            "  * Shutdown callback on filter",
            "  *",
            "  * Specified as `filter.shutdown`, this is an optional callback invoked",
            "  * when the filter is unregistered or when libgit2 is shutting down.  It",
            "  * will be called once at most and should release resources as needed.",
            "  * This may be called even if the `initialize` callback was not made.",
            "  *",
            "  * Typically this function will free the `git_filter` object itself.",
            "+ *",
            "+ * @param self the filter to shutdown",
            "  */",
            " typedef void GIT_CALLBACK(git_filter_shutdown_fn)(git_filter *self);",
            " ",
            " /**",
            "  * Callback to decide if a given source needs this filter",
            "  *",
            "  * Specified as `filter.check`, this is an optional callback that checks",
            "@@ -167,14 +204,20 @@",
            "  *",
            "  * The `payload` will be a pointer to a reference payload for the filter.",
            "  * This will start as NULL, but `check` can assign to this pointer for",
            "  * later use by the `stream` callback.  Note that the value should be heap",
            "  * allocated (not stack), so that it doesn't go away before the `stream`",
            "  * callback can use it.  If a filter allocates and assigns a value to the",
            "  * `payload`, it will need a `cleanup` callback to free the payload.",
            "+ *",
            "+ * @param self the filter check",
            "+ * @param payload a data for future filter functions",
            "+ * @param src the filter source",
            "+ * @param attr_values the attribute values",
            "+ * @return 0 on success or a negative value on error",
            "  */",
            " typedef int GIT_CALLBACK(git_filter_check_fn)(",
            " \tgit_filter              *self,",
            " \tvoid                   **payload, /* NULL on entry, may be set */",
            " \tconst git_filter_source *src,",
            " \tconst char             **attr_values);",
            " ",
            "@@ -187,14 +230,20 @@",
            "  * `check`, it can return GIT_PASSTHROUGH to indicate that the filter",
            "  * doesn't want to run.  Other error codes will stop filter processing and",
            "  * return to the caller.",
            "  *",
            "  * The `payload` value will refer to any payload that was set by the",
            "  * `check` callback.  It may be read from or written to as needed.",
            "  *",
            "+ * @param self the filter check",
            "+ * @param payload a data for future filter functions",
            "+ * @param to the input buffer",
            "+ * @param from the output buffer",
            "+ * @param src the filter source",
            "+ * @return 0 on success or a negative value on error",
            "  * @deprecated use git_filter_stream_fn",
            "  */",
            " typedef int GIT_CALLBACK(git_filter_apply_fn)(",
            " \tgit_filter              *self,",
            " \tvoid                   **payload, /* may be read and/or set */",
            " \tgit_buf                 *to,",
            " \tconst git_buf           *from,",
            "@@ -205,14 +254,21 @@",
            "  * Callback to perform the data filtering.",
            "  *",
            "  * Specified as `filter.stream`, this is a callback that filters data",
            "  * in a streaming manner.  This function will provide a",
            "  * `git_writestream` that will the original data will be written to;",
            "  * with that data, the `git_writestream` will then perform the filter",
            "  * translation and stream the filtered data out to the `next` location.",
            "+ *",
            "+ * @param out the write stream",
            "+ * @param self the filter",
            "+ * @param payload a data for future filter functions",
            "+ * @param src the filter source",
            "+ * @param next the output stream",
            "+ * @return 0 on success or a negative value on error",
            "  */",
            " typedef int GIT_CALLBACK(git_filter_stream_fn)(",
            " \tgit_writestream        **out,",
            " \tgit_filter              *self,",
            " \tvoid                   **payload,",
            " \tconst git_filter_source *src,",
            " \tgit_writestream         *next);",
            "@@ -221,14 +277,17 @@",
            "  * Callback to clean up after filtering has been applied",
            "  *",
            "  * Specified as `filter.cleanup`, this is an optional callback invoked",
            "  * after the filter has been applied.  If the `check`, `apply`, or",
            "  * `stream` callbacks allocated a `payload` to keep per-source filter",
            "  * state, use this callback to free that payload and release resources",
            "  * as required.",
            "+ *",
            "+ * @param self the filter",
            "+ * @param payload a data for future filter functions",
            "  */",
            " typedef void GIT_CALLBACK(git_filter_cleanup_fn)(",
            " \tgit_filter              *self,",
            " \tvoid                    *payload);",
            " ",
            " /**",
            "  * Filter structure used to register custom filters.",
            "@@ -287,24 +346,27 @@",
            " \t */",
            " \tgit_filter_stream_fn   stream;",
            " ",
            " \t/** Called when the system is done filtering for a file. */",
            " \tgit_filter_cleanup_fn  cleanup;",
            " };",
            " ",
            "+/** Current version for the `git_filter_options` structure */",
            " #define GIT_FILTER_VERSION 1",
            "+",
            "+/** Static constructor for `git_filter_options` */",
            " #define GIT_FILTER_INIT {GIT_FILTER_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_filter` with default values. Equivalent to",
            "  * creating an instance with GIT_FILTER_INIT.",
            "  *",
            "  * @param filter the `git_filter` struct to initialize.",
            "  * @param version Version the struct; pass `GIT_FILTER_VERSION`",
            "- * @return Zero on success; -1 on failure.",
            "+ * @return 0 on success; -1 on failure.",
            "  */",
            " GIT_EXTERN(int) git_filter_init(git_filter *filter, unsigned int version);",
            " ",
            " /**",
            "  * Register a filter under a given name with a given priority.",
            "  *",
            "  * As mentioned elsewhere, the initialize callback will not be invoked",
            "@@ -346,8 +408,9 @@",
            "  * @param name The name under which the filter was registered",
            "  * @return 0 on success, error code <0 on failure",
            "  */",
            " GIT_EXTERN(int) git_filter_unregister(const char *name);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/hashsig.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/hashsig.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/hashsig.h",
            "@@ -5,14 +5,24 @@",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_sys_hashsig_h__",
            " #define INCLUDE_sys_hashsig_h__",
            " ",
            " #include \"git2/common.h\"",
            " ",
            "+/**",
            "+ * @file git2/sys/hashsig.h",
            "+ * @brief Signatures for file similarity comparison",
            "+ * @defgroup git_hashsig Git merge routines",
            "+ * @ingroup Git",
            "+ *",
            "+ * Hash signatures are used for file similary comparison; this is",
            "+ * used for git's rename handling.",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Similarity signature of arbitrary text content based on line hashes",
            "  */",
            " typedef struct git_hashsig git_hashsig;",
            " ",
            "@@ -97,10 +107,11 @@",
            "  * @param b The second similarity signature to compare.",
            "  * @return [0 to 100] on success as the similarity score, or error code.",
            "  */",
            " GIT_EXTERN(int) git_hashsig_compare(",
            " \tconst git_hashsig *a,",
            " \tconst git_hashsig *b);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/index.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/index.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/index.h",
            "@@ -8,16 +8,16 @@",
            " #define INCLUDE_sys_git_index_h__",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " ",
            " /**",
            "  * @file git2/sys/index.h",
            "- * @brief Low-level Git index manipulation routines",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @brief Low-level index manipulation routines",
            "+ * @defgroup git_index Low-level index manipulation routines",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /** Representation of a rename conflict entry in the index. */",
            " typedef struct git_index_name_entry {",
            "@@ -63,14 +63,15 @@",
            " /**",
            "  * Record the filenames involved in a rename conflict.",
            "  *",
            "  * @param index an existing index object",
            "  * @param ancestor the path of the file as it existed in the ancestor",
            "  * @param ours the path of the file as it existed in our tree",
            "  * @param theirs the path of the file as it existed in their tree",
            "+ * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_index_name_add(git_index *index,",
            " \tconst char *ancestor, const char *ours, const char *theirs);",
            " ",
            " /**",
            "  * Remove all filename conflict entries.",
            "  *"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/mempack.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/mempack.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/mempack.h",
            "@@ -11,16 +11,16 @@",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " #include \"git2/odb.h\"",
            " #include \"git2/buffer.h\"",
            " ",
            " /**",
            "  * @file git2/sys/mempack.h",
            "- * @brief Custom ODB backend that permits packing objects in-memory",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @brief A custom object database backend for storing objects in-memory",
            "+ * @defgroup git_mempack A custom object database backend for storing objects in-memory",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Instantiate a new mempack backend.",
            "@@ -41,14 +41,34 @@",
            "  *",
            "  * @param out Pointer where to store the ODB backend",
            "  * @return 0 on success; error code otherwise",
            "  */",
            " GIT_EXTERN(int) git_mempack_new(git_odb_backend **out);",
            " ",
            " /**",
            "+ * Write a thin packfile with the objects in the memory store.",
            "+ *",
            "+ * A thin packfile is a packfile that does not contain its transitive closure of",
            "+ * references. This is useful for efficiently distributing additions to a",
            "+ * repository over the network, but also finds use in the efficient bulk",
            "+ * addition of objects to a repository, locally.",
            "+ *",
            "+ * This operation performs the (shallow) insert operations into the",
            "+ * `git_packbuilder`, but does not write the packfile to disk;",
            "+ * see `git_packbuilder_write_buf`.",
            "+ *",
            "+ * It also does not reset the in-memory object database; see `git_mempack_reset`.",
            "+ *",
            "+ * @param backend The mempack backend",
            "+ * @param pb The packbuilder to use to write the packfile",
            "+ * @return 0 on success or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_mempack_write_thin_pack(git_odb_backend *backend, git_packbuilder *pb);",
            "+",
            "+/**",
            "  * Dump all the queued in-memory writes to a packfile.",
            "  *",
            "  * The contents of the packfile will be stored in the given buffer.",
            "  * It is the caller's responsibility to ensure that the generated",
            "  * packfile is available to the repository (e.g. by writing it",
            "  * to disk, or doing something crazy like distributing it across",
            "  * several copies of the repository over a network).",
            "@@ -78,10 +98,20 @@",
            "  * semantics to the Git repository.",
            "  *",
            "  * @param backend The mempack backend",
            "  * @return 0 on success; error code otherwise",
            "  */",
            " GIT_EXTERN(int) git_mempack_reset(git_odb_backend *backend);",
            " ",
            "+/**",
            "+ * Get the total number of objects in mempack",
            "+ *",
            "+ * @param count The count of objects in the mempack",
            "+ * @param backend The mempack backend",
            "+ * @return 0 on success, or -1 on error",
            "+ */",
            "+GIT_EXTERN(int) git_mempack_object_count(size_t *count, git_odb_backend *backend);",
            "+",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/merge.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/merge.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/merge.h",
            "@@ -10,57 +10,90 @@",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/index.h\"",
            " #include \"git2/merge.h\"",
            " ",
            " /**",
            "  * @file git2/sys/merge.h",
            "- * @brief Git merge driver backend and plugin routines",
            "- * @defgroup git_merge Git merge driver APIs",
            "+ * @brief Custom merge drivers",
            "+ * @defgroup git_merge Custom merge drivers",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            "+/**",
            "+ * A \"merge driver\" is a mechanism that can be configured to handle",
            "+ * conflict resolution for files changed in both the \"ours\" and \"theirs\"",
            "+ * side of a merge.",
            "+ */",
            " typedef struct git_merge_driver git_merge_driver;",
            " ",
            " /**",
            "  * Look up a merge driver by name",
            "  *",
            "  * @param name The name of the merge driver",
            "  * @return Pointer to the merge driver object or NULL if not found",
            "  */",
            " GIT_EXTERN(git_merge_driver *) git_merge_driver_lookup(const char *name);",
            " ",
            "+/** The \"text\" merge driver */",
            " #define GIT_MERGE_DRIVER_TEXT   \"text\"",
            "+/** The \"binary\" merge driver */",
            " #define GIT_MERGE_DRIVER_BINARY \"binary\"",
            "+/** The \"union\" merge driver */",
            " #define GIT_MERGE_DRIVER_UNION  \"union\"",
            " ",
            " /**",
            "  * A merge driver source represents the file to be merged",
            "  */",
            " typedef struct git_merge_driver_source git_merge_driver_source;",
            " ",
            "-/** Get the repository that the source data is coming from. */",
            "+/**",
            "+ * Get the repository that the source data is coming from.",
            "+ *",
            "+ * @param src the merge driver source",
            "+ * @return the repository",
            "+ */",
            " GIT_EXTERN(git_repository *) git_merge_driver_source_repo(",
            " \tconst git_merge_driver_source *src);",
            " ",
            "-/** Gets the ancestor of the file to merge. */",
            "+/**",
            "+ * Gets the ancestor of the file to merge.",
            "+ *",
            "+ * @param src the merge driver source",
            "+ * @return the ancestor or NULL if there was no ancestor",
            "+ */",
            " GIT_EXTERN(const git_index_entry *) git_merge_driver_source_ancestor(",
            " \tconst git_merge_driver_source *src);",
            " ",
            "-/** Gets the ours side of the file to merge. */",
            "+/**",
            "+ * Gets the ours side of the file to merge.",
            "+ *",
            "+ * @param src the merge driver source",
            "+ * @return the ours side or NULL if there was no ours side",
            "+ */",
            " GIT_EXTERN(const git_index_entry *) git_merge_driver_source_ours(",
            " \tconst git_merge_driver_source *src);",
            " ",
            "-/** Gets the theirs side of the file to merge. */",
            "+/**",
            "+ * Gets the theirs side of the file to merge.",
            "+ *",
            "+ * @param src the merge driver source",
            "+ * @return the theirs side or NULL if there was no theirs side",
            "+ */",
            " GIT_EXTERN(const git_index_entry *) git_merge_driver_source_theirs(",
            " \tconst git_merge_driver_source *src);",
            " ",
            "-/** Gets the merge file options that the merge was invoked with */",
            "+/**",
            "+ * Gets the merge file options that the merge was invoked with.",
            "+ *",
            "+ * @param src the merge driver source",
            "+ * @return the options",
            "+ */",
            " GIT_EXTERN(const git_merge_file_options *) git_merge_driver_source_file_options(",
            " \tconst git_merge_driver_source *src);",
            " ",
            " ",
            " /**",
            "  * Initialize callback on merge driver",
            "  *",
            "@@ -68,26 +101,31 @@",
            "  * before a merge driver is first used.  It will be called once at most",
            "  * per library lifetime.",
            "  *",
            "  * If non-NULL, the merge driver's `initialize` callback will be invoked",
            "  * right before the first use of the driver, so you can defer expensive",
            "  * initialization operations (in case libgit2 is being used in a way that",
            "  * doesn't need the merge driver).",
            "+ *",
            "+ * @param self the merge driver to initialize",
            "+ * @return 0 on success, or a negative number on failure",
            "  */",
            " typedef int GIT_CALLBACK(git_merge_driver_init_fn)(git_merge_driver *self);",
            " ",
            " /**",
            "  * Shutdown callback on merge driver",
            "  *",
            "  * Specified as `driver.shutdown`, this is an optional callback invoked",
            "  * when the merge driver is unregistered or when libgit2 is shutting down.",
            "  * It will be called once at most and should release resources as needed.",
            "  * This may be called even if the `initialize` callback was not made.",
            "  *",
            "  * Typically this function will free the `git_merge_driver` object itself.",
            "+ *",
            "+ * @param self the merge driver to shutdown",
            "  */",
            " typedef void GIT_CALLBACK(git_merge_driver_shutdown_fn)(git_merge_driver *self);",
            " ",
            " /**",
            "  * Callback to perform the merge.",
            "  *",
            "  * Specified as `driver.apply`, this is the callback that actually does the",
            "@@ -100,14 +138,22 @@",
            "  * and the file will remain conflicted.  Any other errors will fail and",
            "  * return to the caller.",
            "  *",
            "  * The `filter_name` contains the name of the filter that was invoked, as",
            "  * specified by the file's attributes.",
            "  *",
            "  * The `src` contains the data about the file to be merged.",
            "+ *",
            "+ * @param self the merge driver",
            "+ * @param path_out the resolved path",
            "+ * @param mode_out the resolved mode",
            "+ * @param merged_out the merged output contents",
            "+ * @param filter_name the filter that was invoked",
            "+ * @param src the data about the unmerged file",
            "+ * @return 0 on success, or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_merge_driver_apply_fn)(",
            " \tgit_merge_driver *self,",
            " \tconst char **path_out,",
            " \tuint32_t *mode_out,",
            " \tgit_buf *merged_out,",
            " \tconst char *filter_name,",
            "@@ -135,14 +181,15 @@",
            " \t * returns `GIT_PASSTHROUGH` then the default (`text`) merge driver",
            " \t * will instead be invoked.  If this function returns",
            " \t * `GIT_EMERGECONFLICT` then the file will remain conflicted.",
            " \t */",
            " \tgit_merge_driver_apply_fn    apply;",
            " };",
            " ",
            "+/** The version for the `git_merge_driver` */",
            " #define GIT_MERGE_DRIVER_VERSION 1",
            " ",
            " /**",
            "  * Register a merge driver under a given name.",
            "  *",
            "  * As mentioned elsewhere, the initialize callback will not be invoked",
            "  * immediately.  It is deferred until the driver is used in some way.",
            "@@ -175,8 +222,9 @@",
            "  * @param name The name under which the merge driver was registered",
            "  * @return 0 on success, error code <0 on failure",
            "  */",
            " GIT_EXTERN(int) git_merge_driver_unregister(const char *name);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/midx.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/midx.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/midx.h",
            "@@ -7,35 +7,73 @@",
            " #ifndef INCLUDE_sys_git_midx_h__",
            " #define INCLUDE_sys_git_midx_h__",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " ",
            " /**",
            "- * @file git2/midx.h",
            "- * @brief Git multi-pack-index routines",
            "- * @defgroup git_midx Git multi-pack-index routines",
            "+ * @file git2/sys/midx.h",
            "+ * @brief Incremental multi-pack indexes",
            "+ * @defgroup git_midx Incremental multi-pack indexes",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "+ * Options structure for `git_midx_writer_options`.",
            "+ *",
            "+ * Initialize with `GIT_MIDX_WRITER_OPTIONS_INIT`. Alternatively,",
            "+ * you can use `git_midx_writer_options_init`.",
            "+ */",
            "+typedef struct {",
            "+\tunsigned int version;",
            "+",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\t/** The object ID type that this commit graph contains. */",
            "+\tgit_oid_t oid_type;",
            "+#endif",
            "+} git_midx_writer_options;",
            "+",
            "+/** Current version for the `git_midx_writer_options` structure */",
            "+#define GIT_MIDX_WRITER_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_midx_writer_options` */",
            "+#define GIT_MIDX_WRITER_OPTIONS_INIT { \\",
            "+\t\tGIT_MIDX_WRITER_OPTIONS_VERSION \\",
            "+\t}",
            "+",
            "+/**",
            "+ * Initialize git_midx_writer_options structure",
            "+ *",
            "+ * Initializes a `git_midx_writer_options` with default values.",
            "+ * Equivalent to creating an instance with",
            "+ * `GIT_MIDX_WRITER_OPTIONS_INIT`.",
            "+ *",
            "+ * @param opts The `git_midx_writer_options` struct to initialize.",
            "+ * @param version The struct version; pass `GIT_MIDX_WRITER_OPTIONS_VERSION`.",
            "+ * @return Zero on success; -1 on failure.",
            "+ */",
            "+GIT_EXTERN(int) git_midx_writer_options_init(",
            "+\tgit_midx_writer_options *opts,",
            "+\tunsigned int version);",
            "+",
            "+/**",
            "  * Create a new writer for `multi-pack-index` files.",
            "  *",
            "  * @param out location to store the writer pointer.",
            "  * @param pack_dir the directory where the `.pack` and `.idx` files are. The",
            "  * `multi-pack-index` file will be written in this directory, too.",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_midx_writer_new(",
            " \t\tgit_midx_writer **out,",
            " \t\tconst char *pack_dir",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t\t, git_oid_t oid_type",
            "+\t\t, git_midx_writer_options *options",
            " #endif",
            " \t\t);",
            " ",
            " /**",
            "  * Free the multi-pack-index writer and its resources.",
            "  *",
            "  * @param w the writer to free. If NULL no action is taken.",
            "@@ -71,8 +109,9 @@",
            "  */",
            " GIT_EXTERN(int) git_midx_writer_dump(",
            " \t\tgit_buf *midx,",
            " \t\tgit_midx_writer *w);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/odb_backend.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/odb_backend.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/odb_backend.h",
            "@@ -9,17 +9,17 @@",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " #include \"git2/odb.h\"",
            " ",
            " /**",
            "- * @file git2/sys/backend.h",
            "- * @brief Git custom backend implementors functions",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @file git2/sys/odb_backend.h",
            "+ * @brief Object database backends for custom object storage",
            "+ * @defgroup git_backend Object database backends for custom object storage",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * An instance for a custom backend",
            "@@ -102,15 +102,18 @@",
            " \t/**",
            " \t * Frees any resources held by the odb (including the `git_odb_backend`",
            " \t * itself). An odb backend implementation must provide this function.",
            " \t */",
            " \tvoid GIT_CALLBACK(free)(git_odb_backend *);",
            " };",
            " ",
            "+/** Current version for the `git_odb_backend_options` structure */",
            " #define GIT_ODB_BACKEND_VERSION 1",
            "+",
            "+/** Static constructor for `git_odb_backend_options` */",
            " #define GIT_ODB_BACKEND_INIT {GIT_ODB_BACKEND_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_odb_backend` with default values. Equivalent to",
            "  * creating an instance with GIT_ODB_BACKEND_INIT.",
            "  *",
            "  * @param backend the `git_odb_backend` struct to initialize.",
            "@@ -163,10 +166,11 @@",
            "  * @deprecated git_odb_backend_data_alloc",
            "  * @see git_odb_backend_data_alloc",
            "  */",
            " GIT_EXTERN(void *) git_odb_backend_malloc(git_odb_backend *backend, size_t len);",
            " ",
            " #endif",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/openssl.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/openssl.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/openssl.h",
            "@@ -5,14 +5,20 @@",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_git_openssl_h__",
            " #define INCLUDE_git_openssl_h__",
            " ",
            " #include \"git2/common.h\"",
            " ",
            "+/**",
            "+ * @file git2/sys/openssl.h",
            "+ * @brief Custom OpenSSL functionality",
            "+ * @defgroup git_openssl Custom OpenSSL functionality",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Initialize the OpenSSL locks",
            "  *",
            "  * OpenSSL requires the application to determine how it performs",
            "  * locking.",
            "@@ -29,10 +35,11 @@",
            "  * this function.",
            "  *",
            "  * @return 0 on success, -1 if there are errors or if libgit2 was not",
            "  * built with OpenSSL and threading support.",
            "  */",
            " GIT_EXTERN(int) git_openssl_set_locking(void);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            "-#endif",
            " ",
            "+#endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/path.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/path.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/path.h",
            "@@ -6,14 +6,24 @@",
            "  */",
            " ",
            " #ifndef INCLUDE_sys_git_path_h__",
            " #define INCLUDE_sys_git_path_h__",
            " ",
            " #include \"git2/common.h\"",
            " ",
            "+/**",
            "+ * @file git2/sys/path.h",
            "+ * @brief Custom path handling",
            "+ * @defgroup git_path Custom path handling",
            "+ * @ingroup Git",
            "+ *",
            "+ * Merge will take two commits and attempt to produce a commit that",
            "+ * includes the changes that were made in both branches.",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * The kinds of git-specific files we know about.",
            "  *",
            "  * The order needs to stay the same to not break the `gitfiles`",
            "  * array in path.c",
            "@@ -55,10 +65,11 @@",
            "  * @param gitfile which file to check against",
            "  * @param fs which filesystem-specific checks to use",
            "  * @return 0 in case the file does not match, a positive value if",
            "  *         it does; -1 in case of an error",
            "  */",
            " GIT_EXTERN(int) git_path_is_gitfile(const char *path, size_t pathlen, git_path_gitfile gitfile, git_path_fs fs);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            "-#endif\t/* INCLUDE_sys_git_path */",
            "+#endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/refdb_backend.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/refdb_backend.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/refdb_backend.h",
            "@@ -8,17 +8,17 @@",
            " #define INCLUDE_sys_git_refdb_backend_h__",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " ",
            " /**",
            "- * @file git2/refdb_backend.h",
            "- * @brief Git custom refs backend functions",
            "- * @defgroup git_refdb_backend Git custom refs backend API",
            "+ * @file git2/sys/refdb_backend.h",
            "+ * @brief Custom reference database backends for refs storage",
            "+ * @defgroup git_refdb_backend Custom reference database backends for refs storage",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " ",
            " /**",
            "@@ -61,81 +61,81 @@",
            " \tunsigned int version; /**< The backend API version */",
            " ",
            " \t/**",
            " \t * Queries the refdb backend for the existence of a reference.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg exists The implementation shall set this to `0` if a ref does",
            "+\t * @param exists The implementation shall set this to `0` if a ref does",
            " \t *             not exist, otherwise to `1`.",
            "-\t * @arg ref_name The reference's name that should be checked for",
            "+\t * @param ref_name The reference's name that should be checked for",
            " \t *               existence.",
            " \t * @return `0` on success, a negative error value code.",
            " \t */",
            " \tint GIT_CALLBACK(exists)(",
            " \t\tint *exists,",
            " \t\tgit_refdb_backend *backend,",
            " \t\tconst char *ref_name);",
            " ",
            " \t/**",
            " \t * Queries the refdb backend for a given reference.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg out The implementation shall set this to the allocated",
            "+\t * @param out The implementation shall set this to the allocated",
            " \t *          reference, if it could be found, otherwise to `NULL`.",
            "-\t * @arg ref_name The reference's name that should be checked for",
            "+\t * @param ref_name The reference's name that should be checked for",
            " \t *               existence.",
            " \t * @return `0` on success, `GIT_ENOTFOUND` if the reference does",
            " \t *         exist, otherwise a negative error code.",
            " \t */",
            " \tint GIT_CALLBACK(lookup)(",
            " \t\tgit_reference **out,",
            " \t\tgit_refdb_backend *backend,",
            " \t\tconst char *ref_name);",
            " ",
            " \t/**",
            " \t * Allocate an iterator object for the backend.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg out The implementation shall set this to the allocated",
            "+\t * @param out The implementation shall set this to the allocated",
            " \t *          reference iterator. A custom structure may be used with an",
            " \t *          embedded `git_reference_iterator` structure. Both `next`",
            " \t *          and `next_name` functions of `git_reference_iterator` need",
            " \t *          to be populated.",
            "-\t * @arg glob A pattern to filter references by. If given, the iterator",
            "+\t * @param glob A pattern to filter references by. If given, the iterator",
            " \t *           shall only return references that match the glob when",
            " \t *           passed to `wildmatch`.",
            " \t * @return `0` on success, otherwise a negative error code.",
            " \t */",
            " \tint GIT_CALLBACK(iterator)(",
            " \t\tgit_reference_iterator **iter,",
            " \t\tstruct git_refdb_backend *backend,",
            " \t\tconst char *glob);",
            " ",
            " \t/**",
            " \t * Writes the given reference to the refdb.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg ref The reference to persist. May either be a symbolic or",
            "+\t * @param ref The reference to persist. May either be a symbolic or",
            " \t *          direct reference.",
            "-\t * @arg force Whether to write the reference if a reference with the",
            "+\t * @param force Whether to write the reference if a reference with the",
            " \t *            same name already exists.",
            "-\t * @arg who The person updating the reference. Shall be used to create",
            "+\t * @param who The person updating the reference. Shall be used to create",
            " \t *          a reflog entry.",
            "-\t * @arg message The message detailing what kind of reference update is",
            "+\t * @param message The message detailing what kind of reference update is",
            " \t *              performed. Shall be used to create a reflog entry.",
            "-\t * @arg old If not `NULL` and `force` is not set, then the",
            "+\t * @param old If not `NULL` and `force` is not set, then the",
            " \t *          implementation needs to ensure that the reference is currently at",
            " \t *          the given OID before writing the new value. If both `old`",
            " \t *          and `old_target` are `NULL`, then the reference should not",
            " \t *          exist at the point of writing.",
            "-\t * @arg old_target If not `NULL` and `force` is not set, then the",
            "+\t * @param old_target If not `NULL` and `force` is not set, then the",
            " \t *                 implementation needs to ensure that the symbolic",
            " \t *                 reference is currently at the given target before",
            " \t *                 writing the new value. If both `old` and",
            " \t *                 `old_target` are `NULL`, then the reference should",
            " \t *                 not exist at the point of writing.",
            " \t * @return `0` on success, otherwise a negative error code.",
            " \t */",
            "@@ -145,23 +145,23 @@",
            " \t\t     const git_oid *old, const char *old_target);",
            " ",
            " \t/**",
            " \t * Rename a reference in the refdb.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg out The implementation shall set this to the newly created",
            "+\t * @param out The implementation shall set this to the newly created",
            " \t *          reference or `NULL` on error.",
            "-\t * @arg old_name The current name of the reference that is to be renamed.",
            "-\t * @arg new_name The new name that the old reference shall be renamed to.",
            "-\t * @arg force Whether to write the reference if a reference with the",
            "+\t * @param old_name The current name of the reference that is to be renamed.",
            "+\t * @param new_name The new name that the old reference shall be renamed to.",
            "+\t * @param force Whether to write the reference if a reference with the",
            " \t *            target name already exists.",
            "-\t * @arg who The person updating the reference. Shall be used to create",
            "+\t * @param who The person updating the reference. Shall be used to create",
            " \t *          a reflog entry.",
            "-\t * @arg message The message detailing what kind of reference update is",
            "+\t * @param message The message detailing what kind of reference update is",
            " \t *              performed. Shall be used to create a reflog entry.",
            " \t * @return `0` on success, otherwise a negative error code.",
            " \t */",
            " \tint GIT_CALLBACK(rename)(",
            " \t\tgit_reference **out, git_refdb_backend *backend,",
            " \t\tconst char *old_name, const char *new_name, int force,",
            " \t\tconst git_signature *who, const char *message);",
            "@@ -169,19 +169,19 @@",
            " \t/**",
            " \t * Deletes the given reference from the refdb.",
            " \t *",
            " \t * If it exists, its reflog should be deleted as well.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg ref_name The name of the reference name that shall be deleted.",
            "-\t * @arg old_id If not `NULL` and `force` is not set, then the",
            "+\t * @param ref_name The name of the reference name that shall be deleted.",
            "+\t * @param old_id If not `NULL` and `force` is not set, then the",
            " \t *             implementation needs to ensure that the reference is currently at",
            " \t *             the given OID before writing the new value.",
            "-\t * @arg old_target If not `NULL` and `force` is not set, then the",
            "+\t * @param old_target If not `NULL` and `force` is not set, then the",
            " \t *                 implementation needs to ensure that the symbolic",
            " \t *                 reference is currently at the given target before",
            " \t *                 writing the new value.",
            " \t * @return `0` on success, otherwise a negative error code.",
            " \t */",
            " \tint GIT_CALLBACK(del)(git_refdb_backend *backend, const char *ref_name, const git_oid *old_id, const char *old_target);",
            " ",
            "@@ -239,84 +239,87 @@",
            " \tint GIT_CALLBACK(reflog_read)(git_reflog **out, git_refdb_backend *backend, const char *name);",
            " ",
            " \t/**",
            " \t * Write a reflog to disk.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg reflog The complete reference log for a given reference. Note",
            "+\t * @param reflog The complete reference log for a given reference. Note",
            " \t *             that this may contain entries that have already been",
            " \t *             written to disk.",
            " \t * @return `0` on success, a negative error code otherwise",
            " \t */",
            " \tint GIT_CALLBACK(reflog_write)(git_refdb_backend *backend, git_reflog *reflog);",
            " ",
            " \t/**",
            " \t * Rename a reflog.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg old_name The name of old reference whose reflog shall be renamed from.",
            "-\t * @arg new_name The name of new reference whose reflog shall be renamed to.",
            "+\t * @param old_name The name of old reference whose reflog shall be renamed from.",
            "+\t * @param new_name The name of new reference whose reflog shall be renamed to.",
            " \t * @return `0` on success, a negative error code otherwise",
            " \t */",
            " \tint GIT_CALLBACK(reflog_rename)(git_refdb_backend *_backend, const char *old_name, const char *new_name);",
            " ",
            " \t/**",
            " \t * Remove a reflog.",
            " \t *",
            " \t * A refdb implementation must provide this function.",
            " \t *",
            "-\t * @arg name The name of the reference whose reflog shall be deleted.",
            "+\t * @param name The name of the reference whose reflog shall be deleted.",
            " \t * @return `0` on success, a negative error code otherwise",
            " \t */",
            " \tint GIT_CALLBACK(reflog_delete)(git_refdb_backend *backend, const char *name);",
            " ",
            " \t/**",
            " \t * Lock a reference.",
            " \t *",
            " \t * A refdb implementation may provide this function; if it is not",
            " \t * provided, the transaction API will fail to work.",
            " \t *",
            "-\t * @arg payload_out Opaque parameter that will be passed verbosely to",
            "+\t * @param payload_out Opaque parameter that will be passed verbosely to",
            " \t *                  `unlock`.",
            "-\t * @arg refname Reference that shall be locked.",
            "+\t * @param refname Reference that shall be locked.",
            " \t * @return `0` on success, a negative error code otherwise",
            " \t */",
            " \tint GIT_CALLBACK(lock)(void **payload_out, git_refdb_backend *backend, const char *refname);",
            " ",
            " \t/**",
            " \t * Unlock a reference.",
            " \t *",
            " \t * Only one of target or symbolic_target will be set.",
            " \t * `success` will be true if the reference should be update, false if",
            " \t * the lock must be discarded.",
            " \t *",
            " \t * A refdb implementation must provide this function if a `lock`",
            " \t * implementation is provided.",
            " \t *",
            "-\t * @arg payload The payload returned by `lock`.",
            "-\t * @arg success `1` if a reference should be updated, `2` if",
            "+\t * @param payload The payload returned by `lock`.",
            "+\t * @param success `1` if a reference should be updated, `2` if",
            " \t *              a reference should be deleted, `0` if the lock must be",
            " \t *              discarded.",
            "-\t * @arg update_reflog `1` in case the reflog should be updated, `0`",
            "+\t * @param update_reflog `1` in case the reflog should be updated, `0`",
            " \t *                    otherwise.",
            "-\t * @arg ref The reference which should be unlocked.",
            "-\t * @arg who The person updating the reference. Shall be used to create",
            "+\t * @param ref The reference which should be unlocked.",
            "+\t * @param who The person updating the reference. Shall be used to create",
            " \t *          a reflog entry in case `update_reflog` is set.",
            "-\t * @arg message The message detailing what kind of reference update is",
            "+\t * @param message The message detailing what kind of reference update is",
            " \t *              performed. Shall be used to create a reflog entry in",
            " \t *              case `update_reflog` is set.",
            " \t * @return `0` on success, a negative error code otherwise",
            " \t */",
            " \tint GIT_CALLBACK(unlock)(git_refdb_backend *backend, void *payload, int success, int update_reflog,",
            " \t\t      const git_reference *ref, const git_signature *sig, const char *message);",
            " };",
            " ",
            "+/** Current version for the `git_refdb_backend_options` structure */",
            " #define GIT_REFDB_BACKEND_VERSION 1",
            "+",
            "+/** Static constructor for `git_refdb_backend_options` */",
            " #define GIT_REFDB_BACKEND_INIT {GIT_REFDB_BACKEND_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_refdb_backend` with default values. Equivalent to",
            "  * creating an instance with GIT_REFDB_BACKEND_INIT.",
            "  *",
            "  * @param backend the `git_refdb_backend` struct to initialize",
            "@@ -352,10 +355,11 @@",
            "  * @param backend pointer to a git_refdb_backend instance",
            "  * @return 0 on success; error code otherwise",
            "  */",
            " GIT_EXTERN(int) git_refdb_set_backend(",
            " \tgit_refdb *refdb,",
            " \tgit_refdb_backend *backend);",
            " ",
            "+/** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/refs.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/refs.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/refs.h",
            "@@ -9,16 +9,16 @@",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " ",
            " /**",
            "  * @file git2/sys/refs.h",
            "- * @brief Low-level Git ref creation",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @brief Low-level git reference creation",
            "+ * @defgroup git_backend Low-level git reference creation",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Create a new direct reference from an OID.",
            "@@ -42,8 +42,9 @@",
            "  */",
            " GIT_EXTERN(git_reference *) git_reference__alloc_symbolic(",
            " \tconst char *name,",
            " \tconst char *target);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/remote.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/remote.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/remote.h",
            "@@ -9,15 +9,15 @@",
            " #define INCLUDE_sys_git_remote_h",
            " ",
            " #include \"git2/remote.h\"",
            " ",
            " /**",
            "  * @file git2/sys/remote.h",
            "  * @brief Low-level remote functionality for custom transports",
            "- * @defgroup git_remote Low-level remote functionality",
            "+ * @defgroup git_remote Low-level remote functionality for custom transports",
            "  * @ingroup Git",
            "  * @{",
            " */",
            " ",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "@@ -45,8 +45,9 @@",
            "  * @param opts The `git_remote_connect_options` struct to dispose.",
            "  */",
            " GIT_EXTERN(void) git_remote_connect_options_dispose(",
            " \t\tgit_remote_connect_options *opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/repository.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/repository.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/repository.h",
            "@@ -9,38 +9,90 @@",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/oid.h\"",
            " ",
            " /**",
            "  * @file git2/sys/repository.h",
            "- * @brief Git repository custom implementation routines",
            "- * @defgroup git_backend Git custom backend APIs",
            "+ * @brief Custom repository handling",
            "+ * @defgroup git_repository Custom repository handling",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+",
            "+/**",
            "+ * The options for creating an repository from scratch.",
            "+ *",
            "+ * Initialize with `GIT_REPOSITORY_NEW_OPTIONS_INIT`. Alternatively,",
            "+ * you can use `git_repository_new_options_init`.",
            "+ *",
            "+ * @options[version] GIT_REPOSITORY_NEW_OPTIONS_VERSION",
            "+ * @options[init_macro] GIT_REPOSITORY_NEW_OPTIONS_INIT",
            "+ * @options[init_function] git_repository_new_options_init",
            "+ */",
            "+typedef struct git_repository_new_options {",
            "+\tunsigned int version; /**< The version */",
            "+",
            "+\t/**",
            "+\t * The object ID type for the object IDs that exist in the index.",
            "+\t *",
            "+\t * If this is not specified, this defaults to `GIT_OID_SHA1`.",
            "+\t */",
            "+\tgit_oid_t oid_type;",
            "+} git_repository_new_options;",
            "+",
            "+/** Current version for the `git_repository_new_options` structure */",
            "+#define GIT_REPOSITORY_NEW_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_repository_new_options` */",
            "+#define GIT_REPOSITORY_NEW_OPTIONS_INIT { GIT_REPOSITORY_NEW_OPTIONS_VERSION }",
            "+",
            "+/**",
            "+ * Initialize git_repository_new_options structure",
            "+ *",
            "+ * Initializes a `git_repository_new_options` with default values.",
            "+ * Equivalent to creating an instance with",
            "+ * `GIT_REPOSITORY_NEW_OPTIONS_INIT`.",
            "+ *",
            "+ * @param opts The `git_repository_new_options` struct to initialize.",
            "+ * @param version The struct version; pass `GIT_REPOSITORY_NEW_OPTIONS_VERSION`.",
            "+ * @return Zero on success; -1 on failure.",
            "+ */",
            "+GIT_EXTERN(int) git_repository_new_options_init(",
            "+\tgit_repository_new_options *opts,",
            "+\tunsigned int version);",
            "+",
            "+/**",
            "+ * Create a new repository with no backends.",
            "+ *",
            "+ * @param[out] out The blank repository",
            "+ * @param opts the options for repository creation, or NULL for defaults",
            "+ * @return 0 on success, or an error code",
            "+ */",
            "+GIT_EXTERN(int) git_repository_new(git_repository **out, git_repository_new_options *opts);",
            "+#else",
            "+",
            " /**",
            "  * Create a new repository with neither backends nor config object",
            "  *",
            "  * Note that this is only useful if you wish to associate the repository",
            "  * with a non-filesystem-backed object database and config store.",
            "  *",
            "  * Caveats: since this repository has no physical location, some systems",
            "  * can fail to function properly: locations under $GIT_DIR, $GIT_COMMON_DIR,",
            "  * or $GIT_INFO_DIR are impacted.",
            "  *",
            "- * @param out The blank repository",
            "+ * @param[out] out The blank repository",
            "  * @return 0 on success, or an error code",
            "  */",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-GIT_EXTERN(int) git_repository_new(git_repository **out, git_oid_t oid_type);",
            "-#else",
            " GIT_EXTERN(int) git_repository_new(git_repository **out);",
            "+",
            " #endif",
            " ",
            " /**",
            "  * Reset all the internal state in a repository.",
            "  *",
            "  * This will free all the mapped memory and internal objects",
            "  * of the repository and leave it in a \"blank\" state.",
            "@@ -157,14 +209,15 @@",
            "  * Because the `.gitmodules` file is unstructured, loading submodules is an",
            "  * O(N) operation.  Any operation (such as `git_rebase_init`) that requires",
            "  * accessing all submodules is O(N^2) in the number of submodules, if it",
            "  * has to look each one up individually.  This function loads all submodules",
            "  * and caches them so that subsequent calls to `git_submodule_lookup` are O(1).",
            "  *",
            "  * @param repo the repository whose submodules will be cached.",
            "+ * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_submodule_cache_all(",
            " \tgit_repository *repo);",
            " ",
            " /**",
            "  * Clear the submodule cache.",
            "  *",
            "@@ -172,14 +225,16 @@",
            "  * If there is no cache, do nothing.",
            "  *",
            "  * The cache incorporates data from the repository's configuration, as well",
            "  * as the state of the working tree, the index, and HEAD.  So any time any",
            "  * of these has changed, the cache might become invalid.",
            "  *",
            "  * @param repo the repository whose submodule cache will be cleared",
            "+ * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_repository_submodule_cache_clear(",
            " \tgit_repository *repo);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/stream.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/stream.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/stream.h",
            "@@ -7,16 +7,24 @@",
            " #ifndef INCLUDE_sys_git_stream_h__",
            " #define INCLUDE_sys_git_stream_h__",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/proxy.h\"",
            " ",
            "+/**",
            "+ * @file git2/sys/stream.h",
            "+ * @brief Streaming file I/O functionality",
            "+ * @defgroup git_stream Streaming file I/O functionality",
            "+ * @ingroup Git",
            "+ * @{",
            "+ */",
            " GIT_BEGIN_DECL",
            " ",
            "+/** Current version for the `git_stream` structures */",
            " #define GIT_STREAM_VERSION 1",
            " ",
            " /**",
            "  * Every stream must have this struct as its first element, so the",
            "  * API can talk to it. You'd define your stream as",
            "  *",
            "  *     struct my_stream {",
            "@@ -143,10 +151,11 @@",
            "  */",
            " GIT_EXTERN(int) git_stream_register_tls(git_stream_cb ctor);",
            " ",
            " /**@}*/",
            " ",
            " #endif",
            " ",
            "+/**@}*/",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/sys/transport.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/sys/transport.h",
            "+++ /home/libgit2-1.9.1/include/git2/sys/transport.h",
            "@@ -14,22 +14,28 @@",
            " #include \"git2/remote.h\"",
            " #include \"git2/strarray.h\"",
            " #include \"git2/transport.h\"",
            " #include \"git2/types.h\"",
            " ",
            " /**",
            "  * @file git2/sys/transport.h",
            "- * @brief Git custom transport registration interfaces and functions",
            "- * @defgroup git_transport Git custom transport registration",
            "+ * @brief Custom transport registration interfaces and functions",
            "+ * @defgroup git_transport Custom transport registration",
            "  * @ingroup Git",
            "+ *",
            "+ * Callers can override the default HTTPS or SSH implementation by",
            "+ * specifying a custom transport.",
            "  * @{",
            "  */",
            " ",
            " GIT_BEGIN_DECL",
            " ",
            "+/**",
            "+ * The negotiation state during a fetch smart transport negotiation.",
            "+ */",
            " typedef struct {",
            " \tconst git_remote_head * const *refs;",
            " \tsize_t refs_len;",
            " \tgit_oid *shallow_roots;",
            " \tsize_t shallow_roots_len;",
            " \tint depth;",
            " } git_fetch_negotiation;",
            "@@ -142,15 +148,18 @@",
            " \t */",
            " \tint GIT_CALLBACK(close)(git_transport *transport);",
            " ",
            " \t/** Frees/destructs the git_transport object. */",
            " \tvoid GIT_CALLBACK(free)(git_transport *transport);",
            " };",
            " ",
            "+/** Current version for the `git_transport` structure */",
            " #define GIT_TRANSPORT_VERSION 1",
            "+",
            "+/** Static constructor for `git_transport` */",
            " #define GIT_TRANSPORT_INIT {GIT_TRANSPORT_VERSION}",
            " ",
            " /**",
            "  * Initializes a `git_transport` with default values. Equivalent to",
            "  * creating an instance with GIT_TRANSPORT_INIT.",
            "  *",
            "  * @param opts the `git_transport` struct to initialize",
            "@@ -295,14 +304,15 @@",
            "  * Get a copy of the remote connect options",
            "  *",
            "  * All data is copied and must be freed by the caller by calling",
            "  * `git_remote_connect_options_dispose`.",
            "  *",
            "  * @param out options struct to fill",
            "  * @param transport the transport to extract the data from.",
            "+ * @return 0 on success, or an error code",
            "  */",
            " GIT_EXTERN(int) git_transport_remote_connect_options(",
            " \t\tgit_remote_connect_options *out,",
            " \t\tgit_transport *transport);",
            " ",
            " /*",
            "  *** End of base transport interface ***",
            "@@ -382,15 +392,22 @@",
            " \t */",
            " \tint GIT_CALLBACK(close)(git_smart_subtransport *transport);",
            " ",
            " \t/** Free the subtransport */",
            " \tvoid GIT_CALLBACK(free)(git_smart_subtransport *transport);",
            " };",
            " ",
            "-/** A function which creates a new subtransport for the smart transport */",
            "+/**",
            "+ * A function that creates a new subtransport for the smart transport",
            "+ *",
            "+ * @param out the smart subtransport",
            "+ * @param owner the transport owner",
            "+ * @param param the input parameter",
            "+ * @return 0 on success, or an error code",
            "+ */",
            " typedef int GIT_CALLBACK(git_smart_subtransport_cb)(",
            " \tgit_smart_subtransport **out,",
            " \tgit_transport *owner,",
            " \tvoid *param);",
            " ",
            " /**",
            "  * Definition for a \"subtransport\"",
            "@@ -425,41 +442,45 @@",
            " /**",
            "  * Create an instance of the http subtransport.",
            "  *",
            "  * This subtransport also supports https.",
            "  *",
            "  * @param out The newly created subtransport",
            "  * @param owner The smart transport to own this subtransport",
            "+ * @param param custom parameters for the subtransport",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_smart_subtransport_http(",
            " \tgit_smart_subtransport **out,",
            " \tgit_transport *owner,",
            " \tvoid *param);",
            " ",
            " /**",
            "  * Create an instance of the git subtransport.",
            "  *",
            "  * @param out The newly created subtransport",
            "  * @param owner The smart transport to own this subtransport",
            "+ * @param param custom parameters for the subtransport",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_smart_subtransport_git(",
            " \tgit_smart_subtransport **out,",
            " \tgit_transport *owner,",
            " \tvoid *param);",
            " ",
            " /**",
            "  * Create an instance of the ssh subtransport.",
            "  *",
            "  * @param out The newly created subtransport",
            "  * @param owner The smart transport to own this subtransport",
            "+ * @param param custom parameters for the subtransport",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_smart_subtransport_ssh(",
            " \tgit_smart_subtransport **out,",
            " \tgit_transport *owner,",
            " \tvoid *param);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/tag.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/tag.h",
            "+++ /home/libgit2-1.9.1/include/git2/tag.h",
            "@@ -11,15 +11,15 @@",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"object.h\"",
            " #include \"strarray.h\"",
            " ",
            " /**",
            "  * @file git2/tag.h",
            "- * @brief Git tag parsing routines",
            "+ * @brief A (nearly) immutable pointer to a commit; useful for versioning",
            "  * @defgroup git_tag Git tag management",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "@@ -331,14 +331,15 @@",
            " ",
            " /**",
            "  * Call callback `cb' for each tag in the repository",
            "  *",
            "  * @param repo Repository",
            "  * @param callback Callback function",
            "  * @param payload Pointer to callback data (optional)",
            "+ * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_tag_foreach(",
            " \tgit_repository *repo,",
            " \tgit_tag_foreach_cb callback,",
            " \tvoid *payload);",
            " ",
            " ",
            "@@ -376,8 +377,9 @@",
            "  * @param name a tag name to test",
            "  * @return 0 on success or an error code",
            "  */",
            " GIT_EXTERN(int) git_tag_name_is_valid(int *valid, const char *name);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/trace.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/trace.h",
            "+++ /home/libgit2-1.9.1/include/git2/trace.h",
            "@@ -8,16 +8,16 @@",
            " #define INCLUDE_git_trace_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/trace.h",
            "- * @brief Git tracing configuration routines",
            "- * @defgroup git_trace Git tracing configuration routines",
            "+ * @brief Tracing functionality to introspect libgit2 in your application",
            "+ * @defgroup git_trace Tracing functionality to introspect libgit2 in your application",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Available tracing levels.  When tracing is set to a particular level,",
            "@@ -44,24 +44,30 @@",
            " ",
            " \t/** Exceptionally detailed debugging data */",
            " \tGIT_TRACE_TRACE = 6",
            " } git_trace_level_t;",
            " ",
            " /**",
            "  * An instance for a tracing function",
            "+ *",
            "+ * @param level the trace level",
            "+ * @param msg the trace message",
            "  */",
            "-typedef void GIT_CALLBACK(git_trace_cb)(git_trace_level_t level, const char *msg);",
            "+typedef void GIT_CALLBACK(git_trace_cb)(",
            "+\tgit_trace_level_t level,",
            "+\tconst char *msg);",
            " ",
            " /**",
            "  * Sets the system tracing configuration to the specified level with the",
            "  * specified callback.  When system events occur at a level equal to, or",
            "  * lower than, the given level they will be reported to the given callback.",
            "  *",
            "  * @param level Level to set tracing to",
            "  * @param cb Function to call with trace data",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_trace_set(git_trace_level_t level, git_trace_cb cb);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/transaction.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/transaction.h",
            "+++ /home/libgit2-1.9.1/include/git2/transaction.h",
            "@@ -8,16 +8,16 @@",
            " #define INCLUDE_git_transaction_h__",
            " ",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " ",
            " /**",
            "  * @file git2/transaction.h",
            "- * @brief Git transactional reference routines",
            "- * @defgroup git_transaction Git transactional reference routines",
            "+ * @brief Transactional reference handling",
            "+ * @defgroup git_transaction Transactional reference handling",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Create a new transaction object",
            "@@ -114,8 +114,9 @@",
            "  *",
            "  * @param tx the transaction",
            "  */",
            " GIT_EXTERN(void) git_transaction_free(git_transaction *tx);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/transport.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/transport.h",
            "+++ /home/libgit2-1.9.1/include/git2/transport.h",
            "@@ -11,32 +11,40 @@",
            " #include \"net.h\"",
            " #include \"types.h\"",
            " #include \"cert.h\"",
            " #include \"credential.h\"",
            " ",
            " /**",
            "  * @file git2/transport.h",
            "- * @brief Git transport interfaces and functions",
            "- * @defgroup git_transport interfaces and functions",
            "+ * @brief Transports are the low-level mechanism to connect to a remote server",
            "+ * @defgroup git_transport Transports are the low-level mechanism to connect to a remote server",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Callback for messages received by the transport.",
            "  *",
            "  * Return a negative value to cancel the network operation.",
            "  *",
            "  * @param str The message from the transport",
            "  * @param len The length of the message",
            "  * @param payload Payload provided by the caller",
            "+ * @return 0 on success or an error code",
            "  */",
            " typedef int GIT_CALLBACK(git_transport_message_cb)(const char *str, int len, void *payload);",
            " ",
            "-/** Signature of a function which creates a transport */",
            "+/**",
            "+ * Signature of a function which creates a transport.",
            "+ *",
            "+ * @param out the transport generate",
            "+ * @param owner the owner for the transport",
            "+ * @param param the param to the transport creation",
            "+ * @return 0 on success or an error code",
            "+ */",
            " typedef int GIT_CALLBACK(git_transport_cb)(git_transport **out, git_remote *owner, void *param);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/tree.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/tree.h",
            "+++ /home/libgit2-1.9.1/include/git2/tree.h",
            "@@ -10,25 +10,25 @@",
            " #include \"common.h\"",
            " #include \"types.h\"",
            " #include \"oid.h\"",
            " #include \"object.h\"",
            " ",
            " /**",
            "  * @file git2/tree.h",
            "- * @brief Git tree parsing, loading routines",
            "- * @defgroup git_tree Git tree parsing, loading routines",
            "+ * @brief Trees are collections of files and folders to make up the repository hierarchy",
            "+ * @defgroup git_tree Trees are collections of files and folders to make up the repository hierarchy",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * Lookup a tree object from the repository.",
            "  *",
            "- * @param out Pointer to the looked up tree",
            "+ * @param[out] out Pointer to the looked up tree",
            "  * @param repo The repo to use when locating the tree.",
            "  * @param id Identity of the tree to locate.",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_tree_lookup(",
            " \tgit_tree **out, git_repository *repo, const git_oid *id);",
            " ",
            "@@ -341,14 +341,18 @@",
            " ",
            " /**",
            "  * Callback for git_treebuilder_filter",
            "  *",
            "  * The return value is treated as a boolean, with zero indicating that the",
            "  * entry should be left alone and any non-zero value meaning that the",
            "  * entry should be removed from the treebuilder list (i.e. filtered out).",
            "+ *",
            "+ * @param entry the tree entry for the callback to examine",
            "+ * @param payload the payload from the caller",
            "+ * @return 0 to do nothing, non-zero to remove the entry",
            "  */",
            " typedef int GIT_CALLBACK(git_treebuilder_filter_cb)(",
            " \tconst git_tree_entry *entry, void *payload);",
            " ",
            " /**",
            "  * Selectively remove entries in the tree",
            "  *",
            "@@ -375,15 +379,22 @@",
            "  * @param id Pointer to store the OID of the newly written tree",
            "  * @param bld Tree builder to write",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_treebuilder_write(",
            " \tgit_oid *id, git_treebuilder *bld);",
            " ",
            "-/** Callback for the tree traversal method */",
            "+/**",
            "+ * Callback for the tree traversal method.",
            "+ *",
            "+ * @param root the current (relative) root to the entry",
            "+ * @param entry the tree entry",
            "+ * @param payload the caller-provided callback payload",
            "+ * @return a positive value to skip the entry, a negative value to stop the walk",
            "+ */",
            " typedef int GIT_CALLBACK(git_treewalk_cb)(",
            " \tconst char *root, const git_tree_entry *entry, void *payload);",
            " ",
            " /** Tree traversal modes */",
            " typedef enum {",
            " \tGIT_TREEWALK_PRE = 0, /* Pre-order */",
            " \tGIT_TREEWALK_POST = 1 /* Post-order */",
            "@@ -466,10 +477,10 @@",
            "  * @param nupdates the number of elements in the update list",
            "  * @param updates the list of updates to perform",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_tree_create_updated(git_oid *out, git_repository *repo, git_tree *baseline, size_t nupdates, const git_tree_update *updates);",
            " ",
            " /** @} */",
            "-",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/types.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/types.h",
            "+++ /home/libgit2-1.9.1/include/git2/types.h",
            "@@ -77,21 +77,26 @@",
            " \tGIT_OBJECT_TREE =      2, /**< A tree (directory listing) object. */",
            " \tGIT_OBJECT_BLOB =      3, /**< A file revision object. */",
            " \tGIT_OBJECT_TAG =       4, /**< An annotated tag object. */",
            " \tGIT_OBJECT_OFS_DELTA = 6, /**< A delta, base is given by an offset. */",
            " \tGIT_OBJECT_REF_DELTA = 7  /**< A delta, base is given by object id. */",
            " } git_object_t;",
            " ",
            "-/** An open object database handle. */",
            "+/**",
            "+ * An object database stores the objects (commit, trees, blobs, tags,",
            "+ * etc) for a repository.",
            "+ */",
            " typedef struct git_odb git_odb;",
            " ",
            " /** A custom backend in an ODB */",
            " typedef struct git_odb_backend git_odb_backend;",
            " ",
            "-/** An object read from the ODB */",
            "+/**",
            "+ * A \"raw\" object read from the object database.",
            "+ */",
            " typedef struct git_odb_object git_odb_object;",
            " ",
            " /** A stream to read/write from the ODB */",
            " typedef struct git_odb_stream git_odb_stream;",
            " ",
            " /** A stream to write a packfile to the ODB */",
            " typedef struct git_odb_writepack git_odb_writepack;",
            "@@ -190,15 +195,26 @@",
            " ",
            " /** Iterator for references */",
            " typedef struct git_reference_iterator  git_reference_iterator;",
            " ",
            " /** Transactional interface to references */",
            " typedef struct git_transaction git_transaction;",
            " ",
            "-/** Annotated commits, the input to merge and rebase. */",
            "+/**",
            "+ * Annotated commits are commits with additional metadata about how the",
            "+ * commit was resolved, which can be used for maintaining the user's",
            "+ * \"intent\" through commands like merge and rebase.",
            "+ *",
            "+ * For example, if a user wants to conceptually \"merge `HEAD`\", then the",
            "+ * commit portion of an annotated commit will point to the `HEAD` commit,",
            "+ * but the _annotation_ will denote the ref `HEAD`. This allows git to",
            "+ * perform the internal bookkeeping so that the system knows both the",
            "+ * content of what is being merged but also how the content was looked up",
            "+ * so that it can be recorded in the reflog appropriately.",
            "+ */",
            " typedef struct git_annotated_commit git_annotated_commit;",
            " ",
            " /** Representation of a status collection */",
            " typedef struct git_status_list git_status_list;",
            " ",
            " /** Representation of a rebase */",
            " typedef struct git_rebase git_rebase;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/version.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/version.h",
            "+++ /home/libgit2-1.9.1/include/git2/version.h",
            "@@ -3,41 +3,75 @@",
            "  *",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_git_version_h__",
            " #define INCLUDE_git_version_h__",
            " ",
            "+#include \"common.h\"",
            "+",
            "+/**",
            "+ * @file git2/version.h",
            "+ * @brief The version of libgit2",
            "+ * @ingroup Git",
            "+ * @{",
            "+ */",
            "+GIT_BEGIN_DECL",
            "+",
            " /**",
            "  * The version string for libgit2.  This string follows semantic",
            "  * versioning (v2) guidelines.",
            "  */",
            "-#define LIBGIT2_VERSION        \"1.8.2\"",
            "+#define LIBGIT2_VERSION           \"1.9.1\"",
            " ",
            " /** The major version number for this version of libgit2. */",
            "-#define LIBGIT2_VER_MAJOR      1",
            "+#define LIBGIT2_VERSION_MAJOR      1",
            " ",
            " /** The minor version number for this version of libgit2. */",
            "-#define LIBGIT2_VER_MINOR      8",
            "+#define LIBGIT2_VERSION_MINOR      9",
            " ",
            " /** The revision (\"teeny\") version number for this version of libgit2. */",
            "-#define LIBGIT2_VER_REVISION   2",
            "+#define LIBGIT2_VERSION_REVISION   1",
            " ",
            " /** The Windows DLL patch number for this version of libgit2. */",
            "-#define LIBGIT2_VER_PATCH      0",
            "+#define LIBGIT2_VERSION_PATCH      0",
            " ",
            " /**",
            "  * The prerelease string for this version of libgit2.  For development",
            "  * (nightly) builds, this will be \"alpha\".  For prereleases, this will be",
            "  * a prerelease name like \"beta\" or \"rc1\".  For final releases, this will",
            "  * be `NULL`.",
            "  */",
            "-#define LIBGIT2_VER_PRERELEASE NULL",
            "+#define LIBGIT2_VERSION_PRERELEASE NULL",
            " ",
            " /**",
            "  * The library ABI soversion for this version of libgit2. This should",
            "  * only be changed when the library has a breaking ABI change, and so",
            "- * may trail the library's version number.",
            "+ * may not reflect the library's API version number.",
            "+ */",
            "+#define LIBGIT2_SOVERSION         \"1.9\"",
            "+",
            "+/**",
            "+ * An integer value representing the libgit2 version number. For example,",
            "+ * libgit2 1.6.3 is 1060300.",
            "+ */",
            "+#define LIBGIT2_VERSION_NUMBER (    \\",
            "+    (LIBGIT2_VERSION_MAJOR * 1000000) + \\",
            "+    (LIBGIT2_VERSION_MINOR * 10000) +   \\",
            "+    (LIBGIT2_VERSION_REVISION * 100))",
            "+",
            "+/**",
            "+ * Compare the libgit2 version against a given version. Evaluates to true",
            "+ * if the given major, minor, and revision values are greater than or equal",
            "+ * to the currently running libgit2 version. For example:",
            "+ *",
            "+ *  #if LIBGIT2_VERSION_CHECK(1, 6, 3)",
            "+ *  # error libgit2 version is >= 1.6.3",
            "+ *  #endif",
            "  */",
            "-#define LIBGIT2_SOVERSION      \"1.8\"",
            "+#define LIBGIT2_VERSION_CHECK(major, minor, revision) \\",
            "+\t(LIBGIT2_VERSION_NUMBER >= ((major)*1000000)+((minor)*10000)+((revision)*100))",
            "+",
            "+/** @} */",
            "+GIT_END_DECL",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/include/git2/worktree.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/include/git2/worktree.h",
            "+++ /home/libgit2-1.9.1/include/git2/worktree.h",
            "@@ -10,17 +10,17 @@",
            " #include \"common.h\"",
            " #include \"buffer.h\"",
            " #include \"types.h\"",
            " #include \"strarray.h\"",
            " #include \"checkout.h\"",
            " ",
            " /**",
            "- * @file git2/worktrees.h",
            "- * @brief Git worktree related functions",
            "- * @defgroup git_commit Git worktree related functions",
            "+ * @file git2/worktree.h",
            "+ * @brief Additional working directories for a repository",
            "+ * @defgroup git_commit Additional working directories for a repository",
            "  * @ingroup Git",
            "  * @{",
            "  */",
            " GIT_BEGIN_DECL",
            " ",
            " /**",
            "  * List names of linked working trees",
            "@@ -92,15 +92,18 @@",
            " ",
            " \t/**",
            " \t * Options for the checkout.",
            " \t */",
            " \tgit_checkout_options checkout_options;",
            " } git_worktree_add_options;",
            " ",
            "+/** Current version for the `git_worktree_add_options` structure */",
            " #define GIT_WORKTREE_ADD_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_worktree_add_options` */",
            " #define GIT_WORKTREE_ADD_OPTIONS_INIT { GIT_WORKTREE_ADD_OPTIONS_VERSION, \\",
            " \t0, 0, NULL, GIT_CHECKOUT_OPTIONS_INIT }",
            " ",
            " /**",
            "  * Initialize git_worktree_add_options structure",
            "  *",
            "  * Initializes a `git_worktree_add_options` with default values. Equivalent to",
            "@@ -207,15 +210,18 @@",
            " typedef struct git_worktree_prune_options {",
            " \tunsigned int version;",
            " ",
            " \t/** A combination of `git_worktree_prune_t` */",
            " \tuint32_t flags;",
            " } git_worktree_prune_options;",
            " ",
            "+/** Current version for the `git_worktree_prune_options` structure */",
            " #define GIT_WORKTREE_PRUNE_OPTIONS_VERSION 1",
            "+",
            "+/** Static constructor for `git_worktree_prune_options` */",
            " #define GIT_WORKTREE_PRUNE_OPTIONS_INIT {GIT_WORKTREE_PRUNE_OPTIONS_VERSION,0}",
            " ",
            " /**",
            "  * Initialize git_worktree_prune_options structure",
            "  *",
            "  * Initializes a `git_worktree_prune_options` with default values. Equivalent to",
            "  * creating an instance with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`.",
            "@@ -264,8 +270,9 @@",
            "  * @return 0 or an error code",
            "  */",
            " GIT_EXTERN(int) git_worktree_prune(git_worktree *wt,",
            " \tgit_worktree_prune_options *opts);",
            " ",
            " /** @} */",
            " GIT_END_DECL",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd.h",
            "+++ /home/libgit2-1.9.1/src/cli/cmd.h",
            "@@ -21,15 +21,17 @@",
            " /* All the commands supported by the CLI */",
            " extern const cli_cmd_spec cli_cmds[];",
            " ",
            " /* Find a command by name */",
            " extern const cli_cmd_spec *cli_cmd_spec_byname(const char *name);",
            " ",
            " /* Commands */",
            "+extern int cmd_blame(int argc, char **argv);",
            " extern int cmd_cat_file(int argc, char **argv);",
            " extern int cmd_clone(int argc, char **argv);",
            " extern int cmd_config(int argc, char **argv);",
            " extern int cmd_hash_object(int argc, char **argv);",
            " extern int cmd_help(int argc, char **argv);",
            " extern int cmd_index_pack(int argc, char **argv);",
            "+extern int cmd_init(int argc, char **argv);",
            " ",
            " #endif /* CLI_cmd_h__ */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd_cat_file.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd_cat_file.c",
            "+++ /home/libgit2-1.9.1/src/cli/cmd_cat_file.c",
            "@@ -15,15 +15,14 @@",
            " \tDISPLAY_CONTENT = 0,",
            " \tDISPLAY_EXISTS,",
            " \tDISPLAY_PRETTY,",
            " \tDISPLAY_SIZE,",
            " \tDISPLAY_TYPE",
            " } display_t;",
            " ",
            "-static int show_help;",
            " static int display = DISPLAY_CONTENT;",
            " static char *type_name, *object_spec;",
            " ",
            " static const cli_opt_spec opts[] = {",
            " \tCLI_COMMON_OPT,",
            " ",
            " \t{ CLI_OPT_TYPE_SWITCH,     NULL,    't', &display,    DISPLAY_TYPE,",
            "@@ -39,15 +38,15 @@",
            " \t{ CLI_OPT_TYPE_ARG,       \"object\",  0, &object_spec, 0,",
            " \t  CLI_OPT_USAGE_REQUIRED, \"object\", \"the object to display\" },",
            " \t{ 0 },",
            " };",
            " ",
            " static void print_help(void)",
            " {",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts, 0);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Display the content for the given object in the repository.\\n\");",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Options:\\n\");",
            " ",
            "@@ -143,15 +142,15 @@",
            " \tgit_object_t type;",
            " \tcli_opt invalid_opt;",
            " \tint giterr, ret = 0;",
            " ",
            " \tif (cli_opt_parse(&invalid_opt, opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU))",
            " \t\treturn cli_opt_usage_error(COMMAND_NAME, opts, &invalid_opt);",
            " ",
            "-\tif (show_help) {",
            "+\tif (cli_opt__show_help) {",
            " \t\tprint_help();",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (cli_repository_open(&repo, &open_opts) < 0)",
            " \t\treturn cli_error_git();"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd_clone.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd_clone.c",
            "+++ /home/libgit2-1.9.1/src/cli/cmd_clone.c",
            "@@ -15,15 +15,15 @@",
            " ",
            " #include \"fs_path.h\"",
            " #include \"futils.h\"",
            " ",
            " #define COMMAND_NAME \"clone\"",
            " ",
            " static char *branch, *remote_path, *local_path, *depth;",
            "-static int show_help, quiet, checkout = 1, bare;",
            "+static int quiet, checkout = 1, bare;",
            " static bool local_path_exists;",
            " static cli_progress progress = CLI_PROGRESS_INIT;",
            " ",
            " static const cli_opt_spec opts[] = {",
            " \tCLI_COMMON_OPT,",
            " ",
            " \t{ CLI_OPT_TYPE_SWITCH,    \"quiet\",       'q', &quiet,       1,",
            "@@ -42,15 +42,15 @@",
            " \t{ CLI_OPT_TYPE_ARG,       \"directory\",    0,  &local_path,  0,",
            " \t  CLI_OPT_USAGE_DEFAULT,  \"directory\",    \"directory to clone into\" },",
            " \t{ 0 }",
            " };",
            " ",
            " static void print_help(void)",
            " {",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts, 0);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Clone a repository into a new directory.\\n\");",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Options:\\n\");",
            " ",
            "@@ -129,15 +129,15 @@",
            " \tcli_opt invalid_opt;",
            " \tchar *computed_path = NULL;",
            " \tint ret = 0;",
            " ",
            " \tif (cli_opt_parse(&invalid_opt, opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU))",
            " \t\treturn cli_opt_usage_error(COMMAND_NAME, opts, &invalid_opt);",
            " ",
            "-\tif (show_help) {",
            "+\tif (cli_opt__show_help) {",
            " \t\tprint_help();",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (!remote_path) {",
            " \t\tret = cli_error_usage(\"you must specify a repository to clone\");",
            " \t\tgoto done;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd_config.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd_config.c",
            "+++ /home/libgit2-1.9.1/src/cli/cmd_config.c",
            "@@ -19,15 +19,14 @@",
            " \tACTION_REPLACE_ALL,",
            " \tACTION_LIST",
            " } action_t;",
            " ",
            " static action_t action = ACTION_NONE;",
            " static int show_origin;",
            " static int show_scope;",
            "-static int show_help;",
            " static int null_separator;",
            " static int config_level;",
            " static char *config_filename;",
            " static char *name, *value, *value_pattern;",
            " ",
            " static const cli_opt_spec opts[] = {",
            " \tCLI_COMMON_OPT, \\",
            "@@ -64,15 +63,15 @@",
            " \t{ CLI_OPT_TYPE_ARG,       \"regexp\",      0,  &value_pattern, 0,",
            " \t  0,                      \"regexp\",     \"regular expression of values to replace\" },",
            " \t{ 0 },",
            " };",
            " ",
            " static void print_help(void)",
            " {",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts, 0);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Query and set configuration options.\\n\");",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Options:\\n\");",
            " ",
            "@@ -176,15 +175,15 @@",
            " \tcli_repository_open_options open_opts = { argv + 1, argc - 1};",
            " \tcli_opt invalid_opt;",
            " \tint ret = 0;",
            " ",
            " \tif (cli_opt_parse(&invalid_opt, opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU))",
            " \t\treturn cli_opt_usage_error(COMMAND_NAME, opts, &invalid_opt);",
            " ",
            "-\tif (show_help) {",
            "+\tif (cli_opt__show_help) {",
            " \t\tprint_help();",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (config_filename) {",
            " \t\tif (git_config_new(&config) < 0 ||",
            " \t\t    git_config_add_file_ondisk(config, config_filename,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd_hash_object.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd_hash_object.c",
            "+++ /home/libgit2-1.9.1/src/cli/cmd_hash_object.c",
            "@@ -9,15 +9,14 @@",
            " #include \"common.h\"",
            " #include \"cmd.h\"",
            " ",
            " #include \"futils.h\"",
            " ",
            " #define COMMAND_NAME \"hash-object\"",
            " ",
            "-static int show_help;",
            " static char *type_name;",
            " static int write_object, read_stdin, literally;",
            " static char **filenames;",
            " ",
            " static const cli_opt_spec opts[] = {",
            " \tCLI_COMMON_OPT,",
            " ",
            "@@ -32,15 +31,15 @@",
            " \t{ CLI_OPT_TYPE_ARGS,     \"file\",      0, &filenames,    0,",
            " \t  CLI_OPT_USAGE_CHOICE,  \"file\",     \"the file (or files) to read and hash\" },",
            " \t{ 0 },",
            " };",
            " ",
            " static void print_help(void)",
            " {",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts, 0);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Compute the object ID for a given file and optionally write that file\\nto the object database.\\n\");",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Options:\\n\");",
            " ",
            "@@ -99,15 +98,15 @@",
            " \tgit_object_t object_type = GIT_OBJECT_BLOB;",
            " \tchar **filename;",
            " \tint ret = 0;",
            " ",
            " \tif (cli_opt_parse(&invalid_opt, opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU))",
            " \t\treturn cli_opt_usage_error(COMMAND_NAME, opts, &invalid_opt);",
            " ",
            "-\tif (show_help) {",
            "+\tif (cli_opt__show_help) {",
            " \t\tprint_help();",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (type_name && (object_type = git_object_string2type(type_name)) == GIT_OBJECT_INVALID)",
            " \t\treturn cli_error_usage(\"invalid object type '%s'\", type_name);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd_help.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd_help.c",
            "+++ /home/libgit2-1.9.1/src/cli/cmd_help.c",
            "@@ -9,41 +9,40 @@",
            " #include <git2.h>",
            " #include \"common.h\"",
            " #include \"cmd.h\"",
            " ",
            " #define COMMAND_NAME \"help\"",
            " ",
            " static char *command;",
            "-static int show_help;",
            " ",
            " static const cli_opt_spec opts[] = {",
            " \tCLI_COMMON_OPT,",
            " ",
            " \t{ CLI_OPT_TYPE_ARG,      \"command\",  0, &command,   0,",
            " \t  CLI_OPT_USAGE_DEFAULT, \"command\", \"the command to show help for\" },",
            " \t{ 0 },",
            " };",
            " ",
            " static int print_help(void)",
            " {",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts, CLI_OPT_USAGE_SHOW_HIDDEN);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Display help information about %s.  If a command is specified, help\\n\", PROGRAM_NAME);",
            " \tprintf(\"about that command will be shown.  Otherwise, general information about\\n\");",
            " \tprintf(\"%s will be shown, including the commands available.\\n\", PROGRAM_NAME);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int print_commands(void)",
            " {",
            " \tconst cli_cmd_spec *cmd;",
            " ",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, NULL, cli_common_opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, NULL, cli_common_opts, CLI_OPT_USAGE_SHOW_HIDDEN);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"These are the %s commands available:\\n\\n\", PROGRAM_NAME);",
            " ",
            " \tfor (cmd = cli_cmds; cmd->name; cmd++)",
            " \t\tprintf(\"   %-11s  %s\\n\", cmd->name, cmd->desc);",
            " ",
            "@@ -58,15 +57,15 @@",
            " \tconst cli_cmd_spec *cmd;",
            " \tcli_opt invalid_opt;",
            " ",
            " \tif (cli_opt_parse(&invalid_opt, opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU))",
            " \t\treturn cli_opt_usage_error(COMMAND_NAME, opts, &invalid_opt);",
            " ",
            " \t/* Show the meta-help */",
            "-\tif (show_help)",
            "+\tif (cli_opt__show_help)",
            " \t\treturn print_help();",
            " ",
            " \t/* We were not asked to show help for a specific command. */",
            " \tif (!command)",
            " \t\treturn print_commands();",
            " ",
            " \t/*"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/cmd_index_pack.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/cmd_index_pack.c",
            "+++ /home/libgit2-1.9.1/src/cli/cmd_index_pack.c",
            "@@ -10,22 +10,20 @@",
            " #include \"cmd.h\"",
            " #include \"progress.h\"",
            " ",
            " #define COMMAND_NAME \"index-pack\"",
            " ",
            " #define BUFFER_SIZE (1024 * 1024)",
            " ",
            "-static int show_help, verbose, read_stdin;",
            "+static int verbose, read_stdin;",
            " static char *filename;",
            " static cli_progress progress = CLI_PROGRESS_INIT;",
            " ",
            " static const cli_opt_spec opts[] = {",
            "-\t{ CLI_OPT_TYPE_SWITCH,    \"help\",     0, &show_help,   1,",
            "-\t  CLI_OPT_USAGE_HIDDEN | CLI_OPT_USAGE_STOP_PARSING, NULL,",
            "-\t  \"display help about the \" COMMAND_NAME \" command\" },",
            "+\tCLI_COMMON_OPT,",
            " ",
            " \t{ CLI_OPT_TYPE_SWITCH,    \"verbose\", 'v', &verbose,    1,",
            " \t  CLI_OPT_USAGE_DEFAULT,   NULL,    \"display progress output\" },",
            " ",
            " \t{ CLI_OPT_TYPE_LITERAL },",
            " ",
            " \t{ CLI_OPT_TYPE_SWITCH,    \"stdin\",    0,   &read_stdin, 1,",
            "@@ -34,15 +32,15 @@",
            " \t  CLI_OPT_USAGE_CHOICE,   \"pack-file\", \"packfile path\" },",
            " ",
            " \t{ 0 },",
            " };",
            " ",
            " static void print_help(void)",
            " {",
            "-\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts);",
            "+\tcli_opt_usage_fprint(stdout, PROGRAM_NAME, COMMAND_NAME, opts, 0);",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Indexes a packfile and writes the index to disk.\\n\");",
            " \tprintf(\"\\n\");",
            " ",
            " \tprintf(\"Options:\\n\");",
            " ",
            "@@ -58,15 +56,15 @@",
            " \tchar buf[BUFFER_SIZE];",
            " \tssize_t read_len;",
            " \tint fd, ret;",
            " ",
            " \tif (cli_opt_parse(&invalid_opt, opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU))",
            " \t\treturn cli_opt_usage_error(COMMAND_NAME, opts, &invalid_opt);",
            " ",
            "-\tif (show_help) {",
            "+\tif (cli_opt__show_help) {",
            " \t\tprint_help();",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (verbose) {",
            " \t\tidx_opts.progress_cb = cli_progress_indexer;",
            " \t\tidx_opts.progress_cb_payload = &progress;",
            "@@ -76,15 +74,17 @@",
            " \t\tfd = fileno(stdin);",
            " \t} else if ((fd = p_open(filename, O_RDONLY)) < 0) {",
            " \t\tret = cli_error_git();",
            " \t\tgoto done;",
            " \t}",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tret = git_indexer_new(&idx, \".\", GIT_OID_SHA1, &idx_opts);",
            "+\tidx_opts.oid_type = GIT_OID_SHA1;",
            "+",
            "+\tret = git_indexer_new(&idx, \".\", &idx_opts);",
            " #else",
            " \tret = git_indexer_new(&idx, \".\", 0, NULL, &idx_opts);",
            " #endif",
            " ",
            " \tif (ret < 0) {",
            " \t\tret = cli_error_git();",
            " \t\tgoto done;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/common.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/common.c",
            "+++ /home/libgit2-1.9.1/src/cli/common.c",
            "@@ -6,14 +6,15 @@",
            "  */",
            " ",
            " #include <git2.h>",
            " #include <git2/sys/config.h>",
            " ",
            " #include \"git2_util.h\"",
            " #include \"vector.h\"",
            "+#include \"fs_path.h\"",
            " ",
            " #include \"common.h\"",
            " #include \"error.h\"",
            " ",
            " static int parse_option(cli_opt *opt, void *data)",
            " {",
            " \tgit_str kv = GIT_STR_INIT, env = GIT_STR_INIT;",
            "@@ -101,15 +102,15 @@",
            " \t\t\trepo, 0) < 0)",
            " \t\terror = cli_error_git();",
            " ",
            " done:",
            " \tif (error && backend)",
            " \t\tbackend->free(backend);",
            " \tgit_config_free(config);",
            "-\tgit_vector_free_deep(&cmdline);",
            "+\tgit_vector_dispose_deep(&cmdline);",
            " \treturn error;",
            " }",
            " ",
            " int cli_repository_open(",
            " \tgit_repository **out,",
            " \tcli_repository_open_options *opts)",
            " {",
            "@@ -120,7 +121,48 @@",
            " ",
            " \tif (opts && parse_common_options(repo, opts) < 0)",
            " \t\treturn -1;",
            " ",
            " \t*out = repo;",
            " \treturn 0;",
            " }",
            "+",
            "+/*",
            "+ * This resolves paths - not _pathspecs_ like git - it accepts an absolute",
            "+ * path (to a path within the repository working directory) or a path",
            "+ * relative to the current directory.",
            "+ */",
            "+int cli_resolve_path(git_str *out, git_repository *repo, const char *given_path)",
            "+{",
            "+\tgit_str path = GIT_STR_INIT;",
            "+\tint error = 0;",
            "+",
            "+\tif (!git_fs_path_is_absolute(given_path)) {",
            "+\t\tchar cwd[GIT_PATH_MAX];",
            "+",
            "+\t\tif (p_getcwd(cwd, GIT_PATH_MAX) < 0)",
            "+\t\t\terror = cli_error_os();",
            "+\t\telse if (git_str_puts(&path, cwd) < 0 ||",
            "+\t\t         git_fs_path_apply_relative(&path, given_path) < 0)",
            "+\t\t\terror = cli_error_git();",
            "+",
            "+\t\tif (error)",
            "+\t\t\tgoto done;",
            "+\t} else if (git_str_puts(&path, given_path) < 0) {",
            "+\t\terror = cli_error_git();",
            "+\t\tgoto done;",
            "+\t}",
            "+",
            "+\terror = git_fs_path_make_relative(&path, git_repository_workdir(repo));",
            "+",
            "+\tif (error == GIT_ENOTFOUND)",
            "+\t\terror = cli_error(\"path '%s' is not inside the git repository '%s'\",",
            "+\t\t\tgiven_path, git_repository_workdir(repo));",
            "+\telse if (error < 0)",
            "+\t\terror = cli_error_git();",
            "+\telse",
            "+\t\tgit_str_swap(out, &path);",
            "+",
            "+done:",
            "+\tgit_str_dispose(&path);",
            "+\treturn error;",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/common.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/common.h",
            "+++ /home/libgit2-1.9.1/src/cli/common.h",
            "@@ -16,51 +16,48 @@",
            " #include \"opt.h\"",
            " #include \"opt_usage.h\"",
            " ",
            " /*",
            "  * Common command arguments.",
            "  */",
            " ",
            "+extern int cli_opt__show_help;",
            "+extern int cli_opt__use_pager;",
            "+",
            " #define CLI_COMMON_OPT_HELP \\",
            "-\tCLI_OPT_TYPE_SWITCH, \"help\",       0, &show_help, 1, \\",
            "-\tCLI_OPT_USAGE_HIDDEN | CLI_OPT_USAGE_STOP_PARSING",
            "+\tCLI_OPT_TYPE_SWITCH, \"help\",       0, &cli_opt__show_help,  1, \\",
            "+\tCLI_OPT_USAGE_HIDDEN | CLI_OPT_USAGE_STOP_PARSING, \\",
            "+\tNULL, \"display help information\"",
            " #define CLI_COMMON_OPT_CONFIG \\",
            "-\tCLI_OPT_TYPE_VALUE,   NULL,       'c', NULL,      0, \\",
            "-\tCLI_OPT_USAGE_HIDDEN",
            "+\tCLI_OPT_TYPE_VALUE,   NULL,       'c', NULL,                0, \\",
            "+\tCLI_OPT_USAGE_HIDDEN, \\",
            "+\t\"key=value\", \"add configuration value\"",
            " #define CLI_COMMON_OPT_CONFIG_ENV \\",
            "-\tCLI_OPT_TYPE_VALUE,  \"config-env\", 0,  NULL,      0, \\",
            "-\tCLI_OPT_USAGE_HIDDEN",
            "+\tCLI_OPT_TYPE_VALUE,  \"config-env\", 0,  NULL,                0, \\",
            "+\tCLI_OPT_USAGE_HIDDEN, \\",
            "+\t\"key=value\", \"set configuration value to environment variable\"",
            "+#define CLI_COMMON_OPT_NO_PAGER \\",
            "+\tCLI_OPT_TYPE_SWITCH, \"no-pager\",   0,  &cli_opt__use_pager, 0, \\",
            "+\tCLI_OPT_USAGE_HIDDEN, \\",
            "+\tNULL, \"don't paginate multi-page output\"",
            " ",
            " #define CLI_COMMON_OPT \\",
            " \t{ CLI_COMMON_OPT_HELP }, \\",
            " \t{ CLI_COMMON_OPT_CONFIG }, \\",
            "-\t{ CLI_COMMON_OPT_CONFIG_ENV }",
            "+\t{ CLI_COMMON_OPT_CONFIG_ENV }, \\",
            "+\t{ CLI_COMMON_OPT_NO_PAGER }",
            " ",
            " typedef struct {",
            " \tchar **args;",
            " \tint args_len;",
            " } cli_repository_open_options;",
            " ",
            " extern int cli_repository_open(",
            " \tgit_repository **out,",
            " \tcli_repository_open_options *opts);",
            " ",
            "-/*",
            "- * Common command arguments.",
            "- */",
            "-",
            "-#define CLI_COMMON_OPT_HELP \\",
            "-\tCLI_OPT_TYPE_SWITCH, \"help\",       0, &show_help, 1, \\",
            "-\tCLI_OPT_USAGE_HIDDEN | CLI_OPT_USAGE_STOP_PARSING",
            "-#define CLI_COMMON_OPT_CONFIG \\",
            "-\tCLI_OPT_TYPE_VALUE,   NULL,       'c', NULL,      0, \\",
            "-\tCLI_OPT_USAGE_HIDDEN",
            "-#define CLI_COMMON_OPT_CONFIG_ENV \\",
            "-\tCLI_OPT_TYPE_VALUE,  \"config-env\", 0,  NULL,      0, \\",
            "-\tCLI_OPT_USAGE_HIDDEN",
            "-",
            "-#define CLI_COMMON_OPT \\",
            "-\t{ CLI_COMMON_OPT_HELP }, \\",
            "-\t{ CLI_COMMON_OPT_CONFIG }, \\",
            "-\t{ CLI_COMMON_OPT_CONFIG_ENV }",
            "+extern int cli_resolve_path(",
            "+\tgit_str *out,",
            "+\tgit_repository *repo,",
            "+\tconst char *given_path);",
            " ",
            " #endif /* CLI_common_h__ */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/main.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/main.c",
            "+++ /home/libgit2-1.9.1/src/cli/main.c",
            "@@ -6,42 +6,42 @@",
            "  */",
            " ",
            " #include <stdio.h>",
            " #include <git2.h>",
            " #include \"common.h\"",
            " #include \"cmd.h\"",
            " ",
            "-static int show_help = 0;",
            "+int cli_opt__show_help = 0;",
            "+int cli_opt__use_pager = 1;",
            "+",
            " static int show_version = 0;",
            " static char *command = NULL;",
            " static char **args = NULL;",
            " ",
            " const cli_opt_spec cli_common_opts[] = {",
            "-\t{ CLI_OPT_TYPE_SWITCH,    \"help\",       0, &show_help,    1,",
            "-\t  CLI_OPT_USAGE_DEFAULT,   NULL,       \"display help information\" },",
            "-\t{ CLI_OPT_TYPE_VALUE,      NULL,       'c', NULL,         0,",
            "-\t  CLI_OPT_USAGE_DEFAULT,  \"key=value\", \"add configuration value\" },",
            "-\t{ CLI_OPT_TYPE_VALUE,     \"config-env\", 0, NULL,          0,",
            "-\t  CLI_OPT_USAGE_DEFAULT,  \"key=value\", \"set configuration value to environment variable\" },",
            "+\tCLI_COMMON_OPT,",
            "+",
            " \t{ CLI_OPT_TYPE_SWITCH,    \"version\",   0, &show_version, 1,",
            " \t  CLI_OPT_USAGE_DEFAULT,   NULL,      \"display the version\" },",
            " \t{ CLI_OPT_TYPE_ARG,       \"command\",   0, &command,      0,",
            " \t  CLI_OPT_USAGE_REQUIRED, \"command\", \"the command to run\" },",
            " \t{ CLI_OPT_TYPE_ARGS,      \"args\",      0, &args,         0,",
            " \t  CLI_OPT_USAGE_DEFAULT,  \"args\",    \"arguments for the command\" },",
            " \t{ 0 }",
            " };",
            " ",
            " const cli_cmd_spec cli_cmds[] = {",
            "+\t{ \"blame\",       cmd_blame,       \"Show the origin of each line of a file\" },",
            " \t{ \"cat-file\",    cmd_cat_file,    \"Display an object in the repository\" },",
            " \t{ \"clone\",       cmd_clone,       \"Clone a repository into a new directory\" },",
            " \t{ \"config\",      cmd_config,      \"View or set configuration values \" },",
            " \t{ \"hash-object\", cmd_hash_object, \"Hash a raw object and product its object ID\" },",
            " \t{ \"help\",        cmd_help,        \"Display help information\" },",
            " \t{ \"index-pack\",  cmd_index_pack,  \"Create an index for a packfile\" },",
            "+\t{ \"init\",        cmd_init,        \"Create a new git repository\" },",
            " \t{ NULL }",
            " };",
            " ",
            " /*",
            "  * Reorder the argv as it was given, since git has the notion of global",
            "  * options (like `--help` or `-c key=val`) that we want to pass to the",
            "  * subcommand, and that can appear early in the arguments, before the",
            "@@ -59,14 +59,27 @@",
            " ",
            " \tfor (i = first; i > 1; i--)",
            " \t\targv[i] = argv[i - 1];",
            " ",
            " \targv[1] = tmp;",
            " }",
            " ",
            "+/*",
            "+ * When invoked without a command, or just with `--help`, we invoke",
            "+ * the help command; but we want to preserve only arguments that would",
            "+ * be useful for that.",
            "+ */",
            "+static void help_args(int *argc, char **argv)",
            "+{",
            "+\tcli_opt__show_help = 0;",
            "+",
            "+\targv[0] = \"help\";",
            "+\t*argc = 1;",
            "+}",
            "+",
            " int main(int argc, char **argv)",
            " {",
            " \tconst cli_cmd_spec *cmd;",
            " \tcli_opt_parser optparser;",
            " \tcli_opt opt;",
            " \tint ret = 0;",
            " ",
            "@@ -77,15 +90,15 @@",
            " ",
            " \tcli_opt_parser_init(&optparser, cli_common_opts, argv + 1, argc - 1, CLI_OPT_PARSE_GNU);",
            " ",
            " \t/* Parse the top-level (common) options and command information */",
            " \twhile (cli_opt_parser_next(&opt, &optparser)) {",
            " \t\tif (!opt.spec) {",
            " \t\t\tcli_opt_status_fprint(stderr, PROGRAM_NAME, &opt);",
            "-\t\t\tcli_opt_usage_fprint(stderr, PROGRAM_NAME, NULL, cli_common_opts);",
            "+\t\t\tcli_opt_usage_fprint(stderr, PROGRAM_NAME, NULL, cli_common_opts, CLI_OPT_USAGE_SHOW_HIDDEN);",
            " \t\t\tret = CLI_EXIT_USAGE;",
            " \t\t\tgoto done;",
            " \t\t}",
            " ",
            " \t\t/*",
            " \t\t * When we see a command, stop parsing and capture the",
            " \t\t * remaining arguments as args for the command itself.",
            "@@ -98,14 +111,15 @@",
            " ",
            " \tif (show_version) {",
            " \t\tprintf(\"%s version %s\\n\", PROGRAM_NAME, LIBGIT2_VERSION);",
            " \t\tgoto done;",
            " \t}",
            " ",
            " \tif (!command) {",
            "+\t\thelp_args(&argc, argv);",
            " \t\tret = cmd_help(argc, argv);",
            " \t\tgoto done;",
            " \t}",
            " ",
            " \tif ((cmd = cli_cmd_spec_byname(command)) == NULL) {",
            " \t\tret = cli_error(\"'%s' is not a %s command. See '%s help'.\",",
            " \t\t                command, PROGRAM_NAME, PROGRAM_NAME);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/opt.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/opt.c",
            "+++ /home/libgit2-1.9.1/src/cli/opt.c",
            "@@ -15,15 +15,15 @@",
            " ",
            " #include <stdlib.h>",
            " #include <string.h>",
            " #include <stdio.h>",
            " #include <limits.h>",
            " #include <assert.h>",
            " ",
            "-#if defined(__sun) || defined(__illumos__)",
            "+#if defined(__sun) || defined(__illumos__) || defined(__CYGWIN__)",
            " # include <alloca.h>",
            " #endif",
            " ",
            " #include \"common.h\"",
            " #include \"opt.h\"",
            " ",
            " #ifdef _WIN32"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/opt_usage.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/opt_usage.c",
            "+++ /home/libgit2-1.9.1/src/cli/opt_usage.c",
            "@@ -4,62 +4,112 @@",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " ",
            " #include \"common.h\"",
            " #include \"str.h\"",
            " ",
            "-static int print_spec_name(git_str *out, const cli_opt_spec *spec)",
            "+#define is_switch_or_value(spec) \\",
            "+\t((spec)->type == CLI_OPT_TYPE_SWITCH || \\",
            "+\t (spec)->type == CLI_OPT_TYPE_VALUE)",
            "+",
            "+static int print_spec_args(git_str *out, const cli_opt_spec *spec)",
            " {",
            "-\tif (spec->type == CLI_OPT_TYPE_VALUE && spec->alias &&",
            "-\t    !(spec->usage & CLI_OPT_USAGE_VALUE_OPTIONAL) &&",
            "-\t    !(spec->usage & CLI_OPT_USAGE_SHOW_LONG))",
            "-\t\treturn git_str_printf(out, \"-%c <%s>\", spec->alias, spec->value_name);",
            "-\tif (spec->type == CLI_OPT_TYPE_VALUE && spec->alias &&",
            "-\t    !(spec->usage & CLI_OPT_USAGE_SHOW_LONG))",
            "-\t\treturn git_str_printf(out, \"-%c [<%s>]\", spec->alias, spec->value_name);",
            "-\tif (spec->type == CLI_OPT_TYPE_VALUE &&",
            "-\t    !(spec->usage & CLI_OPT_USAGE_VALUE_OPTIONAL))",
            "-\t\treturn git_str_printf(out, \"--%s[=<%s>]\", spec->name, spec->value_name);",
            "-\tif (spec->type == CLI_OPT_TYPE_VALUE)",
            "-\t\treturn git_str_printf(out, \"--%s=<%s>\", spec->name, spec->value_name);",
            "+\tGIT_ASSERT(!is_switch_or_value(spec));",
            "+",
            " \tif (spec->type == CLI_OPT_TYPE_ARG)",
            " \t\treturn git_str_printf(out, \"<%s>\", spec->value_name);",
            " \tif (spec->type == CLI_OPT_TYPE_ARGS)",
            " \t\treturn git_str_printf(out, \"<%s>...\", spec->value_name);",
            " \tif (spec->type == CLI_OPT_TYPE_LITERAL)",
            " \t\treturn git_str_printf(out, \"--\");",
            "-\tif (spec->alias && !(spec->usage & CLI_OPT_USAGE_SHOW_LONG))",
            "+",
            "+\tGIT_ASSERT(!\"unknown option spec type\");",
            "+\treturn -1;",
            "+}",
            "+",
            "+GIT_INLINE(int) print_spec_alias(git_str *out, const cli_opt_spec *spec)",
            "+{",
            "+\tGIT_ASSERT(is_switch_or_value(spec) && spec->alias);",
            "+",
            "+\tif (spec->type == CLI_OPT_TYPE_VALUE &&",
            "+\t    !(spec->usage & CLI_OPT_USAGE_VALUE_OPTIONAL))",
            "+\t\treturn git_str_printf(out, \"-%c <%s>\", spec->alias, spec->value_name);",
            "+\telse if (spec->type == CLI_OPT_TYPE_VALUE)",
            "+\t\treturn git_str_printf(out, \"-%c [<%s>]\", spec->alias, spec->value_name);",
            "+\telse",
            " \t\treturn git_str_printf(out, \"-%c\", spec->alias);",
            "-\tif (spec->name)",
            "+}",
            "+",
            "+GIT_INLINE(int) print_spec_name(git_str *out, const cli_opt_spec *spec)",
            "+{",
            "+\tGIT_ASSERT(is_switch_or_value(spec) && spec->name);",
            "+",
            "+\tif (spec->type == CLI_OPT_TYPE_VALUE &&",
            "+\t    !(spec->usage & CLI_OPT_USAGE_VALUE_OPTIONAL))",
            "+\t\treturn git_str_printf(out, \"--%s=<%s>\", spec->name, spec->value_name);",
            "+\telse if (spec->type == CLI_OPT_TYPE_VALUE)",
            "+\t\treturn git_str_printf(out, \"--%s[=<%s>]\", spec->name, spec->value_name);",
            "+\telse",
            " \t\treturn git_str_printf(out, \"--%s\", spec->name);",
            "+}",
            "+",
            "+GIT_INLINE(int) print_spec_full(git_str *out, const cli_opt_spec *spec)",
            "+{",
            "+\tint error = 0;",
            "+",
            "+\tif (is_switch_or_value(spec)) {",
            "+\t\tif (spec->alias)",
            "+\t\t\terror |= print_spec_alias(out, spec);",
            "+",
            "+\t\tif (spec->alias && spec->name)",
            "+\t\t\terror |= git_str_printf(out, \", \");",
            "+",
            "+\t\tif (spec->name)",
            "+\t\t\terror |= print_spec_name(out, spec);",
            "+\t} else {",
            "+\t\terror |= print_spec_args(out, spec);",
            "+\t}",
            "+",
            "+\treturn error;",
            "+}",
            "+",
            "+GIT_INLINE(int) print_spec(git_str *out, const cli_opt_spec *spec)",
            "+{",
            "+\tif (is_switch_or_value(spec)) {",
            "+\t\tif (spec->alias && !(spec->usage & CLI_OPT_USAGE_SHOW_LONG))",
            "+\t\t\treturn print_spec_alias(out, spec);",
            "+\t\telse",
            "+\t\t\treturn print_spec_name(out, spec);",
            "+\t}",
            " ",
            "-\tGIT_ASSERT(0);",
            "+\treturn print_spec_args(out, spec);",
            " }",
            " ",
            " /*",
            "  * This is similar to adopt's function, but modified to understand",
            "  * that we have a command (\"git\") and a \"subcommand\" (\"checkout\").",
            "  * It also understands a terminal's line length and wrap appropriately,",
            "  * using a `git_str` for storage.",
            "  */",
            " int cli_opt_usage_fprint(",
            " \tFILE *file,",
            " \tconst char *command,",
            " \tconst char *subcommand,",
            "-\tconst cli_opt_spec specs[])",
            "+\tconst cli_opt_spec specs[],",
            "+\tunsigned int print_flags)",
            " {",
            " \tgit_str usage = GIT_BUF_INIT, opt = GIT_BUF_INIT;",
            " \tconst cli_opt_spec *spec;",
            " \tsize_t i, prefixlen, linelen;",
            " \tbool choice = false, next_choice = false, optional = false;",
            " \tint error;",
            " ",
            " \t/* TODO: query actual console width. */",
            "-\tint console_width = 80;",
            "+\tint console_width = 78;",
            " ",
            " \tif ((error = git_str_printf(&usage, \"usage: %s\", command)) < 0)",
            " \t\tgoto done;",
            " ",
            " \tif (subcommand &&",
            " \t    (error = git_str_printf(&usage, \" %s\", subcommand)) < 0)",
            " \t\tgoto done;",
            "@@ -69,28 +119,29 @@",
            " ",
            " \tfor (spec = specs; spec->type; ++spec) {",
            " \t\tif (!choice)",
            " \t\t\toptional = !(spec->usage & CLI_OPT_USAGE_REQUIRED);",
            " ",
            " \t\tnext_choice = !!((spec + 1)->usage & CLI_OPT_USAGE_CHOICE);",
            " ",
            "-\t\tif (spec->usage & CLI_OPT_USAGE_HIDDEN)",
            "+\t\tif ((spec->usage & CLI_OPT_USAGE_HIDDEN) &&",
            "+\t\t    !(print_flags & CLI_OPT_USAGE_SHOW_HIDDEN))",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (choice)",
            " \t\t\tgit_str_putc(&opt, '|');",
            " \t\telse",
            " \t\t\tgit_str_clear(&opt);",
            " ",
            " \t\tif (optional && !choice)",
            " \t\t\tgit_str_putc(&opt, '[');",
            " \t\tif (!optional && !choice && next_choice)",
            " \t\t\tgit_str_putc(&opt, '(');",
            " ",
            "-\t\tif ((error = print_spec_name(&opt, spec)) < 0)",
            "+\t\tif ((error = print_spec(&opt, spec)) < 0)",
            " \t\t\tgoto done;",
            " ",
            " \t\tif (!optional && choice && !next_choice)",
            " \t\t\tgit_str_putc(&opt, ')');",
            " \t\telse if (optional && !next_choice)",
            " \t\t\tgit_str_putc(&opt, ']');",
            " ",
            "@@ -107,19 +158,19 @@",
            " \t\t    linelen + git_str_len(&opt) + 1 > (size_t)console_width) {",
            " \t\t\tgit_str_putc(&usage, '\\n');",
            " ",
            " \t\t\tfor (i = 0; i < prefixlen; i++)",
            " \t\t\t\tgit_str_putc(&usage, ' ');",
            " ",
            " \t\t\tlinelen = prefixlen;",
            "-\t\t} else {",
            "-\t\t\tgit_str_putc(&usage, ' ');",
            "-\t\t\tlinelen += git_str_len(&opt) + 1;",
            " \t\t}",
            " ",
            "+\t\tgit_str_putc(&usage, ' ');",
            "+\t\tlinelen += git_str_len(&opt) + 1;",
            "+",
            " \t\tgit_str_puts(&usage, git_str_cstr(&opt));",
            " ",
            " \t\tif (git_str_oom(&usage)) {",
            " \t\t\terror = -1;",
            " \t\t\tgoto done;",
            " \t\t}",
            " \t}",
            "@@ -136,53 +187,71 @@",
            " ",
            " int cli_opt_usage_error(",
            " \tconst char *subcommand,",
            " \tconst cli_opt_spec specs[],",
            " \tconst cli_opt *invalid_opt)",
            " {",
            " \tcli_opt_status_fprint(stderr, PROGRAM_NAME, invalid_opt);",
            "-\tcli_opt_usage_fprint(stderr, PROGRAM_NAME, subcommand, specs);",
            "+\tcli_opt_usage_fprint(stderr, PROGRAM_NAME, subcommand, specs, 0);",
            " \treturn CLI_EXIT_USAGE;",
            " }",
            " ",
            " int cli_opt_help_fprint(",
            " \tFILE *file,",
            " \tconst cli_opt_spec specs[])",
            " {",
            " \tgit_str help = GIT_BUF_INIT;",
            " \tconst cli_opt_spec *spec;",
            "+\tbool required;",
            " \tint error = 0;",
            " ",
            " \t/* Display required arguments first */",
            " \tfor (spec = specs; spec->type; ++spec) {",
            "-\t\tif (! (spec->usage & CLI_OPT_USAGE_REQUIRED) ||",
            "-\t\t    (spec->usage & CLI_OPT_USAGE_HIDDEN))",
            "+\t\tif ((spec->usage & CLI_OPT_USAGE_HIDDEN) ||",
            "+\t\t    (spec->type == CLI_OPT_TYPE_LITERAL))",
            "+\t\t\tcontinue;",
            "+",
            "+\t\trequired = ((spec->usage & CLI_OPT_USAGE_REQUIRED) ||",
            "+\t\t    ((spec->usage & CLI_OPT_USAGE_CHOICE) && required));",
            "+",
            "+\t\tif (!required)",
            " \t\t\tcontinue;",
            " ",
            " \t\tgit_str_printf(&help, \"    \");",
            " ",
            "-\t\tif ((error = print_spec_name(&help, spec)) < 0)",
            "+\t\tif ((error = print_spec_full(&help, spec)) < 0)",
            " \t\t\tgoto done;",
            " ",
            "-\t\tgit_str_printf(&help, \": %s\\n\", spec->help);",
            "+\t\tgit_str_printf(&help, \"\\n\");",
            "+",
            "+\t\tif (spec->help)",
            "+\t\t\tgit_str_printf(&help, \"        %s\\n\", spec->help);",
            " \t}",
            " ",
            " \t/* Display the remaining arguments */",
            " \tfor (spec = specs; spec->type; ++spec) {",
            "-\t\tif ((spec->usage & CLI_OPT_USAGE_REQUIRED) ||",
            "-\t\t    (spec->usage & CLI_OPT_USAGE_HIDDEN))",
            "+\t\tif ((spec->usage & CLI_OPT_USAGE_HIDDEN) ||",
            "+\t\t    (spec->type == CLI_OPT_TYPE_LITERAL))",
            "+\t\t\tcontinue;",
            "+",
            "+\t\trequired = ((spec->usage & CLI_OPT_USAGE_REQUIRED) ||",
            "+\t\t    ((spec->usage & CLI_OPT_USAGE_CHOICE) && required));",
            "+",
            "+\t\tif (required)",
            " \t\t\tcontinue;",
            " ",
            " \t\tgit_str_printf(&help, \"    \");",
            " ",
            "-\t\tif ((error = print_spec_name(&help, spec)) < 0)",
            "+\t\tif ((error = print_spec_full(&help, spec)) < 0)",
            " \t\t\tgoto done;",
            " ",
            "-\t\tgit_str_printf(&help, \": %s\\n\", spec->help);",
            "+\t\tgit_str_printf(&help, \"\\n\");",
            " ",
            "+\t\tif (spec->help)",
            "+\t\t\tgit_str_printf(&help, \"        %s\\n\", spec->help);",
            " \t}",
            " ",
            " \tif (git_str_oom(&help) ||",
            " \t    p_write(fileno(file), help.ptr, help.size) < 0)",
            " \t\terror = -1;",
            " ",
            " done:"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/cli/opt_usage.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/cli/opt_usage.h",
            "+++ /home/libgit2-1.9.1/src/cli/opt_usage.h",
            "@@ -4,28 +4,33 @@",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " ",
            " #ifndef CLI_opt_usage_h__",
            " #define CLI_opt_usage_h__",
            " ",
            "+typedef enum {",
            "+\tCLI_OPT_USAGE_SHOW_HIDDEN = (1 << 0),",
            "+} cli_opt_usage_flags;",
            "+",
            " /**",
            "  * Prints usage information to the given file handle.",
            "  *",
            "  * @param file The file to print information to",
            "  * @param command The name of the command to use when printing",
            "  * @param subcommand The name of the subcommand (eg \"checkout\") to use when printing, or NULL to skip",
            "  * @param specs The specifications allowed by the command",
            "  * @return 0 on success, -1 on failure",
            "  */",
            " int cli_opt_usage_fprint(",
            " \tFILE *file,",
            " \tconst char *command,",
            " \tconst char *subcommand,",
            "-\tconst cli_opt_spec specs[]);",
            "+\tconst cli_opt_spec specs[],",
            "+\tunsigned int print_flags);",
            " ",
            " int cli_opt_usage_error(",
            " \tconst char *subcommand,",
            " \tconst cli_opt_spec specs[],",
            " \tconst cli_opt *invalid_opt);",
            " ",
            " int cli_opt_help_fprint("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/apply.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/apply.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/apply.c",
            "@@ -16,14 +16,15 @@",
            " #include \"patch.h\"",
            " #include \"futils.h\"",
            " #include \"delta.h\"",
            " #include \"zstream.h\"",
            " #include \"reader.h\"",
            " #include \"index.h\"",
            " #include \"repository.h\"",
            "+#include \"hashmap_str.h\"",
            " #include \"apply.h\"",
            " ",
            " typedef struct {",
            " \t/* The lines that we allocate ourself are allocated out of the pool.",
            " \t * (Lines may have been allocated out of the diff.)",
            " \t */",
            " \tgit_pool pool;",
            "@@ -92,15 +93,15 @@",
            " ",
            " static void patch_image_free(patch_image *image)",
            " {",
            " \tif (image == NULL)",
            " \t\treturn;",
            " ",
            " \tgit_pool_clear(&image->pool);",
            "-\tgit_vector_free(&image->lines);",
            "+\tgit_vector_dispose(&image->lines);",
            " }",
            " ",
            " static bool match_hunk(",
            " \tpatch_image *image,",
            " \tpatch_image *preimage,",
            " \tsize_t linenum)",
            " {",
            "@@ -448,15 +449,15 @@",
            " static int apply_one(",
            " \tgit_repository *repo,",
            " \tgit_reader *preimage_reader,",
            " \tgit_index *preimage,",
            " \tgit_reader *postimage_reader,",
            " \tgit_index *postimage,",
            " \tgit_diff *diff,",
            "-\tgit_strmap *removed_paths,",
            "+\tgit_hashset_str *removed_paths,",
            " \tsize_t i,",
            " \tconst git_apply_options *opts)",
            " {",
            " \tgit_patch *patch = NULL;",
            " \tgit_str pre_contents = GIT_STR_INIT, post_contents = GIT_STR_INIT;",
            " \tconst git_diff_delta *delta;",
            " \tchar *filename = NULL;",
            "@@ -485,15 +486,15 @@",
            " ",
            " \t/*",
            " \t * Ensure that the file has not been deleted or renamed if we're",
            " \t * applying a modification delta.",
            " \t */",
            " \tif (delta->status != GIT_DELTA_RENAMED &&",
            " \t    delta->status != GIT_DELTA_ADDED) {",
            "-\t\tif (git_strmap_exists(removed_paths, delta->old_file.path)) {",
            "+\t\tif (git_hashset_str_contains(removed_paths, delta->old_file.path)) {",
            " \t\t\terror = apply_err(\"path '%s' has been renamed or deleted\", delta->old_file.path);",
            " \t\t\tgoto done;",
            " \t\t}",
            " \t}",
            " ",
            " \t/*",
            " \t * We may be applying a second delta to an already seen file.  If so,",
            "@@ -569,19 +570,19 @@",
            " ",
            " \t\tif ((error = git_index_add(postimage, &post_entry)) < 0)",
            " \t\t\tgoto done;",
            " \t}",
            " ",
            " \tif (delta->status == GIT_DELTA_RENAMED ||",
            " \t    delta->status == GIT_DELTA_DELETED)",
            "-\t\terror = git_strmap_set(removed_paths, delta->old_file.path, (char *) delta->old_file.path);",
            "+\t\terror = git_hashset_str_add(removed_paths, delta->old_file.path);",
            " ",
            " \tif (delta->status == GIT_DELTA_RENAMED ||",
            " \t    delta->status == GIT_DELTA_ADDED)",
            "-\t\tgit_strmap_delete(removed_paths, delta->new_file.path);",
            "+\t\tgit_hashset_str_remove(removed_paths, delta->new_file.path);",
            " ",
            " done:",
            " \tgit_str_dispose(&pre_contents);",
            " \tgit_str_dispose(&post_contents);",
            " \tgit__free(filename);",
            " \tgit_patch_free(patch);",
            " ",
            "@@ -593,28 +594,25 @@",
            " \tgit_reader *pre_reader,",
            " \tgit_index *preimage,",
            " \tgit_reader *post_reader,",
            " \tgit_index *postimage,",
            " \tgit_diff *diff,",
            " \tconst git_apply_options *opts)",
            " {",
            "-\tgit_strmap *removed_paths;",
            "+\tgit_hashset_str removed_paths = GIT_HASHSET_INIT;",
            " \tsize_t i;",
            " \tint error = 0;",
            " ",
            "-\tif (git_strmap_new(&removed_paths) < 0)",
            "-\t\treturn -1;",
            "-",
            " \tfor (i = 0; i < git_diff_num_deltas(diff); i++) {",
            "-\t\tif ((error = apply_one(repo, pre_reader, preimage, post_reader, postimage, diff, removed_paths, i, opts)) < 0)",
            "+\t\tif ((error = apply_one(repo, pre_reader, preimage, post_reader, postimage, diff, &removed_paths, i, opts)) < 0)",
            " \t\t\tgoto done;",
            " \t}",
            " ",
            " done:",
            "-\tgit_strmap_free(removed_paths);",
            "+\tgit_hashset_str_dispose(&removed_paths);",
            " \treturn error;",
            " }",
            " ",
            " int git_apply_to_tree(",
            " \tgit_index **out,",
            " \tgit_repository *repo,",
            " \tgit_tree *preimage,",
            "@@ -711,30 +709,29 @@",
            " \t\t\tgoto done;",
            " ",
            " \t\tif (strcmp(delta->old_file.path, delta->new_file.path) &&",
            " \t\t    (error = git_vector_insert(&paths, (void *)delta->new_file.path)) < 0)",
            " \t\t\tgoto done;",
            " \t}",
            " ",
            "-\tcheckout_opts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            " \tcheckout_opts.checkout_strategy |= GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH;",
            " \tcheckout_opts.checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;",
            " ",
            " \tif (location == GIT_APPLY_LOCATION_WORKDIR)",
            " \t\tcheckout_opts.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;",
            " ",
            " \tcheckout_opts.paths.strings = (char **)paths.contents;",
            " \tcheckout_opts.paths.count = paths.length;",
            " ",
            " \tcheckout_opts.baseline_index = preimage;",
            " ",
            " \terror = git_checkout_index(repo, postimage, &checkout_opts);",
            " ",
            " done:",
            "-\tgit_vector_free(&paths);",
            "+\tgit_vector_dispose(&paths);",
            " \treturn error;",
            " }",
            " ",
            " static int git_apply__to_index(",
            " \tgit_repository *repo,",
            " \tgit_diff *diff,",
            " \tgit_index *preimage,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/attr.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/attr.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/attr.c",
            "@@ -9,14 +9,15 @@",
            " ",
            " #include \"repository.h\"",
            " #include \"sysdir.h\"",
            " #include \"config.h\"",
            " #include \"attr_file.h\"",
            " #include \"ignore.h\"",
            " #include \"git2/oid.h\"",
            "+#include \"hashmap_str.h\"",
            " #include <ctype.h>",
            " ",
            " const char *git_attr__true  = \"[internal]__TRUE__\";",
            " const char *git_attr__false = \"[internal]__FALSE__\";",
            " const char *git_attr__unset = \"[internal]__UNSET__\";",
            " ",
            " git_attr_value_t git_attr_value(const char *attr)",
            "@@ -250,54 +251,53 @@",
            " \tint error;",
            " \tgit_attr_path path;",
            " \tgit_vector files = GIT_VECTOR_INIT;",
            " \tsize_t i, j, k;",
            " \tgit_attr_file *file;",
            " \tgit_attr_rule *rule;",
            " \tgit_attr_assignment *assign;",
            "-\tgit_strmap *seen = NULL;",
            "+\tgit_hashset_str seen = GIT_HASHSET_INIT;",
            " \tgit_dir_flag dir_flag = GIT_DIR_FLAG_UNKNOWN;",
            " ",
            " \tGIT_ASSERT_ARG(repo);",
            " \tGIT_ASSERT_ARG(callback);",
            " \tGIT_ERROR_CHECK_VERSION(opts, GIT_ATTR_OPTIONS_VERSION, \"git_attr_options\");",
            " ",
            " \tif (git_repository_is_bare(repo))",
            " \t\tdir_flag = GIT_DIR_FLAG_FALSE;",
            " ",
            " \tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), dir_flag) < 0)",
            " \t\treturn -1;",
            " ",
            "-\tif ((error = collect_attr_files(repo, NULL, opts, pathname, &files)) < 0 ||",
            "-\t    (error = git_strmap_new(&seen)) < 0)",
            "+\tif ((error = collect_attr_files(repo, NULL, opts, pathname, &files)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tgit_vector_foreach(&files, i, file) {",
            " ",
            " \t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {",
            " ",
            " \t\t\tgit_vector_foreach(&rule->assigns, k, assign) {",
            " \t\t\t\t/* skip if higher priority assignment was already seen */",
            "-\t\t\t\tif (git_strmap_exists(seen, assign->name))",
            "+\t\t\t\tif (git_hashset_str_contains(&seen, assign->name))",
            " \t\t\t\t\tcontinue;",
            " ",
            "-\t\t\t\tif ((error = git_strmap_set(seen, assign->name, assign)) < 0)",
            "+\t\t\t\tif ((error = git_hashset_str_add(&seen, assign->name)) < 0)",
            " \t\t\t\t\tgoto cleanup;",
            " ",
            " \t\t\t\terror = callback(assign->name, assign->value, payload);",
            " \t\t\t\tif (error) {",
            " \t\t\t\t\tgit_error_set_after_callback(error);",
            " \t\t\t\t\tgoto cleanup;",
            " \t\t\t\t}",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            " cleanup:",
            "-\tgit_strmap_free(seen);",
            "+\tgit_hashset_str_dispose(&seen);",
            " \trelease_attr_files(&files);",
            " \tgit_attr_path__free(&path);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int preload_attr_source(",
            "@@ -380,14 +380,16 @@",
            " \tgit_attr_session *attr_session,",
            " \tgit_attr_options *opts)",
            " {",
            " \tgit_str system = GIT_STR_INIT, info = GIT_STR_INIT;",
            " \tgit_attr_file_source index_source = { GIT_ATTR_FILE_SOURCE_INDEX, NULL, GIT_ATTR_FILE, NULL };",
            " \tgit_attr_file_source head_source = { GIT_ATTR_FILE_SOURCE_HEAD, NULL, GIT_ATTR_FILE, NULL };",
            " \tgit_attr_file_source commit_source = { GIT_ATTR_FILE_SOURCE_COMMIT, NULL, GIT_ATTR_FILE, NULL };",
            "+\tgit_attr_cache *attrcache;",
            "+\tconst char *attr_cfg_file = NULL;",
            " \tgit_index *idx = NULL;",
            " \tconst char *workdir;",
            " \tint error = 0;",
            " ",
            " \tif (attr_session && attr_session->init_setup)",
            " \t\treturn 0;",
            " ",
            "@@ -403,16 +405,18 @@",
            " \t    (error = preload_attr_file(repo, attr_session, NULL, system.ptr)) < 0) {",
            " \t\tif (error != GIT_ENOTFOUND)",
            " \t\t\tgoto out;",
            " ",
            " \t\terror = 0;",
            " \t}",
            " ",
            "-\tif ((error = preload_attr_file(repo, attr_session, NULL,",
            "-\t                               git_repository_attr_cache(repo)->cfg_attr_file)) < 0)",
            "+\tif ((attrcache = git_repository_attr_cache(repo)) != NULL)",
            "+\t\tattr_cfg_file = git_attr_cache_attributesfile(attrcache);",
            "+",
            "+\tif ((error = preload_attr_file(repo, attr_session, NULL, attr_cfg_file)) < 0)",
            " \t\tgoto out;",
            " ",
            " \tif ((error = git_repository__item_path(&info, repo, GIT_REPOSITORY_ITEM_INFO)) < 0 ||",
            " \t    (error = preload_attr_file(repo, attr_session, info.ptr, GIT_ATTR_FILE_INREPO)) < 0) {",
            " \t\tif (error != GIT_ENOTFOUND)",
            " \t\t\tgoto out;",
            " ",
            "@@ -460,26 +464,28 @@",
            " int git_attr_add_macro(",
            " \tgit_repository *repo,",
            " \tconst char *name,",
            " \tconst char *values)",
            " {",
            " \tint error;",
            " \tgit_attr_rule *macro = NULL;",
            "+\tgit_attr_cache *attrcache;",
            " \tgit_pool *pool;",
            " ",
            " \tGIT_ASSERT_ARG(repo);",
            " \tGIT_ASSERT_ARG(name);",
            " ",
            " \tif ((error = git_attr_cache__init(repo)) < 0)",
            " \t\treturn error;",
            " ",
            " \tmacro = git__calloc(1, sizeof(git_attr_rule));",
            " \tGIT_ERROR_CHECK_ALLOC(macro);",
            " ",
            "-\tpool = &git_repository_attr_cache(repo)->pool;",
            "+\tattrcache = git_repository_attr_cache(repo);",
            "+\tpool = git_attr_cache_pool(attrcache);",
            " ",
            " \tmacro->match.pattern = git_pool_strdup(pool, name);",
            " \tGIT_ERROR_CHECK_ALLOC(macro->match.pattern);",
            " ",
            " \tmacro->match.length = strlen(macro->match.pattern);",
            " \tmacro->match.flags = GIT_ATTR_FNMATCH_MACRO;",
            " ",
            "@@ -614,27 +620,29 @@",
            " \tsize_t i;",
            " \tgit_attr_file *file;",
            " ",
            " \tgit_vector_foreach(files, i, file) {",
            " \t\tgit_attr_file__free(file);",
            " \t\tfiles->contents[i] = NULL;",
            " \t}",
            "-\tgit_vector_free(files);",
            "+\tgit_vector_dispose(files);",
            " }",
            " ",
            " static int collect_attr_files(",
            " \tgit_repository *repo,",
            " \tgit_attr_session *attr_session,",
            " \tgit_attr_options *opts,",
            " \tconst char *path,",
            " \tgit_vector *files)",
            " {",
            " \tint error = 0;",
            " \tgit_str dir = GIT_STR_INIT, attrfile = GIT_STR_INIT;",
            " \tconst char *workdir = git_repository_workdir(repo);",
            "+\tgit_attr_cache *attrcache;",
            "+\tconst char *attr_cfg_file = NULL;",
            " \tattr_walk_up_info info = { NULL };",
            " ",
            " \tGIT_ASSERT(!git_fs_path_is_absolute(path));",
            " ",
            " \tif ((error = attr_setup(repo, attr_session, opts)) < 0)",
            " \t\treturn error;",
            " ",
            "@@ -675,16 +683,21 @@",
            " \t\terror = push_one_attr(&info, \"\");",
            " \telse",
            " \t\terror = git_fs_path_walk_up(&dir, workdir, push_one_attr, &info);",
            " ",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            "-\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {",
            "-\t\terror = push_attr_file(repo, attr_session, files, NULL, git_repository_attr_cache(repo)->cfg_attr_file);",
            "+\tif ((attrcache = git_repository_attr_cache(repo)) != NULL)",
            "+\t\tattr_cfg_file = git_attr_cache_attributesfile(attrcache);",
            "+",
            "+",
            "+\tif (attr_cfg_file) {",
            "+\t\terror = push_attr_file(repo, attr_session, files, NULL, attr_cfg_file);",
            "+",
            " \t\tif (error < 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " ",
            " \tif (!opts || (opts->flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {",
            " \t\terror = system_attr_file(&dir, attr_session);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/attr_file.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/attr_file.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/attr_file.c",
            "@@ -65,15 +65,15 @@",
            " \tif (need_lock && git_mutex_lock(&file->lock) < 0) {",
            " \t\tgit_error_set(GIT_ERROR_OS, \"failed to lock attribute file\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tgit_vector_foreach(&file->rules, i, rule)",
            " \t\tgit_attr_rule__free(rule);",
            "-\tgit_vector_free(&file->rules);",
            "+\tgit_vector_dispose(&file->rules);",
            " ",
            " \tif (need_lock)",
            " \t\tgit_mutex_unlock(&file->lock);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "@@ -139,26 +139,29 @@",
            " \t\t\treturn error;",
            " ",
            " \t\t/* Do not assume that data straight from the ODB is NULL-terminated;",
            " \t\t * copy the contents of a file to a buffer to work on */",
            " \t\tblobsize = git_blob_rawsize(blob);",
            " ",
            " \t\tGIT_ERROR_CHECK_BLOBSIZE(blobsize);",
            "+\t\tif (blobsize > GIT_ATTR_MAX_FILE_SIZE) /* TODO: issue warning when warning API is available */",
            "+\t\t\tgoto cleanup;",
            " \t\tgit_str_put(&content, git_blob_rawcontent(blob), (size_t)blobsize);",
            " \t\tbreak;",
            " \t}",
            " \tcase GIT_ATTR_FILE_SOURCE_FILE: {",
            " \t\tint fd = -1;",
            " ",
            " \t\t/* For open or read errors, pretend that we got ENOTFOUND. */",
            " \t\t/* TODO: issue warning when warning API is available */",
            " ",
            " \t\tif (p_stat(entry->fullpath, &st) < 0 ||",
            " \t\t\tS_ISDIR(st.st_mode) ||",
            " \t\t\t(fd = git_futils_open_ro(entry->fullpath)) < 0 ||",
            "+\t\t\t(st.st_size > GIT_ATTR_MAX_FILE_SIZE) ||",
            " \t\t\t(error = git_futils_readbuffer_fd(&content, fd, (size_t)st.st_size)) < 0)",
            " \t\t\tnonexistent = true;",
            " ",
            " \t\tif (fd >= 0)",
            " \t\t\tp_close(fd);",
            " ",
            " \t\tbreak;",
            "@@ -194,14 +197,16 @@",
            " \t\t/*",
            " \t\t * Do not assume that data straight from the ODB is NULL-terminated;",
            " \t\t * copy the contents of a file to a buffer to work on.",
            " \t\t */",
            " \t\tblobsize = git_blob_rawsize(blob);",
            " ",
            " \t\tGIT_ERROR_CHECK_BLOBSIZE(blobsize);",
            "+\t\tif (blobsize > GIT_ATTR_MAX_FILE_SIZE) /* TODO: issue warning when warning API is available */",
            "+\t\t\tgoto cleanup;",
            " \t\tif ((error = git_str_put(&content,",
            " \t\t\tgit_blob_rawcontent(blob), (size_t)blobsize)) < 0)",
            " \t\t\tgoto cleanup;",
            " ",
            " \t\tbreak;",
            " \t}",
            " \tdefault:",
            "@@ -338,15 +343,15 @@",
            " \tconst char *pattern);",
            " ",
            " int git_attr_file__parse_buffer(",
            " \tgit_repository *repo, git_attr_file *attrs, const char *data, bool allow_macros)",
            " {",
            " \tconst char *scan = data, *context = NULL;",
            " \tgit_attr_rule *rule = NULL;",
            "-\tint error = 0;",
            "+\tint ignorecase = 0, error = 0;",
            " ",
            " \t/* If subdir file path, convert context for file paths */",
            " \tif (attrs->entry && git_fs_path_root(attrs->entry->path) < 0 &&",
            " \t    !git__suffixcmp(attrs->entry->path, \"/\" GIT_ATTR_FILE))",
            " \t\tcontext = attrs->entry->path;",
            " ",
            " \tif (git_mutex_lock(&attrs->lock) < 0) {",
            "@@ -370,14 +375,21 @@",
            " \t\t{",
            " \t\t\tif (error != GIT_ENOTFOUND)",
            " \t\t\t\tgoto out;",
            " \t\t\terror = 0;",
            " \t\t\tcontinue;",
            " \t\t}",
            " ",
            "+\t\tif (repo &&",
            "+\t\t    (error = git_repository__configmap_lookup(&ignorecase, repo, GIT_CONFIGMAP_IGNORECASE)) < 0)",
            "+\t\t\tgoto out;",
            "+",
            "+\t\tif (ignorecase)",
            "+\t\t\trule->match.flags |= GIT_ATTR_FNMATCH_ICASE;",
            "+",
            " \t\tif (rule->match.flags & GIT_ATTR_FNMATCH_MACRO) {",
            " \t\t\t/* TODO: warning if macro found in file below repo root */",
            " \t\t\tif (!allow_macros)",
            " \t\t\t\tcontinue;",
            " \t\t\tif ((error = git_attr_cache__insert_macro(repo, rule)) < 0)",
            " \t\t\t\tgoto out;",
            " \t\t} else if ((error = git_vector_insert(&attrs->rules, rule)) < 0)",
            "@@ -473,15 +485,15 @@",
            " \t/*",
            " \t * If the rule was generated in a subdirectory, we must only",
            " \t * use it for paths inside that directory. We can thus return",
            " \t * a non-match if the prefixes don't match.",
            " \t */",
            " \tif (match->containing_dir) {",
            " \t\tif (match->flags & GIT_ATTR_FNMATCH_ICASE) {",
            "-\t\t\tif (git__strncasecmp(path->path, match->containing_dir, match->containing_dir_length))",
            "+\t\t\tif (git__prefixcmp_icase(path->path, match->containing_dir))",
            " \t\t\t\treturn 0;",
            " \t\t} else {",
            " \t\t\tif (git__prefixcmp(path->path, match->containing_dir))",
            " \t\t\t\treturn 0;",
            " \t\t}",
            " ",
            " \t\trelpath += match->containing_dir_length;",
            "@@ -987,15 +999,15 @@",
            " ",
            " \tif (!rule)",
            " \t\treturn;",
            " ",
            " \tif (!(rule->match.flags & GIT_ATTR_FNMATCH_IGNORE)) {",
            " \t\tgit_vector_foreach(&rule->assigns, i, assign)",
            " \t\t\tGIT_REFCOUNT_DEC(assign, git_attr_assignment__free);",
            "-\t\tgit_vector_free(&rule->assigns);",
            "+\t\tgit_vector_dispose(&rule->assigns);",
            " \t}",
            " ",
            " \t/* match.pattern is stored in a git_pool, so no need to free */",
            " \trule->match.pattern = NULL;",
            " \trule->match.length = 0;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/attr_file.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/attr_file.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/attr_file.h",
            "@@ -17,14 +17,16 @@",
            " #include \"futils.h\"",
            " ",
            " #define GIT_ATTR_FILE\t\t\t\".gitattributes\"",
            " #define GIT_ATTR_FILE_INREPO\t\"attributes\"",
            " #define GIT_ATTR_FILE_SYSTEM\t\"gitattributes\"",
            " #define GIT_ATTR_FILE_XDG\t\t\"attributes\"",
            " ",
            "+#define GIT_ATTR_MAX_FILE_SIZE\t100 * 1024 * 1024",
            "+",
            " #define GIT_ATTR_FNMATCH_NEGATIVE\t(1U << 0)",
            " #define GIT_ATTR_FNMATCH_DIRECTORY\t(1U << 1)",
            " #define GIT_ATTR_FNMATCH_FULLPATH\t(1U << 2)",
            " #define GIT_ATTR_FNMATCH_MACRO\t\t(1U << 3)",
            " #define GIT_ATTR_FNMATCH_IGNORE\t\t(1U << 4)",
            " #define GIT_ATTR_FNMATCH_HASWILD\t(1U << 5)",
            " #define GIT_ATTR_FNMATCH_ALLOWSPACE\t(1U << 6)"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/attrcache.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/attrcache.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/attrcache.c",
            "@@ -9,14 +9,46 @@",
            " ",
            " #include \"repository.h\"",
            " #include \"attr_file.h\"",
            " #include \"config.h\"",
            " #include \"sysdir.h\"",
            " #include \"ignore.h\"",
            " #include \"path.h\"",
            "+#include \"hashmap_str.h\"",
            "+",
            "+GIT_HASHMAP_STR_SETUP(git_attr_cache_filemap, git_attr_file_entry *);",
            "+GIT_HASHMAP_STR_SETUP(git_attr_cache_macromap, git_attr_rule *);",
            "+",
            "+struct git_attr_cache {",
            "+\tchar *cfg_attr_file; /* cached value of core.attributesfile */",
            "+\tchar *cfg_excl_file; /* cached value of core.excludesfile */",
            "+",
            "+\t/* hash path to git_attr_file_entry records */",
            "+\tgit_attr_cache_filemap files;",
            "+\t/* hash name to git_attr_rule */",
            "+\tgit_attr_cache_macromap macros;",
            "+",
            "+\tgit_mutex lock;",
            "+\tgit_pool  pool;",
            "+};",
            "+",
            "+const char *git_attr_cache_attributesfile(git_attr_cache *cache)",
            "+{",
            "+\treturn cache->cfg_attr_file;",
            "+}",
            "+",
            "+const char *git_attr_cache_excludesfile(git_attr_cache *cache)",
            "+{",
            "+\treturn cache->cfg_excl_file;",
            "+}",
            "+",
            "+git_pool *git_attr_cache_pool(git_attr_cache *cache)",
            "+{",
            "+\treturn &cache->pool;",
            "+}",
            " ",
            " GIT_INLINE(int) attr_cache_lock(git_attr_cache *cache)",
            " {",
            " \tGIT_UNUSED(cache); /* avoid warning if threading is off */",
            " ",
            " \tif (git_mutex_lock(&cache->lock) < 0) {",
            " \t\tgit_error_set(GIT_ERROR_OS, \"unable to get attr cache lock\");",
            "@@ -30,15 +62,20 @@",
            " \tGIT_UNUSED(cache); /* avoid warning if threading is off */",
            " \tgit_mutex_unlock(&cache->lock);",
            " }",
            " ",
            " GIT_INLINE(git_attr_file_entry *) attr_cache_lookup_entry(",
            " \tgit_attr_cache *cache, const char *path)",
            " {",
            "-\treturn git_strmap_get(cache->files, path);",
            "+\tgit_attr_file_entry *result;",
            "+",
            "+\tif (git_attr_cache_filemap_get(&result, &cache->files, path) == 0)",
            "+\t\treturn result;",
            "+",
            "+\treturn NULL;",
            " }",
            " ",
            " int git_attr_cache__alloc_file_entry(",
            " \tgit_attr_file_entry **out,",
            " \tgit_repository *repo,",
            " \tconst char *base,",
            " \tconst char *path,",
            "@@ -88,15 +125,15 @@",
            " \tgit_attr_file_entry *entry = NULL;",
            " \tint error;",
            " ",
            " \tif ((error = git_attr_cache__alloc_file_entry(&entry, repo,",
            " \t\tgit_repository_workdir(repo), path, &cache->pool)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tif ((error = git_strmap_set(cache->files, entry->path, entry)) < 0)",
            "+\tif ((error = git_attr_cache_filemap_put(&cache->files, entry->path, entry)) < 0)",
            " \t\treturn error;",
            " ",
            " \t*out = entry;",
            " \treturn error;",
            " }",
            " ",
            " /* insert entry or replace existing if we raced with another thread */",
            "@@ -267,20 +304,19 @@",
            " bool git_attr_cache__is_cached(",
            " \tgit_repository *repo,",
            " \tgit_attr_file_source_t source_type,",
            " \tconst char *filename)",
            " {",
            " \tgit_attr_cache *cache = git_repository_attr_cache(repo);",
            " \tgit_attr_file_entry *entry;",
            "-\tgit_strmap *files;",
            " ",
            "-\tif (!cache || !(files = cache->files))",
            "+\tif (!cache)",
            " \t\treturn false;",
            " ",
            "-\tif ((entry = git_strmap_get(files, filename)) == NULL)",
            "+\tif (git_attr_cache_filemap_get(&entry, &cache->files, filename) != 0)",
            " \t\treturn false;",
            " ",
            " \treturn entry && (entry->file[source_type] != NULL);",
            " }",
            " ",
            " ",
            " static int attr_cache__lookup_path(",
            "@@ -314,45 +350,42 @@",
            " \tgit_str_dispose(&buf);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static void attr_cache__free(git_attr_cache *cache)",
            " {",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            "+\tgit_attr_rule *rule;",
            "+\tgit_attr_file_entry *entry;",
            " \tbool unlock;",
            " ",
            " \tif (!cache)",
            " \t\treturn;",
            " ",
            " \tunlock = (attr_cache_lock(cache) == 0);",
            " ",
            "-\tif (cache->files != NULL) {",
            "-\t\tgit_attr_file_entry *entry;",
            "+\twhile (git_attr_cache_filemap_iterate(&iter, NULL, &entry, &cache->files) == 0) {",
            " \t\tgit_attr_file *file;",
            "-\t\tint i;",
            "+\t\tsize_t i;",
            " ",
            "-\t\tgit_strmap_foreach_value(cache->files, entry, {",
            "-\t\t\tfor (i = 0; i < GIT_ATTR_FILE_NUM_SOURCES; ++i) {",
            "-\t\t\t\tif ((file = git_atomic_swap(entry->file[i], NULL)) != NULL) {",
            "-\t\t\t\t\tGIT_REFCOUNT_OWN(file, NULL);",
            "-\t\t\t\t\tgit_attr_file__free(file);",
            "-\t\t\t\t}",
            "+\t\tfor (i = 0; i < GIT_ATTR_FILE_NUM_SOURCES; i++) {",
            "+\t\t\tif ((file = git_atomic_swap(entry->file[i], NULL)) != NULL) {",
            "+\t\t\t\tGIT_REFCOUNT_OWN(file, NULL);",
            "+\t\t\t\tgit_attr_file__free(file);",
            " \t\t\t}",
            "-\t\t});",
            "-\t\tgit_strmap_free(cache->files);",
            "+\t\t}",
            " \t}",
            " ",
            "-\tif (cache->macros != NULL) {",
            "-\t\tgit_attr_rule *rule;",
            "+\titer = GIT_HASHMAP_ITER_INIT;",
            "+\twhile (git_attr_cache_macromap_iterate(&iter, NULL, &rule, &cache->macros) == 0)",
            "+\t\tgit_attr_rule__free(rule);",
            " ",
            "-\t\tgit_strmap_foreach_value(cache->macros, rule, {",
            "-\t\t\tgit_attr_rule__free(rule);",
            "-\t\t});",
            "-\t\tgit_strmap_free(cache->macros);",
            "-\t}",
            "+\tgit_attr_cache_filemap_dispose(&cache->files);",
            "+\tgit_attr_cache_macromap_dispose(&cache->macros);",
            " ",
            " \tgit_pool_clear(&cache->pool);",
            " ",
            " \tgit__free(cache->cfg_attr_file);",
            " \tcache->cfg_attr_file = NULL;",
            " ",
            " \tgit__free(cache->cfg_excl_file);",
            "@@ -397,17 +430,15 @@",
            " \t\t&cache->cfg_excl_file, cfg, GIT_IGNORE_CONFIG, GIT_IGNORE_FILE_XDG);",
            " \tif (ret < 0)",
            " \t\tgoto cancel;",
            " ",
            " \t/* allocate hashtable for attribute and ignore file contents,",
            " \t * hashtable for attribute macros, and string pool",
            " \t */",
            "-\tif ((ret = git_strmap_new(&cache->files)) < 0 ||",
            "-\t    (ret = git_strmap_new(&cache->macros)) < 0 ||",
            "-\t    (ret = git_pool_init(&cache->pool, 1)) < 0)",
            "+\tif ((ret = git_pool_init(&cache->pool, 1)) < 0)",
            " \t\tgoto cancel;",
            " ",
            " \tif (git_atomic_compare_and_swap(&repo->attrcache, NULL, cache) != NULL)",
            " \t\tgoto cancel; /* raced with another thread, free this but no error */",
            " ",
            " \tgit_config_free(cfg);",
            " ",
            "@@ -453,26 +484,31 @@",
            " \t\tgoto out;",
            " \t}",
            " ",
            " \tif ((error = attr_cache_lock(cache)) < 0)",
            " \t\tgoto out;",
            " \tlocked = true;",
            " ",
            "-\tif ((preexisting = git_strmap_get(cache->macros, macro->match.pattern)) != NULL)",
            "-\t    git_attr_rule__free(preexisting);",
            "+\tif (git_attr_cache_macromap_get(&preexisting, &cache->macros, macro->match.pattern) == 0)",
            "+\t\tgit_attr_rule__free(preexisting);",
            " ",
            "-\tif ((error = git_strmap_set(cache->macros, macro->match.pattern, macro)) < 0)",
            "-\t    goto out;",
            "+\tif ((error = git_attr_cache_macromap_put(&cache->macros, macro->match.pattern, macro)) < 0)",
            "+\t\tgoto out;",
            " ",
            " out:",
            " \tif (locked)",
            " \t\tattr_cache_unlock(cache);",
            " \treturn error;",
            " }",
            " ",
            " git_attr_rule *git_attr_cache__lookup_macro(",
            " \tgit_repository *repo, const char *name)",
            " {",
            "-\tgit_strmap *macros = git_repository_attr_cache(repo)->macros;",
            "+\tgit_attr_cache *cache = git_repository_attr_cache(repo);",
            "+\tgit_attr_rule *rule;",
            "+",
            "+\tif (!cache ||",
            "+\t    git_attr_cache_macromap_get(&rule, &cache->macros, name) != 0)",
            "+\t\treturn NULL;",
            " ",
            "-\treturn git_strmap_get(macros, name);",
            "+\treturn rule;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/attrcache.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/attrcache.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/attrcache.h",
            "@@ -6,30 +6,26 @@",
            "  */",
            " #ifndef INCLUDE_attrcache_h__",
            " #define INCLUDE_attrcache_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"attr_file.h\"",
            "-#include \"strmap.h\"",
            " ",
            " #define GIT_ATTR_CONFIG       \"core.attributesfile\"",
            " #define GIT_IGNORE_CONFIG     \"core.excludesfile\"",
            " ",
            "-typedef struct {",
            "-\tchar *cfg_attr_file; /* cached value of core.attributesfile */",
            "-\tchar *cfg_excl_file; /* cached value of core.excludesfile */",
            "-\tgit_strmap *files;\t /* hash path to git_attr_cache_entry records */",
            "-\tgit_strmap *macros;\t /* hash name to vector<git_attr_assignment> */",
            "-\tgit_mutex lock;",
            "-\tgit_pool  pool;",
            "-} git_attr_cache;",
            "+typedef struct git_attr_cache git_attr_cache;",
            " ",
            " extern int git_attr_cache__init(git_repository *repo);",
            " ",
            "+extern const char *git_attr_cache_attributesfile(git_attr_cache *ac);",
            "+extern const char *git_attr_cache_excludesfile(git_attr_cache *ac);",
            "+extern git_pool *git_attr_cache_pool(git_attr_cache *ac);",
            "+",
            " /* get file - loading and reload as needed */",
            " extern int git_attr_cache__get(",
            " \tgit_attr_file **file,",
            " \tgit_repository *repo,",
            " \tgit_attr_session *attr_session,",
            " \tgit_attr_file_source *source,",
            " \tgit_attr_file_parser parser,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/blame.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/blame.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/blame.c",
            "@@ -15,15 +15,14 @@",
            " #include \"git2/blob.h\"",
            " #include \"git2/signature.h\"",
            " #include \"git2/mailmap.h\"",
            " #include \"util.h\"",
            " #include \"repository.h\"",
            " #include \"blame_git.h\"",
            " ",
            "-",
            " static int hunk_byfinalline_search_cmp(const void *key, const void *entry)",
            " {",
            " \tgit_blame_hunk *hunk = (git_blame_hunk*)entry;",
            " ",
            " \tsize_t lineno = *(size_t*)key;",
            " \tsize_t lines_in_hunk = hunk->lines_in_hunk;",
            " \tsize_t final_start_line_number = hunk->final_start_line_number;",
            "@@ -77,17 +76,20 @@",
            " \tgit_oid_clear(&hunk->final_commit_id, blame->repository->oid_type);",
            " ",
            " \treturn hunk;",
            " }",
            " ",
            " static void free_hunk(git_blame_hunk *hunk)",
            " {",
            "-\tgit__free((void*)hunk->orig_path);",
            "+\tgit__free((char *)hunk->orig_path);",
            "+\tgit__free((char *)hunk->summary);",
            " \tgit_signature_free(hunk->final_signature);",
            "+\tgit_signature_free(hunk->final_committer);",
            " \tgit_signature_free(hunk->orig_signature);",
            "+\tgit_signature_free(hunk->orig_committer);",
            " \tgit__free(hunk);",
            " }",
            " ",
            " static git_blame_hunk *dup_hunk(git_blame_hunk *hunk, git_blame *blame)",
            " {",
            " \tgit_blame_hunk *newhunk = new_hunk(",
            " \t\t\thunk->final_start_line_number,",
            "@@ -100,15 +102,18 @@",
            " \t\treturn NULL;",
            " ",
            " \tgit_oid_cpy(&newhunk->orig_commit_id, &hunk->orig_commit_id);",
            " \tgit_oid_cpy(&newhunk->final_commit_id, &hunk->final_commit_id);",
            " \tnewhunk->boundary = hunk->boundary;",
            " ",
            " \tif (git_signature_dup(&newhunk->final_signature, hunk->final_signature) < 0 ||",
            "-\t\tgit_signature_dup(&newhunk->orig_signature, hunk->orig_signature) < 0) {",
            "+\t    git_signature_dup(&newhunk->final_committer, hunk->final_committer) < 0 ||",
            "+\t    git_signature_dup(&newhunk->orig_signature, hunk->orig_signature) < 0 ||",
            "+\t    git_signature_dup(&newhunk->orig_committer, hunk->orig_committer) < 0 ||",
            "+\t    (newhunk->summary = git__strdup(hunk->summary)) == NULL) {",
            " \t\tfree_hunk(newhunk);",
            " \t\treturn NULL;",
            " \t}",
            " ",
            " \treturn newhunk;",
            " }",
            " ",
            "@@ -135,18 +140,17 @@",
            " \tif (!gbr)",
            " \t\treturn NULL;",
            " ",
            " \tgbr->repository = repo;",
            " \tgbr->options = opts;",
            " ",
            " \tif (git_vector_init(&gbr->hunks, 8, hunk_cmp) < 0 ||",
            "-\t\tgit_vector_init(&gbr->paths, 8, paths_cmp) < 0 ||",
            "-\t\t(gbr->path = git__strdup(path)) == NULL ||",
            "-\t\tgit_vector_insert(&gbr->paths, git__strdup(path)) < 0)",
            "-\t{",
            "+\t    git_vector_init(&gbr->paths, 8, paths_cmp) < 0 ||",
            "+\t    (gbr->path = git__strdup(path)) == NULL ||",
            "+\t    git_vector_insert(&gbr->paths, git__strdup(path)) < 0) {",
            " \t\tgit_blame_free(gbr);",
            " \t\treturn NULL;",
            " \t}",
            " ",
            " \tif (opts.flags & GIT_BLAME_USE_MAILMAP &&",
            " \t    git_mailmap_from_repository(&gbr->mailmap, repo) < 0) {",
            " \t\tgit_blame_free(gbr);",
            "@@ -161,51 +165,98 @@",
            " \tsize_t i;",
            " \tgit_blame_hunk *hunk;",
            " ",
            " \tif (!blame) return;",
            " ",
            " \tgit_vector_foreach(&blame->hunks, i, hunk)",
            " \t\tfree_hunk(hunk);",
            "-\tgit_vector_free(&blame->hunks);",
            " ",
            "-\tgit_vector_free_deep(&blame->paths);",
            "+\tgit_vector_dispose(&blame->hunks);",
            "+\tgit_array_clear(blame->lines);",
            "+",
            "+\tgit_vector_dispose_deep(&blame->paths);",
            " ",
            " \tgit_array_clear(blame->line_index);",
            " ",
            " \tgit_mailmap_free(blame->mailmap);",
            " ",
            " \tgit__free(blame->path);",
            " \tgit_blob_free(blame->final_blob);",
            " \tgit__free(blame);",
            " }",
            " ",
            "-uint32_t git_blame_get_hunk_count(git_blame *blame)",
            "+size_t git_blame_hunkcount(git_blame *blame)",
            " {",
            " \tGIT_ASSERT_ARG(blame);",
            "-\treturn (uint32_t)blame->hunks.length;",
            "+",
            "+\treturn blame->hunks.length;",
            "+}",
            "+",
            "+size_t git_blame_linecount(git_blame *blame)",
            "+{",
            "+\tGIT_ASSERT_ARG(blame);",
            "+",
            "+\treturn git_array_size(blame->line_index);",
            "+}",
            "+",
            "+const git_blame_line *git_blame_line_byindex(",
            "+\tgit_blame *blame,",
            "+\tsize_t idx)",
            "+{",
            "+\tGIT_ASSERT_ARG_WITH_RETVAL(blame, NULL);",
            "+\tGIT_ASSERT_WITH_RETVAL(idx > 0 && idx <= git_array_size(blame->line_index), NULL);",
            "+",
            "+\treturn git_array_get(blame->lines, idx - 1);",
            " }",
            " ",
            "-const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, uint32_t index)",
            "+const git_blame_hunk *git_blame_hunk_byindex(",
            "+\tgit_blame *blame,",
            "+\tsize_t index)",
            " {",
            " \tGIT_ASSERT_ARG_WITH_RETVAL(blame, NULL);",
            "-\treturn (git_blame_hunk*)git_vector_get(&blame->hunks, index);",
            "+\treturn git_vector_get(&blame->hunks, index);",
            " }",
            " ",
            "-const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, size_t lineno)",
            "+const git_blame_hunk *git_blame_hunk_byline(",
            "+\tgit_blame *blame,",
            "+\tsize_t lineno)",
            " {",
            " \tsize_t i, new_lineno = lineno;",
            " ",
            " \tGIT_ASSERT_ARG_WITH_RETVAL(blame, NULL);",
            " ",
            "-\tif (!git_vector_bsearch2(&i, &blame->hunks, hunk_byfinalline_search_cmp, &new_lineno)) {",
            "-\t\treturn git_blame_get_hunk_byindex(blame, (uint32_t)i);",
            "-\t}",
            "+\tif (git_vector_bsearch2(&i, &blame->hunks,",
            "+\t\t\thunk_byfinalline_search_cmp, &new_lineno) != 0)",
            "+\t\treturn NULL;",
            "+",
            "+\treturn git_blame_hunk_byindex(blame, i);",
            "+}",
            "+",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+uint32_t git_blame_get_hunk_count(git_blame *blame)",
            "+{",
            "+\tsize_t count = git_blame_hunkcount(blame);",
            "+\tGIT_ASSERT(count < UINT32_MAX);",
            "+\treturn (uint32_t)count;",
            "+}",
            "+",
            "+const git_blame_hunk *git_blame_get_hunk_byindex(",
            "+\tgit_blame *blame,",
            "+\tuint32_t index)",
            "+{",
            "+\treturn git_blame_hunk_byindex(blame, index);",
            "+}",
            " ",
            "-\treturn NULL;",
            "+const git_blame_hunk *git_blame_get_hunk_byline(",
            "+\tgit_blame *blame,",
            "+\tsize_t lineno)",
            "+{",
            "+\treturn git_blame_hunk_byline(blame, lineno);",
            " }",
            "+#endif",
            " ",
            " static int normalize_options(",
            " \t\tgit_blame_options *out,",
            " \t\tconst git_blame_options *in,",
            " \t\tgit_repository *repo)",
            " {",
            " \tgit_blame_options dummy = GIT_BLAME_OPTIONS_INIT;",
            "@@ -278,51 +329,85 @@",
            "  * https://github.com/gitster/git/blob/be5c9fb9049ed470e7005f159bb923a5f4de1309/builtin/blame.c#L1760-L1789",
            "  */",
            " static int index_blob_lines(git_blame *blame)",
            " {",
            "     const char *buf = blame->final_buf;",
            "     size_t len = blame->final_buf_size;",
            "     int num = 0, incomplete = 0, bol = 1;",
            "+    git_blame_line *line = NULL;",
            "     size_t *i;",
            " ",
            "     if (len && buf[len-1] != '\\n')",
            "         incomplete++; /* incomplete line at the end */",
            "+",
            "     while (len--) {",
            "         if (bol) {",
            "             i = git_array_alloc(blame->line_index);",
            "             GIT_ERROR_CHECK_ALLOC(i);",
            "             *i = buf - blame->final_buf;",
            "+",
            "+            GIT_ASSERT(line == NULL);",
            "+            line = git_array_alloc(blame->lines);",
            "+            GIT_ERROR_CHECK_ALLOC(line);",
            "+",
            "+            line->ptr = buf;",
            "             bol = 0;",
            "         }",
            "+",
            "         if (*buf++ == '\\n') {",
            "+            GIT_ASSERT(line);",
            "+            line->len = (buf - line->ptr) - 1;",
            "+            line = NULL;",
            "+",
            "             num++;",
            "             bol = 1;",
            "         }",
            "     }",
            "+",
            "     i = git_array_alloc(blame->line_index);",
            "     GIT_ERROR_CHECK_ALLOC(i);",
            "     *i = buf - blame->final_buf;",
            "+",
            "+    if (!bol) {",
            "+        GIT_ASSERT(line);",
            "+        line->len = buf - line->ptr;",
            "+\tline = NULL;",
            "+    }",
            "+",
            "+    GIT_ASSERT(!line);",
            "+",
            "     blame->num_lines = num + incomplete;",
            "     return blame->num_lines;",
            " }",
            " ",
            " static git_blame_hunk *hunk_from_entry(git_blame__entry *e, git_blame *blame)",
            " {",
            "+\tconst char *summary;",
            " \tgit_blame_hunk *h = new_hunk(",
            " \t\te->lno+1, e->num_lines, e->s_lno+1, e->suspect->path,",
            " \t\tblame);",
            " ",
            " \tif (!h)",
            " \t\treturn NULL;",
            " ",
            " \tgit_oid_cpy(&h->final_commit_id, git_commit_id(e->suspect->commit));",
            " \tgit_oid_cpy(&h->orig_commit_id, git_commit_id(e->suspect->commit));",
            "-\tgit_commit_author_with_mailmap(",
            "-\t\t&h->final_signature, e->suspect->commit, blame->mailmap);",
            "-\tgit_signature_dup(&h->orig_signature, h->final_signature);",
            "+",
            "+\tif (git_commit_author_with_mailmap(",
            "+\t\t&h->final_signature, e->suspect->commit, blame->mailmap) < 0 ||",
            "+\t    git_commit_committer_with_mailmap(",
            "+\t\t&h->final_committer, e->suspect->commit, blame->mailmap) < 0 ||",
            "+\t    git_signature_dup(&h->orig_signature, h->final_signature) < 0 ||",
            "+\t    git_signature_dup(&h->orig_committer, h->final_committer) < 0 ||",
            "+\t    (summary = git_commit_summary(e->suspect->commit)) == NULL ||",
            "+\t    (h->summary = git__strdup(summary)) == NULL) {",
            "+\t\tfree_hunk(h);",
            "+\t\treturn NULL;",
            "+\t}",
            "+",
            " \th->boundary = e->is_boundary ? 1 : 0;",
            " \treturn h;",
            " }",
            " ",
            " static int load_blob(git_blame *blame)",
            " {",
            " \tint error;",
            "@@ -343,20 +428,20 @@",
            " {",
            " \tint error;",
            " \tgit_blame__entry *ent = NULL;",
            " \tgit_blame__origin *o;",
            " ",
            " \tif ((error = load_blob(blame)) < 0 ||",
            " \t    (error = git_blame__get_origin(&o, blame, blame->final, blame->path)) < 0)",
            "-\t\tgoto cleanup;",
            "+\t\tgoto on_error;",
            " ",
            " \tif (git_blob_rawsize(blame->final_blob) > SIZE_MAX) {",
            " \t\tgit_error_set(GIT_ERROR_NOMEMORY, \"blob is too large to blame\");",
            " \t\terror = -1;",
            "-\t\tgoto cleanup;",
            "+\t\tgoto on_error;",
            " \t}",
            " ",
            " \tblame->final_buf = git_blob_rawcontent(blame->final_blob);",
            " \tblame->final_buf_size = (size_t)git_blob_rawsize(blame->final_blob);",
            " ",
            " \tent = git__calloc(1, sizeof(git_blame__entry));",
            " \tGIT_ERROR_CHECK_ALLOC(ent);",
            "@@ -367,25 +452,27 @@",
            " \tif (blame->options.max_line > 0)",
            " \t\tent->num_lines = blame->options.max_line - blame->options.min_line + 1;",
            " \tent->s_lno = ent->lno;",
            " \tent->suspect = o;",
            " ",
            " \tblame->ent = ent;",
            " ",
            "-\terror = git_blame__like_git(blame, blame->options.flags);",
            "+\tif ((error = git_blame__like_git(blame, blame->options.flags)) < 0)",
            "+\t\tgoto on_error;",
            " ",
            "-cleanup:",
            "-\tfor (ent = blame->ent; ent; ) {",
            "-\t\tgit_blame__entry *e = ent->next;",
            "+\tfor (ent = blame->ent; ent; ent = ent->next) {",
            " \t\tgit_blame_hunk *h = hunk_from_entry(ent, blame);",
            "-",
            " \t\tgit_vector_insert(&blame->hunks, h);",
            "+\t}",
            " ",
            "+on_error:",
            "+\tfor (ent = blame->ent; ent; ) {",
            "+\t\tgit_blame__entry *next = ent->next;",
            " \t\tgit_blame__free_entry(ent);",
            "-\t\tent = e;",
            "+\t\tent = next;",
            " \t}",
            " ",
            " \treturn error;",
            " }",
            " ",
            " /*******************************************************************************",
            "  * File blaming",
            "@@ -440,17 +527,17 @@",
            " \tvoid *payload)",
            " {",
            " \tgit_blame *blame = (git_blame*)payload;",
            " \tuint32_t wedge_line;",
            " ",
            " \tGIT_UNUSED(delta);",
            " ",
            "-\twedge_line = (hunk->new_start >= hunk->old_start || hunk->old_lines==0) ? hunk->new_start : hunk->old_start; ",
            "+\twedge_line = (hunk->new_start >= hunk->old_start || hunk->old_lines==0) ? hunk->new_start : hunk->old_start;",
            " \tblame->current_diff_line = wedge_line;",
            "-\tblame->current_hunk = (git_blame_hunk*)git_blame_get_hunk_byline(blame, wedge_line);",
            "+\tblame->current_hunk = (git_blame_hunk*)git_blame_hunk_byline(blame, wedge_line);",
            " \tif (!blame->current_hunk) {",
            " \t\t/* Line added at the end of the file */",
            " \t\tblame->current_hunk = new_hunk(wedge_line, 0, wedge_line,",
            " \t\t\tblame->path, blame);",
            " \t\tblame->current_diff_line++;",
            " \t\tGIT_ERROR_CHECK_ALLOC(blame->current_hunk);",
            " \t\tgit_vector_insert(&blame->hunks, blame->current_hunk);",
            "@@ -500,16 +587,16 @@",
            " ",
            " \t\tif (--(blame->current_hunk->lines_in_hunk) == 0) {",
            " \t\t\tsize_t i;",
            " \t\t\tsize_t i_next;",
            " \t\t\tif (!git_vector_search2(&i, &blame->hunks, ptrs_equal_cmp, blame->current_hunk)) {",
            " \t\t\t\tgit_vector_remove(&blame->hunks, i);",
            " \t\t\t\tfree_hunk(blame->current_hunk);",
            "-\t\t\t\ti_next = min( i , blame->hunks.length -1); ",
            "-\t\t\t\tblame->current_hunk = (git_blame_hunk*)git_blame_get_hunk_byindex(blame, (uint32_t)i_next);",
            "+\t\t\t\ti_next = min( i , blame->hunks.length -1);",
            "+\t\t\t\tblame->current_hunk = (git_blame_hunk*)git_blame_hunk_byindex(blame, (uint32_t)i_next);",
            " \t\t\t}",
            " \t\t}",
            " \t\tshift_hunks_by(&blame->hunks, shift_base, -1);",
            " \t}",
            " \treturn 0;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/blame.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/blame.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/blame.h",
            "@@ -67,14 +67,15 @@",
            " struct git_blame {",
            " \tchar *path;",
            " \tgit_repository *repository;",
            " \tgit_mailmap *mailmap;",
            " \tgit_blame_options options;",
            " ",
            " \tgit_vector hunks;",
            "+\tgit_array_t(git_blame_line) lines;",
            " \tgit_vector paths;",
            " ",
            " \tgit_blob *final_blob;",
            " \tgit_array_t(size_t) line_index;",
            " ",
            " \tsize_t current_diff_line;",
            " \tgit_blame_hunk *current_hunk;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/cache.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/cache.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/cache.c",
            "@@ -10,14 +10,17 @@",
            " #include \"repository.h\"",
            " #include \"commit.h\"",
            " #include \"thread.h\"",
            " #include \"util.h\"",
            " #include \"odb.h\"",
            " #include \"object.h\"",
            " #include \"git2/oid.h\"",
            "+#include \"hashmap_oid.h\"",
            "+",
            "+GIT_HASHMAP_OID_FUNCTIONS(git_cache_oidmap, GIT_HASHMAP_INLINE, git_cached_obj *);",
            " ",
            " bool git_cache__enabled = true;",
            " ssize_t git_cache__max_storage = (256 * 1024 * 1024);",
            " git_atomic_ssize git_cache__current_storage = {0};",
            " ",
            " static size_t git_cache__max_object_size[8] = {",
            " \t0,     /* GIT_OBJECT__EXT1 */",
            "@@ -41,86 +44,88 @@",
            " \treturn 0;",
            " }",
            " ",
            " int git_cache_init(git_cache *cache)",
            " {",
            " \tmemset(cache, 0, sizeof(*cache));",
            " ",
            "-\tif ((git_oidmap_new(&cache->map)) < 0)",
            "-\t\treturn -1;",
            "-",
            " \tif (git_rwlock_init(&cache->lock)) {",
            " \t\tgit_error_set(GIT_ERROR_OS, \"failed to initialize cache rwlock\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " /* called with lock */",
            " static void clear_cache(git_cache *cache)",
            " {",
            " \tgit_cached_obj *evict = NULL;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tif (git_cache_size(cache) == 0)",
            " \t\treturn;",
            " ",
            "-\tgit_oidmap_foreach_value(cache->map, evict, {",
            "+\twhile (git_cache_oidmap_iterate(&iter, NULL, &evict, &cache->map) == 0)",
            " \t\tgit_cached_obj_decref(evict);",
            "-\t});",
            " ",
            "-\tgit_oidmap_clear(cache->map);",
            "+\tgit_cache_oidmap_clear(&cache->map);",
            " \tgit_atomic_ssize_add(&git_cache__current_storage, -cache->used_memory);",
            " \tcache->used_memory = 0;",
            " }",
            " ",
            " void git_cache_clear(git_cache *cache)",
            " {",
            " \tif (git_rwlock_wrlock(&cache->lock) < 0)",
            " \t\treturn;",
            " ",
            " \tclear_cache(cache);",
            " ",
            " \tgit_rwlock_wrunlock(&cache->lock);",
            " }",
            " ",
            "+size_t git_cache_size(git_cache *cache)",
            "+{",
            "+\treturn git_cache_oidmap_size(&cache->map);",
            "+}",
            "+",
            " void git_cache_dispose(git_cache *cache)",
            " {",
            " \tgit_cache_clear(cache);",
            "-\tgit_oidmap_free(cache->map);",
            "+\tgit_cache_oidmap_dispose(&cache->map);",
            " \tgit_rwlock_free(&cache->lock);",
            " \tgit__memzero(cache, sizeof(*cache));",
            " }",
            " ",
            " /* Called with lock */",
            " static void cache_evict_entries(git_cache *cache)",
            " {",
            "-\tsize_t evict_count = git_cache_size(cache) / 2048, i;",
            "+\tsize_t evict_count = git_cache_size(cache) / 2048;",
            " \tssize_t evicted_memory = 0;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tif (evict_count < 8)",
            " \t\tevict_count = 8;",
            " ",
            " \t/* do not infinite loop if there's not enough entries to evict  */",
            " \tif (evict_count > git_cache_size(cache)) {",
            " \t\tclear_cache(cache);",
            " \t\treturn;",
            " \t}",
            " ",
            "-\ti = 0;",
            " \twhile (evict_count > 0) {",
            "-\t\tgit_cached_obj *evict;",
            " \t\tconst git_oid *key;",
            "+\t\tgit_cached_obj *evict;",
            " ",
            "-\t\tif (git_oidmap_iterate((void **) &evict, cache->map, &i, &key) == GIT_ITEROVER)",
            "+\t\tif (git_cache_oidmap_iterate(&iter, &key, &evict, &cache->map) != 0)",
            " \t\t\tbreak;",
            " ",
            " \t\tevict_count--;",
            " \t\tevicted_memory += evict->size;",
            "-\t\tgit_oidmap_delete(cache->map, key);",
            "+\t\tgit_cache_oidmap_remove(&cache->map, key);",
            " \t\tgit_cached_obj_decref(evict);",
            " \t}",
            " ",
            " \tcache->used_memory -= evicted_memory;",
            " \tgit_atomic_ssize_add(&git_cache__current_storage, -evicted_memory);",
            " }",
            " ",
            "@@ -128,20 +133,20 @@",
            " {",
            " \tsize_t max_size = git_cache__max_object_size[object_type];",
            " \treturn git_cache__enabled && object_size < max_size;",
            " }",
            " ",
            " static void *cache_get(git_cache *cache, const git_oid *oid, unsigned int flags)",
            " {",
            "-\tgit_cached_obj *entry;",
            "+\tgit_cached_obj *entry = NULL;",
            " ",
            " \tif (!git_cache__enabled || git_rwlock_rdlock(&cache->lock) < 0)",
            " \t\treturn NULL;",
            " ",
            "-\tif ((entry = git_oidmap_get(cache->map, oid)) != NULL) {",
            "+\tif (git_cache_oidmap_get(&entry, &cache->map, oid) == 0) {",
            " \t\tif (flags && entry->flags != flags) {",
            " \t\t\tentry = NULL;",
            " \t\t} else {",
            " \t\t\tgit_cached_obj_incref(entry);",
            " \t\t}",
            " \t}",
            " ",
            "@@ -168,30 +173,30 @@",
            " \t\treturn entry;",
            " ",
            " \t/* soften the load on the cache */",
            " \tif (git_atomic_ssize_get(&git_cache__current_storage) > git_cache__max_storage)",
            " \t\tcache_evict_entries(cache);",
            " ",
            " \t/* not found */",
            "-\tif ((stored_entry = git_oidmap_get(cache->map, &entry->oid)) == NULL) {",
            "-\t\tif (git_oidmap_set(cache->map, &entry->oid, entry) == 0) {",
            "+\tif (git_cache_oidmap_get(&stored_entry, &cache->map, &entry->oid) != 0) {",
            "+\t\tif (git_cache_oidmap_put(&cache->map, &entry->oid, entry) == 0) {",
            " \t\t\tgit_cached_obj_incref(entry);",
            " \t\t\tcache->used_memory += entry->size;",
            " \t\t\tgit_atomic_ssize_add(&git_cache__current_storage, (ssize_t)entry->size);",
            " \t\t}",
            " \t}",
            " \t/* found */",
            " \telse {",
            " \t\tif (stored_entry->flags == entry->flags) {",
            " \t\t\tgit_cached_obj_decref(entry);",
            " \t\t\tgit_cached_obj_incref(stored_entry);",
            " \t\t\tentry = stored_entry;",
            " \t\t} else if (stored_entry->flags == GIT_CACHE_STORE_RAW &&",
            " \t\t\t   entry->flags == GIT_CACHE_STORE_PARSED) {",
            "-\t\t\tif (git_oidmap_set(cache->map, &entry->oid, entry) == 0) {",
            "+\t\t\tif (git_cache_oidmap_put(&cache->map, &entry->oid, entry) == 0) {",
            " \t\t\t\tgit_cached_obj_decref(stored_entry);",
            " \t\t\t\tgit_cached_obj_incref(entry);",
            " \t\t\t} else {",
            " \t\t\t\tgit_cached_obj_decref(entry);",
            " \t\t\t\tgit_cached_obj_incref(stored_entry);",
            " \t\t\t\tentry = stored_entry;",
            " \t\t\t}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/cache.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/cache.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/cache.h",
            "@@ -10,15 +10,15 @@",
            " #include \"common.h\"",
            " ",
            " #include \"git2/common.h\"",
            " #include \"git2/oid.h\"",
            " #include \"git2/odb.h\"",
            " ",
            " #include \"thread.h\"",
            "-#include \"oidmap.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            " enum {",
            " \tGIT_CACHE_STORE_ANY = 0,",
            " \tGIT_CACHE_STORE_RAW = 1,",
            " \tGIT_CACHE_STORE_PARSED = 2",
            " };",
            " ",
            "@@ -26,42 +26,40 @@",
            " \tgit_oid      oid;",
            " \tint16_t      type;  /* git_object_t value */",
            " \tuint16_t     flags; /* GIT_CACHE_STORE value */",
            " \tsize_t       size;",
            " \tgit_atomic32 refcount;",
            " } git_cached_obj;",
            " ",
            "+GIT_HASHMAP_OID_STRUCT(git_cache_oidmap, git_cached_obj *);",
            "+",
            " typedef struct {",
            "-\tgit_oidmap *map;",
            "-\tgit_rwlock  lock;",
            "-\tssize_t     used_memory;",
            "+\tgit_cache_oidmap map;",
            "+\tgit_rwlock       lock;",
            "+\tssize_t          used_memory;",
            " } git_cache;",
            " ",
            " extern bool git_cache__enabled;",
            " extern ssize_t git_cache__max_storage;",
            " extern git_atomic_ssize git_cache__current_storage;",
            " ",
            " int git_cache_set_max_object_size(git_object_t type, size_t size);",
            " ",
            " int git_cache_init(git_cache *cache);",
            " void git_cache_dispose(git_cache *cache);",
            " void git_cache_clear(git_cache *cache);",
            "+size_t git_cache_size(git_cache *cache);",
            " ",
            " void *git_cache_store_raw(git_cache *cache, git_odb_object *entry);",
            " void *git_cache_store_parsed(git_cache *cache, git_object *entry);",
            " ",
            " git_odb_object *git_cache_get_raw(git_cache *cache, const git_oid *oid);",
            " git_object *git_cache_get_parsed(git_cache *cache, const git_oid *oid);",
            " void *git_cache_get_any(git_cache *cache, const git_oid *oid);",
            " ",
            "-GIT_INLINE(size_t) git_cache_size(git_cache *cache)",
            "-{",
            "-\treturn (size_t)git_oidmap_size(cache->map);",
            "-}",
            "-",
            " GIT_INLINE(void) git_cached_obj_incref(void *_obj)",
            " {",
            " \tgit_cached_obj *obj = _obj;",
            " \tgit_atomic32_inc(&obj->refcount);",
            " }",
            " ",
            " void git_cached_obj_decref(void *_obj);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/checkout.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/checkout.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/checkout.c",
            "@@ -26,16 +26,16 @@",
            " #include \"diff.h\"",
            " #include \"diff_generate.h\"",
            " #include \"pathspec.h\"",
            " #include \"diff_xdiff.h\"",
            " #include \"fs_path.h\"",
            " #include \"attr.h\"",
            " #include \"pool.h\"",
            "-#include \"strmap.h\"",
            " #include \"path.h\"",
            "+#include \"hashmap_str.h\"",
            " ",
            " /* See docs/checkout-internals.md for more information */",
            " ",
            " enum {",
            " \tCHECKOUT_ACTION__NONE = 0,",
            " \tCHECKOUT_ACTION__REMOVE = 1,",
            " \tCHECKOUT_ACTION__UPDATE_BLOB = 2,",
            "@@ -68,15 +68,15 @@",
            " \tunsigned int strategy;",
            " \tint can_symlink;",
            " \tint respect_filemode;",
            " \tbool reload_submodules;",
            " \tsize_t total_steps;",
            " \tsize_t completed_steps;",
            " \tgit_checkout_perfdata perfdata;",
            "-\tgit_strmap *mkdir_map;",
            "+\tgit_hashset_str mkdir_pathcache;",
            " \tgit_attr_session attr_session;",
            " } checkout_data;",
            " ",
            " typedef struct {",
            " \tconst git_index_entry *ancestor;",
            " \tconst git_index_entry *ours;",
            " \tconst git_index_entry *theirs;",
            "@@ -290,33 +290,36 @@",
            " \tcheckout_data *data,",
            " \tconst git_diff_delta *delta)",
            " {",
            " \tint error = 0;",
            " ",
            " \t*action = CHECKOUT_ACTION__NONE;",
            " ",
            "+\tif ((data->strategy & GIT_CHECKOUT_NONE))",
            "+\t\treturn 0;",
            "+",
            " \tswitch (delta->status) {",
            " \tcase GIT_DELTA_UNMODIFIED: /* case 12 */",
            " \t\terror = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);",
            " \t\tif (error)",
            " \t\t\treturn error;",
            " \t\t*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);",
            " \t\tbreak;",
            " \tcase GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */",
            "-\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);",
            "+\t\t*action = CHECKOUT_ACTION__UPDATE_BLOB;",
            " \t\tbreak;",
            " \tcase GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */",
            " \t\t*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);",
            " \t\tbreak;",
            " \tcase GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/",
            " \t\tif (delta->new_file.mode == GIT_FILEMODE_TREE)",
            "-\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);",
            "+\t\t\t*action = CHECKOUT_ACTION__UPDATE_BLOB;",
            " \t\tbreak;",
            " \tcase GIT_DELTA_DELETED: /* case 8 or 25 */",
            "-\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);",
            "+\t\t*action = CHECKOUT_ACTION__REMOVE;",
            " \t\tbreak;",
            " \tdefault: /* impossible */",
            " \t\tbreak;",
            " \t}",
            " ",
            " \treturn checkout_action_common(action, data, delta, NULL);",
            " }",
            "@@ -490,14 +493,17 @@",
            " \tcheckout_data *data,",
            " \tconst git_diff_delta *delta,",
            " \tgit_iterator *workdir,",
            " \tconst git_index_entry *wd)",
            " {",
            " \t*action = CHECKOUT_ACTION__NONE;",
            " ",
            "+\tif ((data->strategy & GIT_CHECKOUT_NONE))",
            "+\t\treturn 0;",
            "+",
            " \tswitch (delta->status) {",
            " \tcase GIT_DELTA_UNMODIFIED: /* case 14/15 or 33 */",
            " \t\tif (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd)) {",
            " \t\t\tGIT_ERROR_CHECK_ERROR(",
            " \t\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, wd) );",
            " \t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, NONE);",
            " \t\t}",
            "@@ -508,45 +514,45 @@",
            " \t\telse",
            " \t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, CONFLICT);",
            " \t\tbreak;",
            " \tcase GIT_DELTA_DELETED: /* case 9 or 10 (or 26 but not really) */",
            " \t\tif (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))",
            " \t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);",
            " \t\telse",
            "-\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);",
            "+\t\t\t*action = CHECKOUT_ACTION__REMOVE;",
            " \t\tbreak;",
            " \tcase GIT_DELTA_MODIFIED: /* case 16, 17, 18 (or 36 but not really) */",
            " \t\tif (wd->mode != GIT_FILEMODE_COMMIT &&",
            " \t\t\tcheckout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))",
            " \t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, CONFLICT);",
            " \t\telse",
            "-\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);",
            "+\t\t\t*action = CHECKOUT_ACTION__UPDATE_BLOB;",
            " \t\tbreak;",
            " \tcase GIT_DELTA_TYPECHANGE: /* case 22, 23, 29, 30 */",
            " \t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {",
            " \t\t\tif (wd->mode == GIT_FILEMODE_TREE)",
            " \t\t\t\t/* either deleting items in old tree will delete the wd dir,",
            " \t\t\t\t * or we'll get a conflict when we attempt blob update...",
            " \t\t\t\t */",
            "-\t\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);",
            "+\t\t\t\t*action = CHECKOUT_ACTION__UPDATE_BLOB;",
            " \t\t\telse if (wd->mode == GIT_FILEMODE_COMMIT) {",
            " \t\t\t\t/* workdir is possibly a \"phantom\" submodule - treat as a",
            " \t\t\t\t * tree if the only submodule info came from the config",
            " \t\t\t\t */",
            " \t\t\t\tif (submodule_is_config_only(data, wd->path))",
            "-\t\t\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);",
            "+\t\t\t\t\t*action = CHECKOUT_ACTION__UPDATE_BLOB;",
            " \t\t\t\telse",
            " \t\t\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);",
            " \t\t\t} else",
            " \t\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);",
            " \t\t}",
            " \t\telse if (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))",
            " \t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);",
            " \t\telse",
            "-\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE_AND_UPDATE, NONE);",
            "+\t\t\t*action = CHECKOUT_ACTION__REMOVE_AND_UPDATE;",
            " ",
            " \t\t/* don't update if the typechange is to a tree */",
            " \t\tif (delta->new_file.mode == GIT_FILEMODE_TREE)",
            " \t\t\t*action = (*action & ~CHECKOUT_ACTION__UPDATE_BLOB);",
            " \t\tbreak;",
            " \tdefault: /* impossible */",
            " \t\tbreak;",
            "@@ -559,14 +565,17 @@",
            " \tint *action,",
            " \tcheckout_data *data,",
            " \tconst git_diff_delta *delta,",
            " \tconst git_index_entry *wd)",
            " {",
            " \t*action = CHECKOUT_ACTION__NONE;",
            " ",
            "+\tif ((data->strategy & GIT_CHECKOUT_NONE))",
            "+\t\treturn 0;",
            "+",
            " \tswitch (delta->status) {",
            " \tcase GIT_DELTA_UNMODIFIED:",
            " \t\t/* should show delta as dirty / deleted */",
            " \t\tGIT_ERROR_CHECK_ERROR(",
            " \t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, wd) );",
            " \t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, NONE);",
            " \t\tbreak;",
            "@@ -593,14 +602,17 @@",
            " \tcheckout_data *data,",
            " \tconst git_diff_delta *delta,",
            " \tgit_iterator *workdir,",
            " \tconst git_index_entry *wd)",
            " {",
            " \t*action = CHECKOUT_ACTION__NONE;",
            " ",
            "+\tif ((data->strategy & GIT_CHECKOUT_NONE))",
            "+\t\treturn 0;",
            "+",
            " \tswitch (delta->status) {",
            " \tcase GIT_DELTA_UNMODIFIED: /* case 19 or 24 (or 34 but not really) */",
            " \t\tGIT_ERROR_CHECK_ERROR(",
            " \t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL));",
            " \t\tGIT_ERROR_CHECK_ERROR(",
            " \t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_UNTRACKED, NULL, wd));",
            " \t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, NONE);",
            "@@ -623,15 +635,15 @@",
            " \t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {",
            " \t\t\t/* For typechange from dir, remove dir and add blob, but it is",
            " \t\t\t * not safe to remove dir if it contains modified files.",
            " \t\t\t * However, safely removing child files will remove the parent",
            " \t\t\t * directory if is it left empty, so we can defer removing the",
            " \t\t\t * dir and it will succeed if no children are left.",
            " \t\t\t */",
            "-\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);",
            "+\t\t\t*action = CHECKOUT_ACTION__UPDATE_BLOB;",
            " \t\t}",
            " \t\telse if (delta->new_file.mode != GIT_FILEMODE_TREE)",
            " \t\t\t/* For typechange to dir, dir is already created so no action */",
            " \t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);",
            " \t\tbreak;",
            " \tdefault: /* impossible */",
            " \t\tbreak;",
            "@@ -1415,16 +1427,18 @@",
            " \tconst char *base,",
            " \tmode_t mode,",
            " \tunsigned int flags)",
            " {",
            " \tstruct git_futils_mkdir_options mkdir_opts = {0};",
            " \tint error;",
            " ",
            "-\tmkdir_opts.dir_map = data->mkdir_map;",
            "-\tmkdir_opts.pool = &data->pool;",
            "+\tif (git_pool_is_initialized(&data->pool)) {",
            "+\t\tmkdir_opts.cache_pool = &data->pool;",
            "+\t\tmkdir_opts.cache_pathset = &data->mkdir_pathcache;",
            "+\t}",
            " ",
            " \terror = git_futils_mkdir_relative(",
            " \t\tpath, base, mode, flags, &mkdir_opts);",
            " ",
            " \tdata->perfdata.mkdir_calls += mkdir_opts.perfdata.mkdir_calls;",
            " \tdata->perfdata.stat_calls += mkdir_opts.perfdata.stat_calls;",
            " \tdata->perfdata.chmod_calls += mkdir_opts.perfdata.chmod_calls;",
            "@@ -2312,31 +2326,30 @@",
            " static void checkout_data_clear(checkout_data *data)",
            " {",
            " \tif (data->opts_free_baseline) {",
            " \t\tgit_tree_free(data->opts.baseline);",
            " \t\tdata->opts.baseline = NULL;",
            " \t}",
            " ",
            "-\tgit_vector_free(&data->removes);",
            "+\tgit_vector_dispose(&data->removes);",
            " \tgit_pool_clear(&data->pool);",
            " ",
            "-\tgit_vector_free_deep(&data->remove_conflicts);",
            "-\tgit_vector_free_deep(&data->update_conflicts);",
            "+\tgit_vector_dispose_deep(&data->remove_conflicts);",
            "+\tgit_vector_dispose_deep(&data->update_conflicts);",
            " ",
            " \tgit__free(data->pfx);",
            " \tdata->pfx = NULL;",
            " ",
            " \tgit_str_dispose(&data->target_path);",
            " \tgit_str_dispose(&data->tmp);",
            " ",
            " \tgit_index_free(data->index);",
            " \tdata->index = NULL;",
            " ",
            "-\tgit_strmap_free(data->mkdir_map);",
            "-\tdata->mkdir_map = NULL;",
            "+\tgit_hashset_str_dispose(&data->mkdir_pathcache);",
            " ",
            " \tgit_attr_session__free(&data->attr_session);",
            " }",
            " ",
            " static int validate_target_directory(checkout_data *data)",
            " {",
            " \tint error;",
            "@@ -2428,22 +2441,20 @@",
            " \t\t\tgit_index_name_clear(data->index);",
            " \t\t\tgit_index_reuc_clear(data->index);",
            " \t\t}",
            " \t}",
            " ",
            " \t/* if you are forcing, allow all safe updates, plus recreate missing */",
            " \tif ((data->opts.checkout_strategy & GIT_CHECKOUT_FORCE) != 0)",
            "-\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_SAFE |",
            "-\t\t\tGIT_CHECKOUT_RECREATE_MISSING;",
            "+\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \t/* if the repository does not actually have an index file, then this",
            " \t * is an initial checkout (perhaps from clone), so we allow safe updates",
            " \t */",
            "-\tif (!data->index->on_disk &&",
            "-\t\t(data->opts.checkout_strategy & GIT_CHECKOUT_SAFE) != 0)",
            "+\tif (!data->index->on_disk)",
            " \t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tdata->strategy = data->opts.checkout_strategy;",
            " ",
            " \t/* opts->disable_filters is false by default */",
            " ",
            " \tif (!data->opts.dir_mode)",
            "@@ -2509,16 +2520,15 @@",
            " \t}",
            " ",
            " \tif ((error = git_pool_init(&data->pool, 1)) < 0 ||",
            " \t    (error = git_vector_init(&data->removes, 0, git__strcmp_cb)) < 0 ||",
            " \t    (error = git_vector_init(&data->remove_conflicts, 0, NULL)) < 0 ||",
            " \t    (error = git_vector_init(&data->update_conflicts, 0, NULL)) < 0 ||",
            " \t    (error = git_str_puts(&data->target_path, data->opts.target_directory)) < 0 ||",
            "-\t    (error = git_fs_path_to_dir(&data->target_path)) < 0 ||",
            "-\t    (error = git_strmap_new(&data->mkdir_map)) < 0)",
            "+\t    (error = git_fs_path_to_dir(&data->target_path)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tdata->target_len = git_str_len(&data->target_path);",
            " ",
            " \tgit_attr_session__init(&data->attr_session, data->repo);",
            " ",
            " cleanup:"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/checkout.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/checkout.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/checkout.h",
            "@@ -8,16 +8,14 @@",
            " #define INCLUDE_checkout_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"git2/checkout.h\"",
            " #include \"iterator.h\"",
            " ",
            "-#define GIT_CHECKOUT__NOTIFY_CONFLICT_TREE (1u << 12)",
            "-",
            " /**",
            "  * Update the working directory to match the target iterator.  The",
            "  * expected baseline value can be passed in via the checkout options",
            "  * or else will default to the HEAD commit.",
            "  */",
            " extern int git_checkout_iterator(",
            " \tgit_iterator *target,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/cherrypick.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/cherrypick.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/cherrypick.c",
            "@@ -69,16 +69,15 @@",
            " static int cherrypick_normalize_opts(",
            " \tgit_repository *repo,",
            " \tgit_cherrypick_options *opts,",
            " \tconst git_cherrypick_options *given,",
            " \tconst char *their_label)",
            " {",
            " \tint error = 0;",
            "-\tunsigned int default_checkout_strategy = GIT_CHECKOUT_SAFE |",
            "-\t\tGIT_CHECKOUT_ALLOW_CONFLICTS;",
            "+\tunsigned int default_checkout_strategy = GIT_CHECKOUT_ALLOW_CONFLICTS;",
            " ",
            " \tGIT_UNUSED(repo);",
            " ",
            " \tif (given != NULL)",
            " \t\tmemcpy(opts, given, sizeof(git_cherrypick_options));",
            " \telse {",
            " \t\tgit_cherrypick_options default_opts = GIT_CHERRYPICK_OPTIONS_INIT;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/clone.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/clone.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/clone.c",
            "@@ -12,24 +12,23 @@",
            " #include \"git2/revparse.h\"",
            " #include \"git2/branch.h\"",
            " #include \"git2/config.h\"",
            " #include \"git2/checkout.h\"",
            " #include \"git2/commit.h\"",
            " #include \"git2/tree.h\"",
            " ",
            "+#include \"checkout.h\"",
            " #include \"remote.h\"",
            " #include \"futils.h\"",
            " #include \"refs.h\"",
            " #include \"fs_path.h\"",
            " #include \"repository.h\"",
            " #include \"odb.h\"",
            " #include \"net.h\"",
            " ",
            "-static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);",
            "-",
            " static int create_branch(",
            " \tgit_reference **branch,",
            " \tgit_repository *repo,",
            " \tconst git_oid *target,",
            " \tconst char *name,",
            " \tconst char *log_message)",
            " {",
            "@@ -362,85 +361,81 @@",
            " \treturn error;",
            " }",
            " ",
            " static int should_checkout(",
            " \tbool *out,",
            " \tgit_repository *repo,",
            " \tbool is_bare,",
            "-\tconst git_checkout_options *opts)",
            "+\tconst git_clone_options *opts)",
            " {",
            " \tint error;",
            " ",
            "-\tif (!opts || is_bare || opts->checkout_strategy == GIT_CHECKOUT_NONE) {",
            "-\t\t*out = 0;",
            "+\tif (!opts || is_bare ||",
            "+\t    opts->checkout_opts.checkout_strategy == GIT_CHECKOUT_NONE) {",
            "+\t\t*out = false;",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif ((error = git_repository_head_unborn(repo)) < 0)",
            " \t\treturn error;",
            " ",
            " \t*out = !error;",
            " \treturn 0;",
            " }",
            " ",
            "-static int checkout_branch(git_repository *repo, git_remote *remote, const git_checkout_options *co_opts, const char *branch, const char *reflog_message)",
            "+static int checkout_branch(",
            "+\tgit_repository *repo,",
            "+\tgit_remote *remote,",
            "+\tconst git_clone_options *opts,",
            "+\tconst char *reflog_message)",
            " {",
            " \tbool checkout;",
            " \tint error;",
            " ",
            "-\tif (branch)",
            "-\t\terror = update_head_to_branch(repo, remote, branch, reflog_message);",
            "+\tif (opts->checkout_branch)",
            "+\t\terror = update_head_to_branch(repo, remote, opts->checkout_branch, reflog_message);",
            " \t/* Point HEAD to the same ref as the remote's head */",
            " \telse",
            " \t\terror = update_head_to_remote(repo, remote, reflog_message);",
            " ",
            " \tif (error < 0)",
            " \t\treturn error;",
            " ",
            "-\tif ((error = should_checkout(&checkout, repo, git_repository_is_bare(repo), co_opts)) < 0)",
            "+\tif ((error = should_checkout(&checkout, repo, git_repository_is_bare(repo), opts)) < 0)",
            " \t\treturn error;",
            " ",
            " \tif (checkout)",
            "-\t\terror = git_checkout_head(repo, co_opts);",
            "+\t\terror = git_checkout_head(repo, &opts->checkout_opts);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int clone_into(",
            " \tgit_repository *repo,",
            " \tgit_remote *_remote,",
            "-\tconst git_fetch_options *opts,",
            "-\tconst git_checkout_options *co_opts,",
            "-\tconst char *branch)",
            "+\tconst git_clone_options *opts)",
            " {",
            "-\tint error;",
            " \tgit_str reflog_message = GIT_STR_INIT;",
            " \tgit_remote_connect_options connect_opts = GIT_REMOTE_CONNECT_OPTIONS_INIT;",
            "-\tgit_fetch_options fetch_opts;",
            " \tgit_remote *remote;",
            " \tgit_oid_t oid_type;",
            "+\tint error;",
            " ",
            " \tGIT_ASSERT_ARG(repo);",
            " \tGIT_ASSERT_ARG(_remote);",
            " ",
            " \tif (!git_repository_is_empty(repo)) {",
            " \t\tgit_error_set(GIT_ERROR_INVALID, \"the repository is not empty\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif ((error = git_remote_dup(&remote, _remote)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tmemcpy(&fetch_opts, opts, sizeof(git_fetch_options));",
            "-\tfetch_opts.update_fetchhead = 0;",
            "-",
            "-\tif (!opts->depth)",
            "-\t\tfetch_opts.download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;",
            "-",
            "-\tif ((error = git_remote_connect_options__from_fetch_opts(&connect_opts, remote, &fetch_opts)) < 0)",
            "+\tif ((error = git_remote_connect_options__from_fetch_opts(&connect_opts, remote, &opts->fetch_opts)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tgit_str_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));",
            " ",
            " \t/*",
            " \t * Connect to the server so that we can identify the remote",
            " \t * object format.",
            "@@ -450,75 +445,187 @@",
            " \t\t\t&connect_opts)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tif ((error = git_remote_oid_type(&oid_type, remote)) < 0 ||",
            " \t    (error = git_repository__set_objectformat(repo, oid_type)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            "-\tif ((error = git_remote_fetch(remote, NULL, &fetch_opts, git_str_cstr(&reflog_message))) != 0)",
            "+\tif ((error = git_remote_fetch(remote, NULL, &opts->fetch_opts, git_str_cstr(&reflog_message))) != 0)",
            " \t\tgoto cleanup;",
            " ",
            "-\terror = checkout_branch(repo, remote, co_opts, branch, git_str_cstr(&reflog_message));",
            "+\terror = checkout_branch(repo, remote, opts, git_str_cstr(&reflog_message));",
            " ",
            " cleanup:",
            " \tgit_remote_free(remote);",
            " \tgit_remote_connect_options_dispose(&connect_opts);",
            " \tgit_str_dispose(&reflog_message);",
            " ",
            " \treturn error;",
            " }",
            " ",
            "-int git_clone__should_clone_local(const char *url_or_path, git_clone_local_t local)",
            "+static bool can_link(const char *src, const char *dst, int link)",
            "+{",
            "+#ifdef GIT_WIN32",
            "+\tGIT_UNUSED(src);",
            "+\tGIT_UNUSED(dst);",
            "+\tGIT_UNUSED(link);",
            "+\treturn false;",
            "+#else",
            "+",
            "+\tstruct stat st_src, st_dst;",
            "+",
            "+\tif (!link)",
            "+\t\treturn false;",
            "+",
            "+\tif (p_stat(src, &st_src) < 0)",
            "+\t\treturn false;",
            "+",
            "+\tif (p_stat(dst, &st_dst) < 0)",
            "+\t\treturn false;",
            "+",
            "+\treturn st_src.st_dev == st_dst.st_dev;",
            "+#endif",
            "+}",
            "+",
            "+static int clone_local_into(",
            "+\tgit_repository *repo,",
            "+\tgit_remote *remote,",
            "+\tconst git_clone_options *opts)",
            "+{",
            "+\tint error, flags;",
            "+\tgit_repository *src;",
            "+\tgit_str src_odb = GIT_STR_INIT, dst_odb = GIT_STR_INIT, src_path = GIT_STR_INIT;",
            "+\tgit_str reflog_message = GIT_STR_INIT;",
            "+\tbool link = (opts && opts->local != GIT_CLONE_LOCAL_NO_LINKS);",
            "+",
            "+\tGIT_ASSERT_ARG(repo);",
            "+\tGIT_ASSERT_ARG(remote);",
            "+",
            "+\tif (!git_repository_is_empty(repo)) {",
            "+\t\tgit_error_set(GIT_ERROR_INVALID, \"the repository is not empty\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\t/*",
            "+\t * Let's figure out what path we should use for the source",
            "+\t * repo, if it's not rooted, the path should be relative to",
            "+\t * the repository's worktree/gitdir.",
            "+\t */",
            "+\tif ((error = git_fs_path_from_url_or_path(&src_path, git_remote_url(remote))) < 0)",
            "+\t\treturn error;",
            "+",
            "+\t/* Copy .git/objects/ from the source to the target */",
            "+\tif ((error = git_repository_open(&src, git_str_cstr(&src_path))) < 0) {",
            "+\t\tgit_str_dispose(&src_path);",
            "+\t\treturn error;",
            "+\t}",
            "+",
            "+\tif (git_repository__item_path(&src_odb, src, GIT_REPOSITORY_ITEM_OBJECTS) < 0 ||",
            "+\t    git_repository__item_path(&dst_odb, repo, GIT_REPOSITORY_ITEM_OBJECTS) < 0) {",
            "+\t\terror = -1;",
            "+\t\tgoto cleanup;",
            "+\t}",
            "+",
            "+\tflags = 0;",
            "+\tif (can_link(git_repository_path(src), git_repository_path(repo), link))",
            "+\t\tflags |= GIT_CPDIR_LINK_FILES;",
            "+",
            "+\terror = git_futils_cp_r(git_str_cstr(&src_odb), git_str_cstr(&dst_odb),",
            "+\t\t\t\tflags, GIT_OBJECT_DIR_MODE);",
            "+",
            "+\t/*",
            "+\t * can_link() doesn't catch all variations, so if we hit an",
            "+\t * error and did want to link, let's try again without trying",
            "+\t * to link.",
            "+\t */",
            "+\tif (error < 0 && link) {",
            "+\t\tflags &= ~GIT_CPDIR_LINK_FILES;",
            "+\t\terror = git_futils_cp_r(git_str_cstr(&src_odb), git_str_cstr(&dst_odb),",
            "+\t\t\t\t\tflags, GIT_OBJECT_DIR_MODE);",
            "+\t}",
            "+",
            "+\tif (error < 0)",
            "+\t\tgoto cleanup;",
            "+",
            "+\tgit_str_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));",
            "+",
            "+\tif ((error = git_remote_fetch(remote, NULL, &opts->fetch_opts, git_str_cstr(&reflog_message))) != 0)",
            "+\t\tgoto cleanup;",
            "+",
            "+\terror = checkout_branch(repo, remote, opts, git_str_cstr(&reflog_message));",
            "+",
            "+cleanup:",
            "+\tgit_str_dispose(&reflog_message);",
            "+\tgit_str_dispose(&src_path);",
            "+\tgit_str_dispose(&src_odb);",
            "+\tgit_str_dispose(&dst_odb);",
            "+\tgit_repository_free(src);",
            "+\treturn error;",
            "+}",
            "+",
            "+int git_clone__should_clone_local(",
            "+\tbool *out,",
            "+\tconst char *url_or_path,",
            "+\tgit_clone_local_t local)",
            " {",
            " \tgit_str fromurl = GIT_STR_INIT;",
            "-\tbool is_local;",
            "+",
            "+\t*out = false;",
            " ",
            " \tif (local == GIT_CLONE_NO_LOCAL)",
            " \t\treturn 0;",
            " ",
            " \tif (git_net_str_is_url(url_or_path)) {",
            "-\t\t/* If GIT_CLONE_LOCAL_AUTO is specified, any url should be treated as remote */",
            "+\t\t/* If GIT_CLONE_LOCAL_AUTO is specified, any url should",
            "+\t\t * be treated as remote */",
            " \t\tif (local == GIT_CLONE_LOCAL_AUTO ||",
            " \t\t    !git_fs_path_is_local_file_url(url_or_path))",
            " \t\t\treturn 0;",
            " ",
            "-\t\tif (git_fs_path_fromurl(&fromurl, url_or_path) == 0)",
            "-\t\t\tis_local = git_fs_path_isdir(git_str_cstr(&fromurl));",
            "-\t\telse",
            "-\t\t\tis_local = -1;",
            "+\t\tif (git_fs_path_fromurl(&fromurl, url_or_path) < 0)",
            "+\t\t\treturn -1;",
            "+",
            "+\t\t*out = git_fs_path_isdir(git_str_cstr(&fromurl));",
            " \t\tgit_str_dispose(&fromurl);",
            " \t} else {",
            "-\t\tis_local = git_fs_path_isdir(url_or_path);",
            "+\t\t*out = git_fs_path_isdir(url_or_path);",
            " \t}",
            "-\treturn is_local;",
            "+",
            "+\treturn 0;",
            " }",
            " ",
            "-static int git__clone(",
            "+static int clone_repo(",
            " \tgit_repository **out,",
            " \tconst char *url,",
            " \tconst char *local_path,",
            "-\tconst git_clone_options *_options,",
            "+\tconst git_clone_options *given_opts,",
            " \tint use_existing)",
            " {",
            " \tint error = 0;",
            " \tgit_repository *repo = NULL;",
            " \tgit_remote *origin;",
            " \tgit_clone_options options = GIT_CLONE_OPTIONS_INIT;",
            " \tuint32_t rmdir_flags = GIT_RMDIR_REMOVE_FILES;",
            " \tgit_repository_create_cb repository_cb;",
            " ",
            " \tGIT_ASSERT_ARG(out);",
            " \tGIT_ASSERT_ARG(url);",
            " \tGIT_ASSERT_ARG(local_path);",
            " ",
            "-\tif (_options)",
            "-\t\tmemcpy(&options, _options, sizeof(git_clone_options));",
            "+\tif (given_opts)",
            "+\t\tmemcpy(&options, given_opts, sizeof(git_clone_options));",
            " ",
            " \tGIT_ERROR_CHECK_VERSION(&options, GIT_CLONE_OPTIONS_VERSION, \"git_clone_options\");",
            " ",
            "+\t/* enforce some behavior on fetch */",
            "+\toptions.fetch_opts.update_fetchhead = 0;",
            "+",
            "+\tif (!options.fetch_opts.depth)",
            "+\t\toptions.fetch_opts.download_tags = GIT_REMOTE_DOWNLOAD_TAGS_ALL;",
            "+",
            " \t/* Only clone to a new directory or an empty directory */",
            " \tif (git_fs_path_exists(local_path) && !use_existing && !git_fs_path_is_empty_dir(local_path)) {",
            " \t\tgit_error_set(GIT_ERROR_INVALID,",
            " \t\t\t\"'%s' exists and is not an empty directory\", local_path);",
            " \t\treturn GIT_EEXISTS;",
            " \t}",
            " ",
            "@@ -531,27 +638,25 @@",
            " \telse",
            " \t\trepository_cb = default_repository_create;",
            " ",
            " \tif ((error = repository_cb(&repo, local_path, options.bare, options.repository_cb_payload)) < 0)",
            " \t\treturn error;",
            " ",
            " \tif (!(error = create_and_configure_origin(&origin, repo, url, &options))) {",
            "-\t\tint clone_local = git_clone__should_clone_local(url, options.local);",
            "-\t\tint link = options.local != GIT_CLONE_LOCAL_NO_LINKS;",
            "+\t\tbool clone_local;",
            "+",
            "+\t\tif ((error = git_clone__should_clone_local(&clone_local, url, options.local)) < 0) {",
            "+\t\t\tgit_remote_free(origin);",
            "+\t\t\treturn error;",
            "+\t\t}",
            " ",
            "-\t\tif (clone_local == 1)",
            "-\t\t\terror = clone_local_into(",
            "-\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,",
            "-\t\t\t\toptions.checkout_branch, link);",
            "-\t\telse if (clone_local == 0)",
            "-\t\t\terror = clone_into(",
            "-\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,",
            "-\t\t\t\toptions.checkout_branch);",
            "+\t\tif (clone_local)",
            "+\t\t\terror = clone_local_into(repo, origin, &options);",
            " \t\telse",
            "-\t\t\terror = -1;",
            "+\t\t\terror = clone_into(repo, origin, &options);",
            " ",
            " \t\tgit_remote_free(origin);",
            " \t}",
            " ",
            " \tif (error != 0) {",
            " \t\tgit_error *last_error;",
            " \t\tgit_error_save(&last_error);",
            "@@ -568,26 +673,26 @@",
            " \treturn error;",
            " }",
            " ",
            " int git_clone(",
            " \tgit_repository **out,",
            " \tconst char *url,",
            " \tconst char *local_path,",
            "-\tconst git_clone_options *_options)",
            "+\tconst git_clone_options *options)",
            " {",
            "-\treturn git__clone(out, url, local_path, _options, 0);",
            "+\treturn clone_repo(out, url, local_path, options, 0);",
            " }",
            " ",
            " int git_clone__submodule(",
            " \tgit_repository **out,",
            " \tconst char *url,",
            " \tconst char *local_path,",
            "-\tconst git_clone_options *_options)",
            "+\tconst git_clone_options *options)",
            " {",
            "-\treturn git__clone(out, url, local_path, _options, 1);",
            "+\treturn clone_repo(out, url, local_path, options, 1);",
            " }",
            " ",
            " int git_clone_options_init(git_clone_options *opts, unsigned int version)",
            " {",
            " \tGIT_INIT_STRUCTURE_FROM_TEMPLATE(",
            " \t\topts, version, git_clone_options, GIT_CLONE_OPTIONS_INIT);",
            " \treturn 0;",
            "@@ -595,103 +700,7 @@",
            " ",
            " #ifndef GIT_DEPRECATE_HARD",
            " int git_clone_init_options(git_clone_options *opts, unsigned int version)",
            " {",
            " \treturn git_clone_options_init(opts, version);",
            " }",
            " #endif",
            "-",
            "-static bool can_link(const char *src, const char *dst, int link)",
            "-{",
            "-#ifdef GIT_WIN32",
            "-\tGIT_UNUSED(src);",
            "-\tGIT_UNUSED(dst);",
            "-\tGIT_UNUSED(link);",
            "-\treturn false;",
            "-#else",
            "-",
            "-\tstruct stat st_src, st_dst;",
            "-",
            "-\tif (!link)",
            "-\t\treturn false;",
            "-",
            "-\tif (p_stat(src, &st_src) < 0)",
            "-\t\treturn false;",
            "-",
            "-\tif (p_stat(dst, &st_dst) < 0)",
            "-\t\treturn false;",
            "-",
            "-\treturn st_src.st_dev == st_dst.st_dev;",
            "-#endif",
            "-}",
            "-",
            "-static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link)",
            "-{",
            "-\tint error, flags;",
            "-\tgit_repository *src;",
            "-\tgit_str src_odb = GIT_STR_INIT, dst_odb = GIT_STR_INIT, src_path = GIT_STR_INIT;",
            "-\tgit_str reflog_message = GIT_STR_INIT;",
            "-",
            "-\tGIT_ASSERT_ARG(repo);",
            "-\tGIT_ASSERT_ARG(remote);",
            "-",
            "-\tif (!git_repository_is_empty(repo)) {",
            "-\t\tgit_error_set(GIT_ERROR_INVALID, \"the repository is not empty\");",
            "-\t\treturn -1;",
            "-\t}",
            "-",
            "-\t/*",
            "-\t * Let's figure out what path we should use for the source",
            "-\t * repo, if it's not rooted, the path should be relative to",
            "-\t * the repository's worktree/gitdir.",
            "-\t */",
            "-\tif ((error = git_fs_path_from_url_or_path(&src_path, git_remote_url(remote))) < 0)",
            "-\t\treturn error;",
            "-",
            "-\t/* Copy .git/objects/ from the source to the target */",
            "-\tif ((error = git_repository_open(&src, git_str_cstr(&src_path))) < 0) {",
            "-\t\tgit_str_dispose(&src_path);",
            "-\t\treturn error;",
            "-\t}",
            "-",
            "-\tif (git_repository__item_path(&src_odb, src, GIT_REPOSITORY_ITEM_OBJECTS) < 0 ||",
            "-\t    git_repository__item_path(&dst_odb, repo, GIT_REPOSITORY_ITEM_OBJECTS) < 0) {",
            "-\t\terror = -1;",
            "-\t\tgoto cleanup;",
            "-\t}",
            "-",
            "-\tflags = 0;",
            "-\tif (can_link(git_repository_path(src), git_repository_path(repo), link))",
            "-\t\tflags |= GIT_CPDIR_LINK_FILES;",
            "-",
            "-\terror = git_futils_cp_r(git_str_cstr(&src_odb), git_str_cstr(&dst_odb),",
            "-\t\t\t\tflags, GIT_OBJECT_DIR_MODE);",
            "-",
            "-\t/*",
            "-\t * can_link() doesn't catch all variations, so if we hit an",
            "-\t * error and did want to link, let's try again without trying",
            "-\t * to link.",
            "-\t */",
            "-\tif (error < 0 && link) {",
            "-\t\tflags &= ~GIT_CPDIR_LINK_FILES;",
            "-\t\terror = git_futils_cp_r(git_str_cstr(&src_odb), git_str_cstr(&dst_odb),",
            "-\t\t\t\t\tflags, GIT_OBJECT_DIR_MODE);",
            "-\t}",
            "-",
            "-\tif (error < 0)",
            "-\t\tgoto cleanup;",
            "-",
            "-\tgit_str_printf(&reflog_message, \"clone: from %s\", git_remote_url(remote));",
            "-",
            "-\tif ((error = git_remote_fetch(remote, NULL, fetch_opts, git_str_cstr(&reflog_message))) != 0)",
            "-\t\tgoto cleanup;",
            "-",
            "-\terror = checkout_branch(repo, remote, co_opts, branch, git_str_cstr(&reflog_message));",
            "-",
            "-cleanup:",
            "-\tgit_str_dispose(&reflog_message);",
            "-\tgit_str_dispose(&src_path);",
            "-\tgit_str_dispose(&src_odb);",
            "-\tgit_str_dispose(&dst_odb);",
            "-\tgit_repository_free(src);",
            "-\treturn error;",
            "-}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/clone.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/clone.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/clone.h",
            "@@ -11,10 +11,13 @@",
            " ",
            " #include \"git2/clone.h\"",
            " ",
            " extern int git_clone__submodule(git_repository **out,",
            " \tconst char *url, const char *local_path,",
            " \tconst git_clone_options *_options);",
            " ",
            "-extern int git_clone__should_clone_local(const char *url, git_clone_local_t local);",
            "+extern int git_clone__should_clone_local(",
            "+\tbool *out,",
            "+\tconst char *url,",
            "+\tgit_clone_local_t local);",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/commit_graph.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/commit_graph.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/commit_graph.c",
            "@@ -9,26 +9,26 @@",
            " ",
            " #include \"array.h\"",
            " #include \"buf.h\"",
            " #include \"filebuf.h\"",
            " #include \"futils.h\"",
            " #include \"hash.h\"",
            " #include \"oidarray.h\"",
            "-#include \"oidmap.h\"",
            " #include \"pack.h\"",
            " #include \"repository.h\"",
            " #include \"revwalk.h\"",
            " ",
            " #define GIT_COMMIT_GRAPH_MISSING_PARENT 0x70000000",
            " #define GIT_COMMIT_GRAPH_GENERATION_NUMBER_MAX 0x3FFFFFFF",
            " #define GIT_COMMIT_GRAPH_GENERATION_NUMBER_INFINITY 0xFFFFFFFF",
            " ",
            " #define COMMIT_GRAPH_SIGNATURE 0x43475048 /* \"CGPH\" */",
            " #define COMMIT_GRAPH_VERSION 1",
            " #define COMMIT_GRAPH_OBJECT_ID_VERSION 1",
            "+",
            " struct git_commit_graph_header {",
            " \tuint32_t signature;",
            " \tuint8_t version;",
            " \tuint8_t object_id_version;",
            " \tuint8_t chunks;",
            " \tuint8_t base_graph_files;",
            " };",
            "@@ -361,23 +361,32 @@",
            " \treturn 0;",
            " }",
            " ",
            " int git_commit_graph_open(",
            " \tgit_commit_graph **cgraph_out,",
            " \tconst char *objects_dir",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t, git_oid_t oid_type",
            "+\t, const git_commit_graph_open_options *opts",
            " #endif",
            " \t)",
            " {",
            "-#ifndef GIT_EXPERIMENTAL_SHA256",
            "-\tgit_oid_t oid_type = GIT_OID_SHA1;",
            "-#endif",
            "+\tgit_oid_t oid_type;",
            " \tint error;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tGIT_ERROR_CHECK_VERSION(opts,",
            "+\t\tGIT_COMMIT_GRAPH_OPEN_OPTIONS_VERSION,",
            "+\t\t\"git_commit_graph_open_options\");",
            "+",
            "+\toid_type = opts && opts->oid_type ? opts->oid_type : GIT_OID_DEFAULT;",
            "+\tGIT_ASSERT_ARG(git_oid_type_is_valid(oid_type));",
            "+#else",
            "+\toid_type = GIT_OID_SHA1;",
            "+#endif",
            "+",
            " \terror = git_commit_graph_new(cgraph_out, objects_dir, true,",
            " \t\t\toid_type);",
            " ",
            " \tif (!error)",
            " \t\treturn git_commit_graph_validate(*cgraph_out);",
            " ",
            " \treturn error;",
            "@@ -680,29 +689,48 @@",
            " static int packed_commit__cmp(const void *a_, const void *b_)",
            " {",
            " \tconst struct packed_commit *a = a_;",
            " \tconst struct packed_commit *b = b_;",
            " \treturn git_oid_cmp(&a->sha1, &b->sha1);",
            " }",
            " ",
            "+int git_commit_graph_writer_options_init(",
            "+\tgit_commit_graph_writer_options *opts,",
            "+\tunsigned int version)",
            "+{",
            "+\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(",
            "+\t\topts,",
            "+\t\tversion,",
            "+\t\tgit_commit_graph_writer_options,",
            "+\t\tGIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT);",
            "+\treturn 0;",
            "+}",
            "+",
            " int git_commit_graph_writer_new(",
            " \tgit_commit_graph_writer **out,",
            "-\tconst char *objects_info_dir",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t, git_oid_t oid_type",
            "-#endif",
            "+\tconst char *objects_info_dir,",
            "+\tconst git_commit_graph_writer_options *opts",
            " \t)",
            " {",
            " \tgit_commit_graph_writer *w;",
            "+\tgit_oid_t oid_type;",
            " ",
            "-#ifndef GIT_EXPERIMENTAL_SHA256",
            "-\tgit_oid_t oid_type = GIT_OID_SHA1;",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tGIT_ERROR_CHECK_VERSION(opts,",
            "+\t\tGIT_COMMIT_GRAPH_WRITER_OPTIONS_VERSION,",
            "+\t\t\"git_commit_graph_writer_options\");",
            "+",
            "+\toid_type = opts && opts->oid_type ? opts->oid_type : GIT_OID_DEFAULT;",
            "+\tGIT_ASSERT_ARG(git_oid_type_is_valid(oid_type));",
            "+#else",
            "+\tGIT_UNUSED(opts);",
            "+\toid_type = GIT_OID_SHA1;",
            " #endif",
            " ",
            "-\tGIT_ASSERT_ARG(out && objects_info_dir && oid_type);",
            "+\tGIT_ASSERT_ARG(out && objects_info_dir);",
            " ",
            " \tw = git__calloc(1, sizeof(git_commit_graph_writer));",
            " \tGIT_ERROR_CHECK_ALLOC(w);",
            " ",
            " \tw->oid_type = oid_type;",
            " ",
            " \tif (git_str_sets(&w->objects_info_dir, objects_info_dir) < 0) {",
            "@@ -726,15 +754,15 @@",
            " \tsize_t i;",
            " ",
            " \tif (!w)",
            " \t\treturn;",
            " ",
            " \tgit_vector_foreach (&w->commits, i, packed_commit)",
            " \t\tpacked_commit_free(packed_commit);",
            "-\tgit_vector_free(&w->commits);",
            "+\tgit_vector_dispose(&w->commits);",
            " \tgit_str_dispose(&w->objects_info_dir);",
            " \tgit__free(w);",
            " }",
            " ",
            " struct object_entry_cb_state {",
            " \tgit_repository *repo;",
            " \tgit_odb *db;",
            "@@ -771,17 +799,17 @@",
            " \t\treturn error;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " int git_commit_graph_writer_add_index_file(",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tgit_repository *repo,",
            "-\t\tconst char *idx_path)",
            "+\tgit_commit_graph_writer *w,",
            "+\tgit_repository *repo,",
            "+\tconst char *idx_path)",
            " {",
            " \tint error;",
            " \tstruct git_pack_file *p = NULL;",
            " \tstruct object_entry_cb_state state = {0};",
            " \tstate.repo = repo;",
            " \tstate.commits = &w->commits;",
            " ",
            "@@ -835,32 +863,31 @@",
            " enum generation_number_commit_state {",
            " \tGENERATION_NUMBER_COMMIT_STATE_UNVISITED = 0,",
            " \tGENERATION_NUMBER_COMMIT_STATE_ADDED = 1,",
            " \tGENERATION_NUMBER_COMMIT_STATE_EXPANDED = 2,",
            " \tGENERATION_NUMBER_COMMIT_STATE_VISITED = 3",
            " };",
            " ",
            "+GIT_HASHMAP_OID_SETUP(git_commit_graph_oidmap, struct packed_commit *);",
            "+",
            " static int compute_generation_numbers(git_vector *commits)",
            " {",
            " \tgit_array_t(size_t) index_stack = GIT_ARRAY_INIT;",
            " \tsize_t i, j;",
            " \tsize_t *parent_idx;",
            " \tenum generation_number_commit_state *commit_states = NULL;",
            " \tstruct packed_commit *child_packed_commit;",
            "-\tgit_oidmap *packed_commit_map = NULL;",
            "+\tgit_commit_graph_oidmap packed_commit_map = GIT_HASHMAP_INIT;",
            " \tint error = 0;",
            " ",
            " \t/* First populate the parent indices fields */",
            "-\terror = git_oidmap_new(&packed_commit_map);",
            "-\tif (error < 0)",
            "-\t\tgoto cleanup;",
            " \tgit_vector_foreach (commits, i, child_packed_commit) {",
            " \t\tchild_packed_commit->index = i;",
            "-\t\terror = git_oidmap_set(",
            "-\t\t\t\tpacked_commit_map, &child_packed_commit->sha1, child_packed_commit);",
            "+\t\terror = git_commit_graph_oidmap_put(&packed_commit_map,",
            "+\t\t\t\t&child_packed_commit->sha1, child_packed_commit);",
            " \t\tif (error < 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " ",
            " \tgit_vector_foreach (commits, i, child_packed_commit) {",
            " \t\tsize_t parent_i, *parent_idx_ptr;",
            " \t\tstruct packed_commit *parent_packed_commit;",
            "@@ -870,16 +897,15 @@",
            " \t\t\t\tgit_array_size(child_packed_commit->parents));",
            " \t\tif (git_array_size(child_packed_commit->parents)",
            " \t\t    && !child_packed_commit->parent_indices.ptr) {",
            " \t\t\terror = -1;",
            " \t\t\tgoto cleanup;",
            " \t\t}",
            " \t\tgit_array_foreach (child_packed_commit->parents, parent_i, parent_id) {",
            "-\t\t\tparent_packed_commit = git_oidmap_get(packed_commit_map, parent_id);",
            "-\t\t\tif (!parent_packed_commit) {",
            "+\t\t\tif (git_commit_graph_oidmap_get(&parent_packed_commit, &packed_commit_map, parent_id) != 0) {",
            " \t\t\t\tgit_error_set(GIT_ERROR_ODB,",
            " \t\t\t\t\t      \"parent commit %s not found in commit graph\",",
            " \t\t\t\t\t      git_oid_tostr_s(parent_id));",
            " \t\t\t\terror = GIT_ENOTFOUND;",
            " \t\t\t\tgoto cleanup;",
            " \t\t\t}",
            " \t\t\tparent_idx_ptr = git_array_alloc(child_packed_commit->parent_indices);",
            "@@ -971,15 +997,15 @@",
            " \t\t\tcommit_states[*parent_idx] = GENERATION_NUMBER_COMMIT_STATE_ADDED;",
            " \t\t\t*(size_t *)git_array_alloc(index_stack) = *parent_idx;",
            " \t\t}",
            " \t\tcommit_states[i] = GENERATION_NUMBER_COMMIT_STATE_EXPANDED;",
            " \t}",
            " ",
            " cleanup:",
            "-\tgit_oidmap_free(packed_commit_map);",
            "+\tgit_commit_graph_oidmap_dispose(&packed_commit_map);",
            " \tgit__free(commit_states);",
            " \tgit_array_clear(index_stack);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int write_offset(off64_t offset, commit_graph_write_cb write_cb, void *cb_data)",
            "@@ -1025,30 +1051,33 @@",
            " };",
            " ",
            " static int commit_graph_write_hash(const char *buf, size_t size, void *data)",
            " {",
            " \tstruct commit_graph_write_hash_context *ctx = data;",
            " \tint error;",
            " ",
            "-\terror = git_hash_update(ctx->ctx, buf, size);",
            "-\tif (error < 0)",
            "-\t\treturn error;",
            "+\tif (ctx->ctx) {",
            "+\t\terror = git_hash_update(ctx->ctx, buf, size);",
            "+",
            "+\t\tif (error < 0)",
            "+\t\t\treturn error;",
            "+\t}",
            " ",
            " \treturn ctx->write_cb(buf, size, ctx->cb_data);",
            " }",
            " ",
            " static void packed_commit_free_dup(void *packed_commit)",
            " {",
            " \tpacked_commit_free(packed_commit);",
            " }",
            " ",
            " static int commit_graph_write(",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tcommit_graph_write_cb write_cb,",
            "-\t\tvoid *cb_data)",
            "+\tgit_commit_graph_writer *w,",
            "+\tcommit_graph_write_cb write_cb,",
            "+\tvoid *cb_data)",
            " {",
            " \tint error = 0;",
            " \tsize_t i;",
            " \tstruct packed_commit *packed_commit;",
            " \tstruct git_commit_graph_header hdr = {0};",
            " \tuint32_t oid_fanout_count;",
            " \tuint32_t extra_edge_list_count;",
            "@@ -1223,14 +1252,17 @@",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \t/* Finalize the checksum and write the trailer. */",
            " \terror = git_hash_final(checksum, &ctx);",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            "+",
            "+\thash_cb_data.ctx = NULL;",
            "+",
            " \terror = write_cb((char *)checksum, checksum_size, cb_data);",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            " cleanup:",
            " \tgit_str_dispose(&oid_lookup);",
            " \tgit_str_dispose(&commit_data);",
            "@@ -1241,38 +1273,21 @@",
            " ",
            " static int commit_graph_write_filebuf(const char *buf, size_t size, void *data)",
            " {",
            " \tgit_filebuf *f = (git_filebuf *)data;",
            " \treturn git_filebuf_write(f, buf, size);",
            " }",
            " ",
            "-int git_commit_graph_writer_options_init(",
            "-\tgit_commit_graph_writer_options *opts,",
            "-\tunsigned int version)",
            "-{",
            "-\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(",
            "-\t\t\topts,",
            "-\t\t\tversion,",
            "-\t\t\tgit_commit_graph_writer_options,",
            "-\t\t\tGIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT);",
            "-\treturn 0;",
            "-}",
            "-",
            "-int git_commit_graph_writer_commit(",
            "-\t\tgit_commit_graph_writer *w,",
            "-\t\tgit_commit_graph_writer_options *opts)",
            "+int git_commit_graph_writer_commit(git_commit_graph_writer *w)",
            " {",
            " \tint error;",
            " \tint filebuf_flags = GIT_FILEBUF_DO_NOT_BUFFER;",
            " \tgit_str commit_graph_path = GIT_STR_INIT;",
            " \tgit_filebuf output = GIT_FILEBUF_INIT;",
            " ",
            "-\t/* TODO: support options and fill in defaults. */",
            "-\tGIT_UNUSED(opts);",
            "-",
            " \terror = git_str_joinpath(",
            " \t\t\t&commit_graph_path, git_str_cstr(&w->objects_info_dir), \"commit-graph\");",
            " \tif (error < 0)",
            " \t\treturn error;",
            " ",
            " \tif (git_repository__fsync_gitdir)",
            " \t\tfilebuf_flags |= GIT_FILEBUF_FSYNC;",
            "@@ -1288,22 +1303,18 @@",
            " \t}",
            " ",
            " \treturn git_filebuf_commit(&output);",
            " }",
            " ",
            " int git_commit_graph_writer_dump(",
            " \tgit_buf *cgraph,",
            "-\tgit_commit_graph_writer *w,",
            "-\tgit_commit_graph_writer_options *opts)",
            "+\tgit_commit_graph_writer *w)",
            " {",
            "-\tGIT_BUF_WRAP_PRIVATE(cgraph, git_commit_graph__writer_dump, w, opts);",
            "+\tGIT_BUF_WRAP_PRIVATE(cgraph, git_commit_graph__writer_dump, w);",
            " }",
            " ",
            " int git_commit_graph__writer_dump(",
            " \tgit_str *cgraph,",
            "-\tgit_commit_graph_writer *w,",
            "-\tgit_commit_graph_writer_options *opts)",
            "+\tgit_commit_graph_writer *w)",
            " {",
            "-\t/* TODO: support options. */",
            "-\tGIT_UNUSED(opts);",
            " \treturn commit_graph_write(w, commit_graph_write_buf, cgraph);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/commit_graph.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/commit_graph.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/commit_graph.h",
            "@@ -152,16 +152,15 @@",
            " ",
            " \t/* The list of packed commits. */",
            " \tgit_vector commits;",
            " };",
            " ",
            " int git_commit_graph__writer_dump(",
            " \tgit_str *cgraph,",
            "-\tgit_commit_graph_writer *w,",
            "-\tgit_commit_graph_writer_options *opts);",
            "+\tgit_commit_graph_writer *w);",
            " ",
            " /*",
            "  * Returns whether the git_commit_graph_file needs to be reloaded since the",
            "  * contents of the commit-graph file have changed on disk.",
            "  */",
            " bool git_commit_graph_file_needs_refresh(",
            " \t\tconst git_commit_graph_file *file, const char *path);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/config.c",
            "@@ -46,18 +46,21 @@",
            " \tbackend_instance *instance;",
            " \tgit_config_level_t level;",
            " \tint write_order;",
            " } backend_entry;",
            " ",
            " void git_config_entry_free(git_config_entry *entry)",
            " {",
            "+\tgit_config_backend_entry *be;",
            "+",
            " \tif (!entry)",
            " \t\treturn;",
            " ",
            "-\tentry->free(entry);",
            "+\tbe = (git_config_backend_entry *)entry;",
            "+\tbe->free(be);",
            " }",
            " ",
            " static void backend_instance_free(backend_instance *instance)",
            " {",
            " \tgit_config_backend *backend;",
            " ",
            " \tbackend = instance->backend;",
            "@@ -71,16 +74,16 @@",
            " \tbackend_entry *entry;",
            " ",
            " \tgit_vector_foreach(&config->readers, i, entry) {",
            " \t\tGIT_REFCOUNT_DEC(entry->instance, backend_instance_free);",
            " \t\tgit__free(entry);",
            " \t}",
            " ",
            "-\tgit_vector_free(&config->readers);",
            "-\tgit_vector_free(&config->writers);",
            "+\tgit_vector_dispose(&config->readers);",
            "+\tgit_vector_dispose(&config->writers);",
            " \tgit__free(config);",
            " }",
            " ",
            " void git_config_free(git_config *config)",
            " {",
            " \tif (config == NULL)",
            " \t\treturn;",
            "@@ -426,23 +429,27 @@",
            " \tgit_config_iterator parent;",
            " \tgit_config_iterator *current;",
            " \tconst git_config *config;",
            " \tgit_regexp regex;",
            " \tsize_t i;",
            " } all_iter;",
            " ",
            "-static int all_iter_next(git_config_entry **out, git_config_iterator *_iter)",
            "+static int all_iter_next(",
            "+\tgit_config_backend_entry **out,",
            "+\tgit_config_iterator *_iter)",
            " {",
            " \tall_iter *iter = (all_iter *) _iter;",
            " \tbackend_entry *entry;",
            " \tgit_config_backend *backend;",
            "+\tgit_config_backend_entry *be;",
            " \tint error = 0;",
            " ",
            " \tif (iter->current != NULL &&",
            "-\t    (error = iter->current->next(out, iter->current)) == 0) {",
            "+\t    (error = iter->current->next(&be, iter->current)) == 0) {",
            "+\t\t*out = be;",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (error < 0 && error != GIT_ITEROVER)",
            " \t\treturn error;",
            " ",
            " \tdo {",
            "@@ -456,44 +463,51 @@",
            " \t\titer->i--;",
            " ",
            " \t\tif (iter->current)",
            " \t\t\titer->current->free(iter->current);",
            " ",
            " \t\titer->current = NULL;",
            " \t\terror = backend->iterator(&iter->current, backend);",
            "+",
            " \t\tif (error == GIT_ENOTFOUND)",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (error < 0)",
            " \t\t\treturn error;",
            " ",
            "-\t\terror = iter->current->next(out, iter->current);",
            "+\t\tif ((error = iter->current->next(&be, iter->current)) == 0) {",
            "+\t\t\t*out = be;",
            "+\t\t\treturn 0;",
            "+\t\t}",
            "+",
            " \t\t/* If this backend is empty, then keep going */",
            " \t\tif (error == GIT_ITEROVER)",
            " \t\t\tcontinue;",
            " ",
            " \t\treturn error;",
            " ",
            " \t} while(1);",
            " ",
            " \treturn GIT_ITEROVER;",
            " }",
            " ",
            "-static int all_iter_glob_next(git_config_entry **entry, git_config_iterator *_iter)",
            "+static int all_iter_glob_next(",
            "+\tgit_config_backend_entry **entry,",
            "+\tgit_config_iterator *_iter)",
            " {",
            " \tint error;",
            " \tall_iter *iter = (all_iter *) _iter;",
            " ",
            " \t/*",
            " \t * We use the \"normal\" function to grab the next one across",
            " \t * readers and then apply the regex",
            " \t */",
            " \twhile ((error = all_iter_next(entry, _iter)) == 0) {",
            " \t\t/* skip non-matching keys if regexp was provided */",
            "-\t\tif (git_regexp_match(&iter->regex, (*entry)->name) != 0)",
            "+\t\tif (git_regexp_match(&iter->regex, (*entry)->entry.name) != 0)",
            " \t\t\tcontinue;",
            " ",
            " \t\t/* and simply return if we like the entry's name */",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \treturn error;",
            "@@ -569,15 +583,15 @@",
            " ",
            " int git_config_backend_foreach_match(",
            " \tgit_config_backend *backend,",
            " \tconst char *regexp,",
            " \tgit_config_foreach_cb cb,",
            " \tvoid *payload)",
            " {",
            "-\tgit_config_entry *entry;",
            "+\tgit_config_backend_entry *entry;",
            " \tgit_config_iterator *iter;",
            " \tgit_regexp regex;",
            " \tint error = 0;",
            " ",
            " \tGIT_ASSERT_ARG(backend);",
            " \tGIT_ASSERT_ARG(cb);",
            " ",
            "@@ -587,19 +601,19 @@",
            " \tif ((error = backend->iterator(&iter, backend)) < 0) {",
            " \t\titer = NULL;",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \twhile (!(iter->next(&entry, iter) < 0)) {",
            " \t\t/* skip non-matching keys if regexp was provided */",
            "-\t\tif (regexp && git_regexp_match(&regex, entry->name) != 0)",
            "+\t\tif (regexp && git_regexp_match(&regex, entry->entry.name) != 0)",
            " \t\t\tcontinue;",
            " ",
            " \t\t/* abort iterator on non-zero return value */",
            "-\t\tif ((error = cb(entry, payload)) != 0) {",
            "+\t\tif ((error = cb(&entry->entry, payload)) != 0) {",
            " \t\t\tgit_error_set_after_callback(error);",
            " \t\t\tbreak;",
            " \t\t}",
            " \t}",
            " ",
            " \tif (regexp != NULL)",
            " \t\tgit_regexp_dispose(&regex);",
            "@@ -768,14 +782,15 @@",
            " \tconst git_config *config,",
            " \tconst char *name,",
            " \tbool normalize_name,",
            " \tint want_errors)",
            " {",
            " \tbackend_entry *entry;",
            " \tgit_config_backend *backend;",
            "+\tgit_config_backend_entry *be;",
            " \tint res = GIT_ENOTFOUND;",
            " \tconst char *key = name;",
            " \tchar *normalized = NULL;",
            " \tsize_t i;",
            " ",
            " \t*out = NULL;",
            " ",
            "@@ -786,18 +801,20 @@",
            " \t}",
            " ",
            " \tres = GIT_ENOTFOUND;",
            " \tgit_vector_foreach(&config->readers, i, entry) {",
            " \t\tGIT_ASSERT(entry->instance && entry->instance->backend);",
            " ",
            " \t\tbackend = entry->instance->backend;",
            "-\t\tres = backend->get(backend, key, out);",
            "+\t\tres = backend->get(backend, key, &be);",
            " ",
            "-\t\tif (res != GIT_ENOTFOUND)",
            "+\t\tif (res != GIT_ENOTFOUND) {",
            "+\t\t\t*out = &be->entry;",
            " \t\t\tbreak;",
            "+\t\t}",
            " \t}",
            " ",
            " \tgit__free(normalized);",
            " ",
            " cleanup:",
            " \tif (res == GIT_ENOTFOUND) {",
            " \t\tres = (want_errors > GET_ALL_ERRORS) ? 0 : config_error_notfound(name);",
            "@@ -1039,24 +1056,24 @@",
            " ",
            " int git_config_get_multivar_foreach(",
            " \tconst git_config *config, const char *name, const char *regexp,",
            " \tgit_config_foreach_cb cb, void *payload)",
            " {",
            " \tint err, found;",
            " \tgit_config_iterator *iter;",
            "-\tgit_config_entry *entry;",
            "+\tgit_config_backend_entry *be;",
            " ",
            " \tif ((err = git_config_multivar_iterator_new(&iter, config, name, regexp)) < 0)",
            " \t\treturn err;",
            " ",
            " \tfound = 0;",
            "-\twhile ((err = iter->next(&entry, iter)) == 0) {",
            "+\twhile ((err = iter->next(&be, iter)) == 0) {",
            " \t\tfound = 1;",
            " ",
            "-\t\tif ((err = cb(entry, payload)) != 0) {",
            "+\t\tif ((err = cb(&be->entry, payload)) != 0) {",
            " \t\t\tgit_error_set_after_callback(err);",
            " \t\t\tbreak;",
            " \t\t}",
            " \t}",
            " ",
            " \titer->free(iter);",
            " \tif (err == GIT_ITEROVER)",
            "@@ -1072,27 +1089,29 @@",
            " \tgit_config_iterator parent;",
            " \tgit_config_iterator *iter;",
            " \tchar *name;",
            " \tgit_regexp regex;",
            " \tint have_regex;",
            " } multivar_iter;",
            " ",
            "-static int multivar_iter_next(git_config_entry **entry, git_config_iterator *_iter)",
            "+static int multivar_iter_next(",
            "+\tgit_config_backend_entry **entry,",
            "+\tgit_config_iterator *_iter)",
            " {",
            " \tmultivar_iter *iter = (multivar_iter *) _iter;",
            " \tint error = 0;",
            " ",
            " \twhile ((error = iter->iter->next(entry, iter->iter)) == 0) {",
            "-\t\tif (git__strcmp(iter->name, (*entry)->name))",
            "+\t\tif (git__strcmp(iter->name, (*entry)->entry.name))",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (!iter->have_regex)",
            " \t\t\treturn 0;",
            " ",
            "-\t\tif (git_regexp_match(&iter->regex, (*entry)->value) == 0)",
            "+\t\tif (git_regexp_match(&iter->regex, (*entry)->entry.value) == 0)",
            " \t\t\treturn 0;",
            " \t}",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static void multivar_iter_free(git_config_iterator *_iter)",
            "@@ -1164,15 +1183,22 @@",
            " \t\treturn GIT_EREADONLY;",
            " ",
            " \treturn backend->del_multivar(backend, name, regexp);",
            " }",
            " ",
            " int git_config_next(git_config_entry **entry, git_config_iterator *iter)",
            " {",
            "-\treturn iter->next(entry, iter);",
            "+\tgit_config_backend_entry *be;",
            "+\tint error;",
            "+",
            "+\tif ((error = iter->next(&be, iter)) != 0)",
            "+\t\treturn error;",
            "+",
            "+\t*entry = &be->entry;",
            "+\treturn 0;",
            " }",
            " ",
            " void git_config_iterator_free(git_config_iterator *iter)",
            " {",
            " \tif (iter == NULL)",
            " \t\treturn;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_backend.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_backend.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_backend.h",
            "@@ -47,15 +47,22 @@",
            " \tif (cfg)",
            " \t\tcfg->free(cfg);",
            " }",
            " ",
            " GIT_INLINE(int) git_config_backend_get_string(",
            " \tgit_config_entry **out, git_config_backend *cfg, const char *name)",
            " {",
            "-\treturn cfg->get(cfg, name, out);",
            "+\tgit_config_backend_entry *be;",
            "+\tint error;",
            "+",
            "+\tif ((error = cfg->get(cfg, name, &be)) < 0)",
            "+\t\treturn error;",
            "+",
            "+\t*out = &be->entry;",
            "+\treturn 0;",
            " }",
            " ",
            " GIT_INLINE(int) git_config_backend_set_string(",
            " \tgit_config_backend *cfg, const char *name, const char *value)",
            " {",
            " \treturn cfg->set(cfg, name, value);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_cache.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_cache.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_cache.c",
            "@@ -60,30 +60,29 @@",
            " ",
            " static git_configmap _configmap_logallrefupdates[] = {",
            " \t{GIT_CONFIGMAP_FALSE, NULL, GIT_LOGALLREFUPDATES_FALSE},",
            " \t{GIT_CONFIGMAP_TRUE, NULL, GIT_LOGALLREFUPDATES_TRUE},",
            " \t{GIT_CONFIGMAP_STRING, \"always\", GIT_LOGALLREFUPDATES_ALWAYS},",
            " };",
            " ",
            "-/*",
            "- * Generic map for integer values",
            "- */",
            "-static git_configmap _configmap_int[] = {",
            "+static git_configmap _configmap_abbrev[] = {",
            " \t{GIT_CONFIGMAP_INT32, NULL, 0},",
            "+\t{GIT_CONFIGMAP_FALSE, NULL, GIT_ABBREV_FALSE},",
            "+\t{GIT_CONFIGMAP_STRING, \"auto\", GIT_ABBREV_DEFAULT}",
            " };",
            " ",
            " static struct map_data _configmaps[] = {",
            " \t{\"core.autocrlf\", _configmap_autocrlf, ARRAY_SIZE(_configmap_autocrlf), GIT_AUTO_CRLF_DEFAULT},",
            " \t{\"core.eol\", _configmap_eol, ARRAY_SIZE(_configmap_eol), GIT_EOL_DEFAULT},",
            " \t{\"core.symlinks\", NULL, 0, GIT_SYMLINKS_DEFAULT },",
            " \t{\"core.ignorecase\", NULL, 0, GIT_IGNORECASE_DEFAULT },",
            " \t{\"core.filemode\", NULL, 0, GIT_FILEMODE_DEFAULT },",
            " \t{\"core.ignorestat\", NULL, 0, GIT_IGNORESTAT_DEFAULT },",
            " \t{\"core.trustctime\", NULL, 0, GIT_TRUSTCTIME_DEFAULT },",
            "-\t{\"core.abbrev\", _configmap_int, 1, GIT_ABBREV_DEFAULT },",
            "+\t{\"core.abbrev\", _configmap_abbrev, ARRAY_SIZE(_configmap_abbrev), GIT_ABBREV_DEFAULT },",
            " \t{\"core.precomposeunicode\", NULL, 0, GIT_PRECOMPOSE_DEFAULT },",
            " \t{\"core.safecrlf\", _configmap_safecrlf, ARRAY_SIZE(_configmap_safecrlf), GIT_SAFE_CRLF_DEFAULT},",
            " \t{\"core.logallrefupdates\", _configmap_logallrefupdates, ARRAY_SIZE(_configmap_logallrefupdates), GIT_LOGALLREFUPDATES_DEFAULT},",
            " \t{\"core.protecthfs\", NULL, 0, GIT_PROTECTHFS_DEFAULT },",
            " \t{\"core.protectntfs\", NULL, 0, GIT_PROTECTNTFS_DEFAULT },",
            " \t{\"core.fsyncobjectfiles\", NULL, 0, GIT_FSYNCOBJECTFILES_DEFAULT },",
            " \t{\"core.longpaths\", NULL, 0, GIT_LONGPATHS_DEFAULT },"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_file.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_file.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_file.c",
            "@@ -306,16 +306,16 @@",
            " \t\treturn error;",
            " ",
            " \t/* Check whether we'd be modifying an included or multivar key */",
            " \tif ((error = git_config_list_get_unique(&existing, config_list, key)) < 0) {",
            " \t\tif (error != GIT_ENOTFOUND)",
            " \t\t\tgoto out;",
            " \t\terror = 0;",
            "-\t} else if ((!existing->base.value && !value) ||",
            "-\t\t   (existing->base.value && value && !strcmp(existing->base.value, value))) {",
            "+\t} else if ((!existing->base.entry.value && !value) ||",
            "+\t\t   (existing->base.entry.value && value && !strcmp(existing->base.entry.value, value))) {",
            " \t\t/* don't update if old and new values already match */",
            " \t\terror = 0;",
            " \t\tgoto out;",
            " \t}",
            " ",
            " \t/* No early returns due to sanity checks, let's write it out and refresh */",
            " \tif (value) {",
            "@@ -332,15 +332,18 @@",
            " \tgit__free(key);",
            " \treturn error;",
            " }",
            " ",
            " /*",
            "  * Internal function that actually gets the value in string form",
            "  */",
            "-static int config_file_get(git_config_backend *cfg, const char *key, git_config_entry **out)",
            "+static int config_file_get(",
            "+\tgit_config_backend *cfg,",
            "+\tconst char *key,",
            "+\tgit_config_backend_entry **out)",
            " {",
            " \tconfig_file_backend *h = GIT_CONTAINER_OF(cfg, config_file_backend, parent);",
            " \tgit_config_list *config_list = NULL;",
            " \tgit_config_list_entry *entry;",
            " \tint error = 0;",
            " ",
            " \tif (!h->parent.readonly && ((error = config_file_refresh(cfg)) < 0))",
            "@@ -403,15 +406,15 @@",
            " \t/* Check whether we'd be modifying an included or multivar key */",
            " \tif ((error = git_config_list_get_unique(&entry, config_list, key)) < 0) {",
            " \t\tif (error == GIT_ENOTFOUND)",
            " \t\t\tgit_error_set(GIT_ERROR_CONFIG, \"could not find key '%s' to delete\", name);",
            " \t\tgoto out;",
            " \t}",
            " ",
            "-\tif ((error = config_file_write(b, name, entry->base.name, NULL, NULL)) < 0)",
            "+\tif ((error = config_file_write(b, name, entry->base.entry.name, NULL, NULL)) < 0)",
            " \t\tgoto out;",
            " ",
            " out:",
            " \tgit_config_list_free(config_list);",
            " \tgit__free(key);",
            " \treturn error;",
            " }",
            "@@ -791,44 +794,44 @@",
            " ",
            " \tif (git_str_oom(&buf))",
            " \t\treturn -1;",
            " ",
            " \tentry = git__calloc(1, sizeof(git_config_list_entry));",
            " \tGIT_ERROR_CHECK_ALLOC(entry);",
            " ",
            "-\tentry->base.name = git_str_detach(&buf);",
            "-\tGIT_ERROR_CHECK_ALLOC(entry->base.name);",
            "+\tentry->base.entry.name = git_str_detach(&buf);",
            "+\tGIT_ERROR_CHECK_ALLOC(entry->base.entry.name);",
            " ",
            " \tif (var_value) {",
            "-\t\tentry->base.value = git__strdup(var_value);",
            "-\t\tGIT_ERROR_CHECK_ALLOC(entry->base.value);",
            "+\t\tentry->base.entry.value = git__strdup(var_value);",
            "+\t\tGIT_ERROR_CHECK_ALLOC(entry->base.entry.value);",
            " \t}",
            " ",
            "-\tentry->base.backend_type = git_config_list_add_string(parse_data->config_list, CONFIG_FILE_TYPE);",
            "-\tGIT_ERROR_CHECK_ALLOC(entry->base.backend_type);",
            "+\tentry->base.entry.backend_type = git_config_list_add_string(parse_data->config_list, CONFIG_FILE_TYPE);",
            "+\tGIT_ERROR_CHECK_ALLOC(entry->base.entry.backend_type);",
            " ",
            "-\tentry->base.origin_path = git_config_list_add_string(parse_data->config_list, parse_data->file->path);",
            "-\tGIT_ERROR_CHECK_ALLOC(entry->base.origin_path);",
            "+\tentry->base.entry.origin_path = git_config_list_add_string(parse_data->config_list, parse_data->file->path);",
            "+\tGIT_ERROR_CHECK_ALLOC(entry->base.entry.origin_path);",
            " ",
            "-\tentry->base.level = parse_data->level;",
            "-\tentry->base.include_depth = parse_data->depth;",
            "+\tentry->base.entry.level = parse_data->level;",
            "+\tentry->base.entry.include_depth = parse_data->depth;",
            " \tentry->base.free = git_config_list_entry_free;",
            " \tentry->config_list = parse_data->config_list;",
            " ",
            " \tif ((result = git_config_list_append(parse_data->config_list, entry)) < 0)",
            " \t\treturn result;",
            " ",
            " \tresult = 0;",
            " ",
            " \t/* Add or append the new config option */",
            "-\tif (!git__strcmp(entry->base.name, \"include.path\"))",
            "-\t\tresult = parse_include(parse_data, entry->base.value);",
            "-\telse if (!git__prefixcmp(entry->base.name, \"includeif.\") &&",
            "-\t         !git__suffixcmp(entry->base.name, \".path\"))",
            "-\t\tresult = parse_conditional_include(parse_data, entry->base.name, entry->base.value);",
            "+\tif (!git__strcmp(entry->base.entry.name, \"include.path\"))",
            "+\t\tresult = parse_include(parse_data, entry->base.entry.value);",
            "+\telse if (!git__prefixcmp(entry->base.entry.name, \"includeif.\") &&",
            "+\t         !git__suffixcmp(entry->base.entry.name, \".path\"))",
            "+\t\tresult = parse_conditional_include(parse_data, entry->base.entry.name, entry->base.entry.value);",
            " ",
            " \treturn result;",
            " }",
            " ",
            " static int config_file_read_buffer(",
            " \tgit_config_list *config_list,",
            " \tconst git_repository *repo,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_list.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_list.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_list.c",
            "@@ -2,14 +2,15 @@",
            "  * Copyright (C) the libgit2 contributors. All rights reserved.",
            "  *",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " ",
            " #include \"config_list.h\"",
            "+#include \"hashmap_str.h\"",
            " ",
            " typedef struct config_entry_list {",
            " \tstruct config_entry_list *next;",
            " \tstruct config_entry_list *last;",
            " \tgit_config_list_entry *entry;",
            " } config_entry_list;",
            " ",
            "@@ -20,82 +21,76 @@",
            " ",
            " typedef struct config_list_iterator {",
            " \tgit_config_iterator parent;",
            " \tgit_config_list *list;",
            " \tconfig_entry_list *head;",
            " } config_list_iterator;",
            " ",
            "+GIT_HASHMAP_STR_SETUP(git_config_list_pathmap, char *);",
            "+GIT_HASHMAP_STR_SETUP(git_config_list_headmap, config_entry_map_head *);",
            "+",
            " struct git_config_list {",
            " \tgit_refcount rc;",
            " ",
            " \t/* Interned strings - paths to config files or backend types */",
            "-\tgit_strmap *strings;",
            "+\tgit_config_list_pathmap strings;",
            " ",
            " \t/* Config entries */",
            "-\tgit_strmap *map;",
            "+\tgit_config_list_headmap map;",
            " \tconfig_entry_list *entries;",
            " };",
            " ",
            " int git_config_list_new(git_config_list **out)",
            " {",
            " \tgit_config_list *config_list;",
            " ",
            " \tconfig_list = git__calloc(1, sizeof(git_config_list));",
            " \tGIT_ERROR_CHECK_ALLOC(config_list);",
            " \tGIT_REFCOUNT_INC(config_list);",
            " ",
            "-\tif (git_strmap_new(&config_list->strings) < 0 ||",
            "-\t    git_strmap_new(&config_list->map) < 0) {",
            "-\t\tgit_strmap_free(config_list->strings);",
            "-\t\tgit_strmap_free(config_list->map);",
            "-\t\tgit__free(config_list);",
            "-",
            "-\t\treturn -1;",
            "-\t}",
            "-",
            " \t*out = config_list;",
            " \treturn 0;",
            " }",
            " ",
            " int git_config_list_dup_entry(git_config_list *config_list, const git_config_entry *entry)",
            " {",
            " \tgit_config_list_entry *duplicated;",
            " \tint error;",
            " ",
            " \tduplicated = git__calloc(1, sizeof(git_config_list_entry));",
            " \tGIT_ERROR_CHECK_ALLOC(duplicated);",
            " ",
            "-\tduplicated->base.name = git__strdup(entry->name);",
            "-\tGIT_ERROR_CHECK_ALLOC(duplicated->base.name);",
            "+\tduplicated->base.entry.name = git__strdup(entry->name);",
            "+\tGIT_ERROR_CHECK_ALLOC(duplicated->base.entry.name);",
            " ",
            " \tif (entry->value) {",
            "-\t\tduplicated->base.value = git__strdup(entry->value);",
            "-\t\tGIT_ERROR_CHECK_ALLOC(duplicated->base.value);",
            "+\t\tduplicated->base.entry.value = git__strdup(entry->value);",
            "+\t\tGIT_ERROR_CHECK_ALLOC(duplicated->base.entry.value);",
            " \t}",
            " ",
            "-\tduplicated->base.backend_type = git_config_list_add_string(config_list, entry->backend_type);",
            "-\tGIT_ERROR_CHECK_ALLOC(duplicated->base.backend_type);",
            "+\tduplicated->base.entry.backend_type = git_config_list_add_string(config_list, entry->backend_type);",
            "+\tGIT_ERROR_CHECK_ALLOC(duplicated->base.entry.backend_type);",
            " ",
            " \tif (entry->origin_path) {",
            "-\t\tduplicated->base.origin_path = git_config_list_add_string(config_list, entry->origin_path);",
            "-\t\tGIT_ERROR_CHECK_ALLOC(duplicated->base.origin_path);",
            "+\t\tduplicated->base.entry.origin_path = git_config_list_add_string(config_list, entry->origin_path);",
            "+\t\tGIT_ERROR_CHECK_ALLOC(duplicated->base.entry.origin_path);",
            " \t}",
            " ",
            "-\tduplicated->base.level = entry->level;",
            "-\tduplicated->base.include_depth = entry->include_depth;",
            "+\tduplicated->base.entry.level = entry->level;",
            "+\tduplicated->base.entry.include_depth = entry->include_depth;",
            " \tduplicated->base.free = git_config_list_entry_free;",
            " \tduplicated->config_list = config_list;",
            " ",
            " \tif ((error = git_config_list_append(config_list, duplicated)) < 0)",
            " \t\tgoto out;",
            " ",
            " out:",
            " \tif (error && duplicated) {",
            "-\t\tgit__free((char *) duplicated->base.name);",
            "-\t\tgit__free((char *) duplicated->base.value);",
            "+\t\tgit__free((char *) duplicated->base.entry.name);",
            "+\t\tgit__free((char *) duplicated->base.entry.value);",
            " \t\tgit__free(duplicated);",
            " \t}",
            " \treturn error;",
            " }",
            " ",
            " int git_config_list_dup(git_config_list **out, git_config_list *config_list)",
            " {",
            "@@ -103,15 +98,15 @@",
            " \tconfig_entry_list *head;",
            " \tint error;",
            " ",
            " \tif ((error = git_config_list_new(&result)) < 0)",
            " \t\tgoto out;",
            " ",
            " \tfor (head = config_list->entries; head; head = head->next)",
            "-\t\tif ((git_config_list_dup_entry(result, &head->entry->base)) < 0)",
            "+\t\tif ((git_config_list_dup_entry(result, &head->entry->base.entry)) < 0)",
            " \t\t\tgoto out;",
            " ",
            " \t*out = result;",
            " \tresult = NULL;",
            " ",
            " out:",
            " \tgit_config_list_free(result);",
            "@@ -124,30 +119,32 @@",
            " }",
            " ",
            " static void config_list_free(git_config_list *config_list)",
            " {",
            " \tconfig_entry_list *entry_list = NULL, *next;",
            " \tconfig_entry_map_head *head;",
            " \tchar *str;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            "-\tgit_strmap_foreach_value(config_list->strings, str, {",
            "+\twhile (git_config_list_pathmap_iterate(&iter, NULL, &str, &config_list->strings) == 0)",
            " \t\tgit__free(str);",
            "-\t});",
            "-\tgit_strmap_free(config_list->strings);",
            " ",
            "-\tgit_strmap_foreach_value(config_list->map, head, {",
            "-\t\tgit__free((char *) head->entry->base.name);",
            "+\tgit_config_list_pathmap_dispose(&config_list->strings);",
            "+",
            "+\titer = GIT_HASHMAP_ITER_INIT;",
            "+\twhile (git_config_list_headmap_iterate(&iter, NULL, &head, &config_list->map) == 0) {",
            "+\t\tgit__free((char *) head->entry->base.entry.name);",
            " \t\tgit__free(head);",
            "-\t});",
            "-\tgit_strmap_free(config_list->map);",
            "+\t}",
            "+\tgit_config_list_headmap_dispose(&config_list->map);",
            " ",
            " \tentry_list = config_list->entries;",
            " \twhile (entry_list != NULL) {",
            " \t\tnext = entry_list->next;",
            "-\t\tgit__free((char *) entry_list->entry->base.value);",
            "+\t\tgit__free((char *) entry_list->entry->base.entry.value);",
            " \t\tgit__free(entry_list->entry);",
            " \t\tgit__free(entry_list);",
            " \t\tentry_list = next;",
            " \t}",
            " ",
            " \tgit__free(config_list);",
            " }",
            "@@ -159,27 +156,27 @@",
            " }",
            " ",
            " int git_config_list_append(git_config_list *config_list, git_config_list_entry *entry)",
            " {",
            " \tconfig_entry_list *list_head;",
            " \tconfig_entry_map_head *map_head;",
            " ",
            "-\tif ((map_head = git_strmap_get(config_list->map, entry->base.name)) != NULL) {",
            "+\tif (git_config_list_headmap_get(&map_head, &config_list->map, entry->base.entry.name) == 0) {",
            " \t\tmap_head->multivar = true;",
            " \t\t/*",
            " \t\t * This is a micro-optimization for configuration files",
            " \t\t * with a lot of same keys. As for multivars the entry's",
            " \t\t * key will be the same for all list, we can just free",
            " \t\t * all except the first entry's name and just re-use it.",
            " \t\t */",
            "-\t\tgit__free((char *) entry->base.name);",
            "-\t\tentry->base.name = map_head->entry->base.name;",
            "+\t\tgit__free((char *) entry->base.entry.name);",
            "+\t\tentry->base.entry.name = map_head->entry->base.entry.name;",
            " \t} else {",
            " \t\tmap_head = git__calloc(1, sizeof(*map_head));",
            "-\t\tif ((git_strmap_set(config_list->map, entry->base.name, map_head)) < 0)",
            "+\t\tif ((git_config_list_headmap_put(&config_list->map, entry->base.entry.name, map_head)) < 0)",
            " \t\t\treturn -1;",
            " \t}",
            " \tmap_head->entry = entry;",
            " ",
            " \tlist_head = git__calloc(1, sizeof(config_entry_list));",
            " \tGIT_ERROR_CHECK_ALLOC(list_head);",
            " \tlist_head->entry = entry;",
            "@@ -193,34 +190,34 @@",
            " \treturn 0;",
            " }",
            " ",
            " int git_config_list_get(git_config_list_entry **out, git_config_list *config_list, const char *key)",
            " {",
            " \tconfig_entry_map_head *entry;",
            " ",
            "-\tif ((entry = git_strmap_get(config_list->map, key)) == NULL)",
            "+\tif (git_config_list_headmap_get(&entry, &config_list->map, key) != 0)",
            " \t\treturn GIT_ENOTFOUND;",
            " ",
            " \t*out = entry->entry;",
            " \treturn 0;",
            " }",
            " ",
            " int git_config_list_get_unique(git_config_list_entry **out, git_config_list *config_list, const char *key)",
            " {",
            " \tconfig_entry_map_head *entry;",
            " ",
            "-\tif ((entry = git_strmap_get(config_list->map, key)) == NULL)",
            "+\tif (git_config_list_headmap_get(&entry, &config_list->map, key) != 0)",
            " \t\treturn GIT_ENOTFOUND;",
            " ",
            " \tif (entry->multivar) {",
            " \t\tgit_error_set(GIT_ERROR_CONFIG, \"entry is not unique due to being a multivar\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            "-\tif (entry->entry->base.include_depth) {",
            "+\tif (entry->entry->base.entry.include_depth) {",
            " \t\tgit_error_set(GIT_ERROR_CONFIG, \"entry is not unique due to being included\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \t*out = entry->entry;",
            " \treturn 0;",
            " }",
            "@@ -229,15 +226,15 @@",
            " {",
            " \tconfig_list_iterator *it = (config_list_iterator *) iter;",
            " \tgit_config_list_free(it->list);",
            " \tgit__free(it);",
            " }",
            " ",
            " static int config_iterator_next(",
            "-\tgit_config_entry **entry,",
            "+\tgit_config_backend_entry **entry,",
            " \tgit_config_iterator *iter)",
            " {",
            " \tconfig_list_iterator *it = (config_list_iterator *) iter;",
            " ",
            " \tif (!it->head)",
            " \t\treturn GIT_ITEROVER;",
            " ",
            "@@ -261,28 +258,28 @@",
            " \tgit_config_list_incref(config_list);",
            " \t*out = &it->parent;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " /* release the map containing the entry as an equivalent to freeing it */",
            "-void git_config_list_entry_free(git_config_entry *e)",
            "+void git_config_list_entry_free(git_config_backend_entry *e)",
            " {",
            " \tgit_config_list_entry *entry = (git_config_list_entry *)e;",
            " \tgit_config_list_free(entry->config_list);",
            " }",
            " ",
            " const char *git_config_list_add_string(",
            " \tgit_config_list *config_list,",
            " \tconst char *str)",
            " {",
            "-\tconst char *s;",
            "+\tchar *s;",
            " ",
            "-\tif ((s = git_strmap_get(config_list->strings, str)) != NULL)",
            "+\tif (git_config_list_pathmap_get(&s, &config_list->strings, str) == 0)",
            " \t\treturn s;",
            " ",
            " \tif ((s = git__strdup(str)) == NULL ||",
            "-\t    git_strmap_set(config_list->strings, s, (void *)s) < 0)",
            "+\t     git_config_list_pathmap_put(&config_list->strings, s, s) < 0)",
            " \t\treturn NULL;",
            " ",
            " \treturn s;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_list.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_list.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_list.h",
            "@@ -9,15 +9,15 @@",
            " ",
            " #include \"git2/sys/config.h\"",
            " #include \"config.h\"",
            " ",
            " typedef struct git_config_list git_config_list;",
            " ",
            " typedef struct {",
            "-\tgit_config_entry base;",
            "+\tgit_config_backend_entry base;",
            " \tgit_config_list *config_list;",
            " } git_config_list_entry;",
            " ",
            " int git_config_list_new(git_config_list **out);",
            " int git_config_list_dup(git_config_list **out, git_config_list *list);",
            " int git_config_list_dup_entry(git_config_list *list, const git_config_entry *entry);",
            " void git_config_list_incref(git_config_list *list);",
            "@@ -25,8 +25,8 @@",
            " /* Add or append the new config option */",
            " int git_config_list_append(git_config_list *list, git_config_list_entry *entry);",
            " int git_config_list_get(git_config_list_entry **out, git_config_list *list, const char *key);",
            " int git_config_list_get_unique(git_config_list_entry **out, git_config_list *list, const char *key);",
            " int git_config_list_iterator_new(git_config_iterator **out, git_config_list *list);",
            " const char *git_config_list_add_string(git_config_list *list, const char *str);",
            " ",
            "-void git_config_list_entry_free(git_config_entry *entry);",
            "+void git_config_list_entry_free(git_config_backend_entry *entry);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_mem.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_mem.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_mem.c",
            "@@ -73,20 +73,20 @@",
            " \t\tgit_str_putc(&buf, git__tolower(*c));",
            " ",
            " \tif (git_str_oom(&buf))",
            " \t\treturn -1;",
            " ",
            " \tentry = git__calloc(1, sizeof(git_config_list_entry));",
            " \tGIT_ERROR_CHECK_ALLOC(entry);",
            "-\tentry->base.name = git_str_detach(&buf);",
            "-\tentry->base.value = var_value ? git__strdup(var_value) : NULL;",
            "-\tentry->base.level = parse_data->level;",
            "-\tentry->base.include_depth = 0;",
            "-\tentry->base.backend_type = parse_data->backend_type;",
            "-\tentry->base.origin_path = parse_data->origin_path;",
            "+\tentry->base.entry.name = git_str_detach(&buf);",
            "+\tentry->base.entry.value = var_value ? git__strdup(var_value) : NULL;",
            "+\tentry->base.entry.level = parse_data->level;",
            "+\tentry->base.entry.include_depth = 0;",
            "+\tentry->base.entry.backend_type = parse_data->backend_type;",
            "+\tentry->base.entry.origin_path = parse_data->origin_path;",
            " \tentry->base.free = git_config_list_entry_free;",
            " \tentry->config_list = parse_data->config_list;",
            " ",
            " \tif ((result = git_config_list_append(parse_data->config_list, entry)) < 0)",
            " \t\treturn result;",
            " ",
            " \treturn result;",
            "@@ -147,26 +147,26 @@",
            " \t\t\tgit_error_set(GIT_ERROR_CONFIG, \"empty config key\");",
            " \t\t\treturn -1;",
            " \t\t}",
            " ",
            " \t\tentry = git__calloc(1, sizeof(git_config_list_entry));",
            " \t\tGIT_ERROR_CHECK_ALLOC(entry);",
            " ",
            "-\t\tentry->base.name = git__strndup(memory_backend->values[i], name_len);",
            "-\t\tGIT_ERROR_CHECK_ALLOC(entry->base.name);",
            "+\t\tentry->base.entry.name = git__strndup(memory_backend->values[i], name_len);",
            "+\t\tGIT_ERROR_CHECK_ALLOC(entry->base.entry.name);",
            " ",
            " \t\tif (eql) {",
            "-\t\t\tentry->base.value = git__strdup(eql + 1);",
            "-\t\t\tGIT_ERROR_CHECK_ALLOC(entry->base.value);",
            "+\t\t\tentry->base.entry.value = git__strdup(eql + 1);",
            "+\t\t\tGIT_ERROR_CHECK_ALLOC(entry->base.entry.value);",
            " \t\t}",
            " ",
            "-\t\tentry->base.level = level;",
            "-\t\tentry->base.include_depth = 0;",
            "-\t\tentry->base.backend_type = backend_type;",
            "-\t\tentry->base.origin_path = origin_path;",
            "+\t\tentry->base.entry.level = level;",
            "+\t\tentry->base.entry.include_depth = 0;",
            "+\t\tentry->base.entry.backend_type = backend_type;",
            "+\t\tentry->base.entry.origin_path = origin_path;",
            " \t\tentry->base.free = git_config_list_entry_free;",
            " \t\tentry->config_list = memory_backend->config_list;",
            " ",
            " \t\tif (git_config_list_append(memory_backend->config_list, entry) < 0)",
            " \t\t\treturn -1;",
            " \t}",
            " ",
            "@@ -186,15 +186,15 @@",
            " \tif (memory_backend->values_len > 0 &&",
            " \t    parse_values(memory_backend, level) < 0)",
            " \t\treturn -1;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-static int config_memory_get(git_config_backend *backend, const char *key, git_config_entry **out)",
            "+static int config_memory_get(git_config_backend *backend, const char *key, git_config_backend_entry **out)",
            " {",
            " \tconfig_memory_backend *memory_backend = (config_memory_backend *) backend;",
            " \tgit_config_list_entry *entry;",
            " \tint error;",
            " ",
            " \tif ((error = git_config_list_get(&entry, memory_backend->config_list, key)) != 0)",
            " \t\treturn error;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/config_snapshot.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/config_snapshot.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/config_snapshot.c",
            "@@ -37,15 +37,18 @@",
            " ",
            " out:",
            " \t/* Let iterator delete duplicated config_list when it's done */",
            " \tgit_config_list_free(config_list);",
            " \treturn error;",
            " }",
            " ",
            "-static int config_snapshot_get(git_config_backend *cfg, const char *key, git_config_entry **out)",
            "+static int config_snapshot_get(",
            "+\tgit_config_backend *cfg,",
            "+\tconst char *key,",
            "+\tgit_config_backend_entry **out)",
            " {",
            " \tconfig_snapshot_backend *b = GIT_CONTAINER_OF(cfg, config_snapshot_backend, parent);",
            " \tgit_config_list *config_list = NULL;",
            " \tgit_config_list_entry *entry;",
            " \tint error = 0;",
            " ",
            " \tif (git_mutex_lock(&b->values_mutex) < 0) {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/describe.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/describe.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/describe.c",
            "@@ -10,46 +10,48 @@",
            " #include \"git2/describe.h\"",
            " #include \"git2/diff.h\"",
            " #include \"git2/status.h\"",
            " ",
            " #include \"buf.h\"",
            " #include \"commit.h\"",
            " #include \"commit_list.h\"",
            "-#include \"oidmap.h\"",
            " #include \"refs.h\"",
            " #include \"repository.h\"",
            " #include \"revwalk.h\"",
            " #include \"strarray.h\"",
            " #include \"tag.h\"",
            " #include \"vector.h\"",
            " #include \"wildmatch.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            " /* Ported from https://github.com/git/git/blob/89dde7882f71f846ccd0359756d27bebc31108de/builtin/describe.c */",
            " ",
            " struct commit_name {",
            " \tgit_tag *tag;",
            " \tunsigned prio:2; /* annotated tag = 2, tag = 1, head = 0 */",
            " \tunsigned name_checked:1;",
            " \tgit_oid sha1;",
            " \tchar *path;",
            " ",
            "-\t/* Khash workaround. They original key has to still be reachable */",
            "+\t/* The original key for the hashmap */",
            " \tgit_oid peeled;",
            " };",
            " ",
            "-static void *oidmap_value_bykey(git_oidmap *map, const git_oid *key)",
            "-{",
            "-\treturn git_oidmap_get(map, key);",
            "-}",
            "+GIT_HASHMAP_OID_SETUP(git_describe_oidmap, struct commit_name *);",
            " ",
            " static struct commit_name *find_commit_name(",
            "-\tgit_oidmap *names,",
            "+\tgit_describe_oidmap *names,",
            " \tconst git_oid *peeled)",
            " {",
            "-\treturn (struct commit_name *)(oidmap_value_bykey(names, peeled));",
            "+\tstruct commit_name *result;",
            "+",
            "+\tif (git_describe_oidmap_get(&result, names, peeled) == 0)",
            "+\t\treturn result;",
            "+",
            "+\treturn NULL;",
            " }",
            " ",
            " static int replace_name(",
            " \tgit_tag **tag,",
            " \tgit_repository *repo,",
            " \tstruct commit_name *e,",
            " \tunsigned int prio,",
            "@@ -88,15 +90,15 @@",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int add_to_known_names(",
            " \tgit_repository *repo,",
            "-\tgit_oidmap *names,",
            "+\tgit_describe_oidmap *names,",
            " \tconst char *path,",
            " \tconst git_oid *peeled,",
            " \tunsigned int prio,",
            " \tconst git_oid *sha1)",
            " {",
            " \tstruct commit_name *e = find_commit_name(names, peeled);",
            " \tbool found = (e != NULL);",
            "@@ -117,15 +119,15 @@",
            " \t\te->prio = prio;",
            " \t\te->name_checked = 0;",
            " \t\tgit_oid_cpy(&e->sha1, sha1);",
            " \t\tgit__free(e->path);",
            " \t\te->path = git__strdup(path);",
            " \t\tgit_oid_cpy(&e->peeled, peeled);",
            " ",
            "-\t\tif (!found && git_oidmap_set(names, &e->peeled, e) < 0)",
            "+\t\tif (!found && git_describe_oidmap_put(names, &e->peeled, e) < 0)",
            " \t\t\treturn -1;",
            " \t}",
            " \telse",
            " \t\tgit_tag_free(tag);",
            " ",
            " \treturn 0;",
            " }",
            "@@ -170,15 +172,15 @@",
            " \tstruct possible_tag *tag;",
            " };",
            " ",
            " struct get_name_data",
            " {",
            " \tgit_describe_options *opts;",
            " \tgit_repository *repo;",
            "-\tgit_oidmap *names;",
            "+\tgit_describe_oidmap names;",
            " \tgit_describe_result *result;",
            " };",
            " ",
            " static int commit_name_dup(struct commit_name **out, struct commit_name *in)",
            " {",
            " \tstruct commit_name *name;",
            " ",
            "@@ -236,15 +238,15 @@",
            " \tif (is_annotated)",
            " \t\tprio = 2;",
            " \telse if (is_tag)",
            " \t\tprio = 1;",
            " \telse",
            " \t\tprio = 0;",
            " ",
            "-\tadd_to_known_names(data->repo, data->names,",
            "+\tadd_to_known_names(data->repo, &data->names,",
            " \t\tall ? refname + strlen(GIT_REFS_DIR) : refname + strlen(GIT_REFS_TAGS_DIR),",
            " \t\t&peeled, prio, &sha1);",
            " \treturn 0;",
            " }",
            " ",
            " struct possible_tag {",
            " \tstruct commit_name *name;",
            "@@ -447,15 +449,15 @@",
            " \t\tgoto cleanup;",
            " ",
            " \tall = data->opts->describe_strategy == GIT_DESCRIBE_ALL;",
            " \ttags = data->opts->describe_strategy == GIT_DESCRIBE_TAGS;",
            " ",
            " \tgit_oid_cpy(&data->result->commit_id, git_commit_id(commit));",
            " ",
            "-\tn = find_commit_name(data->names, git_commit_id(commit));",
            "+\tn = find_commit_name(&data->names, git_commit_id(commit));",
            " \tif (n && (tags || all || n->prio == 2)) {",
            " \t\t/*",
            " \t\t * Exact match to an existing ref.",
            " \t\t */",
            " \t\tdata->result->exact_match = 1;",
            " \t\tif ((error = commit_name_dup(&data->result->name, n)) < 0)",
            " \t\t\tgoto cleanup;",
            "@@ -488,15 +490,15 @@",
            " \twhile (git_pqueue_size(&list) > 0)",
            " \t{",
            " \t\tint i;",
            " ",
            " \t\tgit_commit_list_node *c = (git_commit_list_node *)git_pqueue_pop(&list);",
            " \t\tseen_commits++;",
            " ",
            "-\t\tn = find_commit_name(data->names, &c->oid);",
            "+\t\tn = find_commit_name(&data->names, &c->oid);",
            " ",
            " \t\tif (n) {",
            " \t\t\tif (!tags && !all && n->prio < 2) {",
            " \t\t\t\tunannotated_cnt++;",
            " \t\t\t} else if (match_cnt < data->opts->max_candidates_tags) {",
            " \t\t\t\tstruct possible_tag *t = git__malloc(sizeof(struct commit_name));",
            " \t\t\t\tGIT_ERROR_CHECK_ALLOC(t);",
            "@@ -623,15 +625,15 @@",
            " \t{",
            " \t\tsize_t i;",
            " \t\tstruct possible_tag *match;",
            " \t\tgit_vector_foreach(&all_matches, i, match) {",
            " \t\t\tgit__free(match);",
            " \t\t}",
            " \t}",
            "-\tgit_vector_free(&all_matches);",
            "+\tgit_vector_dispose(&all_matches);",
            " \tgit_pqueue_free(&list);",
            " \tgit_revwalk_free(walk);",
            " \treturn error;",
            " }",
            " ",
            " static int normalize_options(",
            " \tgit_describe_options *dst,",
            "@@ -649,19 +651,20 @@",
            " }",
            " ",
            " int git_describe_commit(",
            " \tgit_describe_result **result,",
            " \tgit_object *committish,",
            " \tgit_describe_options *opts)",
            " {",
            "-\tstruct get_name_data data;",
            "+\tstruct get_name_data data = {0};",
            " \tstruct commit_name *name;",
            " \tgit_commit *commit;",
            "-\tint error = -1;",
            " \tgit_describe_options normalized;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_INIT;",
            "+\tint error = -1;",
            " ",
            " \tGIT_ASSERT_ARG(result);",
            " \tGIT_ASSERT_ARG(committish);",
            " ",
            " \tdata.result = git__calloc(1, sizeof(git_describe_result));",
            " \tGIT_ERROR_CHECK_ALLOC(data.result);",
            " \tdata.result->repo = git_object_owner(committish);",
            "@@ -673,47 +676,44 @@",
            " ",
            " \tGIT_ERROR_CHECK_VERSION(",
            " \t\t&normalized,",
            " \t\tGIT_DESCRIBE_OPTIONS_VERSION,",
            " \t\t\"git_describe_options\");",
            " \tdata.opts = &normalized;",
            " ",
            "-\tif ((error = git_oidmap_new(&data.names)) < 0)",
            "-\t\treturn error;",
            "-",
            " \t/** TODO: contains to be implemented */",
            " ",
            " \tif ((error = git_object_peel((git_object **)(&commit), committish, GIT_OBJECT_COMMIT)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tif ((error = git_reference_foreach_name(",
            " \t\t\tgit_object_owner(committish),",
            " \t\t\tget_name, &data)) < 0)",
            " \t\t\t\tgoto cleanup;",
            " ",
            "-\tif (git_oidmap_size(data.names) == 0 && !normalized.show_commit_oid_as_fallback) {",
            "+\tif (git_describe_oidmap_size(&data.names) == 0 && !normalized.show_commit_oid_as_fallback) {",
            " \t\tgit_error_set(GIT_ERROR_DESCRIBE, \"cannot describe - \"",
            " \t\t\t\"no reference found, cannot describe anything.\");",
            " \t\terror = -1;",
            " \t\tgoto cleanup;",
            " \t}",
            " ",
            " \tif ((error = describe(&data, commit)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " cleanup:",
            " \tgit_commit_free(commit);",
            " ",
            "-\tgit_oidmap_foreach_value(data.names, name, {",
            "+\twhile (git_describe_oidmap_iterate(&iter, NULL, &name, &data.names) == 0) {",
            " \t\tgit_tag_free(name->tag);",
            " \t\tgit__free(name->path);",
            " \t\tgit__free(name);",
            "-\t});",
            "+\t}",
            " ",
            "-\tgit_oidmap_free(data.names);",
            "+\tgit_describe_oidmap_dispose(&data.names);",
            " ",
            " \tif (error < 0)",
            " \t\tgit_describe_result_free(data.result);",
            " \telse",
            " \t\t*result = data.result;",
            " ",
            " \treturn error;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff.c",
            "@@ -12,15 +12,15 @@",
            " #include \"patch.h\"",
            " #include \"email.h\"",
            " #include \"commit.h\"",
            " #include \"index.h\"",
            " #include \"diff_generate.h\"",
            " ",
            " #include \"git2/version.h\"",
            "-#include \"git2/email.h\"",
            "+#include \"git2/sys/email.h\"",
            " ",
            " struct patch_id_args {",
            " \tgit_diff *diff;",
            " \tgit_hash_ctx ctx;",
            " \tgit_oid result;",
            " \tgit_oid_t oid_type;",
            " \tint first_file;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_driver.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_driver.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_driver.c",
            "@@ -7,19 +7,19 @@",
            " ",
            " #include \"diff_driver.h\"",
            " ",
            " #include \"git2/attr.h\"",
            " ",
            " #include \"common.h\"",
            " #include \"diff.h\"",
            "-#include \"strmap.h\"",
            " #include \"map.h\"",
            " #include \"config.h\"",
            " #include \"regexp.h\"",
            " #include \"repository.h\"",
            "+#include \"userdiff.h\"",
            " ",
            " typedef enum {",
            " \tDIFF_DRIVER_AUTO = 0,",
            " \tDIFF_DRIVER_BINARY = 1,",
            " \tDIFF_DRIVER_TEXT = 2,",
            " \tDIFF_DRIVER_PATTERNLIST = 3",
            " } git_diff_driver_t;",
            "@@ -39,50 +39,43 @@",
            " \tuint32_t binary_flags;",
            " \tuint32_t other_flags;",
            " \tgit_array_t(git_diff_driver_pattern) fn_patterns;",
            " \tgit_regexp  word_pattern;",
            " \tchar name[GIT_FLEX_ARRAY];",
            " };",
            " ",
            "-#include \"userdiff.h\"",
            "+GIT_HASHMAP_STR_SETUP(git_diff_driver_map, git_diff_driver *);",
            " ",
            " struct git_diff_driver_registry {",
            "-\tgit_strmap *drivers;",
            "+\tgit_diff_driver_map map;",
            " };",
            " ",
            " #define FORCE_DIFFABLE (GIT_DIFF_FORCE_TEXT | GIT_DIFF_FORCE_BINARY)",
            " ",
            " static git_diff_driver diff_driver_auto =   { DIFF_DRIVER_AUTO,   0, 0 };",
            " static git_diff_driver diff_driver_binary = { DIFF_DRIVER_BINARY, GIT_DIFF_FORCE_BINARY, 0 };",
            " static git_diff_driver diff_driver_text =   { DIFF_DRIVER_TEXT,   GIT_DIFF_FORCE_TEXT, 0 };",
            " ",
            " git_diff_driver_registry *git_diff_driver_registry_new(void)",
            " {",
            "-\tgit_diff_driver_registry *reg =",
            "-\t\tgit__calloc(1, sizeof(git_diff_driver_registry));",
            "-\tif (!reg)",
            "-\t\treturn NULL;",
            "-",
            "-\tif (git_strmap_new(&reg->drivers) < 0) {",
            "-\t\tgit_diff_driver_registry_free(reg);",
            "-\t\treturn NULL;",
            "-\t}",
            "-",
            "-\treturn reg;",
            "+\treturn git__calloc(1, sizeof(git_diff_driver_registry));",
            " }",
            " ",
            " void git_diff_driver_registry_free(git_diff_driver_registry *reg)",
            " {",
            " \tgit_diff_driver *drv;",
            "+\tgit_hashmap_iter_t iter = 0;",
            " ",
            " \tif (!reg)",
            " \t\treturn;",
            " ",
            "-\tgit_strmap_foreach_value(reg->drivers, drv, git_diff_driver_free(drv));",
            "-\tgit_strmap_free(reg->drivers);",
            "+\twhile (git_diff_driver_map_iterate(&iter, NULL, &drv, &reg->map) == 0)",
            "+\t\tgit_diff_driver_free(drv);",
            "+",
            "+\tgit_diff_driver_map_dispose(&reg->map);",
            " \tgit__free(reg);",
            " }",
            " ",
            " static int diff_driver_add_patterns(",
            " \tgit_diff_driver *drv, const char *regex_str, int regex_flags)",
            " {",
            " \tint error = 0;",
            "@@ -211,15 +204,15 @@",
            " \t\t\tdrv, ddef->fns, ddef->flags)) < 0)",
            " \t\tgoto done;",
            " ",
            " \tif (ddef->words &&",
            " \t    (error = git_regexp_compile(&drv->word_pattern, ddef->words, ddef->flags)) < 0)",
            " \t\tgoto done;",
            " ",
            "-\tif ((error = git_strmap_set(reg->drivers, drv->name, drv)) < 0)",
            "+\tif ((error = git_diff_driver_map_put(&reg->map, drv->name, drv)) < 0)",
            " \t\tgoto done;",
            " ",
            " done:",
            " \tif (error && drv)",
            " \t\tgit_diff_driver_free(drv);",
            " \telse",
            " \t\t*out = drv;",
            "@@ -238,15 +231,15 @@",
            " \tgit_str name = GIT_STR_INIT;",
            " \tgit_config_entry *ce = NULL;",
            " \tbool found_driver = false;",
            " ",
            " \tif ((reg = git_repository_driver_registry(repo)) == NULL)",
            " \t\treturn -1;",
            " ",
            "-\tif ((drv = git_strmap_get(reg->drivers, driver_name)) != NULL) {",
            "+\tif (git_diff_driver_map_get(&drv, &reg->map, driver_name) == 0) {",
            " \t\t*out = drv;",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif ((error = diff_driver_alloc(&drv, &namelen, driver_name)) < 0)",
            " \t\tgoto done;",
            " ",
            "@@ -327,15 +320,15 @@",
            " \t */",
            " ",
            " \t/* if no driver config found at all, fall back on AUTO driver */",
            " \tif (!found_driver)",
            " \t\tgoto done;",
            " ",
            " \t/* store driver in registry */",
            "-\tif ((error = git_strmap_set(reg->drivers, drv->name, drv)) < 0)",
            "+\tif ((error = git_diff_driver_map_put(&reg->map, drv->name, drv)) < 0)",
            " \t\tgoto done;",
            " ",
            " \t*out = drv;",
            " ",
            " done:",
            " \tgit_config_entry_free(ce);",
            " \tgit_str_dispose(&name);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_driver.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_driver.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_driver.h",
            "@@ -7,22 +7,22 @@",
            " #ifndef INCLUDE_diff_driver_h__",
            " #define INCLUDE_diff_driver_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"attr_file.h\"",
            " #include \"str.h\"",
            "+#include \"hashmap.h\"",
            " ",
            "+typedef struct git_diff_driver git_diff_driver;",
            " typedef struct git_diff_driver_registry git_diff_driver_registry;",
            " ",
            " git_diff_driver_registry *git_diff_driver_registry_new(void);",
            " void git_diff_driver_registry_free(git_diff_driver_registry *);",
            " ",
            "-typedef struct git_diff_driver git_diff_driver;",
            "-",
            " int git_diff_driver_lookup(git_diff_driver **, git_repository *,",
            " \tgit_attr_session *attrsession, const char *);",
            " void git_diff_driver_free(git_diff_driver *);",
            " ",
            " /* diff option flags to force off and on for this driver */",
            " void git_diff_driver_update_options(uint32_t *option_flags, git_diff_driver *);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_generate.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_generate.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_generate.c",
            "@@ -425,15 +425,15 @@",
            " }",
            " ",
            " static void diff_generated_free(git_diff *d)",
            " {",
            " \tgit_diff_generated *diff = (git_diff_generated *)d;",
            " ",
            " \tgit_attr_session__free(&diff->base.attrsession);",
            "-\tgit_vector_free_deep(&diff->base.deltas);",
            "+\tgit_vector_dispose_deep(&diff->base.deltas);",
            " ",
            " \tgit_pathspec__vfree(&diff->pathspec);",
            " \tgit_pool_clear(&diff->base.pool);",
            " ",
            " \tgit__memzero(diff, sizeof(*diff));",
            " \tgit__free(diff);",
            " }",
            "@@ -725,15 +725,15 @@",
            " ",
            " typedef struct {",
            " \tgit_repository *repo;",
            " \tgit_iterator *old_iter;",
            " \tgit_iterator *new_iter;",
            " \tconst git_index_entry *oitem;",
            " \tconst git_index_entry *nitem;",
            "-\tgit_strmap *submodule_cache;",
            "+\tgit_submodule_cache *submodule_cache;",
            " \tbool submodule_cache_initialized;",
            " } diff_in_progress;",
            " ",
            " #define MODE_BITS_MASK 0000777",
            " ",
            " static int maybe_modified_submodule(",
            " \tgit_delta_t *status,",
            "@@ -741,15 +741,15 @@",
            " \tgit_diff_generated *diff,",
            " \tdiff_in_progress *info)",
            " {",
            " \tint error = 0;",
            " \tgit_submodule *sub;",
            " \tunsigned int sm_status = 0;",
            " \tgit_submodule_ignore_t ign = diff->base.opts.ignore_submodules;",
            "-\tgit_strmap *submodule_cache = NULL;",
            "+\tgit_submodule_cache *submodule_cache = NULL;",
            " ",
            " \t*status = GIT_DELTA_UNMODIFIED;",
            " ",
            " \tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES) ||",
            " \t\tign == GIT_SUBMODULE_IGNORE_ALL)",
            " \t\treturn 0;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_parse.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_parse.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_parse.c",
            "@@ -16,17 +16,17 @@",
            " \tgit_diff_parsed *diff = (git_diff_parsed *)d;",
            " \tgit_patch *patch;",
            " \tsize_t i;",
            " ",
            " \tgit_vector_foreach(&diff->patches, i, patch)",
            " \t\tgit_patch_free(patch);",
            " ",
            "-\tgit_vector_free(&diff->patches);",
            "+\tgit_vector_dispose(&diff->patches);",
            " ",
            "-\tgit_vector_free(&diff->base.deltas);",
            "+\tgit_vector_dispose(&diff->base.deltas);",
            " \tgit_pool_clear(&diff->base.pool);",
            " ",
            " \tgit__memzero(diff, sizeof(*diff));",
            " \tgit__free(diff);",
            " }",
            " ",
            " static git_diff_parsed *diff_parsed_alloc(git_oid_t oid_type)"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_print.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_print.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_print.c",
            "@@ -11,14 +11,15 @@",
            " #include \"diff.h\"",
            " #include \"diff_file.h\"",
            " #include \"patch_generate.h\"",
            " #include \"futils.h\"",
            " #include \"zstream.h\"",
            " #include \"blob.h\"",
            " #include \"delta.h\"",
            "+#include \"repository.h\"",
            " #include \"git2/sys/diff.h\"",
            " ",
            " typedef struct {",
            " \tgit_diff_format_t format;",
            " \tgit_diff_line_cb print_cb;",
            " \tvoid *payload;",
            " ",
            "@@ -49,22 +50,18 @@",
            " \tpi->buf = out;",
            " ",
            " \tGIT_ASSERT(pi->oid_type);",
            " ",
            " \tif (!pi->id_strlen) {",
            " \t\tif (!repo)",
            " \t\t\tpi->id_strlen = GIT_ABBREV_DEFAULT;",
            "-\t\telse if (git_repository__configmap_lookup(&pi->id_strlen, repo, GIT_CONFIGMAP_ABBREV) < 0)",
            "+\t\telse if (git_repository__abbrev_length(&pi->id_strlen, repo) < 0)",
            " \t\t\treturn -1;",
            " \t}",
            " ",
            "-\tif (pi->id_strlen > 0 &&",
            "-\t    (size_t)pi->id_strlen > git_oid_hexsize(pi->oid_type))",
            "-\t\tpi->id_strlen = (int)git_oid_hexsize(pi->oid_type);",
            "-",
            " \tmemset(&pi->line, 0, sizeof(pi->line));",
            " \tpi->line.old_lineno = -1;",
            " \tpi->line.new_lineno = -1;",
            " \tpi->line.num_lines = 1;",
            " ",
            " \treturn 0;",
            " }",
            "@@ -663,14 +660,21 @@",
            " \tconst char *new_pfx =",
            " \t\tpi->new_prefix ? pi->new_prefix : DIFF_NEW_PREFIX_DEFAULT;",
            " \tint error;",
            " ",
            " \tif ((error = flush_file_header(delta, pi)) < 0)",
            " \t\treturn error;",
            " ",
            "+\t/*",
            "+\t * If the caller only wants the header, we just needed to make sure to",
            "+\t * call flush_file_header",
            "+\t */",
            "+\tif (pi->format == GIT_DIFF_FORMAT_PATCH_HEADER)",
            "+\t\treturn 0;",
            "+",
            " \tgit_str_clear(pi->buf);",
            " ",
            " \tif ((error = diff_print_patch_file_binary(",
            " \t\tpi, (git_diff_delta *)delta, old_pfx, new_pfx, binary)) < 0)",
            " \t\treturn error;",
            " ",
            " \tpi->line.origin = GIT_DIFF_LINE_BINARY;",
            "@@ -690,14 +694,21 @@",
            " ",
            " \tif (S_ISDIR(d->new_file.mode))",
            " \t\treturn 0;",
            " ",
            " \tif ((error = flush_file_header(d, pi)) < 0)",
            " \t\treturn error;",
            " ",
            "+\t/*",
            "+\t * If the caller only wants the header, we just needed to make sure to",
            "+\t * call flush_file_header",
            "+\t */",
            "+\tif (pi->format == GIT_DIFF_FORMAT_PATCH_HEADER)",
            "+\t\treturn 0;",
            "+",
            " \tpi->line.origin      = GIT_DIFF_LINE_HUNK_HDR;",
            " \tpi->line.content     = h->header;",
            " \tpi->line.content_len = h->header_len;",
            " ",
            " \treturn pi->print_cb(d, h, &pi->line, pi->payload);",
            " }",
            " ",
            "@@ -744,14 +755,16 @@",
            " \tcase GIT_DIFF_FORMAT_PATCH_ID:",
            " \t\tprint_file = diff_print_patch_file;",
            " \t\tprint_binary = diff_print_patch_binary;",
            " \t\tprint_line = diff_print_patch_line;",
            " \t\tbreak;",
            " \tcase GIT_DIFF_FORMAT_PATCH_HEADER:",
            " \t\tprint_file = diff_print_patch_file;",
            "+\t\tprint_binary = diff_print_patch_binary;",
            "+\t\tprint_hunk = diff_print_patch_hunk;",
            " \t\tbreak;",
            " \tcase GIT_DIFF_FORMAT_RAW:",
            " \t\tprint_file = diff_print_one_raw;",
            " \t\tbreak;",
            " \tcase GIT_DIFF_FORMAT_NAME_ONLY:",
            " \t\tprint_file = diff_print_one_name_only;",
            " \t\tbreak;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_stats.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_stats.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_stats.c",
            "@@ -24,15 +24,14 @@",
            " struct git_diff_stats {",
            " \tgit_diff *diff;",
            " \tdiff_file_stats *filestats;",
            " ",
            " \tsize_t files_changed;",
            " \tsize_t insertions;",
            " \tsize_t deletions;",
            "-\tsize_t renames;",
            " ",
            " \tsize_t max_name;",
            " \tsize_t max_filestat;",
            " \tint max_digits;",
            " };",
            " ",
            " static int digits_for_value(size_t val)",
            "@@ -64,38 +63,37 @@",
            " \told_size = delta->old_file.size;",
            " \tnew_size = delta->new_file.size;",
            " ",
            " \tif (old_path && new_path && strcmp(old_path, new_path) != 0) {",
            " \t\tsize_t common_dirlen;",
            " \t\tint error;",
            " ",
            "-\t\tpadding = stats->max_name - strlen(old_path) - strlen(new_path);",
            "-",
            " \t\tif ((common_dirlen = git_fs_path_common_dirlen(old_path, new_path)) &&",
            " \t\t    common_dirlen <= INT_MAX) {",
            " \t\t\terror = git_str_printf(out, \" %.*s{%s\"DIFF_RENAME_FILE_SEPARATOR\"%s}\",",
            " \t\t\t\t\t       (int) common_dirlen, old_path,",
            " \t\t\t\t\t       old_path + common_dirlen,",
            " \t\t\t\t\t       new_path + common_dirlen);",
            "+\t\t\tpadding = stats->max_name + common_dirlen - strlen(old_path)",
            "+\t\t\t          - strlen(new_path) - 2 - strlen(DIFF_RENAME_FILE_SEPARATOR);",
            " \t\t} else {",
            " \t\t\terror = git_str_printf(out, \" %s\" DIFF_RENAME_FILE_SEPARATOR \"%s\",",
            " \t\t\t\t\t       old_path, new_path);",
            "+\t\t\tpadding = stats->max_name - strlen(old_path)",
            "+\t\t\t          - strlen(new_path) - strlen(DIFF_RENAME_FILE_SEPARATOR);",
            " \t\t}",
            " ",
            " \t\tif (error < 0)",
            " \t\t\tgoto on_error;",
            " \t} else {",
            " \t\tadddel_path = new_path ? new_path : old_path;",
            " \t\tif (git_str_printf(out, \" %s\", adddel_path) < 0)",
            " \t\t\tgoto on_error;",
            " ",
            " \t\tpadding = stats->max_name - strlen(adddel_path);",
            "-",
            "-\t\tif (stats->renames > 0)",
            "-\t\t\tpadding += strlen(DIFF_RENAME_FILE_SEPARATOR);",
            " \t}",
            " ",
            " \tif (git_str_putcn(out, ' ', padding) < 0 ||",
            " \t\tgit_str_puts(out, \" | \") < 0)",
            " \t\tgoto on_error;",
            " ",
            " \tif (delta->flags & GIT_DIFF_FLAG_BINARY) {",
            "@@ -206,22 +204,31 @@",
            " \t\tgit_patch *patch = NULL;",
            " \t\tsize_t add = 0, remove = 0, namelen;",
            " \t\tconst git_diff_delta *delta;",
            " ",
            " \t\tif ((error = git_patch_from_diff(&patch, diff, i)) < 0)",
            " \t\t\tbreak;",
            " ",
            "-\t\t/* keep a count of renames because it will affect formatting */",
            "+\t\t/* Length calculation for renames mirrors the actual presentation format",
            "+\t\t * generated in diff_file_stats_full_to_buf; namelen is the full length of",
            "+\t\t * what will be printed, taking into account renames and common prefixes.",
            "+\t\t */",
            " \t\tdelta = patch->delta;",
            "-",
            "-\t\t/* TODO ugh */",
            " \t\tnamelen = strlen(delta->new_file.path);",
            "-\t\tif (delta->old_file.path && strcmp(delta->old_file.path, delta->new_file.path) != 0) {",
            "-\t\t\tnamelen += strlen(delta->old_file.path);",
            "-\t\t\tstats->renames++;",
            "+\t\tif (delta->old_file.path &&",
            "+\t\t    strcmp(delta->old_file.path, delta->new_file.path) != 0) {",
            "+\t\t\tsize_t common_dirlen;",
            "+\t\t\tif ((common_dirlen = git_fs_path_common_dirlen(delta->old_file.path, delta->new_file.path)) &&",
            "+\t\t\t    common_dirlen <= INT_MAX) {",
            "+\t\t\t\tnamelen += strlen(delta->old_file.path) + 2 +",
            "+\t\t\t\t           strlen(DIFF_RENAME_FILE_SEPARATOR) - common_dirlen;",
            "+\t\t\t} else {",
            "+\t\t\t\tnamelen += strlen(delta->old_file.path) +",
            "+\t\t\t\t           strlen(DIFF_RENAME_FILE_SEPARATOR);",
            "+\t\t\t}",
            " \t\t}",
            " ",
            " \t\t/* and, of course, count the line stats */",
            " \t\terror = git_patch_line_stats(NULL, &add, &remove, patch);",
            " ",
            " \t\tgit_patch_free(patch);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/diff_tform.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/diff_tform.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/diff_tform.c",
            "@@ -186,15 +186,15 @@",
            " \t\t/* prefix strings also come from old pool, so recreate those.*/",
            " \t\tonto->opts.old_prefix =",
            " \t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);",
            " \t\tonto->opts.new_prefix =",
            " \t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);",
            " \t}",
            " ",
            "-\tgit_vector_free_deep(&onto_new);",
            "+\tgit_vector_dispose_deep(&onto_new);",
            " \tgit_pool_clear(&onto_pool);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " int git_diff_merge(git_diff *onto, const git_diff *from)",
            " {",
            "@@ -420,21 +420,21 @@",
            " \tgit_vector_foreach(&diff->deltas, i, delta) {",
            " \t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)",
            " \t\t\tgit__free(delta);",
            " \t}",
            " ",
            " \t/* swap new delta list into place */",
            " \tgit_vector_swap(&diff->deltas, &onto);",
            "-\tgit_vector_free(&onto);",
            "+\tgit_vector_dispose(&onto);",
            " \tgit_vector_sort(&diff->deltas);",
            " ",
            " \treturn 0;",
            " ",
            " on_error:",
            "-\tgit_vector_free_deep(&onto);",
            "+\tgit_vector_dispose_deep(&onto);",
            " ",
            " \treturn -1;",
            " }",
            " ",
            " GIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)",
            " {",
            " \tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/email.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/email.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/email.c",
            "@@ -12,14 +12,15 @@",
            " #include \"diff_generate.h\"",
            " #include \"diff_stats.h\"",
            " #include \"patch.h\"",
            " #include \"date.h\"",
            " ",
            " #include \"git2/email.h\"",
            " #include \"git2/patch.h\"",
            "+#include \"git2/sys/email.h\"",
            " #include \"git2/version.h\"",
            " ",
            " /*",
            "  * Git uses a \"magic\" timestamp to indicate that an email message",
            "  * is from `git format-patch` (or our equivalent).",
            "  */",
            " #define EMAIL_TIMESTAMP \"Mon Sep 17 00:00:00 2001\""
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/filter.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/filter.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/filter.c",
            "@@ -235,15 +235,15 @@",
            " \t\t}",
            " ",
            " \t\tgit__free(fdef->filter_name);",
            " \t\tgit__free(fdef->attrdata);",
            " \t\tgit__free(fdef);",
            " \t}",
            " ",
            "-\tgit_vector_free(&filter_registry.filters);",
            "+\tgit_vector_dispose(&filter_registry.filters);",
            " ",
            " \tgit_rwlock_wrunlock(&filter_registry.lock);",
            " \tgit_rwlock_free(&filter_registry.lock);",
            " }",
            " ",
            " /* Note: callers must lock the registry before calling this function */",
            " static int filter_registry_find(size_t *pos, const char *name)",
            "@@ -1102,15 +1102,15 @@",
            " static void filter_streams_free(git_vector *streams)",
            " {",
            " \tgit_writestream *stream;",
            " \tsize_t i;",
            " ",
            " \tgit_vector_foreach(streams, i, stream)",
            " \t\tstream->free(stream);",
            "-\tgit_vector_free(streams);",
            "+\tgit_vector_dispose(streams);",
            " }",
            " ",
            " int git_filter_list_stream_file(",
            " \tgit_filter_list *filters,",
            " \tgit_repository *repo,",
            " \tconst char *path,",
            " \tgit_writestream *target)"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/grafts.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/grafts.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/grafts.c",
            "@@ -7,18 +7,21 @@",
            " ",
            " #include \"grafts.h\"",
            " ",
            " #include \"futils.h\"",
            " #include \"oid.h\"",
            " #include \"oidarray.h\"",
            " #include \"parse.h\"",
            "+#include \"hashmap_oid.h\"",
            "+",
            "+GIT_HASHMAP_OID_SETUP(git_grafts_oidmap, git_commit_graft *);",
            " ",
            " struct git_grafts {",
            " \t/* Map of `git_commit_graft`s */",
            "-\tgit_oidmap *commits;",
            "+\tgit_grafts_oidmap commits;",
            " ",
            " \t/* Type of object IDs */",
            " \tgit_oid_t oid_type;",
            " ",
            " \t/* File backing the graft. NULL if it's an in-memory graft */",
            " \tchar *path;",
            " \tunsigned char path_checksum[GIT_HASH_SHA256_SIZE];",
            "@@ -29,19 +32,14 @@",
            " \tgit_grafts *grafts;",
            " ",
            " \tGIT_ASSERT_ARG(out && oid_type);",
            " ",
            " \tgrafts = git__calloc(1, sizeof(*grafts));",
            " \tGIT_ERROR_CHECK_ALLOC(grafts);",
            " ",
            "-\tif ((git_oidmap_new(&grafts->commits)) < 0) {",
            "-\t\tgit__free(grafts);",
            "-\t\treturn -1;",
            "-\t}",
            "-",
            " \tgrafts->oid_type = oid_type;",
            " ",
            " \t*out = grafts;",
            " \treturn 0;",
            " }",
            " ",
            " int git_grafts_open(",
            "@@ -84,31 +82,32 @@",
            " ",
            " void git_grafts_free(git_grafts *grafts)",
            " {",
            " \tif (!grafts)",
            " \t\treturn;",
            " \tgit__free(grafts->path);",
            " \tgit_grafts_clear(grafts);",
            "-\tgit_oidmap_free(grafts->commits);",
            "+\tgit_grafts_oidmap_dispose(&grafts->commits);",
            " \tgit__free(grafts);",
            " }",
            " ",
            " void git_grafts_clear(git_grafts *grafts)",
            " {",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tgit_commit_graft *graft;",
            " ",
            " \tif (!grafts)",
            " \t\treturn;",
            " ",
            "-\tgit_oidmap_foreach_value(grafts->commits, graft, {",
            "+\twhile (git_grafts_oidmap_iterate(&iter, NULL, &graft, &grafts->commits) == 0) {",
            " \t\tgit__free(graft->parents.ptr);",
            " \t\tgit__free(graft);",
            "-\t});",
            "+\t}",
            " ",
            "-\tgit_oidmap_clear(grafts->commits);",
            "+\tgit_grafts_oidmap_clear(&grafts->commits);",
            " }",
            " ",
            " int git_grafts_refresh(git_grafts *grafts)",
            " {",
            " \tgit_str contents = GIT_STR_INIT;",
            " \tint error, updated = 0;",
            " ",
            "@@ -201,15 +200,15 @@",
            " \t\tgit_oid_cpy(id, parent_oid);",
            " \t}",
            " \tgit_oid_cpy(&graft->oid, oid);",
            " ",
            " \tif ((error = git_grafts_remove(grafts, &graft->oid)) < 0 && error != GIT_ENOTFOUND)",
            " \t\tgoto cleanup;",
            " ",
            "-\tif ((error = git_oidmap_set(grafts->commits, &graft->oid, graft)) < 0)",
            "+\tif ((error = git_grafts_oidmap_put(&grafts->commits, &graft->oid, graft)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \treturn 0;",
            " ",
            " cleanup:",
            " \tgit_array_clear(graft->parents);",
            " \tgit__free(graft);",
            "@@ -219,54 +218,53 @@",
            " int git_grafts_remove(git_grafts *grafts, const git_oid *oid)",
            " {",
            " \tgit_commit_graft *graft;",
            " \tint error;",
            " ",
            " \tGIT_ASSERT_ARG(grafts && oid);",
            " ",
            "-\tif ((graft = git_oidmap_get(grafts->commits, oid)) == NULL)",
            "+\tif (git_grafts_oidmap_get(&graft, &grafts->commits, oid) != 0)",
            " \t\treturn GIT_ENOTFOUND;",
            " ",
            "-\tif ((error = git_oidmap_delete(grafts->commits, oid)) < 0)",
            "+\tif ((error = git_grafts_oidmap_remove(&grafts->commits, oid)) < 0)",
            " \t\treturn error;",
            " ",
            " \tgit__free(graft->parents.ptr);",
            " \tgit__free(graft);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " int git_grafts_get(git_commit_graft **out, git_grafts *grafts, const git_oid *oid)",
            " {",
            " \tGIT_ASSERT_ARG(out && grafts && oid);",
            "-\tif ((*out = git_oidmap_get(grafts->commits, oid)) == NULL)",
            "-\t\treturn GIT_ENOTFOUND;",
            "-\treturn 0;",
            "+\treturn git_grafts_oidmap_get(out, &grafts->commits, oid);",
            " }",
            " ",
            " int git_grafts_oids(git_oid **out, size_t *out_len, git_grafts *grafts)",
            " {",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tgit_array_oid_t array = GIT_ARRAY_INIT;",
            " \tconst git_oid *oid;",
            "-\tsize_t existing, i = 0;",
            "+\tsize_t existing;",
            " ",
            " \tGIT_ASSERT_ARG(out && grafts);",
            " ",
            "-\tif ((existing = git_oidmap_size(grafts->commits)) > 0)",
            "+\tif ((existing = git_grafts_oidmap_size(&grafts->commits)) > 0)",
            " \t\tgit_array_init_to_size(array, existing);",
            " ",
            "-\twhile (git_oidmap_iterate(NULL, grafts->commits, &i, &oid) == 0) {",
            "+\twhile (git_grafts_oidmap_iterate(&iter, &oid, NULL, &grafts->commits) == 0) {",
            " \t\tgit_oid *cpy = git_array_alloc(array);",
            " \t\tGIT_ERROR_CHECK_ALLOC(cpy);",
            " \t\tgit_oid_cpy(cpy, oid);",
            " \t}",
            " ",
            " \t*out = array.ptr;",
            " \t*out_len = array.size;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " size_t git_grafts_size(git_grafts *grafts)",
            " {",
            "-\treturn git_oidmap_size(grafts->commits);",
            "+\treturn git_grafts_oidmap_size(&grafts->commits);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/grafts.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/grafts.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/grafts.h",
            "@@ -5,15 +5,14 @@",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_graft_h__",
            " #define INCLUDE_graft_h__",
            " ",
            " #include \"common.h\"",
            " #include \"oidarray.h\"",
            "-#include \"oidmap.h\"",
            " ",
            " /** graft commit */",
            " typedef struct {",
            " \tgit_oid oid;",
            " \tgit_array_oid_t parents;",
            " } git_commit_graft;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/graph.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/graph.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/graph.c",
            "@@ -239,11 +239,11 @@",
            " \t} else {",
            " \t\t/* No merge-base found, it's not a descendant */",
            " \t\terror = 0;",
            " \t}",
            " ",
            " done:",
            " \tgit_commit_list_free(&result);",
            "-\tgit_vector_free(&list);",
            "+\tgit_vector_dispose(&list);",
            " \tgit_revwalk_free(walk);",
            " \treturn error;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/ignore.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/ignore.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/ignore.c",
            "@@ -292,14 +292,16 @@",
            " int git_ignore__for_path(",
            " \tgit_repository *repo,",
            " \tconst char *path,",
            " \tgit_ignores *ignores)",
            " {",
            " \tint error = 0;",
            " \tconst char *workdir = git_repository_workdir(repo);",
            "+\tgit_attr_cache *attrcache;",
            "+\tconst char *excludes_file = NULL;",
            " \tgit_str infopath = GIT_STR_INIT;",
            " ",
            " \tGIT_ASSERT_ARG(repo);",
            " \tGIT_ASSERT_ARG(ignores);",
            " \tGIT_ASSERT_ARG(path);",
            " ",
            " \tmemset(ignores, 0, sizeof(*ignores));",
            "@@ -354,18 +356,20 @@",
            " \t\t(error = push_ignore_file(ignores, &ignores->ign_global, infopath.ptr, GIT_IGNORE_FILE_INREPO)) < 0) {",
            " \t\tif (error != GIT_ENOTFOUND)",
            " \t\t\tgoto cleanup;",
            " \t\terror = 0;",
            " \t}",
            " ",
            " \t/* load core.excludesfile */",
            "-\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)",
            "+\tattrcache = git_repository_attr_cache(repo);",
            "+\texcludes_file = git_attr_cache_excludesfile(attrcache);",
            "+",
            "+\tif (excludes_file != NULL)",
            " \t\terror = push_ignore_file(",
            "-\t\t\tignores, &ignores->ign_global, NULL,",
            "-\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);",
            "+\t\t\tignores, &ignores->ign_global, NULL, excludes_file);",
            " ",
            " cleanup:",
            " \tgit_str_dispose(&infopath);",
            " \tif (error < 0)",
            " \t\tgit_ignore__free(ignores);",
            " ",
            " \treturn error;",
            "@@ -424,21 +428,21 @@",
            " ",
            " \tgit_attr_file__free(ignores->ign_internal);",
            " ",
            " \tgit_vector_foreach(&ignores->ign_path, i, file) {",
            " \t\tgit_attr_file__free(file);",
            " \t\tignores->ign_path.contents[i] = NULL;",
            " \t}",
            "-\tgit_vector_free(&ignores->ign_path);",
            "+\tgit_vector_dispose(&ignores->ign_path);",
            " ",
            " \tgit_vector_foreach(&ignores->ign_global, i, file) {",
            " \t\tgit_attr_file__free(file);",
            " \t\tignores->ign_global.contents[i] = NULL;",
            " \t}",
            "-\tgit_vector_free(&ignores->ign_global);",
            "+\tgit_vector_dispose(&ignores->ign_global);",
            " ",
            " \tgit_str_dispose(&ignores->dir);",
            " }",
            " ",
            " static bool ignore_lookup_in_rules(",
            " \tint *ignored, git_attr_file *file, git_attr_path *path)",
            " {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/index.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/index.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/index.c",
            "@@ -13,18 +13,18 @@",
            " #include \"tree.h\"",
            " #include \"tree-cache.h\"",
            " #include \"hash.h\"",
            " #include \"iterator.h\"",
            " #include \"pathspec.h\"",
            " #include \"ignore.h\"",
            " #include \"blob.h\"",
            "-#include \"idxmap.h\"",
            " #include \"diff.h\"",
            " #include \"varint.h\"",
            " #include \"path.h\"",
            "+#include \"index_map.h\"",
            " ",
            " #include \"git2/odb.h\"",
            " #include \"git2/oid.h\"",
            " #include \"git2/blob.h\"",
            " #include \"git2/config.h\"",
            " #include \"git2/sys/index.h\"",
            " ",
            "@@ -129,38 +129,14 @@",
            " static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
            " static bool is_index_extended(git_index *index);",
            " static int write_index(unsigned char checksum[GIT_HASH_MAX_SIZE], size_t *checksum_size, git_index *index, git_filebuf *file);",
            " ",
            " static void index_entry_free(git_index_entry *entry);",
            " static void index_entry_reuc_free(git_index_reuc_entry *reuc);",
            " ",
            "-GIT_INLINE(int) index_map_set(git_idxmap *map, git_index_entry *e, bool ignore_case)",
            "-{",
            "-\tif (ignore_case)",
            "-\t\treturn git_idxmap_icase_set((git_idxmap_icase *) map, e, e);",
            "-\telse",
            "-\t\treturn git_idxmap_set(map, e, e);",
            "-}",
            "-",
            "-GIT_INLINE(int) index_map_delete(git_idxmap *map, git_index_entry *e, bool ignore_case)",
            "-{",
            "-\tif (ignore_case)",
            "-\t\treturn git_idxmap_icase_delete((git_idxmap_icase *) map, e);",
            "-\telse",
            "-\t\treturn git_idxmap_delete(map, e);",
            "-}",
            "-",
            "-GIT_INLINE(int) index_map_resize(git_idxmap *map, size_t count, bool ignore_case)",
            "-{",
            "-\tif (ignore_case)",
            "-\t\treturn git_idxmap_icase_resize((git_idxmap_icase *) map, count);",
            "-\telse",
            "-\t\treturn git_idxmap_resize(map, count);",
            "-}",
            "-",
            " int git_index_entry_srch(const void *key, const void *array_member)",
            " {",
            " \tconst struct entry_srch_key *srch_key = key;",
            " \tconst struct entry_internal *entry = array_member;",
            " \tint cmp;",
            " \tsize_t len1, len2, len;",
            " ",
            "@@ -384,14 +360,15 @@",
            " \treturn index_find_in_entries(",
            " \t\tout, &index->entries, index->entries_search, path, path_len, stage);",
            " }",
            " ",
            " void git_index__set_ignore_case(git_index *index, bool ignore_case)",
            " {",
            " \tindex->ignore_case = ignore_case;",
            "+\tindex->entries_map.ignore_case = ignore_case;",
            " ",
            " \tif (ignore_case) {",
            " \t\tindex->entries_cmp_path    = git__strcasecmp_cb;",
            " \t\tindex->entries_search      = git_index_entry_isrch;",
            " \t\tindex->entries_search_path = index_entry_isrch_path;",
            " \t\tindex->reuc_search         = reuc_isrch;",
            " \t} else {",
            "@@ -418,14 +395,15 @@",
            " \tint error = -1;",
            " ",
            " \tGIT_ASSERT_ARG(index_out);",
            " ",
            " \tindex = git__calloc(1, sizeof(git_index));",
            " \tGIT_ERROR_CHECK_ALLOC(index);",
            " ",
            "+\tGIT_ASSERT_ARG(git_oid_type_is_valid(oid_type));",
            " \tindex->oid_type = oid_type;",
            " ",
            " \tif (git_pool_init(&index->tree_pool, 1) < 0)",
            " \t\tgoto fail;",
            " ",
            " \tif (index_path != NULL) {",
            " \t\tindex->index_file_path = git__strdup(index_path);",
            "@@ -434,15 +412,14 @@",
            " ",
            " \t\t/* Check if index file is stored on disk already */",
            " \t\tif (git_fs_path_exists(index->index_file_path) == true)",
            " \t\t\tindex->on_disk = 1;",
            " \t}",
            " ",
            " \tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||",
            "-\t    git_idxmap_new(&index->entries_map) < 0 ||",
            " \t    git_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||",
            " \t    git_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||",
            " \t    git_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)",
            " \t\tgoto fail;",
            " ",
            " \tindex->entries_cmp_path = git__strcmp_cb;",
            " \tindex->entries_search = git_index_entry_srch;",
            "@@ -461,34 +438,39 @@",
            " fail:",
            " \tgit_pool_clear(&index->tree_pool);",
            " \tgit_index_free(index);",
            " \treturn error;",
            " }",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-int git_index_open(git_index **index_out, const char *index_path, git_oid_t oid_type)",
            "+int git_index_open(",
            "+\tgit_index **index_out,",
            "+\tconst char *index_path,",
            "+\tconst git_index_options *opts)",
            " {",
            "-\treturn git_index__open(index_out, index_path, oid_type);",
            "+\treturn git_index__open(index_out, index_path,",
            "+\t\topts && opts->oid_type ? opts->oid_type : GIT_OID_DEFAULT);",
            " }",
            " #else",
            " int git_index_open(git_index **index_out, const char *index_path)",
            " {",
            " \treturn git_index__open(index_out, index_path, GIT_OID_SHA1);",
            " }",
            " #endif",
            " ",
            " int git_index__new(git_index **out, git_oid_t oid_type)",
            " {",
            " \treturn git_index__open(out, NULL, oid_type);",
            " }",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-int git_index_new(git_index **out, git_oid_t oid_type)",
            "+int git_index_new(git_index **out, const git_index_options *opts)",
            " {",
            "-\treturn git_index__new(out, oid_type);",
            "+\treturn git_index__new(out,",
            "+\t\topts && opts->oid_type ? opts->oid_type : GIT_OID_DEFAULT);",
            " }",
            " #else",
            " int git_index_new(git_index **out)",
            " {",
            " \treturn git_index__new(out, GIT_OID_SHA1);",
            " }",
            " #endif",
            "@@ -498,19 +480,19 @@",
            " \t/* index iterators increment the refcount of the index, so if we",
            " \t * get here then there should be no outstanding iterators.",
            " \t */",
            " \tif (git_atomic32_get(&index->readers))",
            " \t\treturn;",
            " ",
            " \tgit_index_clear(index);",
            "-\tgit_idxmap_free(index->entries_map);",
            "-\tgit_vector_free(&index->entries);",
            "-\tgit_vector_free(&index->names);",
            "-\tgit_vector_free(&index->reuc);",
            "-\tgit_vector_free(&index->deleted);",
            "+\tgit_index_entrymap_dispose(&index->entries_map);",
            "+\tgit_vector_dispose(&index->entries);",
            "+\tgit_vector_dispose(&index->names);",
            "+\tgit_vector_dispose(&index->reuc);",
            "+\tgit_vector_dispose(&index->deleted);",
            " ",
            " \tgit__free(index->index_file_path);",
            " ",
            " \tgit__memzero(index, sizeof(*index));",
            " \tgit__free(index);",
            " }",
            " ",
            "@@ -543,15 +525,15 @@",
            " static int index_remove_entry(git_index *index, size_t pos)",
            " {",
            " \tint error = 0;",
            " \tgit_index_entry *entry = git_vector_get(&index->entries, pos);",
            " ",
            " \tif (entry != NULL) {",
            " \t\tgit_tree_cache_invalidate_path(index->tree, entry->path);",
            "-\t\tindex_map_delete(index->entries_map, entry, index->ignore_case);",
            "+\t\tgit_index_entrymap_remove(&index->entries_map, entry);",
            " \t}",
            " ",
            " \terror = git_vector_remove(&index->entries, pos);",
            " ",
            " \tif (!error) {",
            " \t\tif (git_atomic32_get(&index->readers) > 0) {",
            " \t\t\terror = git_vector_insert(&index->deleted, entry);",
            "@@ -571,15 +553,16 @@",
            " ",
            " \tGIT_ASSERT_ARG(index);",
            " ",
            " \tindex->dirty = 1;",
            " \tindex->tree = NULL;",
            " \tgit_pool_clear(&index->tree_pool);",
            " ",
            "-\tgit_idxmap_clear(index->entries_map);",
            "+\tgit_index_entrymap_clear(&index->entries_map);",
            "+",
            " \twhile (!error && index->entries.length > 0)",
            " \t\terror = index_remove_entry(index, index->entries.length - 1);",
            " ",
            " \tif (error)",
            " \t\tgoto done;",
            " ",
            " \tindex_free_deleted(index);",
            "@@ -782,16 +765,18 @@",
            " ",
            " \tif (paths.length == 0)",
            " \t\tgoto done;",
            " ",
            " \tdiff_opts.pathspec.count = paths.length;",
            " \tdiff_opts.pathspec.strings = (char **)paths.contents;",
            " ",
            "-\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)",
            "+\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0) {",
            "+\t\tgit_vector_dispose(&paths);",
            " \t\treturn error;",
            "+\t}",
            " ",
            " \tgit_vector_foreach(&diff->deltas, i, delta) {",
            " \t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);",
            " ",
            " \t\t/* Ensure that we have a stage 0 for this file (ie, it's not a",
            " \t\t * conflict), otherwise smudging it is quite pointless.",
            " \t\t */",
            "@@ -799,15 +784,15 @@",
            " \t\t\tentry->file_size = 0;",
            " \t\t\tindex->dirty = 1;",
            " \t\t}",
            " \t}",
            " ",
            " done:",
            " \tgit_diff_free(diff);",
            "-\tgit_vector_free(&paths);",
            "+\tgit_vector_dispose(&paths);",
            " \treturn 0;",
            " }",
            " ",
            " unsigned git_index_version(git_index *index)",
            " {",
            " \tGIT_ASSERT_ARG(index);",
            " ",
            "@@ -900,22 +885,17 @@",
            " \tgit_index_entry *value;",
            " ",
            " \tGIT_ASSERT_ARG_WITH_RETVAL(index, NULL);",
            " ",
            " \tkey.path = path;",
            " \tGIT_INDEX_ENTRY_STAGE_SET(&key, stage);",
            " ",
            "-\tif (index->ignore_case)",
            "-\t\tvalue = git_idxmap_icase_get((git_idxmap_icase *) index->entries_map, &key);",
            "-\telse",
            "-\t\tvalue = git_idxmap_get(index->entries_map, &key);",
            "-",
            "-\tif (!value) {",
            "-\t    git_error_set(GIT_ERROR_INDEX, \"index does not contain '%s'\", path);",
            "-\t    return NULL;",
            "+\tif (git_index_entrymap_get(&value, &index->entries_map, &key) != 0) {",
            "+\t\tgit_error_set(GIT_ERROR_INDEX, \"index does not contain '%s'\", path);",
            "+\t\treturn NULL;",
            " \t}",
            " ",
            " \treturn value;",
            " }",
            " ",
            " void git_index_entry__init_from_stat(",
            " \tgit_index_entry *entry, struct stat *st, bool trust_mode)",
            "@@ -1449,15 +1429,15 @@",
            " \t} else {",
            " \t\t/*",
            " \t\t * If replace is not requested or no existing entry exists, insert",
            " \t\t * at the sorted position.  (Since we re-sort after each insert to",
            " \t\t * check for dups, this is actually cheaper in the long run.)",
            " \t\t */",
            " \t\tif ((error = git_vector_insert_sorted(&index->entries, entry, index_no_dups)) < 0 ||",
            "-\t\t    (error = index_map_set(index->entries_map, entry, index->ignore_case)) < 0)",
            "+\t\t    (error = git_index_entrymap_put(&index->entries_map, entry)) < 0)",
            " \t\t\tgoto out;",
            " \t}",
            " ",
            " \tindex->dirty = 1;",
            " ",
            " out:",
            " \tif (error < 0) {",
            "@@ -1678,32 +1658,29 @@",
            " ",
            " \tGIT_ASSERT_ARG(index);",
            " ",
            " \tif (!source_entries->length)",
            " \t\treturn 0;",
            " ",
            " \tif (git_vector_size_hint(&index->entries, source_entries->length) < 0 ||",
            "-\t    index_map_resize(index->entries_map, (size_t)(source_entries->length * 1.3),",
            "-\t\t\t     index->ignore_case) < 0)",
            "+\t    git_index_entrymap_resize(&index->entries_map, (size_t)(source_entries->length * 1.3)) < 0)",
            " \t\treturn -1;",
            " ",
            " \tgit_vector_foreach(source_entries, i, source_entry) {",
            " \t\tgit_index_entry *entry = NULL;",
            " ",
            " \t\tif ((error = index_entry_dup(&entry, index, source_entry)) < 0)",
            " \t\t\tbreak;",
            " ",
            " \t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);",
            " \t\tentry->flags_extended |= GIT_INDEX_ENTRY_UPTODATE;",
            " \t\tentry->mode = git_index__create_mode(entry->mode);",
            " ",
            "-\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0)",
            "-\t\t\tbreak;",
            "-",
            "-\t\tif ((error = index_map_set(index->entries_map, entry, index->ignore_case)) < 0)",
            "+\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0 ||",
            "+\t\t    (error = git_index_entrymap_put(&index->entries_map, entry)) < 0)",
            " \t\t\tbreak;",
            " ",
            " \t\tindex->dirty = 1;",
            " \t}",
            " ",
            " \tif (!error)",
            " \t\tgit_vector_sort(&index->entries);",
            "@@ -1738,15 +1715,15 @@",
            " \tint error;",
            " \tsize_t position;",
            " \tgit_index_entry remove_key = {{ 0 }};",
            " ",
            " \tremove_key.path = path;",
            " \tGIT_INDEX_ENTRY_STAGE_SET(&remove_key, stage);",
            " ",
            "-\tindex_map_delete(index->entries_map, &remove_key, index->ignore_case);",
            "+\tgit_index_entrymap_remove(&index->entries_map, &remove_key);",
            " ",
            " \tif (index_find(&position, index, path, 0, stage) < 0) {",
            " \t\tgit_error_set(",
            " \t\t\tGIT_ERROR_INDEX, \"index does not contain %s at stage %d\", path, stage);",
            " \t\terror = GIT_ENOTFOUND;",
            " \t} else {",
            " \t\terror = index_remove_entry(index, position);",
            "@@ -2791,15 +2768,15 @@",
            " \tif (index->version >= INDEX_VERSION_NUMBER_COMP)",
            " \t\tlast = empty;",
            " ",
            " \tseek_forward(INDEX_HEADER_SIZE);",
            " ",
            " \tGIT_ASSERT(!index->entries.length);",
            " ",
            "-\tif ((error = index_map_resize(index->entries_map, header.entry_count, index->ignore_case)) < 0)",
            "+\tif ((error = git_index_entrymap_resize(&index->entries_map, header.entry_count)) < 0)",
            " \t\treturn error;",
            " ",
            " \t/* Parse all the entries */",
            " \tfor (i = 0; i < header.entry_count && buffer_size > checksum_size; ++i) {",
            " \t\tgit_index_entry *entry = NULL;",
            " \t\tsize_t entry_size;",
            " ",
            "@@ -2809,15 +2786,15 @@",
            " \t\t}",
            " ",
            " \t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {",
            " \t\t\tindex_entry_free(entry);",
            " \t\t\tgoto done;",
            " \t\t}",
            " ",
            "-\t\tif ((error = index_map_set(index->entries_map, entry, index->ignore_case)) < 0) {",
            "+\t\tif ((error = git_index_entrymap_put(&index->entries_map, entry)) < 0) {",
            " \t\t\tindex_entry_free(entry);",
            " \t\t\tgoto done;",
            " \t\t}",
            " \t\terror = 0;",
            " ",
            " \t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)",
            " \t\t\tlast = entry->path;",
            "@@ -3085,15 +3062,15 @@",
            " \t\tif ((error = write_disk_entry(index, file, entry, last)) < 0)",
            " \t\t\tbreak;",
            " \t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)",
            " \t\t\tlast = entry->path;",
            " \t}",
            " ",
            " done:",
            "-\tgit_vector_free(&case_sorted);",
            "+\tgit_vector_dispose(&case_sorted);",
            " \treturn error;",
            " }",
            " ",
            " static int write_extension(git_filebuf *file, struct index_extension *header, git_str *data)",
            " {",
            " \tstruct index_extension ondisk;",
            " ",
            "@@ -3361,22 +3338,19 @@",
            " \treturn 0;",
            " }",
            " ",
            " int git_index_read_tree(git_index *index, const git_tree *tree)",
            " {",
            " \tint error = 0;",
            " \tgit_vector entries = GIT_VECTOR_INIT;",
            "-\tgit_idxmap *entries_map;",
            "+\tgit_index_entrymap entries_map = GIT_INDEX_ENTRYMAP_INIT;",
            " \tread_tree_data data;",
            " \tsize_t i;",
            " \tgit_index_entry *e;",
            " ",
            "-\tif (git_idxmap_new(&entries_map) < 0)",
            "-\t\treturn -1;",
            "-",
            " \tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */",
            " ",
            " \tdata.index = index;",
            " \tdata.old_entries = &index->entries;",
            " \tdata.new_entries = &entries;",
            " \tdata.entry_cmp   = index->entries_search;",
            " ",
            "@@ -3384,40 +3358,40 @@",
            " \tgit_pool_clear(&index->tree_pool);",
            " ",
            " \tgit_vector_sort(&index->entries);",
            " ",
            " \tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            "-\tif ((error = index_map_resize(entries_map, entries.length, index->ignore_case)) < 0)",
            "+\tif ((error = git_index_entrymap_resize(&entries_map, entries.length)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tgit_vector_foreach(&entries, i, e) {",
            "-\t\tif ((error = index_map_set(entries_map, e, index->ignore_case)) < 0) {",
            "+\t\tif ((error = git_index_entrymap_put(&entries_map, e)) < 0) {",
            " \t\t\tgit_error_set(GIT_ERROR_INDEX, \"failed to insert entry into map\");",
            " \t\t\treturn error;",
            " \t\t}",
            " \t}",
            " ",
            " \terror = 0;",
            " ",
            " \tgit_vector_sort(&entries);",
            " ",
            "-\tif ((error = git_index_clear(index)) < 0) {",
            "-\t\t/* well, this isn't good */;",
            "-\t} else {",
            "-\t\tgit_vector_swap(&entries, &index->entries);",
            "-\t\tentries_map = git_atomic_swap(index->entries_map, entries_map);",
            "-\t}",
            "+\tif ((error = git_index_clear(index)) < 0)",
            "+\t\tgoto cleanup;",
            "+",
            "+\tgit_vector_swap(&entries, &index->entries);",
            "+\tgit_index_entrymap_swap(&entries_map, &index->entries_map);",
            " ",
            " \tindex->dirty = 1;",
            " ",
            " cleanup:",
            "-\tgit_vector_free(&entries);",
            "-\tgit_idxmap_free(entries_map);",
            "+\tgit_vector_dispose(&entries);",
            "+\tgit_index_entrymap_dispose(&entries_map);",
            "+",
            " \tif (error < 0)",
            " \t\treturn error;",
            " ",
            " \terror = git_tree_cache_read_tree(&index->tree, tree, index->oid_type, &index->tree_pool);",
            " ",
            " \treturn error;",
            " }",
            "@@ -3425,31 +3399,30 @@",
            " static int git_index_read_iterator(",
            " \tgit_index *index,",
            " \tgit_iterator *new_iterator,",
            " \tsize_t new_length_hint)",
            " {",
            " \tgit_vector new_entries = GIT_VECTOR_INIT,",
            " \t\tremove_entries = GIT_VECTOR_INIT;",
            "-\tgit_idxmap *new_entries_map = NULL;",
            "+\tgit_index_entrymap new_entries_map = GIT_INDEX_ENTRYMAP_INIT;",
            " \tgit_iterator *index_iterator = NULL;",
            " \tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tconst git_index_entry *old_entry, *new_entry;",
            " \tgit_index_entry *entry;",
            " \tsize_t i;",
            " \tint error;",
            " ",
            " \tGIT_ASSERT((new_iterator->flags & GIT_ITERATOR_DONT_IGNORE_CASE));",
            " ",
            " \tif ((error = git_vector_init(&new_entries, new_length_hint, index->entries._cmp)) < 0 ||",
            "-\t    (error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||",
            "-\t    (error = git_idxmap_new(&new_entries_map)) < 0)",
            "+\t    (error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0)",
            " \t\tgoto done;",
            " ",
            "-\tif (new_length_hint && (error = index_map_resize(new_entries_map, new_length_hint,",
            "-\t\t\t\t\t\t\t index->ignore_case)) < 0)",
            "+\tif (new_length_hint &&",
            "+\t    (error = git_index_entrymap_resize(&new_entries_map, new_length_hint)) < 0)",
            " \t\tgoto done;",
            " ",
            " \topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE |",
            " \t\tGIT_ITERATOR_INCLUDE_CONFLICTS;",
            " ",
            " \tif ((error = git_iterator_for_index(&index_iterator,",
            " \t\t\tgit_index_owner(index), index, &opts)) < 0 ||",
            "@@ -3506,16 +3479,15 @@",
            " \t\t * invalidate the parent trees)",
            " \t\t */",
            " \t\tif (dup_entry && !remove_entry && index->tree)",
            " \t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);",
            " ",
            " \t\tif (add_entry) {",
            " \t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)",
            "-\t\t\t\terror = index_map_set(new_entries_map, add_entry,",
            "-\t\t\t\t\t\t      index->ignore_case);",
            "+\t\t\t\terror = git_index_entrymap_put(&new_entries_map, add_entry);",
            " \t\t}",
            " ",
            " \t\tif (remove_entry && error >= 0)",
            " \t\t\terror = git_vector_insert(&remove_entries, remove_entry);",
            " ",
            " \t\tif (error < 0) {",
            " \t\t\tgit_error_set(GIT_ERROR_INDEX, \"failed to insert entry\");",
            "@@ -3536,32 +3508,32 @@",
            " \t}",
            " ",
            " \tif ((error = git_index_name_clear(index)) < 0 ||",
            " \t\t(error = git_index_reuc_clear(index)) < 0)",
            " \t    goto done;",
            " ",
            " \tgit_vector_swap(&new_entries, &index->entries);",
            "-\tnew_entries_map = git_atomic_swap(index->entries_map, new_entries_map);",
            "+\tgit_index_entrymap_swap(&index->entries_map, &new_entries_map);",
            " ",
            " \tgit_vector_foreach(&remove_entries, i, entry) {",
            " \t\tif (index->tree)",
            " \t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);",
            " ",
            " \t\tindex_entry_free(entry);",
            " \t}",
            " ",
            " \tclear_uptodate(index);",
            " ",
            " \tindex->dirty = 1;",
            " \terror = 0;",
            " ",
            " done:",
            "-\tgit_idxmap_free(new_entries_map);",
            "-\tgit_vector_free(&new_entries);",
            "-\tgit_vector_free(&remove_entries);",
            "+\tgit_index_entrymap_dispose(&new_entries_map);",
            "+\tgit_vector_dispose(&new_entries);",
            "+\tgit_vector_dispose(&remove_entries);",
            " \tgit_iterator_free(index_iterator);",
            " \treturn error;",
            " }",
            " ",
            " int git_index_read_index(",
            " \tgit_index *index,",
            " \tconst git_index *new_index)",
            "@@ -3854,15 +3826,15 @@",
            " \t\tgit_index_snapshot_release(snap, index);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " void git_index_snapshot_release(git_vector *snap, git_index *index)",
            " {",
            "-\tgit_vector_free(snap);",
            "+\tgit_vector_dispose(snap);",
            " ",
            " \tgit_atomic32_dec(&index->readers);",
            " ",
            " \tgit_index_free(index);",
            " }",
            " ",
            " int git_index_snapshot_find("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/index.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/index.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/index.h",
            "@@ -8,16 +8,16 @@",
            " #define INCLUDE_index_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"futils.h\"",
            " #include \"filebuf.h\"",
            " #include \"vector.h\"",
            "-#include \"idxmap.h\"",
            " #include \"tree-cache.h\"",
            "+#include \"index_map.h\"",
            " #include \"git2/odb.h\"",
            " #include \"git2/index.h\"",
            " ",
            " #define GIT_INDEX_FILE \"index\"",
            " #define GIT_INDEX_FILE_MODE 0666",
            " ",
            " extern bool git_index__enforce_unsaved_safety;",
            "@@ -26,15 +26,15 @@",
            " \tgit_refcount rc;",
            " ",
            " \tchar *index_file_path;",
            " \tgit_futils_filestamp stamp;",
            " \tunsigned char checksum[GIT_HASH_MAX_SIZE];",
            " ",
            " \tgit_vector entries;",
            "-\tgit_idxmap *entries_map;",
            "+\tgit_index_entrymap entries_map;",
            " ",
            " \tgit_vector deleted; /* deleted entries if readers > 0 */",
            " \tgit_atomic32 readers; /* number of active iterators */",
            " ",
            " \tgit_oid_t oid_type;",
            " ",
            " \tunsigned int on_disk:1;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/indexer.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/indexer.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/indexer.c",
            "@@ -16,22 +16,24 @@",
            " #include \"pack.h\"",
            " #include \"mwindow.h\"",
            " #include \"posix.h\"",
            " #include \"pack.h\"",
            " #include \"filebuf.h\"",
            " #include \"oid.h\"",
            " #include \"oidarray.h\"",
            "-#include \"oidmap.h\"",
            " #include \"zstream.h\"",
            " #include \"object.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            " size_t git_indexer__max_objects = UINT32_MAX;",
            " ",
            " #define UINT31_MAX (0x7FFFFFFF)",
            " ",
            "+GIT_HASHMAP_OID_SETUP(git_indexer_oidmap, git_oid *);",
            "+",
            " struct entry {",
            " \tgit_oid oid;",
            " \tuint32_t crc;",
            " \tuint32_t offset;",
            " \tuint64_t offset_long;",
            " };",
            " ",
            "@@ -59,15 +61,15 @@",
            " \tunsigned char checksum[GIT_HASH_MAX_SIZE];",
            " \tchar name[(GIT_HASH_MAX_SIZE * 2) + 1];",
            " \tgit_indexer_progress_cb progress_cb;",
            " \tvoid *progress_payload;",
            " \tchar objbuf[8*1024];",
            " ",
            " \t/* OIDs referenced from pack objects. Used for verification. */",
            "-\tgit_oidmap *expected_oids;",
            "+\tgit_indexer_oidmap expected_oids;",
            " ",
            " \t/* Needed to look up objects which we want to inject to fix a thin pack */",
            " \tgit_odb *odb;",
            " ",
            " \t/* Fields for calculating the packfile trailer (hash of everything before it) */",
            " \tchar inbuf[GIT_HASH_MAX_SIZE];",
            " \tsize_t inbuf_len;",
            "@@ -165,28 +167,30 @@",
            " \tstatic const char suff[] = \"/pack\";",
            " \tgit_hash_algorithm_t checksum_type;",
            " \tint error, fd = -1;",
            " ",
            " \tif (in_opts)",
            " \t\tmemcpy(&opts, in_opts, sizeof(opts));",
            " ",
            "+\tif (oid_type)",
            "+\t\tGIT_ASSERT_ARG(git_oid_type_is_valid(oid_type));",
            "+",
            " \tidx = git__calloc(1, sizeof(git_indexer));",
            " \tGIT_ERROR_CHECK_ALLOC(idx);",
            "-\tidx->oid_type = oid_type;",
            "+\tidx->oid_type = oid_type ? oid_type : GIT_OID_DEFAULT;",
            " \tidx->odb = odb;",
            " \tidx->progress_cb = opts.progress_cb;",
            " \tidx->progress_payload = opts.progress_cb_payload;",
            " \tidx->mode = mode ? mode : GIT_PACK_FILE_MODE;",
            " \tgit_str_init(&idx->entry_data, 0);",
            " ",
            " \tchecksum_type = indexer_hash_algorithm(idx);",
            " ",
            " \tif ((error = git_hash_ctx_init(&idx->hash_ctx, checksum_type)) < 0 ||",
            "-\t    (error = git_hash_ctx_init(&idx->trailer, checksum_type)) < 0 ||",
            "-\t    (error = git_oidmap_new(&idx->expected_oids)) < 0)",
            "+\t    (error = git_hash_ctx_init(&idx->trailer, checksum_type)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \tidx->do_verify = opts.verify;",
            " ",
            " \tif (git_repository__fsync_gitdir)",
            " \t\tidx->do_fsync = 1;",
            " ",
            "@@ -228,21 +232,20 @@",
            " \treturn -1;",
            " }",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " int git_indexer_new(",
            " \tgit_indexer **out,",
            " \tconst char *prefix,",
            "-\tgit_oid_t oid_type,",
            " \tgit_indexer_options *opts)",
            " {",
            " \treturn indexer_new(",
            " \t\tout,",
            " \t\tprefix,",
            "-\t\toid_type,",
            "+\t\topts ? opts->oid_type : 0,",
            " \t\topts ? opts->mode : 0,",
            " \t\topts ? opts->odb : NULL,",
            " \t\topts);",
            " }",
            " #else",
            " int git_indexer_new(",
            " \tgit_indexer **out,",
            "@@ -376,20 +379,20 @@",
            " {",
            " \t/*",
            " \t * If we know about that object because it is stored in our ODB or",
            " \t * because we have already processed it as part of our pack file, we do",
            " \t * not have to expect it.",
            " \t */",
            " \tif ((!idx->odb || !git_odb_exists(idx->odb, oid)) &&",
            "-\t    !git_oidmap_exists(idx->pack->idx_cache, oid) &&",
            "-\t    !git_oidmap_exists(idx->expected_oids, oid)) {",
            "+\t    !git_pack_oidmap_contains(&idx->pack->idx_cache, oid) &&",
            "+\t    !git_indexer_oidmap_contains(&idx->expected_oids, oid)) {",
            " \t\t    git_oid *dup = git__malloc(sizeof(*oid));",
            " \t\t    GIT_ERROR_CHECK_ALLOC(dup);",
            " \t\t    git_oid_cpy(dup, oid);",
            "-\t\t    return git_oidmap_set(idx->expected_oids, dup, dup);",
            "+\t\t    return git_indexer_oidmap_put(&idx->expected_oids, dup, dup);",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int check_object_connectivity(git_indexer *idx, const git_rawobj *obj)",
            " {",
            "@@ -408,16 +411,16 @@",
            " \t\t * parse_raw returns EINVALID on invalid data; downgrade",
            " \t\t * that to a normal -1 error code.",
            " \t\t */",
            " \t\terror = -1;",
            " \t\tgoto out;",
            " \t}",
            " ",
            "-\tif ((expected = git_oidmap_get(idx->expected_oids, &object->cached.oid)) != NULL) {",
            "-\t\tgit_oidmap_delete(idx->expected_oids, &object->cached.oid);",
            "+\tif (git_indexer_oidmap_get(&expected, &idx->expected_oids, &object->cached.oid) == 0) {",
            "+\t\tgit_indexer_oidmap_remove(&idx->expected_oids, &object->cached.oid);",
            " \t\tgit__free(expected);",
            " \t}",
            " ",
            " \t/*",
            " \t * Check whether this is a known object. If so, we can just continue as",
            " \t * we assume that the ODB has a complete graph.",
            " \t */",
            "@@ -514,27 +517,27 @@",
            " \t\tif ((error = check_object_connectivity(idx, &rawobj)) < 0)",
            " \t\t\tgoto on_error;",
            " \t}",
            " ",
            " \tgit_oid_cpy(&pentry->id, &oid);",
            " \tpentry->offset = entry_start;",
            " ",
            "-\tif (git_oidmap_exists(idx->pack->idx_cache, &pentry->id)) {",
            "+\tif (git_pack_oidmap_contains(&idx->pack->idx_cache, &pentry->id)) {",
            " \t\tconst char *idstr = git_oid_tostr_s(&pentry->id);",
            " ",
            " \t\tif (!idstr)",
            " \t\t\tgit_error_set(GIT_ERROR_INDEXER, \"failed to parse object id\");",
            " \t\telse",
            " \t\t\tgit_error_set(GIT_ERROR_INDEXER, \"duplicate object %s found in pack\", idstr);",
            " ",
            " \t\tgit__free(pentry);",
            " \t\tgoto on_error;",
            " \t}",
            " ",
            "-\tif ((error = git_oidmap_set(idx->pack->idx_cache, &pentry->id, pentry)) < 0) {",
            "+\tif ((error = git_pack_oidmap_put(&idx->pack->idx_cache, &pentry->id, pentry)) < 0) {",
            " \t\tgit__free(pentry);",
            " \t\tgit_error_set_oom();",
            " \t\tgoto on_error;",
            " \t}",
            " ",
            " \tgit_oid_cpy(&entry->oid, &oid);",
            " ",
            "@@ -555,15 +558,15 @@",
            " \tgit__free(entry);",
            " ",
            " \treturn -1;",
            " }",
            " ",
            " GIT_INLINE(bool) has_entry(git_indexer *idx, git_oid *id)",
            " {",
            "-\treturn git_oidmap_exists(idx->pack->idx_cache, id);",
            "+\treturn git_pack_oidmap_contains(&idx->pack->idx_cache, id);",
            " }",
            " ",
            " static int save_entry(git_indexer *idx, struct entry *entry, struct git_pack_entry *pentry, off64_t entry_start)",
            " {",
            " \tint i;",
            " ",
            " \tif (entry_start > UINT31_MAX) {",
            "@@ -571,16 +574,16 @@",
            " \t\tentry->offset_long = entry_start;",
            " \t} else {",
            " \t\tentry->offset = (uint32_t)entry_start;",
            " \t}",
            " ",
            " \tpentry->offset = entry_start;",
            " ",
            "-\tif (git_oidmap_exists(idx->pack->idx_cache, &pentry->id) ||",
            "-\t    git_oidmap_set(idx->pack->idx_cache, &pentry->id, pentry) < 0) {",
            "+\tif (git_pack_oidmap_contains(&idx->pack->idx_cache, &pentry->id) ||",
            "+\t    git_pack_oidmap_put(&idx->pack->idx_cache, &pentry->id, pentry) < 0) {",
            " \t\tgit_error_set(GIT_ERROR_INDEXER, \"cannot insert object into pack\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \t/* Add the object to the list */",
            " \tif (git_vector_insert(&idx->objects, entry) < 0)",
            " \t\treturn -1;",
            "@@ -907,17 +910,14 @@",
            " \t\tif (idx->nr_objects <= git_indexer__max_objects) {",
            " \t\t\ttotal_objects = (unsigned int)idx->nr_objects;",
            " \t\t} else {",
            " \t\t\tgit_error_set(GIT_ERROR_INDEXER, \"too many objects\");",
            " \t\t\treturn -1;",
            " \t\t}",
            " ",
            "-\t\tif (git_oidmap_new(&idx->pack->idx_cache) < 0)",
            "-\t\t\treturn -1;",
            "-",
            " \t\tidx->pack->has_cache = 1;",
            " \t\tif (git_vector_init(&idx->objects, total_objects, objects_cmp) < 0)",
            " \t\t\treturn -1;",
            " ",
            " \t\tif (git_vector_init(&idx->deltas, total_objects / 2, NULL) < 0)",
            " \t\t\treturn -1;",
            " ",
            "@@ -1297,17 +1297,17 @@",
            " ",
            " \t/*",
            " \t * Is the resulting graph fully connected or are we still",
            " \t * missing some objects? In the second case, we can",
            " \t * bail out due to an incomplete and thus corrupt",
            " \t * packfile.",
            " \t */",
            "-\tif (git_oidmap_size(idx->expected_oids) > 0) {",
            "+\tif (git_indexer_oidmap_size(&idx->expected_oids) > 0) {",
            " \t\tgit_error_set(GIT_ERROR_INDEXER, \"packfile is missing %\"PRIuZ\" objects\",",
            "-\t\t\tgit_oidmap_size(idx->expected_oids));",
            "+\t\t\t(size_t)git_indexer_oidmap_size(&idx->expected_oids));",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tgit_vector_sort(&idx->objects);",
            " ",
            " \t/* Use the trailer hash as the pack file name to ensure",
            " \t * files with different contents have different names */",
            "@@ -1442,42 +1442,38 @@",
            " \tgit_filebuf_cleanup(&index_file);",
            " \tgit_str_dispose(&filename);",
            " \treturn -1;",
            " }",
            " ",
            " void git_indexer_free(git_indexer *idx)",
            " {",
            "-\tconst git_oid *key;",
            "-\tgit_oid *value;",
            "-\tsize_t iter;",
            "+\tstruct git_pack_entry *pentry;",
            "+\tgit_oid *id;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tif (idx == NULL)",
            " \t\treturn;",
            " ",
            " \tif (idx->have_stream)",
            " \t\tgit_packfile_stream_dispose(&idx->stream);",
            " ",
            "-\tgit_vector_free_deep(&idx->objects);",
            "+\tgit_vector_dispose_deep(&idx->objects);",
            " ",
            "-\tif (idx->pack->idx_cache) {",
            "-\t\tstruct git_pack_entry *pentry;",
            "-\t\tgit_oidmap_foreach_value(idx->pack->idx_cache, pentry, {",
            "-\t\t\tgit__free(pentry);",
            "-\t\t});",
            "+\twhile (git_pack_oidmap_iterate(&iter, NULL, &pentry, &idx->pack->idx_cache) == 0)",
            "+\t\tgit__free(pentry);",
            " ",
            "-\t\tgit_oidmap_free(idx->pack->idx_cache);",
            "-\t}",
            "+\tgit_pack_oidmap_dispose(&idx->pack->idx_cache);",
            " ",
            "-\tgit_vector_free_deep(&idx->deltas);",
            "+\tgit_vector_dispose_deep(&idx->deltas);",
            " ",
            " \tgit_packfile_free(idx->pack, !idx->pack_committed);",
            " ",
            "-\titer = 0;",
            "-\twhile (git_oidmap_iterate((void **) &value, idx->expected_oids, &iter, &key) == 0)",
            "-\t\tgit__free(value);",
            "+\titer = GIT_HASHMAP_ITER_INIT;",
            "+\twhile (git_indexer_oidmap_iterate(&iter, NULL, &id, &idx->expected_oids) == 0)",
            "+\t\tgit__free(id);",
            " ",
            " \tgit_hash_ctx_cleanup(&idx->trailer);",
            " \tgit_hash_ctx_cleanup(&idx->hash_ctx);",
            " \tgit_str_dispose(&idx->entry_data);",
            "-\tgit_oidmap_free(idx->expected_oids);",
            "+\tgit_indexer_oidmap_dispose(&idx->expected_oids);",
            " \tgit__free(idx);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/iterator.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/iterator.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/iterator.c",
            "@@ -692,28 +692,28 @@",
            " \tgit_tree *tree;",
            " \tsize_t i;",
            " ",
            " \tGIT_ASSERT(iter->frames.size);",
            " ",
            " \tframe = git_array_pop(iter->frames);",
            " ",
            "-\tgit_vector_free(&frame->entries);",
            "+\tgit_vector_dispose(&frame->entries);",
            " \tgit_tree_free(frame->tree);",
            " ",
            " \tdo {",
            " \t\tbuf = git_array_pop(frame->similar_paths);",
            " \t\tgit_str_dispose(buf);",
            " \t} while (buf != NULL);",
            " ",
            " \tgit_array_clear(frame->similar_paths);",
            " ",
            " \tgit_vector_foreach(&frame->similar_trees, i, tree)",
            " \t\tgit_tree_free(tree);",
            " ",
            "-\tgit_vector_free(&frame->similar_trees);",
            "+\tgit_vector_dispose(&frame->similar_trees);",
            " ",
            " \tgit_str_dispose(&frame->path);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int tree_iterator_current(",
            "@@ -1497,15 +1497,15 @@",
            " ",
            " \tGIT_ASSERT(iter->frames.size);",
            " ",
            " \tframe = git_array_pop(iter->frames);",
            " \tfilesystem_iterator_frame_pop_ignores(iter);",
            " ",
            " \tgit_pool_clear(&frame->entry_pool);",
            "-\tgit_vector_free(&frame->entries);",
            "+\tgit_vector_dispose(&frame->entries);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static void filesystem_iterator_set_current(",
            " \tfilesystem_iterator *iter,",
            " \tfilesystem_iterator_entry *entry)",
            "@@ -2332,15 +2332,15 @@",
            " void git_iterator_free(git_iterator *iter)",
            " {",
            " \tif (iter == NULL)",
            " \t\treturn;",
            " ",
            " \titer->cb->free(iter);",
            " ",
            "-\tgit_vector_free(&iter->pathlist);",
            "+\tgit_vector_dispose(&iter->pathlist);",
            " \tgit__free(iter->start);",
            " \tgit__free(iter->end);",
            " ",
            " \tmemset(iter, 0, sizeof(*iter));",
            " ",
            " \tgit__free(iter);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/libgit2.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/libgit2.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/libgit2.c",
            "@@ -62,24 +62,24 @@",
            " int git_libgit2_shutdown(void)",
            " {",
            " \treturn git_runtime_shutdown();",
            " }",
            " ",
            " int git_libgit2_version(int *major, int *minor, int *rev)",
            " {",
            "-\t*major = LIBGIT2_VER_MAJOR;",
            "-\t*minor = LIBGIT2_VER_MINOR;",
            "-\t*rev = LIBGIT2_VER_REVISION;",
            "+\t*major = LIBGIT2_VERSION_MAJOR;",
            "+\t*minor = LIBGIT2_VERSION_MINOR;",
            "+\t*rev = LIBGIT2_VERSION_REVISION;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " const char *git_libgit2_prerelease(void)",
            " {",
            "-\treturn LIBGIT2_VER_PRERELEASE;",
            "+\treturn LIBGIT2_VERSION_PRERELEASE;",
            " }",
            " ",
            " int git_libgit2_features(void)",
            " {",
            " \treturn 0",
            " #ifdef GIT_THREADS",
            " \t\t| GIT_FEATURE_THREADS",
            "@@ -89,9 +89,180 @@",
            " #endif",
            " #ifdef GIT_SSH",
            " \t\t| GIT_FEATURE_SSH",
            " #endif",
            " #ifdef GIT_USE_NSEC",
            " \t\t| GIT_FEATURE_NSEC",
            " #endif",
            "+\t\t| GIT_FEATURE_HTTP_PARSER",
            "+\t\t| GIT_FEATURE_REGEX",
            "+#ifdef GIT_USE_ICONV",
            "+\t\t| GIT_FEATURE_I18N",
            "+#endif",
            "+#if defined(GIT_NTLM) || defined(GIT_WIN32)",
            "+\t\t| GIT_FEATURE_AUTH_NTLM",
            "+#endif",
            "+#if defined(GIT_GSSAPI) || defined(GIT_GSSFRAMEWORK) || defined(GIT_WIN32)",
            "+\t\t| GIT_FEATURE_AUTH_NEGOTIATE",
            "+#endif",
            "+\t\t| GIT_FEATURE_COMPRESSION",
            "+\t\t| GIT_FEATURE_SHA1",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\t\t| GIT_FEATURE_SHA256",
            "+#endif",
            " \t;",
            " }",
            "+",
            "+const char *git_libgit2_feature_backend(git_feature_t feature)",
            "+{",
            "+\tswitch (feature) {",
            "+\tcase GIT_FEATURE_THREADS:",
            "+#if defined(GIT_THREADS) && defined(GIT_WIN32)",
            "+\t\treturn \"win32\";",
            "+#elif defined(GIT_THREADS)",
            "+\t\treturn \"pthread\";",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_HTTPS:",
            "+#if defined(GIT_HTTPS) && defined(GIT_OPENSSL)",
            "+\t\treturn \"openssl\";",
            "+#elif defined(GIT_HTTPS) && defined(GIT_OPENSSL_DYNAMIC)",
            "+\t\treturn \"openssl-dynamic\";",
            "+#elif defined(GIT_HTTPS) && defined(GIT_MBEDTLS)",
            "+\t\treturn \"mbedtls\";",
            "+#elif defined(GIT_HTTPS) && defined(GIT_SECURE_TRANSPORT)",
            "+\t\treturn \"securetransport\";",
            "+#elif defined(GIT_HTTPS) && defined(GIT_SCHANNEL)",
            "+\t\treturn \"schannel\";",
            "+#elif defined(GIT_HTTPS) && defined(GIT_WINHTTP)",
            "+\t\treturn \"winhttp\";",
            "+#elif defined(GIT_HTTPS)",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown HTTPS backend\", NULL);",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_SSH:",
            "+#if defined(GIT_SSH_EXEC)",
            "+\t\treturn \"exec\";",
            "+#elif defined(GIT_SSH_LIBSSH2)",
            "+\t\treturn \"libssh2\";",
            "+#elif defined(GIT_SSH)",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown SSH backend\", NULL);",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_NSEC:",
            "+#if defined(GIT_USE_NSEC) && defined(GIT_USE_STAT_MTIMESPEC)",
            "+\t\treturn \"mtimespec\";",
            "+#elif defined(GIT_USE_NSEC) && defined(GIT_USE_STAT_MTIM)",
            "+\t\treturn \"mtim\";",
            "+#elif defined(GIT_USE_NSEC) && defined(GIT_USE_STAT_MTIME_NSEC)",
            "+\t\treturn \"mtime\";",
            "+#elif defined(GIT_USE_NSEC) && defined(GIT_WIN32)",
            "+\t\treturn \"win32\";",
            "+#elif defined(GIT_USE_NSEC)",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown high-resolution time backend\", NULL);",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_HTTP_PARSER:",
            "+#if defined(GIT_HTTPPARSER_HTTPPARSER)",
            "+\t\treturn \"httpparser\";",
            "+#elif defined(GIT_HTTPPARSER_LLHTTP)",
            "+\t\treturn \"llhttp\";",
            "+#elif defined(GIT_HTTPPARSER_BUILTIN)",
            "+\t\treturn \"builtin\";",
            "+#endif",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown HTTP parser backend\", NULL);",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_REGEX:",
            "+#if defined(GIT_REGEX_REGCOMP_L)",
            "+\t\treturn \"regcomp_l\";",
            "+#elif defined(GIT_REGEX_REGCOMP)",
            "+\t\treturn \"regcomp\";",
            "+#elif defined(GIT_REGEX_PCRE)",
            "+\t\treturn \"pcre\";",
            "+#elif defined(GIT_REGEX_PCRE2)",
            "+\t\treturn \"pcre2\";",
            "+#elif defined(GIT_REGEX_BUILTIN)",
            "+\t\treturn \"builtin\";",
            "+#endif",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown regular expression backend\", NULL);",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_I18N:",
            "+#if defined(GIT_USE_ICONV)",
            "+\t\treturn \"iconv\";",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_AUTH_NTLM:",
            "+#if defined(GIT_NTLM)",
            "+\t\treturn \"ntlmclient\";",
            "+#elif defined(GIT_WIN32)",
            "+\t\treturn \"sspi\";",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_AUTH_NEGOTIATE:",
            "+#if defined(GIT_GSSAPI)",
            "+\t\treturn \"gssapi\";",
            "+#elif defined(GIT_WIN32)",
            "+\t\treturn \"sspi\";",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_COMPRESSION:",
            "+#if defined(GIT_COMPRESSION_ZLIB)",
            "+\t\treturn \"zlib\";",
            "+#elif defined(GIT_COMPRESSION_BUILTIN)",
            "+\t\treturn \"builtin\";",
            "+#else",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown compression backend\", NULL);",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_SHA1:",
            "+#if defined(GIT_SHA1_COLLISIONDETECT)",
            "+\t\treturn \"builtin\";",
            "+#elif defined(GIT_SHA1_OPENSSL)",
            "+\t\treturn \"openssl\";",
            "+#elif defined(GIT_SHA1_OPENSSL_FIPS)",
            "+\t\treturn \"openssl-fips\";",
            "+#elif defined(GIT_SHA1_OPENSSL_DYNAMIC)",
            "+\t\treturn \"openssl-dynamic\";",
            "+#elif defined(GIT_SHA1_MBEDTLS)",
            "+\t\treturn \"mbedtls\";",
            "+#elif defined(GIT_SHA1_COMMON_CRYPTO)",
            "+\t\treturn \"commoncrypto\";",
            "+#elif defined(GIT_SHA1_WIN32)",
            "+\t\treturn \"win32\";",
            "+#else",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown SHA1 backend\", NULL);",
            "+#endif",
            "+\t\tbreak;",
            "+",
            "+\tcase GIT_FEATURE_SHA256:",
            "+#if defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_BUILTIN)",
            "+\t\treturn \"builtin\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_OPENSSL)",
            "+\t\treturn \"openssl\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_OPENSSL_FIPS)",
            "+\t\treturn \"openssl-fips\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_OPENSSL_DYNAMIC)",
            "+\t\treturn \"openssl-dynamic\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_MBEDTLS)",
            "+\t\treturn \"mbedtls\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_COMMON_CRYPTO)",
            "+\t\treturn \"commoncrypto\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_WIN32)",
            "+\t\treturn \"win32\";",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256)",
            "+\t\tGIT_ASSERT_WITH_RETVAL(!\"Unknown SHA256 backend\", NULL);",
            "+#endif",
            "+\t\tbreak;",
            "+\t}",
            "+",
            "+\treturn NULL;",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/mailmap.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/mailmap.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/mailmap.c",
            "@@ -169,15 +169,15 @@",
            " \tgit_mailmap_entry *entry;",
            " \tif (!mm)",
            " \t\treturn;",
            " ",
            " \tgit_vector_foreach(&mm->entries, idx, entry)",
            " \t\tmailmap_entry_free(entry);",
            " ",
            "-\tgit_vector_free(&mm->entries);",
            "+\tgit_vector_dispose(&mm->entries);",
            " \tgit__free(mm);",
            " }",
            " ",
            " static int mailmap_add_entry_unterminated(",
            " \tgit_mailmap *mm,",
            " \tconst char *real_name, size_t real_name_size,",
            " \tconst char *real_email, size_t real_email_size,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/merge.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/merge.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/merge.c",
            "@@ -28,15 +28,14 @@",
            " #include \"filebuf.h\"",
            " #include \"config.h\"",
            " #include \"oidarray.h\"",
            " #include \"annotated_commit.h\"",
            " #include \"commit.h\"",
            " #include \"oidarray.h\"",
            " #include \"merge_driver.h\"",
            "-#include \"oidmap.h\"",
            " #include \"array.h\"",
            " ",
            " #include \"git2/types.h\"",
            " #include \"git2/repository.h\"",
            " #include \"git2/object.h\"",
            " #include \"git2/commit.h\"",
            " #include \"git2/merge.h\"",
            "@@ -120,19 +119,19 @@",
            " \t\terror = GIT_ENOTFOUND;",
            " \t\tgoto on_error;",
            " \t}",
            " ",
            " \t*out = result;",
            " \t*walk_out = walk;",
            " ",
            "-\tgit_vector_free(&list);",
            "+\tgit_vector_dispose(&list);",
            " \treturn 0;",
            " ",
            " on_error:",
            "-\tgit_vector_free(&list);",
            "+\tgit_vector_dispose(&list);",
            " \tgit_revwalk_free(walk);",
            " \treturn error;",
            " }",
            " ",
            " int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])",
            " {",
            " \tgit_revwalk *walk;",
            "@@ -507,15 +506,15 @@",
            " \t\tif (redundant[i])",
            " \t\t\tcommits->contents[i] = NULL;",
            " \t}",
            " ",
            " done:",
            " \tgit__free(redundant);",
            " \tgit__free(filled_index);",
            "-\tgit_vector_free(&work);",
            "+\tgit_vector_dispose(&work);",
            " \treturn error;",
            " }",
            " ",
            " int git_merge__bases_many(",
            " \t\tgit_commit_list **out,",
            " \t\tgit_revwalk *walk,",
            " \t\tgit_commit_list_node *one,",
            "@@ -566,24 +565,24 @@",
            " ",
            " \t\twhile (result)",
            " \t\t\tgit_vector_insert(&redundant, git_commit_list_pop(&result));",
            " ",
            " \t\tif ((error = clear_commit_marks(one, ALL_FLAGS)) < 0 ||",
            " \t\t    (error = clear_commit_marks_many(twos, ALL_FLAGS)) < 0 ||",
            " \t\t    (error = remove_redundant(walk, &redundant, minimum_generation)) < 0) {",
            "-\t\t\tgit_vector_free(&redundant);",
            "+\t\t\tgit_vector_dispose(&redundant);",
            " \t\t\treturn error;",
            " \t\t}",
            " ",
            " \t\tgit_vector_foreach(&redundant, i, two) {",
            " \t\t\tif (two != NULL)",
            " \t\t\t\tgit_commit_list_insert_by_date(two, &result);",
            " \t\t}",
            " ",
            "-\t\tgit_vector_free(&redundant);",
            "+\t\tgit_vector_dispose(&redundant);",
            " \t}",
            " ",
            " \t*out = result;",
            " \treturn 0;",
            " }",
            " ",
            " int git_repository_mergehead_foreach(",
            "@@ -1140,57 +1139,62 @@",
            " */",
            " typedef struct {",
            " \tgit_array_t(size_t) arr;",
            " \tsize_t next_pos;",
            " \tsize_t first_entry;",
            " } deletes_by_oid_queue;",
            " ",
            "-static void deletes_by_oid_free(git_oidmap *map) {",
            "+GIT_HASHMAP_OID_SETUP(git_merge_deletes_oidmap, deletes_by_oid_queue *);",
            "+",
            "+static void deletes_by_oid_dispose(git_merge_deletes_oidmap *map)",
            "+{",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tdeletes_by_oid_queue *queue;",
            " ",
            " \tif (!map)",
            " \t\treturn;",
            " ",
            "-\tgit_oidmap_foreach_value(map, queue, {",
            "+\twhile (git_merge_deletes_oidmap_iterate(&iter, NULL, &queue, map) == 0)",
            " \t\tgit_array_clear(queue->arr);",
            "-\t});",
            "-\tgit_oidmap_free(map);",
            "+",
            "+\tgit_merge_deletes_oidmap_dispose(map);",
            " }",
            " ",
            "-static int deletes_by_oid_enqueue(git_oidmap *map, git_pool *pool, const git_oid *id, size_t idx)",
            "+static int deletes_by_oid_enqueue(git_merge_deletes_oidmap *map, git_pool *pool, const git_oid *id, size_t idx)",
            " {",
            " \tdeletes_by_oid_queue *queue;",
            " \tsize_t *array_entry;",
            " ",
            "-\tif ((queue = git_oidmap_get(map, id)) == NULL) {",
            "+\tif (git_merge_deletes_oidmap_get(&queue, map, id) != 0) {",
            " \t\tqueue = git_pool_malloc(pool, sizeof(deletes_by_oid_queue));",
            " \t\tGIT_ERROR_CHECK_ALLOC(queue);",
            " ",
            " \t\tgit_array_init(queue->arr);",
            " \t\tqueue->next_pos = 0;",
            " \t\tqueue->first_entry = idx;",
            " ",
            "-\t\tif (git_oidmap_set(map, id, queue) < 0)",
            "+\t\tif (git_merge_deletes_oidmap_put(map, id, queue) < 0)",
            " \t\t\treturn -1;",
            " \t} else {",
            " \t\tarray_entry = git_array_alloc(queue->arr);",
            " \t\tGIT_ERROR_CHECK_ALLOC(array_entry);",
            " \t\t*array_entry = idx;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-static int deletes_by_oid_dequeue(size_t *idx, git_oidmap *map, const git_oid *id)",
            "+static int deletes_by_oid_dequeue(size_t *idx, git_merge_deletes_oidmap *map, const git_oid *id)",
            " {",
            " \tdeletes_by_oid_queue *queue;",
            " \tsize_t *array_entry;",
            "+\tint error;",
            " ",
            "-\tif ((queue = git_oidmap_get(map, id)) == NULL)",
            "-\t\treturn GIT_ENOTFOUND;",
            "+\tif ((error = git_merge_deletes_oidmap_get(&queue, map, id)) != 0)",
            "+\t\treturn error;",
            " ",
            " \tif (queue->next_pos == 0) {",
            " \t\t*idx = queue->first_entry;",
            " \t} else {",
            " \t\tarray_entry = git_array_get(queue->arr, queue->next_pos - 1);",
            " \t\tif (array_entry == NULL)",
            " \t\t\treturn GIT_ENOTFOUND;",
            "@@ -1205,23 +1209,18 @@",
            " static int merge_diff_mark_similarity_exact(",
            " \tgit_merge_diff_list *diff_list,",
            " \tstruct merge_diff_similarity *similarity_ours,",
            " \tstruct merge_diff_similarity *similarity_theirs)",
            " {",
            " \tsize_t i, j;",
            " \tgit_merge_diff *conflict_src, *conflict_tgt;",
            "-\tgit_oidmap *ours_deletes_by_oid = NULL, *theirs_deletes_by_oid = NULL;",
            "+\tgit_merge_deletes_oidmap ours_deletes_by_oid = GIT_HASHMAP_INIT,",
            "+\t                         theirs_deletes_by_oid = GIT_HASHMAP_INIT;",
            " \tint error = 0;",
            " ",
            "-\tif (git_oidmap_new(&ours_deletes_by_oid) < 0 ||",
            "-\t    git_oidmap_new(&theirs_deletes_by_oid) < 0) {",
            "-\t\terror = -1;",
            "-\t\tgoto done;",
            "-\t}",
            "-",
            " \t/* Build a map of object ids to conflicts */",
            " \tgit_vector_foreach(&diff_list->conflicts, i, conflict_src) {",
            " \t\t/* Items can be the source of a rename iff they have an item in the",
            " \t\t* ancestor slot and lack an item in the ours or theirs slot. */",
            " \t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->ancestor_entry))",
            " \t\t\tcontinue;",
            " ",
            "@@ -1229,54 +1228,54 @@",
            " \t\t * Ignore empty files because it has always the same blob sha1",
            " \t\t * and will lead to incorrect matches between all entries.",
            " \t\t */",
            " \t\tif (git_oid_equal(&conflict_src->ancestor_entry.id, &git_oid__empty_blob_sha1))",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->our_entry)) {",
            "-\t\t\terror = deletes_by_oid_enqueue(ours_deletes_by_oid, &diff_list->pool, &conflict_src->ancestor_entry.id, i);",
            "+\t\t\terror = deletes_by_oid_enqueue(&ours_deletes_by_oid, &diff_list->pool, &conflict_src->ancestor_entry.id, i);",
            " \t\t\tif (error < 0)",
            " \t\t\t\tgoto done;",
            " \t\t}",
            " ",
            " \t\tif (!GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_src->their_entry)) {",
            "-\t\t\terror = deletes_by_oid_enqueue(theirs_deletes_by_oid, &diff_list->pool, &conflict_src->ancestor_entry.id, i);",
            "+\t\t\terror = deletes_by_oid_enqueue(&theirs_deletes_by_oid, &diff_list->pool, &conflict_src->ancestor_entry.id, i);",
            " \t\t\tif (error < 0)",
            " \t\t\t\tgoto done;",
            " \t\t}",
            " \t}",
            " ",
            " \tgit_vector_foreach(&diff_list->conflicts, j, conflict_tgt) {",
            " \t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->ancestor_entry))",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->our_entry)) {",
            "-\t\t\tif (deletes_by_oid_dequeue(&i, ours_deletes_by_oid, &conflict_tgt->our_entry.id) == 0) {",
            "+\t\t\tif (deletes_by_oid_dequeue(&i, &ours_deletes_by_oid, &conflict_tgt->our_entry.id) == 0) {",
            " \t\t\t\tsimilarity_ours[i].similarity = 100;",
            " \t\t\t\tsimilarity_ours[i].other_idx = j;",
            " ",
            " \t\t\t\tsimilarity_ours[j].similarity = 100;",
            " \t\t\t\tsimilarity_ours[j].other_idx = i;",
            " \t\t\t}",
            " \t\t}",
            " ",
            " \t\tif (GIT_MERGE_INDEX_ENTRY_EXISTS(conflict_tgt->their_entry)) {",
            "-\t\t\tif (deletes_by_oid_dequeue(&i, theirs_deletes_by_oid, &conflict_tgt->their_entry.id) == 0) {",
            "+\t\t\tif (deletes_by_oid_dequeue(&i, &theirs_deletes_by_oid, &conflict_tgt->their_entry.id) == 0) {",
            " \t\t\t\tsimilarity_theirs[i].similarity = 100;",
            " \t\t\t\tsimilarity_theirs[i].other_idx = j;",
            " ",
            " \t\t\t\tsimilarity_theirs[j].similarity = 100;",
            " \t\t\t\tsimilarity_theirs[j].other_idx = i;",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            " done:",
            "-\tdeletes_by_oid_free(ours_deletes_by_oid);",
            "-\tdeletes_by_oid_free(theirs_deletes_by_oid);",
            "+\tdeletes_by_oid_dispose(&ours_deletes_by_oid);",
            "+\tdeletes_by_oid_dispose(&theirs_deletes_by_oid);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int merge_diff_mark_similarity_inexact(",
            " \tgit_repository *repo,",
            " \tgit_merge_diff_list *diff_list,",
            "@@ -1862,17 +1861,17 @@",
            " }",
            " ",
            " void git_merge_diff_list__free(git_merge_diff_list *diff_list)",
            " {",
            " \tif (!diff_list)",
            " \t\treturn;",
            " ",
            "-\tgit_vector_free(&diff_list->staged);",
            "-\tgit_vector_free(&diff_list->conflicts);",
            "-\tgit_vector_free(&diff_list->resolved);",
            "+\tgit_vector_dispose(&diff_list->staged);",
            "+\tgit_vector_dispose(&diff_list->conflicts);",
            "+\tgit_vector_dispose(&diff_list->resolved);",
            " \tgit_pool_clear(&diff_list->pool);",
            " \tgit__free(diff_list);",
            " }",
            " ",
            " static int merge_normalize_opts(",
            " \tgit_repository *repo,",
            " \tgit_merge_options *opts,",
            "@@ -2832,15 +2831,15 @@",
            " ",
            " cleanup:",
            " \tif (error < 0)",
            " \t\tgit_filebuf_cleanup(&file);",
            " ",
            " \tgit_str_dispose(&file_path);",
            " ",
            "-\tgit_vector_free(&matching);",
            "+\tgit_vector_dispose(&matching);",
            " \tgit__free(entries);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " int git_merge__setup(",
            " \tgit_repository *repo,",
            "@@ -3011,15 +3010,15 @@",
            " done:",
            " \tgit_tree_free(head_tree);",
            " \tgit_index_free(index_repo);",
            " \tgit_iterator_free(iter_repo);",
            " \tgit_iterator_free(iter_new);",
            " \tgit_diff_free(staged_diff_list);",
            " \tgit_diff_free(index_diff_list);",
            "-\tgit_vector_free(&staged_paths);",
            "+\tgit_vector_dispose(&staged_paths);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int merge_check_workdir(size_t *conflicts, git_repository *repo, git_index *index_new, git_vector *merged_paths)",
            " {",
            " \tgit_diff *wd_diff_list = NULL;",
            "@@ -3108,15 +3107,15 @@",
            " \tif ((conflicts = index_conflicts + wd_conflicts) > 0) {",
            " \t\tgit_error_set(GIT_ERROR_MERGE, \"%\" PRIuZ \" uncommitted change%s would be overwritten by merge\",",
            " \t\t\tconflicts, (conflicts != 1) ? \"s\" : \"\");",
            " \t\terror = GIT_ECONFLICT;",
            " \t}",
            " ",
            " done:",
            "-\tgit_vector_free(&paths);",
            "+\tgit_vector_dispose(&paths);",
            " \tgit_tree_free(head_tree);",
            " \tgit_iterator_free(iter_head);",
            " \tgit_iterator_free(iter_new);",
            " \tgit_diff_free(merged_list);",
            " ",
            " \treturn error;",
            " }",
            "@@ -3349,16 +3348,15 @@",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif ((error = git_repository__ensure_not_bare(repo, \"merge\")) < 0)",
            " \t\tgoto done;",
            " ",
            " \tcheckout_strategy = given_checkout_opts ?",
            "-\t\tgiven_checkout_opts->checkout_strategy :",
            "-\t\tGIT_CHECKOUT_SAFE;",
            "+\t\tgiven_checkout_opts->checkout_strategy : 0;",
            " ",
            " \tif ((error = git_indexwriter_init_for_operation(&indexwriter, repo,",
            " \t\t&checkout_strategy)) < 0)",
            " \t\tgoto done;",
            " ",
            " \tif ((error = git_repository_index(&repo_index, repo) < 0) ||",
            " \t    (error = git_index_read(repo_index, 0) < 0))"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/merge_driver.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/merge_driver.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/merge_driver.c",
            "@@ -214,15 +214,15 @@",
            " \t\t\tmerge_driver_name__binary, &git_merge_driver__binary)) < 0)",
            " \t\tgoto done;",
            " ",
            " \terror = git_runtime_shutdown_register(git_merge_driver_global_shutdown);",
            " ",
            " done:",
            " \tif (error < 0)",
            "-\t\tgit_vector_free_deep(&merge_driver_registry.drivers);",
            "+\t\tgit_vector_dispose_deep(&merge_driver_registry.drivers);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static void git_merge_driver_global_shutdown(void)",
            " {",
            " \tgit_merge_driver_entry *entry;",
            "@@ -234,15 +234,15 @@",
            " \tgit_vector_foreach(&merge_driver_registry.drivers, i, entry) {",
            " \t\tif (entry->driver->shutdown)",
            " \t\t\tentry->driver->shutdown(entry->driver);",
            " ",
            " \t\tgit__free(entry);",
            " \t}",
            " ",
            "-\tgit_vector_free(&merge_driver_registry.drivers);",
            "+\tgit_vector_dispose(&merge_driver_registry.drivers);",
            " ",
            " \tgit_rwlock_wrunlock(&merge_driver_registry.lock);",
            " \tgit_rwlock_free(&merge_driver_registry.lock);",
            " }",
            " ",
            " /* Note: callers must lock the registry before calling this function */",
            " static int merge_driver_registry_find(size_t *pos, const char *name)"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/midx.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/midx.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/midx.c",
            "@@ -480,15 +480,15 @@",
            " int git_midx_close(git_midx_file *idx)",
            " {",
            " \tGIT_ASSERT_ARG(idx);",
            " ",
            " \tif (idx->index_map.data)",
            " \t\tgit_futils_mmap_free(&idx->index_map);",
            " ",
            "-\tgit_vector_free(&idx->packfile_names);",
            "+\tgit_vector_dispose(&idx->packfile_names);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " void git_midx_free(git_midx_file *idx)",
            " {",
            " \tif (!idx)",
            "@@ -504,28 +504,36 @@",
            " \tconst struct git_pack_file *a = a_;",
            " \tconst struct git_pack_file *b = b_;",
            " ",
            " \treturn strcmp(a->pack_name, b->pack_name);",
            " }",
            " ",
            " int git_midx_writer_new(",
            "-\t\tgit_midx_writer **out,",
            "-\t\tconst char *pack_dir",
            "+\tgit_midx_writer **out,",
            "+\tconst char *pack_dir",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t\t, git_oid_t oid_type",
            "+\t, git_midx_writer_options *opts",
            " #endif",
            " \t\t)",
            " {",
            " \tgit_midx_writer *w;",
            "+\tgit_oid_t oid_type;",
            " ",
            "-#ifndef GIT_EXPERIMENTAL_SHA256",
            "-\tgit_oid_t oid_type = GIT_OID_SHA1;",
            "-#endif",
            "+\tGIT_ASSERT_ARG(out && pack_dir);",
            " ",
            "-\tGIT_ASSERT_ARG(out && pack_dir && oid_type);",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tGIT_ERROR_CHECK_VERSION(opts,",
            "+\t\tGIT_MIDX_WRITER_OPTIONS_VERSION,",
            "+\t\t\"git_midx_writer_options\");",
            "+",
            "+\toid_type = opts && opts->oid_type ? opts->oid_type : GIT_OID_DEFAULT;",
            "+\tGIT_ASSERT_ARG(git_oid_type_is_valid(oid_type));",
            "+#else",
            "+\toid_type = GIT_OID_SHA1;",
            "+#endif",
            " ",
            " \tw = git__calloc(1, sizeof(git_midx_writer));",
            " \tGIT_ERROR_CHECK_ALLOC(w);",
            " ",
            " \tif (git_str_sets(&w->pack_dir, pack_dir) < 0) {",
            " \t\tgit__free(w);",
            " \t\treturn -1;",
            "@@ -550,15 +558,15 @@",
            " \tsize_t i;",
            " ",
            " \tif (!w)",
            " \t\treturn;",
            " ",
            " \tgit_vector_foreach (&w->packs, i, p)",
            " \t\tgit_mwindow_put_pack(p);",
            "-\tgit_vector_free(&w->packs);",
            "+\tgit_vector_dispose(&w->packs);",
            " \tgit_str_dispose(&w->pack_dir);",
            " \tgit__free(w);",
            " }",
            " ",
            " int git_midx_writer_add(",
            " \t\tgit_midx_writer *w,",
            " \t\tconst char *idx_path)",
            "@@ -656,17 +664,19 @@",
            " };",
            " ",
            " static int midx_write_hash(const char *buf, size_t size, void *data)",
            " {",
            " \tstruct midx_write_hash_context *ctx = (struct midx_write_hash_context *)data;",
            " \tint error;",
            " ",
            "-\terror = git_hash_update(ctx->ctx, buf, size);",
            "-\tif (error < 0)",
            "-\t\treturn error;",
            "+\tif (ctx->ctx) {",
            "+\t\terror = git_hash_update(ctx->ctx, buf, size);",
            "+\t\tif (error < 0)",
            "+\t\t\treturn error;",
            "+\t}",
            " ",
            " \treturn ctx->write_cb(buf, size, ctx->cb_data);",
            " }",
            " ",
            " static int midx_write(",
            " \t\tgit_midx_writer *w,",
            " \t\tmidx_write_cb write_cb,",
            "@@ -859,21 +869,24 @@",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \t/* Finalize the checksum and write the trailer. */",
            " \terror = git_hash_final(checksum, &ctx);",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            "+",
            "+\thash_cb_data.ctx = NULL;",
            "+",
            " \terror = write_cb((char *)checksum, checksum_size, cb_data);",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            " cleanup:",
            " \tgit_array_clear(object_entries_array);",
            "-\tgit_vector_free(&object_entries);",
            "+\tgit_vector_dispose(&object_entries);",
            " \tgit_str_dispose(&packfile_names);",
            " \tgit_str_dispose(&oid_lookup);",
            " \tgit_str_dispose(&object_offsets);",
            " \tgit_str_dispose(&object_large_offsets);",
            " \tgit_hash_ctx_cleanup(&ctx);",
            " \treturn error;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/mwindow.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/mwindow.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/mwindow.c",
            "@@ -7,15 +7,14 @@",
            " ",
            " #include \"mwindow.h\"",
            " ",
            " #include \"vector.h\"",
            " #include \"futils.h\"",
            " #include \"map.h\"",
            " #include \"runtime.h\"",
            "-#include \"strmap.h\"",
            " #include \"pack.h\"",
            " ",
            " #define DEFAULT_WINDOW_SIZE \\",
            " \t(sizeof(void*) >= 8 \\",
            " \t\t? 1 * 1024 * 1024 * 1024 \\",
            " \t\t: 32 * 1024 * 1024)",
            " ",
            "@@ -25,41 +24,35 @@",
            " /* default is unlimited */",
            " #define DEFAULT_FILE_LIMIT 0",
            " ",
            " size_t git_mwindow__window_size = DEFAULT_WINDOW_SIZE;",
            " size_t git_mwindow__mapped_limit = DEFAULT_MAPPED_LIMIT;",
            " size_t git_mwindow__file_limit = DEFAULT_FILE_LIMIT;",
            " ",
            "-/* Mutex to control access to `git_mwindow__mem_ctl` and `git__pack_cache`. */",
            "-git_mutex git__mwindow_mutex;",
            "+/* Mutex to control access to `git_mwindow__mem_ctl` and `git_mwindow__pack_cache`. */",
            "+git_mutex git_mwindow__mutex;",
            " ",
            "-/* Whenever you want to read or modify this, grab `git__mwindow_mutex` */",
            "+/* Whenever you want to read or modify this, grab `git_mwindow__mutex` */",
            " git_mwindow_ctl git_mwindow__mem_ctl;",
            " ",
            " /* Global list of mwindow files, to open packs once across repos */",
            "-git_strmap *git__pack_cache = NULL;",
            "+GIT_HASHMAP_STR_FUNCTIONS(git_mwindow_packmap, , struct git_pack_file *);",
            "+git_mwindow_packmap git_mwindow__pack_cache;",
            " ",
            " static void git_mwindow_global_shutdown(void)",
            " {",
            "-\tgit_strmap *tmp = git__pack_cache;",
            "-",
            "-\tgit_mutex_free(&git__mwindow_mutex);",
            "-",
            "-\tgit__pack_cache = NULL;",
            "-\tgit_strmap_free(tmp);",
            "+\tgit_mutex_free(&git_mwindow__mutex);",
            "+\tgit_mwindow_packmap_dispose(&git_mwindow__pack_cache);",
            " }",
            " ",
            " int git_mwindow_global_init(void)",
            " {",
            " \tint error;",
            " ",
            "-\tGIT_ASSERT(!git__pack_cache);",
            "-",
            "-\tif ((error = git_mutex_init(&git__mwindow_mutex)) < 0 ||",
            "-\t    (error = git_strmap_new(&git__pack_cache)) < 0)",
            "+\tif ((error = git_mutex_init(&git_mwindow__mutex)) < 0)",
            " \t    return error;",
            " ",
            " \treturn git_runtime_shutdown_register(git_mwindow_global_shutdown);",
            " }",
            " ",
            " int git_mwindow_get_pack(",
            " \tstruct git_pack_file **out,",
            "@@ -69,76 +62,76 @@",
            " \tstruct git_pack_file *pack;",
            " \tchar *packname;",
            " \tint error;",
            " ",
            " \tif ((error = git_packfile__name(&packname, path)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tif (git_mutex_lock(&git__mwindow_mutex) < 0) {",
            "+\tif (git_mutex_lock(&git_mwindow__mutex) < 0) {",
            " \t\tgit_error_set(GIT_ERROR_OS, \"failed to lock mwindow mutex\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            "-\tpack = git_strmap_get(git__pack_cache, packname);",
            "+\terror = git_mwindow_packmap_get(&pack, &git_mwindow__pack_cache, packname);",
            " \tgit__free(packname);",
            " ",
            "-\tif (pack != NULL) {",
            "+\tif (error == 0) {",
            " \t\tgit_atomic32_inc(&pack->refcount);",
            "-\t\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\t\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \t\t*out = pack;",
            " \t\treturn 0;",
            "+\t} else if (error != GIT_ENOTFOUND) {",
            "+\t\treturn error;",
            " \t}",
            " ",
            " \t/* If we didn't find it, we need to create it */",
            " \tif ((error = git_packfile_alloc(&pack, path, oid_type)) < 0) {",
            "-\t\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\t\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \t\treturn error;",
            " \t}",
            " ",
            " \tgit_atomic32_inc(&pack->refcount);",
            " ",
            "-\terror = git_strmap_set(git__pack_cache, pack->pack_name, pack);",
            "-\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\terror = git_mwindow_packmap_put(&git_mwindow__pack_cache, pack->pack_name, pack);",
            "+\tgit_mutex_unlock(&git_mwindow__mutex);",
            "+",
            " \tif (error < 0) {",
            " \t\tgit_packfile_free(pack, false);",
            " \t\treturn error;",
            " \t}",
            " ",
            " \t*out = pack;",
            " \treturn 0;",
            " }",
            " ",
            " int git_mwindow_put_pack(struct git_pack_file *pack)",
            " {",
            " \tint count, error;",
            " \tstruct git_pack_file *pack_to_delete = NULL;",
            " ",
            "-\tif ((error = git_mutex_lock(&git__mwindow_mutex)) < 0)",
            "+\tif ((error = git_mutex_lock(&git_mwindow__mutex)) < 0)",
            " \t\treturn error;",
            " ",
            "-\t/* put before get would be a corrupted state */",
            "-\tGIT_ASSERT(git__pack_cache);",
            "-",
            " \t/* if we cannot find it, the state is corrupted */",
            "-\tGIT_ASSERT(git_strmap_exists(git__pack_cache, pack->pack_name));",
            "+\tGIT_ASSERT(git_mwindow_packmap_contains(&git_mwindow__pack_cache, pack->pack_name));",
            " ",
            " \tcount = git_atomic32_dec(&pack->refcount);",
            " \tif (count == 0) {",
            "-\t\tgit_strmap_delete(git__pack_cache, pack->pack_name);",
            "+\t\tgit_mwindow_packmap_remove(&git_mwindow__pack_cache, pack->pack_name);",
            " \t\tpack_to_delete = pack;",
            " \t}",
            "-\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \tgit_packfile_free(pack_to_delete, false);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " /*",
            "  * Free all the windows in a sequence, typically because we're done",
            "- * with the file. Needs to hold the git__mwindow_mutex.",
            "+ * with the file. Needs to hold the git_mwindow__mutex.",
            "  */",
            " static int git_mwindow_free_all_locked(git_mwindow_file *mwf)",
            " {",
            " \tgit_mwindow_ctl *ctl = &git_mwindow__mem_ctl;",
            " \tsize_t i;",
            " ",
            " \t/*",
            "@@ -148,15 +141,15 @@",
            " \t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {",
            " \t\t\tgit_vector_remove(&ctl->windowfiles, i);",
            " \t\t\tbreak;",
            " \t\t}",
            " \t}",
            " ",
            " \tif (ctl->windowfiles.length == 0) {",
            "-\t\tgit_vector_free(&ctl->windowfiles);",
            "+\t\tgit_vector_dispose(&ctl->windowfiles);",
            " \t\tctl->windowfiles.contents = NULL;",
            " \t}",
            " ",
            " \twhile (mwf->windows) {",
            " \t\tgit_mwindow *w = mwf->windows;",
            " \t\tGIT_ASSERT(w->inuse_cnt == 0);",
            " ",
            "@@ -172,22 +165,22 @@",
            " \treturn 0;",
            " }",
            " ",
            " int git_mwindow_free_all(git_mwindow_file *mwf)",
            " {",
            " \tint error;",
            " ",
            "-\tif (git_mutex_lock(&git__mwindow_mutex)) {",
            "+\tif (git_mutex_lock(&git_mwindow__mutex)) {",
            " \t\tgit_error_set(GIT_ERROR_THREAD, \"unable to lock mwindow mutex\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \terror = git_mwindow_free_all_locked(mwf);",
            " ",
            "-\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\tgit_mutex_unlock(&git_mwindow__mutex);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " /*",
            "  * Check if a window 'win' contains both the address 'offset' and 'extra'.",
            "  *",
            "@@ -401,15 +394,15 @@",
            " \toff64_t offset,",
            " \tsize_t extra,",
            " \tunsigned int *left)",
            " {",
            " \tgit_mwindow_ctl *ctl = &git_mwindow__mem_ctl;",
            " \tgit_mwindow *w = *cursor;",
            " ",
            "-\tif (git_mutex_lock(&git__mwindow_mutex)) {",
            "+\tif (git_mutex_lock(&git_mwindow__mutex)) {",
            " \t\tgit_error_set(GIT_ERROR_THREAD, \"unable to lock mwindow mutex\");",
            " \t\treturn NULL;",
            " \t}",
            " ",
            " \tif (!w || !(git_mwindow_contains(w, offset, extra))) {",
            " \t\tif (w) {",
            " \t\t\tw->inuse_cnt--;",
            "@@ -423,15 +416,15 @@",
            " \t\t/*",
            " \t\t * If there isn't a suitable window, we need to create a new",
            " \t\t * one.",
            " \t\t */",
            " \t\tif (!w) {",
            " \t\t\tw = new_window_locked(mwf->fd, mwf->size, offset);",
            " \t\t\tif (w == NULL) {",
            "-\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\t\t\t\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \t\t\t\treturn NULL;",
            " \t\t\t}",
            " \t\t\tw->next = mwf->windows;",
            " \t\t\tmwf->windows = w;",
            " \t\t}",
            " \t}",
            " ",
            "@@ -443,34 +436,34 @@",
            " \t}",
            " ",
            " \toffset -= w->offset;",
            " ",
            " \tif (left)",
            " \t\t*left = (unsigned int)(w->window_map.len - offset);",
            " ",
            "-\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \treturn (unsigned char *) w->window_map.data + offset;",
            " }",
            " ",
            " int git_mwindow_file_register(git_mwindow_file *mwf)",
            " {",
            " \tgit_vector closed_files = GIT_VECTOR_INIT;",
            " \tgit_mwindow_ctl *ctl = &git_mwindow__mem_ctl;",
            " \tint error;",
            " \tsize_t i;",
            " \tgit_mwindow_file *closed_file = NULL;",
            " ",
            "-\tif (git_mutex_lock(&git__mwindow_mutex)) {",
            "+\tif (git_mutex_lock(&git_mwindow__mutex)) {",
            " \t\tgit_error_set(GIT_ERROR_THREAD, \"unable to lock mwindow mutex\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (ctl->windowfiles.length == 0 &&",
            " \t    (error = git_vector_init(&ctl->windowfiles, 8, NULL)) < 0) {",
            "-\t\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\t\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \t\tgoto cleanup;",
            " \t}",
            " ",
            " \tif (git_mwindow__file_limit) {",
            " \t\tgit_mwindow_file *lru_file;",
            " \t\twhile (git_mwindow__file_limit <= ctl->windowfiles.length &&",
            " \t\t\t\tgit_mwindow_find_lru_file_locked(&lru_file) == 0) {",
            "@@ -482,15 +475,15 @@",
            " \t\t\t\tbreak;",
            " \t\t\t}",
            " \t\t\tgit_mwindow_free_all_locked(lru_file);",
            " \t\t}",
            " \t}",
            " ",
            " \terror = git_vector_insert(&ctl->windowfiles, mwf);",
            "-\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \t/*",
            " \t * Once we have released the global windowfiles lock, we can close each",
            " \t * individual file. Before doing so, acquire that file's lock to avoid",
            " \t * closing a file that is currently being used.",
            "@@ -501,44 +494,44 @@",
            " \t\t\tcontinue;",
            " \t\tp_close(closed_file->fd);",
            " \t\tclosed_file->fd = -1;",
            " \t\tgit_mutex_unlock(&closed_file->lock);",
            " \t}",
            " ",
            " cleanup:",
            "-\tgit_vector_free(&closed_files);",
            "+\tgit_vector_dispose(&closed_files);",
            " \treturn error;",
            " }",
            " ",
            " void git_mwindow_file_deregister(git_mwindow_file *mwf)",
            " {",
            " \tgit_mwindow_ctl *ctl = &git_mwindow__mem_ctl;",
            " \tgit_mwindow_file *cur;",
            " \tsize_t i;",
            " ",
            "-\tif (git_mutex_lock(&git__mwindow_mutex))",
            "+\tif (git_mutex_lock(&git_mwindow__mutex))",
            " \t\treturn;",
            " ",
            " \tgit_vector_foreach(&ctl->windowfiles, i, cur) {",
            " \t\tif (cur == mwf) {",
            " \t\t\tgit_vector_remove(&ctl->windowfiles, i);",
            "-\t\t\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\t\t\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \t\t\treturn;",
            " \t\t}",
            " \t}",
            "-\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\tgit_mutex_unlock(&git_mwindow__mutex);",
            " }",
            " ",
            " void git_mwindow_close(git_mwindow **window)",
            " {",
            " \tgit_mwindow *w = *window;",
            " \tif (w) {",
            "-\t\tif (git_mutex_lock(&git__mwindow_mutex)) {",
            "+\t\tif (git_mutex_lock(&git_mwindow__mutex)) {",
            " \t\t\tgit_error_set(GIT_ERROR_THREAD, \"unable to lock mwindow mutex\");",
            " \t\t\treturn;",
            " \t\t}",
            " ",
            " \t\tw->inuse_cnt--;",
            "-\t\tgit_mutex_unlock(&git__mwindow_mutex);",
            "+\t\tgit_mutex_unlock(&git_mwindow__mutex);",
            " \t\t*window = NULL;",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/mwindow.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/mwindow.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/mwindow.h",
            "@@ -8,14 +8,18 @@",
            " #ifndef INCLUDE_mwindow__",
            " #define INCLUDE_mwindow__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"map.h\"",
            " #include \"vector.h\"",
            "+#include \"hashmap_str.h\"",
            "+",
            "+GIT_HASHMAP_STR_STRUCT(git_mwindow_packmap, struct git_pack_file *);",
            "+GIT_HASHMAP_STR_PROTOTYPES(git_mwindow_packmap, struct git_pack_file *);",
            " ",
            " typedef struct git_mwindow {",
            " \tstruct git_mwindow *next;",
            " \tgit_map window_map;",
            " \toff64_t offset;",
            " \tsize_t last_used;",
            " \tsize_t inuse_cnt;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/object.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/object.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/object.c",
            "@@ -522,30 +522,31 @@",
            " ",
            " static int git_object__short_id(git_str *out, const git_object *obj)",
            " {",
            " \tgit_repository *repo;",
            " \tgit_oid id;",
            " \tgit_odb *odb;",
            " \tsize_t oid_hexsize;",
            "-\tint len = GIT_ABBREV_DEFAULT, error;",
            "+\tint len, error;",
            " ",
            " \tGIT_ASSERT_ARG(out);",
            " \tGIT_ASSERT_ARG(obj);",
            " ",
            " \trepo = git_object_owner(obj);",
            " ",
            " \tgit_oid_clear(&id, repo->oid_type);",
            " \toid_hexsize = git_oid_hexsize(repo->oid_type);",
            " ",
            "-\tif ((error = git_repository__configmap_lookup(&len, repo, GIT_CONFIGMAP_ABBREV)) < 0)",
            "+\tif ((error = git_repository__abbrev_length(&len, repo)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tif (len < 0 || (size_t)len > oid_hexsize) {",
            "-\t\tgit_error_set(GIT_ERROR_CONFIG, \"invalid oid abbreviation setting: '%d'\", len);",
            "-\t\treturn -1;",
            "+\tif ((size_t)len == oid_hexsize) {",
            "+\t\tif ((error = git_oid_cpy(&id, &obj->cached.oid)) < 0) {",
            "+\t\t\treturn error;",
            "+\t\t}",
            " \t}",
            " ",
            " \tif ((error = git_repository_odb(&odb, repo)) < 0)",
            " \t\treturn error;",
            " ",
            " \twhile ((size_t)len < oid_hexsize) {",
            " \t\t/* set up short oid */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/odb.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/odb.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/odb.c",
            "@@ -786,20 +786,16 @@",
            " \tbuffer = (char *)alternates_buf.ptr;",
            " ",
            " \t/* add each alternate as a new backend; one alternate per line */",
            " \twhile ((alternate = git__strtok(&buffer, \"\\r\\n\")) != NULL) {",
            " \t\tif (*alternate == '\\0' || *alternate == '#')",
            " \t\t\tcontinue;",
            " ",
            "-\t\t/*",
            "-\t\t * Relative path: build based on the current `objects`",
            "-\t\t * folder. However, relative paths are only allowed in",
            "-\t\t * the current repository.",
            "-\t\t */",
            "-\t\tif (*alternate == '.' && !alternate_depth) {",
            "+\t\t/* Relative path: build based on the current `objects` folder. */",
            "+\t\tif (*alternate == '.') {",
            " \t\t\tif ((result = git_str_joinpath(&alternates_path, objects_dir, alternate)) < 0)",
            " \t\t\t\tbreak;",
            " \t\t\talternate = git_str_cstr(&alternates_path);",
            " \t\t}",
            " ",
            " \t\tif ((result = git_odb__add_default_backends(odb, alternate, true, alternate_depth + 1)) < 0)",
            " \t\t\tbreak;",
            "@@ -911,15 +907,15 @@",
            " ",
            " \t\tgit__free(internal);",
            " \t}",
            " \tif (locked)",
            " \t\tgit_mutex_unlock(&db->lock);",
            " ",
            " \tgit_commit_graph_free(db->cgraph);",
            "-\tgit_vector_free(&db->backends);",
            "+\tgit_vector_dispose(&db->backends);",
            " \tgit_cache_dispose(&db->own_cache);",
            " \tgit_mutex_free(&db->lock);",
            " ",
            " \tgit__memzero(db, sizeof(*db));",
            " \tgit__free(db);",
            " }",
            " ",
            "@@ -1605,15 +1601,15 @@",
            " \t\tgit_odb_backend *b = internal->backend;",
            " \t\terror = b->foreach(b, cb, payload);",
            " \t\tif (error != 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " ",
            " cleanup:",
            "-\tgit_vector_free(&backends);",
            "+\tgit_vector_dispose(&backends);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " int git_odb_write(",
            " \tgit_oid *oid, git_odb *db, const void *data, size_t len, git_object_t type)",
            " {",
            "@@ -1792,15 +1788,16 @@",
            " }",
            " ",
            " void git_odb_stream_free(git_odb_stream *stream)",
            " {",
            " \tif (stream == NULL)",
            " \t\treturn;",
            " ",
            "-\tgit_hash_ctx_cleanup(stream->hash_ctx);",
            "+\tif (stream->hash_ctx)",
            "+\t\tgit_hash_ctx_cleanup(stream->hash_ctx);",
            " \tgit__free(stream->hash_ctx);",
            " \tstream->free(stream);",
            " }",
            " ",
            " int git_odb_open_rstream(",
            " \tgit_odb_stream **stream,",
            " \tsize_t *len,",
            "@@ -1918,15 +1915,15 @@",
            " ",
            " void git_odb_backend_data_free(git_odb_backend *backend, void *data)",
            " {",
            " \tGIT_UNUSED(backend);",
            " \tgit__free(data);",
            " }",
            " ",
            "-int git_odb_refresh(struct git_odb *db)",
            "+int git_odb_refresh(git_odb *db)",
            " {",
            " \tsize_t i;",
            " \tint error;",
            " ",
            " \tGIT_ASSERT_ARG(db);",
            " ",
            " \tif ((error = git_mutex_lock(&db->lock)) < 0) {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/odb_mempack.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/odb_mempack.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/odb_mempack.c",
            "@@ -8,15 +8,14 @@",
            " #include \"common.h\"",
            " ",
            " #include \"buf.h\"",
            " #include \"futils.h\"",
            " #include \"hash.h\"",
            " #include \"odb.h\"",
            " #include \"array.h\"",
            "-#include \"oidmap.h\"",
            " #include \"pack-objects.h\"",
            " ",
            " #include \"git2/odb_backend.h\"",
            " #include \"git2/object.h\"",
            " #include \"git2/types.h\"",
            " #include \"git2/pack.h\"",
            " #include \"git2/sys/odb_backend.h\"",
            "@@ -25,39 +24,41 @@",
            " struct memobject {",
            " \tgit_oid oid;",
            " \tsize_t len;",
            " \tgit_object_t type;",
            " \tchar data[GIT_FLEX_ARRAY];",
            " };",
            " ",
            "+GIT_HASHMAP_OID_SETUP(git_odb_mempack_oidmap, struct memobject *);",
            "+",
            " struct memory_packer_db {",
            " \tgit_odb_backend parent;",
            "-\tgit_oidmap *objects;",
            "+\tgit_odb_mempack_oidmap objects;",
            " \tgit_array_t(struct memobject *) commits;",
            " };",
            " ",
            " static int impl__write(git_odb_backend *_backend, const git_oid *oid, const void *data, size_t len, git_object_t type)",
            " {",
            " \tstruct memory_packer_db *db = (struct memory_packer_db *)_backend;",
            " \tstruct memobject *obj = NULL;",
            " \tsize_t alloc_len;",
            " ",
            "-\tif (git_oidmap_exists(db->objects, oid))",
            "+\tif (git_odb_mempack_oidmap_contains(&db->objects, oid))",
            " \t\treturn 0;",
            " ",
            " \tGIT_ERROR_CHECK_ALLOC_ADD(&alloc_len, sizeof(struct memobject), len);",
            " \tobj = git__malloc(alloc_len);",
            " \tGIT_ERROR_CHECK_ALLOC(obj);",
            " ",
            " \tmemcpy(obj->data, data, len);",
            " \tgit_oid_cpy(&obj->oid, oid);",
            " \tobj->len = len;",
            " \tobj->type = type;",
            " ",
            "-\tif (git_oidmap_set(db->objects, &obj->oid, obj) < 0)",
            "+\tif (git_odb_mempack_oidmap_put(&db->objects, &obj->oid, obj) < 0)",
            " \t\treturn -1;",
            " ",
            " \tif (type == GIT_OBJECT_COMMIT) {",
            " \t\tstruct memobject **store = git_array_alloc(db->commits);",
            " \t\tGIT_ERROR_CHECK_ALLOC(store);",
            " \t\t*store = obj;",
            " \t}",
            "@@ -65,41 +66,43 @@",
            " \treturn 0;",
            " }",
            " ",
            " static int impl__exists(git_odb_backend *backend, const git_oid *oid)",
            " {",
            " \tstruct memory_packer_db *db = (struct memory_packer_db *)backend;",
            " ",
            "-\treturn git_oidmap_exists(db->objects, oid);",
            "+\treturn git_odb_mempack_oidmap_contains(&db->objects, oid);",
            " }",
            " ",
            " static int impl__read(void **buffer_p, size_t *len_p, git_object_t *type_p, git_odb_backend *backend, const git_oid *oid)",
            " {",
            " \tstruct memory_packer_db *db = (struct memory_packer_db *)backend;",
            " \tstruct memobject *obj;",
            "+\tint error;",
            " ",
            "-\tif ((obj = git_oidmap_get(db->objects, oid)) == NULL)",
            "-\t\treturn GIT_ENOTFOUND;",
            "+\tif ((error = git_odb_mempack_oidmap_get(&obj, &db->objects, oid)) != 0)",
            "+\t\treturn error;",
            " ",
            " \t*len_p = obj->len;",
            " \t*type_p = obj->type;",
            " \t*buffer_p = git__malloc(obj->len);",
            " \tGIT_ERROR_CHECK_ALLOC(*buffer_p);",
            " ",
            " \tmemcpy(*buffer_p, obj->data, obj->len);",
            " \treturn 0;",
            " }",
            " ",
            " static int impl__read_header(size_t *len_p, git_object_t *type_p, git_odb_backend *backend, const git_oid *oid)",
            " {",
            " \tstruct memory_packer_db *db = (struct memory_packer_db *)backend;",
            " \tstruct memobject *obj;",
            "+\tint error;",
            " ",
            "-\tif ((obj = git_oidmap_get(db->objects, oid)) == NULL)",
            "-\t\treturn GIT_ENOTFOUND;",
            "+\tif ((error = git_odb_mempack_oidmap_get(&obj, &db->objects, oid)) != 0)",
            "+\t\treturn error;",
            " ",
            " \t*len_p = obj->len;",
            " \t*type_p = obj->type;",
            " \treturn 0;",
            " }",
            " ",
            " static int git_mempack__dump(",
            "@@ -128,62 +131,91 @@",
            " \terr = git_packbuilder__write_buf(pack, packbuilder);",
            " ",
            " cleanup:",
            " \tgit_packbuilder_free(packbuilder);",
            " \treturn err;",
            " }",
            " ",
            "+int git_mempack_write_thin_pack(git_odb_backend *backend, git_packbuilder *pb)",
            "+{",
            "+\tstruct memory_packer_db *db = (struct memory_packer_db *)backend;",
            "+\tconst git_oid *oid;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_INIT;",
            "+\tint err;",
            "+",
            "+\twhile (true) {",
            "+\t\terr = git_odb_mempack_oidmap_iterate(&iter, &oid, NULL, &db->objects);",
            "+",
            "+\t\tif (err == GIT_ITEROVER)",
            "+\t\t\tbreak;",
            "+\t\telse if (err != 0)",
            "+\t\t\treturn err;",
            "+",
            "+\t\terr = git_packbuilder_insert(pb, oid, NULL);",
            "+\t\tif (err != 0)",
            "+\t\t\treturn err;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            " int git_mempack_dump(",
            " \tgit_buf *pack,",
            " \tgit_repository *repo,",
            " \tgit_odb_backend *_backend)",
            " {",
            " \tGIT_BUF_WRAP_PRIVATE(pack, git_mempack__dump, repo, _backend);",
            " }",
            " ",
            " int git_mempack_reset(git_odb_backend *_backend)",
            " {",
            " \tstruct memory_packer_db *db = (struct memory_packer_db *)_backend;",
            " \tstruct memobject *object = NULL;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            "-\tgit_oidmap_foreach_value(db->objects, object, {",
            "+\twhile (git_odb_mempack_oidmap_iterate(&iter, NULL, &object, &db->objects) == 0)",
            " \t\tgit__free(object);",
            "-\t});",
            " ",
            " \tgit_array_clear(db->commits);",
            "-",
            "-\tgit_oidmap_clear(db->objects);",
            "+\tgit_odb_mempack_oidmap_clear(&db->objects);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static void impl__free(git_odb_backend *_backend)",
            " {",
            " \tstruct memory_packer_db *db = (struct memory_packer_db *)_backend;",
            " ",
            " \tgit_mempack_reset(_backend);",
            "-\tgit_oidmap_free(db->objects);",
            "+\tgit_odb_mempack_oidmap_dispose(&db->objects);",
            " \tgit__free(db);",
            " }",
            " ",
            " int git_mempack_new(git_odb_backend **out)",
            " {",
            " \tstruct memory_packer_db *db;",
            " ",
            " \tGIT_ASSERT_ARG(out);",
            " ",
            " \tdb = git__calloc(1, sizeof(struct memory_packer_db));",
            " \tGIT_ERROR_CHECK_ALLOC(db);",
            " ",
            "-\tif (git_oidmap_new(&db->objects) < 0)",
            "-\t\treturn -1;",
            "-",
            " \tdb->parent.version = GIT_ODB_BACKEND_VERSION;",
            " \tdb->parent.read = &impl__read;",
            " \tdb->parent.write = &impl__write;",
            " \tdb->parent.read_header = &impl__read_header;",
            " \tdb->parent.exists = &impl__exists;",
            " \tdb->parent.free = &impl__free;",
            " ",
            " \t*out = (git_odb_backend *)db;",
            " \treturn 0;",
            " }",
            "+",
            "+int git_mempack_object_count(size_t *out, git_odb_backend *_backend)",
            "+{",
            "+\tstruct memory_packer_db *db = (struct memory_packer_db *)_backend;",
            "+",
            "+\tGIT_ASSERT_ARG(_backend);",
            "+",
            "+\t*out = (size_t)git_odb_mempack_oidmap_size(&db->objects);",
            "+\treturn 0;",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/odb_pack.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/odb_pack.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/odb_pack.c",
            "@@ -739,18 +739,18 @@",
            " \tbackend = (struct pack_backend *)_backend;",
            " ",
            " \twritepack = git__calloc(1, sizeof(struct pack_writepack));",
            " \tGIT_ERROR_CHECK_ALLOC(writepack);",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " \topts.odb = odb;",
            "+\topts.oid_type = backend->opts.oid_type;",
            " ",
            " \terror = git_indexer_new(&writepack->indexer,",
            " \t\tbackend->pack_folder,",
            "-\t\tbackend->opts.oid_type,",
            " \t\t&opts);",
            " #else",
            " \terror = git_indexer_new(&writepack->indexer,",
            " \t\tbackend->pack_folder, 0, odb, &opts);",
            " #endif",
            " ",
            " \tif (error < 0)",
            "@@ -792,21 +792,29 @@",
            " {",
            " \tstruct pack_backend *backend;",
            " \tgit_midx_writer *w = NULL;",
            " \tstruct git_pack_file *p;",
            " \tsize_t i;",
            " \tint error = 0;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tgit_midx_writer_options midx_opts = GIT_MIDX_WRITER_OPTIONS_INIT;",
            "+#endif",
            "+",
            " \tGIT_ASSERT_ARG(_backend);",
            " ",
            " \tbackend = (struct pack_backend *)_backend;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tmidx_opts.oid_type = backend->opts.oid_type;",
            "+#endif",
            "+",
            " \terror = git_midx_writer_new(&w, backend->pack_folder",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t\t, backend->opts.oid_type",
            "+\t\t, &midx_opts",
            " #endif",
            " \t\t);",
            " ",
            " \tif (error < 0)",
            " \t\treturn error;",
            " ",
            " \tgit_vector_foreach(&backend->midx_packs, i, p) {",
            "@@ -859,16 +867,16 @@",
            " ",
            " \tgit_vector_foreach(&backend->midx_packs, i, p)",
            " \t\tgit_mwindow_put_pack(p);",
            " \tgit_vector_foreach(&backend->packs, i, p)",
            " \t\tgit_mwindow_put_pack(p);",
            " ",
            " \tgit_midx_free(backend->midx);",
            "-\tgit_vector_free(&backend->midx_packs);",
            "-\tgit_vector_free(&backend->packs);",
            "+\tgit_vector_dispose(&backend->midx_packs);",
            "+\tgit_vector_dispose(&backend->packs);",
            " \tgit__free(backend->pack_folder);",
            " \tgit__free(backend);",
            " }",
            " ",
            " static int pack_backend__alloc(",
            " \tstruct pack_backend **out,",
            " \tsize_t initial_size,",
            "@@ -879,15 +887,15 @@",
            " ",
            " \tif (git_vector_init(&backend->midx_packs, 0, NULL) < 0) {",
            " \t\tgit__free(backend);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (git_vector_init(&backend->packs, initial_size, packfile_sort__cb) < 0) {",
            "-\t\tgit_vector_free(&backend->midx_packs);",
            "+\t\tgit_vector_dispose(&backend->midx_packs);",
            " \t\tgit__free(backend);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (opts)",
            " \t\tmemcpy(&backend->opts, opts, sizeof(git_odb_backend_pack_options));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/oid.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/oid.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/oid.h",
            "@@ -62,14 +62,23 @@",
            " #endif",
            " ",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "+GIT_INLINE(bool) git_oid_type_is_valid(git_oid_t type)",
            "+{",
            "+\treturn (type == GIT_OID_SHA1",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\t     || type == GIT_OID_SHA256",
            "+#endif",
            "+\t);",
            "+}",
            "+",
            " GIT_INLINE(const char *) git_oid_type_name(git_oid_t type)",
            " {",
            " \tswitch (type) {",
            " \tcase GIT_OID_SHA1:",
            " \t\treturn \"sha1\";",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/pack-objects.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/pack-objects.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/pack-objects.c",
            "@@ -60,14 +60,17 @@",
            " ",
            " /* The minimal interval between progress updates (in seconds). */",
            " #define MIN_PROGRESS_UPDATE_INTERVAL 0.5",
            " ",
            " /* Size of the buffer to feed to zlib */",
            " #define COMPRESS_BUFLEN (1024 * 1024)",
            " ",
            "+GIT_HASHMAP_OID_FUNCTIONS(git_packbuilder_pobjectmap, GIT_HASHMAP_INLINE, git_pobject *);",
            "+GIT_HASHMAP_OID_FUNCTIONS(git_packbuilder_walk_objectmap, GIT_HASHMAP_INLINE, struct walk_object *);",
            "+",
            " static unsigned name_hash(const char *name)",
            " {",
            " \tunsigned c, hash = 0;",
            " ",
            " \tif (!name)",
            " \t\treturn 0;",
            " ",
            "@@ -135,17 +138,15 @@",
            " \tGIT_ERROR_CHECK_ALLOC(pb);",
            " ",
            " \tpb->oid_type = repo->oid_type;",
            " ",
            " \thash_algorithm = git_oid_algorithm(pb->oid_type);",
            " \tGIT_ASSERT(hash_algorithm);",
            " ",
            "-\tif (git_oidmap_new(&pb->object_ix) < 0 ||",
            "-\t    git_oidmap_new(&pb->walk_objects) < 0 ||",
            "-\t    git_pool_init(&pb->object_pool, sizeof(struct walk_object)) < 0)",
            "+\tif (git_pool_init(&pb->object_pool, sizeof(struct walk_object)) < 0)",
            " \t\tgoto on_error;",
            " ",
            " \tpb->repo = repo;",
            " \tpb->nr_threads = 1; /* do not spawn any thread by default */",
            " ",
            " \tif (git_hash_ctx_init(&pb->ctx, hash_algorithm) < 0 ||",
            " \t\tgit_zstream_init(&pb->zstream, GIT_ZSTREAM_DEFLATE) < 0 ||",
            "@@ -188,18 +189,18 @@",
            " }",
            " ",
            " static int rehash(git_packbuilder *pb)",
            " {",
            " \tgit_pobject *po;",
            " \tsize_t i;",
            " ",
            "-\tgit_oidmap_clear(pb->object_ix);",
            "+\tgit_packbuilder_pobjectmap_clear(&pb->object_ix);",
            " ",
            " \tfor (i = 0, po = pb->object_list; i < pb->nr_objects; i++, po++) {",
            "-\t\tif (git_oidmap_set(pb->object_ix, &po->id, po) < 0)",
            "+\t\tif (git_packbuilder_pobjectmap_put(&pb->object_ix, &po->id, po) < 0)",
            " \t\t\treturn -1;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " int git_packbuilder_insert(git_packbuilder *pb, const git_oid *oid,",
            "@@ -210,15 +211,15 @@",
            " \tint ret;",
            " ",
            " \tGIT_ASSERT_ARG(pb);",
            " \tGIT_ASSERT_ARG(oid);",
            " ",
            " \t/* If the object already exists in the hash table, then we don't",
            " \t * have any work to do */",
            "-\tif (git_oidmap_exists(pb->object_ix, oid))",
            "+\tif (git_packbuilder_pobjectmap_contains(&pb->object_ix, oid))",
            " \t\treturn 0;",
            " ",
            " \tif (pb->nr_objects >= pb->nr_alloc) {",
            " \t\tGIT_ERROR_CHECK_ALLOC_ADD(&newsize, pb->nr_alloc, 1024);",
            " \t\tGIT_ERROR_CHECK_ALLOC_MULTIPLY(&newsize, newsize / 2, 3);",
            " ",
            " \t\tif (!git__is_uint32(newsize)) {",
            "@@ -242,15 +243,15 @@",
            " \tif ((ret = git_odb_read_header(&po->size, &po->type, pb->odb, oid)) < 0)",
            " \t\treturn ret;",
            " ",
            " \tpb->nr_objects++;",
            " \tgit_oid_cpy(&po->id, oid);",
            " \tpo->hash = name_hash(name);",
            " ",
            "-\tif (git_oidmap_set(pb->object_ix, &po->id, po) < 0) {",
            "+\tif (git_packbuilder_pobjectmap_put(&pb->object_ix, &po->id, po) < 0) {",
            " \t\tgit_error_set_oom();",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tpb->done = false;",
            " ",
            " \tif (pb->progress_cb) {",
            "@@ -511,15 +512,15 @@",
            " static int cb_tag_foreach(const char *name, git_oid *oid, void *data)",
            " {",
            " \tgit_packbuilder *pb = data;",
            " \tgit_pobject *po;",
            " ",
            " \tGIT_UNUSED(name);",
            " ",
            "-\tif ((po = git_oidmap_get(pb->object_ix, oid)) == NULL)",
            "+\tif (git_packbuilder_pobjectmap_get(&po, &pb->object_ix, oid) != 0)",
            " \t\treturn 0;",
            " ",
            " \tpo->tagged = 1;",
            " ",
            " \t/* TODO: peel objects */",
            " ",
            " \treturn 0;",
            "@@ -928,27 +929,32 @@",
            " }",
            " ",
            " static int report_delta_progress(",
            " \tgit_packbuilder *pb, uint32_t count, bool force)",
            " {",
            " \tint ret;",
            " ",
            "+\tif (pb->failure)",
            "+\t\treturn pb->failure;",
            "+",
            " \tif (pb->progress_cb) {",
            " \t\tuint64_t current_time = git_time_monotonic();",
            " \t\tuint64_t elapsed = current_time - pb->last_progress_report_time;",
            " ",
            " \t\tif (force || elapsed >= MIN_PROGRESS_UPDATE_INTERVAL) {",
            " \t\t\tpb->last_progress_report_time = current_time;",
            " ",
            " \t\t\tret = pb->progress_cb(",
            " \t\t\t\tGIT_PACKBUILDER_DELTAFICATION,",
            " \t\t\t\tcount, pb->nr_objects, pb->progress_cb_payload);",
            " ",
            "-\t\t\tif (ret)",
            "+\t\t\tif (ret) {",
            "+\t\t\t\tpb->failure = ret;",
            " \t\t\t\treturn git_error_set_after_callback(ret);",
            "+\t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int find_deltas(git_packbuilder *pb, git_pobject **list,",
            "@@ -972,15 +978,18 @@",
            " \t\tGIT_ASSERT(git_packbuilder__progress_lock(pb) == 0);",
            " \t\tif (!*list_size) {",
            " \t\t\tGIT_ASSERT(git_packbuilder__progress_unlock(pb) == 0);",
            " \t\t\tbreak;",
            " \t\t}",
            " ",
            " \t\tpb->nr_deltified += 1;",
            "-\t\treport_delta_progress(pb, pb->nr_deltified, false);",
            "+\t\tif ((error = report_delta_progress(pb, pb->nr_deltified, false)) < 0) {",
            "+\t\t\t\tGIT_ASSERT(git_packbuilder__progress_unlock(pb) == 0);",
            "+\t\t\t\tgoto on_error;",
            "+\t\t}",
            " ",
            " \t\tpo = *list++;",
            " \t\t(*list_size)--;",
            " \t\tGIT_ASSERT(git_packbuilder__progress_unlock(pb) == 0);",
            " ",
            " \t\tmem_usage -= free_unpacked(n);",
            " \t\tn->object = po;",
            "@@ -1120,24 +1129,33 @@",
            " \tsize_t list_size;",
            " \tsize_t remaining;",
            " ",
            " \tsize_t window;",
            " \tsize_t depth;",
            " \tsize_t working;",
            " \tsize_t data_ready;",
            "+",
            "+\t/* A pb->progress_cb can stop the packing process by returning an error.",
            "+\t   When that happens, all threads observe the error and stop voluntarily. */",
            "+\tbool stopped;",
            " };",
            " ",
            " static void *threaded_find_deltas(void *arg)",
            " {",
            " \tstruct thread_params *me = arg;",
            " ",
            " \twhile (me->remaining) {",
            " \t\tif (find_deltas(me->pb, me->list, &me->remaining,",
            " \t\t\t\tme->window, me->depth) < 0) {",
            "-\t\t\t; /* TODO */",
            "+\t\t\tme->stopped = true;",
            "+\t\t\tGIT_ASSERT_WITH_RETVAL(git_packbuilder__progress_lock(me->pb) == 0, NULL);",
            "+\t\t\tme->working = false;",
            "+\t\t\tgit_cond_signal(&me->pb->progress_cond);",
            "+\t\t\tGIT_ASSERT_WITH_RETVAL(git_packbuilder__progress_unlock(me->pb) == 0, NULL);",
            "+\t\t\treturn NULL;",
            " \t\t}",
            " ",
            " \t\tGIT_ASSERT_WITH_RETVAL(git_packbuilder__progress_lock(me->pb) == 0, NULL);",
            " \t\tme->working = 0;",
            " \t\tgit_cond_signal(&me->pb->progress_cond);",
            " \t\tGIT_ASSERT_WITH_RETVAL(git_packbuilder__progress_unlock(me->pb) == 0, NULL);",
            " ",
            "@@ -1171,16 +1189,15 @@",
            " \tsize_t i;",
            " \tint ret, active_threads = 0;",
            " ",
            " \tif (!pb->nr_threads)",
            " \t\tpb->nr_threads = git__online_cpus();",
            " ",
            " \tif (pb->nr_threads <= 1) {",
            "-\t\tfind_deltas(pb, list, &list_size, window, depth);",
            "-\t\treturn 0;",
            "+\t\treturn find_deltas(pb, list, &list_size, window, depth);",
            " \t}",
            " ",
            " \tp = git__mallocarray(pb->nr_threads, sizeof(*p));",
            " \tGIT_ERROR_CHECK_ALLOC(p);",
            " ",
            " \t/* Partition the work among the threads */",
            " \tfor (i = 0; i < pb->nr_threads; ++i) {",
            "@@ -1191,14 +1208,15 @@",
            " \t\t\tsub_size = 0;",
            " ",
            " \t\tp[i].pb = pb;",
            " \t\tp[i].window = window;",
            " \t\tp[i].depth = depth;",
            " \t\tp[i].working = 1;",
            " \t\tp[i].data_ready = 0;",
            "+\t\tp[i].stopped = 0;",
            " ",
            " \t\t/* try to split chunks on \"path\" boundaries */",
            " \t\twhile (sub_size && sub_size < list_size &&",
            " \t\t       list[sub_size]->hash &&",
            " \t\t       list[sub_size]->hash == list[sub_size-1]->hash)",
            " \t\t\tsub_size++;",
            " ",
            "@@ -1258,15 +1276,15 @@",
            " \t\t * a thread to receive more work. We still need to locate a",
            " \t\t * thread from which to steal work (the victim). */",
            " \t\tfor (i = 0; i < pb->nr_threads; i++)",
            " \t\t\tif (p[i].remaining > 2*window &&",
            " \t\t\t    (!victim || victim->remaining < p[i].remaining))",
            " \t\t\t\tvictim = &p[i];",
            " ",
            "-\t\tif (victim) {",
            "+\t\tif (victim && !target->stopped) {",
            " \t\t\tsub_size = victim->remaining / 2;",
            " \t\t\tlist = victim->list + victim->list_size - sub_size;",
            " \t\t\twhile (sub_size && list[0]->hash &&",
            " \t\t\t       list[0]->hash == list[-1]->hash) {",
            " \t\t\t\tlist++;",
            " \t\t\t\tsub_size--;",
            " \t\t\t}",
            "@@ -1282,57 +1300,60 @@",
            " \t\t\t}",
            " \t\t\ttarget->list = list;",
            " \t\t\tvictim->list_size -= sub_size;",
            " \t\t\tvictim->remaining -= sub_size;",
            " \t\t}",
            " \t\ttarget->list_size = sub_size;",
            " \t\ttarget->remaining = sub_size;",
            "-\t\ttarget->working = 1;",
            "+\t\ttarget->working = 1; /* even when target->stopped, so that we don't process this thread again */",
            " \t\tGIT_ASSERT(git_packbuilder__progress_unlock(pb) == 0);",
            " ",
            " \t\tif (git_mutex_lock(&target->mutex)) {",
            " \t\t\tgit_error_set(GIT_ERROR_THREAD, \"unable to lock packfile condition mutex\");",
            " \t\t\tgit__free(p);",
            " \t\t\treturn -1;",
            " \t\t}",
            " ",
            " \t\ttarget->data_ready = 1;",
            " \t\tgit_cond_signal(&target->cond);",
            " \t\tgit_mutex_unlock(&target->mutex);",
            " ",
            "-\t\tif (!sub_size) {",
            "+\t\tif (target->stopped || !sub_size) {",
            " \t\t\tgit_thread_join(&target->thread, NULL);",
            " \t\t\tgit_cond_free(&target->cond);",
            " \t\t\tgit_mutex_free(&target->mutex);",
            " \t\t\tactive_threads--;",
            " \t\t}",
            " \t}",
            " ",
            " \tgit__free(p);",
            "-\treturn 0;",
            "+\treturn pb->failure;",
            " }",
            " ",
            " #else",
            " #define ll_find_deltas(pb, l, ls, w, d) find_deltas(pb, l, &ls, w, d)",
            " #endif",
            " ",
            " int git_packbuilder__prepare(git_packbuilder *pb)",
            " {",
            " \tgit_pobject **delta_list;",
            " \tsize_t i, n = 0;",
            "+\tint error;",
            " ",
            " \tif (pb->nr_objects == 0 || pb->done)",
            " \t\treturn 0; /* nothing to do */",
            " ",
            " \t/*",
            " \t * Although we do not report progress during deltafication, we",
            " \t * at least report that we are in the deltafication stage",
            " \t */",
            "-\tif (pb->progress_cb)",
            "-\t\t\tpb->progress_cb(GIT_PACKBUILDER_DELTAFICATION, 0, pb->nr_objects, pb->progress_cb_payload);",
            "+\tif (pb->progress_cb) {",
            "+\t\tif ((error = pb->progress_cb(GIT_PACKBUILDER_DELTAFICATION, 0, pb->nr_objects, pb->progress_cb_payload)) < 0)",
            "+\t\t\treturn git_error_set_after_callback(error);",
            "+\t}",
            " ",
            " \tdelta_list = git__mallocarray(pb->nr_objects, sizeof(*delta_list));",
            " \tGIT_ERROR_CHECK_ALLOC(delta_list);",
            " ",
            " \tfor (i = 0; i < pb->nr_objects; ++i) {",
            " \t\tgit_pobject *po = pb->object_list + i;",
            " ",
            "@@ -1341,39 +1362,41 @@",
            " \t\t\tcontinue;",
            " ",
            " \t\tdelta_list[n++] = po;",
            " \t}",
            " ",
            " \tif (n > 1) {",
            " \t\tgit__tsort((void **)delta_list, n, type_size_sort);",
            "-\t\tif (ll_find_deltas(pb, delta_list, n,",
            "+\t\tif ((error = ll_find_deltas(pb, delta_list, n,",
            " \t\t\t\t   GIT_PACK_WINDOW + 1,",
            "-\t\t\t\t   GIT_PACK_DEPTH) < 0) {",
            "+\t\t\t\t   GIT_PACK_DEPTH)) < 0) {",
            " \t\t\tgit__free(delta_list);",
            "-\t\t\treturn -1;",
            "+\t\t\treturn error;",
            " \t\t}",
            " \t}",
            " ",
            "-\treport_delta_progress(pb, pb->nr_objects, true);",
            "+\terror = report_delta_progress(pb, pb->nr_objects, true);",
            " ",
            " \tpb->done = true;",
            " \tgit__free(delta_list);",
            "-\treturn 0;",
            "+\treturn error;",
            " }",
            " ",
            "-#define PREPARE_PACK if (git_packbuilder__prepare(pb) < 0) { return -1; }",
            "+#define PREPARE_PACK error = git_packbuilder__prepare(pb); if (error < 0) { return error; }",
            " ",
            " int git_packbuilder_foreach(git_packbuilder *pb, int (*cb)(void *buf, size_t size, void *payload), void *payload)",
            " {",
            "+\tint error;",
            " \tPREPARE_PACK;",
            " \treturn write_pack(pb, cb, payload);",
            " }",
            " ",
            " int git_packbuilder__write_buf(git_str *buf, git_packbuilder *pb)",
            " {",
            "+\tint error;",
            " \tPREPARE_PACK;",
            " ",
            " \treturn write_pack(pb, &write_pack_buf, buf);",
            " }",
            " ",
            " int git_packbuilder_write_buf(git_buf *buf, git_packbuilder *pb)",
            " {",
            "@@ -1415,16 +1438,17 @@",
            " \topts.progress_cb_payload = progress_cb_payload;",
            " ",
            " \t/* TODO: SHA256 */",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " \topts.mode = mode;",
            " \topts.odb = pb->odb;",
            "+\topts.oid_type = GIT_OID_SHA1;",
            " ",
            "-\terror = git_indexer_new(&indexer, path, GIT_OID_SHA1, &opts);",
            "+\terror = git_indexer_new(&indexer, path, &opts);",
            " #else",
            " \terror = git_indexer_new(&indexer, path, mode, pb->odb, &opts);",
            " #endif",
            " ",
            " \tif (error < 0)",
            " \t\tgoto cleanup;",
            " ",
            "@@ -1580,20 +1604,24 @@",
            " }",
            " ",
            " static int retrieve_object(struct walk_object **out, git_packbuilder *pb, const git_oid *id)",
            " {",
            " \tstruct walk_object *obj;",
            " \tint error;",
            " ",
            "-\tif ((obj = git_oidmap_get(pb->walk_objects, id)) == NULL) {",
            "+\terror = git_packbuilder_walk_objectmap_get(&obj, &pb->walk_objects, id);",
            "+",
            "+\tif (error == GIT_ENOTFOUND) {",
            " \t\tif ((error = lookup_walk_object(&obj, pb, id)) < 0)",
            " \t\t\treturn error;",
            " ",
            "-\t\tif ((error = git_oidmap_set(pb->walk_objects, &obj->id, obj)) < 0)",
            "+\t\tif ((error = git_packbuilder_walk_objectmap_put(&pb->walk_objects, &obj->id, obj)) < 0)",
            " \t\t\treturn error;",
            "+\t} else if (error != 0) {",
            "+\t\treturn error;",
            " \t}",
            " ",
            " \t*out = obj;",
            " \treturn 0;",
            " }",
            " ",
            " static int mark_blob_uninteresting(git_packbuilder *pb, const git_oid *id)",
            "@@ -1817,21 +1845,20 @@",
            " \tgit_cond_free(&pb->progress_cond);",
            " ",
            " #endif",
            " ",
            " \tif (pb->odb)",
            " \t\tgit_odb_free(pb->odb);",
            " ",
            "-\tif (pb->object_ix)",
            "-\t\tgit_oidmap_free(pb->object_ix);",
            "+\tgit_packbuilder_pobjectmap_dispose(&pb->object_ix);",
            " ",
            " \tif (pb->object_list)",
            " \t\tgit__free(pb->object_list);",
            " ",
            "-\tgit_oidmap_free(pb->walk_objects);",
            "+\tgit_packbuilder_walk_objectmap_dispose(&pb->walk_objects);",
            " \tgit_pool_clear(&pb->object_pool);",
            " ",
            " \tgit_hash_ctx_cleanup(&pb->ctx);",
            " \tgit_zstream_free(&pb->zstream);",
            " ",
            " \tgit__free(pb->pack_name);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/pack-objects.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/pack-objects.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/pack-objects.h",
            "@@ -8,18 +8,18 @@",
            " #ifndef INCLUDE_pack_objects_h__",
            " #define INCLUDE_pack_objects_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"str.h\"",
            " #include \"hash.h\"",
            "-#include \"oidmap.h\"",
            " #include \"zstream.h\"",
            " #include \"pool.h\"",
            " #include \"indexer.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            " #include \"git2/oid.h\"",
            " #include \"git2/pack.h\"",
            " ",
            " #define GIT_PACK_WINDOW 10 /* number of objects to possibly delta against */",
            " #define GIT_PACK_DEPTH 50 /* max delta depth */",
            " #define GIT_PACK_DELTA_CACHE_SIZE (256 * 1024 * 1024)",
            "@@ -47,14 +47,19 @@",
            " ",
            " \tunsigned int written:1,",
            " \t             recursing:1,",
            " \t             tagged:1,",
            " \t             filled:1;",
            " } git_pobject;",
            " ",
            "+typedef struct walk_object walk_object;",
            "+",
            "+GIT_HASHMAP_OID_STRUCT(git_packbuilder_pobjectmap, git_pobject *);",
            "+GIT_HASHMAP_OID_STRUCT(git_packbuilder_walk_objectmap, walk_object *);",
            "+",
            " struct git_packbuilder {",
            " \tgit_repository *repo; /* associated repository */",
            " \tgit_odb *odb; /* associated object database */",
            " ",
            " \tgit_oid_t oid_type;",
            " ",
            " \tgit_hash_ctx ctx;",
            "@@ -65,17 +70,16 @@",
            " \t\tnr_written,",
            " \t\tnr_remaining;",
            " ",
            " \tsize_t nr_alloc;",
            " ",
            " \tgit_pobject *object_list;",
            " ",
            "-\tgit_oidmap *object_ix;",
            "-",
            "-\tgit_oidmap *walk_objects;",
            "+\tgit_packbuilder_pobjectmap object_ix;",
            "+\tgit_packbuilder_walk_objectmap walk_objects;",
            " \tgit_pool object_pool;",
            " ",
            " #ifndef GIT_DEPRECATE_HARD",
            " \tgit_oid pack_oid; /* hash of written pack */",
            " #endif",
            " \tchar *pack_name; /* name of written pack */",
            " ",
            "@@ -96,14 +100,18 @@",
            " \tgit_packbuilder_progress progress_cb;",
            " \tvoid *progress_cb_payload;",
            " ",
            " \t/* the time progress was last reported, in millisecond ticks */",
            " \tuint64_t last_progress_report_time;",
            " ",
            " \tbool done;",
            "+",
            "+\t/* A non-zero error code in failure causes all threads to shut themselves",
            "+\t   down. Some functions will return this error code.  */",
            "+\tvolatile int failure;",
            " };",
            " ",
            " int git_packbuilder__write_buf(git_str *buf, git_packbuilder *pb);",
            " int git_packbuilder__prepare(git_packbuilder *pb);",
            " ",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/pack.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/pack.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/pack.c",
            "@@ -9,14 +9,15 @@",
            " ",
            " #include \"delta.h\"",
            " #include \"futils.h\"",
            " #include \"mwindow.h\"",
            " #include \"odb.h\"",
            " #include \"oid.h\"",
            " #include \"oidarray.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            " /* Option to bypass checking existence of '.keep' files */",
            " bool git_disable_pack_keep_file_checks = false;",
            " ",
            " static int packfile_open_locked(struct git_pack_file *p);",
            " static off64_t nth_packed_object_offset_locked(struct git_pack_file *p, uint32_t n);",
            " static int packfile_unpack_compressed(",
            "@@ -37,14 +38,20 @@",
            " static int pack_entry_find_offset(",
            " \t\toff64_t *offset_out,",
            " \t\tgit_oid *found_oid,",
            " \t\tstruct git_pack_file *p,",
            " \t\tconst git_oid *short_oid,",
            " \t\tsize_t len);",
            " ",
            "+#define off64_hash(key) (uint32_t)((key)>>33^(key)^(key)<<11)",
            "+#define off64_equal(a, b) ((a) == (b))",
            "+",
            "+GIT_HASHMAP_FUNCTIONS(git_pack_offsetmap, GIT_HASHMAP_INLINE, off64_t, git_pack_cache_entry *, off64_hash, off64_equal);",
            "+GIT_HASHMAP_OID_FUNCTIONS(git_pack_oidmap, , struct git_pack_entry *);",
            "+",
            " static int packfile_error(const char *message)",
            " {",
            " \tgit_error_set(GIT_ERROR_ODB, \"invalid pack file - %s\", message);",
            " \treturn -1;",
            " }",
            " ",
            " /********************",
            "@@ -71,74 +78,66 @@",
            " \t\tgit__free(e->raw.data);",
            " \t\tgit__free(e);",
            " \t}",
            " }",
            " ",
            " static void cache_free(git_pack_cache *cache)",
            " {",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tgit_pack_cache_entry *entry;",
            " ",
            "-\tif (cache->entries) {",
            "-\t\tgit_offmap_foreach_value(cache->entries, entry, {",
            "-\t\t\tfree_cache_object(entry);",
            "-\t\t});",
            "+\twhile (git_pack_offsetmap_iterate(&iter, NULL, &entry, &cache->entries) == 0)",
            "+\t\tfree_cache_object(entry);",
            " ",
            "-\t\tgit_offmap_free(cache->entries);",
            "-\t\tcache->entries = NULL;",
            "-\t}",
            "+\tgit_pack_offsetmap_dispose(&cache->entries);",
            " }",
            " ",
            " static int cache_init(git_pack_cache *cache)",
            " {",
            "-\tif (git_offmap_new(&cache->entries) < 0)",
            "-\t\treturn -1;",
            "-",
            " \tcache->memory_limit = GIT_PACK_CACHE_MEMORY_LIMIT;",
            " ",
            " \tif (git_mutex_init(&cache->lock)) {",
            " \t\tgit_error_set(GIT_ERROR_OS, \"failed to initialize pack cache mutex\");",
            "-",
            "-\t\tgit__free(cache->entries);",
            "-\t\tcache->entries = NULL;",
            "-",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static git_pack_cache_entry *cache_get(git_pack_cache *cache, off64_t offset)",
            " {",
            "-\tgit_pack_cache_entry *entry;",
            "+\tgit_pack_cache_entry *entry = NULL;",
            " ",
            " \tif (git_mutex_lock(&cache->lock) < 0)",
            " \t\treturn NULL;",
            " ",
            "-\tif ((entry = git_offmap_get(cache->entries, offset)) != NULL) {",
            "+\tif (git_pack_offsetmap_get(&entry, &cache->entries, offset) == 0) {",
            " \t\tgit_atomic32_inc(&entry->refcount);",
            " \t\tentry->last_usage = cache->use_ctr++;",
            " \t}",
            "+",
            " \tgit_mutex_unlock(&cache->lock);",
            " ",
            " \treturn entry;",
            " }",
            " ",
            " /* Run with the cache lock held */",
            " static void free_lowest_entry(git_pack_cache *cache)",
            " {",
            "-\toff64_t offset;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tgit_pack_cache_entry *entry;",
            "+\toff64_t offset;",
            " ",
            "-\tgit_offmap_foreach(cache->entries, offset, entry, {",
            "+\twhile (git_pack_offsetmap_iterate(&iter, &offset, &entry, &cache->entries) == 0) {",
            " \t\tif (entry && git_atomic32_get(&entry->refcount) == 0) {",
            " \t\t\tcache->memory_used -= entry->raw.len;",
            "-\t\t\tgit_offmap_delete(cache->entries, offset);",
            "+\t\t\tgit_pack_offsetmap_remove(&cache->entries, offset);",
            " \t\t\tfree_cache_object(entry);",
            " \t\t}",
            "-\t});",
            "+\t}",
            " }",
            " ",
            " static int cache_add(",
            " \t\tgit_pack_cache_entry **cached_out,",
            " \t\tgit_pack_cache *cache,",
            " \t\tgit_rawobj *base,",
            " \t\toff64_t offset)",
            "@@ -153,20 +152,20 @@",
            " \tif (entry) {",
            " \t\tif (git_mutex_lock(&cache->lock) < 0) {",
            " \t\t\tgit_error_set(GIT_ERROR_OS, \"failed to lock cache\");",
            " \t\t\tgit__free(entry);",
            " \t\t\treturn -1;",
            " \t\t}",
            " \t\t/* Add it to the cache if nobody else has */",
            "-\t\texists = git_offmap_exists(cache->entries, offset);",
            "+\t\texists = git_pack_offsetmap_contains(&cache->entries, offset);",
            " \t\tif (!exists) {",
            " \t\t\twhile (cache->memory_used + base->len > cache->memory_limit)",
            " \t\t\t\tfree_lowest_entry(cache);",
            " ",
            "-\t\t\tgit_offmap_set(cache->entries, offset, entry);",
            "+\t\t\tgit_pack_offsetmap_put(&cache->entries, offset, entry);",
            " \t\t\tcache->memory_used += entry->raw.len;",
            " ",
            " \t\t\t*cached_out = entry;",
            " \t\t}",
            " \t\tgit_mutex_unlock(&cache->lock);",
            " \t\t/* Somebody beat us to adding it into the cache */",
            " \t\tif (exists) {",
            "@@ -1005,15 +1004,15 @@",
            " \t\tgit_oid base_oid;",
            " \t\tgit_oid__fromraw(&base_oid, base_info, p->oid_type);",
            " ",
            " \t\t/* If we have the cooperative cache, search in it first */",
            " \t\tif (p->has_cache) {",
            " \t\t\tstruct git_pack_entry *entry;",
            " ",
            "-\t\t\tif ((entry = git_oidmap_get(p->idx_cache, &base_oid)) != NULL) {",
            "+\t\t\tif (git_pack_oidmap_get(&entry, &p->idx_cache, &base_oid) == 0) {",
            " \t\t\t\tif (entry->offset == 0)",
            " \t\t\t\t\treturn packfile_error(\"delta offset is zero\");",
            " ",
            " \t\t\t\t*curpos += p->oid_size;",
            " \t\t\t\t*delta_base_out = entry->offset;",
            " \t\t\t\treturn 0;",
            " \t\t\t} else {",
            "@@ -1347,15 +1346,15 @@",
            " \t\t\tfor (i = 0; i < p->num_objects; i++)",
            " \t\t\t\tgit_vector_insert(&offsets, (void*)&index[(p->oid_size + 4) * i]);",
            " \t\t\tgit_vector_sort(&offsets);",
            " \t\t\tgit_vector_foreach(&offsets, i, current)",
            " \t\t\t\tgit_vector_insert(&oids, (void*)&current[4]);",
            " \t\t}",
            " ",
            "-\t\tgit_vector_free(&offsets);",
            "+\t\tgit_vector_dispose(&offsets);",
            " \t\tp->ids = (unsigned char **)git_vector_detach(NULL, NULL, &oids);",
            " \t}",
            " ",
            " \t/*",
            " \t * We need to copy the OIDs to another array before we",
            " \t * relinquish the lock to avoid races.  We can also take",
            " \t * this opportunity to put them into normal form."
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/pack.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/pack.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/pack.h",
            "@@ -12,18 +12,17 @@",
            " ",
            " #include \"git2/oid.h\"",
            " ",
            " #include \"array.h\"",
            " #include \"map.h\"",
            " #include \"mwindow.h\"",
            " #include \"odb.h\"",
            "-#include \"offmap.h\"",
            "-#include \"oidmap.h\"",
            " #include \"zstream.h\"",
            " #include \"oid.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            " /**",
            "  * Function type for callbacks from git_pack_foreach_entry_offset.",
            "  */",
            " typedef int git_pack_foreach_entry_offset_cb(",
            " \t\tconst git_oid *id,",
            " \t\toff64_t offset,",
            "@@ -79,20 +78,31 @@",
            " };",
            " ",
            " typedef git_array_t(struct pack_chain_elem) git_dependency_chain;",
            " ",
            " #define GIT_PACK_CACHE_MEMORY_LIMIT 16 * 1024 * 1024",
            " #define GIT_PACK_CACHE_SIZE_LIMIT 1024 * 1024 /* don't bother caching anything over 1MB */",
            " ",
            "+struct git_pack_entry {",
            "+\toff64_t offset;",
            "+\tgit_oid id;",
            "+\tstruct git_pack_file *p;",
            "+};",
            "+",
            "+GIT_HASHMAP_STRUCT(git_pack_offsetmap, off64_t, git_pack_cache_entry *);",
            "+",
            "+GIT_HASHMAP_OID_STRUCT(git_pack_oidmap, struct git_pack_entry *);",
            "+GIT_HASHMAP_OID_PROTOTYPES(git_pack_oidmap, struct git_pack_entry *);",
            "+",
            " typedef struct {",
            " \tsize_t memory_used;",
            " \tsize_t memory_limit;",
            " \tsize_t use_ctr;",
            " \tgit_mutex lock;",
            "-\tgit_offmap *entries;",
            "+\tgit_pack_offsetmap entries;",
            " } git_pack_cache;",
            " ",
            " struct git_pack_file {",
            " \tgit_mwindow_file mwf;",
            " \tgit_map index_map;",
            " \tgit_mutex lock; /* protect updates to index_map */",
            " \tgit_atomic32 refcount;",
            "@@ -106,15 +116,16 @@",
            " \t         oid_size:6,",
            " \t         pack_local:1,",
            " \t         pack_keep:1,",
            " \t\t has_cache:1;",
            " ",
            " \tint index_version;",
            " \tgit_time_t mtime;",
            "-\tgit_oidmap *idx_cache;",
            "+",
            "+\tgit_pack_oidmap idx_cache;",
            " \tunsigned char **ids;",
            " ",
            " \tgit_pack_cache bases; /* delta base cache */",
            " ",
            " \ttime_t last_freshen; /* last time the packfile was freshened */",
            " ",
            " \t/* something like \".git/objects/pack/xxxxx.pack\" */",
            "@@ -135,20 +146,14 @@",
            " \tconst void *id_lookup_table,",
            " \tsize_t stride,",
            " \tunsigned lo,",
            " \tunsigned hi,",
            " \tconst unsigned char *id_prefix,",
            " \tconst git_oid_t oid_type);",
            " ",
            "-struct git_pack_entry {",
            "-\toff64_t offset;",
            "-\tgit_oid id;",
            "-\tstruct git_pack_file *p;",
            "-};",
            "-",
            " typedef struct git_packfile_stream {",
            " \toff64_t curpos;",
            " \tint done;",
            " \tgit_zstream zstream;",
            " \tstruct git_pack_file *p;",
            " \tgit_mwindow *mw;",
            " } git_packfile_stream;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/pathspec.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/pathspec.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/pathspec.c",
            "@@ -101,15 +101,15 @@",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " /* free data from the pathspec vector */",
            " void git_pathspec__vfree(git_vector *vspec)",
            " {",
            "-\tgit_vector_free_deep(vspec);",
            "+\tgit_vector_dispose_deep(vspec);",
            " }",
            " ",
            " struct pathspec_match_context {",
            " \tint wildmatch_flags;",
            " \tint (*strcomp)(const char *, const char *);",
            " \tint (*strncomp)(const char *, const char *, size_t);",
            " };"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/push.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/push.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/push.c",
            "@@ -52,30 +52,30 @@",
            " ",
            " \tif (git_vector_init(&p->specs, 0, push_spec_rref_cmp) < 0) {",
            " \t\tgit__free(p);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (git_vector_init(&p->status, 0, push_status_ref_cmp) < 0) {",
            "-\t\tgit_vector_free(&p->specs);",
            "+\t\tgit_vector_dispose(&p->specs);",
            " \t\tgit__free(p);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (git_vector_init(&p->updates, 0, NULL) < 0) {",
            "-\t\tgit_vector_free(&p->status);",
            "-\t\tgit_vector_free(&p->specs);",
            "+\t\tgit_vector_dispose(&p->status);",
            "+\t\tgit_vector_dispose(&p->specs);",
            " \t\tgit__free(p);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (git_vector_init(&p->remote_push_options, 0, git__strcmp_cb) < 0) {",
            "-\t\tgit_vector_free(&p->status);",
            "-\t\tgit_vector_free(&p->specs);",
            "-\t\tgit_vector_free(&p->updates);",
            "+\t\tgit_vector_dispose(&p->status);",
            "+\t\tgit_vector_dispose(&p->specs);",
            "+\t\tgit_vector_dispose(&p->updates);",
            " \t\tgit__free(p);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \t*out = p;",
            " \treturn 0;",
            " }",
            "@@ -217,20 +217,33 @@",
            " \t\t\tif (error != GIT_ENOTFOUND)",
            " \t\t\t\tgoto on_error;",
            " ",
            " \t\t\tgit_error_clear();",
            " \t\t\tfire_callback = 0;",
            " \t\t}",
            " ",
            "-\t\tif (fire_callback && callbacks && callbacks->update_tips) {",
            "-\t\t\terror = callbacks->update_tips(git_str_cstr(&remote_ref_name),",
            "-\t\t\t\t\t\t&push_spec->roid, &push_spec->loid, callbacks->payload);",
            "+\t\tif (!fire_callback || !callbacks)",
            "+\t\t\tcontinue;",
            " ",
            "-\t\t\tif (error < 0)",
            "-\t\t\t\tgoto on_error;",
            "+\t\tif (callbacks->update_refs)",
            "+\t\t\terror = callbacks->update_refs(",
            "+\t\t\t\tgit_str_cstr(&remote_ref_name),",
            "+\t\t\t\t&push_spec->roid, &push_spec->loid,",
            "+\t\t\t\t&push_spec->refspec, callbacks->payload);",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+\t\telse if (callbacks->update_tips)",
            "+\t\t\terror = callbacks->update_tips(",
            "+\t\t\t\tgit_str_cstr(&remote_ref_name),",
            "+\t\t\t\t&push_spec->roid, &push_spec->loid,",
            "+\t\t\t\tcallbacks->payload);",
            "+#endif",
            "+",
            "+\t\tif (error < 0) {",
            "+\t\t\tgit_error_set_after_callback_function(error, \"git_remote_push\");",
            "+\t\t\tgoto on_error;",
            " \t\t}",
            " \t}",
            " ",
            " \terror = 0;",
            " ",
            " on_error:",
            " \tgit_str_dispose(&remote_ref_name);",
            "@@ -279,14 +292,15 @@",
            " \tif (git_revwalk_new(&rw, push->repo) < 0)",
            " \t\treturn -1;",
            " ",
            " \tgit_revwalk_sorting(rw, GIT_SORT_TIME);",
            " ",
            " \tgit_vector_foreach(&push->specs, i, spec) {",
            " \t\tgit_object_t type;",
            "+\t\tgit_oid id;",
            " \t\tsize_t size;",
            " ",
            " \t\tif (git_oid_is_zero(&spec->loid))",
            " \t\t\t/*",
            " \t\t\t * Delete reference on remote side;",
            " \t\t\t * nothing to do here.",
            " \t\t\t */",
            "@@ -300,28 +314,28 @@",
            " ",
            " \t\tif (type == GIT_OBJECT_TAG) {",
            " \t\t\tgit_object *target;",
            " ",
            " \t\t\tif ((error = enqueue_tag(&target, push, &spec->loid)) < 0)",
            " \t\t\t\tgoto on_error;",
            " ",
            "-\t\t\tif (git_object_type(target) == GIT_OBJECT_COMMIT) {",
            "-\t\t\t\tif ((error = git_revwalk_push(rw, git_object_id(target))) < 0) {",
            "-\t\t\t\t\tgit_object_free(target);",
            "-\t\t\t\t\tgoto on_error;",
            "-\t\t\t\t}",
            "-\t\t\t} else {",
            "-\t\t\t\tif ((error = git_packbuilder_insert(",
            "-\t\t\t\t\tpush->pb, git_object_id(target), NULL)) < 0) {",
            "-\t\t\t\t\tgit_object_free(target);",
            "-\t\t\t\t\tgoto on_error;",
            "-\t\t\t\t}",
            "-\t\t\t}",
            "+\t\t\ttype = git_object_type(target);",
            "+\t\t\tgit_oid_cpy(&id, git_object_id(target));",
            "+",
            " \t\t\tgit_object_free(target);",
            "-\t\t} else if ((error = git_revwalk_push(rw, &spec->loid)) < 0)",
            "+\t\t} else {",
            "+\t\t\tgit_oid_cpy(&id, &spec->loid);",
            "+\t\t}",
            "+",
            "+\t\tif (type == GIT_OBJECT_COMMIT)",
            "+\t\t\terror = git_revwalk_push(rw, &id);",
            "+\t\telse",
            "+\t\t\terror = git_packbuilder_insert(push->pb, &id, NULL);",
            "+",
            "+\t\tif (error < 0)",
            " \t\t\tgoto on_error;",
            " ",
            " \t\tif (!spec->refspec.force) {",
            " \t\t\tgit_oid base;",
            " ",
            " \t\t\tif (git_oid_is_zero(&spec->roid))",
            " \t\t\t\tcontinue;",
            "@@ -564,32 +578,32 @@",
            " ",
            " \tif (push == NULL)",
            " \t\treturn;",
            " ",
            " \tgit_vector_foreach(&push->specs, i, spec) {",
            " \t\tfree_refspec(spec);",
            " \t}",
            "-\tgit_vector_free(&push->specs);",
            "+\tgit_vector_dispose(&push->specs);",
            " ",
            " \tgit_vector_foreach(&push->status, i, status) {",
            " \t\tgit_push_status_free(status);",
            " \t}",
            "-\tgit_vector_free(&push->status);",
            "+\tgit_vector_dispose(&push->status);",
            " ",
            " \tgit_vector_foreach(&push->updates, i, update) {",
            " \t\tgit__free(update->src_refname);",
            " \t\tgit__free(update->dst_refname);",
            " \t\tgit__free(update);",
            " \t}",
            "-\tgit_vector_free(&push->updates);",
            "+\tgit_vector_dispose(&push->updates);",
            " ",
            " \tgit_vector_foreach(&push->remote_push_options, i, option) {",
            " \t\tgit__free(option);",
            " \t}",
            "-\tgit_vector_free(&push->remote_push_options);",
            "+\tgit_vector_dispose(&push->remote_push_options);",
            " ",
            " \tgit__free(push);",
            " }",
            " ",
            " int git_push_options_init(git_push_options *opts, unsigned int version)",
            " {",
            " \tGIT_INIT_STRUCTURE_FROM_TEMPLATE("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/refdb_fs.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/refdb_fs.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/refdb_fs.c",
            "@@ -22,15 +22,14 @@",
            " ",
            " #include <git2/tag.h>",
            " #include <git2/object.h>",
            " #include <git2/refdb.h>",
            " #include <git2/branch.h>",
            " #include <git2/sys/refdb_backend.h>",
            " #include <git2/sys/refs.h>",
            "-#include <git2/sys/reflog.h>",
            " ",
            " #define DEFAULT_NESTING_LEVEL\t5",
            " #define MAX_NESTING_LEVEL\t\t10",
            " ",
            " enum {",
            " \tPACKREF_HAS_PEEL = 1,",
            " \tPACKREF_WAS_LOOSE = 2,",
            "@@ -797,15 +796,15 @@",
            " \tsize_t packed_pos;",
            " } refdb_fs_iter;",
            " ",
            " static void refdb_fs_backend__iterator_free(git_reference_iterator *_iter)",
            " {",
            " \trefdb_fs_iter *iter = GIT_CONTAINER_OF(_iter, refdb_fs_iter, parent);",
            " ",
            "-\tgit_vector_free(&iter->loose);",
            "+\tgit_vector_dispose(&iter->loose);",
            " \tgit_pool_clear(&iter->pool);",
            " \tgit_sortedcache_free(iter->cache);",
            " \tgit__free(iter);",
            " }",
            " ",
            " struct iter_load_context {",
            " \trefdb_fs_backend *backend;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/reflog.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/reflog.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/reflog.c",
            "@@ -9,15 +9,14 @@",
            " ",
            " #include \"repository.h\"",
            " #include \"filebuf.h\"",
            " #include \"signature.h\"",
            " #include \"refdb.h\"",
            " ",
            " #include \"git2/sys/refdb_backend.h\"",
            "-#include \"git2/sys/reflog.h\"",
            " ",
            " void git_reflog_entry__free(git_reflog_entry *entry)",
            " {",
            " \tgit_signature_free(entry->committer);",
            " ",
            " \tgit__free(entry->msg);",
            " \tgit__free(entry);",
            "@@ -36,15 +35,15 @@",
            " ",
            " \tfor (i=0; i < reflog->entries.length; i++) {",
            " \t\tentry = git_vector_get(&reflog->entries, i);",
            " ",
            " \t\tgit_reflog_entry__free(entry);",
            " \t}",
            " ",
            "-\tgit_vector_free(&reflog->entries);",
            "+\tgit_vector_dispose(&reflog->entries);",
            " \tgit__free(reflog->ref_name);",
            " \tgit__free(reflog);",
            " }",
            " ",
            " int git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)",
            " {",
            " \tgit_refdb *refdb;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/reflog.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/reflog.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/reflog.h",
            "@@ -33,8 +33,10 @@",
            " };",
            " ",
            " GIT_INLINE(size_t) reflog_inverse_index(size_t idx, size_t total)",
            " {",
            " \treturn (total - 1) - idx;",
            " }",
            " ",
            "+void git_reflog_entry__free(git_reflog_entry *entry);",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/refs.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/refs.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/refs.c",
            "@@ -804,15 +804,15 @@",
            " \tarray->count = 0;",
            " ",
            " \tif (git_vector_init(&ref_list, 8, NULL) < 0)",
            " \t\treturn -1;",
            " ",
            " \tif (git_reference_foreach_name(",
            " \t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {",
            "-\t\tgit_vector_free(&ref_list);",
            "+\t\tgit_vector_dispose(&ref_list);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);",
            " ",
            " \treturn 0;",
            " }",
            "@@ -831,25 +831,28 @@",
            " \tcase '[':",
            " \t\treturn 0;",
            " \tdefault:",
            " \t\treturn 1;",
            " \t}",
            " }",
            " ",
            "-static int ensure_segment_validity(const char *name, char may_contain_glob)",
            "+static int ensure_segment_validity(const char *name, char may_contain_glob, bool allow_caret_prefix)",
            " {",
            " \tconst char *current = name;",
            "+\tconst char *start = current;",
            " \tchar prev = '\\0';",
            " \tconst int lock_len = (int)strlen(GIT_FILELOCK_EXTENSION);",
            " \tint segment_len;",
            " ",
            " \tif (*current == '.')",
            " \t\treturn -1; /* Refname starts with \".\" */",
            "+\tif (allow_caret_prefix && *current == '^')",
            "+\t\tstart++;",
            " ",
            "-\tfor (current = name; ; current++) {",
            "+\tfor (current = start; ; current++) {",
            " \t\tif (*current == '\\0' || *current == '/')",
            " \t\t\tbreak;",
            " ",
            " \t\tif (!is_valid_ref_char(*current))",
            " \t\t\treturn -1; /* Illegal character in refname */",
            " ",
            " \t\tif (prev == '.' && *current == '.')",
            "@@ -873,25 +876,28 @@",
            " \tif (segment_len >= lock_len &&",
            " \t\t!memcmp(current - lock_len, GIT_FILELOCK_EXTENSION, lock_len))",
            " \t\t\treturn -1;",
            " ",
            " \treturn segment_len;",
            " }",
            " ",
            "-static bool is_all_caps_and_underscore(const char *name, size_t len)",
            "+static bool is_valid_normalized_name(const char *name, size_t len)",
            " {",
            " \tsize_t i;",
            " \tchar c;",
            " ",
            " \tGIT_ASSERT_ARG(name);",
            " \tGIT_ASSERT_ARG(len > 0);",
            " ",
            " \tfor (i = 0; i < len; i++)",
            " \t{",
            " \t\tc = name[i];",
            "+\t\tif (i == 0 && c == '^')",
            "+\t\t\tcontinue; /* The first character is allowed to be \"^\" for negative refspecs */",
            "+",
            " \t\tif ((c < 'A' || c > 'Z') && c != '_')",
            " \t\t\treturn false;",
            " \t}",
            " ",
            " \tif (*name == '_' || name[len - 1] == '_')",
            " \t\treturn false;",
            " ",
            "@@ -904,14 +910,15 @@",
            " \tconst char *name,",
            " \tunsigned int flags)",
            " {",
            " \tconst char *current;",
            " \tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;",
            " \tunsigned int process_flags;",
            " \tbool normalize = (buf != NULL);",
            "+\tbool allow_caret_prefix = true;",
            " \tbool validate = (flags & GIT_REFERENCE_FORMAT__VALIDATION_DISABLE) == 0;",
            " ",
            " #ifdef GIT_USE_ICONV",
            " \tgit_fs_path_iconv_t ic = GIT_PATH_ICONV_INIT;",
            " #endif",
            " ",
            " \tGIT_ASSERT_ARG(name);",
            "@@ -941,15 +948,15 @@",
            " \t\terror = git_str_oom(buf) ? -1 : 0;",
            " \t\tgoto cleanup;",
            " \t}",
            " ",
            " \twhile (true) {",
            " \t\tchar may_contain_glob = process_flags & GIT_REFERENCE_FORMAT_REFSPEC_PATTERN;",
            " ",
            "-\t\tsegment_len = ensure_segment_validity(current, may_contain_glob);",
            "+\t\tsegment_len = ensure_segment_validity(current, may_contain_glob, allow_caret_prefix);",
            " \t\tif (segment_len < 0)",
            " \t\t\tgoto cleanup;",
            " ",
            " \t\tif (segment_len > 0) {",
            " \t\t\t/*",
            " \t\t\t * There may only be one glob in a pattern, thus we reset",
            " \t\t\t * the pattern-flag in case the current segment has one.",
            "@@ -977,14 +984,20 @@",
            " \t\tif (segment_len == 0 && !normalize)",
            " \t\t\tgoto cleanup;",
            " ",
            " \t\tif (current[segment_len] == '\\0')",
            " \t\t\tbreak;",
            " ",
            " \t\tcurrent += segment_len + 1;",
            "+",
            "+\t\t/*",
            "+\t\t * A caret prefix is only allowed in the first segment to signify a",
            "+\t\t * negative refspec.",
            "+\t\t */",
            "+\t\tallow_caret_prefix = false;",
            " \t}",
            " ",
            " \t/* A refname can not be empty */",
            " \tif (segment_len == 0 && segments_count == 0)",
            " \t\tgoto cleanup;",
            " ",
            " \t/* A refname can not end with \".\" */",
            "@@ -996,20 +1009,20 @@",
            " \t\tgoto cleanup;",
            " ",
            " \tif ((segments_count == 1 ) && !(flags & GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL))",
            " \t\tgoto cleanup;",
            " ",
            " \tif ((segments_count == 1 ) &&",
            " \t    !(flags & GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND) &&",
            "-\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||",
            "+\t\t!(is_valid_normalized_name(name, (size_t)segment_len) ||",
            " \t\t\t((flags & GIT_REFERENCE_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))",
            " \t\t\tgoto cleanup;",
            " ",
            " \tif ((segments_count > 1)",
            "-\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))",
            "+\t\t&& (is_valid_normalized_name(name, strchr(name, '/') - name)))",
            " \t\t\tgoto cleanup;",
            " ",
            " \terror = 0;",
            " ",
            " cleanup:",
            " \tif (error == GIT_EINVALIDSPEC)",
            " \t\tgit_error_set("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/refs.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/refs.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/refs.h",
            "@@ -8,15 +8,14 @@",
            " #define INCLUDE_refs_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"git2/oid.h\"",
            " #include \"git2/refs.h\"",
            " #include \"git2/refdb.h\"",
            "-#include \"strmap.h\"",
            " #include \"str.h\"",
            " #include \"oid.h\"",
            " ",
            " extern bool git_reference__enable_symbolic_ref_target_validation;",
            " ",
            " #define GIT_REFS_DIR \"refs/\"",
            " #define GIT_REFS_HEADS_DIR GIT_REFS_DIR \"heads/\""
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/refspec.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/refspec.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/refspec.c",
            "@@ -18,26 +18,30 @@",
            " \t/* Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636 */",
            " ",
            " \tsize_t llen;",
            " \tint is_glob = 0;",
            " \tconst char *lhs, *rhs;",
            " \tint valid = 0;",
            " \tunsigned int flags;",
            "+\tbool is_neg_refspec = false;",
            " ",
            " \tGIT_ASSERT_ARG(refspec);",
            " \tGIT_ASSERT_ARG(input);",
            " ",
            " \tmemset(refspec, 0x0, sizeof(git_refspec));",
            " \trefspec->push = !is_fetch;",
            " ",
            " \tlhs = input;",
            " \tif (*lhs == '+') {",
            " \t\trefspec->force = 1;",
            " \t\tlhs++;",
            " \t}",
            "+\tif (*lhs == '^') {",
            "+\t\tis_neg_refspec = true;",
            "+\t}",
            " ",
            " \trhs = strrchr(lhs, ':');",
            " ",
            " \t/*",
            " \t * Before going on, special case \":\" (or \"+:\") as a refspec",
            " \t * for matching refs.",
            " \t */",
            "@@ -58,15 +62,22 @@",
            " \t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));",
            " \t\t\trefspec->dst = git__strndup(rhs, rlen);",
            " \t\t}",
            " \t}",
            " ",
            " \tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));",
            " \tif (1 <= llen && memchr(lhs, '*', llen)) {",
            "-\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))",
            "+\t\t/*",
            "+\t\t * If the lefthand side contains a glob, then one of the following must be",
            "+\t\t * true, otherwise the spec is invalid",
            "+\t\t *   1) the rhs exists and also contains a glob",
            "+\t\t *   2) it is a negative refspec (i.e. no rhs)",
            "+\t\t *   3) the rhs doesn't exist and we're fetching",
            "+\t\t */",
            "+\t\tif ((rhs && !is_glob) || (rhs && is_neg_refspec) || (!rhs && is_fetch && !is_neg_refspec))",
            " \t\t\tgoto invalid;",
            " \t\tis_glob = 1;",
            " \t} else if (rhs && is_glob)",
            " \t\tgoto invalid;",
            " ",
            " \trefspec->pattern = is_glob;",
            " \trefspec->src = git__strndup(lhs, llen);",
            "@@ -221,14 +232,22 @@",
            " int git_refspec_force(const git_refspec *refspec)",
            " {",
            " \tGIT_ASSERT_ARG(refspec);",
            " ",
            " \treturn refspec->force;",
            " }",
            " ",
            "+int git_refspec_src_matches_negative(const git_refspec *refspec, const char *refname)",
            "+{",
            "+\tif (refspec == NULL || refspec->src == NULL || !git_refspec_is_negative(refspec))",
            "+\t\treturn false;",
            "+",
            "+\treturn (wildmatch(refspec->src + 1, refname, 0) == 0);",
            "+}",
            "+",
            " int git_refspec_src_matches(const git_refspec *refspec, const char *refname)",
            " {",
            " \tif (refspec == NULL || refspec->src == NULL)",
            " \t\treturn false;",
            " ",
            " \treturn (wildmatch(refspec->src, refname, 0) == 0);",
            " }",
            "@@ -336,14 +355,22 @@",
            " {",
            " \tGIT_ASSERT_ARG(spec);",
            " \tGIT_ASSERT_ARG(spec->src);",
            " ",
            " \treturn (spec->src[strlen(spec->src) - 1] == '*');",
            " }",
            " ",
            "+int git_refspec_is_negative(const git_refspec *spec)",
            "+{",
            "+\tGIT_ASSERT_ARG(spec);",
            "+\tGIT_ASSERT_ARG(spec->src);",
            "+",
            "+\treturn (spec->src[0] == '^' && spec->dst == NULL);",
            "+}",
            "+",
            " git_direction git_refspec_direction(const git_refspec *spec)",
            " {",
            " \tGIT_ASSERT_ARG(spec);",
            " ",
            " \treturn spec->push;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/refspec.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/refspec.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/refspec.h",
            "@@ -42,13 +42,21 @@",
            "  *",
            "  * @param spec the refspec",
            "  * @return 1 if the refspec is a wildcard, 0 otherwise",
            "  */",
            " int git_refspec_is_wildcard(const git_refspec *spec);",
            " ",
            " /**",
            "+ * Determines if a refspec is a negative refspec.",
            "+ *",
            "+ * @param spec the refspec",
            "+ * @return 1 if the refspec is a negative, 0 otherwise",
            "+ */",
            "+int git_refspec_is_negative(const git_refspec *spec);",
            "+",
            "+/**",
            "  * DWIM `spec` with `refs` existing on the remote, append the dwim'ed",
            "  * result in `out`.",
            "  */",
            " int git_refspec__dwim_one(git_vector *out, git_refspec *spec, git_vector *refs);",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/remote.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/remote.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/remote.c",
            "@@ -1289,17 +1289,17 @@",
            " \tfree_refspecs(&remote->passive_refspecs);",
            " \tif ((error = dwim_refspecs(&remote->passive_refspecs, &remote->refspecs, &refs)) < 0)",
            " \t\tgoto on_error;",
            " ",
            " \tfree_refspecs(&remote->active_refspecs);",
            " \terror = dwim_refspecs(&remote->active_refspecs, to_active, &refs);",
            " ",
            "-\tgit_vector_free(&refs);",
            "+\tgit_vector_dispose(&refs);",
            " \tfree_refspecs(&specs);",
            "-\tgit_vector_free(&specs);",
            "+\tgit_vector_dispose(&specs);",
            " ",
            " \tif (error < 0)",
            " \t\tgoto on_error;",
            " ",
            " \tif (remote->push) {",
            " \t\tgit_push_free(remote->push);",
            " \t\tremote->push = NULL;",
            "@@ -1307,17 +1307,17 @@",
            " ",
            " \tif ((error = git_fetch_negotiate(remote, opts)) < 0)",
            " \t\tgoto on_error;",
            " ",
            " \terror = git_fetch_download_pack(remote);",
            " ",
            " on_error:",
            "-\tgit_vector_free(&refs);",
            "+\tgit_vector_dispose(&refs);",
            " \tfree_refspecs(&specs);",
            "-\tgit_vector_free(&specs);",
            "+\tgit_vector_dispose(&specs);",
            " \treturn error;",
            " }",
            " ",
            " int git_remote_download(",
            " \tgit_remote *remote,",
            " \tconst git_strarray *refspecs,",
            " \tconst git_fetch_options *opts)",
            "@@ -1585,15 +1585,15 @@",
            " ",
            " \tgit_fetchhead_write(remote->repo, &fetchhead_refs);",
            " ",
            " cleanup:",
            " \tfor (i = 0; i < fetchhead_refs.length; ++i)",
            " \t\tgit_fetchhead_ref_free(fetchhead_refs.contents[i]);",
            " ",
            "-\tgit_vector_free(&fetchhead_refs);",
            "+\tgit_vector_dispose(&fetchhead_refs);",
            " \tgit_reference_free(head_ref);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " /**",
            "  * Generate a list of candidates for pruning by getting a list of",
            "@@ -1720,34 +1720,44 @@",
            " \t\t\tgit_reference_free(ref);",
            " \t\t\tcontinue;",
            " \t\t}",
            " ",
            " \t\tgit_oid_cpy(&id, git_reference_target(ref));",
            " \t\terror = git_reference_delete(ref);",
            " \t\tgit_reference_free(ref);",
            "+",
            " \t\tif (error < 0)",
            " \t\t\tgoto cleanup;",
            " ",
            "-\t\tif (callbacks && callbacks->update_tips)",
            "-\t\t\terror = callbacks->update_tips(refname, &id, &zero_id, callbacks->payload);",
            "+\t\tif (callbacks && callbacks->update_refs)",
            "+\t\t\terror = callbacks->update_refs(refname, &id,",
            "+\t\t\t\t&zero_id, NULL, callbacks->payload);",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+\t\telse if (callbacks && callbacks->update_tips)",
            "+\t\t\terror = callbacks->update_tips(refname, &id,",
            "+\t\t\t\t&zero_id, callbacks->payload);",
            "+#endif",
            " ",
            "-\t\tif (error < 0)",
            "+\t\tif (error < 0) {",
            "+\t\t\tgit_error_set_after_callback_function(error, \"git_remote_fetch\");",
            " \t\t\tgoto cleanup;",
            "+\t\t}",
            " \t}",
            " ",
            " cleanup:",
            "-\tgit_vector_free(&remote_refs);",
            "-\tgit_vector_free_deep(&candidates);",
            "+\tgit_vector_dispose(&remote_refs);",
            "+\tgit_vector_dispose_deep(&candidates);",
            " \treturn error;",
            " }",
            " ",
            " static int update_ref(",
            " \tconst git_remote *remote,",
            " \tconst char *ref_name,",
            " \tgit_oid *id,",
            "+\tgit_refspec *spec,",
            " \tconst char *msg,",
            " \tconst git_remote_callbacks *callbacks)",
            " {",
            " \tgit_reference *ref;",
            " \tgit_oid old_id;",
            " \tint error;",
            " ",
            "@@ -1768,17 +1778,27 @@",
            " \t\terror = git_reference_create_matching(&ref, remote->repo, ref_name, id, true, &old_id, msg);",
            " ",
            " \tgit_reference_free(ref);",
            " ",
            " \tif (error < 0)",
            " \t\treturn error;",
            " ",
            "-\tif (callbacks && callbacks->update_tips &&",
            "-\t    (error = callbacks->update_tips(ref_name, &old_id, id, callbacks->payload)) < 0)",
            "+\tif (callbacks && callbacks->update_refs)",
            "+\t\terror = callbacks->update_refs(ref_name, &old_id,",
            "+\t\t\tid, spec, callbacks->payload);",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+\telse if (callbacks && callbacks->update_tips)",
            "+\t\terror = callbacks->update_tips(ref_name, &old_id,",
            "+\t\t\tid, callbacks->payload);",
            "+#endif",
            "+",
            "+\tif (error < 0) {",
            "+\t\tgit_error_set_after_callback_function(error, \"git_remote_fetch\");",
            " \t\treturn error;",
            "+\t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int update_one_tip(",
            " \tgit_vector *update_heads,",
            " \tgit_remote *remote,",
            "@@ -1876,17 +1896,28 @@",
            " \t\t\tif (error == GIT_EEXISTS)",
            " \t\t\t\terror = 0;",
            " ",
            " \t\t\tgoto done;",
            " \t\t}",
            " \t}",
            " ",
            "-\tif (callbacks && callbacks->update_tips != NULL &&",
            "-\t    (updated || (update_flags & GIT_REMOTE_UPDATE_REPORT_UNCHANGED)) &&",
            "-\t    (error = callbacks->update_tips(refname.ptr, &old, &head->oid, callbacks->payload)) < 0)",
            "+\tif (!callbacks ||",
            "+\t    (!updated && (update_flags & GIT_REMOTE_UPDATE_REPORT_UNCHANGED) == 0))",
            "+\t\tgoto done;",
            "+",
            "+\tif (callbacks && callbacks->update_refs)",
            "+\t\terror = callbacks->update_refs(refname.ptr, &old,",
            "+\t\t\t&head->oid, spec, callbacks->payload);",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+\telse if (callbacks && callbacks->update_tips)",
            "+\t\terror = callbacks->update_tips(refname.ptr, &old,",
            "+\t\t\t&head->oid, callbacks->payload);",
            "+#endif",
            "+",
            "+\tif (error < 0)",
            " \t\tgit_error_set_after_callback_function(error, \"git_remote_fetch\");",
            " ",
            " done:",
            " \tgit_reference_free(ref);",
            " \tgit_str_dispose(&refname);",
            " \treturn error;",
            " }",
            "@@ -1928,35 +1959,35 @@",
            " \tif (git_oid__is_hexstr(spec->src, remote->repo->oid_type)) {",
            " \t\tgit_oid id;",
            " ",
            " \t\tif ((error = git_oid__fromstr(&id, spec->src, remote->repo->oid_type)) < 0)",
            " \t\t\tgoto on_error;",
            " ",
            " \t\tif (spec->dst &&",
            "-\t\t     (error = update_ref(remote, spec->dst, &id, log_message, callbacks)) < 0)",
            "+\t\t     (error = update_ref(remote, spec->dst, &id, spec, log_message, callbacks)) < 0)",
            " \t\t\tgoto on_error;",
            " ",
            " \t\tgit_oid_cpy(&oid_head.oid, &id);",
            " \t\toid_head.name = spec->src;",
            " ",
            " \t\tif ((error = git_vector_insert(&update_heads, &oid_head)) < 0)",
            " \t\t\tgoto on_error;",
            " \t}",
            " ",
            " \tif ((update_flags & GIT_REMOTE_UPDATE_FETCHHEAD) &&",
            " \t    (error = git_remote_write_fetchhead(remote, spec, &update_heads)) < 0)",
            " \t\tgoto on_error;",
            " ",
            " \tgit_refspec__dispose(&tagspec);",
            "-\tgit_vector_free(&update_heads);",
            "+\tgit_vector_dispose(&update_heads);",
            " \treturn 0;",
            " ",
            " on_error:",
            " \tgit_refspec__dispose(&tagspec);",
            "-\tgit_vector_free(&update_heads);",
            "+\tgit_vector_dispose(&update_heads);",
            " \treturn -1;",
            " ",
            " }",
            " ",
            " /**",
            "  * Iteration over the three vectors, with a pause whenever we find a match",
            "  *",
            "@@ -2040,15 +2071,15 @@",
            " \t\t * passive refspecs, so we should update that",
            " \t\t * remote-tracking branch, but not add it to",
            " \t\t * FETCH_HEAD",
            " \t\t */",
            " ",
            " \t\tgit_str_clear(&refname);",
            " \t\tif ((error = git_refspec__transform(&refname, spec, head->name)) < 0 ||",
            "-\t\t    (error = update_ref(remote, refname.ptr, &head->oid, msg, callbacks)) < 0)",
            "+\t\t    (error = update_ref(remote, refname.ptr, &head->oid, spec, msg, callbacks)) < 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " ",
            " \tif (error != GIT_ITEROVER)",
            " \t\tgoto cleanup;",
            " ",
            " \terror = 0;",
            "@@ -2119,15 +2150,15 @@",
            " \t}",
            " ",
            " \t/* Only try to do opportunistic updates if the refspec lists differ. */",
            " \tif (remote->passed_refspecs)",
            " \t\terror = opportunistic_updates(remote, callbacks, &refs, reflog_message);",
            " ",
            " out:",
            "-\tgit_vector_free(&refs);",
            "+\tgit_vector_dispose(&refs);",
            " \tgit_refspec__dispose(&tagspec);",
            " \treturn error;",
            " }",
            " ",
            " int git_remote_connected(const git_remote *remote)",
            " {",
            " \tGIT_ASSERT_ARG(remote);",
            "@@ -2178,27 +2209,27 @@",
            " \tif (remote->transport != NULL) {",
            " \t\tgit_remote_disconnect(remote);",
            " ",
            " \t\tremote->transport->free(remote->transport);",
            " \t\tremote->transport = NULL;",
            " \t}",
            " ",
            "-\tgit_vector_free(&remote->refs);",
            "+\tgit_vector_dispose(&remote->refs);",
            " ",
            " \tfree_refspecs(&remote->refspecs);",
            "-\tgit_vector_free(&remote->refspecs);",
            "+\tgit_vector_dispose(&remote->refspecs);",
            " ",
            " \tfree_refspecs(&remote->active_refspecs);",
            "-\tgit_vector_free(&remote->active_refspecs);",
            "+\tgit_vector_dispose(&remote->active_refspecs);",
            " ",
            " \tfree_refspecs(&remote->passive_refspecs);",
            "-\tgit_vector_free(&remote->passive_refspecs);",
            "+\tgit_vector_dispose(&remote->passive_refspecs);",
            " ",
            " \tfree_heads(&remote->local_heads);",
            "-\tgit_vector_free(&remote->local_heads);",
            "+\tgit_vector_dispose(&remote->local_heads);",
            " ",
            " \tgit_push_free(remote->push);",
            " \tgit__free(remote->url);",
            " \tgit__free(remote->pushurl);",
            " \tgit__free(remote->name);",
            " \tgit__free(remote);",
            " }",
            "@@ -2233,15 +2264,15 @@",
            " \tif ((error = git_vector_init(&list, 4, git__strcmp_cb)) < 0)",
            " \t\treturn error;",
            " ",
            " \terror = git_config_foreach_match(",
            " \t\tcfg, \"^remote\\\\..*\\\\.(push)?url$\", remote_list_cb, &list);",
            " ",
            " \tif (error < 0) {",
            "-\t\tgit_vector_free_deep(&list);",
            "+\t\tgit_vector_dispose_deep(&list);",
            " \t\treturn error;",
            " \t}",
            " ",
            " \tgit_vector_uniq(&list, git__free);",
            " ",
            " \tremotes_list->strings =",
            " \t\t(char **)git_vector_detach(&remotes_list->count, NULL, &list);",
            "@@ -2514,15 +2545,15 @@",
            " \tgit_str_dispose(&val);",
            " ",
            " \tif (error < 0) {",
            " \t\tchar *str;",
            " \t\tgit_vector_foreach(problems, i, str)",
            " \t\t\tgit__free(str);",
            " ",
            "-\t\tgit_vector_free(problems);",
            "+\t\tgit_vector_dispose(problems);",
            " \t}",
            " ",
            " \treturn error;",
            " }",
            " ",
            " int git_remote_rename(git_strarray *out, git_repository *repo, const char *name, const char *new_name)",
            " {",
            "@@ -2554,15 +2585,15 @@",
            " \t\tgoto cleanup;",
            " ",
            " \tout->count = problem_refspecs.length;",
            " \tout->strings = (char **) problem_refspecs.contents;",
            " ",
            " cleanup:",
            " \tif (error < 0)",
            "-\t\tgit_vector_free(&problem_refspecs);",
            "+\t\tgit_vector_dispose(&problem_refspecs);",
            " ",
            " \tgit_remote_free(remote);",
            " \treturn error;",
            " }",
            " ",
            " int git_remote_name_is_valid(int *valid, const char *remote_name)",
            " {",
            "@@ -2593,25 +2624,29 @@",
            " ",
            " \treturn error;",
            " }",
            " ",
            " git_refspec *git_remote__matching_refspec(git_remote *remote, const char *refname)",
            " {",
            " \tgit_refspec *spec;",
            "+\tgit_refspec *match = NULL;",
            " \tsize_t i;",
            " ",
            " \tgit_vector_foreach(&remote->active_refspecs, i, spec) {",
            " \t\tif (spec->push)",
            " \t\t\tcontinue;",
            " ",
            "-\t\tif (git_refspec_src_matches(spec, refname))",
            "-\t\t\treturn spec;",
            "+\t\tif (git_refspec_src_matches_negative(spec, refname))",
            "+\t\t\treturn NULL;",
            "+",
            "+\t\tif (git_refspec_src_matches(spec, refname) && match == NULL)",
            "+\t\t\tmatch = spec;",
            " \t}",
            " ",
            "-\treturn NULL;",
            "+\treturn match;",
            " }",
            " ",
            " git_refspec *git_remote__matching_dst_refspec(git_remote *remote, const char *refname)",
            " {",
            " \tgit_refspec *spec;",
            " \tsize_t i;",
            " ",
            "@@ -2661,15 +2696,15 @@",
            " ",
            " \tarray->strings = (char **)refspecs.contents;",
            " \tarray->count = refspecs.length;",
            " ",
            " \treturn 0;",
            " ",
            " on_error:",
            "-\tgit_vector_free_deep(&refspecs);",
            "+\tgit_vector_dispose_deep(&refspecs);",
            " ",
            " \treturn -1;",
            " }",
            " ",
            " int git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)",
            " {",
            " \treturn copy_refspecs(array, remote, false);",
            "@@ -2809,15 +2844,15 @@",
            " \t}",
            " ",
            " cleanup:",
            " \tgit_reference_iterator_free(iter);",
            " \tgit_vector_foreach(&refs, i, dup) {",
            " \t\tgit__free(dup);",
            " \t}",
            "-\tgit_vector_free(&refs);",
            "+\tgit_vector_dispose(&refs);",
            " \treturn error;",
            " }",
            " ",
            " static int remove_remote_tracking(git_repository *repo, const char *remote_name)",
            " {",
            " \tgit_remote *remote;",
            " \tint error;",
            "@@ -2987,20 +3022,21 @@",
            " \t\t\tchar *optstr = git__strdup(opts->remote_push_options.strings[i]);",
            " \t\t\tGIT_ERROR_CHECK_ALLOC(optstr);",
            " ",
            " \t\t\tif ((error = git_vector_insert(&push->remote_push_options, optstr)) < 0)",
            " \t\t\t\tgoto cleanup;",
            " \t\t}",
            " ",
            "-\tif ((error = git_push_finish(push)) < 0)",
            "-\t\tgoto cleanup;",
            "+\terror = git_push_finish(push);",
            " ",
            "-\tif (connect_opts.callbacks.push_update_reference &&",
            "-\t    (error = git_push_status_foreach(push, connect_opts.callbacks.push_update_reference, connect_opts.callbacks.payload)) < 0)",
            "-\t\tgoto cleanup;",
            "+\tif (connect_opts.callbacks.push_update_reference) {",
            "+\t\tconst int cb_error = git_push_status_foreach(push, connect_opts.callbacks.push_update_reference, connect_opts.callbacks.payload);",
            "+\t\tif (!error)",
            "+\t\t\terror = cb_error;",
            "+\t}",
            " ",
            " cleanup:",
            " \tgit_remote_connect_options_dispose(&connect_opts);",
            " \treturn error;",
            " }",
            " ",
            " int git_remote_push("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/repository.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/repository.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/repository.c",
            "@@ -30,15 +30,14 @@",
            " #include \"remote.h\"",
            " #include \"merge.h\"",
            " #include \"diff_driver.h\"",
            " #include \"annotated_commit.h\"",
            " #include \"submodule.h\"",
            " #include \"worktree.h\"",
            " #include \"path.h\"",
            "-#include \"strmap.h\"",
            " ",
            " #ifdef GIT_WIN32",
            " # include \"win32/w32_util.h\"",
            " #endif",
            " ",
            " bool git_repository__validate_ownership = true;",
            " bool git_repository__fsync_gitdir = false;",
            "@@ -332,25 +331,27 @@",
            " int git_repository__new(git_repository **out, git_oid_t oid_type)",
            " {",
            " \tgit_repository *repo;",
            " ",
            " \t*out = repo = repository_alloc();",
            " \tGIT_ERROR_CHECK_ALLOC(repo);",
            " ",
            "+\tGIT_ASSERT_ARG(git_oid_type_is_valid(oid_type));",
            "+",
            " \trepo->is_bare = 1;",
            " \trepo->is_worktree = 0;",
            " \trepo->oid_type = oid_type;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-int git_repository_new(git_repository **out, git_oid_t oid_type)",
            "+int git_repository_new(git_repository **out, git_repository_new_options *opts)",
            " {",
            "-\treturn git_repository__new(out, oid_type);",
            "+\treturn git_repository__new(out, opts && opts->oid_type ? opts->oid_type : GIT_OID_DEFAULT);",
            " }",
            " #else",
            " int git_repository_new(git_repository** out)",
            " {",
            " \treturn git_repository__new(out, GIT_OID_SHA1);",
            " }",
            " #endif",
            "@@ -1218,47 +1219,30 @@",
            " ",
            " out:",
            " \tgit_str_dispose(&path);",
            " ",
            " \treturn err;",
            " }",
            " ",
            "-int git_repository__wrap_odb(",
            "-\tgit_repository **out,",
            "-\tgit_odb *odb,",
            "-\tgit_oid_t oid_type)",
            "+int git_repository_wrap_odb(git_repository **out, git_odb *odb)",
            " {",
            " \tgit_repository *repo;",
            " ",
            " \trepo = repository_alloc();",
            " \tGIT_ERROR_CHECK_ALLOC(repo);",
            " ",
            "-\trepo->oid_type = oid_type;",
            "+\tGIT_ASSERT(git_oid_type_is_valid(odb->options.oid_type));",
            "+\trepo->oid_type = odb->options.oid_type;",
            " ",
            " \tgit_repository_set_odb(repo, odb);",
            " \t*out = repo;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-#ifdef GIT_EXPERIMENTAL_SHA256",
            "-int git_repository_wrap_odb(",
            "-\tgit_repository **out,",
            "-\tgit_odb *odb,",
            "-\tgit_oid_t oid_type)",
            "-{",
            "-\treturn git_repository__wrap_odb(out, odb, oid_type);",
            "-}",
            "-#else",
            "-int git_repository_wrap_odb(git_repository **out, git_odb *odb)",
            "-{",
            "-\treturn git_repository__wrap_odb(out, odb, GIT_OID_DEFAULT);",
            "-}",
            "-#endif",
            "-",
            " int git_repository_discover(",
            " \tgit_buf *out,",
            " \tconst char *start_path,",
            " \tint across_fs,",
            " \tconst char *ceiling_dirs)",
            " {",
            " \tstruct repo_paths paths = { GIT_STR_INIT };",
            "@@ -1877,14 +1861,15 @@",
            " \treturn 0;",
            " }",
            " ",
            " static const char *builtin_extensions[] = {",
            " \t\"noop\",",
            " \t\"objectformat\",",
            " \t\"worktreeconfig\",",
            "+\t\"preciousobjects\"",
            " };",
            " ",
            " static git_vector user_extensions = { 0, git__strcmp_cb };",
            " ",
            " static int check_valid_extension(const git_config_entry *entry, void *payload)",
            " {",
            " \tgit_str cfg = GIT_STR_INIT;",
            "@@ -2102,15 +2087,15 @@",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " void git_repository__free_extensions(void)",
            " {",
            "-\tgit_vector_free_deep(&user_extensions);",
            "+\tgit_vector_dispose_deep(&user_extensions);",
            " }",
            " ",
            " int git_repository_create_head(const char *git_dir, const char *ref_name)",
            " {",
            " \tgit_str ref_path = GIT_STR_INIT;",
            " \tgit_filebuf ref = GIT_FILEBUF_INIT;",
            " \tconst char *fmt;",
            "@@ -2517,15 +2502,15 @@",
            " ",
            " \terror = git_str_sets(&path_to_repo, to_repo);",
            " ",
            " \tif (!error && use_relative_path)",
            " \t\terror = git_fs_path_make_relative(&path_to_repo, in_dir);",
            " ",
            " \tif (!error)",
            "-\t\terror = git_str_join(&buf, ' ', GIT_FILE_CONTENT_PREFIX, path_to_repo.ptr);",
            "+\t\terror = git_str_printf(&buf, \"%s %s\\n\", GIT_FILE_CONTENT_PREFIX, path_to_repo.ptr);",
            " ",
            " \tif (!error)",
            " \t\terror = repo_write_template(in_dir, true, DOT_GIT, 0666, true, buf.ptr);",
            " ",
            " cleanup:",
            " \tgit_str_dispose(&buf);",
            " \tgit_str_dispose(&path_to_repo);",
            "@@ -2549,15 +2534,16 @@",
            " \tconst char *repo_dir,",
            " \tconst char *work_dir,",
            " \tgit_repository_init_options *opts)",
            " {",
            " \tint error = 0;",
            " \trepo_template_item *tpl;",
            " \tbool external_tpl =",
            "-\t\t((opts->flags & GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE) != 0);",
            "+\t\t opts->template_path != NULL ||",
            "+\t\t(opts->flags & GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE) != 0;",
            " \tmode_t dmode = pick_dir_mode(opts);",
            " \tbool chmod = opts->mode != GIT_REPOSITORY_INIT_SHARED_UMASK;",
            " ",
            " \t/* Hide the \".git\" directory */",
            " #ifdef GIT_WIN32",
            " \tif ((opts->flags & GIT_REPOSITORY_INIT__HAS_DOTGIT) != 0) {",
            " \t\tif (git_win32__set_hidden(repo_dir, true) < 0) {",
            "@@ -4005,7 +3991,31 @@",
            " done:",
            " \tgit_vector_foreach(&parents, i, commit)",
            " \t\tgit__free(commit);",
            " ",
            " \tgit_reference_free(head_ref);",
            " \treturn error;",
            " }",
            "+",
            "+int git_repository__abbrev_length(int *out, git_repository *repo)",
            "+{",
            "+\tsize_t oid_hexsize;",
            "+\tint len;",
            "+\tint error;",
            "+",
            "+\toid_hexsize = git_oid_hexsize(repo->oid_type);",
            "+",
            "+\tif ((error = git_repository__configmap_lookup(&len, repo, GIT_CONFIGMAP_ABBREV)) < 0)",
            "+\t\treturn error;",
            "+",
            "+\tif (len < GIT_ABBREV_MINIMUM) {",
            "+\t\tgit_error_set(GIT_ERROR_CONFIG, \"invalid oid abbreviation setting: '%d'\", len);",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\tif (len == GIT_ABBREV_FALSE || (size_t)len > oid_hexsize)",
            "+\t\tlen = (int)oid_hexsize;",
            "+",
            "+\t*out = len;",
            "+",
            "+\treturn error;",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/repository.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/repository.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/repository.h",
            "@@ -98,14 +98,16 @@",
            " \t/* core.filemode */",
            " \tGIT_FILEMODE_DEFAULT = GIT_CONFIGMAP_TRUE,",
            " \t/* core.ignorestat */",
            " \tGIT_IGNORESTAT_DEFAULT = GIT_CONFIGMAP_FALSE,",
            " \t/* core.trustctime */",
            " \tGIT_TRUSTCTIME_DEFAULT = GIT_CONFIGMAP_TRUE,",
            " \t/* core.abbrev */",
            "+\tGIT_ABBREV_FALSE = GIT_OID_MAX_HEXSIZE,",
            "+\tGIT_ABBREV_MINIMUM = 4,",
            " \tGIT_ABBREV_DEFAULT = 7,",
            " \t/* core.precomposeunicode */",
            " \tGIT_PRECOMPOSE_DEFAULT = GIT_CONFIGMAP_FALSE,",
            " \t/* core.safecrlf */",
            " \tGIT_SAFE_CRLF_DEFAULT = GIT_CONFIGMAP_FALSE,",
            " \t/* core.logallrefupdates */",
            " \tGIT_LOGALLREFUPDATES_FALSE = GIT_CONFIGMAP_FALSE,",
            "@@ -161,15 +163,15 @@",
            " ",
            " \tgit_grafts *grafts;",
            " \tgit_grafts *shallow_grafts;",
            " ",
            " \tgit_atomic32 attr_session_key;",
            " ",
            " \tintptr_t configmap_cache[GIT_CONFIGMAP_CACHE_MAX];",
            "-\tgit_strmap *submodule_cache;",
            "+\tgit_submodule_cache *submodule_cache;",
            " };",
            " ",
            " GIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)",
            " {",
            " \treturn repo->attrcache;",
            " }",
            " ",
            "@@ -193,28 +195,26 @@",
            " int git_repository_config__weakptr(git_config **out, git_repository *repo);",
            " int git_repository_odb__weakptr(git_odb **out, git_repository *repo);",
            " int git_repository_refdb__weakptr(git_refdb **out, git_repository *repo);",
            " int git_repository_index__weakptr(git_index **out, git_repository *repo);",
            " int git_repository_grafts__weakptr(git_grafts **out, git_repository *repo);",
            " int git_repository_shallow_grafts__weakptr(git_grafts **out, git_repository *repo);",
            " ",
            "-int git_repository__wrap_odb(",
            "-\tgit_repository **out,",
            "-\tgit_odb *odb,",
            "-\tgit_oid_t oid_type);",
            "-",
            " /*",
            "  * Configuration map cache",
            "  *",
            "  * Efficient access to the most used config variables of a repository.",
            "  * The cache is cleared every time the config backend is replaced.",
            "  */",
            " int git_repository__configmap_lookup(int *out, git_repository *repo, git_configmap_item item);",
            " void git_repository__configmap_lookup_cache_clear(git_repository *repo);",
            " ",
            "+/** Return the length that object names will be abbreviated to. */",
            "+int git_repository__abbrev_length(int *out, git_repository *repo);",
            "+",
            " int git_repository__item_path(git_str *out, const git_repository *repo, git_repository_item_t item);",
            " ",
            " GIT_INLINE(int) git_repository__ensure_not_bare(",
            " \tgit_repository *repo,",
            " \tconst char *operation_name)",
            " {",
            " \tif (!git_repository_is_bare(repo))"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/revert.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/revert.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/revert.c",
            "@@ -70,16 +70,15 @@",
            " static int revert_normalize_opts(",
            " \tgit_repository *repo,",
            " \tgit_revert_options *opts,",
            " \tconst git_revert_options *given,",
            " \tconst char *their_label)",
            " {",
            " \tint error = 0;",
            "-\tunsigned int default_checkout_strategy = GIT_CHECKOUT_SAFE |",
            "-\t\tGIT_CHECKOUT_ALLOW_CONFLICTS;",
            "+\tunsigned int default_checkout_strategy = GIT_CHECKOUT_ALLOW_CONFLICTS;",
            " ",
            " \tGIT_UNUSED(repo);",
            " ",
            " \tif (given != NULL)",
            " \t\tmemcpy(opts, given, sizeof(git_revert_options));",
            " \telse {",
            " \t\tgit_revert_options default_opts = GIT_REVERT_OPTIONS_INIT;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/revwalk.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/revwalk.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/revwalk.c",
            "@@ -10,33 +10,36 @@",
            " #include \"commit.h\"",
            " #include \"odb.h\"",
            " #include \"pool.h\"",
            " ",
            " #include \"git2/revparse.h\"",
            " #include \"merge.h\"",
            " #include \"vector.h\"",
            "+#include \"hashmap_oid.h\"",
            "+",
            "+GIT_HASHMAP_OID_FUNCTIONS(git_revwalk_oidmap, GIT_HASHMAP_INLINE, git_commit_list_node *);",
            " ",
            " static int get_revision(git_commit_list_node **out, git_revwalk *walk, git_commit_list **list);",
            " ",
            " git_commit_list_node *git_revwalk__commit_lookup(",
            " \tgit_revwalk *walk, const git_oid *oid)",
            " {",
            " \tgit_commit_list_node *commit;",
            " ",
            " \t/* lookup and reserve space if not already present */",
            "-\tif ((commit = git_oidmap_get(walk->commits, oid)) != NULL)",
            "+\tif (git_revwalk_oidmap_get(&commit, &walk->commits, oid) == 0)",
            " \t\treturn commit;",
            " ",
            " \tcommit = git_commit_list_alloc_node(walk);",
            " \tif (commit == NULL)",
            " \t\treturn NULL;",
            " ",
            " \tgit_oid_cpy(&commit->oid, oid);",
            " ",
            "-\tif ((git_oidmap_set(walk->commits, &commit->oid, commit)) < 0)",
            "+\tif (git_revwalk_oidmap_put(&walk->commits, &commit->oid, commit) < 0)",
            " \t\treturn NULL;",
            " ",
            " \treturn commit;",
            " }",
            " ",
            " int git_revwalk__push_commit(git_revwalk *walk, const git_oid *oid, const git_revwalk__push_options *opts)",
            " {",
            "@@ -619,15 +622,15 @@",
            " ",
            " \t/* If there were no pushes, we know that the walk is already over */",
            " \tif (!walk->did_push) {",
            " \t\tgit_error_clear();",
            " \t\treturn GIT_ITEROVER;",
            " \t}",
            " ",
            "-\t/* ",
            "+\t/*",
            " \t * This is a bit convoluted, but necessary to maintain the order of",
            " \t * the commits. This is especially important in situations where",
            " \t * git_revwalk__push_glob is called with a git_revwalk__push_options",
            " \t * setting insert_by_date = 1, which is critical for fetch negotiation.",
            " \t */",
            " \tfor (list = walk->user_input; list; list = list->next) {",
            " \t\tgit_commit_list_node *commit = list->item;",
            "@@ -639,21 +642,21 @@",
            " ",
            " \t\tif (!commit->seen) {",
            " \t\t\tgit_commit_list *new_list = NULL;",
            " \t\t\tif ((new_list = git_commit_list_create(commit, NULL)) == NULL) {",
            " \t\t\t\tgit_error_set_oom();",
            " \t\t\t\treturn -1;",
            " \t\t\t}",
            "-\t\t\t",
            "+",
            " \t\t\tcommit->seen = 1;",
            " \t\t\tif (commits_last == NULL)",
            " \t\t\t\tcommits = new_list;",
            " \t\t\telse",
            " \t\t\t\tcommits_last->next = new_list;",
            "-\t\t\t",
            "+",
            " \t\t\tcommits_last = new_list;",
            " \t\t}",
            " \t}",
            " ",
            " \tif (walk->limited && (error = limit_list(&commits, walk, commits)) < 0)",
            " \t\treturn error;",
            " ",
            "@@ -696,16 +699,15 @@",
            " ",
            " ",
            " int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)",
            " {",
            " \tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));",
            " \tGIT_ERROR_CHECK_ALLOC(walk);",
            " ",
            "-\tif (git_oidmap_new(&walk->commits) < 0 ||",
            "-\t    git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0 ||",
            "+\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0 ||",
            " \t    git_pool_init(&walk->commit_pool, COMMIT_ALLOC) < 0)",
            " \t\treturn -1;",
            " ",
            " \twalk->get_next = &revwalk_next_unsorted;",
            " \twalk->enqueue = &revwalk_enqueue_unsorted;",
            " ",
            " \twalk->repo = repo;",
            "@@ -723,15 +725,15 @@",
            " {",
            " \tif (walk == NULL)",
            " \t\treturn;",
            " ",
            " \tgit_revwalk_reset(walk);",
            " \tgit_odb_free(walk->odb);",
            " ",
            "-\tgit_oidmap_free(walk->commits);",
            "+\tgit_revwalk_oidmap_dispose(&walk->commits);",
            " \tgit_pool_clear(&walk->commit_pool);",
            " \tgit_pqueue_free(&walk->iterator_time);",
            " \tgit__free(walk);",
            " }",
            " ",
            " git_repository *git_revwalk_repository(git_revwalk *walk)",
            " {",
            "@@ -795,25 +797,26 @@",
            " ",
            " \treturn error;",
            " }",
            " ",
            " int git_revwalk_reset(git_revwalk *walk)",
            " {",
            " \tgit_commit_list_node *commit;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tGIT_ASSERT_ARG(walk);",
            " ",
            "-\tgit_oidmap_foreach_value(walk->commits, commit, {",
            "+\twhile (git_revwalk_oidmap_iterate(&iter, NULL, &commit, &walk->commits) == 0) {",
            " \t\tcommit->seen = 0;",
            " \t\tcommit->in_degree = 0;",
            " \t\tcommit->topo_delay = 0;",
            " \t\tcommit->uninteresting = 0;",
            " \t\tcommit->added = 0;",
            " \t\tcommit->flags = 0;",
            "-\t\t});",
            "+\t}",
            " ",
            " \tgit_pqueue_clear(&walk->iterator_time);",
            " \tgit_commit_list_free(&walk->iterator_topo);",
            " \tgit_commit_list_free(&walk->iterator_rand);",
            " \tgit_commit_list_free(&walk->iterator_reverse);",
            " \tgit_commit_list_free(&walk->user_input);",
            " \twalk->first_parent = 0;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/revwalk.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/revwalk.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/revwalk.h",
            "@@ -6,27 +6,27 @@",
            "  */",
            " #ifndef INCLUDE_revwalk_h__",
            " #define INCLUDE_revwalk_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"git2/revwalk.h\"",
            "-#include \"oidmap.h\"",
            " #include \"commit_list.h\"",
            " #include \"pqueue.h\"",
            " #include \"pool.h\"",
            " #include \"vector.h\"",
            "+#include \"hashmap_oid.h\"",
            " ",
            "-#include \"oidmap.h\"",
            "+GIT_HASHMAP_OID_STRUCT(git_revwalk_oidmap, git_commit_list_node *);",
            " ",
            " struct git_revwalk {",
            " \tgit_repository *repo;",
            " \tgit_odb *odb;",
            " ",
            "-\tgit_oidmap *commits;",
            "+\tgit_revwalk_oidmap commits;",
            " \tgit_pool commit_pool;",
            " ",
            " \tgit_commit_list *iterator_topo;",
            " \tgit_commit_list *iterator_rand;",
            " \tgit_commit_list *iterator_reverse;",
            " \tgit_pqueue iterator_time;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/settings.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/settings.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/settings.c",
            "@@ -218,14 +218,26 @@",
            " \t\t}",
            " #else",
            " \t\tgit_error_set(GIT_ERROR_SSL, \"TLS backend doesn't support certificate locations\");",
            " \t\terror = -1;",
            " #endif",
            " \t\tbreak;",
            " ",
            "+\tcase GIT_OPT_ADD_SSL_X509_CERT:",
            "+#ifdef GIT_OPENSSL",
            "+\t\t{",
            "+\t\t\tX509 *cert = va_arg(ap, X509 *);",
            "+\t\t\terror = git_openssl__add_x509_cert(cert);",
            "+\t\t}",
            "+#else",
            "+\t\tgit_error_set(GIT_ERROR_SSL, \"TLS backend doesn't support adding of the raw certs\");",
            "+\t\terror = -1;",
            "+#endif",
            "+\t\tbreak;",
            "+",
            " \tcase GIT_OPT_SET_USER_AGENT:",
            " \t\t{",
            " \t\t\tconst char *new_agent = va_arg(ap, const char *);",
            " ",
            " \t\t\tgit__free(git__user_agent);",
            " ",
            " \t\t\tif (new_agent) {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/signature.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/signature.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/signature.c",
            "@@ -6,14 +6,15 @@",
            "  */",
            " ",
            " #include \"signature.h\"",
            " ",
            " #include \"repository.h\"",
            " #include \"git2/common.h\"",
            " #include \"posix.h\"",
            "+#include \"date.h\"",
            " ",
            " void git_signature_free(git_signature *sig)",
            " {",
            " \tif (sig == NULL)",
            " \t\treturn;",
            " ",
            " \tgit__free(sig->name);",
            "@@ -148,44 +149,47 @@",
            " \tsignature->when.sign = source->when.sign;",
            " ",
            " \t*dest = signature;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-int git_signature_now(git_signature **sig_out, const char *name, const char *email)",
            "+static void current_time(time_t *now_out, int *offset_out)",
            " {",
            "-\ttime_t now;",
            " \ttime_t offset;",
            "-\tstruct tm *utc_tm;",
            "-\tgit_signature *sig;",
            "-\tstruct tm _utc;",
            "-",
            "-\t*sig_out = NULL;",
            "+\tstruct tm _utc, *utc_tm;",
            " ",
            " \t/*",
            " \t * Get the current time as seconds since the epoch and",
            " \t * transform that into a tm struct containing the time at",
            " \t * UTC. Give that to mktime which considers it a local time",
            " \t * (tm_isdst = -1 asks it to take DST into account) and gives",
            " \t * us that time as seconds since the epoch. The difference",
            " \t * between its return value and 'now' is our offset to UTC.",
            " \t */",
            "-\ttime(&now);",
            "-\tutc_tm = p_gmtime_r(&now, &_utc);",
            "+\ttime(now_out);",
            "+\tutc_tm = p_gmtime_r(now_out, &_utc);",
            " \tutc_tm->tm_isdst = -1;",
            "-\toffset = (time_t)difftime(now, mktime(utc_tm));",
            "+\toffset = (time_t)difftime(*now_out, mktime(utc_tm));",
            " \toffset /= 60;",
            " ",
            "-\tif (git_signature_new(&sig, name, email, now, (int)offset) < 0)",
            "-\t\treturn -1;",
            "+\t*offset_out = (int)offset;",
            "+}",
            "+",
            "+int git_signature_now(",
            "+\tgit_signature **sig_out,",
            "+\tconst char *name,",
            "+\tconst char *email)",
            "+{",
            "+\ttime_t now;",
            "+\tint offset;",
            " ",
            "-\t*sig_out = sig;",
            "+\tcurrent_time(&now, &offset);",
            " ",
            "-\treturn 0;",
            "+\treturn git_signature_new(sig_out, name, email, now, offset);",
            " }",
            " ",
            " int git_signature_default(git_signature **out, git_repository *repo)",
            " {",
            " \tint error;",
            " \tgit_config *cfg;",
            " \tconst char *user_name, *user_email;",
            "@@ -197,14 +201,128 @@",
            " \t\t!(error = git_config_get_string(&user_email, cfg, \"user.email\")))",
            " \t\terror = git_signature_now(out, user_name, user_email);",
            " ",
            " \tgit_config_free(cfg);",
            " \treturn error;",
            " }",
            " ",
            "+static int user_from_env(",
            "+\tgit_signature **out,",
            "+\tgit_repository *repo,",
            "+\tconst char *name_env_var,",
            "+\tconst char *email_env_var,",
            "+\tconst char *date_env_var,",
            "+\ttime_t default_time,",
            "+\tint default_offset)",
            "+{",
            "+\tint error;",
            "+\tgit_config *cfg;",
            "+\tconst char *name, *email, *date;",
            "+\tgit_time_t timestamp;",
            "+\tint offset;",
            "+\tgit_str name_env = GIT_STR_INIT;",
            "+\tgit_str email_env = GIT_STR_INIT;",
            "+\tgit_str date_env = GIT_STR_INIT;",
            "+",
            "+\tif ((error = git_repository_config_snapshot(&cfg, repo)) < 0)",
            "+\t\treturn error;",
            "+",
            "+\t/* Check if the environment variable for the name is set */",
            "+\tif (!(git__getenv(&name_env, name_env_var))) {",
            "+\t\tname = git_str_cstr(&name_env);",
            "+\t} else {",
            "+\t\t/* or else read the configuration value. */",
            "+\t\tif ((error = git_config_get_string(&name, cfg, \"user.name\")) < 0)",
            "+\t\t\tgoto done;",
            "+\t}",
            "+",
            "+\t/* Check if the environment variable for the email is set. */",
            "+\tif (!(git__getenv(&email_env, email_env_var))) {",
            "+\t\temail = git_str_cstr(&email_env);",
            "+\t} else {",
            "+\t\tif ((error = git_config_get_string(&email, cfg, \"user.email\")) == GIT_ENOTFOUND) {",
            "+\t\t\tgit_error *last_error;",
            "+",
            "+\t\t\tgit_error_save(&last_error);",
            "+",
            "+\t\t\tif ((error = git__getenv(&email_env, \"EMAIL\")) < 0) {",
            "+\t\t\t\tgit_error_restore(last_error);",
            "+\t\t\t\terror = GIT_ENOTFOUND;",
            "+\t\t\t\tgoto done;",
            "+\t\t\t}",
            "+",
            "+\t\t\temail = git_str_cstr(&email_env);",
            "+\t\t\tgit_error_free(last_error);",
            "+\t\t} else if (error < 0) {",
            "+\t\t\tgoto done;",
            "+\t\t}",
            "+\t}",
            "+",
            "+\t/* Check if the environment variable for the timestamp is set */",
            "+\tif (!(git__getenv(&date_env, date_env_var))) {",
            "+\t\tdate = git_str_cstr(&date_env);",
            "+",
            "+\t\tif ((error = git_date_offset_parse(&timestamp, &offset, date)) < 0)",
            "+\t\t\tgoto done;",
            "+\t} else {",
            "+\t\ttimestamp = default_time;",
            "+\t\toffset = default_offset;",
            "+\t}",
            "+",
            "+\terror = git_signature_new(out, name, email, timestamp, offset);",
            "+",
            "+done:",
            "+\tgit_config_free(cfg);",
            "+\tgit_str_dispose(&name_env);",
            "+\tgit_str_dispose(&email_env);",
            "+\tgit_str_dispose(&date_env);",
            "+\treturn error;",
            "+}",
            "+",
            "+int git_signature_default_from_env(",
            "+\tgit_signature **author_out,",
            "+\tgit_signature **committer_out,",
            "+\tgit_repository *repo)",
            "+{",
            "+\tgit_signature *author = NULL, *committer = NULL;",
            "+\ttime_t now;",
            "+\tint offset;",
            "+\tint error;",
            "+",
            "+\tGIT_ASSERT_ARG(author_out || committer_out);",
            "+\tGIT_ASSERT_ARG(repo);",
            "+",
            "+\tcurrent_time(&now, &offset);",
            "+",
            "+\tif (author_out &&",
            "+\t    (error = user_from_env(&author, repo, \"GIT_AUTHOR_NAME\",",
            "+\t\t\t\"GIT_AUTHOR_EMAIL\", \"GIT_AUTHOR_DATE\",",
            "+\t\t\tnow, offset)) < 0)",
            "+\t\tgoto on_error;",
            "+",
            "+\tif (committer_out &&",
            "+\t    (error = user_from_env(&committer, repo, \"GIT_COMMITTER_NAME\",",
            "+\t\t\t\"GIT_COMMITTER_EMAIL\", \"GIT_COMMITTER_DATE\",",
            "+\t\t\tnow, offset)) < 0)",
            "+\t\tgoto on_error;",
            "+",
            "+\tif (author_out)",
            "+\t\t*author_out = author;",
            "+",
            "+\tif (committer_out)",
            "+\t\t*committer_out = committer;",
            "+",
            "+\treturn 0;",
            "+",
            "+on_error:",
            "+\tgit__free(author);",
            "+\tgit__free(committer);",
            "+\treturn error;",
            "+}",
            "+",
            " int git_signature__parse(git_signature *sig, const char **buffer_out,",
            " \t\tconst char *buffer_end, const char *header, char ender)",
            " {",
            " \tconst char *buffer = *buffer_out;",
            " \tconst char *email_start, *email_end;",
            " ",
            " \tmemset(sig, 0, sizeof(git_signature));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/signature.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/signature.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/signature.h",
            "@@ -13,11 +13,10 @@",
            " #include \"git2/signature.h\"",
            " #include \"repository.h\"",
            " #include <time.h>",
            " ",
            " int git_signature__parse(git_signature *sig, const char **buffer_out, const char *buffer_end, const char *header, char ender);",
            " void git_signature__writebuf(git_str *buf, const char *header, const git_signature *sig);",
            " bool git_signature__equal(const git_signature *one, const git_signature *two);",
            "-",
            " int git_signature__pdup(git_signature **dest, const git_signature *source, git_pool *pool);",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/status.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/status.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/status.c",
            "@@ -410,15 +410,15 @@",
            " {",
            " \tif (status == NULL)",
            " \t\treturn;",
            " ",
            " \tgit_diff_free(status->head2idx);",
            " \tgit_diff_free(status->idx2wd);",
            " ",
            "-\tgit_vector_free_deep(&status->paired);",
            "+\tgit_vector_dispose_deep(&status->paired);",
            " ",
            " \tgit__memzero(status, sizeof(*status));",
            " \tgit__free(status);",
            " }",
            " ",
            " int git_status_foreach_ext(",
            " \tgit_repository *repo,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/streams/mbedtls.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/streams/mbedtls.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/streams/mbedtls.c",
            "@@ -35,16 +35,16 @@",
            " #include <mbedtls/ssl.h>",
            " #include <mbedtls/error.h>",
            " #include <mbedtls/entropy.h>",
            " #include <mbedtls/ctr_drbg.h>",
            " ",
            " #undef inline",
            " ",
            "-#define GIT_SSL_DEFAULT_CIPHERS \"TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256:TLS-DHE-DSS-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-DSS-WITH-AES-256-GCM-SHA384:TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256:TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA:TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA:TLS-DHE-RSA-WITH-AES-128-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-128-CBC-SHA:TLS-DHE-RSA-WITH-AES-256-CBC-SHA:TLS-DHE-DSS-WITH-AES-128-CBC-SHA256:TLS-DHE-DSS-WITH-AES-256-CBC-SHA256:TLS-DHE-DSS-WITH-AES-128-CBC-SHA:TLS-DHE-DSS-WITH-AES-256-CBC-SHA:TLS-RSA-WITH-AES-128-GCM-SHA256:TLS-RSA-WITH-AES-256-GCM-SHA384:TLS-RSA-WITH-AES-128-CBC-SHA256:TLS-RSA-WITH-AES-256-CBC-SHA256:TLS-RSA-WITH-AES-128-CBC-SHA:TLS-RSA-WITH-AES-256-CBC-SHA\"",
            "-#define GIT_SSL_DEFAULT_CIPHERS_COUNT 30",
            "+#define GIT_SSL_DEFAULT_CIPHERS \"TLS1-3-AES-128-GCM-SHA256:TLS1-3-AES-256-GCM-SHA384:TLS1-3-CHACHA20-POLY1305-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256:TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256:TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA:TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA:TLS-DHE-RSA-WITH-AES-128-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-RSA-WITH-AES-128-GCM-SHA256:TLS-RSA-WITH-AES-256-GCM-SHA384:TLS-RSA-WITH-AES-128-CBC-SHA256:TLS-RSA-WITH-AES-256-CBC-SHA256:TLS-RSA-WITH-AES-128-CBC-SHA:TLS-RSA-WITH-AES-256-CBC-SHA\"",
            "+#define GIT_SSL_DEFAULT_CIPHERS_COUNT 28",
            " ",
            " static int ciphers_list[GIT_SSL_DEFAULT_CIPHERS_COUNT];",
            " ",
            " static bool initialized = false;",
            " static mbedtls_ssl_config mbedtls_config;",
            " static mbedtls_ctr_drbg_context mbedtls_rng;",
            " static mbedtls_entropy_context mbedtls_entropy;",
            "@@ -90,15 +90,15 @@",
            " \t                                MBEDTLS_SSL_IS_CLIENT,",
            " \t                                MBEDTLS_SSL_TRANSPORT_STREAM,",
            " \t                                MBEDTLS_SSL_PRESET_DEFAULT) != 0) {",
            " \t\tgit_error_set(GIT_ERROR_SSL, \"failed to initialize mbedTLS\");",
            " \t\tgoto cleanup;",
            " \t}",
            " ",
            "-\t/* configure TLSv1.1 */",
            "+\t/* configure TLSv1.1 or better */",
            " #ifdef MBEDTLS_SSL_MINOR_VERSION_2",
            " \tmbedtls_ssl_conf_min_version(&mbedtls_config, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_2);",
            " #endif",
            " ",
            " \t/* verify_server_cert is responsible for making the check.",
            " \t * OPTIONAL because REQUIRED drops the certificate as soon as the check",
            " \t * is made, so we can never see the certificate and override it. */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/streams/openssl.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/streams/openssl.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/streams/openssl.c",
            "@@ -36,16 +36,15 @@",
            " # include <openssl/bio.h>",
            " #endif",
            " ",
            " extern char *git__ssl_ciphers;",
            " ",
            " SSL_CTX *git__ssl_ctx;",
            " ",
            "-#define GIT_SSL_DEFAULT_CIPHERS \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-DSS-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES128-SHA256:DHE-DSS-AES256-SHA256:DHE-DSS-AES128-SHA:DHE-DSS-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA\"",
            "-",
            "+#define GIT_SSL_DEFAULT_CIPHERS \"TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA\"",
            " ",
            " static BIO_METHOD *git_stream_bio_method;",
            " static int init_bio_method(void);",
            " ",
            " /**",
            "  * This function aims to clean-up the SSL context which",
            "  * we allocated.",
            "@@ -131,18 +130,18 @@",
            " \t\tallocators_initialized = true;",
            " \t}",
            " #endif",
            " ",
            " \tOPENSSL_init_ssl(0, NULL);",
            " ",
            " \t/*",
            "-\t * Load SSLv{2,3} and TLSv1 so that we can talk with servers",
            "-\t * which use the SSL hellos, which are often used for",
            "-\t * compatibility. We then disable SSL so we only allow OpenSSL",
            "-\t * to speak TLSv1 to perform the encryption itself.",
            "+\t * Despite the name SSLv23_method, this is actually a version-",
            "+\t * flexible context, which honors the protocol versions",
            "+\t * specified in `ssl_opts`. So we only support TLSv1.0 and",
            "+\t * higher.",
            " \t */",
            " \tif (!(git__ssl_ctx = SSL_CTX_new(SSLv23_method())))",
            " \t\tgoto error;",
            " ",
            " \tSSL_CTX_set_options(git__ssl_ctx, ssl_opts);",
            " \tSSL_CTX_set_mode(git__ssl_ctx, SSL_MODE_AUTO_RETRY);",
            " \tSSL_CTX_set_verify(git__ssl_ctx, SSL_VERIFY_NONE, NULL);",
            "@@ -718,14 +717,38 @@",
            " \t\t\terrmsg);",
            " ",
            " \t\treturn -1;",
            " \t}",
            " \treturn 0;",
            " }",
            " ",
            "+int git_openssl__add_x509_cert(X509 *cert)",
            "+{",
            "+\tX509_STORE *cert_store;",
            "+",
            "+\tif (openssl_ensure_initialized() < 0)",
            "+\t\treturn -1;",
            "+",
            "+\tif (!(cert_store = SSL_CTX_get_cert_store(git__ssl_ctx)))",
            "+\t\treturn -1;",
            "+",
            "+\tif (cert && X509_STORE_add_cert(cert_store, cert) == 0) {",
            "+\t\tgit_error_set(GIT_ERROR_SSL, \"OpenSSL error: failed to add raw X509 certificate\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+int git_openssl__reset_context(void)",
            "+{",
            "+\tshutdown_ssl();",
            "+\treturn openssl_init();",
            "+}",
            "+",
            " #else",
            " ",
            " #include \"stream.h\"",
            " #include \"git2/sys/openssl.h\"",
            " ",
            " int git_openssl_stream_global_init(void)",
            " {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/streams/openssl.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/streams/openssl.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/streams/openssl.h",
            "@@ -20,12 +20,14 @@",
            " # include <openssl/err.h>",
            " # include <openssl/x509v3.h>",
            " # include <openssl/bio.h>",
            " # endif",
            " ",
            " #ifdef GIT_OPENSSL",
            " extern int git_openssl__set_cert_location(const char *file, const char *path);",
            "+extern int git_openssl__add_x509_cert(X509 *cert);",
            "+extern int git_openssl__reset_context(void);",
            " extern int git_openssl_stream_new(git_stream **out, const char *host, const char *port);",
            " extern int git_openssl_stream_wrap(git_stream **out, git_stream *in, const char *host);",
            " #endif",
            " ",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/streams/openssl_dynamic.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/streams/openssl_dynamic.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/streams/openssl_dynamic.c",
            "@@ -61,14 +61,15 @@",
            " void (*SSL_set_bio)(SSL *ssl, BIO *rbio, BIO *wbio);",
            " int (*SSL_shutdown)(SSL *ssl);",
            " int (*SSL_write)(SSL *ssl, const void *buf, int num);",
            " ",
            " long (*SSL_CTX_ctrl)(SSL_CTX *ctx, int cmd, long larg, void *parg);",
            " void (*SSL_CTX_free)(SSL_CTX *ctx);",
            " SSL_CTX *(*SSL_CTX_new)(const SSL_METHOD *method);",
            "+X509_STORE *(*SSL_CTX_get_cert_store)(const SSL_CTX *);",
            " int (*SSL_CTX_set_cipher_list)(SSL_CTX *ctx, const char *str);",
            " int (*SSL_CTX_set_default_verify_paths)(SSL_CTX *ctx);",
            " long (*SSL_CTX_set_options)(SSL_CTX *ctx, long options);",
            " void (*SSL_CTX_set_verify)(SSL_CTX *ctx, int mode, int (*verify_callback)(int, X509_STORE_CTX *));",
            " int (*SSL_CTX_load_verify_locations)(SSL_CTX *ctx, const char *CAfile, const char *CApath);",
            " ",
            " const SSL_METHOD *(*SSLv23_method)(void);",
            "@@ -76,14 +77,15 @@",
            " ",
            " ASN1_STRING *(*X509_NAME_ENTRY_get_data)(const X509_NAME_ENTRY *ne);",
            " X509_NAME_ENTRY *(*X509_NAME_get_entry)(X509_NAME *name, int loc);",
            " int (*X509_NAME_get_index_by_NID)(X509_NAME *name, int nid, int lastpos);",
            " void (*X509_free)(X509 *a);",
            " void *(*X509_get_ext_d2i)(const X509 *x, int nid, int *crit, int *idx);",
            " X509_NAME *(*X509_get_subject_name)(const X509 *x);",
            "+int (*X509_STORE_add_cert)(X509_STORE *ctx, X509 *x);",
            " ",
            " int (*i2d_X509)(X509 *a, unsigned char **ppout);",
            " ",
            " int (*OPENSSL_sk_num)(const void *sk);",
            " void *(*OPENSSL_sk_value)(const void *sk, int i);",
            " void (*OPENSSL_sk_free)(void *sk);",
            " ",
            "@@ -190,14 +192,15 @@",
            " \tif (!(SSL_get_peer_certificate = (X509 *(*)(const SSL *))openssl_sym(&err, \"SSL_get_peer_certificate\", false))) {",
            " \t\tSSL_get_peer_certificate = (X509 *(*)(const SSL *))openssl_sym(&err, \"SSL_get1_peer_certificate\", true);",
            " \t}",
            " ",
            " \tSSL_CTX_ctrl = (long (*)(SSL_CTX *, int, long, void *))openssl_sym(&err, \"SSL_CTX_ctrl\", true);",
            " \tSSL_CTX_free = (void (*)(SSL_CTX *))openssl_sym(&err, \"SSL_CTX_free\", true);",
            " \tSSL_CTX_new = (SSL_CTX *(*)(const SSL_METHOD *))openssl_sym(&err, \"SSL_CTX_new\", true);",
            "+\tSSL_CTX_get_cert_store = (X509_STORE *(*)(const SSL_CTX *))openssl_sym(&err, \"SSL_CTX_get_cert_store\", true);",
            " \tSSL_CTX_set_cipher_list = (int (*)(SSL_CTX *, const char *))openssl_sym(&err, \"SSL_CTX_set_cipher_list\", true);",
            " \tSSL_CTX_set_default_verify_paths = (int (*)(SSL_CTX *ctx))openssl_sym(&err, \"SSL_CTX_set_default_verify_paths\", true);",
            " \tSSL_CTX_set_options = (long (*)(SSL_CTX *, long))openssl_sym(&err, \"SSL_CTX_set_options\", false);",
            " \tSSL_CTX_set_verify = (void (*)(SSL_CTX *, int, int (*)(int, X509_STORE_CTX *)))openssl_sym(&err, \"SSL_CTX_set_verify\", true);",
            " \tSSL_CTX_load_verify_locations = (int (*)(SSL_CTX *, const char *, const char *))openssl_sym(&err, \"SSL_CTX_load_verify_locations\", true);",
            " ",
            " \tSSLv23_method = (const SSL_METHOD *(*)(void))openssl_sym(&err, \"SSLv23_method\", false);",
            "@@ -205,14 +208,15 @@",
            " ",
            " \tX509_NAME_ENTRY_get_data = (ASN1_STRING *(*)(const X509_NAME_ENTRY *))openssl_sym(&err, \"X509_NAME_ENTRY_get_data\", true);",
            " \tX509_NAME_get_entry = (X509_NAME_ENTRY *(*)(X509_NAME *, int))openssl_sym(&err, \"X509_NAME_get_entry\", true);",
            " \tX509_NAME_get_index_by_NID = (int (*)(X509_NAME *, int, int))openssl_sym(&err, \"X509_NAME_get_index_by_NID\", true);",
            " \tX509_free = (void (*)(X509 *))openssl_sym(&err, \"X509_free\", true);",
            " \tX509_get_ext_d2i = (void *(*)(const X509 *x, int nid, int *crit, int *idx))openssl_sym(&err, \"X509_get_ext_d2i\", true);",
            " \tX509_get_subject_name = (X509_NAME *(*)(const X509 *))openssl_sym(&err, \"X509_get_subject_name\", true);",
            "+\tX509_STORE_add_cert = (int (*)(X509_STORE *ctx, X509 *x))openssl_sym(&err, \"X509_STORE_add_cert\", true);",
            " ",
            " \ti2d_X509 = (int (*)(X509 *a, unsigned char **ppout))openssl_sym(&err, \"i2d_X509\", true);",
            " ",
            " \tif (err)",
            " \t\tgoto on_error;",
            " ",
            " \t/* Add legacy functionality */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/streams/openssl_dynamic.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/streams/openssl_dynamic.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/streams/openssl_dynamic.h",
            "@@ -200,14 +200,15 @@",
            " typedef void GENERAL_NAMES;",
            " typedef void SSL;",
            " typedef void SSL_CTX;",
            " typedef void SSL_METHOD;",
            " typedef void X509;",
            " typedef void X509_NAME;",
            " typedef void X509_NAME_ENTRY;",
            "+typedef void X509_STORE;",
            " typedef void X509_STORE_CTX;",
            " ",
            " typedef struct {",
            "     int length;",
            "     int type;",
            "     unsigned char *data;",
            "     long flags;",
            "@@ -305,14 +306,15 @@",
            " extern int (*SSL_write)(SSL *ssl, const void *buf, int num);",
            " ",
            " # define SSL_set_tlsext_host_name(s, name) SSL_ctrl((s), SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, (char *)(name));",
            " ",
            " extern long (*SSL_CTX_ctrl)(SSL_CTX *ctx, int cmd, long larg, void *parg);",
            " extern void (*SSL_CTX_free)(SSL_CTX *ctx);",
            " extern SSL_CTX *(*SSL_CTX_new)(const SSL_METHOD *method);",
            "+extern X509_STORE *(*SSL_CTX_get_cert_store)(const SSL_CTX *ctx);",
            " extern int (*SSL_CTX_set_cipher_list)(SSL_CTX *ctx, const char *str);",
            " extern int (*SSL_CTX_set_default_verify_paths)(SSL_CTX *ctx);",
            " extern long (*SSL_CTX_set_options)(SSL_CTX *ctx, long options);",
            " extern void (*SSL_CTX_set_verify)(SSL_CTX *ctx, int mode, int (*verify_callback)(int, X509_STORE_CTX *));",
            " extern int (*SSL_CTX_load_verify_locations)(SSL_CTX *ctx, const char *CAfile, const char *CApath);",
            " ",
            " # define SSL_CTX_set_mode(ctx, mode) SSL_CTX_ctrl((ctx), SSL_CTRL_MODE, (mode), NULL);",
            "@@ -322,14 +324,15 @@",
            " ",
            " extern ASN1_STRING *(*X509_NAME_ENTRY_get_data)(const X509_NAME_ENTRY *ne);",
            " extern X509_NAME_ENTRY *(*X509_NAME_get_entry)(X509_NAME *name, int loc);",
            " extern int (*X509_NAME_get_index_by_NID)(X509_NAME *name, int nid, int lastpos);",
            " extern void (*X509_free)(X509 *a);",
            " extern void *(*X509_get_ext_d2i)(const X509 *x, int nid, int *crit, int *idx);",
            " extern X509_NAME *(*X509_get_subject_name)(const X509 *x);",
            "+extern int (*X509_STORE_add_cert)(X509_STORE *ctx, X509 *x);",
            " ",
            " extern int (*i2d_X509)(X509 *a, unsigned char **ppout);",
            " ",
            " extern int (*OPENSSL_sk_num)(const void *sk);",
            " extern void *(*OPENSSL_sk_value)(const void *sk, int i);",
            " extern void (*OPENSSL_sk_free)(void *sk);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/streams/stransport.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/streams/stransport.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/streams/stransport.c",
            "@@ -9,36 +9,64 @@",
            " ",
            " #ifdef GIT_SECURE_TRANSPORT",
            " ",
            " #include <CoreFoundation/CoreFoundation.h>",
            " #include <Security/SecureTransport.h>",
            " #include <Security/SecCertificate.h>",
            " ",
            "+#include \"common.h\"",
            "+#include \"trace.h\"",
            " #include \"git2/transport.h\"",
            "-",
            " #include \"streams/socket.h\"",
            " ",
            " static int stransport_error(OSStatus ret)",
            " {",
            "-\tCFStringRef message;",
            "+\tCFStringRef message_ref = NULL;",
            "+\tconst char *message_cstr = NULL;",
            "+\tchar *message_ptr = NULL;",
            " ",
            " \tif (ret == noErr || ret == errSSLClosedGraceful) {",
            " \t\tgit_error_clear();",
            " \t\treturn 0;",
            " \t}",
            " ",
            " #if !TARGET_OS_IPHONE",
            "-\tmessage = SecCopyErrorMessageString(ret, NULL);",
            "-\tGIT_ERROR_CHECK_ALLOC(message);",
            "+\tmessage_ref = SecCopyErrorMessageString(ret, NULL);",
            "+\tGIT_ERROR_CHECK_ALLOC(message_ref);",
            "+",
            "+\t/*",
            "+\t * Attempt the cheap CFString conversion; this can return NULL",
            "+\t * when that would be expensive. In that case, call the more",
            "+\t * expensive function.",
            "+\t */",
            "+\tmessage_cstr = CFStringGetCStringPtr(message_ref, kCFStringEncodingUTF8);",
            "+",
            "+\tif (!message_cstr) {",
            "+\t\t/* Provide buffer to convert from UTF16 to UTF8 */",
            "+\t\tsize_t message_size = CFStringGetLength(message_ref) * 2 + 1;",
            "+",
            "+\t\tmessage_cstr = message_ptr = git__malloc(message_size);",
            "+\t\tGIT_ERROR_CHECK_ALLOC(message_ptr);",
            "+",
            "+\t\tif (!CFStringGetCString(message_ref, message_ptr, message_size, kCFStringEncodingUTF8)) {",
            "+\t\t\tgit_error_set(GIT_ERROR_NET, \"SecureTransport error: %d\", (unsigned int)ret);",
            "+\t\t\tgoto done;",
            "+\t\t}",
            "+\t}",
            "+",
            "+\tgit_error_set(GIT_ERROR_NET, \"SecureTransport error: %s\", message_cstr);",
            " ",
            "-\tgit_error_set(GIT_ERROR_NET, \"SecureTransport error: %s\", CFStringGetCStringPtr(message, kCFStringEncodingUTF8));",
            "-\tCFRelease(message);",
            "+done:",
            "+\tgit__free(message_ptr);",
            "+\tCFRelease(message_ref);",
            " #else",
            " \tgit_error_set(GIT_ERROR_NET, \"SecureTransport error: OSStatus %d\", (unsigned int)ret);",
            "-\tGIT_UNUSED(message);",
            "+\tGIT_UNUSED(message_ref);",
            "+\tGIT_UNUSED(message_cstr);",
            "+\tGIT_UNUSED(message_ptr);",
            " #endif",
            " ",
            " \treturn -1;",
            " }",
            " ",
            " typedef struct {",
            " \tgit_stream parent;",
            "@@ -232,14 +260,18 @@",
            " static ssize_t stransport_read(git_stream *stream, void *data, size_t len)",
            " {",
            " \tstransport_stream *st = (stransport_stream *)stream;",
            " \tsize_t processed;",
            " \tOSStatus ret;",
            " ",
            " \tif ((ret = SSLRead(st->ctx, data, len, &processed)) != noErr) {",
            "+\t\t/* This specific SecureTransport error is not well described */",
            "+\t\tif (ret == -9806)",
            "+\t\t\tgit_trace(GIT_TRACE_INFO, \"SecureTraceport error during SSLRead: returned -9806 (connection closed via error)\");",
            "+",
            " \t\tif (st->error == GIT_TIMEOUT)",
            " \t\t\treturn GIT_TIMEOUT;",
            " ",
            " \t\treturn stransport_error(ret);",
            " \t}",
            " ",
            " \treturn processed;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/submodule.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/submodule.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/submodule.c",
            "@@ -165,62 +165,70 @@",
            " \terror = 0;",
            " ",
            " out:",
            " \tgit_str_dispose(&dir);",
            " \treturn error;",
            " }",
            " ",
            "+GIT_HASHMAP_STR_SETUP(git_submodule_namemap, char *);",
            "+",
            " /**",
            "  * Release the name map returned by 'load_submodule_names'.",
            "  */",
            "-static void free_submodule_names(git_strmap *names)",
            "+static void free_submodule_names(git_submodule_namemap *names)",
            " {",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tconst char *key;",
            " \tchar *value;",
            " ",
            " \tif (names == NULL)",
            " \t\treturn;",
            " ",
            "-\tgit_strmap_foreach(names, key, value, {",
            "-\t\tgit__free((char *) key);",
            "+\twhile (git_submodule_namemap_iterate(&iter, &key, &value, names) == 0) {",
            "+\t\tgit__free((char *)key);",
            " \t\tgit__free(value);",
            "-\t});",
            "-\tgit_strmap_free(names);",
            "+\t}",
            "+",
            "+\tgit_submodule_namemap_dispose(names);",
            "+\tgit__free(names);",
            " ",
            " \treturn;",
            " }",
            " ",
            " /**",
            "  * Map submodule paths to names.",
            "  * TODO: for some use-cases, this might need case-folding on a",
            "  * case-insensitive filesystem",
            "  */",
            "-static int load_submodule_names(git_strmap **out, git_repository *repo, git_config *cfg)",
            "+static int load_submodule_names(git_submodule_namemap **out, git_repository *repo, git_config *cfg)",
            " {",
            " \tconst char *key = \"^submodule\\\\..*\\\\.path$\";",
            "+\tchar *value;",
            " \tgit_config_iterator *iter = NULL;",
            " \tgit_config_entry *entry;",
            " \tgit_str buf = GIT_STR_INIT;",
            "-\tgit_strmap *names;",
            "+\tgit_submodule_namemap *names;",
            " \tint isvalid, error;",
            " ",
            " \t*out = NULL;",
            " ",
            "-\tif ((error = git_strmap_new(&names)) < 0)",
            "+\tif ((names = git__calloc(1, sizeof(git_submodule_namemap))) == NULL) {",
            "+\t\terror = -1;",
            " \t\tgoto out;",
            "+\t}",
            " ",
            " \tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)",
            " \t\tgoto out;",
            " ",
            " \twhile ((error = git_config_next(&entry, iter)) == 0) {",
            " \t\tconst char *fdot, *ldot;",
            " \t\tfdot = strchr(entry->name, '.');",
            " \t\tldot = strrchr(entry->name, '.');",
            " ",
            "-\t\tif (git_strmap_exists(names, entry->value)) {",
            "+\t\tif (git_submodule_namemap_contains(names, entry->value)) {",
            " \t\t\tgit_error_set(GIT_ERROR_SUBMODULE,",
            " \t\t\t\t   \"duplicated submodule path '%s'\", entry->value);",
            " \t\t\terror = -1;",
            " \t\t\tgoto out;",
            " \t\t}",
            " ",
            " \t\tgit_str_clear(&buf);",
            "@@ -229,15 +237,20 @@",
            " \t\tif (isvalid < 0) {",
            " \t\t\terror = isvalid;",
            " \t\t\tgoto out;",
            " \t\t}",
            " \t\tif (!isvalid)",
            " \t\t\tcontinue;",
            " ",
            "-\t\tif ((error = git_strmap_set(names, git__strdup(entry->value), git_str_detach(&buf))) < 0) {",
            "+\t\tif ((value = git__strdup(entry->value)) == NULL) {",
            "+\t\t\terror = -1;",
            "+\t\t\tgoto out;",
            "+\t\t}",
            "+",
            "+\t\tif ((error = git_submodule_namemap_put(names, value, git_str_detach(&buf))) < 0) {",
            " \t\t\tgit_error_set(GIT_ERROR_NOMEMORY, \"error inserting submodule into hash table\");",
            " \t\t\terror = -1;",
            " \t\t\tgoto out;",
            " \t\t}",
            " \t}",
            " \tif (error == GIT_ITEROVER)",
            " \t\terror = 0;",
            "@@ -248,39 +261,51 @@",
            " out:",
            " \tfree_submodule_names(names);",
            " \tgit_str_dispose(&buf);",
            " \tgit_config_iterator_free(iter);",
            " \treturn error;",
            " }",
            " ",
            "-int git_submodule_cache_init(git_strmap **out, git_repository *repo)",
            "+GIT_HASHMAP_STR_FUNCTIONS(git_submodule_cache, GIT_HASHMAP_INLINE, git_submodule *);",
            "+",
            "+int git_submodule__map(git_submodule_cache *cache, git_repository *repo);",
            "+",
            "+int git_submodule_cache_init(git_submodule_cache **out, git_repository *repo)",
            " {",
            "+\tgit_submodule_cache *cache = NULL;",
            " \tint error = 0;",
            "-\tgit_strmap *cache = NULL;",
            "+",
            " \tGIT_ASSERT_ARG(out);",
            " \tGIT_ASSERT_ARG(repo);",
            "-\tif ((error = git_strmap_new(&cache)) < 0)",
            "-\t\treturn error;",
            "-\tif ((error = git_submodule__map(repo, cache)) < 0) {",
            "+",
            "+\tif ((cache = git__calloc(1, sizeof(git_submodule_cache))) == NULL)",
            "+\t\treturn -1;",
            "+",
            "+\tif ((error = git_submodule__map(cache, repo)) < 0) {",
            " \t\tgit_submodule_cache_free(cache);",
            " \t\treturn error;",
            " \t}",
            "+",
            " \t*out = cache;",
            " \treturn error;",
            " }",
            " ",
            "-int git_submodule_cache_free(git_strmap *cache)",
            "+int git_submodule_cache_free(git_submodule_cache *cache)",
            " {",
            " \tgit_submodule *sm = NULL;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            "+",
            " \tif (cache == NULL)",
            " \t\treturn 0;",
            "-\tgit_strmap_foreach_value(cache, sm, {",
            "+",
            "+\twhile (git_submodule_cache_iterate(&iter, NULL, &sm, cache) == 0)",
            " \t\tgit_submodule_free(sm);",
            "-\t});",
            "-\tgit_strmap_free(cache);",
            "+",
            "+\tgit_submodule_cache_dispose(cache);",
            "+\tgit__free(cache);",
            " \treturn 0;",
            " }",
            " ",
            " int git_submodule_lookup(",
            " \tgit_submodule **out, /* NULL if user only wants to test existence */",
            " \tgit_repository *repo,",
            " \tconst char *name)    /* trailing slash is allowed */",
            "@@ -288,30 +313,30 @@",
            " \treturn git_submodule__lookup_with_cache(out, repo, name, repo->submodule_cache);",
            " }",
            " ",
            " int git_submodule__lookup_with_cache(",
            " \tgit_submodule **out, /* NULL if user only wants to test existence */",
            " \tgit_repository *repo,",
            " \tconst char *name,    /* trailing slash is allowed */",
            "-\tgit_strmap *cache)",
            "+\tgit_submodule_cache *cache)",
            " {",
            " \tint error;",
            " \tunsigned int location;",
            " \tgit_submodule *sm;",
            " ",
            " \tGIT_ASSERT_ARG(repo);",
            " \tGIT_ASSERT_ARG(name);",
            " ",
            " \tif (repo->is_bare) {",
            " \t\tgit_error_set(GIT_ERROR_SUBMODULE, \"cannot get submodules without a working tree\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tif (cache != NULL) {",
            "-\t\tif ((sm = git_strmap_get(cache, name)) != NULL) {",
            "+\t\tif (git_submodule_cache_get(&sm, cache, name) == 0) {",
            " \t\t\tif (out) {",
            " \t\t\t\t*out = sm;",
            " \t\t\t\tGIT_REFCOUNT_INC(*out);",
            " \t\t\t}",
            " \t\t\treturn 0;",
            " \t\t}",
            " \t}",
            "@@ -430,65 +455,72 @@",
            " }",
            " ",
            " static void submodule_free_dup(void *sm)",
            " {",
            " \tgit_submodule_free(sm);",
            " }",
            " ",
            "-static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)",
            "+static int submodule_get_or_create(",
            "+\tgit_submodule **out,",
            "+\tgit_repository *repo,",
            "+\tgit_submodule_cache *cache,",
            "+\tconst char *name)",
            " {",
            " \tgit_submodule *sm = NULL;",
            " \tint error;",
            " ",
            "-\tif ((sm = git_strmap_get(map, name)) != NULL)",
            "+\tif (git_submodule_cache_get(&sm, cache, name) == 0)",
            " \t\tgoto done;",
            " ",
            " \t/* if the submodule doesn't exist yet in the map, create it */",
            " \tif ((error = submodule_alloc(&sm, repo, name)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tif ((error = git_strmap_set(map, sm->name, sm)) < 0) {",
            "+\tif ((error = git_submodule_cache_put(cache, sm->name, sm)) < 0) {",
            " \t\tgit_submodule_free(sm);",
            " \t\treturn error;",
            " \t}",
            " ",
            " done:",
            " \tGIT_REFCOUNT_INC(sm);",
            " \t*out = sm;",
            " \treturn 0;",
            " }",
            " ",
            "-static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)",
            "+static int submodules_from_index(",
            "+\tgit_submodule_cache *cache,",
            "+\tgit_index *idx,",
            "+\tgit_config *cfg)",
            " {",
            " \tint error;",
            " \tgit_iterator *i = NULL;",
            " \tconst git_index_entry *entry;",
            "-\tgit_strmap *names;",
            "+\tgit_submodule_namemap *names;",
            " ",
            " \tif ((error = load_submodule_names(&names, git_index_owner(idx), cfg)))",
            " \t\tgoto done;",
            " ",
            " \tif ((error = git_iterator_for_index(&i, git_index_owner(idx), idx, NULL)) < 0)",
            " \t\tgoto done;",
            " ",
            " \twhile (!(error = git_iterator_advance(&entry, i))) {",
            " \t\tgit_submodule *sm;",
            " ",
            "-\t\tif ((sm = git_strmap_get(map, entry->path)) != NULL) {",
            "+\t\tif (git_submodule_cache_get(&sm, cache, entry->path) == 0) {",
            " \t\t\tif (S_ISGITLINK(entry->mode))",
            " \t\t\t\tsubmodule_update_from_index_entry(sm, entry);",
            " \t\t\telse",
            " \t\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;",
            " \t\t} else if (S_ISGITLINK(entry->mode)) {",
            " \t\t\tconst char *name;",
            " ",
            "-\t\t\tif ((name = git_strmap_get(names, entry->path)) == NULL)",
            "+\t\t\tif (git_submodule_namemap_get((char **)&name, names, entry->path) != 0)",
            " \t\t\t\tname = entry->path;",
            " ",
            "-\t\t\tif (!submodule_get_or_create(&sm, git_index_owner(idx), map, name)) {",
            "+\t\t\tif (!submodule_get_or_create(&sm, git_index_owner(idx), cache, name)) {",
            " \t\t\t\tsubmodule_update_from_index_entry(sm, entry);",
            " \t\t\t\tgit_submodule_free(sm);",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            " \tif (error == GIT_ITEROVER)",
            "@@ -497,42 +529,45 @@",
            " done:",
            " \tgit_iterator_free(i);",
            " \tfree_submodule_names(names);",
            " ",
            " \treturn error;",
            " }",
            " ",
            "-static int submodules_from_head(git_strmap *map, git_tree *head, git_config *cfg)",
            "+static int submodules_from_head(",
            "+\tgit_submodule_cache *cache,",
            "+\tgit_tree *head,",
            "+\tgit_config *cfg)",
            " {",
            " \tint error;",
            " \tgit_iterator *i = NULL;",
            " \tconst git_index_entry *entry;",
            "-\tgit_strmap *names;",
            "+\tgit_submodule_namemap *names;",
            " ",
            " \tif ((error = load_submodule_names(&names, git_tree_owner(head), cfg)))",
            " \t\tgoto done;",
            " ",
            " \tif ((error = git_iterator_for_tree(&i, head, NULL)) < 0)",
            " \t\tgoto done;",
            " ",
            " \twhile (!(error = git_iterator_advance(&entry, i))) {",
            " \t\tgit_submodule *sm;",
            " ",
            "-\t\tif ((sm = git_strmap_get(map, entry->path)) != NULL) {",
            "+\t\tif (git_submodule_cache_get(&sm, cache, entry->path) == 0) {",
            " \t\t\tif (S_ISGITLINK(entry->mode))",
            " \t\t\t\tsubmodule_update_from_head_data(sm, entry->mode, &entry->id);",
            " \t\t\telse",
            " \t\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;",
            " \t\t} else if (S_ISGITLINK(entry->mode)) {",
            " \t\t\tconst char *name;",
            " ",
            "-\t\t\tif ((name = git_strmap_get(names, entry->path)) == NULL)",
            "+\t\t\tif (git_submodule_namemap_get((char **)&name, names, entry->path) != 0)",
            " \t\t\t\tname = entry->path;",
            " ",
            "-\t\t\tif (!submodule_get_or_create(&sm, git_tree_owner(head), map, name)) {",
            "+\t\t\tif (!submodule_get_or_create(&sm, git_tree_owner(head), cache, name)) {",
            " \t\t\t\tsubmodule_update_from_head_data(",
            " \t\t\t\t\tsm, entry->mode, &entry->id);",
            " \t\t\t\tgit_submodule_free(sm);",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            "@@ -545,30 +580,30 @@",
            " ",
            " \treturn error;",
            " }",
            " ",
            " /* If have_sm is true, sm is populated, otherwise map an repo are. */",
            " typedef struct {",
            " \tgit_config *mods;",
            "-\tgit_strmap *map;",
            "+\tgit_submodule_cache *cache;",
            " \tgit_repository *repo;",
            " } lfc_data;",
            " ",
            "-int git_submodule__map(git_repository *repo, git_strmap *map)",
            "+int git_submodule__map(git_submodule_cache *cache, git_repository *repo)",
            " {",
            " \tint error = 0;",
            " \tgit_index *idx = NULL;",
            " \tgit_tree *head = NULL;",
            " \tgit_str path = GIT_STR_INIT;",
            " \tgit_submodule *sm;",
            " \tgit_config *mods = NULL;",
            " \tbool has_workdir;",
            " ",
            "+\tGIT_ASSERT_ARG(cache);",
            " \tGIT_ASSERT_ARG(repo);",
            "-\tGIT_ASSERT_ARG(map);",
            " ",
            " \t/* get sources that we will need to check */",
            " \tif (git_repository_index(&idx, repo) < 0)",
            " \t\tgit_error_clear();",
            " \tif (git_repository_head_tree(&head, repo) < 0)",
            " \t\tgit_error_clear();",
            " ",
            "@@ -577,15 +612,15 @@",
            " \tif (has_workdir &&",
            " \t    (error = git_repository_workdir_path(&path, repo, GIT_MODULES_FILE)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \t/* add submodule information from .gitmodules */",
            " \tif (has_workdir) {",
            " \t\tlfc_data data = { 0 };",
            "-\t\tdata.map = map;",
            "+\t\tdata.cache = cache;",
            " \t\tdata.repo = repo;",
            " ",
            " \t\tif ((error = gitmodules_snapshot(&mods, repo)) < 0) {",
            " \t\t\tif (error == GIT_ENOTFOUND)",
            " \t\t\t\terror = 0;",
            " \t\t\tgoto cleanup;",
            " \t\t}",
            "@@ -593,27 +628,30 @@",
            " \t\tdata.mods = mods;",
            " \t\tif ((error = git_config_foreach(",
            " \t\t\t    mods, submodule_load_each, &data)) < 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " \t/* add back submodule information from index */",
            " \tif (mods && idx) {",
            "-\t\tif ((error = submodules_from_index(map, idx, mods)) < 0)",
            "+\t\tif ((error = submodules_from_index(cache, idx, mods)) < 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " \t/* add submodule information from HEAD */",
            " \tif (mods && head) {",
            "-\t\tif ((error = submodules_from_head(map, head, mods)) < 0)",
            "+\t\tif ((error = submodules_from_head(cache, head, mods)) < 0)",
            " \t\t\tgoto cleanup;",
            " \t}",
            " \t/* shallow scan submodules in work tree as needed */",
            " \tif (has_workdir) {",
            "-\t\tgit_strmap_foreach_value(map, sm, {",
            "-\t\t\t\tsubmodule_load_from_wd_lite(sm);",
            "-\t\t\t});",
            "+\t\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            "+",
            "+\t\twhile (git_submodule_cache_iterate(&iter, NULL, &sm, cache) == 0) {",
            "+\t\t\tif ((error = submodule_load_from_wd_lite(sm)) < 0)",
            "+\t\t\t\tgoto cleanup;",
            "+\t\t}",
            " \t}",
            " ",
            " cleanup:",
            " \tgit_config_free(mods);",
            " \t/* TODO: if we got an error, mark submodule config as invalid? */",
            " \tgit_index_free(idx);",
            " \tgit_tree_free(head);",
            "@@ -623,38 +661,41 @@",
            " ",
            " int git_submodule_foreach(",
            " \tgit_repository *repo,",
            " \tgit_submodule_cb callback,",
            " \tvoid *payload)",
            " {",
            " \tgit_vector snapshot = GIT_VECTOR_INIT;",
            "-\tgit_strmap *submodules;",
            "+\tgit_submodule_cache *submodules;",
            " \tgit_submodule *sm;",
            "+\tgit_hashmap_iter_t iter;",
            " \tint error;",
            " \tsize_t i;",
            " ",
            " \tif (repo->is_bare) {",
            " \t\tgit_error_set(GIT_ERROR_SUBMODULE, \"cannot get submodules without a working tree\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            "-\tif ((error = git_strmap_new(&submodules)) < 0)",
            "-\t\treturn error;",
            "+\tif ((submodules = git__calloc(1, sizeof(git_submodule_cache))) == NULL)",
            "+\t\treturn -1;",
            " ",
            "-\tif ((error = git_submodule__map(repo, submodules)) < 0)",
            "+\tif ((error = git_submodule__map(submodules, repo)) < 0)",
            " \t\tgoto done;",
            " ",
            "-\tif (!(error = git_vector_init(",
            "-\t\t\t&snapshot, git_strmap_size(submodules), submodule_cmp))) {",
            "-",
            "-\t\tgit_strmap_foreach_value(submodules, sm, {",
            "+\tif (!(error = git_vector_init(&snapshot,",
            "+\t\t\tgit_submodule_cache_size(submodules),",
            "+\t\t\tsubmodule_cmp))) {",
            "+\t\tfor (iter = GIT_HASHMAP_ITER_INIT;",
            "+\t\t     git_submodule_cache_iterate(&iter, NULL, &sm, submodules) == 0; ) {",
            " \t\t\tif ((error = git_vector_insert(&snapshot, sm)) < 0)",
            " \t\t\t\tbreak;",
            "+",
            " \t\t\tGIT_REFCOUNT_INC(sm);",
            "-\t\t});",
            "+\t\t}",
            " \t}",
            " ",
            " \tif (error < 0)",
            " \t\tgoto done;",
            " ",
            " \tgit_vector_uniq(&snapshot, submodule_free_dup);",
            " ",
            "@@ -664,20 +705,22 @@",
            " \t\t\tbreak;",
            " \t\t}",
            " \t}",
            " ",
            " done:",
            " \tgit_vector_foreach(&snapshot, i, sm)",
            " \t\tgit_submodule_free(sm);",
            "-\tgit_vector_free(&snapshot);",
            "+\tgit_vector_dispose(&snapshot);",
            " ",
            "-\tgit_strmap_foreach_value(submodules, sm, {",
            "+\tfor (iter = GIT_HASHMAP_ITER_INIT;",
            "+\t     git_submodule_cache_iterate(&iter, NULL, &sm, submodules) == 0; )",
            " \t\tgit_submodule_free(sm);",
            "-\t});",
            "-\tgit_strmap_free(submodules);",
            "+",
            "+\tgit_submodule_cache_dispose(submodules);",
            "+\tgit__free(submodules);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int submodule_repo_init(",
            " \tgit_repository **out,",
            " \tgit_repository *parent_repo,",
            "@@ -1334,19 +1377,19 @@",
            " ",
            " \t/* Copy over the remote callbacks */",
            " \tmemcpy(&clone_options.fetch_opts, &update_options.fetch_opts, sizeof(git_fetch_options));",
            " ",
            " \t/* Get the status of the submodule to determine if it is already initialized  */",
            " \tif ((error = git_submodule_status(&submodule_status, sm->repo, sm->name, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0)",
            " \t\tgoto done;",
            "-\t",
            "+",
            " \t/* If the submodule is configured but hasn't been added, skip it */",
            " \tif (submodule_status == GIT_SUBMODULE_STATUS_IN_CONFIG)",
            " \t        goto done;",
            "-\t",
            "+",
            " \t/*",
            " \t * If submodule work dir is not already initialized, check to see",
            " \t * what we need to do (initialize, clone, return error...)",
            " \t */",
            " \tif (submodule_status & GIT_SUBMODULE_STATUS_WD_UNINITIALIZED) {",
            " \t\t/*",
            " \t\t * Work dir is not initialized, check to see if the submodule",
            "@@ -2045,15 +2088,15 @@",
            " \treturn error;",
            " }",
            " ",
            " static int submodule_load_each(const git_config_entry *entry, void *payload)",
            " {",
            " \tlfc_data *data = payload;",
            " \tconst char *namestart, *property;",
            "-\tgit_strmap *map = data->map;",
            "+\tgit_submodule_cache *cache = data->cache;",
            " \tgit_str name = GIT_STR_INIT;",
            " \tgit_submodule *sm;",
            " \tint error, isvalid;",
            " ",
            " \tif (git__prefixcmp(entry->name, \"submodule.\") != 0)",
            " \t\treturn 0;",
            " ",
            "@@ -2076,28 +2119,28 @@",
            " ",
            " \t/*",
            " \t * Now that we have the submodule's name, we can use that to",
            " \t * figure out whether it's in the map. If it's not, we create",
            " \t * a new submodule, load the config and insert it. If it's",
            " \t * already inserted, we've already loaded it, so we skip.",
            " \t */",
            "-\tif (git_strmap_exists(map, name.ptr)) {",
            "+\tif (git_submodule_cache_contains(cache, name.ptr)) {",
            " \t\terror = 0;",
            " \t\tgoto done;",
            " \t}",
            " ",
            " \tif ((error = submodule_alloc(&sm, data->repo, name.ptr)) < 0)",
            " \t\tgoto done;",
            " ",
            " \tif ((error = submodule_read_config(sm, data->mods)) < 0) {",
            " \t\tgit_submodule_free(sm);",
            " \t\tgoto done;",
            " \t}",
            " ",
            "-\tif ((error = git_strmap_set(map, sm->name, sm)) < 0)",
            "+\tif ((error = git_submodule_cache_put(cache, sm->name, sm)) < 0)",
            " \t\tgoto done;",
            " ",
            " \terror = 0;",
            " ",
            " done:",
            " \tgit_str_dispose(&name);",
            " \treturn error;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/submodule.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/submodule.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/submodule.h",
            "@@ -8,14 +8,15 @@",
            " #define INCLUDE_submodule_h__",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"git2/submodule.h\"",
            " #include \"git2/repository.h\"",
            " #include \"futils.h\"",
            "+#include \"hashmap.h\"",
            " ",
            " /* Notes:",
            "  *",
            "  * Submodule information can be in four places: the index, the config files",
            "  * (both .git/config and .gitmodules), the HEAD tree, and the working",
            "  * directory.",
            "  *",
            "@@ -112,23 +113,25 @@",
            " \tGIT_SUBMODULE_STATUS__WD_NOT_SUBMODULE    = (1u << 26),",
            " \tGIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES = (1u << 27)",
            " };",
            " ",
            " #define GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(S) \\",
            " \t((S) & ~(0xFFFFFFFFu << 20))",
            " ",
            "+GIT_HASHMAP_STR_STRUCT(git_submodule_cache, git_submodule *);",
            "+",
            " /* Initialize an external submodule cache for the provided repo. */",
            "-extern int git_submodule_cache_init(git_strmap **out, git_repository *repo);",
            "+extern int git_submodule_cache_init(git_submodule_cache **out, git_repository *repo);",
            " ",
            " /* Release the resources of the submodule cache. */",
            "-extern int git_submodule_cache_free(git_strmap *cache);",
            "+extern int git_submodule_cache_free(git_submodule_cache *cache);",
            " ",
            " /* Submodule lookup with an explicit cache */",
            " extern int git_submodule__lookup_with_cache(",
            "-\tgit_submodule **out, git_repository *repo, const char *path, git_strmap *cache);",
            "+\tgit_submodule **out, git_repository *repo, const char *path, git_submodule_cache *cache);",
            " ",
            " /* Internal status fn returns status and optionally the various OIDs */",
            " extern int git_submodule__status(",
            " \tunsigned int *out_status,",
            " \tgit_oid *out_head_id,",
            " \tgit_oid *out_index_id,",
            " \tgit_oid *out_wd_id,",
            "@@ -141,18 +144,14 @@",
            " \tgit_submodule *submodule);",
            " ",
            " extern int git_submodule_parse_ignore(",
            " \tgit_submodule_ignore_t *out, const char *value);",
            " extern int git_submodule_parse_update(",
            " \tgit_submodule_update_t *out, const char *value);",
            " ",
            "-extern int git_submodule__map(",
            "-\tgit_repository *repo,",
            "-\tgit_strmap *map);",
            "-",
            " /**",
            "  * Check whether a submodule's name is valid.",
            "  *",
            "  * Check the path against the path validity rules, either the filesystem",
            "  * defaults (like checkout does) or whichever you want to compare against.",
            "  *",
            "  * @param repo the repository which contains the submodule"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/tag.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/tag.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/tag.c",
            "@@ -259,16 +259,18 @@",
            " }",
            " ",
            " static bool tag_name_is_valid(const char *tag_name)",
            " {",
            " \t/*",
            " \t * Discourage tag name starting with dash,",
            " \t * https://github.com/git/git/commit/4f0accd638b8d2",
            "+\t * and refuse to use HEAD as a tagname,",
            "+\t * https://github.com/git/git/commit/bbd445d5efd415",
            " \t */",
            "-\treturn tag_name[0] != '-';",
            "+\treturn tag_name[0] != '-' && git__strcmp(tag_name, \"HEAD\");",
            " }",
            " ",
            " static int git_tag_create__internal(",
            " \t\tgit_oid *oid,",
            " \t\tgit_repository *repo,",
            " \t\tconst char *tag_name,",
            " \t\tconst git_object *target,",
            "@@ -544,15 +546,15 @@",
            " ",
            " \tfilter.taglist = &taglist;",
            " \tfilter.pattern = pattern;",
            " ",
            " \terror = git_tag_foreach(repo, &tag_list_cb, (void *)&filter);",
            " ",
            " \tif (error < 0)",
            "-\t\tgit_vector_free(&taglist);",
            "+\t\tgit_vector_dispose(&taglist);",
            " ",
            " \ttag_names->strings =",
            " \t\t(char **)git_vector_detach(&tag_names->count, NULL, &taglist);",
            " ",
            " \treturn 0;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transaction.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transaction.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transaction.c",
            "@@ -4,15 +4,14 @@",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " ",
            " #include \"transaction.h\"",
            " ",
            " #include \"repository.h\"",
            "-#include \"strmap.h\"",
            " #include \"refdb.h\"",
            " #include \"pool.h\"",
            " #include \"reflog.h\"",
            " #include \"signature.h\"",
            " #include \"config.h\"",
            " ",
            " #include \"git2/transaction.h\"",
            "@@ -40,22 +39,24 @@",
            " \tconst char *message;",
            " \tgit_signature *sig;",
            " ",
            " \tunsigned int committed :1,",
            " \t\tremove :1;",
            " } transaction_node;",
            " ",
            "+GIT_HASHMAP_STR_SETUP(git_transaction_nodemap, transaction_node *);",
            "+",
            " struct git_transaction {",
            " \ttransaction_t type;",
            " \tgit_repository *repo;",
            " \tgit_refdb *db;",
            " \tgit_config *cfg;",
            " \tvoid *cfg_data;",
            " ",
            "-\tgit_strmap *locks;",
            "+\tgit_transaction_nodemap locks;",
            " \tgit_pool pool;",
            " };",
            " ",
            " int git_transaction_config_new(",
            " \tgit_transaction **out,",
            " \tgit_config *cfg,",
            " \tvoid *data)",
            "@@ -90,19 +91,14 @@",
            " ",
            " \ttx = git_pool_mallocz(&pool, sizeof(git_transaction));",
            " \tif (!tx) {",
            " \t\terror = -1;",
            " \t\tgoto on_error;",
            " \t}",
            " ",
            "-\tif ((error = git_strmap_new(&tx->locks)) < 0) {",
            "-\t\terror = -1;",
            "-\t\tgoto on_error;",
            "-\t}",
            "-",
            " \tif ((error = git_repository_refdb(&tx->db, repo)) < 0)",
            " \t\tgoto on_error;",
            " ",
            " \ttx->type = TRANSACTION_REFS;",
            " \tmemcpy(&tx->pool, &pool, sizeof(git_pool));",
            " \ttx->repo = repo;",
            " \t*out = tx;",
            "@@ -126,30 +122,33 @@",
            " ",
            " \tnode->name = git_pool_strdup(&tx->pool, refname);",
            " \tGIT_ERROR_CHECK_ALLOC(node->name);",
            " ",
            " \tif ((error = git_refdb_lock(&node->payload, tx->db, refname)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tif ((error = git_strmap_set(tx->locks, node->name, node)) < 0)",
            "+\tif ((error = git_transaction_nodemap_put(&tx->locks, node->name, node)) < 0)",
            " \t\tgoto cleanup;",
            " ",
            " \treturn 0;",
            " ",
            " cleanup:",
            " \tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int find_locked(transaction_node **out, git_transaction *tx, const char *refname)",
            " {",
            " \ttransaction_node *node;",
            "+\tint error;",
            "+",
            "+\terror = git_transaction_nodemap_get(&node, &tx->locks, refname);",
            " ",
            "-\tif ((node = git_strmap_get(tx->locks, refname)) == NULL) {",
            "+\tif (error != 0) {",
            " \t\tgit_error_set(GIT_ERROR_REFERENCE, \"the specified reference is not locked\");",
            " \t\treturn GIT_ENOTFOUND;",
            " \t}",
            " ",
            " \t*out = node;",
            " \treturn 0;",
            " }",
            "@@ -330,27 +329,28 @@",
            " ",
            " \treturn error;",
            " }",
            " ",
            " int git_transaction_commit(git_transaction *tx)",
            " {",
            " \ttransaction_node *node;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " \tint error = 0;",
            " ",
            " \tGIT_ASSERT_ARG(tx);",
            " ",
            " \tif (tx->type == TRANSACTION_CONFIG) {",
            " \t\terror = git_config_unlock(tx->cfg, tx->cfg_data, true);",
            " \t\ttx->cfg = NULL;",
            " \t\ttx->cfg_data = NULL;",
            " ",
            " \t\treturn error;",
            " \t}",
            " ",
            "-\tgit_strmap_foreach_value(tx->locks, node, {",
            "+\twhile (git_transaction_nodemap_iterate(&iter, NULL, &node, &tx->locks) == 0) {",
            " \t\tif (node->reflog) {",
            " \t\t\tif ((error = tx->db->backend->reflog_write(tx->db->backend, node->reflog)) < 0)",
            " \t\t\t\treturn error;",
            " \t\t}",
            " ",
            " \t\tif (node->ref_type == GIT_REFERENCE_INVALID) {",
            " \t\t\t/* ref was locked but not modified */",
            "@@ -358,43 +358,44 @@",
            " \t\t\t\treturn error;",
            " \t\t\t}",
            " \t\t\tnode->committed = true;",
            " \t\t} else {",
            " \t\t\tif ((error = update_target(tx->db, node)) < 0)",
            " \t\t\t\treturn error;",
            " \t\t}",
            "-\t});",
            "+\t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " void git_transaction_free(git_transaction *tx)",
            " {",
            " \ttransaction_node *node;",
            " \tgit_pool pool;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tif (!tx)",
            " \t\treturn;",
            " ",
            " \tif (tx->type == TRANSACTION_CONFIG) {",
            " \t\tif (tx->cfg)",
            " \t\t\tgit_config_unlock(tx->cfg, tx->cfg_data, false);",
            " ",
            " \t\tgit__free(tx);",
            " \t\treturn;",
            " \t}",
            " ",
            " \t/* start by unlocking the ones we've left hanging, if any */",
            "-\tgit_strmap_foreach_value(tx->locks, node, {",
            "+\twhile (git_transaction_nodemap_iterate(&iter, NULL, &node, &tx->locks) == 0) {",
            " \t\tif (node->committed)",
            " \t\t\tcontinue;",
            " ",
            " \t\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);",
            "-\t});",
            "+\t}",
            " ",
            " \tgit_refdb_free(tx->db);",
            "-\tgit_strmap_free(tx->locks);",
            "+\tgit_transaction_nodemap_dispose(&tx->locks);",
            " ",
            " \t/* tx is inside the pool, so we need to extract the data */",
            " \tmemcpy(&pool, &tx->pool, sizeof(git_pool));",
            " \tgit_pool_clear(&pool);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transport.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transport.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transport.c",
            "@@ -199,15 +199,15 @@",
            " \t\t\tif ((error = git_vector_remove(&custom_transports, i)) < 0)",
            " \t\t\t\tgoto done;",
            " ",
            " \t\t\tgit__free(d->prefix);",
            " \t\t\tgit__free(d);",
            " ",
            " \t\t\tif (!custom_transports.length)",
            "-\t\t\t\tgit_vector_free(&custom_transports);",
            "+\t\t\t\tgit_vector_dispose(&custom_transports);",
            " ",
            " \t\t\terror = 0;",
            " \t\t\tgoto done;",
            " \t\t}",
            " \t}",
            " ",
            " \terror = GIT_ENOTFOUND;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/httpclient.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/httpclient.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/httpclient.c",
            "@@ -1438,17 +1438,17 @@",
            " \t\terror = -1;",
            " \t\tgoto done;",
            " \t}",
            " ",
            " \tgit_http_response_dispose(response);",
            " ",
            " \tif (client->current_server == PROXY) {",
            "-\t\tgit_vector_free_deep(&client->proxy.auth_challenges);",
            "+\t\tgit_vector_dispose_deep(&client->proxy.auth_challenges);",
            " \t} else if(client->current_server == SERVER) {",
            "-\t\tgit_vector_free_deep(&client->server.auth_challenges);",
            "+\t\tgit_vector_dispose_deep(&client->server.auth_challenges);",
            " \t}",
            " ",
            " \tclient->state = READING_RESPONSE;",
            " \tclient->keepalive = 0;",
            " \tclient->parser.data = &parser_context;",
            " ",
            " \tparser_context.client = client;",
            "@@ -1601,15 +1601,15 @@",
            " \t\tgit_stream_close(server->stream);",
            " \t\tgit_stream_free(server->stream);",
            " \t\tserver->stream = NULL;",
            " \t}",
            " ",
            " \tgit_net_url_dispose(&server->url);",
            " ",
            "-\tgit_vector_free_deep(&server->auth_challenges);",
            "+\tgit_vector_dispose_deep(&server->auth_challenges);",
            " \tfree_auth_context(server);",
            " }",
            " ",
            " static void http_client_close(git_http_client *client)",
            " {",
            " \thttp_server_close(&client->server);",
            " \thttp_server_close(&client->proxy);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/httpparser.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/httpparser.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/httpparser.c",
            "@@ -67,14 +67,16 @@",
            " size_t git_http_parser_execute(",
            " \tgit_http_parser *parser,",
            " \tconst char *data,",
            " \tsize_t len)",
            " {",
            " \tstruct http_parser_settings settings_proxy;",
            " ",
            "+\tmemset(&settings_proxy, 0, sizeof(struct http_parser_settings));",
            "+",
            " \tsettings_proxy.on_message_begin = parser->settings.on_message_begin ? on_message_begin : NULL;",
            " \tsettings_proxy.on_url = parser->settings.on_url ? on_url : NULL;",
            " \tsettings_proxy.on_header_field = parser->settings.on_header_field ? on_header_field : NULL;",
            " \tsettings_proxy.on_header_value = parser->settings.on_header_value ? on_header_value : NULL;",
            " \tsettings_proxy.on_headers_complete = parser->settings.on_headers_complete ? on_headers_complete : NULL;",
            " \tsettings_proxy.on_body = parser->settings.on_body ? on_body : NULL;",
            " \tsettings_proxy.on_message_complete = parser->settings.on_message_complete ? on_message_complete : NULL;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/local.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/local.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/local.c",
            "@@ -54,15 +54,15 @@",
            " {",
            " \tgit_remote_head *head;",
            " \tsize_t i;",
            " ",
            " \tgit_vector_foreach(heads, i, head)",
            " \t\tfree_head(head);",
            " ",
            "-\tgit_vector_free(heads);",
            "+\tgit_vector_dispose(heads);",
            " }",
            " ",
            " static int add_ref(transport_local *t, const char *name)",
            " {",
            " \tconst char peeled[] = \"^{}\";",
            " \tgit_reference *ref, *resolved;",
            " \tgit_remote_head *head;",
            "@@ -104,18 +104,14 @@",
            " \tgit_reference_free(ref);",
            " ",
            " \tif ((error = git_vector_insert(&t->refs, head)) < 0) {",
            " \t\tfree_head(head);",
            " \t\treturn error;",
            " \t}",
            " ",
            "-\t/* If it's not a tag, we don't need to try to peel it */",
            "-\tif (git__prefixcmp(name, GIT_REFS_TAGS_DIR))",
            "-\t\treturn 0;",
            "-",
            " \tif ((error = git_object_lookup(&obj, t->repo, &head->oid, GIT_OBJECT_ANY)) < 0)",
            " \t\treturn error;",
            " ",
            " \thead = NULL;",
            " ",
            " \t/* If it's not an annotated tag, or if we're mocking",
            " \t * git-receive-pack, just get out */",
            "@@ -182,15 +178,15 @@",
            " \t}",
            " ",
            " \tt->have_refs = 1;",
            " \tgit_strarray_dispose(&ref_names);",
            " \treturn 0;",
            " ",
            " on_error:",
            "-\tgit_vector_free(&t->refs);",
            "+\tgit_vector_dispose(&t->refs);",
            " \tgit_strarray_dispose(&ref_names);",
            " \treturn -1;",
            " }",
            " ",
            " /*",
            "  * Try to open the url as a git directory. The direction doesn't",
            "  * matter in this case because we're calculating the heads ourselves."
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/smart.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/smart.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/smart.c",
            "@@ -120,15 +120,15 @@",
            " \tsize_t i;",
            " ",
            " \tgit_vector_foreach(symrefs, i, spec) {",
            " \t\tgit_refspec__dispose(spec);",
            " \t\tgit__free(spec);",
            " \t}",
            " ",
            "-\tgit_vector_free(symrefs);",
            "+\tgit_vector_dispose(symrefs);",
            " }",
            " ",
            " static int git_smart__connect(",
            " \tgit_transport *transport,",
            " \tconst char *url,",
            " \tint direction,",
            " \tconst git_remote_connect_options *connect_opts)",
            "@@ -398,15 +398,15 @@",
            " \t}",
            " ",
            " \tret = git_smart__reset_stream(t, true);",
            " ",
            " \tgit_vector_foreach(common, i, p)",
            " \t\tgit_pkt_free(p);",
            " ",
            "-\tgit_vector_free(common);",
            "+\tgit_vector_dispose(common);",
            " ",
            " \tif (t->url) {",
            " \t\tgit__free(t->url);",
            " \t\tt->url = NULL;",
            " \t}",
            " ",
            " \tt->connected = 0;",
            "@@ -423,19 +423,19 @@",
            " ",
            " \t/* Make sure that the current stream is closed, if we have one. */",
            " \tgit_smart__close(transport);",
            " ",
            " \t/* Free the subtransport */",
            " \tt->wrapped->free(t->wrapped);",
            " ",
            "-\tgit_vector_free(&t->heads);",
            "+\tgit_vector_dispose(&t->heads);",
            " \tgit_vector_foreach(refs, i, p)",
            " \t\tgit_pkt_free(p);",
            " ",
            "-\tgit_vector_free(refs);",
            "+\tgit_vector_dispose(refs);",
            " ",
            " \tgit_remote_connect_options_dispose(&t->connect_opts);",
            " ",
            " \tgit_array_dispose(t->shallow_roots);",
            " ",
            " \tgit__free(t->caps.object_format);",
            " \tgit__free(t->caps.agent);",
            "@@ -520,16 +520,16 @@",
            " ",
            " \tt->owner = owner;",
            " \tt->rpc = definition->rpc;",
            " ",
            " \tif (git_vector_init(&t->refs, 16, ref_name_cmp) < 0 ||",
            " \t    git_vector_init(&t->heads, 16, ref_name_cmp) < 0 ||",
            " \t    definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {",
            "-\t\tgit_vector_free(&t->refs);",
            "-\t\tgit_vector_free(&t->heads);",
            "+\t\tgit_vector_dispose(&t->refs);",
            "+\t\tgit_vector_dispose(&t->heads);",
            " \t\tgit__free(t);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \tgit_staticstr_init(&t->buffer, GIT_SMART_BUFFER_SIZE);",
            " ",
            " \t*out = (git_transport *) t;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/smart_protocol.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/smart_protocol.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/smart_protocol.c",
            "@@ -313,14 +313,21 @@",
            " \tgit_pkt *pkt = NULL;",
            " \tint error;",
            " ",
            " \tdo {",
            " \t\tif ((error = recv_pkt(&pkt, NULL, t)) < 0)",
            " \t\t\treturn error;",
            " ",
            "+\t\tif (t->rpc && (pkt->type == GIT_PKT_SHALLOW ||",
            "+\t\t               pkt->type == GIT_PKT_UNSHALLOW ||",
            "+\t\t               pkt->type == GIT_PKT_FLUSH)) {",
            "+\t\t\tgit__free(pkt);",
            "+\t\t\tcontinue;",
            "+\t\t}",
            "+",
            " \t\tif (pkt->type != GIT_PKT_ACK) {",
            " \t\t\tgit__free(pkt);",
            " \t\t\treturn 0;",
            " \t\t}",
            " ",
            " \t\tif (git_vector_insert(&t->common, pkt) < 0) {",
            " \t\t\tgit__free(pkt);",
            "@@ -390,14 +397,15 @@",
            " ",
            " \tif (wants->shallow_roots_len > 0) {",
            " \t\tgit_array_init_to_size(*out, wants->shallow_roots_len);",
            " \t\tGIT_ERROR_CHECK_ALLOC(out->ptr);",
            " ",
            " \t\tmemcpy(out->ptr, wants->shallow_roots,",
            " \t\t       sizeof(git_oid) * wants->shallow_roots_len);",
            "+\t\tout->size = wants->shallow_roots_len;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " int git_smart__negotiate_fetch(",
            " \tgit_transport *transport,",
            "@@ -429,14 +437,17 @@",
            " ",
            " \tif (wants->depth > 0) {",
            " \t\tgit_pkt_shallow *pkt;",
            " ",
            " \t\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)",
            " \t\t\tgoto on_error;",
            " ",
            "+\t\tif (!t->rpc)",
            "+\t\t\tgit_str_clear(&data);",
            "+",
            " \t\twhile ((error = recv_pkt((git_pkt **)&pkt, NULL, t)) == 0) {",
            " \t\t\tbool complete = false;",
            " ",
            " \t\t\tif (pkt->type == GIT_PKT_SHALLOW) {",
            " \t\t\t\terror = git_oidarray__add(&t->shallow_roots, &pkt->oid);",
            " \t\t\t} else if (pkt->type == GIT_PKT_UNSHALLOW) {",
            " \t\t\t\tgit_oidarray__remove(&t->shallow_roots, &pkt->oid);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/ssh_exec.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/ssh_exec.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/ssh_exec.c",
            "@@ -154,17 +154,18 @@",
            " \tif ((error = git__getenv(&ssh_cmd, \"GIT_SSH\")) == 0)",
            " \t\t;",
            " \telse if (error != GIT_ENOTFOUND)",
            " \t\tgoto done;",
            " \telse if ((error = git_config__get_string_buf(&ssh_cmd, cfg, \"core.sshcommand\")) < 0 && error != GIT_ENOTFOUND)",
            " \t\tgoto done;",
            " ",
            "-\terror = git_str_printf(out, \"%s -p %s \\\"%s%s%s\\\" \\\"%s\\\" \\\"%s\\\"\",",
            "+\terror = git_str_printf(out, \"%s %s %s \\\"%s%s%s\\\" \\\"%s\\\" \\\"%s\\\"\",",
            " \t\tssh_cmd.size > 0 ? ssh_cmd.ptr : default_ssh_cmd,",
            "-\t\turl->port,",
            "+\t\turl->port_specified ? \"-p\" : \"\",",
            "+\t\turl->port_specified ? url->port : \"\",",
            " \t\turl->username ? url->username : \"\",",
            " \t\turl->username ? \"@\" : \"\",",
            " \t\turl->host,",
            " \t\tcommand,",
            " \t\turl->path);",
            " ",
            " done:"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/transports/ssh_libssh2.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/transports/ssh_libssh2.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/transports/ssh_libssh2.c",
            "@@ -111,16 +111,16 @@",
            " ",
            " static int ssh_stream_read(",
            " \tgit_smart_subtransport_stream *stream,",
            " \tchar *buffer,",
            " \tsize_t buf_size,",
            " \tsize_t *bytes_read)",
            " {",
            "-\tint rc;",
            " \tssh_stream *s = GIT_CONTAINER_OF(stream, ssh_stream, parent);",
            "+\tssize_t rc;",
            " ",
            " \t*bytes_read = 0;",
            " ",
            " \tif (!s->sent_command && send_command(s) < 0)",
            " \t\treturn -1;",
            " ",
            " \tif ((rc = libssh2_channel_read(s->channel, buffer, buf_size)) < LIBSSH2_ERROR_NONE) {",
            "@@ -131,23 +131,22 @@",
            " \t/*",
            " \t * If we can't get anything out of stdout, it's typically a",
            " \t * not-found error, so read from stderr and signal EOF on",
            " \t * stderr.",
            " \t */",
            " \tif (rc == 0) {",
            " \t\tif ((rc = libssh2_channel_read_stderr(s->channel, buffer, buf_size)) > 0) {",
            "-\t\t\tgit_error_set(GIT_ERROR_SSH, \"%*s\", rc, buffer);",
            "+\t\t\tgit_error_set(GIT_ERROR_SSH, \"%*s\", (int)rc, buffer);",
            " \t\t\treturn GIT_EEOF;",
            " \t\t} else if (rc < LIBSSH2_ERROR_NONE) {",
            " \t\t\tssh_error(s->session, \"SSH could not read stderr\");",
            " \t\t\treturn -1;",
            " \t\t}",
            " \t}",
            " ",
            "-",
            " \t*bytes_read = rc;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int ssh_stream_write(",
            " \tgit_smart_subtransport_stream *stream,",
            "@@ -512,14 +511,16 @@",
            " \tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_ED25519, \"ssh-ed25519\");",
            " #endif",
            " #ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_256",
            " \tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_ECDSA_256, \"ecdsa-sha2-nistp256\");",
            " \tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_ECDSA_384, \"ecdsa-sha2-nistp384\");",
            " \tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_ECDSA_521, \"ecdsa-sha2-nistp521\");",
            " #endif",
            "+\tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_SSHRSA, \"rsa-sha2-512\");",
            "+\tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_SSHRSA, \"rsa-sha2-256\");",
            " \tadd_hostkey_pref_if_avail(known_hosts, hostname, port, prefs, LIBSSH2_KNOWNHOST_KEY_SSHRSA, \"ssh-rsa\");",
            " }",
            " ",
            " static int _git_ssh_session_create(",
            " \tLIBSSH2_SESSION **session,",
            " \tLIBSSH2_KNOWNHOSTS **hosts,",
            " \tconst char *hostname,",
            "@@ -1011,15 +1012,16 @@",
            " ",
            " static int list_auth_methods(int *out, LIBSSH2_SESSION *session, const char *username)",
            " {",
            " \tconst char *list, *ptr;",
            " ",
            " \t*out = 0;",
            " ",
            "-\tlist = libssh2_userauth_list(session, username, strlen(username));",
            "+\tlist = libssh2_userauth_list(session, username,",
            "+\t\t\t(unsigned int)strlen(username));",
            " ",
            " \t/* either error, or the remote accepts NONE auth, which is bizarre, let's punt */",
            " \tif (list == NULL && !libssh2_userauth_authenticated(session)) {",
            " \t\tssh_error(session, \"remote rejected authentication\");",
            " \t\treturn GIT_EAUTH;",
            " \t}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/tree.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/tree.c",
            "+++ /home/libgit2-1.9.1/src/libgit2/tree.c",
            "@@ -17,14 +17,16 @@",
            " ",
            " #define DEFAULT_TREE_SIZE 16",
            " #define MAX_FILEMODE_BYTES 6",
            " ",
            " #define TREE_ENTRY_CHECK_NAMELEN(n) \\",
            " \tif (n > UINT16_MAX) { git_error_set(GIT_ERROR_INVALID, \"tree entry path too long\"); }",
            " ",
            "+GIT_HASHMAP_STR_FUNCTIONS(git_treebuilder_entrymap, GIT_HASHMAP_INLINE, git_tree_entry *);",
            "+",
            " static bool valid_filemode(const int filemode)",
            " {",
            " \treturn (filemode == GIT_FILEMODE_TREE",
            " \t\t|| filemode == GIT_FILEMODE_BLOB",
            " \t\t|| filemode == GIT_FILEMODE_BLOB_EXECUTABLE",
            " \t\t|| filemode == GIT_FILEMODE_LINK",
            " \t\t|| filemode == GIT_FILEMODE_COMMIT);",
            "@@ -343,15 +345,15 @@",
            " \treturn tree->entries.size;",
            " }",
            " ",
            " size_t git_treebuilder_entrycount(git_treebuilder *bld)",
            " {",
            " \tGIT_ASSERT_ARG_WITH_RETVAL(bld, 0);",
            " ",
            "-\treturn git_strmap_size(bld->map);",
            "+\treturn git_treebuilder_entrymap_size(&bld->map);",
            " }",
            " ",
            " GIT_INLINE(void) set_error(const char *str, const char *path)",
            " {",
            " \tif (path)",
            " \t\tgit_error_set(GIT_ERROR_TREE, \"%s - %s\", str, path);",
            " \telse",
            "@@ -508,29 +510,31 @@",
            " {",
            " \tint error = 0;",
            " \tsize_t i, entrycount;",
            " \tgit_odb *odb;",
            " \tgit_tree_entry *entry;",
            " \tgit_vector entries = GIT_VECTOR_INIT;",
            " \tsize_t oid_size = git_oid_size(bld->repo->oid_type);",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tgit_str_clear(buf);",
            " ",
            "-\tentrycount = git_strmap_size(bld->map);",
            "+\tentrycount = git_treebuilder_entrymap_size(&bld->map);",
            "+",
            " \tif ((error = git_vector_init(&entries, entrycount, entry_sort_cmp)) < 0)",
            " \t\tgoto out;",
            " ",
            " \tif (buf->asize == 0 &&",
            " \t    (error = git_str_grow(buf, entrycount * 72)) < 0)",
            " \t\tgoto out;",
            " ",
            "-\tgit_strmap_foreach_value(bld->map, entry, {",
            "+\twhile (git_treebuilder_entrymap_iterate(&iter, NULL, &entry, &bld->map) == 0) {",
            " \t\tif ((error = git_vector_insert(&entries, entry)) < 0)",
            " \t\t\tgoto out;",
            "-\t});",
            "+\t}",
            " ",
            " \tgit_vector_sort(&entries);",
            " ",
            " \tfor (i = 0; i < entries.length && !error; ++i) {",
            " \t\tentry = git_vector_get(&entries, i);",
            " ",
            " \t\tgit_str_printf(buf, \"%o \", entry->attr);",
            "@@ -543,15 +547,15 @@",
            " \t\t}",
            " \t}",
            " ",
            " \tif ((error = git_repository_odb__weakptr(&odb, bld->repo)) == 0)",
            " \t\terror = git_odb_write(oid, odb, buf->ptr, buf->size, GIT_OBJECT_TREE);",
            " ",
            " out:",
            "-\tgit_vector_free(&entries);",
            "+\tgit_vector_dispose(&entries);",
            " ",
            " \treturn error;",
            " }",
            " ",
            " static int append_entry(",
            " \tgit_treebuilder *bld,",
            " \tconst char *filename,",
            "@@ -566,15 +570,15 @@",
            " \t\treturn error;",
            " ",
            " \tentry = alloc_entry(filename, strlen(filename), id);",
            " \tGIT_ERROR_CHECK_ALLOC(entry);",
            " ",
            " \tentry->attr = (uint16_t)filemode;",
            " ",
            "-\tif ((error = git_strmap_set(bld->map, entry->filename, entry)) < 0) {",
            "+\tif ((error = git_treebuilder_entrymap_put(&bld->map, entry->filename, entry)) < 0) {",
            " \t\tgit_tree_entry_free(entry);",
            " \t\tgit_error_set(GIT_ERROR_TREE, \"failed to append entry %s to the tree builder\", filename);",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            "@@ -749,19 +753,14 @@",
            " \tGIT_ASSERT_ARG(repo);",
            " ",
            " \tbld = git__calloc(1, sizeof(git_treebuilder));",
            " \tGIT_ERROR_CHECK_ALLOC(bld);",
            " ",
            " \tbld->repo = repo;",
            " ",
            "-\tif (git_strmap_new(&bld->map) < 0) {",
            "-\t\tgit__free(bld);",
            "-\t\treturn -1;",
            "-\t}",
            "-",
            " \tif (source != NULL) {",
            " \t\tgit_tree_entry *entry_src;",
            " ",
            " \t\tgit_array_foreach(source->entries, i, entry_src) {",
            " \t\t\tif (append_entry(",
            " \t\t\t\tbld, entry_src->filename,",
            " \t\t\t\t&entry_src->oid,",
            "@@ -792,21 +791,21 @@",
            " \tGIT_ASSERT_ARG(bld);",
            " \tGIT_ASSERT_ARG(id);",
            " \tGIT_ASSERT_ARG(filename);",
            " ",
            " \tif ((error = check_entry(bld->repo, filename, id, filemode)) < 0)",
            " \t\treturn error;",
            " ",
            "-\tif ((entry = git_strmap_get(bld->map, filename)) != NULL) {",
            "+\tif (git_treebuilder_entrymap_get(&entry, &bld->map, filename) == 0) {",
            " \t\tgit_oid_cpy(&entry->oid, id);",
            " \t} else {",
            " \t\tentry = alloc_entry(filename, strlen(filename), id);",
            " \t\tGIT_ERROR_CHECK_ALLOC(entry);",
            " ",
            "-\t\tif ((error = git_strmap_set(bld->map, entry->filename, entry)) < 0) {",
            "+\t\tif (git_treebuilder_entrymap_put(&bld->map, entry->filename, entry) < 0) {",
            " \t\t\tgit_tree_entry_free(entry);",
            " \t\t\tgit_error_set(GIT_ERROR_TREE, \"failed to insert %s\", filename);",
            " \t\t\treturn -1;",
            " \t\t}",
            " \t}",
            " ",
            " \tentry->attr = filemode;",
            "@@ -815,33 +814,38 @@",
            " \t\t*entry_out = entry;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static git_tree_entry *treebuilder_get(git_treebuilder *bld, const char *filename)",
            " {",
            "+\tgit_tree_entry *entry;",
            "+",
            " \tGIT_ASSERT_ARG_WITH_RETVAL(bld, NULL);",
            " \tGIT_ASSERT_ARG_WITH_RETVAL(filename, NULL);",
            " ",
            "-\treturn git_strmap_get(bld->map, filename);",
            "+\tif (git_treebuilder_entrymap_get(&entry, &bld->map, filename) != 0)",
            "+\t\treturn NULL;",
            "+",
            "+\treturn entry;",
            " }",
            " ",
            " const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)",
            " {",
            " \treturn treebuilder_get(bld, filename);",
            " }",
            " ",
            " int git_treebuilder_remove(git_treebuilder *bld, const char *filename)",
            " {",
            " \tgit_tree_entry *entry = treebuilder_get(bld, filename);",
            " ",
            " \tif (entry == NULL)",
            " \t\treturn tree_error(\"failed to remove entry: file isn't in the tree\", filename);",
            " ",
            "-\tgit_strmap_delete(bld->map, filename);",
            "+\tgit_treebuilder_entrymap_remove(&bld->map, filename);",
            " \tgit_tree_entry_free(entry);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " int git_treebuilder_write(git_oid *oid, git_treebuilder *bld)",
            " {",
            "@@ -854,48 +858,52 @@",
            " int git_treebuilder_filter(",
            " \tgit_treebuilder *bld,",
            " \tgit_treebuilder_filter_cb filter,",
            " \tvoid *payload)",
            " {",
            " \tconst char *filename;",
            " \tgit_tree_entry *entry;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tGIT_ASSERT_ARG(bld);",
            " \tGIT_ASSERT_ARG(filter);",
            " ",
            "-\tgit_strmap_foreach(bld->map, filename, entry, {",
            "-\t\t\tif (filter(entry, payload)) {",
            "-\t\t\t\tgit_strmap_delete(bld->map, filename);",
            "-\t\t\t\tgit_tree_entry_free(entry);",
            "-\t\t\t}",
            "-\t});",
            "+\twhile (git_treebuilder_entrymap_iterate(&iter, &filename, &entry, &bld->map) == 0) {",
            "+\t\tif (filter(entry, payload)) {",
            "+\t\t\tgit_treebuilder_entrymap_remove(&bld->map, filename);",
            "+\t\t\tgit_tree_entry_free(entry);",
            "+\t\t}",
            "+\t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " int git_treebuilder_clear(git_treebuilder *bld)",
            " {",
            " \tgit_tree_entry *e;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tGIT_ASSERT_ARG(bld);",
            " ",
            "-\tgit_strmap_foreach_value(bld->map, e, git_tree_entry_free(e));",
            "-\tgit_strmap_clear(bld->map);",
            "+\twhile (git_treebuilder_entrymap_iterate(&iter, NULL, &e, &bld->map) == 0)",
            "+\t\tgit_tree_entry_free(e);",
            "+",
            "+\tgit_treebuilder_entrymap_clear(&bld->map);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " void git_treebuilder_free(git_treebuilder *bld)",
            " {",
            " \tif (bld == NULL)",
            " \t\treturn;",
            " ",
            " \tgit_str_dispose(&bld->write_cache);",
            " \tgit_treebuilder_clear(bld);",
            "-\tgit_strmap_free(bld->map);",
            "+\tgit_treebuilder_entrymap_dispose(&bld->map);",
            " \tgit__free(bld);",
            " }",
            " ",
            " static size_t subpath_len(const char *path)",
            " {",
            " \tconst char *slash_pos = strchr(path, '/');",
            " \tif (slash_pos == NULL)",
            "@@ -1308,15 +1316,15 @@",
            " \t\t\tgit_tree_free(e->tree);",
            " \t\t\tgit__free(e->name);",
            " \t\t}",
            " \t}",
            " ",
            " \tgit_str_dispose(&component);",
            " \tgit_array_clear(stack);",
            "-\tgit_vector_free(&entries);",
            "+\tgit_vector_dispose(&entries);",
            " \treturn error;",
            " }",
            " ",
            " /* Deprecated Functions */",
            " ",
            " #ifndef GIT_DEPRECATE_HARD"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/libgit2/tree.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/libgit2/tree.h",
            "+++ /home/libgit2-1.9.1/src/libgit2/tree.h",
            "@@ -9,15 +9,14 @@",
            " ",
            " #include \"common.h\"",
            " ",
            " #include \"git2/tree.h\"",
            " #include \"repository.h\"",
            " #include \"odb.h\"",
            " #include \"vector.h\"",
            "-#include \"strmap.h\"",
            " #include \"pool.h\"",
            " ",
            " struct git_tree_entry {",
            " \tuint16_t attr;",
            " \tuint16_t filename_len;",
            " \tgit_oid oid;",
            " \tconst char *filename;",
            "@@ -25,17 +24,19 @@",
            " ",
            " struct git_tree {",
            " \tgit_object object;",
            " \tgit_odb_object *odb_obj;",
            " \tgit_array_t(git_tree_entry) entries;",
            " };",
            " ",
            "+GIT_HASHMAP_STR_STRUCT(git_treebuilder_entrymap, git_tree_entry *);",
            "+",
            " struct git_treebuilder {",
            " \tgit_repository *repo;",
            "-\tgit_strmap *map;",
            "+\tgit_treebuilder_entrymap map;",
            " \tgit_str write_cache;",
            " };",
            " ",
            " GIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)",
            " {",
            " \treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/cc-compat.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/cc-compat.h",
            "+++ /home/libgit2-1.9.1/src/util/cc-compat.h",
            "@@ -40,17 +40,19 @@",
            " #if defined(__GNUC__)",
            " # define GIT_UNUSED(x)                                                         \\",
            " \tdo {                                                                   \\",
            " \t\t__typeof__(x) _unused __attribute__((unused));                 \\",
            " \t\t_unused = (x);                                                 \\",
            " \t} while (0)",
            " # define GIT_UNUSED_ARG __attribute__((unused))",
            "+# define GIT_UNUSED_FUNCTION __attribute__((unused))",
            " #else",
            " # define GIT_UNUSED(x) ((void)(x))",
            " # define GIT_UNUSED_ARG",
            "+# define GIT_UNUSED_FUNCTION",
            " #endif",
            " ",
            " /* Define the printf format specifier to use for size_t output */",
            " #if defined(_MSC_VER) || defined(__MINGW32__)",
            " ",
            " /* Visual Studio 2012 and prior lack PRId64 entirely */",
            " #\tifndef PRId64"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/date.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/date.c",
            "+++ /home/libgit2-1.9.1/src/util/date.c",
            "@@ -854,32 +854,40 @@",
            " \t}",
            " \tpending_number(&tm, &number);",
            " \tif (!touched)",
            " \t\t*error_ret = -1;",
            " \treturn update_tm(&tm, &now, 0);",
            " }",
            " ",
            "-int git_date_parse(git_time_t *out, const char *date)",
            "+int git_date_offset_parse(git_time_t *out, int *out_offset, const char *date)",
            " {",
            " \ttime_t time_sec;",
            " \tgit_time_t timestamp;",
            " \tint offset, error_ret=0;",
            " ",
            " \tif (!parse_date_basic(date, &timestamp, &offset)) {",
            " \t\t*out = timestamp;",
            "+\t\t*out_offset = offset;",
            " \t\treturn 0;",
            " \t}",
            " ",
            " \tif (time(&time_sec) == -1)",
            " \t\treturn -1;",
            " ",
            " \t*out = approxidate_str(date, time_sec, &error_ret);",
            " \treturn error_ret;",
            " }",
            " ",
            "+int git_date_parse(git_time_t *out, const char *date)",
            "+{",
            "+\tint offset;",
            "+",
            "+\treturn git_date_offset_parse(out, &offset, date);",
            "+}",
            "+",
            " int git_date_rfc2822_fmt(git_str *out, git_time_t time, int offset)",
            " {",
            " \ttime_t t;",
            " \tstruct tm gmt;",
            " ",
            " \tGIT_ASSERT_ARG(out);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/date.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/date.h",
            "+++ /home/libgit2-1.9.1/src/util/date.h",
            "@@ -7,16 +7,28 @@",
            " #ifndef INCLUDE_date_h__",
            " #define INCLUDE_date_h__",
            " ",
            " #include \"util.h\"",
            " #include \"str.h\"",
            " ",
            " /*",
            "+ * Parse a string into a value as a git_time_t with a timezone offset.",
            "+ *",
            "+ * Sample valid input:",
            "+ * - \"yesterday\"",
            "+ * - \"July 17, 2003\"",
            "+ * - \"2003-7-17 08:23i+03\"",
            "+ */",
            "+extern int git_date_offset_parse(git_time_t *out, int *out_offset, const char *date);",
            "+",
            "+/*",
            "  * Parse a string into a value as a git_time_t.",
            "  *",
            "+ * Timezone offset is ignored.",
            "+ *",
            "  * Sample valid input:",
            "  * - \"yesterday\"",
            "  * - \"July 17, 2003\"",
            "  * - \"2003-7-17 08:23\"",
            "  */",
            " extern int git_date_parse(git_time_t *out, const char *date);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/futils.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/futils.c",
            "+++ /home/libgit2-1.9.1/src/util/futils.c",
            "@@ -4,17 +4,17 @@",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " ",
            " #include \"futils.h\"",
            " ",
            " #include \"runtime.h\"",
            "-#include \"strmap.h\"",
            " #include \"hash.h\"",
            " #include \"rand.h\"",
            "+#include \"hashmap_str.h\"",
            " ",
            " #include <ctype.h>",
            " ",
            " #define GIT_FILEMODE_DEFAULT 0100666",
            " ",
            " int git_futils_mkpath2file(const char *file_path, const mode_t mode)",
            " {",
            "@@ -649,15 +649,16 @@",
            " \t\t\ttail++;",
            " ",
            " \t\t/* truncate path at next component */",
            " \t\tlastch = *tail;",
            " \t\t*tail = '\\0';",
            " \t\tst.st_mode = 0;",
            " ",
            "-\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))",
            "+\t\tif (opts->cache_pathset &&",
            "+\t\t    git_hashset_str_contains(opts->cache_pathset, make_path.ptr))",
            " \t\t\tcontinue;",
            " ",
            " \t\t/* See what's going on with this path component */",
            " \t\topts->perfdata.stat_calls++;",
            " ",
            " retry_lstat:",
            " \t\tif (p_lstat(make_path.ptr, &st) < 0) {",
            "@@ -684,25 +685,25 @@",
            " \t\t}",
            " ",
            " \t\t/* chmod if requested and necessary */",
            " \t\tif ((error = mkdir_validate_mode(",
            " \t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)",
            " \t\t\tgoto done;",
            " ",
            "-\t\tif (opts->dir_map && opts->pool) {",
            "+\t\tif (opts->cache_pathset && opts->cache_pool) {",
            " \t\t\tchar *cache_path;",
            " \t\t\tsize_t alloc_size;",
            " ",
            " \t\t\tGIT_ERROR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);",
            "-\t\t\tcache_path = git_pool_malloc(opts->pool, alloc_size);",
            "+\t\t\tcache_path = git_pool_malloc(opts->cache_pool, alloc_size);",
            " \t\t\tGIT_ERROR_CHECK_ALLOC(cache_path);",
            " ",
            " \t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);",
            " ",
            "-\t\t\tif ((error = git_strmap_set(opts->dir_map, cache_path, cache_path)) < 0)",
            "+\t\t\tif ((error = git_hashset_str_add(opts->cache_pathset, cache_path)) < 0)",
            " \t\t\t\tgoto done;",
            " \t\t}",
            " \t}",
            " ",
            " \terror = 0;",
            " ",
            " \t/* check that full path really is a directory if requested & needed */"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/futils.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/futils.h",
            "+++ /home/libgit2-1.9.1/src/util/futils.h",
            "@@ -9,16 +9,16 @@",
            " ",
            " #include \"git2_util.h\"",
            " ",
            " #include \"map.h\"",
            " #include \"posix.h\"",
            " #include \"fs_path.h\"",
            " #include \"pool.h\"",
            "-#include \"strmap.h\"",
            " #include \"hash.h\"",
            "+#include \"hashmap_str.h\"",
            " ",
            " /**",
            "  * Filebuffer methods",
            "  *",
            "  * Read whole files into an in-memory buffer for processing",
            "  */",
            " extern int git_futils_readbuffer(git_str *obj, const char *path);",
            "@@ -105,16 +105,25 @@",
            " \tsize_t stat_calls;",
            " \tsize_t mkdir_calls;",
            " \tsize_t chmod_calls;",
            " };",
            " ",
            " struct git_futils_mkdir_options",
            " {",
            "-\tgit_strmap *dir_map;",
            "-\tgit_pool *pool;",
            "+\t/*",
            "+\t * Callers can optionally pass an allocation pool and a",
            "+\t * hashset of strings; mkdir will populate these with the",
            "+\t * path(s) it creates; this can be useful for repeated calls",
            "+\t * to mkdir. This will reduce I/O by avoiding testing for the",
            "+\t * existence of intermediate directories that it knows already",
            "+\t * exist (because it created them).",
            "+\t */",
            "+\tgit_pool *cache_pool;",
            "+\tgit_hashset_str *cache_pathset;",
            "+",
            " \tstruct git_futils_mkdir_perfdata perfdata;",
            " };",
            " ",
            " /**",
            "  * Create a directory or entire path.",
            "  *",
            "  * This makes a directory (and the entire path leading up to it if requested),"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/git2_util.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/git2_util.h",
            "+++ /home/libgit2-1.9.1/src/util/git2_util.h",
            "@@ -45,14 +45,18 @@",
            "  */",
            " #if defined(__GNUC__)",
            " # define GIT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))",
            " #else",
            " # define GIT_WARN_UNUSED_RESULT",
            " #endif",
            " ",
            "+#if (defined(_WIN32)) && !defined(__CYGWIN__)",
            "+# define GIT_WIN32 1",
            "+#endif",
            "+",
            " #include <assert.h>",
            " #include <errno.h>",
            " #include <limits.h>",
            " #include <stdlib.h>",
            " #include <stdio.h>",
            " #include <string.h>"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/hash/builtin.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/hash/builtin.c",
            "+++ /home/libgit2-1.9.1/src/util/hash/builtin.c",
            "@@ -28,21 +28,31 @@",
            " \tif (SHA256Reset(&ctx->c)) {",
            " \t\tgit_error_set(GIT_ERROR_SHA, \"SHA256 error\");",
            " \t\treturn -1;",
            " \t}",
            " \treturn 0;",
            " }",
            " ",
            "-int git_hash_sha256_update(git_hash_sha256_ctx *ctx, const void *data, size_t len)",
            "+int git_hash_sha256_update(git_hash_sha256_ctx *ctx, const void *_data, size_t len)",
            " {",
            "+\tconst unsigned char *data = _data;",
            " \tGIT_ASSERT_ARG(ctx);",
            "-\tif (SHA256Input(&ctx->c, data, len)) {",
            "-\t\tgit_error_set(GIT_ERROR_SHA, \"SHA256 error\");",
            "-\t\treturn -1;",
            "+",
            "+\twhile (len > 0) {",
            "+\t\tunsigned int chunk = (len > UINT_MAX) ? UINT_MAX : (unsigned int)len;",
            "+",
            "+\t\tif (SHA256Input(&ctx->c, data, chunk)) {",
            "+\t\t\tgit_error_set(GIT_ERROR_SHA, \"SHA256 error\");",
            "+\t\t\treturn -1;",
            "+\t\t}",
            "+",
            "+\t\tdata += chunk;",
            "+\t\tlen -= chunk;",
            " \t}",
            "+",
            " \treturn 0;",
            " }",
            " ",
            " int git_hash_sha256_final(unsigned char *out, git_hash_sha256_ctx *ctx)",
            " {",
            " \tGIT_ASSERT_ARG(ctx);",
            " \tif (SHA256Result(&ctx->c, out)) {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/hash/openssl.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/hash/openssl.c",
            "+++ /home/libgit2-1.9.1/src/util/hash/openssl.c",
            "@@ -116,14 +116,88 @@",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " #endif",
            " ",
            "+#ifdef GIT_SHA1_OPENSSL_FIPS",
            "+",
            "+static const EVP_MD *SHA1_ENGINE_DIGEST_TYPE = NULL;",
            "+",
            "+int git_hash_sha1_global_init(void)",
            "+{",
            "+\tSHA1_ENGINE_DIGEST_TYPE = EVP_sha1();",
            "+\treturn SHA1_ENGINE_DIGEST_TYPE != NULL ? 0 : -1;",
            "+}",
            "+",
            "+int git_hash_sha1_ctx_init(git_hash_sha1_ctx *ctx)",
            "+{",
            "+\treturn git_hash_sha1_init(ctx);",
            "+}",
            "+",
            "+void git_hash_sha1_ctx_cleanup(git_hash_sha1_ctx *ctx)",
            "+{",
            "+#if OPENSSL_VERSION_NUMBER < 0x10100000L",
            "+\tEVP_MD_CTX_destroy(ctx->c);",
            "+#else",
            "+\tEVP_MD_CTX_free(ctx->c);",
            "+#endif",
            "+}",
            "+",
            "+int git_hash_sha1_init(git_hash_sha1_ctx *ctx)",
            "+{",
            "+\tGIT_ASSERT_ARG(ctx);",
            "+\tGIT_ASSERT(SHA1_ENGINE_DIGEST_TYPE);",
            "+",
            "+#if OPENSSL_VERSION_NUMBER < 0x10100000L",
            "+\tctx->c = EVP_MD_CTX_create();",
            "+#else",
            "+\tctx->c = EVP_MD_CTX_new();",
            "+#endif",
            "+",
            "+\tGIT_ASSERT(ctx->c);",
            "+",
            "+\tif (EVP_DigestInit_ex(ctx->c, SHA1_ENGINE_DIGEST_TYPE, NULL) != 1) {",
            "+\t\tgit_hash_sha1_ctx_cleanup(ctx);",
            "+\t\tgit_error_set(GIT_ERROR_SHA, \"failed to initialize sha1 context\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+int git_hash_sha1_update(git_hash_sha1_ctx *ctx, const void *data, size_t len)",
            "+{",
            "+\tGIT_ASSERT_ARG(ctx && ctx->c);",
            "+",
            "+\tif (EVP_DigestUpdate(ctx->c, data, len) != 1) {",
            "+\t\tgit_error_set(GIT_ERROR_SHA, \"failed to update sha1\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+int git_hash_sha1_final(unsigned char *out, git_hash_sha1_ctx *ctx)",
            "+{",
            "+\tunsigned int len = 0;",
            "+",
            "+\tGIT_ASSERT_ARG(ctx && ctx->c);",
            "+",
            "+\tif (EVP_DigestFinal(ctx->c, out, &len) != 1) {",
            "+\t\tgit_error_set(GIT_ERROR_SHA, \"failed to finalize sha1\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+#endif",
            "+",
            " #ifdef GIT_SHA256_OPENSSL",
            " ",
            " # ifdef GIT_OPENSSL_DYNAMIC",
            " static int (*SHA256_Init)(SHA256_CTX *c);",
            " static int (*SHA256_Update)(SHA256_CTX *c, const void *data, size_t len);",
            " static int (*SHA256_Final)(unsigned char *md, SHA256_CTX *c);",
            " #endif",
            "@@ -188,8 +262,82 @@",
            " \t\tgit_error_set(GIT_ERROR_SHA, \"failed to finalize sha256\");",
            " \t\treturn -1;",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "+#endif",
            "+",
            "+#ifdef GIT_SHA256_OPENSSL_FIPS",
            "+",
            "+static const EVP_MD *SHA256_ENGINE_DIGEST_TYPE = NULL;",
            "+",
            "+int git_hash_sha256_global_init(void)",
            "+{",
            "+\tSHA256_ENGINE_DIGEST_TYPE = EVP_sha256();",
            "+\treturn SHA256_ENGINE_DIGEST_TYPE != NULL ? 0 : -1;",
            "+}",
            "+",
            "+int git_hash_sha256_ctx_init(git_hash_sha256_ctx *ctx)",
            "+{",
            "+\treturn git_hash_sha256_init(ctx);",
            "+}",
            "+",
            "+void git_hash_sha256_ctx_cleanup(git_hash_sha256_ctx *ctx)",
            "+{",
            "+#if OPENSSL_VERSION_NUMBER < 0x10100000L",
            "+\tEVP_MD_CTX_destroy(ctx->c);",
            "+#else",
            "+\tEVP_MD_CTX_free(ctx->c);",
            "+#endif",
            "+}",
            "+",
            "+int git_hash_sha256_init(git_hash_sha256_ctx *ctx)",
            "+{",
            "+\tGIT_ASSERT_ARG(ctx);",
            "+\tGIT_ASSERT(SHA256_ENGINE_DIGEST_TYPE);",
            "+",
            "+#if OPENSSL_VERSION_NUMBER < 0x10100000L",
            "+\tctx->c = EVP_MD_CTX_create();",
            "+#else",
            "+\tctx->c = EVP_MD_CTX_new();",
            "+#endif",
            "+",
            "+\tGIT_ASSERT(ctx->c);",
            "+",
            "+\tif (EVP_DigestInit_ex(ctx->c, SHA256_ENGINE_DIGEST_TYPE, NULL) != 1) {",
            "+\t\tgit_hash_sha256_ctx_cleanup(ctx);",
            "+\t\tgit_error_set(GIT_ERROR_SHA, \"failed to initialize sha256 context\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+int git_hash_sha256_update(git_hash_sha256_ctx *ctx, const void *data, size_t len)",
            "+{",
            "+\tGIT_ASSERT_ARG(ctx && ctx->c);",
            "+",
            "+\tif (EVP_DigestUpdate(ctx->c, data, len) != 1) {",
            "+\t\tgit_error_set(GIT_ERROR_SHA, \"failed to update sha256\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+int git_hash_sha256_final(unsigned char *out, git_hash_sha256_ctx *ctx)",
            "+{",
            "+\tunsigned int len = 0;",
            "+",
            "+\tGIT_ASSERT_ARG(ctx && ctx->c);",
            "+",
            "+\tif (EVP_DigestFinal(ctx->c, out, &len) != 1) {",
            "+\t\tgit_error_set(GIT_ERROR_SHA, \"failed to finalize sha256\");",
            "+\t\treturn -1;",
            "+\t}",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/hash/openssl.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/hash/openssl.h",
            "+++ /home/libgit2-1.9.1/src/util/hash/openssl.h",
            "@@ -7,15 +7,19 @@",
            " ",
            " #ifndef INCLUDE_hash_openssl_h__",
            " #define INCLUDE_hash_openssl_h__",
            " ",
            " #include \"hash/sha.h\"",
            " ",
            " #ifndef GIT_OPENSSL_DYNAMIC",
            "-# include <openssl/sha.h>",
            "+# if defined(GIT_SHA1_OPENSSL_FIPS) || defined(GIT_SHA256_OPENSSL_FIPS)",
            "+#  include <openssl/evp.h>",
            "+# else",
            "+#  include <openssl/sha.h>",
            "+# endif",
            " #else",
            " ",
            " typedef struct {",
            " \tunsigned int h0, h1, h2, h3, h4;",
            " \tunsigned int Nl, Nh;",
            " \tunsigned int data[16];",
            " \tunsigned int num;",
            "@@ -32,14 +36,26 @@",
            " ",
            " #ifdef GIT_SHA1_OPENSSL",
            " struct git_hash_sha1_ctx {",
            " \tSHA_CTX c;",
            " };",
            " #endif",
            " ",
            "+#ifdef GIT_SHA1_OPENSSL_FIPS",
            "+struct git_hash_sha1_ctx {",
            "+\tEVP_MD_CTX* c;",
            "+};",
            "+#endif",
            "+",
            " #ifdef GIT_SHA256_OPENSSL",
            " struct git_hash_sha256_ctx {",
            " \tSHA256_CTX c;",
            " };",
            " #endif",
            " ",
            "+#ifdef GIT_SHA256_OPENSSL_FIPS",
            "+struct git_hash_sha256_ctx {",
            "+\tEVP_MD_CTX* c;",
            "+};",
            "+#endif",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/hash/sha.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/hash/sha.h",
            "+++ /home/libgit2-1.9.1/src/util/hash/sha.h",
            "@@ -13,15 +13,18 @@",
            " typedef struct git_hash_sha1_ctx git_hash_sha1_ctx;",
            " typedef struct git_hash_sha256_ctx git_hash_sha256_ctx;",
            " ",
            " #if defined(GIT_SHA1_COMMON_CRYPTO) || defined(GIT_SHA256_COMMON_CRYPTO)",
            " # include \"common_crypto.h\"",
            " #endif",
            " ",
            "-#if defined(GIT_SHA1_OPENSSL) || defined(GIT_SHA256_OPENSSL)",
            "+#if defined(GIT_SHA1_OPENSSL) || \\",
            "+    defined(GIT_SHA1_OPENSSL_FIPS) || \\",
            "+    defined(GIT_SHA256_OPENSSL) || \\",
            "+    defined(GIT_SHA256_OPENSSL_FIPS)",
            " # include \"openssl.h\"",
            " #endif",
            " ",
            " #if defined(GIT_SHA1_WIN32) || defined(GIT_SHA256_WIN32)",
            " # include \"win32.h\"",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/net.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/net.c",
            "+++ /home/libgit2-1.9.1/src/util/net.c",
            "@@ -383,14 +383,15 @@",
            " static int url_parse_finalize(git_net_url *url, git_net_url_parser *parser)",
            " {",
            " \tgit_str scheme = GIT_STR_INIT, user = GIT_STR_INIT,",
            " \t        password = GIT_STR_INIT, host = GIT_STR_INIT,",
            " \t        port = GIT_STR_INIT, path = GIT_STR_INIT,",
            " \t        query = GIT_STR_INIT, fragment = GIT_STR_INIT;",
            " \tconst char *default_port;",
            "+\tint port_specified = 0;",
            " \tint error = 0;",
            " ",
            " \tif (parser->scheme_len) {",
            " \t\tif ((error = git_str_put(&scheme, parser->scheme, parser->scheme_len)) < 0)",
            " \t\t\tgoto done;",
            " ",
            " \t\tgit__strntolower(scheme.ptr, scheme.size);",
            "@@ -404,18 +405,21 @@",
            " \t    (error = git_str_decode_percent(&password, parser->password, parser->password_len)) < 0)",
            " \t\tgoto done;",
            " ",
            " \tif (parser->host_len &&",
            " \t    (error = git_str_decode_percent(&host, parser->host, parser->host_len)) < 0)",
            " \t\tgoto done;",
            " ",
            "-\tif (parser->port_len)",
            "+\tif (parser->port_len) {",
            "+\t\tport_specified = 1;",
            " \t\terror = git_str_put(&port, parser->port, parser->port_len);",
            "-\telse if (parser->scheme_len && (default_port = default_port_for_scheme(scheme.ptr)) != NULL)",
            "+\t} else if (parser->scheme_len &&",
            "+\t           (default_port = default_port_for_scheme(scheme.ptr)) != NULL) {",
            " \t\terror = git_str_puts(&port, default_port);",
            "+\t}",
            " ",
            " \tif (error < 0)",
            " \t\tgoto done;",
            " ",
            " \tif (parser->path_len)",
            " \t\terror = git_str_put(&path, parser->path, parser->path_len);",
            " \telse if (parser->hierarchical)",
            "@@ -436,14 +440,15 @@",
            " \turl->host = git_str_detach(&host);",
            " \turl->port = git_str_detach(&port);",
            " \turl->path = git_str_detach(&path);",
            " \turl->query = git_str_detach(&query);",
            " \turl->fragment = git_str_detach(&fragment);",
            " \turl->username = git_str_detach(&user);",
            " \turl->password = git_str_detach(&password);",
            "+\turl->port_specified = port_specified;",
            " ",
            " \terror = 0;",
            " ",
            " done:",
            " \tgit_str_dispose(&scheme);",
            " \tgit_str_dispose(&user);",
            " \tgit_str_dispose(&password);",
            "@@ -781,18 +786,20 @@",
            " ",
            " \tif (user_len)",
            " \t\tGIT_ERROR_CHECK_ALLOC(url->username = git__strndup(user, user_len));",
            " ",
            " \tGIT_ASSERT(host_len);",
            " \tGIT_ERROR_CHECK_ALLOC(url->host = git__strndup(host, host_len));",
            " ",
            "-\tif (port_len)",
            "+\tif (port_len) {",
            "+\t\turl->port_specified = 1;",
            " \t\tGIT_ERROR_CHECK_ALLOC(url->port = git__strndup(port, port_len));",
            "-\telse",
            "+\t} else {",
            " \t\tGIT_ERROR_CHECK_ALLOC(url->port = git__strdup(default_port));",
            "+\t}",
            " ",
            " \tGIT_ASSERT(path);",
            " \tGIT_ERROR_CHECK_ALLOC(url->path = git__strdup(path));",
            " ",
            " \treturn 0;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/net.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/net.h",
            "+++ /home/libgit2-1.9.1/src/util/net.h",
            "@@ -31,14 +31,16 @@",
            " \tchar *host;",
            " \tchar *port;",
            " \tchar *path;",
            " \tchar *query;",
            " \tchar *fragment;",
            " \tchar *username;",
            " \tchar *password;",
            "+",
            "+\tunsigned int port_specified;",
            " } git_net_url;",
            " ",
            " #define GIT_NET_URL_INIT { NULL }",
            " ",
            " /** Is a given string a url? */",
            " extern bool git_net_str_is_url(const char *str);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/pool.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/pool.c",
            "+++ /home/libgit2-1.9.1/src/util/pool.c",
            "@@ -140,15 +140,15 @@",
            " \tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " void git_pool_clear(git_pool *pool)",
            " {",
            "-\tgit_vector_free_deep(&pool->allocations);",
            "+\tgit_vector_dispose_deep(&pool->allocations);",
            " }",
            " ",
            " static void *pool_alloc(git_pool *pool, size_t size) {",
            " \tvoid *ptr = NULL;",
            " \tif((ptr = git__malloc(size)) == NULL) {",
            " \t\treturn NULL;",
            " \t}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/pool.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/pool.h",
            "+++ /home/libgit2-1.9.1/src/util/pool.h",
            "@@ -79,14 +79,19 @@",
            "  *     my_item = git_pool_malloc(&pool, 1);",
            "  *",
            "  * Of course, you can use this in other ways, but those are the",
            "  * two most common patterns.",
            "  */",
            " extern int git_pool_init(git_pool *pool, size_t item_size);",
            " ",
            "+GIT_INLINE(bool) git_pool_is_initialized(git_pool *pool)",
            "+{",
            "+\treturn (pool->item_size > 0);",
            "+}",
            "+",
            " /**",
            "  * Free all items in pool",
            "  */",
            " extern void git_pool_clear(git_pool *pool);",
            " ",
            " /**",
            "  * Swap two pools with one another"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/pqueue.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/pqueue.h",
            "+++ /home/libgit2-1.9.1/src/util/pqueue.h",
            "@@ -29,15 +29,15 @@",
            "  */",
            " extern int git_pqueue_init(",
            " \tgit_pqueue *pq,",
            " \tuint32_t flags,",
            " \tsize_t init_size,",
            " \tgit_vector_cmp cmp);",
            " ",
            "-#define git_pqueue_free  git_vector_free",
            "+#define git_pqueue_free  git_vector_dispose",
            " #define git_pqueue_clear git_vector_clear",
            " #define git_pqueue_size  git_vector_length",
            " #define git_pqueue_get   git_vector_get",
            " #define git_pqueue_reverse git_vector_reverse",
            " ",
            " /**",
            "  * Insert a new item into the queue"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/sortedcache.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/sortedcache.c",
            "+++ /home/libgit2-1.9.1/src/util/sortedcache.c",
            "@@ -2,14 +2,15 @@",
            "  * Copyright (C) the libgit2 contributors. All rights reserved.",
            "  *",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " ",
            " #include \"sortedcache.h\"",
            "+#include \"hashmap.h\"",
            " ",
            " int git_sortedcache_new(",
            " \tgit_sortedcache **out,",
            " \tsize_t item_path_offset,",
            " \tgit_sortedcache_free_item_fn free_item,",
            " \tvoid *free_item_payload,",
            " \tgit_vector_cmp item_cmp,",
            "@@ -22,16 +23,15 @@",
            " ",
            " \tGIT_ERROR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);",
            " \tGIT_ERROR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);",
            " \tsc = git__calloc(1, alloclen);",
            " \tGIT_ERROR_CHECK_ALLOC(sc);",
            " ",
            " \tif (git_pool_init(&sc->pool, 1) < 0 ||",
            "-\t    git_vector_init(&sc->items, 4, item_cmp) < 0 ||",
            "-\t    git_strmap_new(&sc->map) < 0)",
            "+\t    git_vector_init(&sc->items, 4, item_cmp) < 0)",
            " \t\tgoto fail;",
            " ",
            " \tif (git_rwlock_init(&sc->lock)) {",
            " \t\tgit_error_set(GIT_ERROR_OS, \"failed to initialize lock\");",
            " \t\tgoto fail;",
            " \t}",
            " ",
            "@@ -42,16 +42,15 @@",
            " \tif (pathlen)",
            " \t\tmemcpy(sc->path, path, pathlen);",
            " ",
            " \t*out = sc;",
            " \treturn 0;",
            " ",
            " fail:",
            "-\tgit_strmap_free(sc->map);",
            "-\tgit_vector_free(&sc->items);",
            "+\tgit_vector_dispose(&sc->items);",
            " \tgit_pool_clear(&sc->pool);",
            " \tgit__free(sc);",
            " \treturn -1;",
            " }",
            " ",
            " void git_sortedcache_incref(git_sortedcache *sc)",
            " {",
            "@@ -61,15 +60,15 @@",
            " const char *git_sortedcache_path(git_sortedcache *sc)",
            " {",
            " \treturn sc->path;",
            " }",
            " ",
            " static void sortedcache_clear(git_sortedcache *sc)",
            " {",
            "-\tgit_strmap_clear(sc->map);",
            "+\tgit_hashmap_str_clear(&sc->map);",
            " ",
            " \tif (sc->free_item) {",
            " \t\tsize_t i;",
            " \t\tvoid *item;",
            " ",
            " \t\tgit_vector_foreach(&sc->items, i, item) {",
            " \t\t\tsc->free_item(sc->free_item_payload, item);",
            "@@ -84,16 +83,16 @@",
            " static void sortedcache_free(git_sortedcache *sc)",
            " {",
            " \t/* acquire write lock to make sure everyone else is done */",
            " \tif (git_sortedcache_wlock(sc) < 0)",
            " \t\treturn;",
            " ",
            " \tsortedcache_clear(sc);",
            "-\tgit_vector_free(&sc->items);",
            "-\tgit_strmap_free(sc->map);",
            "+\tgit_vector_dispose(&sc->items);",
            "+\tgit_hashmap_str_dispose(&sc->map);",
            " ",
            " \tgit_sortedcache_wunlock(sc);",
            " ",
            " \tgit_rwlock_free(&sc->lock);",
            " \tgit__free(sc);",
            " }",
            " ",
            "@@ -270,15 +269,15 @@",
            " int git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)",
            " {",
            " \tsize_t keylen, itemlen;",
            " \tint error = 0;",
            " \tchar *item_key;",
            " \tvoid *item;",
            " ",
            "-\tif ((item = git_strmap_get(sc->map, key)) != NULL)",
            "+\tif (git_hashmap_str_get(&item, &sc->map, key) == 0)",
            " \t\tgoto done;",
            " ",
            " \tkeylen  = strlen(key);",
            " \titemlen = sc->item_path_offset + keylen + 1;",
            " \titemlen = (itemlen + 7) & ~7;",
            " ",
            " \tif ((item = git_pool_mallocz(&sc->pool, itemlen)) == NULL) {",
            "@@ -290,30 +289,32 @@",
            " \t/* one strange thing is that even if the vector or hash table insert",
            " \t * fail, there is no way to free the pool item so we just abandon it",
            " \t */",
            " ",
            " \titem_key = ((char *)item) + sc->item_path_offset;",
            " \tmemcpy(item_key, key, keylen);",
            " ",
            "-\tif ((error = git_strmap_set(sc->map, item_key, item)) < 0)",
            "+\tif ((error = git_hashmap_str_put(&sc->map, item_key, item)) < 0)",
            " \t\tgoto done;",
            " ",
            " \tif ((error = git_vector_insert(&sc->items, item)) < 0)",
            "-\t\tgit_strmap_delete(sc->map, item_key);",
            "+\t\tgit_hashmap_str_remove(&sc->map, item_key);",
            " ",
            " done:",
            " \tif (out)",
            " \t\t*out = !error ? item : NULL;",
            " \treturn error;",
            " }",
            " ",
            " /* lookup item by key */",
            "-void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)",
            "+void *git_sortedcache_lookup(git_sortedcache *sc, const char *key)",
            " {",
            "-\treturn git_strmap_get(sc->map, key);",
            "+\tvoid *value;",
            "+",
            "+\treturn git_hashmap_str_get(&value, &sc->map, key) == 0 ? value : NULL;",
            " }",
            " ",
            " /* find out how many items are in the cache */",
            " size_t git_sortedcache_entrycount(const git_sortedcache *sc)",
            " {",
            " \treturn git_vector_length(&sc->items);",
            " }",
            "@@ -366,15 +367,15 @@",
            " \tif ((item = git_vector_get(&sc->items, pos)) == NULL) {",
            " \t\tgit_error_set(GIT_ERROR_INVALID, \"removing item out of range\");",
            " \t\treturn GIT_ENOTFOUND;",
            " \t}",
            " ",
            " \t(void)git_vector_remove(&sc->items, pos);",
            " ",
            "-\tgit_strmap_delete(sc->map, item + sc->item_path_offset);",
            "+\tgit_hashmap_str_remove(&sc->map, item + sc->item_path_offset);",
            " ",
            " \tif (sc->free_item)",
            " \t\tsc->free_item(sc->free_item_payload, item);",
            " ",
            " \treturn 0;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/sortedcache.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/sortedcache.h",
            "+++ /home/libgit2-1.9.1/src/util/sortedcache.h",
            "@@ -10,15 +10,15 @@",
            " #include \"git2_util.h\"",
            " ",
            " #include \"util.h\"",
            " #include \"futils.h\"",
            " #include \"vector.h\"",
            " #include \"thread.h\"",
            " #include \"pool.h\"",
            "-#include \"strmap.h\"",
            "+#include \"hashmap_str.h\"",
            " ",
            " #include <stddef.h>",
            " ",
            " /*",
            "  * The purpose of this data structure is to cache the parsed contents of a",
            "  * file (a.k.a. the backing file) where each item in the file can be",
            "  * identified by a key string and you want to both look them up by name",
            "@@ -32,15 +32,15 @@",
            " \tgit_refcount rc;",
            " \tgit_rwlock   lock;",
            " \tsize_t       item_path_offset;",
            " \tgit_sortedcache_free_item_fn free_item;",
            " \tvoid         *free_item_payload;",
            " \tgit_pool     pool;",
            " \tgit_vector   items;",
            "-\tgit_strmap   *map;",
            "+\tgit_hashmap_str map;",
            " \tgit_futils_filestamp stamp;",
            " \tchar         path[GIT_FLEX_ARRAY];",
            " } git_sortedcache;",
            " ",
            " /* Create a new sortedcache",
            "  *",
            "  * Even though every sortedcache stores items with a GIT_FLEX_ARRAY at",
            "@@ -159,15 +159,15 @@",
            " /* Lock sortedcache for read */",
            " GIT_WARN_UNUSED_RESULT int git_sortedcache_rlock(git_sortedcache *sc);",
            " ",
            " /* Unlock sorted cache when done with read */",
            " void git_sortedcache_runlock(git_sortedcache *sc);",
            " ",
            " /* Lookup item by key - returns NULL if not found */",
            "-void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key);",
            "+void *git_sortedcache_lookup(git_sortedcache *sc, const char *key);",
            " ",
            " /* Get how many items are in the cache",
            "  *",
            "  * You can call this function without holding a lock, but be aware",
            "  * that it may change before you use it.",
            "  */",
            " size_t git_sortedcache_entrycount(const git_sortedcache *sc);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/unix/process.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/unix/process.c",
            "+++ /home/libgit2-1.9.1/src/util/unix/process.c",
            "@@ -100,15 +100,15 @@",
            " \tgit_vector_insert(&merged, NULL);",
            " ",
            " \t*out = (char **)merged.contents;",
            " ",
            " \treturn 0;",
            " ",
            " on_error:",
            "-\tgit_vector_free_deep(&merged);",
            "+\tgit_vector_dispose_deep(&merged);",
            " \treturn error;",
            " }",
            " ",
            " int git_process_new(",
            " \tgit_process **out,",
            " \tconst char **args,",
            " \tsize_t args_len,"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/unix/realpath.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/unix/realpath.c",
            "+++ /home/libgit2-1.9.1/src/util/unix/realpath.c",
            "@@ -20,15 +20,15 @@",
            " ",
            " \tif ((result = realpath(pathname, resolved)) == NULL)",
            " \t\treturn NULL;",
            " ",
            " #ifdef __OpenBSD__",
            " \t/* The OpenBSD realpath function behaves differently,",
            " \t * figure out if the file exists */",
            "-\tif (access(ret, F_OK) < 0) {",
            "+\tif (access(result, F_OK) < 0) {",
            " \t\tif (!resolved)",
            " \t\t\tfree(result);",
            " ",
            " \t\treturn NULL;",
            " \t}",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/util.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/util.h",
            "+++ /home/libgit2-1.9.1/src/util/util.h",
            "│┄ Ordering differences only",
            "@@ -3,23 +3,23 @@",
            "  *",
            "  * This file is part of libgit2, distributed under the GNU GPL v2 with",
            "  * a Linking Exception. For full terms see the included COPYING file.",
            "  */",
            " #ifndef INCLUDE_util_h__",
            " #define INCLUDE_util_h__",
            " ",
            "-#ifndef GIT_WIN32",
            "-# include <ctype.h>",
            "-#endif",
            "-",
            " #include \"str.h\"",
            " #include \"git2_util.h\"",
            " #include \"strnlen.h\"",
            " #include \"thread.h\"",
            " ",
            "+#ifndef GIT_WIN32",
            "+# include <ctype.h>",
            "+#endif",
            "+",
            " #define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))",
            " #define bitsizeof(x) (CHAR_BIT * sizeof(x))",
            " #define MSB(x, bits) ((x) & (~UINT64_C(0) << (bitsizeof(x) - (bits))))",
            " #ifndef min",
            " # define min(a,b) ((a) < (b) ? (a) : (b))",
            " #endif",
            " #ifndef max"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/vector.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/vector.c",
            "+++ /home/libgit2-1.9.1/src/util/vector.c",
            "@@ -72,39 +72,39 @@",
            " \t\tv->_alloc_size = src->length;",
            " \t\tmemcpy(v->contents, src->contents, bytes);",
            " \t}",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-void git_vector_free(git_vector *v)",
            "+void git_vector_dispose(git_vector *v)",
            " {",
            " \tif (!v)",
            " \t\treturn;",
            " ",
            " \tgit__free(v->contents);",
            " \tv->contents = NULL;",
            " ",
            " \tv->length = 0;",
            " \tv->_alloc_size = 0;",
            " }",
            " ",
            "-void git_vector_free_deep(git_vector *v)",
            "+void git_vector_dispose_deep(git_vector *v)",
            " {",
            " \tsize_t i;",
            " ",
            " \tif (!v)",
            " \t\treturn;",
            " ",
            " \tfor (i = 0; i < v->length; ++i) {",
            " \t\tgit__free(v->contents[i]);",
            " \t\tv->contents[i] = NULL;",
            " \t}",
            " ",
            "-\tgit_vector_free(v);",
            "+\tgit_vector_dispose(v);",
            " }",
            " ",
            " int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)",
            " {",
            " \tGIT_ASSERT_ARG(v);",
            " ",
            " \tv->_alloc_size = 0;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/vector.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/vector.h",
            "+++ /home/libgit2-1.9.1/src/util/vector.h",
            "@@ -24,16 +24,16 @@",
            " \tuint32_t flags;",
            " } git_vector;",
            " ",
            " #define GIT_VECTOR_INIT {0}",
            " ",
            " GIT_WARN_UNUSED_RESULT int git_vector_init(",
            " \tgit_vector *v, size_t initial_size, git_vector_cmp cmp);",
            "-void git_vector_free(git_vector *v);",
            "-void git_vector_free_deep(git_vector *v); /* free each entry and self */",
            "+void git_vector_dispose(git_vector *v);",
            "+void git_vector_dispose_deep(git_vector *v); /* free each entry and self */",
            " void git_vector_clear(git_vector *v);",
            " GIT_WARN_UNUSED_RESULT int git_vector_dup(",
            " \tgit_vector *v, const git_vector *src, git_vector_cmp cmp);",
            " void git_vector_swap(git_vector *a, git_vector *b);",
            " int git_vector_size_hint(git_vector *v, size_t size_hint);",
            " ",
            " void **git_vector_detach(size_t *size, size_t *asize, git_vector *v);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/src/util/win32/posix_w32.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/src/util/win32/posix_w32.c",
            "+++ /home/libgit2-1.9.1/src/util/win32/posix_w32.c",
            "@@ -766,14 +766,15 @@",
            " ",
            " \tif (error == -1) {",
            " \t\tswitch (GetLastError()) {",
            " \t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open",
            " \t\t\t * handle to the directory.\"  This sounds like what everybody else calls",
            " \t\t\t * EBUSY.  Let's convert appropriate error codes.",
            " \t\t\t */",
            "+\t\t\tcase ERROR_ACCESS_DENIED:",
            " \t\t\tcase ERROR_SHARING_VIOLATION:",
            " \t\t\t\terrno = EBUSY;",
            " \t\t\t\tbreak;",
            " ",
            " \t\t\t/* This error can be returned when trying to rmdir an extant file. */",
            " \t\t\tcase ERROR_DIRECTORY:",
            " \t\t\t\terrno = ENOTDIR;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar/fixtures.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar/fixtures.h",
            "+++ /home/libgit2-1.9.1/tests/clar/clar/fixtures.h",
            "@@ -1,12 +1,12 @@",
            " #ifdef CLAR_FIXTURE_PATH",
            " static const char *",
            " fixture_path(const char *base, const char *fixture_name)",
            " {",
            "-\tstatic char _path[4096];",
            "+\tstatic char _path[CLAR_MAX_PATH];",
            " \tsize_t root_len;",
            " ",
            " \troot_len = strlen(base);",
            " \tstrncpy(_path, base, sizeof(_path));",
            " ",
            " \tif (_path[root_len - 1] != '/')",
            " \t\t_path[root_len++] = '/';",
            "@@ -24,15 +24,15 @@",
            " const char *cl_fixture(const char *fixture_name)",
            " {",
            " \treturn fixture_path(CLAR_FIXTURE_PATH, fixture_name);",
            " }",
            " ",
            " void cl_fixture_sandbox(const char *fixture_name)",
            " {",
            "-\tfs_copy(cl_fixture(fixture_name), _clar_path);",
            "+\tfs_copy(cl_fixture(fixture_name), clar_sandbox_path());",
            " }",
            " ",
            " const char *cl_fixture_basename(const char *fixture_name)",
            " {",
            " \tconst char *p;",
            " ",
            " \tfor (p = fixture_name; *p; p++) {",
            "@@ -41,10 +41,10 @@",
            " \t}",
            " ",
            " \treturn fixture_name;",
            " }",
            " ",
            " void cl_fixture_cleanup(const char *fixture_name)",
            " {",
            "-\tfs_rm(fixture_path(_clar_path, cl_fixture_basename(fixture_name)));",
            "+\tfs_rm(fixture_path(clar_sandbox_path(), cl_fixture_basename(fixture_name)));",
            " }",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar/fs.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar/fs.h",
            "+++ /home/libgit2-1.9.1/tests/clar/clar/fs.h",
            "@@ -4,20 +4,14 @@",
            "  * macOS, we avoid fcopyfile by default because it's slightly slower.",
            "  */",
            " #undef USE_FCOPYFILE",
            " #define USE_SENDFILE 1",
            " ",
            " #ifdef _WIN32",
            " ",
            "-#ifdef CLAR_WIN32_LONGPATHS",
            "-# define CLAR_MAX_PATH 4096",
            "-#else",
            "-# define CLAR_MAX_PATH MAX_PATH",
            "-#endif",
            "-",
            " #define RM_RETRY_COUNT\t5",
            " #define RM_RETRY_DELAY\t10",
            " ",
            " #ifdef __MINGW32__",
            " ",
            " /* These security-enhanced functions are not available",
            "  * in MinGW, so just use the vanilla ones */",
            "@@ -142,15 +136,15 @@",
            " \t\t\tlast_error = ERROR_SUCCESS;",
            " ",
            " \t\t/* Is the item gone? */",
            " \t\tif (ERROR_FILE_NOT_FOUND == last_error ||",
            " \t\t\tERROR_PATH_NOT_FOUND == last_error)",
            " \t\t\treturn 0;",
            " ",
            "-\t\tSleep(RM_RETRY_DELAY * retries * retries);\t",
            "+\t\tSleep(RM_RETRY_DELAY * retries * retries);",
            " \t}",
            " \twhile (retries++ <= RM_RETRY_COUNT);",
            " ",
            " \treturn -1;",
            " }",
            " ",
            " static void",
            "@@ -292,15 +286,17 @@",
            " \t\tcl_assert(CopyFileW(wsource, wdest, TRUE));",
            " }",
            " ",
            " void",
            " cl_fs_cleanup(void)",
            " {",
            " #ifdef CLAR_FIXTURE_PATH",
            "-\tfs_rm(fixture_path(_clar_path, \"*\"));",
            "+\tfs_rm(fixture_path(clar_tempdir_path(), \"*\"));",
            "+#else",
            "+\t((void)fs_copy); /* unused */",
            " #endif",
            " }",
            " ",
            " #else",
            " ",
            " #include <errno.h>",
            " #include <string.h>",
            "@@ -512,11 +508,11 @@",
            " \t\tcl_must_pass(unlink(path));",
            " \t}",
            " }",
            " ",
            " void",
            " cl_fs_cleanup(void)",
            " {",
            "-\tclar_unsandbox();",
            "-\tclar_sandbox();",
            "+\tclar_tempdir_shutdown();",
            "+\tclar_tempdir_init();",
            " }",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar/print.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar/print.h",
            "+++ /home/libgit2-1.9.1/tests/clar/clar/print.h",
            "@@ -17,15 +17,15 @@",
            " \tclar_report_all();",
            " }",
            " ",
            " static void clar_print_clap_error(int num, const struct clar_report *report, const struct clar_error *error)",
            " {",
            " \tprintf(\"  %d) Failure:\\n\", num);",
            " ",
            "-\tprintf(\"%s::%s [%s:%\"PRIuZ\"]\\n\",",
            "+\tprintf(\"%s::%s [%s:%\"PRIuMAX\"]\\n\",",
            " \t\treport->suite,",
            " \t\treport->test,",
            " \t\terror->file,",
            " \t\terror->line_number);",
            " ",
            " \tprintf(\"  %s\\n\", error->error_msg);",
            " ",
            "@@ -43,16 +43,16 @@",
            " ",
            " \tif (_clar.verbosity > 1) {",
            " \t\tprintf(\"%s::%s: \", suite_name, test_name);",
            " ",
            " \t\tswitch (status) {",
            " \t\tcase CL_TEST_OK: printf(\"ok\\n\"); break;",
            " \t\tcase CL_TEST_FAILURE: printf(\"fail\\n\"); break;",
            "-\t\tcase CL_TEST_SKIP: printf(\"skipped\"); break;",
            "-\t\tcase CL_TEST_NOTRUN: printf(\"notrun\"); break;",
            "+\t\tcase CL_TEST_SKIP: printf(\"skipped\\n\"); break;",
            "+\t\tcase CL_TEST_NOTRUN: printf(\"notrun\\n\"); break;",
            " \t\t}",
            " \t} else {",
            " \t\tswitch (status) {",
            " \t\tcase CL_TEST_OK: printf(\".\"); break;",
            " \t\tcase CL_TEST_FAILURE: printf(\"F\"); break;",
            " \t\tcase CL_TEST_SKIP: printf(\"S\"); break;",
            " \t\tcase CL_TEST_NOTRUN: printf(\"N\"); break;",
            "@@ -132,15 +132,15 @@",
            " \t\tprintf(\"      %s\\n\", error->error_msg);",
            " ",
            " \t\tif (error->description)",
            " \t\t\tprintf(\"      %s\\n\", error->description);",
            " ",
            " \t\tprintf(\"    at:\\n\");",
            " \t\tprintf(\"      file: '\"); print_escaped(error->file); printf(\"'\\n\");",
            "-\t\tprintf(\"      line: %\" PRIuZ \"\\n\", error->line_number);",
            "+\t\tprintf(\"      line: %\" PRIuMAX \"\\n\", error->line_number);",
            " \t\tprintf(\"      function: '%s'\\n\", error->function);",
            " \t\tprintf(\"    ---\\n\");",
            " ",
            " \t\tbreak;",
            " \tcase CL_TEST_SKIP:",
            " \tcase CL_TEST_NOTRUN:",
            " \t\tprintf(\"ok %d - # SKIP %s::%s\\n\", test_number, suite_name, test_name);",
            "@@ -198,14 +198,19 @@",
            " }",
            " ",
            " static void clar_print_onsuite(const char *suite_name, int suite_index)",
            " {",
            " \tPRINT(onsuite, suite_name, suite_index);",
            " }",
            " ",
            "+static void clar_print_onabortv(const char *msg, va_list argp)",
            "+{",
            "+\tPRINT(onabort, msg, argp);",
            "+}",
            "+",
            " static void clar_print_onabort(const char *msg, ...)",
            " {",
            " \tva_list argp;",
            " \tva_start(argp, msg);",
            "-\tPRINT(onabort, msg, argp);",
            "+\tclar_print_onabortv(msg, argp);",
            " \tva_end(argp);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar/sandbox.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar/sandbox.h",
            "+++ /home/libgit2-1.9.1/tests/clar/clar/sandbox.h",
            "@@ -1,67 +1,78 @@",
            " #ifdef __APPLE__",
            " #include <sys/syslimits.h>",
            " #endif",
            " ",
            "-#define CLAR_PATH_MAX 4096",
            "-static char _clar_path[CLAR_PATH_MAX];",
            "+/*",
            "+ * The tempdir is the temporary directory for the entirety of the clar",
            "+ * process execution. The sandbox is an individual temporary directory",
            "+ * for the execution of an individual test. Sandboxes are deleted",
            "+ * entirely after test execution to avoid pollution across tests.",
            "+ */",
            "+",
            "+static char _clar_tempdir[CLAR_MAX_PATH];",
            "+static size_t _clar_tempdir_len;",
            "+",
            "+static char _clar_sandbox[CLAR_MAX_PATH];",
            " ",
            " static int",
            " is_valid_tmp_path(const char *path)",
            " {",
            " \tSTAT_T st;",
            " ",
            " \tif (stat(path, &st) != 0)",
            " \t\treturn 0;",
            " ",
            " \tif (!S_ISDIR(st.st_mode))",
            " \t\treturn 0;",
            " ",
            "-\treturn (access(path, W_OK) == 0);",
            "+\tif (access(path, W_OK) != 0)",
            "+\t\treturn 0;",
            "+",
            "+\treturn (strlen(path) < CLAR_MAX_PATH);",
            " }",
            " ",
            " static int",
            " find_tmp_path(char *buffer, size_t length)",
            " {",
            " #ifndef _WIN32",
            " \tstatic const size_t var_count = 5;",
            " \tstatic const char *env_vars[] = {",
            " \t\t\"CLAR_TMP\", \"TMPDIR\", \"TMP\", \"TEMP\", \"USERPROFILE\"",
            "- \t};",
            "+\t};",
            " ",
            "- \tsize_t i;",
            "+\tsize_t i;",
            " ",
            " \tfor (i = 0; i < var_count; ++i) {",
            " \t\tconst char *env = getenv(env_vars[i]);",
            "+",
            " \t\tif (!env)",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (is_valid_tmp_path(env)) {",
            "-\t\t\tif (strlen(env) + 1 > CLAR_PATH_MAX)",
            "-\t\t\t\treturn -1;",
            "-",
            " \t\t\tstrncpy(buffer, env, length - 1);",
            " \t\t\tbuffer[length - 1] = '\\0';",
            " \t\t\treturn 0;",
            " \t\t}",
            " \t}",
            " ",
            " \t/* If the environment doesn't say anything, try to use /tmp */",
            " \tif (is_valid_tmp_path(\"/tmp\")) {",
            " \t\tstrncpy(buffer, \"/tmp\", length - 1);",
            " \t\tbuffer[length - 1] = '\\0';",
            " \t\treturn 0;",
            " \t}",
            " ",
            " #else",
            "-\tDWORD env_len = GetEnvironmentVariable(\"CLAR_TMP\", buffer, (DWORD)length);",
            "-\tif (env_len > 0 && env_len < (DWORD)length)",
            "+\tDWORD len = GetEnvironmentVariable(\"CLAR_TMP\", buffer, (DWORD)length);",
            "+\tif (len > 0 && len < (DWORD)length)",
            " \t\treturn 0;",
            " ",
            "-\tif (GetTempPath((DWORD)length, buffer))",
            "+\tlen = GetTempPath((DWORD)length, buffer);",
            "+\tif (len > 0 && len < (DWORD)length)",
            " \t\treturn 0;",
            " #endif",
            " ",
            " \t/* This system doesn't like us, try to use the current directory */",
            " \tif (is_valid_tmp_path(\".\")) {",
            " \t\tstrncpy(buffer, \".\", length - 1);",
            " \t\tbuffer[length - 1] = '\\0';",
            "@@ -70,110 +81,210 @@",
            " ",
            " \treturn -1;",
            " }",
            " ",
            " static int canonicalize_tmp_path(char *buffer)",
            " {",
            " #ifdef _WIN32",
            "-\tchar tmp[CLAR_PATH_MAX];",
            "+\tchar tmp[CLAR_MAX_PATH], *p;",
            " \tDWORD ret;",
            " ",
            "-\tret = GetFullPathName(buffer, CLAR_PATH_MAX, tmp, NULL);",
            "+\tret = GetFullPathName(buffer, CLAR_MAX_PATH, tmp, NULL);",
            " ",
            "-\tif (ret == 0 || ret > CLAR_PATH_MAX)",
            "+\tif (ret == 0 || ret > CLAR_MAX_PATH)",
            " \t\treturn -1;",
            " ",
            "-\tret = GetLongPathName(tmp, buffer, CLAR_PATH_MAX);",
            "+\tret = GetLongPathName(tmp, buffer, CLAR_MAX_PATH);",
            " ",
            "-\tif (ret == 0 || ret > CLAR_PATH_MAX)",
            "+\tif (ret == 0 || ret > CLAR_MAX_PATH)",
            " \t\treturn -1;",
            " ",
            "+\t/* normalize path to POSIX forward slashes */",
            "+\tfor (p = buffer; *p; p++)",
            "+\t\tif (*p == '\\\\')",
            "+\t\t\t*p = '/';",
            "+",
            " \treturn 0;",
            "-#else",
            "-\tchar tmp[CLAR_PATH_MAX];",
            "+#elif defined(CLAR_HAS_REALPATH)",
            "+\tchar tmp[CLAR_MAX_PATH];",
            " ",
            " \tif (realpath(buffer, tmp) == NULL)",
            " \t\treturn -1;",
            " ",
            " \tstrcpy(buffer, tmp);",
            " \treturn 0;",
            "+#else",
            "+\t(void)buffer;",
            "+\treturn 0;",
            " #endif",
            " }",
            " ",
            "-static void clar_unsandbox(void)",
            "+static void clar_tempdir_shutdown(void)",
            " {",
            "-\tif (_clar_path[0] == '\\0')",
            "+\tif (_clar_tempdir[0] == '\\0')",
            " \t\treturn;",
            " ",
            " \tcl_must_pass(chdir(\"..\"));",
            " ",
            "-\tfs_rm(_clar_path);",
            "+\tfs_rm(_clar_tempdir);",
            " }",
            " ",
            "-static int build_sandbox_path(void)",
            "+static int build_tempdir_path(void)",
            " {",
            " #ifdef CLAR_TMPDIR",
            " \tconst char path_tail[] = CLAR_TMPDIR \"_XXXXXX\";",
            " #else",
            " \tconst char path_tail[] = \"clar_tmp_XXXXXX\";",
            " #endif",
            " ",
            " \tsize_t len;",
            " ",
            "-\tif (find_tmp_path(_clar_path, sizeof(_clar_path)) < 0 ||",
            "-\t    canonicalize_tmp_path(_clar_path) < 0)",
            "+\tif (find_tmp_path(_clar_tempdir, sizeof(_clar_tempdir)) < 0 ||",
            "+\t    canonicalize_tmp_path(_clar_tempdir) < 0)",
            " \t\treturn -1;",
            " ",
            "-\tlen = strlen(_clar_path);",
            "+\tlen = strlen(_clar_tempdir);",
            " ",
            "-#ifdef _WIN32",
            "-\t{ /* normalize path to POSIX forward slashes */",
            "-\t\tsize_t i;",
            "-\t\tfor (i = 0; i < len; ++i) {",
            "-\t\t\tif (_clar_path[i] == '\\\\')",
            "-\t\t\t\t_clar_path[i] = '/';",
            "-\t\t}",
            "-\t}",
            "-#endif",
            "+\tif (len + strlen(path_tail) + 2 > CLAR_MAX_PATH)",
            "+\t\treturn -1;",
            " ",
            "-\tif (_clar_path[len - 1] != '/') {",
            "-\t\t_clar_path[len++] = '/';",
            "-\t}",
            "+\tif (_clar_tempdir[len - 1] != '/')",
            "+\t\t_clar_tempdir[len++] = '/';",
            " ",
            "-\tstrncpy(_clar_path + len, path_tail, sizeof(_clar_path) - len);",
            "+\tstrncpy(_clar_tempdir + len, path_tail, sizeof(_clar_tempdir) - len);",
            " ",
            " #if defined(__MINGW32__)",
            "-\tif (_mktemp(_clar_path) == NULL)",
            "+\tif (_mktemp(_clar_tempdir) == NULL)",
            " \t\treturn -1;",
            " ",
            "-\tif (mkdir(_clar_path, 0700) != 0)",
            "+\tif (mkdir(_clar_tempdir, 0700) != 0)",
            " \t\treturn -1;",
            " #elif defined(_WIN32)",
            "-\tif (_mktemp_s(_clar_path, sizeof(_clar_path)) != 0)",
            "+\tif (_mktemp_s(_clar_tempdir, sizeof(_clar_tempdir)) != 0)",
            "+\t\treturn -1;",
            "+",
            "+\tif (mkdir(_clar_tempdir, 0700) != 0)",
            "+\t\treturn -1;",
            "+#elif defined(__sun) || defined(__TANDEM)",
            "+\tif (mktemp(_clar_tempdir) == NULL)",
            " \t\treturn -1;",
            " ",
            "-\tif (mkdir(_clar_path, 0700) != 0)",
            "+\tif (mkdir(_clar_tempdir, 0700) != 0)",
            " \t\treturn -1;",
            " #else",
            "-\tif (mkdtemp(_clar_path) == NULL)",
            "+\tif (mkdtemp(_clar_tempdir) == NULL)",
            " \t\treturn -1;",
            " #endif",
            " ",
            "+\t_clar_tempdir_len = strlen(_clar_tempdir);",
            " \treturn 0;",
            " }",
            " ",
            "-static int clar_sandbox(void)",
            "+static void clar_tempdir_init(void)",
            "+{",
            "+\tif (_clar_tempdir[0] == '\\0' && build_tempdir_path() < 0)",
            "+\t\tclar_abort(\"Failed to build tempdir path.\\n\");",
            "+",
            "+\tif (chdir(_clar_tempdir) != 0)",
            "+\t\tclar_abort(\"Failed to change into tempdir '%s': %s.\\n\",",
            "+\t\t\t   _clar_tempdir, strerror(errno));",
            "+",
            "+#if !defined(CLAR_SANDBOX_TEST_NAMES) && defined(_WIN32)",
            "+\tsrand(clock() ^ (unsigned int)time(NULL) ^ GetCurrentProcessId() ^ GetCurrentThreadId());",
            "+#elif !defined(CLAR_SANDBOX_TEST_NAMES)",
            "+\tsrand(clock() ^ time(NULL) ^ (getpid() << 16));",
            "+#endif",
            "+}",
            "+",
            "+static void append(char *dst, const char *src)",
            " {",
            "-\tif (_clar_path[0] == '\\0' && build_sandbox_path() < 0)",
            "+\tchar *d;",
            "+\tconst char *s;",
            "+",
            "+\tfor (d = dst; *d; d++)",
            "+\t\t;",
            "+",
            "+\tfor (s = src; *s; d++, s++)",
            "+\t\tif (*s == ':')",
            "+\t\t\t*d = '_';",
            "+\t\telse",
            "+\t\t\t*d = *s;",
            "+",
            "+\t*d = '\\0';",
            "+}",
            "+",
            "+static int clar_sandbox_create(const char *suite_name, const char *test_name)",
            "+{",
            "+#ifndef CLAR_SANDBOX_TEST_NAMES",
            "+\tchar alpha[] = \"0123456789abcdef\";",
            "+\tint num = rand();",
            "+#endif",
            "+",
            "+\tcl_assert(_clar_sandbox[0] == '\\0');",
            "+",
            "+\t/*",
            "+\t * We may want to use test names as sandbox directory names for",
            "+\t * readability, _however_ on platforms with restrictions for short",
            "+\t * file / folder names (eg, Windows), this may be too long.",
            "+\t */",
            "+#ifdef CLAR_SANDBOX_TEST_NAMES",
            "+\tcl_assert(strlen(_clar_tempdir) + strlen(suite_name) + strlen(test_name) + 3 < CLAR_MAX_PATH);",
            "+",
            "+\tstrcpy(_clar_sandbox, _clar_tempdir);",
            "+\t_clar_sandbox[_clar_tempdir_len] = '/';",
            "+\t_clar_sandbox[_clar_tempdir_len + 1] = '\\0';",
            "+",
            "+\tappend(_clar_sandbox, suite_name);",
            "+\tappend(_clar_sandbox, \"__\");",
            "+\tappend(_clar_sandbox, test_name);",
            "+#else",
            "+\t((void)suite_name);",
            "+\t((void)test_name);",
            "+\t((void)append);",
            "+",
            "+\tcl_assert(strlen(_clar_tempdir) + 9 < CLAR_MAX_PATH);",
            "+",
            "+\tstrcpy(_clar_sandbox, _clar_tempdir);",
            "+\t_clar_sandbox[_clar_tempdir_len] = '/';",
            "+",
            "+\t_clar_sandbox[_clar_tempdir_len + 1] = alpha[(num & 0xf0000000) >> 28];",
            "+\t_clar_sandbox[_clar_tempdir_len + 2] = alpha[(num & 0x0f000000) >> 24];",
            "+\t_clar_sandbox[_clar_tempdir_len + 3] = alpha[(num & 0x00f00000) >> 20];",
            "+\t_clar_sandbox[_clar_tempdir_len + 4] = alpha[(num & 0x000f0000) >> 16];",
            "+\t_clar_sandbox[_clar_tempdir_len + 5] = alpha[(num & 0x0000f000) >> 12];",
            "+\t_clar_sandbox[_clar_tempdir_len + 6] = alpha[(num & 0x00000f00) >> 8];",
            "+\t_clar_sandbox[_clar_tempdir_len + 7] = alpha[(num & 0x000000f0) >> 4];",
            "+\t_clar_sandbox[_clar_tempdir_len + 8] = alpha[(num & 0x0000000f) >> 0];",
            "+\t_clar_sandbox[_clar_tempdir_len + 9] = '\\0';",
            "+#endif",
            "+",
            "+\tif (mkdir(_clar_sandbox, 0700) != 0)",
            " \t\treturn -1;",
            " ",
            "-\tif (chdir(_clar_path) != 0)",
            "+\tif (chdir(_clar_sandbox) != 0)",
            " \t\treturn -1;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-const char *clar_sandbox_path(void)",
            "+static int clar_sandbox_cleanup(void)",
            "+{",
            "+\tcl_assert(_clar_sandbox[0] != '\\0');",
            "+",
            "+\tif (chdir(_clar_tempdir) != 0)",
            "+\t\treturn -1;",
            "+",
            "+\tfs_rm(_clar_sandbox);",
            "+\t_clar_sandbox[0] = '\\0';",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+const char *clar_tempdir_path(void)",
            " {",
            "-\treturn _clar_path;",
            "+\treturn _clar_tempdir;",
            " }",
            " ",
            "+const char *clar_sandbox_path(void)",
            "+{",
            "+\treturn _clar_sandbox;",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar/summary.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar/summary.h",
            "+++ /home/libgit2-1.9.1/tests/clar/clar/summary.h",
            "@@ -62,24 +62,20 @@",
            " }",
            " ",
            " struct clar_summary *clar_summary_init(const char *filename)",
            " {",
            " \tstruct clar_summary *summary;",
            " \tFILE *fp;",
            " ",
            "-\tif ((fp = fopen(filename, \"w\")) == NULL) {",
            "-\t\tperror(\"fopen\");",
            "-\t\treturn NULL;",
            "-\t}",
            "-",
            "-\tif ((summary = malloc(sizeof(struct clar_summary))) == NULL) {",
            "-\t\tperror(\"malloc\");",
            "-\t\tfclose(fp);",
            "-\t\treturn NULL;",
            "-\t}",
            "+\tif ((fp = fopen(filename, \"w\")) == NULL)",
            "+\t\tclar_abort(\"Failed to open the summary file '%s': %s.\\n\",",
            "+\t\t\t   filename, strerror(errno));",
            "+",
            "+\tif ((summary = malloc(sizeof(struct clar_summary))) == NULL)",
            "+\t\tclar_abort(\"Failed to allocate summary.\\n\");",
            " ",
            " \tsummary->filename = filename;",
            " \tsummary->fp = fp;",
            " ",
            " \treturn summary;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar.c",
            "+++ /home/libgit2-1.9.1/tests/clar/clar.c",
            "@@ -1,50 +1,72 @@",
            " /*",
            "  * Copyright (c) Vicent Marti. All rights reserved.",
            "  *",
            "  * This file is part of clar, distributed under the ISC license.",
            "  * For full terms see the included COPYING file.",
            "  */",
            "-#include <assert.h>",
            "+",
            "+#define _BSD_SOURCE",
            "+#define _DARWIN_C_SOURCE",
            "+#define _DEFAULT_SOURCE",
            "+",
            "+#include <errno.h>",
            " #include <setjmp.h>",
            " #include <stdlib.h>",
            " #include <stdio.h>",
            " #include <string.h>",
            " #include <math.h>",
            " #include <stdarg.h>",
            " #include <wchar.h>",
            " #include <time.h>",
            "+#include <inttypes.h>",
            " ",
            " /* required for sandboxing */",
            " #include <sys/types.h>",
            " #include <sys/stat.h>",
            " ",
            "+#if defined(__UCLIBC__) && ! defined(__UCLIBC_HAS_WCHAR__)",
            "+\t/*",
            "+\t * uClibc can optionally be built without wchar support, in which case",
            "+\t * the installed <wchar.h> is a stub that only defines the `whar_t`",
            "+\t * type but none of the functions typically declared by it.",
            "+\t */",
            "+#else",
            "+#\tdefine CLAR_HAVE_WCHAR",
            "+#endif",
            "+",
            " #ifdef _WIN32",
            "+#\tdefine WIN32_LEAN_AND_MEAN",
            " #\tinclude <windows.h>",
            " #\tinclude <io.h>",
            "-#\tinclude <shellapi.h>",
            " #\tinclude <direct.h>",
            " ",
            " #\tdefine _MAIN_CC __cdecl",
            " ",
            " #\tifndef stat",
            " #\t\tdefine stat(path, st) _stat(path, st)",
            "+\t\ttypedef struct _stat STAT_T;",
            "+#\telse",
            "+\t\ttypedef struct stat STAT_T;",
            " #\tendif",
            " #\tifndef mkdir",
            " #\t\tdefine mkdir(path, mode) _mkdir(path)",
            " #\tendif",
            " #\tifndef chdir",
            " #\t\tdefine chdir(path) _chdir(path)",
            " #\tendif",
            " #\tifndef access",
            " #\t\tdefine access(path, mode) _access(path, mode)",
            " #\tendif",
            " #\tifndef strdup",
            " #\t\tdefine strdup(str) _strdup(str)",
            " #\tendif",
            "+#\tifndef strcasecmp",
            "+#\t\tdefine strcasecmp(a,b) _stricmp(a,b)",
            "+#\tendif",
            " ",
            " #\tifndef __MINGW32__",
            " #\t\tpragma comment(lib, \"shell32\")",
            " #\t\tifndef strncpy",
            " #\t\t\tdefine strncpy(to, from, to_size) strncpy_s(to, to_size, from, _TRUNCATE)",
            " #\t\tendif",
            " #\t\tifndef W_OK",
            "@@ -53,38 +75,19 @@",
            " #\t\tifndef S_ISDIR",
            " #\t\t\tdefine S_ISDIR(x) ((x & _S_IFDIR) != 0)",
            " #\t\tendif",
            " #\t\tdefine p_snprintf(buf,sz,fmt,...) _snprintf_s(buf,sz,_TRUNCATE,fmt,__VA_ARGS__)",
            " #\telse",
            " #\t\tdefine p_snprintf snprintf",
            " #\tendif",
            "-",
            "-#\tifndef PRIuZ",
            "-#\t\tdefine PRIuZ \"Iu\"",
            "-#\tendif",
            "-#\tifndef PRIxZ",
            "-#\t\tdefine PRIxZ \"Ix\"",
            "-#\tendif",
            "-",
            "-#\tif defined(_MSC_VER) || defined(__MINGW32__)",
            "-\ttypedef struct stat STAT_T;",
            "-#\telse",
            "-\ttypedef struct _stat STAT_T;",
            "-#\tendif",
            " #else",
            " #\tinclude <sys/wait.h> /* waitpid(2) */",
            " #\tinclude <unistd.h>",
            " #\tdefine _MAIN_CC",
            " #\tdefine p_snprintf snprintf",
            "-#\tifndef PRIuZ",
            "-#\t\tdefine PRIuZ \"zu\"",
            "-#\tendif",
            "-#\tifndef PRIxZ",
            "-#\t\tdefine PRIxZ \"zx\"",
            "-#\tendif",
            " \ttypedef struct stat STAT_T;",
            " #endif",
            " ",
            " #define MAX(x, y) (((x) > (y)) ? (x) : (y))",
            " ",
            " #include \"clar.h\"",
            " ",
            "@@ -95,15 +98,15 @@",
            " static const char *",
            " fixture_path(const char *base, const char *fixture_name);",
            " #endif",
            " ",
            " struct clar_error {",
            " \tconst char *file;",
            " \tconst char *function;",
            "-\tsize_t line_number;",
            "+\tuintmax_t line_number;",
            " \tconst char *error_msg;",
            " \tchar *description;",
            " ",
            " \tstruct clar_error *next;",
            " };",
            " ",
            " struct clar_explicit {",
            "@@ -157,14 +160,18 @@",
            " ",
            " \tstruct clar_explicit *explicit;",
            " \tstruct clar_explicit *last_explicit;",
            " ",
            " \tstruct clar_report *reports;",
            " \tstruct clar_report *last_report;",
            " ",
            "+\tconst char *invoke_file;",
            "+\tconst char *invoke_func;",
            "+\tsize_t invoke_line;",
            "+",
            " \tvoid (*local_cleanup)(void *);",
            " \tvoid *local_cleanup_payload;",
            " ",
            " \tjmp_buf trampoline;",
            " \tint trampoline_enabled;",
            " ",
            " \tcl_trace_cb *pfn_trace_cb;",
            "@@ -188,19 +195,22 @@",
            " ",
            " /* From clar_print_*.c */",
            " static void clar_print_init(int test_count, int suite_count, const char *suite_names);",
            " static void clar_print_shutdown(int test_count, int suite_count, int error_count);",
            " static void clar_print_error(int num, const struct clar_report *report, const struct clar_error *error);",
            " static void clar_print_ontest(const char *suite_name, const char *test_name, int test_number, enum cl_test_status failed);",
            " static void clar_print_onsuite(const char *suite_name, int suite_index);",
            "+static void clar_print_onabortv(const char *msg, va_list argp);",
            " static void clar_print_onabort(const char *msg, ...);",
            " ",
            " /* From clar_sandbox.c */",
            "-static void clar_unsandbox(void);",
            "-static int clar_sandbox(void);",
            "+static void clar_tempdir_init(void);",
            "+static void clar_tempdir_shutdown(void);",
            "+static int clar_sandbox_create(const char *suite_name, const char *test_name);",
            "+static int clar_sandbox_cleanup(void);",
            " ",
            " /* From summary.h */",
            " static struct clar_summary *clar_summary_init(const char *filename);",
            " static int clar_summary_shutdown(struct clar_summary *fp);",
            " ",
            " /* Load the declarations for the test suite */",
            " #include \"clar.suite\"",
            "@@ -211,14 +221,23 @@",
            " \t\tif (_clar.pfn_trace_cb)\t\t\t\t\t\t\t\t\t\t\t\\",
            " \t\t\t_clar.pfn_trace_cb(ev,\t\t\t\t\t\t\t\t\t\t\\",
            " \t\t\t\t\t\t\t   _clar.active_suite,\t\t\t\t\t\t\\",
            " \t\t\t\t\t\t\t   _clar.active_test,\t\t\t\t\t\t\\",
            " \t\t\t\t\t\t\t   _clar.trace_payload);\t\t\t\t\t\\",
            " \t} while (0)",
            " ",
            "+static void clar_abort(const char *msg, ...)",
            "+{",
            "+\tva_list argp;",
            "+\tva_start(argp, msg);",
            "+\tclar_print_onabortv(msg, argp);",
            "+\tva_end(argp);",
            "+\texit(-1);",
            "+}",
            "+",
            " void cl_trace_register(cl_trace_cb *cb, void *payload)",
            " {",
            " \t_clar.pfn_trace_cb = cb;",
            " \t_clar.trace_payload = payload;",
            " }",
            " ",
            " ",
            "@@ -264,17 +283,15 @@",
            " #else",
            " # include <sys/time.h>",
            " ",
            " # define clar_time struct timeval",
            " ",
            " static void clar_time_now(clar_time *out)",
            " {",
            "-\tstruct timezone tz;",
            "-",
            "-\tgettimeofday(out, &tz);",
            "+\tgettimeofday(out, NULL);",
            " }",
            " ",
            " static double clar_time_diff(clar_time *start, clar_time *end)",
            " {",
            " \treturn ((double)end->tv_sec + (double)end->tv_usec / 1.0E6) -",
            " \t       ((double)start->tv_sec + (double)start->tv_usec / 1.0E6);",
            " }",
            "@@ -289,14 +306,16 @@",
            " {",
            " \tclar_time start, end;",
            " ",
            " \t_clar.trampoline_enabled = 1;",
            " ",
            " \tCL_TRACE(CL_TRACE__TEST__BEGIN);",
            " ",
            "+\tclar_sandbox_create(suite->name, test->name);",
            "+",
            " \t_clar.last_report->start = time(NULL);",
            " \tclar_time_now(&start);",
            " ",
            " \tif (setjmp(_clar.trampoline) == 0) {",
            " \t\tif (initialize->ptr != NULL)",
            " \t\t\tinitialize->ptr();",
            " ",
            "@@ -313,17 +332,21 @@",
            " \t\t_clar.last_report->status = CL_TEST_OK;",
            " ",
            " \t_clar.last_report->elapsed = clar_time_diff(&start, &end);",
            " ",
            " \tif (_clar.local_cleanup != NULL)",
            " \t\t_clar.local_cleanup(_clar.local_cleanup_payload);",
            " ",
            "+\tclar__clear_invokepoint();",
            "+",
            " \tif (cleanup->ptr != NULL)",
            " \t\tcleanup->ptr();",
            " ",
            "+\tclar_sandbox_cleanup();",
            "+",
            " \tCL_TRACE(CL_TRACE__TEST__END);",
            " ",
            " \t_clar.tests_ran++;",
            " ",
            " \t/* remove any local-set cleanup methods */",
            " \t_clar.local_cleanup = NULL;",
            " \t_clar.local_cleanup_payload = NULL;",
            "@@ -379,15 +402,16 @@",
            " \t\t\tcontinue;",
            " ",
            " \t\tif (exact && strlen(test[i].name) != matchlen)",
            " \t\t\tcontinue;",
            " ",
            " \t\t_clar.active_test = test[i].name;",
            " ",
            "-\t\treport = calloc(1, sizeof(struct clar_report));",
            "+\t\tif ((report = calloc(1, sizeof(*report))) == NULL)",
            "+\t\t\tclar_abort(\"Failed to allocate report.\\n\");",
            " \t\treport->suite = _clar.active_suite;",
            " \t\treport->test = _clar.active_test;",
            " \t\treport->test_number = _clar.tests_ran;",
            " \t\treport->status = CL_TEST_NOTRUN;",
            " ",
            " \t\tif (_clar.reports == NULL)",
            " \t\t\t_clar.reports = report;",
            "@@ -417,48 +441,46 @@",
            " \tprintf(\"  -xname        Exclude the suite with `name`\\n\");",
            " \tprintf(\"  -v            Increase verbosity (show suite names)\\n\");",
            " \tprintf(\"  -q            Only report tests that had an error\\n\");",
            " \tprintf(\"  -Q            Quit as soon as a test fails\\n\");",
            " \tprintf(\"  -t            Display results in tap format\\n\");",
            " \tprintf(\"  -l            Print suite names\\n\");",
            " \tprintf(\"  -r[filename]  Write summary file (to the optional filename)\\n\");",
            "-\texit(-1);",
            "+\texit(1);",
            " }",
            " ",
            " static void",
            " clar_parse_args(int argc, char **argv)",
            " {",
            " \tint i;",
            " ",
            "-\t/* Verify options before execute */",
            " \tfor (i = 1; i < argc; ++i) {",
            " \t\tchar *argument = argv[i];",
            " ",
            "-\t\tif (argument[0] != '-' || argument[1] == '\\0'",
            "-\t\t    || strchr(\"sixvqQtlr\", argument[1]) == NULL) {",
            "+\t\tif (argument[0] != '-' || argument[1] == '\\0')",
            " \t\t\tclar_usage(argv[0]);",
            "-\t\t}",
            "-\t}",
            "-",
            "-\tfor (i = 1; i < argc; ++i) {",
            "-\t\tchar *argument = argv[i];",
            " ",
            " \t\tswitch (argument[1]) {",
            " \t\tcase 's':",
            " \t\tcase 'i':",
            " \t\tcase 'x': { /* given suite name */",
            " \t\t\tint offset = (argument[2] == '=') ? 3 : 2, found = 0;",
            " \t\t\tchar action = argument[1];",
            " \t\t\tsize_t j, arglen, suitelen, cmplen;",
            " ",
            " \t\t\targument += offset;",
            " \t\t\targlen = strlen(argument);",
            " ",
            "-\t\t\tif (arglen == 0)",
            "-\t\t\t\tclar_usage(argv[0]);",
            "+\t\t\tif (arglen == 0) {",
            "+\t\t\t\tif (i + 1 == argc)",
            "+\t\t\t\t\tclar_usage(argv[0]);",
            "+",
            "+\t\t\t\targument = argv[++i];",
            "+\t\t\t\targlen = strlen(argument);",
            "+\t\t\t}",
            " ",
            " \t\t\tfor (j = 0; j < _clar_suite_count; ++j) {",
            " \t\t\t\tsuitelen = strlen(_clar_suites[j].name);",
            " \t\t\t\tcmplen = (arglen < suitelen) ? arglen : suitelen;",
            " ",
            " \t\t\t\tif (strncmp(argument, _clar_suites[j].name, cmplen) == 0) {",
            " \t\t\t\t\tint exact = (arglen >= suitelen);",
            "@@ -467,22 +489,20 @@",
            " \t\t\t\t\t * trailing '::' or just a matching substring? */",
            " \t\t\t\t\tif (arglen > suitelen && (argument[suitelen] != ':'",
            " \t\t\t\t\t\t    || argument[suitelen + 1] != ':'))",
            " \t\t\t\t\t    continue;",
            " ",
            " \t\t\t\t\t++found;",
            " ",
            "-\t\t\t\t\tif (!exact)",
            "-\t\t\t\t\t\t_clar.verbosity = MAX(_clar.verbosity, 1);",
            "-",
            " \t\t\t\t\tswitch (action) {",
            " \t\t\t\t\tcase 's': {",
            "-\t\t\t\t\t\tstruct clar_explicit *explicit =",
            "-\t\t\t\t\t\t\tcalloc(1, sizeof(struct clar_explicit));",
            "-\t\t\t\t\t\tassert(explicit);",
            "+\t\t\t\t\t\tstruct clar_explicit *explicit;",
            "+",
            "+\t\t\t\t\t\tif ((explicit = calloc(1, sizeof(*explicit))) == NULL)",
            "+\t\t\t\t\t\t\tclar_abort(\"Failed to allocate explicit test.\\n\");",
            " ",
            " \t\t\t\t\t\texplicit->suite_idx = j;",
            " \t\t\t\t\t\texplicit->filter = argument;",
            " ",
            " \t\t\t\t\t\tif (_clar.explicit == NULL)",
            " \t\t\t\t\t\t\t_clar.explicit = explicit;",
            " ",
            "@@ -498,54 +518,76 @@",
            " \t\t\t\t\t}",
            " ",
            " \t\t\t\t\tif (exact)",
            " \t\t\t\t\t\tbreak;",
            " \t\t\t\t}",
            " \t\t\t}",
            " ",
            "-\t\t\tif (!found) {",
            "-\t\t\t\tclar_print_onabort(\"No suite matching '%s' found.\\n\", argument);",
            "-\t\t\t\texit(-1);",
            "-\t\t\t}",
            "+\t\t\tif (!found)",
            "+\t\t\t\tclar_abort(\"No suite matching '%s' found.\\n\", argument);",
            "+",
            " \t\t\tbreak;",
            " \t\t}",
            " ",
            " \t\tcase 'q':",
            "+\t\t\tif (argument[2] != '\\0')",
            "+\t\t\t\tclar_usage(argv[0]);",
            "+",
            " \t\t\t_clar.report_errors_only = 1;",
            " \t\t\tbreak;",
            " ",
            " \t\tcase 'Q':",
            "+\t\t\tif (argument[2] != '\\0')",
            "+\t\t\t\tclar_usage(argv[0]);",
            "+",
            " \t\t\t_clar.exit_on_error = 1;",
            " \t\t\tbreak;",
            " ",
            " \t\tcase 't':",
            "+\t\t\tif (argument[2] != '\\0')",
            "+\t\t\t\tclar_usage(argv[0]);",
            "+",
            " \t\t\t_clar.output_format = CL_OUTPUT_TAP;",
            " \t\t\tbreak;",
            " ",
            " \t\tcase 'l': {",
            " \t\t\tsize_t j;",
            "+",
            "+\t\t\tif (argument[2] != '\\0')",
            "+\t\t\t\tclar_usage(argv[0]);",
            "+",
            " \t\t\tprintf(\"Test suites (use -s<name> to run just one):\\n\");",
            " \t\t\tfor (j = 0; j < _clar_suite_count; ++j)",
            " \t\t\t\tprintf(\" %3d: %s\\n\", (int)j, _clar_suites[j].name);",
            " ",
            " \t\t\texit(0);",
            " \t\t}",
            " ",
            " \t\tcase 'v':",
            "+\t\t\tif (argument[2] != '\\0')",
            "+\t\t\t\tclar_usage(argv[0]);",
            "+",
            " \t\t\t_clar.verbosity++;",
            " \t\t\tbreak;",
            " ",
            " \t\tcase 'r':",
            " \t\t\t_clar.write_summary = 1;",
            " \t\t\tfree(_clar.summary_filename);",
            "-\t\t\t_clar.summary_filename = *(argument + 2) ? strdup(argument + 2) : NULL;",
            "+",
            "+\t\t\tif (*(argument + 2)) {",
            "+\t\t\t\tif ((_clar.summary_filename = strdup(argument + 2)) == NULL)",
            "+\t\t\t\t\tclar_abort(\"Failed to allocate summary filename.\\n\");",
            "+\t\t\t} else {",
            "+\t\t\t\t_clar.summary_filename = NULL;",
            "+\t\t\t}",
            "+",
            " \t\t\tbreak;",
            " ",
            " \t\tdefault:",
            "-\t\t\tassert(!\"Unexpected commandline argument!\");",
            "+\t\t\tclar_usage(argv[0]);",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " void",
            " clar_test_init(int argc, char **argv)",
            " {",
            "@@ -559,30 +601,26 @@",
            " \t\t(int)_clar_suite_count,",
            " \t\t\"\"",
            " \t);",
            " ",
            " \tif (!_clar.summary_filename &&",
            " \t    (summary_env = getenv(\"CLAR_SUMMARY\")) != NULL) {",
            " \t\t_clar.write_summary = 1;",
            "-\t\t_clar.summary_filename = strdup(summary_env);",
            "+\t\tif ((_clar.summary_filename = strdup(summary_env)) == NULL)",
            "+\t\t\tclar_abort(\"Failed to allocate summary filename.\\n\");",
            " \t}",
            " ",
            " \tif (_clar.write_summary && !_clar.summary_filename)",
            "-\t\t_clar.summary_filename = strdup(\"summary.xml\");",
            "+\t\tif ((_clar.summary_filename = strdup(\"summary.xml\")) == NULL)",
            "+\t\t\tclar_abort(\"Failed to allocate summary filename.\\n\");",
            " ",
            "-\tif (_clar.write_summary &&",
            "-\t    !(_clar.summary = clar_summary_init(_clar.summary_filename))) {",
            "-\t\tclar_print_onabort(\"Failed to open the summary file\\n\");",
            "-\t\texit(-1);",
            "-\t}",
            "+\tif (_clar.write_summary)",
            "+\t    _clar.summary = clar_summary_init(_clar.summary_filename);",
            " ",
            "-\tif (clar_sandbox() < 0) {",
            "-\t\tclar_print_onabort(\"Failed to sandbox the test runner.\\n\");",
            "-\t\texit(-1);",
            "-\t}",
            "+\tclar_tempdir_init();",
            " }",
            " ",
            " int",
            " clar_test_run(void)",
            " {",
            " \tsize_t i;",
            " \tstruct clar_explicit *explicit;",
            "@@ -606,27 +644,34 @@",
            " ",
            " \tclar_print_shutdown(",
            " \t\t_clar.tests_ran,",
            " \t\t(int)_clar_suite_count,",
            " \t\t_clar.total_errors",
            " \t);",
            " ",
            "-\tclar_unsandbox();",
            "+\tclar_tempdir_shutdown();",
            " ",
            "-\tif (_clar.write_summary && clar_summary_shutdown(_clar.summary) < 0) {",
            "-\t\tclar_print_onabort(\"Failed to write the summary file\\n\");",
            "-\t\texit(-1);",
            "-\t}",
            "+\tif (_clar.write_summary && clar_summary_shutdown(_clar.summary) < 0)",
            "+\t\tclar_abort(\"Failed to write the summary file '%s: %s.\\n\",",
            "+\t\t\t   _clar.summary_filename, strerror(errno));",
            " ",
            " \tfor (explicit = _clar.explicit; explicit; explicit = explicit_next) {",
            " \t\texplicit_next = explicit->next;",
            " \t\tfree(explicit);",
            " \t}",
            " ",
            " \tfor (report = _clar.reports; report; report = report_next) {",
            "+\t\tstruct clar_error *error, *error_next;",
            "+",
            "+\t\tfor (error = report->errors; error; error = error_next) {",
            "+\t\t\tfree(error->description);",
            "+\t\t\terror_next = error->next;",
            "+\t\t\tfree(error);",
            "+\t\t}",
            "+",
            " \t\treport_next = report->next;",
            " \t\tfree(report);",
            " \t}",
            " ",
            " \tfree(_clar.summary_filename);",
            " }",
            " ",
            "@@ -642,17 +687,17 @@",
            " \treturn errors;",
            " }",
            " ",
            " static void abort_test(void)",
            " {",
            " \tif (!_clar.trampoline_enabled) {",
            " \t\tclar_print_onabort(",
            "-\t\t\t\t\"Fatal error: a cleanup method raised an exception.\");",
            "+\t\t\t\t\"Fatal error: a cleanup method raised an exception.\\n\");",
            " \t\tclar_report_errors(_clar.last_report);",
            "-\t\texit(-1);",
            "+\t\texit(1);",
            " \t}",
            " ",
            " \tCL_TRACE(CL_TRACE__TEST__LONGJMP);",
            " \tlongjmp(_clar.trampoline, -1);",
            " }",
            " ",
            " void clar__skip(void)",
            "@@ -666,31 +711,35 @@",
            " \tconst char *file,",
            " \tconst char *function,",
            " \tsize_t line,",
            " \tconst char *error_msg,",
            " \tconst char *description,",
            " \tint should_abort)",
            " {",
            "-\tstruct clar_error *error = calloc(1, sizeof(struct clar_error));",
            "+\tstruct clar_error *error;",
            "+",
            "+\tif ((error = calloc(1, sizeof(*error))) == NULL)",
            "+\t\tclar_abort(\"Failed to allocate error.\\n\");",
            " ",
            " \tif (_clar.last_report->errors == NULL)",
            " \t\t_clar.last_report->errors = error;",
            " ",
            " \tif (_clar.last_report->last_error != NULL)",
            " \t\t_clar.last_report->last_error->next = error;",
            " ",
            " \t_clar.last_report->last_error = error;",
            " ",
            "-\terror->file = file;",
            "-\terror->function = function;",
            "-\terror->line_number = line;",
            "+\terror->file = _clar.invoke_file ? _clar.invoke_file : file;",
            "+\terror->function = _clar.invoke_func ? _clar.invoke_func : function;",
            "+\terror->line_number = _clar.invoke_line ? _clar.invoke_line : line;",
            " \terror->error_msg = error_msg;",
            " ",
            "-\tif (description != NULL)",
            "-\t\terror->description = strdup(description);",
            "+\tif (description != NULL &&",
            "+\t    (error->description = strdup(description)) == NULL)",
            "+\t\tclar_abort(\"Failed to allocate description.\\n\");",
            " ",
            " \t_clar.total_errors++;",
            " \t_clar.last_report->status = CL_TEST_FAILURE;",
            " ",
            " \tif (should_abort)",
            " \t\tabort_test();",
            " }",
            "@@ -756,14 +805,15 @@",
            " \t\t\t\tp_snprintf(buf, sizeof(buf), \"'%.*s' != '%.*s' (at byte %d)\",",
            " \t\t\t\t\tlen, s1, len, s2, pos);",
            " \t\t\t} else {",
            " \t\t\t\tp_snprintf(buf, sizeof(buf), \"'%.*s' != '%.*s'\", len, s1, len, s2);",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            "+#ifdef CLAR_HAVE_WCHAR",
            " \telse if (!strcmp(\"%ls\", fmt)) {",
            " \t\tconst wchar_t *wcs1 = va_arg(args, const wchar_t *);",
            " \t\tconst wchar_t *wcs2 = va_arg(args, const wchar_t *);",
            " \t\tis_equal = (!wcs1 || !wcs2) ? (wcs1 == wcs2) : !wcscmp(wcs1, wcs2);",
            " ",
            " \t\tif (!is_equal) {",
            " \t\t\tif (wcs1 && wcs2) {",
            "@@ -791,28 +841,30 @@",
            " \t\t\t\tp_snprintf(buf, sizeof(buf), \"'%.*ls' != '%.*ls' (at byte %d)\",",
            " \t\t\t\t\tlen, wcs1, len, wcs2, pos);",
            " \t\t\t} else {",
            " \t\t\t\tp_snprintf(buf, sizeof(buf), \"'%.*ls' != '%.*ls'\", len, wcs1, len, wcs2);",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            "-\telse if (!strcmp(\"%\"PRIuZ, fmt) || !strcmp(\"%\"PRIxZ, fmt)) {",
            "-\t\tsize_t sz1 = va_arg(args, size_t), sz2 = va_arg(args, size_t);",
            "+#endif /* CLAR_HAVE_WCHAR */",
            "+\telse if (!strcmp(\"%\"PRIuMAX, fmt) || !strcmp(\"%\"PRIxMAX, fmt)) {",
            "+\t\tuintmax_t sz1 = va_arg(args, uintmax_t), sz2 = va_arg(args, uintmax_t);",
            " \t\tis_equal = (sz1 == sz2);",
            " \t\tif (!is_equal) {",
            " \t\t\tint offset = p_snprintf(buf, sizeof(buf), fmt, sz1);",
            " \t\t\tstrncat(buf, \" != \", sizeof(buf) - offset);",
            " \t\t\tp_snprintf(buf + offset + 4, sizeof(buf) - offset - 4, fmt, sz2);",
            " \t\t}",
            " \t}",
            " \telse if (!strcmp(\"%p\", fmt)) {",
            " \t\tvoid *p1 = va_arg(args, void *), *p2 = va_arg(args, void *);",
            " \t\tis_equal = (p1 == p2);",
            " \t\tif (!is_equal)",
            "-\t\t\tp_snprintf(buf, sizeof(buf), \"%p != %p\", p1, p2);",
            "+\t\t\tp_snprintf(buf, sizeof(buf), \"0x%\"PRIxPTR\" != 0x%\"PRIxPTR,",
            "+\t\t\t\t   (uintptr_t)p1, (uintptr_t)p2);",
            " \t}",
            " \telse {",
            " \t\tint i1 = va_arg(args, int), i2 = va_arg(args, int);",
            " \t\tis_equal = (i1 == i2);",
            " \t\tif (!is_equal) {",
            " \t\t\tint offset = p_snprintf(buf, sizeof(buf), fmt, i1);",
            " \t\t\tstrncat(buf, \" != \", sizeof(buf) - offset);",
            "@@ -828,12 +880,29 @@",
            " ",
            " void cl_set_cleanup(void (*cleanup)(void *), void *opaque)",
            " {",
            " \t_clar.local_cleanup = cleanup;",
            " \t_clar.local_cleanup_payload = opaque;",
            " }",
            " ",
            "+void clar__set_invokepoint(",
            "+\tconst char *file,",
            "+\tconst char *func,",
            "+\tsize_t line)",
            "+{",
            "+\t_clar.invoke_file = file;",
            "+\t_clar.invoke_func = func;",
            "+\t_clar.invoke_line = line;",
            "+}",
            "+",
            "+void clar__clear_invokepoint(void)",
            "+{",
            "+\t_clar.invoke_file = NULL;",
            "+\t_clar.invoke_func = NULL;",
            "+\t_clar.invoke_line = 0;",
            "+}",
            "+",
            " #include \"clar/sandbox.h\"",
            " #include \"clar/fixtures.h\"",
            " #include \"clar/fs.h\"",
            " #include \"clar/print.h\"",
            " #include \"clar/summary.h\""
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar.h",
            "+++ /home/libgit2-1.9.1/tests/clar/clar.h",
            "@@ -4,14 +4,33 @@",
            "  * This file is part of clar, distributed under the ISC license.",
            "  * For full terms see the included COPYING file.",
            "  */",
            " #ifndef __CLAR_TEST_H__",
            " #define __CLAR_TEST_H__",
            " ",
            " #include <stdlib.h>",
            "+#include <limits.h>",
            "+",
            "+#if defined(_WIN32) && defined(CLAR_WIN32_LONGPATHS)",
            "+# define CLAR_MAX_PATH 4096",
            "+#elif defined(_WIN32)",
            "+# define CLAR_MAX_PATH MAX_PATH",
            "+#else",
            "+# define CLAR_MAX_PATH PATH_MAX",
            "+#endif",
            "+",
            "+#ifndef CLAR_SELFTEST",
            "+# define CLAR_CURRENT_FILE __FILE__",
            "+# define CLAR_CURRENT_LINE __LINE__",
            "+# define CLAR_CURRENT_FUNC __func__",
            "+#else",
            "+# define CLAR_CURRENT_FILE \"file\"",
            "+# define CLAR_CURRENT_LINE 42",
            "+# define CLAR_CURRENT_FUNC \"func\"",
            "+#endif",
            " ",
            " enum cl_test_status {",
            " \tCL_TEST_OK,",
            " \tCL_TEST_FAILURE,",
            " \tCL_TEST_SKIP,",
            " \tCL_TEST_NOTRUN,",
            " };",
            "@@ -26,14 +45,15 @@",
            " int clar_test_run(void);",
            " void clar_test_shutdown(void);",
            " ",
            " /** One shot setup & run */",
            " int clar_test(int argc, char *argv[]);",
            " ",
            " const char *clar_sandbox_path(void);",
            "+const char *clar_tempdir_path(void);",
            " ",
            " void cl_set_cleanup(void (*cleanup)(void *), void *opaque);",
            " void cl_fs_cleanup(void);",
            " ",
            " /**",
            "  * cl_trace_* is a hook to provide a simple global tracing",
            "  * mechanism.",
            "@@ -80,26 +100,40 @@",
            " const char *cl_fixture(const char *fixture_name);",
            " void cl_fixture_sandbox(const char *fixture_name);",
            " void cl_fixture_cleanup(const char *fixture_name);",
            " const char *cl_fixture_basename(const char *fixture_name);",
            " #endif",
            " ",
            " /**",
            "+ * Invoke a helper function, which itself will use `cl_assert`",
            "+ * constructs. This will preserve the stack information of the",
            "+ * current call point, so that function name and line number",
            "+ * information is shown from the line of the test, instead of",
            "+ * the helper function.",
            "+ */",
            "+#define cl_invoke(expr) \\",
            "+\tdo { \\",
            "+\t\tclar__set_invokepoint(CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE); \\",
            "+\t\texpr; \\",
            "+\t\tclar__clear_invokepoint(); \\",
            "+\t} while(0)",
            "+",
            "+/**",
            "  * Assertion macros with explicit error message",
            "  */",
            "-#define cl_must_pass_(expr, desc) clar__assert((expr) >= 0, __FILE__, __func__, __LINE__, \"Function call failed: \" #expr, desc, 1)",
            "-#define cl_must_fail_(expr, desc) clar__assert((expr) < 0, __FILE__, __func__, __LINE__, \"Expected function call to fail: \" #expr, desc, 1)",
            "-#define cl_assert_(expr, desc) clar__assert((expr) != 0, __FILE__, __func__, __LINE__, \"Expression is not true: \" #expr, desc, 1)",
            "+#define cl_must_pass_(expr, desc) clar__assert((expr) >= 0, CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Function call failed: \" #expr, desc, 1)",
            "+#define cl_must_fail_(expr, desc) clar__assert((expr) < 0, CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Expected function call to fail: \" #expr, desc, 1)",
            "+#define cl_assert_(expr, desc) clar__assert((expr) != 0, CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Expression is not true: \" #expr, desc, 1)",
            " ",
            " /**",
            "  * Check macros with explicit error message",
            "  */",
            "-#define cl_check_pass_(expr, desc) clar__assert((expr) >= 0, __FILE__, __func__, __LINE__, \"Function call failed: \" #expr, desc, 0)",
            "-#define cl_check_fail_(expr, desc) clar__assert((expr) < 0, __FILE__, __func__, __LINE__, \"Expected function call to fail: \" #expr, desc, 0)",
            "-#define cl_check_(expr, desc) clar__assert((expr) != 0, __FILE__, __func__, __LINE__, \"Expression is not true: \" #expr, desc, 0)",
            "+#define cl_check_pass_(expr, desc) clar__assert((expr) >= 0, CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Function call failed: \" #expr, desc, 0)",
            "+#define cl_check_fail_(expr, desc) clar__assert((expr) < 0, CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Expected function call to fail: \" #expr, desc, 0)",
            "+#define cl_check_(expr, desc) clar__assert((expr) != 0, CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Expression is not true: \" #expr, desc, 0)",
            " ",
            " /**",
            "  * Assertion macros with no error message",
            "  */",
            " #define cl_must_pass(expr) cl_must_pass_(expr, NULL)",
            " #define cl_must_fail(expr) cl_must_fail_(expr, NULL)",
            " #define cl_assert(expr) cl_assert_(expr, NULL)",
            "@@ -110,41 +144,41 @@",
            " #define cl_check_pass(expr) cl_check_pass_(expr, NULL)",
            " #define cl_check_fail(expr) cl_check_fail_(expr, NULL)",
            " #define cl_check(expr) cl_check_(expr, NULL)",
            " ",
            " /**",
            "  * Forced failure/warning",
            "  */",
            "-#define cl_fail(desc) clar__fail(__FILE__, __func__, __LINE__, \"Test failed.\", desc, 1)",
            "-#define cl_warning(desc) clar__fail(__FILE__, __func__, __LINE__, \"Warning during test execution:\", desc, 0)",
            "+#define cl_fail(desc) clar__fail(CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Test failed.\", desc, 1)",
            "+#define cl_warning(desc) clar__fail(CLAR_CURRENT_FILE, CLAR_CURRENT_FUNC, CLAR_CURRENT_LINE, \"Warning during test execution:\", desc, 0)",
            " ",
            " #define cl_skip() clar__skip()",
            " ",
            " /**",
            "  * Typed assertion macros",
            "  */",
            "-#define cl_assert_equal_s(s1,s2) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #s1 \" != \" #s2, 1, \"%s\", (s1), (s2))",
            "-#define cl_assert_equal_s_(s1,s2,note) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #s1 \" != \" #s2 \" (\" #note \")\", 1, \"%s\", (s1), (s2))",
            "+#define cl_assert_equal_s(s1,s2) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #s1 \" != \" #s2, 1, \"%s\", (s1), (s2))",
            "+#define cl_assert_equal_s_(s1,s2,note) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #s1 \" != \" #s2 \" (\" #note \")\", 1, \"%s\", (s1), (s2))",
            " ",
            "-#define cl_assert_equal_wcs(wcs1,wcs2) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #wcs1 \" != \" #wcs2, 1, \"%ls\", (wcs1), (wcs2))",
            "-#define cl_assert_equal_wcs_(wcs1,wcs2,note) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #wcs1 \" != \" #wcs2 \" (\" #note \")\", 1, \"%ls\", (wcs1), (wcs2))",
            "+#define cl_assert_equal_wcs(wcs1,wcs2) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #wcs1 \" != \" #wcs2, 1, \"%ls\", (wcs1), (wcs2))",
            "+#define cl_assert_equal_wcs_(wcs1,wcs2,note) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #wcs1 \" != \" #wcs2 \" (\" #note \")\", 1, \"%ls\", (wcs1), (wcs2))",
            " ",
            "-#define cl_assert_equal_strn(s1,s2,len) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #s1 \" != \" #s2, 1, \"%.*s\", (s1), (s2), (int)(len))",
            "-#define cl_assert_equal_strn_(s1,s2,len,note) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #s1 \" != \" #s2 \" (\" #note \")\", 1, \"%.*s\", (s1), (s2), (int)(len))",
            "+#define cl_assert_equal_strn(s1,s2,len) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #s1 \" != \" #s2, 1, \"%.*s\", (s1), (s2), (int)(len))",
            "+#define cl_assert_equal_strn_(s1,s2,len,note) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #s1 \" != \" #s2 \" (\" #note \")\", 1, \"%.*s\", (s1), (s2), (int)(len))",
            " ",
            "-#define cl_assert_equal_wcsn(wcs1,wcs2,len) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #wcs1 \" != \" #wcs2, 1, \"%.*ls\", (wcs1), (wcs2), (int)(len))",
            "-#define cl_assert_equal_wcsn_(wcs1,wcs2,len,note) clar__assert_equal(__FILE__,__func__,__LINE__,\"String mismatch: \" #wcs1 \" != \" #wcs2 \" (\" #note \")\", 1, \"%.*ls\", (wcs1), (wcs2), (int)(len))",
            "+#define cl_assert_equal_wcsn(wcs1,wcs2,len) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #wcs1 \" != \" #wcs2, 1, \"%.*ls\", (wcs1), (wcs2), (int)(len))",
            "+#define cl_assert_equal_wcsn_(wcs1,wcs2,len,note) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"String mismatch: \" #wcs1 \" != \" #wcs2 \" (\" #note \")\", 1, \"%.*ls\", (wcs1), (wcs2), (int)(len))",
            " ",
            "-#define cl_assert_equal_i(i1,i2) clar__assert_equal(__FILE__,__func__,__LINE__,#i1 \" != \" #i2, 1, \"%d\", (int)(i1), (int)(i2))",
            "-#define cl_assert_equal_i_(i1,i2,note) clar__assert_equal(__FILE__,__func__,__LINE__,#i1 \" != \" #i2 \" (\" #note \")\", 1, \"%d\", (i1), (i2))",
            "-#define cl_assert_equal_i_fmt(i1,i2,fmt) clar__assert_equal(__FILE__,__func__,__LINE__,#i1 \" != \" #i2, 1, (fmt), (int)(i1), (int)(i2))",
            "+#define cl_assert_equal_i(i1,i2) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,#i1 \" != \" #i2, 1, \"%d\", (int)(i1), (int)(i2))",
            "+#define cl_assert_equal_i_(i1,i2,note) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,#i1 \" != \" #i2 \" (\" #note \")\", 1, \"%d\", (i1), (i2))",
            "+#define cl_assert_equal_i_fmt(i1,i2,fmt) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,#i1 \" != \" #i2, 1, (fmt), (int)(i1), (int)(i2))",
            " ",
            "-#define cl_assert_equal_b(b1,b2) clar__assert_equal(__FILE__,__func__,__LINE__,#b1 \" != \" #b2, 1, \"%d\", (int)((b1) != 0),(int)((b2) != 0))",
            "+#define cl_assert_equal_b(b1,b2) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,#b1 \" != \" #b2, 1, \"%d\", (int)((b1) != 0),(int)((b2) != 0))",
            " ",
            "-#define cl_assert_equal_p(p1,p2) clar__assert_equal(__FILE__,__func__,__LINE__,\"Pointer mismatch: \" #p1 \" != \" #p2, 1, \"%p\", (p1), (p2))",
            "+#define cl_assert_equal_p(p1,p2) clar__assert_equal(CLAR_CURRENT_FILE,CLAR_CURRENT_FUNC,CLAR_CURRENT_LINE,\"Pointer mismatch: \" #p1 \" != \" #p2, 1, \"%p\", (p1), (p2))",
            " ",
            " void clar__skip(void);",
            " ",
            " void clar__fail(",
            " \tconst char *file,",
            " \tconst char *func,",
            " \tsize_t line,",
            "@@ -166,8 +200,15 @@",
            " \tconst char *func,",
            " \tsize_t line,",
            " \tconst char *err,",
            " \tint should_abort,",
            " \tconst char *fmt,",
            " \t...);",
            " ",
            "+void clar__set_invokepoint(",
            "+\tconst char *file,",
            "+\tconst char *func,",
            "+\tsize_t line);",
            "+",
            "+void clar__clear_invokepoint(void);",
            "+",
            " #endif"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/clar/clar_libgit2.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/clar/clar_libgit2.c",
            "+++ /home/libgit2-1.9.1/tests/clar/clar_libgit2.c",
            "@@ -645,30 +645,30 @@",
            " void cl_sandbox_set_homedir(const char *home)",
            " {",
            " \tgit_str path = GIT_STR_INIT;",
            " ",
            " \tif (home) {",
            " \t\tgit_libgit2_opts(GIT_OPT_SET_HOMEDIR, home);",
            " \t} else {",
            "-\t\tgit_str_joinpath(&path, clar_sandbox_path(), \"__home\");",
            "+\t\tgit_str_joinpath(&path, clar_tempdir_path(), \"__home\");",
            " ",
            " \t\tif (!git_fs_path_exists(path.ptr))",
            " \t\t\tcl_must_pass(p_mkdir(path.ptr, 0777));",
            " ",
            " \t\tgit_libgit2_opts(GIT_OPT_SET_HOMEDIR, path.ptr);",
            " \t}",
            " ",
            " \tgit_str_dispose(&path);",
            " }",
            " ",
            " void cl_sandbox_set_search_path_defaults(void)",
            " {",
            " \tgit_str path = GIT_STR_INIT;",
            " ",
            "-\tgit_str_joinpath(&path, clar_sandbox_path(), \"__config\");",
            "+\tgit_str_joinpath(&path, clar_tempdir_path(), \"__config\");",
            " ",
            " \tif (!git_fs_path_exists(path.ptr))",
            " \t\tcl_must_pass(p_mkdir(path.ptr, 0777));",
            " ",
            " \tgit_libgit2_opts(",
            " \t\tGIT_OPT_SET_SEARCH_PATH, GIT_CONFIG_LEVEL_GLOBAL, path.ptr);",
            " \tgit_libgit2_opts("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/attr/repo.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/attr/repo.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/attr/repo.c",
            "@@ -314,15 +314,15 @@",
            " \tconst char *names[1] = { \"fake\" };",
            " \tconst char *values[1];",
            " \tgit_repository *inmemory;",
            " \tgit_index *index = NULL;",
            " ",
            " \t/* setup bare in-memory repo without index */",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_repository_new(&inmemory, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_repository_new(&inmemory, NULL));",
            " #else",
            " \tcl_git_pass(git_repository_new(&inmemory));",
            " #endif",
            " \tcl_assert(git_repository_is_bare(inmemory));",
            " ",
            " \t/* verify repo isn't given an index upfront in future */",
            " \tgit_repository_index(&index, inmemory);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/blame/blame_helpers.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/blame/blame_helpers.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/blame/blame_helpers.c",
            "@@ -14,15 +14,15 @@",
            " \tprintf(\"\\n\");",
            " }",
            " ",
            " void check_blame_hunk_index(git_repository *repo, git_blame *blame, int idx,",
            " \t\tsize_t start_line, size_t len, char boundary, const char *commit_id, const char *orig_path)",
            " {",
            " \tchar expected[GIT_OID_SHA1_HEXSIZE+1] = {0}, actual[GIT_OID_SHA1_HEXSIZE+1] = {0};",
            "-\tconst git_blame_hunk *hunk = git_blame_get_hunk_byindex(blame, idx);",
            "+\tconst git_blame_hunk *hunk = git_blame_hunk_byindex(blame, idx);",
            " \tcl_assert(hunk);",
            " ",
            " \tif (!strncmp(commit_id, \"0000\", 4)) {",
            " \t\tstrcpy(expected, \"0000000000000000000000000000000000000000\");",
            " \t} else {",
            " \t\tgit_object *obj;",
            " \t\tcl_git_pass(git_revparse_single(&obj, repo, commit_id));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/blame/buffer.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/blame/buffer.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/blame/buffer.c",
            "@@ -216,22 +216,22 @@",
            " \tconst char *buffer = \"Hello\\nWorld!\";",
            " ",
            " \tgit_blame_free(g_fileblame);",
            " \tg_fileblame = NULL;",
            " \tcl_git_pass(git_blame_file(&g_fileblame, g_repo, \"file.txt\", NULL));",
            " ",
            " \tcl_git_pass(git_blame_buffer(&g_bufferblame, g_fileblame, buffer, strlen(buffer)));",
            "-\tcl_assert_equal_i(2, git_blame_get_hunk_count(g_bufferblame));",
            "+\tcl_assert_equal_i(2, git_blame_hunkcount(g_bufferblame));",
            " ",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 0,  1, 1, 0, \"836bc00b\", \"file.txt\");",
            "-\thunk = git_blame_get_hunk_byline(g_bufferblame, 1);",
            "+\thunk = git_blame_hunk_byline(g_bufferblame, 1);",
            " \tcl_assert(hunk);",
            " \tcl_assert_equal_s(\"lhchavez\", hunk->final_signature->name);",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 1,  2, 1, 0, \"00000000\", \"file.txt\");",
            "-\thunk = git_blame_get_hunk_byline(g_bufferblame, 2);",
            "+\thunk = git_blame_hunk_byline(g_bufferblame, 2);",
            " \tcl_assert(hunk);",
            " \tcl_assert(hunk->final_signature == NULL);",
            " }",
            " ",
            " ",
            " ",
            " void test_blame_buffer__added_line(void)",
            "@@ -252,18 +252,18 @@",
            " \\n\\",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\n\";",
            " ",
            " \tcl_git_pass(git_blame_buffer(&g_bufferblame, g_fileblame, buffer, strlen(buffer)));",
            "-\tcl_assert_equal_i(5, git_blame_get_hunk_count(g_bufferblame));",
            "+\tcl_assert_equal_i(5, git_blame_hunkcount(g_bufferblame));",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 2, 6, 1, 0, \"000000\", \"b.txt\");",
            " ",
            "-\thunk = git_blame_get_hunk_byline(g_bufferblame, 16);",
            "+\thunk = git_blame_hunk_byline(g_bufferblame, 16);",
            " \tcl_assert(hunk);",
            " \tcl_assert_equal_s(\"Ben Straub\", hunk->final_signature->name);",
            " }",
            " ",
            " void test_blame_buffer__added_lines(void)",
            " {",
            " ",
            "@@ -290,15 +290,15 @@",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\",
            " \\n\\",
            " \\n\\",
            " \\n\\",
            " \\n\";",
            " ",
            " \tcl_git_pass(git_blame_buffer(&g_bufferblame, g_fileblame, buffer, strlen(buffer)));",
            "-\tcl_assert_equal_i(7, git_blame_get_hunk_count(g_bufferblame));",
            "+\tcl_assert_equal_i(7, git_blame_hunkcount(g_bufferblame));",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 2, 6, 3, 0, \"000000\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 4, 14, 3, 0, \"000000\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 6, 22, 3, 0, \"000000\", \"b.txt\");",
            " ",
            " }",
            " ",
            " void test_blame_buffer__deleted_line(void)",
            "@@ -407,14 +407,14 @@",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\",
            " CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\n\\",
            " \\n\\",
            " abc\\n\\",
            " def\\n\";",
            " \tcl_git_pass(git_blame_buffer(&g_bufferblame, g_fileblame, buffer, strlen(buffer)));",
            " ",
            "-\tcl_assert_equal_i(5, git_blame_get_hunk_count(g_bufferblame));",
            "+\tcl_assert_equal_i(5, git_blame_hunkcount(g_bufferblame));",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 0,  1, 4, 0, \"da237394\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 1,  5, 1, 1, \"b99f7ac0\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 2,  6, 5, 0, \"63d671eb\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 3, 11, 5, 0, \"aa06ecca\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_bufferblame, 4, 16, 2, 0, \"00000000\", \"b.txt\");",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/blame/getters.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/blame/getters.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/blame/getters.c",
            "@@ -6,19 +6,19 @@",
            " ",
            " void test_blame_getters__initialize(void)",
            " {",
            " \tsize_t i;",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tgit_blame_hunk hunks[] = {",
            "-\t\t{ 3, GIT_OID_SHA1_ZERO,  1, NULL, GIT_OID_SHA1_ZERO, \"a\", 0},",
            "-\t\t{ 3, GIT_OID_SHA1_ZERO,  4, NULL, GIT_OID_SHA1_ZERO, \"b\", 0},",
            "-\t\t{ 3, GIT_OID_SHA1_ZERO,  7, NULL, GIT_OID_SHA1_ZERO, \"c\", 0},",
            "-\t\t{ 3, GIT_OID_SHA1_ZERO, 10, NULL, GIT_OID_SHA1_ZERO, \"d\", 0},",
            "-\t\t{ 3, GIT_OID_SHA1_ZERO, 13, NULL, GIT_OID_SHA1_ZERO, \"e\", 0},",
            "+\t\t{ 3, GIT_OID_SHA1_ZERO,  1, NULL, NULL, GIT_OID_SHA1_ZERO, \"a\", 0},",
            "+\t\t{ 3, GIT_OID_SHA1_ZERO,  4, NULL, NULL, GIT_OID_SHA1_ZERO, \"b\", 0},",
            "+\t\t{ 3, GIT_OID_SHA1_ZERO,  7, NULL, NULL, GIT_OID_SHA1_ZERO, \"c\", 0},",
            "+\t\t{ 3, GIT_OID_SHA1_ZERO, 10, NULL, NULL, GIT_OID_SHA1_ZERO, \"d\", 0},",
            "+\t\t{ 3, GIT_OID_SHA1_ZERO, 13, NULL, NULL, GIT_OID_SHA1_ZERO, \"e\", 0},",
            " \t};",
            " ",
            " \tg_blame = git_blame__alloc(NULL, opts, \"\");",
            " ",
            " \tfor (i=0; i<5; i++) {",
            " \t\tgit_blame_hunk *h = git__calloc(1, sizeof(git_blame_hunk));",
            " \t\th->final_start_line_number = hunks[i].final_start_line_number;",
            "@@ -33,24 +33,24 @@",
            " {",
            " \tgit_blame_free(g_blame);",
            " }",
            " ",
            " ",
            " void test_blame_getters__byindex(void)",
            " {",
            "-\tconst git_blame_hunk *h = git_blame_get_hunk_byindex(g_blame, 2);",
            "+\tconst git_blame_hunk *h = git_blame_hunk_byindex(g_blame, 2);",
            " \tcl_assert(h);",
            " \tcl_assert_equal_s(h->orig_path, \"c\");",
            " ",
            "-\th = git_blame_get_hunk_byindex(g_blame, 95);",
            "+\th = git_blame_hunk_byindex(g_blame, 95);",
            " \tcl_assert_equal_p(h, NULL);",
            " }",
            " ",
            " void test_blame_getters__byline(void)",
            " {",
            "-\tconst git_blame_hunk *h = git_blame_get_hunk_byline(g_blame, 5);",
            "+\tconst git_blame_hunk *h = git_blame_hunk_byline(g_blame, 5);",
            " \tcl_assert(h);",
            " \tcl_assert_equal_s(h->orig_path, \"b\");",
            " ",
            "-\th = git_blame_get_hunk_byline(g_blame, 95);",
            "+\th = git_blame_hunk_byline(g_blame, 95);",
            " \tcl_assert_equal_p(h, NULL);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/blame/harder.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/blame/harder.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/blame/harder.c",
            "@@ -6,15 +6,15 @@",
            " /**",
            "  * The test repo has a history that looks like this:",
            "  *",
            "  * * (A) bc7c5ac",
            "  * |\\",
            "  * | * (B) aa06ecc",
            "  * * | (C) 63d671e",
            "- * |/  ",
            "+ * |/",
            "  * * (D) da23739",
            "  * * (E) b99f7ac",
            "  *",
            "  */",
            " ",
            " static git_repository *g_repo = NULL;",
            " ",
            "@@ -67,13 +67,13 @@",
            " }",
            " ",
            " void test_blame_harder__ccc(void)",
            " {",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tGIT_UNUSED(opts);",
            "-\t",
            "+",
            " \t/* Attribute the third hunk in b.txt to (E).  This hunk was deleted from",
            " \t * a.txt in (D), but reintroduced in (B).",
            " \t */",
            " \topts.flags = GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/blame/simple.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/blame/simple.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/blame/simple.c",
            "@@ -23,15 +23,15 @@",
            "  * a65fedf3 2 (Scott Chacon 2011-08-09 19:33:46 -0700 2",
            "  */",
            " void test_blame_simple__trivial_testrepo(void)",
            " {",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"testrepo/.gitted\")));",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"branch_file.txt\", NULL));",
            " ",
            "-\tcl_assert_equal_i(2, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(2, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0, 1, 1, 0, \"c47800c7\", \"branch_file.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1, 2, 1, 0, \"a65fedf3\", \"branch_file.txt\");",
            " }",
            " ",
            " /*",
            "  * $ git blame -n b.txt",
            "  *    orig line no                          final line no",
            "@@ -53,15 +53,15 @@",
            "  * aa06ecca 10 (Ben Straub 2013-02-12 15:14:46 -0800 15",
            "  */",
            " void test_blame_simple__trivial_blamerepo(void)",
            " {",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"b.txt\", NULL));",
            " ",
            "-\tcl_assert_equal_i(4, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(4, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  1, 4, 0, \"da237394\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1,  5, 1, 1, \"b99f7ac0\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 2,  6, 5, 0, \"63d671eb\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 3, 11, 5, 0, \"aa06ecca\", \"b.txt\");",
            " }",
            " ",
            " ",
            "@@ -229,15 +229,15 @@",
            " {",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " ",
            " \topts.min_line = 8;",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"b.txt\", &opts));",
            "-\tcl_assert_equal_i(2, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(2, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  8, 3, 0, \"63d671eb\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1, 11, 5, 0, \"aa06ecca\", \"b.txt\");",
            " }",
            " ",
            " /*",
            "  * $ git blame -n c.txt",
            "  *    orig line no                          final line no",
            "@@ -248,15 +248,15 @@",
            " {",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " ",
            " \topts.flags |= GIT_BLAME_IGNORE_WHITESPACE;",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"c.txt\", &opts));",
            "-\tcl_assert_equal_i(1, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(1, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  1, 4, 0, \"702c7aa5\", \"c.txt\");",
            " }",
            " ",
            " /*",
            "  * $ git blame -n b.txt -L ,6",
            "  *    orig line no                          final line no",
            "  * commit    V  author     timestamp                  V",
            "@@ -271,15 +271,15 @@",
            " {",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " ",
            " \topts.max_line = 6;",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"b.txt\", &opts));",
            "-\tcl_assert_equal_i(3, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(3, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  1, 4, 0, \"da237394\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1,  5, 1, 1, \"b99f7ac0\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 2,  6, 1, 0, \"63d671eb\", \"b.txt\");",
            " }",
            " ",
            " /*",
            "  * $ git blame -n b.txt -L 2,7",
            "@@ -297,28 +297,28 @@",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " ",
            " \topts.min_line = 2;",
            " \topts.max_line = 7;",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"b.txt\", &opts));",
            "-\tcl_assert_equal_i(3, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(3, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  2, 3, 0, \"da237394\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1,  5, 1, 1, \"b99f7ac0\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 2,  6, 2, 0, \"63d671eb\", \"b.txt\");",
            " }",
            " ",
            " void test_blame_simple__can_blame_huge_file(void)",
            " {",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " ",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"huge.txt\", &opts));",
            "-\tcl_assert_equal_i(2, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(2, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0, 1,     65536, 0, \"4eecfea\", \"huge.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1, 65537, 1,     0, \"6653ff4\", \"huge.txt\");",
            " }",
            " ",
            " /*",
            "  * $ git blame -n branch_file.txt be3563a..HEAD",
            "  *    orig line no                          final line no",
            "@@ -337,26 +337,26 @@",
            " \t\tcl_git_pass(git_revparse_single(&obj, g_repo, \"be3563a\"));",
            " \t\tgit_oid_cpy(&opts.oldest_commit, git_object_id(obj));",
            " \t\tgit_object_free(obj);",
            " \t}",
            " ",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"branch_file.txt\", &opts));",
            " ",
            "-\tcl_assert_equal_i(2, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(2, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  1, 1, 1, \"be3563a\", \"branch_file.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1,  2, 1, 0, \"a65fedf\", \"branch_file.txt\");",
            " }",
            " ",
            " void test_blame_simple__can_restrict_to_first_parent_commits(void)",
            " {",
            " \tgit_blame_options opts = GIT_BLAME_OPTIONS_INIT;",
            " \topts.flags |= GIT_BLAME_FIRST_PARENT;",
            " ",
            " \tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"blametest.git\")));",
            " ",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"b.txt\", &opts));",
            "-\tcl_assert_equal_i(4, git_blame_get_hunk_count(g_blame));",
            "+\tcl_assert_equal_i(4, git_blame_hunkcount(g_blame));",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 0,  1, 4, 0, \"da237394\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 1,  5, 1, 1, \"b99f7ac0\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 2,  6, 5, 0, \"63d671eb\", \"b.txt\");",
            " \tcheck_blame_hunk_index(g_repo, g_blame, 3, 11, 5, 0, \"bc7c5ac2\", \"b.txt\");",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/binaryunicode.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/binaryunicode.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/binaryunicode.c",
            "@@ -24,16 +24,14 @@",
            " \tgit_tree *tree;",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"refs/heads/branch1\"));",
            " \tcl_git_pass(git_commit_lookup(&commit, g_repo, &oid));",
            " \tcl_git_pass(git_commit_tree(&tree, commit));",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tcl_git_pass(git_checkout_tree(g_repo, (git_object *)tree, &opts));",
            " ",
            " \tgit_tree_free(tree);",
            " \tgit_commit_free(commit);",
            " ",
            " \t/* Verify that the lenna.jpg file was checked out correctly */",
            " \tcl_git_pass(git_oid__fromstr(&check, \"8ab005d890fe53f65eda14b23672f60d9f4ec5a1\", GIT_OID_SHA1));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/conflict.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/conflict.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/conflict.c",
            "@@ -304,16 +304,14 @@",
            " \t\t{ 0100644, CONFLICTING_OURS_OID, 2, \"df-3/file\" },",
            " ",
            " \t\t{ 0100644, CONFLICTING_OURS_OID, 2, \"df-4\" },",
            " \t\t{ 0100644, CONFLICTING_ANCESTOR_OID, 1, \"df-4/file\" },",
            " \t\t{ 0100644, CONFLICTING_THEIRS_OID, 3, \"df-4/file\" },",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 12);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            " \tensure_workdir_oid(\"df-1/file\", CONFLICTING_THEIRS_OID);",
            " \tensure_workdir_oid(\"df-1~ours\", CONFLICTING_OURS_OID);",
            "@@ -343,15 +341,14 @@",
            " \t\t{ 0100644, CONFLICTING_OURS_OID, 2, \"df-3/file\" },",
            " ",
            " \t\t{ 0100644, CONFLICTING_OURS_OID, 2, \"df-4\" },",
            " \t\t{ 0100644, CONFLICTING_ANCESTOR_OID, 1, \"df-4/file\" },",
            " \t\t{ 0100644, CONFLICTING_THEIRS_OID, 3, \"df-4/file\" },",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            " \topts.our_label = \"HEAD\";",
            " \topts.their_label = \"branch\";",
            " ",
            " \tcreate_index(checkout_index_entries, 12);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            "@@ -384,16 +381,14 @@",
            " \t\t{ 0120000, LINK_THEIRS_OID, 3, \"link-3\" },",
            " ",
            " \t\t{ 0120000, LINK_ANCESTOR_OID, 1, \"link-4\" },",
            " \t\t{ 0120000, LINK_OURS_OID, 2, \"link-4\" },",
            " \t\t{ 0100644, CONFLICTING_THEIRS_OID, 3, \"link-4\" },",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 12);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            " \t/* Typechange conflicts always keep the file in the workdir */",
            " \tensure_workdir_oid(\"link-1\", CONFLICTING_OURS_OID);",
            "@@ -411,16 +406,14 @@",
            " \t\t{ 0120000, LINK_OURS_OID, 2, \"link-1\" },",
            " \t\t{ 0120000, LINK_THEIRS_OID, 3, \"link-1\" },",
            " ",
            " \t\t{ 0120000, LINK_OURS_OID, 2, \"link-2\" },",
            " \t\t{ 0120000, LINK_THEIRS_OID, 3, \"link-2\" },",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 5);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            " \t/* Conflicts with links always keep the ours side (even with -Xtheirs) */",
            " \tensure_workdir_link(g_repo, \"link-1\", LINK_OURS_TARGET);",
            "@@ -432,16 +425,14 @@",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tstruct checkout_index_entry checkout_index_entries[] = {",
            " \t\t{ 0100644, CONFLICTING_OURS_OID, 2, \"conflicting.txt\" },",
            " \t\t{ 0100644, CONFLICTING_THEIRS_OID, 3, \"conflicting.txt\" },",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 2);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            " \t/* Add/add writes diff3 files */",
            " \tensure_workdir_contents(\"conflicting.txt\", CONFLICTING_DIFF3_FILE);",
            "@@ -473,16 +464,14 @@",
            " \t\t{ 0100644, CONFLICTING_THEIRS_OID, 3, \"executable-5\" },",
            " ",
            " \t\t{ 0100755, CONFLICTING_ANCESTOR_OID, 1, \"executable-6\" },",
            " \t\t{ 0100644, CONFLICTING_OURS_OID, 2, \"executable-6\" },",
            " \t\t{ 0100755, CONFLICTING_THEIRS_OID, 3, \"executable-6\" },",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 18);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            " \t/* Keep the modified mode */",
            " \tensure_workdir_oid(\"executable-1\", CONFLICTING_THEIRS_OID);",
            "@@ -604,16 +593,14 @@",
            " \t\t{",
            " \t\t\t\"7-both-renamed-side-2.txt\",",
            " \t\t\t\"7-both-renamed-side-2.txt\",",
            " \t\t\t\"7-both-renamed.txt\"",
            " \t\t}",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 41);",
            " \tcreate_index_names(checkout_name_entries, 9);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            " \tensure_workdir(\"0a-no-change.txt\",",
            "@@ -789,15 +776,15 @@",
            " \t\t{",
            " \t\t\t\"7-both-renamed-side-2.txt\",",
            " \t\t\t\"7-both-renamed-side-2.txt\",",
            " \t\t\t\"7-both-renamed.txt\"",
            " \t\t}",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE | GIT_CHECKOUT_USE_OURS;",
            "+\topts.checkout_strategy |= GIT_CHECKOUT_USE_OURS;",
            " ",
            " \tcreate_index(checkout_index_entries, 41);",
            " \tcreate_index_names(checkout_name_entries, 9);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, g_index, &opts));",
            " ",
            "@@ -922,16 +909,14 @@",
            " \t\t{",
            " \t\t\t\"test-three-side-two.txt\",",
            " \t\t\t\"test-three-side-two.txt\",",
            " \t\t\t\"test-three.txt\"",
            " \t\t}",
            " \t};",
            " ",
            "-\topts.checkout_strategy |= GIT_CHECKOUT_SAFE;",
            "-",
            " \tcreate_index(checkout_index_entries, 24);",
            " \tcreate_index_names(checkout_name_entries, 6);",
            " \tcl_git_pass(git_index_write(g_index));",
            " ",
            " \t/* Add some files on disk that conflict with the names that would be chosen",
            " \t * for the files written for each side. */",
            " ",
            "@@ -976,25 +961,25 @@",
            " ",
            " \tensure_workdir(\"test-two.txt~ours_3\",",
            " \t\t0100644, \"b42712cfe99a1a500b2a51fe984e0b8a7702ba11\");",
            " \tensure_workdir(\"test-two.txt~theirs_3\",",
            " \t\t0100644, \"b69fe837e4cecfd4c9a40cdca7c138468687df07\");",
            " ",
            " \t/* Name is mangled on case insensitive only */",
            "-#if defined(GIT_WIN32) || defined(__APPLE__)",
            "-\tensure_workdir(\"test-three.txt~ours_0\",",
            "-\t\t0100644, \"b42712cfe99a1a500b2a51fe984e0b8a7702ba11\");",
            "-\tensure_workdir(\"test-three.txt~theirs_0\",",
            "-\t\t0100644, \"b69fe837e4cecfd4c9a40cdca7c138468687df07\");",
            "-#else",
            "-\tensure_workdir(\"test-three.txt~ours\",",
            "-\t\t0100644, \"b42712cfe99a1a500b2a51fe984e0b8a7702ba11\");",
            "-\tensure_workdir(\"test-three.txt~theirs\",",
            "-\t\t0100644, \"b69fe837e4cecfd4c9a40cdca7c138468687df07\");",
            "-#endif",
            "+\tif (cl_repo_get_bool(g_repo, \"core.ignorecase\")) {",
            "+\t\tensure_workdir(\"test-three.txt~ours_0\",",
            "+\t\t\t0100644, \"b42712cfe99a1a500b2a51fe984e0b8a7702ba11\");",
            "+\t\tensure_workdir(\"test-three.txt~theirs_0\",",
            "+\t\t\t0100644, \"b69fe837e4cecfd4c9a40cdca7c138468687df07\");",
            "+\t} else {",
            "+\t\tensure_workdir(\"test-three.txt~ours\",",
            "+\t\t\t0100644, \"b42712cfe99a1a500b2a51fe984e0b8a7702ba11\");",
            "+\t\tensure_workdir(\"test-three.txt~theirs\",",
            "+\t\t\t0100644, \"b69fe837e4cecfd4c9a40cdca7c138468687df07\");",
            "+\t}",
            " ",
            " \tensure_workdir(\"directory_file-one~ours_0\", 0100644, CONFLICTING_OURS_OID);",
            " \tensure_workdir(\"directory_file-two~theirs_0\", 0100644, CONFLICTING_THEIRS_OID);",
            " }",
            " ",
            " void test_checkout_conflict__update_only(void)",
            " {",
            "@@ -1137,9 +1122,9 @@",
            " \tcl_assert_equal_s(\"conflicting-2.txt\", git_vector_get(&paths, 1));",
            " \tcl_assert_equal_s(\"conflicting-3.txt\", git_vector_get(&paths, 2));",
            " \tcl_assert_equal_s(\"conflicting-4.txt\", git_vector_get(&paths, 3));",
            " ",
            " \tgit_vector_foreach(&paths, i, path)",
            " \t\tgit__free(path);",
            " ",
            "-\tgit_vector_free(&paths);",
            "+\tgit_vector_dispose(&paths);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/crlf.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/crlf.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/crlf.c",
            "@@ -193,15 +193,15 @@",
            " \t\tcmp = strncasecmp(basename, \".git\", 4);",
            " ",
            " \t\tgit__free(basename);",
            " ",
            " \t\tif (cmp)",
            " \t\t\tcl_git_pass(p_unlink(fn));",
            " \t}",
            "-\tgit_vector_free_deep(&contents);",
            "+\tgit_vector_dispose_deep(&contents);",
            " }",
            " ",
            " void test_checkout_crlf__matches_core_git(void)",
            " {",
            " \tconst char *autocrlf[] = { \"true\", \"false\", \"input\", NULL };",
            " \tconst char *attrs[] = { \"\", \"-crlf\", \"-text\", \"eol=crlf\", \"eol=lf\",",
            " \t\t\"text\", \"text eol=crlf\", \"text eol=lf\","
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/head.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/head.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/head.c",
            "@@ -224,15 +224,14 @@",
            " \t * Checkout should not fail with a conflict; though the file mode",
            " \t * on disk is literally different to the base (0666 vs 0644), Git",
            " \t * ignores the actual mode and simply treats both as non-executable.",
            " \t */",
            " \tcl_git_pass(git_revparse_single(&branch, g_repo, \"099fabac3a9ea935598528c27f866e34089c2eff\"));",
            " ",
            " \topts.checkout_strategy &= ~GIT_CHECKOUT_FORCE;",
            "-\topts.checkout_strategy |=  GIT_CHECKOUT_SAFE;",
            " \tcl_git_pass(git_checkout_tree(g_repo, branch, NULL));",
            " ",
            " \tgit_object_free(branch);",
            " \tgit_object_free(target);",
            " }",
            " ",
            " void test_checkout_head__obeys_filemode_true(void)",
            "@@ -252,15 +251,14 @@",
            " \t/*",
            " \t * Checkout will fail with a conflict; the file mode is updated in",
            " \t * the checkout target, but the contents have changed in our branch.",
            " \t */",
            " \tcl_git_pass(git_revparse_single(&branch, g_repo, \"099fabac3a9ea935598528c27f866e34089c2eff\"));",
            " ",
            " \topts.checkout_strategy &= ~GIT_CHECKOUT_FORCE;",
            "-\topts.checkout_strategy |=  GIT_CHECKOUT_SAFE;",
            " \tcl_git_fail_with(GIT_ECONFLICT, git_checkout_tree(g_repo, branch, NULL));",
            " ",
            " \tgit_object_free(branch);",
            " \tgit_object_free(target);",
            " }",
            " ",
            " void test_checkout_head__obeys_filemode_false(void)",
            "@@ -280,13 +278,12 @@",
            " \t/*",
            " \t * Checkout will fail with a conflict; the file contents are updated",
            " \t * in the checkout target, but the filemode has changed in our branch.",
            " \t */",
            " \tcl_git_pass(git_revparse_single(&branch, g_repo, \"099fabac3a9ea935598528c27f866e34089c2eff\"));",
            " ",
            " \topts.checkout_strategy &= ~GIT_CHECKOUT_FORCE;",
            "-\topts.checkout_strategy |=  GIT_CHECKOUT_SAFE;",
            " \tcl_git_pass(git_checkout_tree(g_repo, branch, NULL));",
            " ",
            " \tgit_object_free(branch);",
            " \tgit_object_free(target);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/icase.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/icase.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/icase.c",
            "@@ -30,15 +30,14 @@",
            " \tif (!icase)",
            " \t\tcl_skip();",
            " ",
            " \tcl_git_pass(git_reference_name_to_id(&id, repo, \"refs/heads/dir\"));",
            " \tcl_git_pass(git_object_lookup(&obj, repo, &id, GIT_OBJECT_ANY));",
            " ",
            " \tgit_checkout_options_init(&checkout_opts, GIT_CHECKOUT_OPTIONS_VERSION);",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_NONE;",
            " }",
            " ",
            " void test_checkout_icase__cleanup(void)",
            " {",
            " \tgit_object_free(obj);",
            " \tcl_git_sandbox_cleanup();",
            " }",
            "@@ -102,15 +101,15 @@",
            " \t\treturn p_symlink(a, b);",
            " \telse",
            " \t\treturn git_futils_fake_symlink(a, b);",
            " }",
            " ",
            " void test_checkout_icase__refuses_to_overwrite_files_for_files(void)",
            " {",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE|GIT_CHECKOUT_RECREATE_MISSING;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_write2file(\"testrepo/BRANCH_FILE.txt\", \"neue file\\n\", 10, \\",
            " \t\tO_WRONLY | O_CREAT | O_TRUNC, 0644);",
            " ",
            " \tcl_git_fail(git_checkout_tree(repo, obj, &checkout_opts));",
            " \tassert_name_is(\"testrepo/BRANCH_FILE.txt\");",
            " }",
            "@@ -124,15 +123,15 @@",
            " ",
            " \tcl_git_pass(git_checkout_tree(repo, obj, &checkout_opts));",
            " \tassert_name_is(\"testrepo/new.txt\");",
            " }",
            " ",
            " void test_checkout_icase__refuses_to_overwrite_links_for_files(void)",
            " {",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE|GIT_CHECKOUT_RECREATE_MISSING;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_must_pass(symlink_or_fake(repo, \"../tmp\", \"testrepo/BRANCH_FILE.txt\"));",
            " ",
            " \tcl_git_fail(git_checkout_tree(repo, obj, &checkout_opts));",
            " ",
            " \tcl_assert(!git_fs_path_exists(\"tmp\"));",
            " \tassert_name_is(\"testrepo/BRANCH_FILE.txt\");",
            "@@ -148,27 +147,27 @@",
            " ",
            " \tcl_assert(!git_fs_path_exists(\"tmp\"));",
            " \tassert_name_is(\"testrepo/new.txt\");",
            " }",
            " ",
            " void test_checkout_icase__overwrites_empty_folders_for_files(void)",
            " {",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE|GIT_CHECKOUT_RECREATE_MISSING;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_must_pass(p_mkdir(\"testrepo/NEW.txt\", 0777));",
            " ",
            " \tcl_git_pass(git_checkout_tree(repo, obj, &checkout_opts));",
            " ",
            " \tassert_name_is(\"testrepo/new.txt\");",
            " \tcl_assert(!git_fs_path_isdir(\"testrepo/new.txt\"));",
            " }",
            " ",
            " void test_checkout_icase__refuses_to_overwrite_populated_folders_for_files(void)",
            " {",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE|GIT_CHECKOUT_RECREATE_MISSING;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_must_pass(p_mkdir(\"testrepo/BRANCH_FILE.txt\", 0777));",
            " \tcl_git_write2file(\"testrepo/BRANCH_FILE.txt/foobar\", \"neue file\\n\", 10, \\",
            " \t\tO_WRONLY | O_CREAT | O_TRUNC, 0644);",
            " ",
            " \tcl_git_fail(git_checkout_tree(repo, obj, &checkout_opts));",
            " ",
            "@@ -188,15 +187,15 @@",
            " ",
            " \tassert_name_is(\"testrepo/new.txt\");",
            " \tcl_assert(!git_fs_path_isdir(\"testrepo/new.txt\"));",
            " }",
            " ",
            " void test_checkout_icase__refuses_to_overwrite_files_for_folders(void)",
            " {",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE|GIT_CHECKOUT_RECREATE_MISSING;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_write2file(\"testrepo/A\", \"neue file\\n\", 10, \\",
            " \t\tO_WRONLY | O_CREAT | O_TRUNC, 0644);",
            " ",
            " \tcl_git_fail(git_checkout_tree(repo, obj, &checkout_opts));",
            " \tassert_name_is(\"testrepo/A\");",
            " \tcl_assert(!git_fs_path_isdir(\"testrepo/A\"));",
            "@@ -212,15 +211,15 @@",
            " \tcl_git_pass(git_checkout_tree(repo, obj, &checkout_opts));",
            " \tassert_name_is(\"testrepo/a\");",
            " \tcl_assert(git_fs_path_isdir(\"testrepo/a\"));",
            " }",
            " ",
            " void test_checkout_icase__refuses_to_overwrite_links_for_folders(void)",
            " {",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE|GIT_CHECKOUT_RECREATE_MISSING;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_must_pass(symlink_or_fake(repo, \"..\", \"testrepo/A\"));",
            " ",
            " \tcl_git_fail(git_checkout_tree(repo, obj, &checkout_opts));",
            " ",
            " \tcl_assert(!git_fs_path_exists(\"b.txt\"));",
            " \tassert_name_is(\"testrepo/A\");",
            "@@ -240,16 +239,14 @@",
            " ",
            " void test_checkout_icase__ignores_unstaged_casechange(void)",
            " {",
            " \tgit_reference *orig_ref, *br2_ref;",
            " \tgit_commit *orig, *br2;",
            " \tgit_checkout_options checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tcl_git_pass(git_reference_lookup_resolved(&orig_ref, repo, \"HEAD\", 100));",
            " \tcl_git_pass(git_commit_lookup(&orig, repo, git_reference_target(orig_ref)));",
            " \tcl_git_pass(git_reset(repo, (git_object *)orig, GIT_RESET_HARD, NULL));",
            " ",
            " \tcl_rename(\"testrepo/branch_file.txt\", \"testrepo/Branch_File.txt\");",
            " ",
            " \tcl_git_pass(git_reference_lookup_resolved(&br2_ref, repo, \"refs/heads/br2\", 100));",
            "@@ -266,16 +263,14 @@",
            " void test_checkout_icase__conflicts_with_casechanged_subtrees(void)",
            " {",
            " \tgit_reference *orig_ref;",
            " \tgit_object *orig, *subtrees;",
            " \tgit_oid oid;",
            " \tgit_checkout_options checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tcl_git_pass(git_reference_lookup_resolved(&orig_ref, repo, \"HEAD\", 100));",
            " \tcl_git_pass(git_object_lookup(&orig, repo, git_reference_target(orig_ref), GIT_OBJECT_COMMIT));",
            " \tcl_git_pass(git_reset(repo, (git_object *)orig, GIT_RESET_HARD, NULL));",
            " ",
            " \tcl_must_pass(p_mkdir(\"testrepo/AB\", 0777));",
            " \tcl_must_pass(p_mkdir(\"testrepo/AB/C\", 0777));",
            " \tcl_git_write2file(\"testrepo/AB/C/3.txt\", \"Foobar!\\n\", 8, O_RDWR|O_CREAT, 0666);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/index.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/index.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/index.c",
            "@@ -57,15 +57,15 @@",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/README\"));",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/branch_file.txt\"));",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/new.txt\"));",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/README\", \"hey there\\n\");",
            " \tcheck_file_contents(\"./testrepo/branch_file.txt\", \"hi\\nbye!\\n\");",
            " \tcheck_file_contents(\"./testrepo/new.txt\", \"my new file\\n\");",
            " }",
            "@@ -77,15 +77,14 @@",
            " \tgit_futils_mkdir(\"./testrepo/dir/subdir/subsubdir\", 0755, GIT_MKDIR_PATH);",
            " \tcl_git_mkfile(\"./testrepo/dir/one\", \"one\\n\");",
            " \tcl_git_mkfile(\"./testrepo/dir/subdir/two\", \"two\\n\");",
            " ",
            " \tcl_assert_equal_i(true, git_fs_path_isdir(\"./testrepo/dir/subdir/subsubdir\"));",
            " ",
            " \topts.checkout_strategy =",
            "-\t\tGIT_CHECKOUT_SAFE |",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING |",
            " \t\tGIT_CHECKOUT_REMOVE_UNTRACKED;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcl_assert_equal_i(false, git_fs_path_isdir(\"./testrepo/dir\"));",
            " }",
            "@@ -153,15 +152,15 @@",
            " \topts.paths.strings = entries;",
            " \topts.paths.count = 1;",
            " ",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/README\"));",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/branch_file.txt\"));",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/new.txt\"));",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/README\"));",
            " \tcheck_file_contents(\"./testrepo/branch_file.txt\", \"hi\\nbye!\\n\");",
            " \tcheck_file_contents(\"./testrepo/new.txt\", \"my new file\\n\");",
            " }",
            "@@ -172,15 +171,15 @@",
            " \tconst char *attributes =",
            " \t\t\"branch_file.txt text eol=crlf\\n\"",
            " \t\t\"new.txt text eol=lf\\n\";",
            " ",
            " \tcl_git_mkfile(\"./testrepo/.gitattributes\", attributes);",
            " \tcl_repo_set_bool(g_repo, \"core.autocrlf\", false);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/README\", \"hey there\\n\");",
            " \tcheck_file_contents(\"./testrepo/new.txt\", \"my new file\\n\");",
            " \tcheck_file_contents(\"./testrepo/branch_file.txt\", \"hi\\r\\nbye!\\r\\n\");",
            " }",
            "@@ -190,15 +189,15 @@",
            " #ifdef GIT_WIN32",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tconst char *expected_readme_text = \"hey there\\r\\n\";",
            " ",
            " \tcl_git_pass(p_unlink(\"./testrepo/.gitattributes\"));",
            " \tcl_repo_set_bool(g_repo, \"core.autocrlf\", true);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/README\", expected_readme_text);",
            " #endif",
            " }",
            " ",
            "@@ -284,15 +283,15 @@",
            " ",
            " \tif (git_fs_path_supports_symlinks(\"testrepo/test\")) {",
            " \t\tcl_skip();",
            " \t}",
            " ",
            " \tcl_repo_set_bool(g_repo, \"core.symlinks\", true);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " \tcl_git_fail(git_checkout_index(g_repo, NULL, &opts));",
            " }",
            " ",
            " void test_checkout_index__honor_coresymlinks_setting_set_to_true(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tchar link_data[GIT_PATH_MAX];",
            "@@ -300,15 +299,15 @@",
            " ",
            " \tif (!git_fs_path_supports_symlinks(\"testrepo/test\")) {",
            " \t\tcl_skip();",
            " \t}",
            " ",
            " \tcl_repo_set_bool(g_repo, \"core.symlinks\", true);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tlink_size = p_readlink(\"./testrepo/link_to_new.txt\", link_data, link_size);",
            " \tlink_data[link_size] = '\\0';",
            " \tcl_assert_equal_i(link_size, strlen(\"new.txt\"));",
            " \tcl_assert_equal_s(link_data, \"new.txt\");",
            "@@ -317,15 +316,15 @@",
            " ",
            " void test_checkout_index__honor_coresymlinks_setting_set_to_false(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_repo_set_bool(g_repo, \"core.symlinks\", false);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/link_to_new.txt\", \"new.txt\");",
            " }",
            " ",
            " void test_checkout_index__donot_overwrite_modified_file_by_default(void)",
            "@@ -333,15 +332,15 @@",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_git_mkfile(\"./testrepo/new.txt\", \"This isn't what's stored!\");",
            " ",
            " \t/* set this up to not return an error code on conflicts, but it",
            " \t * still will not have permission to overwrite anything...",
            " \t */",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_ALLOW_CONFLICTS;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_ALLOW_CONFLICTS;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/new.txt\", \"This isn't what's stored!\");",
            " }",
            " ",
            " void test_checkout_index__can_overwrite_modified_file(void)",
            "@@ -359,15 +358,15 @@",
            " ",
            " void test_checkout_index__options_disable_filters(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_git_mkfile(\"./testrepo/.gitattributes\", \"*.txt text eol=crlf\\n\");",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " \topts.disable_filters = false;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/new.txt\", \"my new file\\r\\n\");",
            " ",
            " \tp_unlink(\"./testrepo/new.txt\");",
            "@@ -390,15 +389,15 @@",
            " \t\treturn;",
            " ",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"refs/heads/dir\"));",
            " \tcl_git_pass(git_commit_lookup(&commit, g_repo, &oid));",
            " ",
            " \treset_index_to_treeish((git_object *)commit);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " \topts.dir_mode = 0701;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \t/* umask will influence actual directory creation mode */",
            " \t(void)p_umask(um = p_umask(022));",
            " ",
            "@@ -417,15 +416,15 @@",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tstruct stat st;",
            " ",
            " \tif (!cl_is_chmod_supported())",
            " \t\treturn;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " \topts.file_mode = 0700;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \tcl_git_pass(p_stat(\"./testrepo/new.txt\", &st));",
            " \tcl_assert_equal_i_fmt(st.st_mode & GIT_MODE_PERMS_MASK, 0700, \"%07o\");",
            " }",
            "@@ -482,15 +481,15 @@",
            " \t * 100644 blob a8233120f6ad708f843d861ce2b7228ec4e3dec6    README",
            " \t * 100644 blob 3697d64be941a53d4ae8f6a271e4e3fa56b022cc    branch_file.txt",
            " \t * 100644 blob a71586c1dfe8a71c6cbf6c129f404c5642ff31bd    new.txt",
            " \t */",
            " \tdata.file = \"new.txt\";",
            " \tdata.sha = \"a71586c1dfe8a71c6cbf6c129f404c5642ff31bd\";",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE |",
            "+\topts.checkout_strategy =",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING |",
            " \t\tGIT_CHECKOUT_ALLOW_CONFLICTS;",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_CONFLICT;",
            " \topts.notify_cb = test_checkout_notify_cb;",
            " \topts.notify_payload = &data;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            "@@ -522,15 +521,14 @@",
            " ",
            " \tcl_git_pass(p_unlink(\"./testrepo/.gitattributes\"));",
            " \tcl_repo_set_bool(g_repo, \"core.autocrlf\", true);",
            " ",
            " \tcl_git_mkfile(\"./testrepo/new.txt\", \"my new file\\r\\n\");",
            " ",
            " \topts.checkout_strategy =",
            "-\t\tGIT_CHECKOUT_SAFE |",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING |",
            " \t\tGIT_CHECKOUT_ALLOW_CONFLICTS;",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_CONFLICT;",
            " \topts.notify_cb = dont_notify_cb;",
            " \topts.notify_payload = NULL;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            "@@ -544,15 +542,15 @@",
            " }",
            " ",
            " void test_checkout_index__calls_progress_callback(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tint calls = 0;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " \topts.progress_cb = checkout_progress_counter;",
            " \topts.progress_payload = &calls;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " \tcl_assert(calls > 0);",
            " }",
            " ",
            "@@ -579,15 +577,14 @@",
            " \tcl_git_pass(p_mkdir(\"./testrepo/path0\", 0777));",
            " \tcl_git_mkfile(\"./testrepo/path0/file0\", \"content\\r\\n\");",
            " ",
            " \tcl_assert(git_fs_path_isfile(\"./testrepo/path1\"));",
            " \tcl_assert(git_fs_path_isfile(\"./testrepo/path0/file0\"));",
            " ",
            " \topts.checkout_strategy =",
            "-\t\tGIT_CHECKOUT_SAFE |",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING |",
            " \t\tGIT_CHECKOUT_ALLOW_CONFLICTS;",
            " \tcl_git_pass(git_checkout_index(g_repo, index, &opts));",
            " ",
            " \tcl_assert(git_fs_path_isfile(\"./testrepo/path1\"));",
            " \tcl_assert(git_fs_path_isfile(\"./testrepo/path0/file0\"));",
            " ",
            "@@ -631,15 +628,14 @@",
            " \tcl_git_mkfile(\"./testrepo/README.after\", \"content\\n\");",
            " \tcl_git_pass(p_mkdir(\"./testrepo/branch_file\", 0777));",
            " \tcl_git_pass(p_mkdir(\"./testrepo/branch_file/contained_dir\", 0777));",
            " \tcl_git_mkfile(\"./testrepo/branch_file/contained_file\", \"content\\n\");",
            " \tcl_git_pass(p_mkdir(\"./testrepo/branch_file.txt.after\", 0777));",
            " ",
            " \topts.checkout_strategy =",
            "-\t\tGIT_CHECKOUT_SAFE |",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING |",
            " \t\tGIT_CHECKOUT_REMOVE_UNTRACKED;",
            " ",
            " \tcl_git_pass(git_checkout_index(g_repo, NULL, &opts));",
            " ",
            " \t/* remove untracked will remove the .gitattributes file before the blobs",
            " \t * were created, so they will have had crlf filtering applied on Windows",
            "@@ -682,15 +678,15 @@",
            " ",
            " void test_checkout_index__target_directory(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tcheckout_counts cts;",
            " \tmemset(&cts, 0, sizeof(cts));",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE |",
            "+\topts.checkout_strategy =",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING;",
            " \topts.target_directory = \"alternative\";",
            " \tcl_assert(!git_fs_path_isdir(\"alternative\"));",
            " ",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_ALL;",
            " \topts.notify_cb = checkout_count_callback;",
            " \topts.notify_payload = &cts;",
            "@@ -727,15 +723,15 @@",
            " ",
            " \tcl_git_pass(git_repository_index(&index, g_repo));",
            " \tcl_git_pass(git_revparse_single(&head, g_repo, \"HEAD^{tree}\"));",
            " \tcl_git_pass(git_index_read_tree(index, (const git_tree *)head));",
            " \tcl_git_pass(git_index_write(index));",
            " \tgit_index_free(index);",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE |",
            "+\topts.checkout_strategy =",
            " \t\tGIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_ALL;",
            " \topts.notify_cb = checkout_count_callback;",
            " \topts.notify_payload = &cts;",
            " ",
            " \t/* fail to checkout a bare repo */",
            "@@ -766,15 +762,15 @@",
            " \tgit_index *index;",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/README\"));",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/branch_file.txt\"));",
            " \tcl_assert_equal_i(false, git_fs_path_isfile(\"./testrepo/new.txt\"));",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \tcl_git_pass(git_repository_index(&index, g_repo));",
            " ",
            " \tcl_git_pass(git_checkout_index(NULL, index, &opts));",
            " ",
            " \tcheck_file_contents(\"./testrepo/README\", \"hey there\\n\");",
            " \tcheck_file_contents(\"./testrepo/branch_file.txt\", \"hi\\nbye!\\n\");"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/checkout/tree.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/checkout/tree.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/checkout/tree.c",
            "@@ -182,16 +182,14 @@",
            " \tcl_assert(!git_fs_path_isdir(\"testrepo/ab\"));",
            " ",
            " \tassert_on_branch(g_repo, \"dir\");",
            " ",
            " \tgit_object_free(obj);",
            " ",
            " \t/* do second checkout safe because we should be clean after first */",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"refs/heads/subtrees\"));",
            " \tcl_git_pass(git_object_lookup(&obj, g_repo, &oid, GIT_OBJECT_ANY));",
            " ",
            " \tcl_git_pass(git_checkout_tree(g_repo, obj, &opts));",
            " \tcl_git_pass(git_repository_set_head(g_repo, \"refs/heads/subtrees\"));",
            " ",
            " \tcl_assert(git_fs_path_isfile(\"testrepo/README\"));",
            "@@ -209,30 +207,30 @@",
            " \tgit_object_free(obj);",
            " }",
            " ",
            " void test_checkout_tree__can_remove_untracked(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_REMOVE_UNTRACKED;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_REMOVE_UNTRACKED;",
            " ",
            " \tcl_git_mkfile(\"testrepo/untracked_file\", \"as you wish\");",
            " \tcl_assert(git_fs_path_isfile(\"testrepo/untracked_file\"));",
            " ",
            " \tcl_git_pass(git_checkout_head(g_repo, &opts));",
            " ",
            " \tcl_assert(!git_fs_path_isfile(\"testrepo/untracked_file\"));",
            " }",
            " ",
            " void test_checkout_tree__can_remove_ignored(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tint ignored = 0;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_REMOVE_IGNORED;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_REMOVE_IGNORED;",
            " ",
            " \tcl_git_mkfile(\"testrepo/ignored_file\", \"as you wish\");",
            " ",
            " \tcl_git_pass(git_ignore_add_rule(g_repo, \"ignored_file\\n\"));",
            " ",
            " \tcl_git_pass(git_ignore_path_is_ignored(&ignored, g_repo, \"ignored_file\"));",
            " \tcl_assert_equal_i(1, ignored);",
            "@@ -309,15 +307,15 @@",
            " }",
            " ",
            " void test_checkout_tree__conflict_on_ignored_when_not_overwriting(void)",
            " {",
            " \tint error;",
            " ",
            " \tcl_git_fail(error = checkout_tree_with_blob_ignored_in_workdir(",
            "-\t\tGIT_CHECKOUT_SAFE | GIT_CHECKOUT_DONT_OVERWRITE_IGNORED, false));",
            "+\t\tGIT_CHECKOUT_DONT_OVERWRITE_IGNORED, false));",
            " ",
            " \tcl_assert_equal_i(GIT_ECONFLICT, error);",
            " }",
            " ",
            " void test_checkout_tree__can_overwrite_ignored_by_default(void)",
            " {",
            " \tcl_git_pass(checkout_tree_with_blob_ignored_in_workdir(GIT_CHECKOUT_SAFE, false));",
            "@@ -330,15 +328,15 @@",
            " }",
            " ",
            " void test_checkout_tree__conflict_on_ignored_folder_when_not_overwriting(void)",
            " {",
            " \tint error;",
            " ",
            " \tcl_git_fail(error = checkout_tree_with_blob_ignored_in_workdir(",
            "-\t\tGIT_CHECKOUT_SAFE | GIT_CHECKOUT_DONT_OVERWRITE_IGNORED, true));",
            "+\t\tGIT_CHECKOUT_DONT_OVERWRITE_IGNORED, true));",
            " ",
            " \tcl_assert_equal_i(GIT_ECONFLICT, error);",
            " }",
            " ",
            " void test_checkout_tree__can_overwrite_ignored_folder_by_default(void)",
            " {",
            " \tcl_git_pass(checkout_tree_with_blob_ignored_in_workdir(GIT_CHECKOUT_SAFE, true));",
            "@@ -366,15 +364,15 @@",
            " ",
            " \tcl_assert(!git_fs_path_isdir(\"testrepo/a\"));",
            " ",
            " \tcheck_file_contents_nocr(\"testrepo/branch_file.txt\", \"hi\\nbye!\\n\");",
            " ",
            " \t/* now checkout branch but with update only */",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_UPDATE_ONLY;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_UPDATE_ONLY;",
            " ",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"refs/heads/dir\"));",
            " \tcl_git_pass(git_object_lookup(&obj, g_repo, &oid, GIT_OBJECT_ANY));",
            " ",
            " \tcl_git_pass(git_checkout_tree(g_repo, obj, &opts));",
            " \tcl_git_pass(git_repository_set_head(g_repo, \"refs/heads/dir\"));",
            " ",
            "@@ -413,15 +411,14 @@",
            " \tcl_assert(git_fs_path_exists(\"testrepo/README\"));",
            " \tcl_assert(!git_fs_path_exists(\"testrepo/branch_file.txt\"));",
            " \tcl_assert(!git_fs_path_exists(\"testrepo/link_to_new.txt\"));",
            " \tcl_assert(!git_fs_path_exists(\"testrepo/new.txt\"));",
            " ",
            " \t/* now to a narrow patterned checkout */",
            " ",
            "-\tg_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            " \tg_opts.paths.strings = entries;",
            " \tg_opts.paths.count = 1;",
            " ",
            " \tcl_git_pass(git_revparse_single(&g_object, g_repo, \"refs/heads/master\"));",
            " ",
            " \tcl_git_pass(git_checkout_tree(g_repo, g_object, &g_opts));",
            " ",
            "@@ -485,15 +482,14 @@",
            " \tg_object = NULL;",
            " ",
            " \tcl_assert(!git_fs_path_isfile(\"testrepo/branch_file.txt\"));",
            " ",
            " \t/* now to a narrow patterned checkout, but disable pattern */",
            " ",
            " \tg_opts.checkout_strategy =",
            "-\t\tGIT_CHECKOUT_SAFE |",
            " \t\tGIT_CHECKOUT_DISABLE_PATHSPEC_MATCH;",
            " \tg_opts.paths.strings = entries;",
            " \tg_opts.paths.count = 1;",
            " ",
            " \tcl_git_pass(git_revparse_single(&g_object, g_repo, \"refs/heads/master\"));",
            " ",
            " \tcl_git_pass(git_checkout_tree(g_repo, g_object, &g_opts));",
            "@@ -602,16 +598,14 @@",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tgit_oid old_id, new_id;",
            " \tgit_commit *old_commit = NULL, *new_commit = NULL;",
            " \tgit_index *index = NULL;",
            " \tcheckout_counts ct;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tmemset(&ct, 0, sizeof(ct));",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_ALL;",
            " \topts.notify_cb = checkout_count_callback;",
            " \topts.notify_payload = &ct;",
            " ",
            " \tcl_git_pass(git_repository_index(&index, g_repo));",
            " ",
            "@@ -879,16 +873,15 @@",
            " \tmemset(&cts, 0, sizeof(cts));",
            " ",
            " \ttest_checkout_tree__cleanup(); /* cleanup default checkout */",
            " ",
            " \tg_repo = cl_git_sandbox_init(\"testrepo.git\");",
            " \tcl_assert(git_repository_is_bare(g_repo));",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE |",
            "-\t\tGIT_CHECKOUT_RECREATE_MISSING;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_RECREATE_MISSING;",
            " ",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_ALL;",
            " \topts.notify_cb = checkout_count_callback;",
            " \topts.notify_payload = &cts;",
            " ",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"HEAD\"));",
            " \tcl_git_pass(git_object_lookup(&g_object, g_repo, &oid, GIT_OBJECT_ANY));",
            "@@ -959,16 +952,14 @@",
            " ",
            " void test_checkout_tree__fails_when_conflicts_exist_in_index(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tgit_oid oid;",
            " \tgit_object *obj = NULL;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"HEAD\"));",
            " \tcl_git_pass(git_object_lookup(&obj, g_repo, &oid, GIT_OBJECT_ANY));",
            " ",
            " \tcreate_conflict(\"conflicts.txt\");",
            " ",
            " \tcl_git_fail(git_checkout_tree(g_repo, obj, &opts));",
            " ",
            "@@ -1618,25 +1609,23 @@",
            " \tgit_index_free(index);",
            " }",
            " ",
            " void test_checkout_tree__retains_external_index_changes(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            "-",
            " \tmodify_index_and_checkout_tree(&opts);",
            " \tassert_status_entrycount(g_repo, 1);",
            " }",
            " ",
            " void test_checkout_tree__no_index_refresh(void)",
            " {",
            " \tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_NO_REFRESH;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_NO_REFRESH;",
            " ",
            " \tmodify_index_and_checkout_tree(&opts);",
            " \tassert_status_entrycount(g_repo, 0);",
            " }",
            " ",
            " void test_checkout_tree__dry_run(void)",
            " {",
            "@@ -1655,15 +1644,15 @@",
            " \tcl_assert(!git_fs_path_isdir(\"testrepo/a\"));",
            " ",
            " \tcheck_file_contents_nocr(\"testrepo/branch_file.txt\", \"hi\\nbye!\\n\");",
            " ",
            " \t/* now checkout branch but with dry run enabled */",
            " ",
            " \tmemset(&ct, 0, sizeof(ct));",
            "-\topts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_DRY_RUN;",
            "+\topts.checkout_strategy = GIT_CHECKOUT_DRY_RUN;",
            " \topts.notify_flags = GIT_CHECKOUT_NOTIFY_ALL;",
            " \topts.notify_cb = checkout_count_callback;",
            " \topts.notify_payload = &ct;",
            " ",
            " \tcl_git_pass(git_reference_name_to_id(&oid, g_repo, \"refs/heads/dir\"));",
            " \tcl_git_pass(git_object_lookup(&obj, g_repo, &oid, GIT_OBJECT_ANY));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/cherrypick/workdir.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/cherrypick/workdir.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/cherrypick/workdir.c",
            "@@ -253,15 +253,15 @@",
            " \tstruct merge_index_entry merge_filesystem_entries[] = {",
            " \t\t{ 0100644, \"242e7977ba73637822ffb265b46004b9b0e5153b\", 0, \"file1.txt\" },",
            " \t\t{ 0100644, \"bd6ffc8c6c41f0f85ff9e3d61c9479516bac0024\", 0, \"file2.txt\" },",
            " \t\t{ 0100644, \"1124c2c1ae07b26fded662d6c3f3631d9dc16f88\", 0, \"file3.txt\" },",
            " \t};",
            " ",
            " \t/* leave the index in a conflicted state, but checkout \"ours\" to the workdir */",
            "-\topts.checkout_opts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_USE_OURS;",
            "+\topts.checkout_opts.checkout_strategy = GIT_CHECKOUT_USE_OURS;",
            " ",
            " \tgit_oid__fromstr(&head_oid, \"bafbf6912c09505ac60575cd43d3f2aba3bd84d8\", GIT_OID_SHA1);",
            " ",
            " \tcl_git_pass(git_commit_lookup(&head, repo, &head_oid));",
            " \tcl_git_pass(git_reset(repo, (git_object *)head, GIT_RESET_HARD, NULL));",
            " ",
            " \tgit_oid__fromstr(&cherry_oid, \"e9b63f3655b2ad80c0ff587389b5a9589a3a7110\", GIT_OID_SHA1);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/clone/local.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/clone/local.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/clone/local.c",
            "@@ -50,49 +50,95 @@",
            " \treturn 0;",
            " }",
            " #endif",
            " ",
            " void test_clone_local__should_clone_local(void)",
            " {",
            " \tgit_str buf = GIT_STR_INIT;",
            "+\tbool local;",
            " ",
            " \t/* we use a fixture path because it needs to exist for us to want to clone */",
            " \tconst char *path = cl_fixture(\"testrepo.git\");",
            " ",
            "+\t/* empty string */",
            " \tcl_git_pass(file_url(&buf, \"\", path));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "+\tcl_assert_equal_i(false, local);",
            " ",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\t/* localhost is special */",
            " \tcl_git_pass(file_url(&buf, \"localhost\", path));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL));",
            "+\tcl_assert_equal_i(true, local);",
            " ",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\t/* a remote host */",
            " \tcl_git_pass(file_url(&buf, \"other-host.mycompany.com\", path));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+\tcl_assert_equal_i(false, local);",
            " ",
            " \t/* Ensure that file:/// urls are percent decoded: .git == %2e%67%69%74 */",
            " \tcl_git_pass(file_url(&buf, \"\", path));",
            " \tgit_str_shorten(&buf, 4);",
            " \tcl_git_pass(git_str_puts(&buf, \"%2e%67%69%74\"));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_NO_LOCAL));",
            "-",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(path, GIT_CLONE_LOCAL_AUTO));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(path, GIT_CLONE_LOCAL));",
            "-\tcl_assert_equal_i(1,  git_clone__should_clone_local(path, GIT_CLONE_LOCAL_NO_LINKS));",
            "-\tcl_assert_equal_i(0, git_clone__should_clone_local(path, GIT_CLONE_NO_LOCAL));",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_AUTO));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_LOCAL_NO_LINKS));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, buf.ptr, GIT_CLONE_NO_LOCAL));",
            "+\tcl_assert_equal_i(false, local);",
            "+",
            "+\t/* a local path on disk */",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, path, GIT_CLONE_LOCAL_AUTO));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, path, GIT_CLONE_LOCAL));",
            "+",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, path, GIT_CLONE_LOCAL_NO_LINKS));",
            "+\tcl_assert_equal_i(true, local);",
            "+",
            "+\tcl_git_pass(git_clone__should_clone_local(&local, path, GIT_CLONE_NO_LOCAL));",
            "+\tcl_assert_equal_i(false, local);",
            " ",
            " \tgit_str_dispose(&buf);",
            " }",
            " ",
            " void test_clone_local__hardlinks(void)",
            " {",
            " \tgit_repository *repo;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/clone/nonetwork.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/clone/nonetwork.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/clone/nonetwork.c",
            "@@ -20,15 +20,14 @@",
            " \tgit_fetch_options dummy_fetch = GIT_FETCH_OPTIONS_INIT;",
            " ",
            " \tg_repo = NULL;",
            " ",
            " \tmemset(&g_options, 0, sizeof(git_clone_options));",
            " \tg_options.version = GIT_CLONE_OPTIONS_VERSION;",
            " \tg_options.checkout_opts = dummy_opts;",
            "-\tg_options.checkout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            " \tg_options.fetch_opts = dummy_fetch;",
            " }",
            " ",
            " void test_clone_nonetwork__cleanup(void)",
            " {",
            " \tif (g_repo) {",
            " \t\tgit_repository_free(g_repo);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/commit/signature.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/commit/signature.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/commit/signature.c",
            "@@ -149,7 +149,87 @@",
            " \tcl_git_pass(git_signature_from_buffer(&with_pos_zero, \"Test User <test@test.tt> 1461698487 +0000\"));",
            " ",
            " \tcl_assert(!git_signature__equal(with_neg_zero, with_pos_zero));",
            " ",
            " \tgit_signature_free((git_signature *)with_neg_zero);",
            " \tgit_signature_free((git_signature *)with_pos_zero);",
            " }",
            "+",
            "+static git_repository *g_repo;",
            "+",
            "+void test_commit_signature__initialize(void)",
            "+{",
            "+\tg_repo = cl_git_sandbox_init(\"empty_standard_repo\");",
            "+}",
            "+",
            "+void test_commit_signature__cleanup(void)",
            "+{",
            "+\tcl_git_sandbox_cleanup();",
            "+\tg_repo = NULL;",
            "+}",
            "+",
            "+void test_commit_signature__from_env(void)",
            "+{",
            "+\tgit_signature *author_sign, *committer_sign;",
            "+\tgit_config *cfg, *local;",
            "+\tcl_git_pass(git_repository_config(&cfg, g_repo));",
            "+\tcl_git_pass(git_config_open_level(&local, cfg, GIT_CONFIG_LEVEL_LOCAL));",
            "+\t/* No configuration value is set and no environment variable */",
            "+\tcl_setenv(\"EMAIL\", NULL);",
            "+\tcl_setenv(\"GIT_AUTHOR_NAME\", NULL);",
            "+\tcl_setenv(\"GIT_AUTHOR_EMAIL\", NULL);",
            "+\tcl_setenv(\"GIT_COMMITTER_NAME\", NULL);",
            "+\tcl_setenv(\"GIT_COMMITTER_EMAIL\", NULL);",
            "+\tcl_git_fail(git_signature_default_from_env(&author_sign, &committer_sign, g_repo));",
            "+\t/* Name is read from configuration and email is read from fallback EMAIL",
            "+\t * environment variable */",
            "+\tcl_git_pass(git_config_set_string(local, \"user.name\", \"Name (config)\"));",
            "+\tcl_setenv(\"EMAIL\", \"email-envvar@example.com\");",
            "+\tcl_git_pass(git_signature_default_from_env(&author_sign, &committer_sign, g_repo));",
            "+\tcl_assert_equal_s(\"Name (config)\", author_sign->name);",
            "+\tcl_assert_equal_s(\"email-envvar@example.com\", author_sign->email);",
            "+\tcl_assert_equal_s(\"Name (config)\", committer_sign->name);",
            "+\tcl_assert_equal_s(\"email-envvar@example.com\", committer_sign->email);",
            "+\tcl_setenv(\"EMAIL\", NULL);",
            "+\tgit_signature_free(author_sign);",
            "+\tgit_signature_free(committer_sign);",
            "+\t/* Environment variables have precedence over configuration */",
            "+\tcl_git_pass(git_config_set_string(local, \"user.email\", \"config@example.com\"));",
            "+\tcl_setenv(\"GIT_AUTHOR_NAME\", \"Author (envvar)\");",
            "+\tcl_setenv(\"GIT_AUTHOR_EMAIL\", \"author-envvar@example.com\");",
            "+\tcl_setenv(\"GIT_COMMITTER_NAME\", \"Committer (envvar)\");",
            "+\tcl_setenv(\"GIT_COMMITTER_EMAIL\", \"committer-envvar@example.com\");",
            "+\tcl_git_pass(git_signature_default_from_env(&author_sign, &committer_sign, g_repo));",
            "+\tcl_assert_equal_s(\"Author (envvar)\", author_sign->name);",
            "+\tcl_assert_equal_s(\"author-envvar@example.com\", author_sign->email);",
            "+\tcl_assert_equal_s(\"Committer (envvar)\", committer_sign->name);",
            "+\tcl_assert_equal_s(\"committer-envvar@example.com\", committer_sign->email);",
            "+\tgit_signature_free(author_sign);",
            "+\tgit_signature_free(committer_sign);",
            "+\t/* When environment variables are not set we can still read from",
            "+\t * configuration */",
            "+\tcl_setenv(\"GIT_AUTHOR_NAME\", NULL);",
            "+\tcl_setenv(\"GIT_AUTHOR_EMAIL\", NULL);",
            "+\tcl_setenv(\"GIT_COMMITTER_NAME\", NULL);",
            "+\tcl_setenv(\"GIT_COMMITTER_EMAIL\", NULL);",
            "+\tcl_git_pass(git_signature_default_from_env(&author_sign, &committer_sign, g_repo));",
            "+\tcl_assert_equal_s(\"Name (config)\", author_sign->name);",
            "+\tcl_assert_equal_s(\"config@example.com\", author_sign->email);",
            "+\tcl_assert_equal_s(\"Name (config)\", committer_sign->name);",
            "+\tcl_assert_equal_s(\"config@example.com\", committer_sign->email);",
            "+\tgit_signature_free(author_sign);",
            "+\tgit_signature_free(committer_sign);",
            "+\t/* We can also override the timestamp with an environment variable */",
            "+\tcl_setenv(\"GIT_AUTHOR_DATE\", \"1971-02-03 04:05:06+01\");",
            "+\tcl_setenv(\"GIT_COMMITTER_DATE\", \"1988-09-10 11:12:13-01\");",
            "+\tcl_git_pass(git_signature_default_from_env(&author_sign, &committer_sign, g_repo));",
            "+\tcl_assert_equal_i(34398306, author_sign->when.time);  /* 1971-02-03 03:05:06 UTC */",
            "+\tcl_assert_equal_i(60, author_sign->when.offset);",
            "+\tcl_assert_equal_i(589896733, committer_sign->when.time);  /* 1988-09-10 12:12:13 UTC */",
            "+\tcl_assert_equal_i(-60, committer_sign->when.offset);",
            "+\tgit_signature_free(author_sign);",
            "+\tgit_signature_free(committer_sign);",
            "+\tcl_setenv(\"GIT_AUTHOR_DATE\", NULL);",
            "+\tcl_setenv(\"GIT_COMMITTER_DATE\", NULL);",
            "+\tgit_config_free(local);",
            "+\tgit_config_free(cfg);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/config/global.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/config/global.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/config/global.c",
            "@@ -16,14 +16,19 @@",
            " \t\tGIT_OPT_SET_SEARCH_PATH, GIT_CONFIG_LEVEL_XDG, path.ptr));",
            " ",
            " \tcl_git_pass(git_futils_mkdir_r(\"etc\", 0777));",
            " \tcl_git_pass(git_fs_path_prettify(&path, \"etc\", NULL));",
            " \tcl_git_pass(git_libgit2_opts(",
            " \t\tGIT_OPT_SET_SEARCH_PATH, GIT_CONFIG_LEVEL_SYSTEM, path.ptr));",
            " ",
            "+\tcl_git_pass(git_futils_mkdir_r(\"programdata\", 0777));",
            "+\tcl_git_pass(git_fs_path_prettify(&path, \"programdata\", NULL));",
            "+\tcl_git_pass(git_libgit2_opts(",
            "+\t\tGIT_OPT_SET_SEARCH_PATH, GIT_CONFIG_LEVEL_PROGRAMDATA, path.ptr));",
            "+",
            " \tgit_str_dispose(&path);",
            " }",
            " ",
            " void test_config_global__cleanup(void)",
            " {",
            " \tcl_sandbox_set_search_path_defaults();",
            " \tcl_git_pass(git_futils_rmdir_r(\"home\", NULL, GIT_RMDIR_REMOVE_FILES));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/core/features.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/core/features.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/core/features.c",
            "@@ -1,19 +1,12 @@",
            " #include \"clar_libgit2.h\"",
            " ",
            "-void test_core_features__0(void)",
            "+void test_core_features__basic(void)",
            " {",
            "-\tint major, minor, rev, caps;",
            "-",
            "-\tgit_libgit2_version(&major, &minor, &rev);",
            "-\tcl_assert_equal_i(LIBGIT2_VER_MAJOR, major);",
            "-\tcl_assert_equal_i(LIBGIT2_VER_MINOR, minor);",
            "-\tcl_assert_equal_i(LIBGIT2_VER_REVISION, rev);",
            "-",
            "-\tcaps = git_libgit2_features();",
            "+\tint caps = git_libgit2_features();",
            " ",
            " #ifdef GIT_THREADS",
            " \tcl_assert((caps & GIT_FEATURE_THREADS) != 0);",
            " #else",
            " \tcl_assert((caps & GIT_FEATURE_THREADS) == 0);",
            " #endif",
            " ",
            "@@ -28,8 +21,206 @@",
            " #endif",
            " ",
            " #if defined(GIT_USE_NSEC)",
            " \tcl_assert((caps & GIT_FEATURE_NSEC) != 0);",
            " #else",
            " \tcl_assert((caps & GIT_FEATURE_NSEC) == 0);",
            " #endif",
            "+",
            "+\tcl_assert((caps & GIT_FEATURE_HTTP_PARSER) != 0);",
            "+\tcl_assert((caps & GIT_FEATURE_REGEX) != 0);",
            "+",
            "+#if defined(GIT_USE_ICONV)",
            "+\tcl_assert((caps & GIT_FEATURE_I18N) != 0);",
            "+#endif",
            "+",
            "+#if defined(GIT_NTLM) || defined(GIT_WIN32)",
            "+\tcl_assert((caps & GIT_FEATURE_AUTH_NTLM) != 0);",
            "+#endif",
            "+#if defined(GIT_GSSAPI) || defined(GIT_GSSFRAMEWORK) || defined(GIT_WIN32)",
            "+\tcl_assert((caps & GIT_FEATURE_AUTH_NEGOTIATE) != 0);",
            "+#endif",
            "+",
            "+\tcl_assert((caps & GIT_FEATURE_COMPRESSION) != 0);",
            "+\tcl_assert((caps & GIT_FEATURE_SHA1) != 0);",
            "+",
            "+#if defined(GIT_EXPERIMENTAL_SHA256)",
            "+\tcl_assert((caps & GIT_FEATURE_SHA256) != 0);",
            "+#endif",
            "+",
            "+\t/*",
            "+\t * Ensure that our tests understand all the features;",
            "+\t * this test tries to ensure that if there's a new feature",
            "+\t * added that the backends test (below) is updated as well.",
            "+\t */",
            "+\tcl_assert((caps & ~(GIT_FEATURE_THREADS |",
            "+\t                    GIT_FEATURE_HTTPS |",
            "+\t                    GIT_FEATURE_SSH |",
            "+\t                    GIT_FEATURE_NSEC |",
            "+\t                    GIT_FEATURE_HTTP_PARSER |",
            "+\t                    GIT_FEATURE_REGEX |",
            "+\t                    GIT_FEATURE_I18N |",
            "+\t                    GIT_FEATURE_AUTH_NTLM |",
            "+\t                    GIT_FEATURE_AUTH_NEGOTIATE |",
            "+\t                    GIT_FEATURE_COMPRESSION |",
            "+\t                    GIT_FEATURE_SHA1 |",
            "+\t                    GIT_FEATURE_SHA256",
            "+\t\t\t    )) == 0);",
            "+}",
            "+",
            "+void test_core_features__backends(void)",
            "+{",
            "+\tconst char *threads = git_libgit2_feature_backend(GIT_FEATURE_THREADS);",
            "+\tconst char *https = git_libgit2_feature_backend(GIT_FEATURE_HTTPS);",
            "+\tconst char *ssh = git_libgit2_feature_backend(GIT_FEATURE_SSH);",
            "+\tconst char *nsec = git_libgit2_feature_backend(GIT_FEATURE_NSEC);",
            "+\tconst char *http_parser = git_libgit2_feature_backend(GIT_FEATURE_HTTP_PARSER);",
            "+\tconst char *regex = git_libgit2_feature_backend(GIT_FEATURE_REGEX);",
            "+\tconst char *i18n = git_libgit2_feature_backend(GIT_FEATURE_I18N);",
            "+\tconst char *ntlm = git_libgit2_feature_backend(GIT_FEATURE_AUTH_NTLM);",
            "+\tconst char *negotiate = git_libgit2_feature_backend(GIT_FEATURE_AUTH_NEGOTIATE);",
            "+\tconst char *compression = git_libgit2_feature_backend(GIT_FEATURE_COMPRESSION);",
            "+\tconst char *sha1 = git_libgit2_feature_backend(GIT_FEATURE_SHA1);",
            "+\tconst char *sha256 = git_libgit2_feature_backend(GIT_FEATURE_SHA256);",
            "+",
            "+#if defined(GIT_THREADS) && defined(GIT_WIN32)",
            "+\tcl_assert_equal_s(\"win32\", threads);",
            "+#elif defined(GIT_THREADS)",
            "+\tcl_assert_equal_s(\"pthread\", threads);",
            "+#else",
            "+\tcl_assert(threads == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_HTTPS) && defined(GIT_OPENSSL)",
            "+\tcl_assert_equal_s(\"openssl\", https);",
            "+#elif defined(GIT_HTTPS) && defined(GIT_OPENSSL_DYNAMIC)",
            "+\tcl_assert_equal_s(\"openssl-dynamic\", https);",
            "+#elif defined(GIT_HTTPS) && defined(GIT_MBEDTLS)",
            "+\tcl_assert_equal_s(\"mbedtls\", https);",
            "+#elif defined(GIT_HTTPS) && defined(GIT_SECURE_TRANSPORT)",
            "+\tcl_assert_equal_s(\"securetransport\", https);",
            "+#elif defined(GIT_HTTPS) && defined(GIT_SCHANNEL)",
            "+\tcl_assert_equal_s(\"schannel\", https);",
            "+#elif defined(GIT_HTTPS) && defined(GIT_WINHTTP)",
            "+\tcl_assert_equal_s(\"winhttp\", https);",
            "+#elif defined(GIT_HTTPS)",
            "+\tcl_assert(0);",
            "+#else",
            "+\tcl_assert(https == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_SSH) && defined(GIT_SSH_EXEC)",
            "+\tcl_assert_equal_s(\"exec\", ssh);",
            "+#elif defined(GIT_SSH) && defined(GIT_SSH_LIBSSH2)",
            "+\tcl_assert_equal_s(\"libssh2\", ssh);",
            "+#elif defined(GIT_SSH)",
            "+\tcl_assert(0);",
            "+#else",
            "+\tcl_assert(ssh == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_USE_NSEC) && defined(GIT_USE_STAT_MTIMESPEC)",
            "+\tcl_assert_equal_s(\"mtimespec\", nsec);",
            "+#elif defined(GIT_USE_NSEC) && defined(GIT_USE_STAT_MTIM)",
            "+\tcl_assert_equal_s(\"mtim\", nsec);",
            "+#elif defined(GIT_USE_NSEC) && defined(GIT_USE_STAT_MTIME_NSEC)",
            "+\tcl_assert_equal_s(\"mtime\", nsec);",
            "+#elif defined(GIT_USE_NSEC) && defined(GIT_WIN32)",
            "+\tcl_assert_equal_s(\"win32\", nsec);",
            "+#elif defined(GIT_USE_NSEC)",
            "+\tcl_assert(0);",
            "+#else",
            "+\tcl_assert(nsec == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_HTTPPARSER_HTTPPARSER)",
            "+\tcl_assert_equal_s(\"httpparser\", http_parser);",
            "+#elif defined(GIT_HTTPPARSER_LLHTTP)",
            "+\tcl_assert_equal_s(\"llhttp\", http_parser);",
            "+#elif defined(GIT_HTTPPARSER_BUILTIN)",
            "+\tcl_assert_equal_s(\"builtin\", http_parser);",
            "+#else",
            "+\tcl_assert(0);",
            "+#endif",
            "+",
            "+#if defined(GIT_REGEX_REGCOMP_L)",
            "+\tcl_assert_equal_s(\"regcomp_l\", regex);",
            "+#elif defined(GIT_REGEX_REGCOMP)",
            "+\tcl_assert_equal_s(\"regcomp\", regex);",
            "+#elif defined(GIT_REGEX_PCRE)",
            "+\tcl_assert_equal_s(\"pcre\", regex);",
            "+#elif defined(GIT_REGEX_PCRE2)",
            "+\tcl_assert_equal_s(\"pcre2\", regex);",
            "+#elif defined(GIT_REGEX_BUILTIN)",
            "+\tcl_assert_equal_s(\"builtin\", regex);",
            "+#else",
            "+\tcl_assert(0);",
            "+#endif",
            "+",
            "+#if defined(GIT_USE_ICONV)",
            "+\tcl_assert_equal_s(\"iconv\", i18n);",
            "+#else",
            "+\tcl_assert(i18n == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_NTLM)",
            "+\tcl_assert_equal_s(\"ntlmclient\", ntlm);",
            "+#elif defined(GIT_WIN32)",
            "+\tcl_assert_equal_s(\"sspi\", ntlm);",
            "+#else",
            "+\tcl_assert(ntlm == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_GSSAPI)",
            "+\tcl_assert_equal_s(\"gssapi\", negotiate);",
            "+#elif defined(GIT_WIN32)",
            "+\tcl_assert_equal_s(\"sspi\", negotiate);",
            "+#else",
            "+\tcl_assert(negotiate == NULL);",
            "+#endif",
            "+",
            "+#if defined(GIT_COMPRESSION_BUILTIN)",
            "+\tcl_assert_equal_s(\"builtin\", compression);",
            "+#elif defined(GIT_COMPRESSION_ZLIB)",
            "+\tcl_assert_equal_s(\"zlib\", compression);",
            "+#else",
            "+\tcl_assert(0);",
            "+#endif",
            "+",
            "+#if defined(GIT_SHA1_COLLISIONDETECT)",
            "+\tcl_assert_equal_s(\"builtin\", sha1);",
            "+#elif defined(GIT_SHA1_OPENSSL)",
            "+\tcl_assert_equal_s(\"openssl\", sha1);",
            "+#elif defined(GIT_SHA1_OPENSSL_FIPS)",
            "+\tcl_assert_equal_s(\"openssl-fips\", sha1);",
            "+#elif defined(GIT_SHA1_OPENSSL_DYNAMIC)",
            "+\tcl_assert_equal_s(\"openssl-dynamic\", sha1);",
            "+#elif defined(GIT_SHA1_MBEDTLS)",
            "+\tcl_assert_equal_s(\"mbedtls\", sha1);",
            "+#elif defined(GIT_SHA1_COMMON_CRYPTO)",
            "+\tcl_assert_equal_s(\"commoncrypto\", sha1);",
            "+#elif defined(GIT_SHA1_WIN32)",
            "+\tcl_assert_equal_s(\"win32\", sha1);",
            "+#else",
            "+\tcl_assert(0);",
            "+#endif",
            "+",
            "+#if defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_BUILTIN)",
            "+\tcl_assert_equal_s(\"builtin\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_OPENSSL)",
            "+\tcl_assert_equal_s(\"openssl\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_OPENSSL_FIPS)",
            "+\tcl_assert_equal_s(\"openssl-fips\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_OPENSSL_DYNAMIC)",
            "+\tcl_assert_equal_s(\"openssl-dynamic\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_MBEDTLS)",
            "+\tcl_assert_equal_s(\"mbedtls\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_COMMON_CRYPTO)",
            "+\tcl_assert_equal_s(\"commoncrypto\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256) && defined(GIT_SHA256_WIN32)",
            "+\tcl_assert_equal_s(\"win32\", sha256);",
            "+#elif defined(GIT_EXPERIMENTAL_SHA256)",
            "+\tcl_assert(0);",
            "+#else",
            "+\tcl_assert(sha256 == NULL);",
            "+#endif",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/core/opts.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/core/opts.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/core/opts.c",
            "@@ -30,66 +30,70 @@",
            " ",
            " void test_core_opts__extensions_query(void)",
            " {",
            " \tgit_strarray out = { 0 };",
            " ",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, &out));",
            " ",
            "-\tcl_assert_equal_sz(out.count, 3);",
            "+\tcl_assert_equal_sz(out.count, 4);",
            " \tcl_assert_equal_s(\"noop\", out.strings[0]);",
            " \tcl_assert_equal_s(\"objectformat\", out.strings[1]);",
            "-\tcl_assert_equal_s(\"worktreeconfig\", out.strings[2]);",
            "+\tcl_assert_equal_s(\"preciousobjects\", out.strings[2]);",
            "+\tcl_assert_equal_s(\"worktreeconfig\", out.strings[3]);",
            " ",
            " \tgit_strarray_dispose(&out);",
            " }",
            " ",
            " void test_core_opts__extensions_add(void)",
            " {",
            " \tconst char *in[] = { \"foo\" };",
            " \tgit_strarray out = { 0 };",
            " ",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, in, ARRAY_SIZE(in)));",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, &out));",
            " ",
            "-\tcl_assert_equal_sz(out.count, 4);",
            "+\tcl_assert_equal_sz(out.count, 5);",
            " \tcl_assert_equal_s(\"foo\", out.strings[0]);",
            " \tcl_assert_equal_s(\"noop\", out.strings[1]);",
            " \tcl_assert_equal_s(\"objectformat\", out.strings[2]);",
            "-\tcl_assert_equal_s(\"worktreeconfig\", out.strings[3]);",
            "+\tcl_assert_equal_s(\"preciousobjects\", out.strings[3]);",
            "+\tcl_assert_equal_s(\"worktreeconfig\", out.strings[4]);",
            " ",
            " \tgit_strarray_dispose(&out);",
            " }",
            " ",
            " void test_core_opts__extensions_remove(void)",
            " {",
            " \tconst char *in[] = { \"bar\", \"!negate\", \"!noop\", \"baz\" };",
            " \tgit_strarray out = { 0 };",
            " ",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, in, ARRAY_SIZE(in)));",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, &out));",
            " ",
            "-\tcl_assert_equal_sz(out.count, 4);",
            "+\tcl_assert_equal_sz(out.count, 5);",
            " \tcl_assert_equal_s(\"bar\", out.strings[0]);",
            " \tcl_assert_equal_s(\"baz\", out.strings[1]);",
            " \tcl_assert_equal_s(\"objectformat\", out.strings[2]);",
            "-\tcl_assert_equal_s(\"worktreeconfig\", out.strings[3]);",
            "+\tcl_assert_equal_s(\"preciousobjects\", out.strings[3]);",
            "+\tcl_assert_equal_s(\"worktreeconfig\", out.strings[4]);",
            " ",
            " \tgit_strarray_dispose(&out);",
            " }",
            " ",
            " void test_core_opts__extensions_uniq(void)",
            " {",
            " \tconst char *in[] = { \"foo\", \"noop\", \"bar\", \"bar\", \"foo\", \"objectformat\" };",
            " \tgit_strarray out = { 0 };",
            " ",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, in, ARRAY_SIZE(in)));",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_GET_EXTENSIONS, &out));",
            " ",
            "-\tcl_assert_equal_sz(out.count, 5);",
            "+\tcl_assert_equal_sz(out.count, 6);",
            " \tcl_assert_equal_s(\"bar\", out.strings[0]);",
            " \tcl_assert_equal_s(\"foo\", out.strings[1]);",
            " \tcl_assert_equal_s(\"noop\", out.strings[2]);",
            " \tcl_assert_equal_s(\"objectformat\", out.strings[3]);",
            "-\tcl_assert_equal_s(\"worktreeconfig\", out.strings[4]);",
            "+\tcl_assert_equal_s(\"preciousobjects\", out.strings[4]);",
            "+\tcl_assert_equal_s(\"worktreeconfig\", out.strings[5]);",
            " ",
            " \tgit_strarray_dispose(&out);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/date/date.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/date/date.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/date/date.c",
            "@@ -16,7 +16,15 @@",
            " ",
            " void test_date_date__invalid_date(void)",
            " {",
            "    git_time_t d;",
            "    cl_git_fail(git_date_parse(&d, \"\"));",
            "    cl_git_fail(git_date_parse(&d, \"NEITHER_INTEGER_NOR_DATETIME\"));",
            " }",
            "+",
            "+void test_date_date__offset(void)",
            "+{",
            "+\tgit_time_t d;",
            "+\tint offset;",
            "+\tcl_git_pass(git_date_offset_parse(&d, &offset, \"1970-1-1 01:00:00+03\"));",
            "+\tcl_assert_equal_i(offset, 3*60);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/diff/drivers.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/diff/drivers.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/diff/drivers.c",
            "@@ -245,15 +245,15 @@",
            " ",
            " \t\tgit__free(path);",
            " \t}",
            " ",
            " \tgit_buf_dispose(&actual);",
            " \tgit_str_dispose(&file);",
            " \tgit_str_dispose(&expected);",
            "-\tgit_vector_free(&files);",
            "+\tgit_vector_dispose(&files);",
            " }",
            " ",
            " void test_diff_drivers__invalid_pattern(void)",
            " {",
            " \tgit_config *cfg;",
            " \tgit_index *idx;",
            " \tgit_diff *diff;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/diff/stats.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/diff/stats.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/diff/stats.c",
            "@@ -225,14 +225,34 @@",
            " \tcl_assert_equal_sz(0, git_diff_stats_deletions(_stats));",
            " ",
            " \tcl_git_pass(git_diff_stats_to_buf(&buf, _stats, GIT_DIFF_STATS_FULL, 0));",
            " \tcl_assert_equal_s(stat, buf.ptr);",
            " \tgit_buf_dispose(&buf);",
            " }",
            " ",
            "+void test_diff_stats__rename_in_subdirectory_aligns(void)",
            "+{",
            "+\tgit_buf buf = GIT_BUF_INIT;",
            "+\tconst char *stat =",
            "+\t\" dir/{renamed.txt => rerenamed.txt} | 0\\n\"",
            "+\t\" file3.txt                          | 2 +-\\n\"",
            "+\t\" 2 files changed, 1 insertion(+), 1 deletion(-)\\n\";",
            "+",
            "+\tdiff_stats_from_commit_oid(",
            "+\t\t&_stats, \"7f4c6d9d6ba363e3352f7c21807ca3a7835072b2\", true);",
            "+",
            "+\tcl_assert_equal_sz(2, git_diff_stats_files_changed(_stats));",
            "+\tcl_assert_equal_sz(1, git_diff_stats_insertions(_stats));",
            "+\tcl_assert_equal_sz(1, git_diff_stats_deletions(_stats));",
            "+",
            "+\tcl_git_pass(git_diff_stats_to_buf(&buf, _stats, GIT_DIFF_STATS_FULL, 0));",
            "+\tcl_assert_equal_s(stat, buf.ptr);",
            "+\tgit_buf_dispose(&buf);",
            "+}",
            "+",
            " void test_diff_stats__rename_no_find(void)",
            " {",
            " \tgit_buf buf = GIT_BUF_INIT;",
            " \tconst char *stat =",
            " \t\" file2.txt         | 5 -----\\n\"",
            " \t\" file2.txt.renamed | 6 ++++++\\n\"",
            " \t\" file3.txt         | 5 -----\\n\""
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/diff/workdir.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/diff/workdir.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/diff/workdir.c",
            "@@ -2132,15 +2132,15 @@",
            " \topts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;",
            " ",
            " \tcl_git_pass(git_diff_index_to_workdir(&diff, g_repo, index, &opts));",
            " \tcl_assert_equal_i(0, git_diff_num_deltas(diff));",
            " \tgit_diff_free(diff);",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&pathlist);",
            "+\tgit_vector_dispose(&pathlist);",
            " }",
            " ",
            " void test_diff_workdir__symlink_changed_on_non_symlink_platform(void)",
            " {",
            " \tgit_tree *tree;",
            " \tgit_diff *diff;",
            " \tdiff_expects exp = {0};",
            "@@ -2194,15 +2194,15 @@",
            " \tcl_assert_equal_i(GIT_FILEMODE_LINK, delta->new_file.mode);",
            " ",
            " \tgit_diff_free(diff);",
            " ",
            " \tcl_git_pass(git_futils_rmdir_r(\"symlink\", NULL, GIT_RMDIR_REMOVE_FILES));",
            " ",
            " \tgit_tree_free(tree);",
            "-\tgit_vector_free(&pathlist);",
            "+\tgit_vector_dispose(&pathlist);",
            " }",
            " ",
            " void test_diff_workdir__order(void)",
            " {",
            " \tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;",
            " \tgit_buf patch = GIT_BUF_INIT;",
            " \tgit_oid tree_oid, blob_oid;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/email/create.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/email/create.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/email/create.c",
            "@@ -1,9 +1,10 @@",
            " #include \"clar.h\"",
            " #include \"clar_libgit2.h\"",
            "+#include \"git2/sys/email.h\"",
            " ",
            " #include \"diff_generate.h\"",
            " ",
            " static git_repository *repo;",
            " ",
            " void test_email_create__initialize(void)",
            " {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/fetchhead/nonetwork.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/fetchhead/nonetwork.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/fetchhead/nonetwork.c",
            "@@ -102,15 +102,15 @@",
            " ",
            " \tgit_str_dispose(&fetchhead_buf);",
            " ",
            " \tgit_vector_foreach(&fetchhead_vector, i, fetchhead_ref) {",
            " \t\tgit_fetchhead_ref_free(fetchhead_ref);",
            " \t}",
            " ",
            "-\tgit_vector_free(&fetchhead_vector);",
            "+\tgit_vector_dispose(&fetchhead_vector);",
            " ",
            " \tcl_assert(equals);",
            " }",
            " ",
            " typedef struct {",
            " \tgit_vector *fetchhead_vector;",
            " \tsize_t idx;",
            "@@ -162,15 +162,15 @@",
            " ",
            " \tcl_git_pass(git_repository_fetchhead_foreach(g_repo, fetchhead_ref_cb, &cb_data));",
            " ",
            " \tgit_vector_foreach(&fetchhead_vector, i, fetchhead_ref) {",
            " \t\tgit_fetchhead_ref_free(fetchhead_ref);",
            " \t}",
            " ",
            "-\tgit_vector_free(&fetchhead_vector);",
            "+\tgit_vector_dispose(&fetchhead_vector);",
            " }",
            " ",
            " static int read_old_style_cb(const char *name, const char *url,",
            " \tconst git_oid *oid, unsigned int is_merge, void *payload)",
            " {",
            " \tgit_oid expected;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/filter/query.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/filter/query.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/filter/query.c",
            "@@ -49,14 +49,26 @@",
            " \tcl_assert_equal_i(1, filter_for(\"id.ident\", \"crlf\"));",
            " \tcl_assert_equal_i(1, filter_for(\"id.ident\", \"ident\"));",
            " ",
            " \tcl_assert_equal_i(0, filter_for(\"id.binident\", \"crlf\"));",
            " \tcl_assert_equal_i(1, filter_for(\"id.binident\", \"ident\"));",
            " }",
            " ",
            "+void test_filter_query__filters_ignorecase(void)",
            "+{",
            "+\tif (!cl_repo_get_bool(g_repo, \"core.ignorecase\"))",
            "+\t\tcl_skip();",
            "+",
            "+\tcl_assert_equal_i(1, filter_for(\"TEXT.TXT\", \"crlf\"));",
            "+\tcl_assert_equal_i(0, filter_for(\"Binary.bin\", \"crlf\"));",
            "+",
            "+\tcl_assert_equal_i(1, filter_for(\"id.Ident\", \"crlf\"));",
            "+\tcl_assert_equal_i(1, filter_for(\"ID.IdEnT\", \"ident\"));",
            "+}",
            "+",
            " void test_filter_query__autocrlf_true_implies_crlf(void)",
            " {",
            " \tcl_repo_set_bool(g_repo, \"core.autocrlf\", true);",
            " \tcl_assert_equal_i(1, filter_for(\"not_in_gitattributes\", \"crlf\"));",
            " \tcl_assert_equal_i(1, filter_for(\"foo.txt\", \"crlf\"));",
            " \tcl_assert_equal_i(0, filter_for(\"foo.bin\", \"crlf\"));",
            " \tcl_assert_equal_i(1, filter_for(\"foo.lf\", \"crlf\"));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/filter/systemattrs.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/filter/systemattrs.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/filter/systemattrs.c",
            "@@ -1,39 +1,52 @@",
            " #include \"clar_libgit2.h\"",
            " #include \"crlf.h\"",
            " #include \"path.h\"",
            "+#include \"futils.h\"",
            " ",
            " static git_repository *g_repo = NULL;",
            "+static git_str orig_system_path = GIT_STR_INIT;",
            " static git_str system_attr_path = GIT_STR_INIT;",
            " ",
            " void test_filter_systemattrs__initialize(void)",
            " {",
            "-\tgit_buf system_path = GIT_BUF_INIT;",
            "+\tgit_str new_system_path = GIT_BUF_INIT;",
            " ",
            " \tg_repo = cl_git_sandbox_init(\"crlf\");",
            " \tcl_must_pass(p_unlink(\"crlf/.gitattributes\"));",
            " ",
            " \tcl_git_pass(git_libgit2_opts(",
            "-\t\tGIT_OPT_GET_SEARCH_PATH, GIT_CONFIG_LEVEL_SYSTEM, &system_path));",
            "+\t\tGIT_OPT_GET_SEARCH_PATH, GIT_CONFIG_LEVEL_SYSTEM, &orig_system_path));",
            "+",
            "+\tcl_git_pass(git_str_joinpath(&new_system_path,",
            "+\t\tclar_sandbox_path(), \"_system_path\"));",
            "+\tcl_git_pass(git_futils_mkdir_r(new_system_path.ptr, 0777));",
            "+\tcl_git_pass(git_libgit2_opts(",
            "+\t\tGIT_OPT_SET_SEARCH_PATH, GIT_CONFIG_LEVEL_SYSTEM, new_system_path.ptr));",
            "+",
            " \tcl_git_pass(git_str_joinpath(&system_attr_path,",
            "-\t\tsystem_path.ptr, \"gitattributes\"));",
            "+\t\tnew_system_path.ptr, \"gitattributes\"));",
            " ",
            " \tcl_git_mkfile(system_attr_path.ptr,",
            " \t\t\"*.txt text\\n\"",
            " \t\t\"*.bin binary\\n\"",
            " \t\t\"*.crlf text eol=crlf\\n\"",
            " \t\t\"*.lf text eol=lf\\n\");",
            " ",
            "-\tgit_buf_dispose(&system_path);",
            "+\tgit_str_dispose(&new_system_path);",
            " }",
            " ",
            " void test_filter_systemattrs__cleanup(void)",
            " {",
            "+\tcl_git_pass(git_libgit2_opts(",
            "+\t\tGIT_OPT_SET_SEARCH_PATH, GIT_CONFIG_LEVEL_SYSTEM, orig_system_path.ptr));",
            "+",
            " \tcl_must_pass(p_unlink(system_attr_path.ptr));",
            " \tgit_str_dispose(&system_attr_path);",
            "+\tgit_str_dispose(&orig_system_path);",
            " ",
            " \tcl_git_sandbox_cleanup();",
            " }",
            " ",
            " void test_filter_systemattrs__reads_system_attributes(void)",
            " {",
            " \tgit_blob *blob;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/grafts/shallow.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/grafts/shallow.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/grafts/shallow.c",
            "@@ -106,16 +106,16 @@",
            " \tgit_oid oid_1, oid_2, oid_3;",
            " ",
            " \tg_repo = cl_git_sandbox_init(\"shallow.git\");",
            " ",
            " \tcl_git_pass(git_revwalk_new(&w, g_repo));",
            " \tcl_git_pass(git_revwalk_push_head(w));",
            " ",
            "-\tcl_git_pass(git_revwalk_next(&oid_1, w)); // a65fedf39aefe402d3bb6e24df4d4f5fe4547750",
            "-\tcl_git_pass(git_revwalk_next(&oid_2, w)); // be3563ae3f795b2b4353bcce3a527ad0a4f7f644",
            "+\tcl_git_pass(git_revwalk_next(&oid_1, w)); /* a65fedf39aefe402d3bb6e24df4d4f5fe4547750 */",
            "+\tcl_git_pass(git_revwalk_next(&oid_2, w)); /* be3563ae3f795b2b4353bcce3a527ad0a4f7f644 */",
            " \tcl_git_fail_with(GIT_ITEROVER, git_revwalk_next(&oid_3, w));",
            " ",
            " \tcl_assert_equal_s(git_oid_tostr_s(&oid_1), \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");",
            " \tcl_assert_equal_s(git_oid_tostr_s(&oid_2), \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");",
            " ",
            " \tgit_revwalk_free(w);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/graph/commitgraph.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/graph/commitgraph.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/graph/commitgraph.c",
            "@@ -101,26 +101,27 @@",
            " \tgit_str expected_cgraph = GIT_STR_INIT, path = GIT_STR_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&repo, cl_fixture(\"testrepo.git\")));",
            " ",
            " \tcl_git_pass(git_str_joinpath(&path, git_repository_path(repo), \"objects/info\"));",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_commit_graph_writer_new(&w, git_str_cstr(&path), GIT_OID_SHA1));",
            "-#else",
            "-\tcl_git_pass(git_commit_graph_writer_new(&w, git_str_cstr(&path)));",
            "+\topts.oid_type = GIT_OID_SHA1;",
            " #endif",
            " ",
            "+\tcl_git_pass(git_commit_graph_writer_new(&w, git_str_cstr(&path), &opts));",
            "+",
            " \t/* This is equivalent to `git commit-graph write --reachable`. */",
            " \tcl_git_pass(git_revwalk_new(&walk, repo));",
            " \tcl_git_pass(git_revwalk_push_glob(walk, \"refs/*\"));",
            " \tcl_git_pass(git_commit_graph_writer_add_revwalk(w, walk));",
            " \tgit_revwalk_free(walk);",
            " ",
            "-\tcl_git_pass(git_commit_graph_writer_dump(&cgraph, w, &opts));",
            "+\tcl_git_pass(git_commit_graph_writer_dump(&cgraph, w));",
            "+",
            " \tcl_git_pass(git_str_joinpath(&path, git_repository_path(repo), \"objects/info/commit-graph\"));",
            " \tcl_git_pass(git_futils_readbuffer(&expected_cgraph, git_str_cstr(&path)));",
            " ",
            " \tcl_assert_equal_i(cgraph.size, git_str_len(&expected_cgraph));",
            " \tcl_assert_equal_i(memcmp(cgraph.ptr, git_str_cstr(&expected_cgraph), cgraph.size), 0);",
            " ",
            " \tgit_buf_dispose(&cgraph);",
            "@@ -132,20 +133,24 @@",
            " ",
            " void test_graph_commitgraph__validate(void)",
            " {",
            " \tgit_repository *repo;",
            " \tstruct git_commit_graph *cgraph;",
            " \tgit_str objects_dir = GIT_STR_INIT;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tgit_commit_graph_open_options opts = GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT;",
            "+#endif",
            "+",
            " \tcl_git_pass(git_repository_open(&repo, cl_fixture(\"testrepo.git\")));",
            " \tcl_git_pass(git_str_joinpath(&objects_dir, git_repository_path(repo), \"objects\"));",
            " ",
            " \t/* git_commit_graph_open() calls git_commit_graph_validate() */",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_commit_graph_open(&cgraph, git_str_cstr(&objects_dir), GIT_OID_SHA1));",
            "+\tcl_git_pass(git_commit_graph_open(&cgraph, git_str_cstr(&objects_dir), &opts));",
            " #else",
            " \tcl_git_pass(git_commit_graph_open(&cgraph, git_str_cstr(&objects_dir)));",
            " #endif",
            " ",
            " \tgit_commit_graph_free(cgraph);",
            " \tgit_str_dispose(&objects_dir);",
            " \tgit_repository_free(repo);",
            "@@ -153,26 +158,30 @@",
            " ",
            " void test_graph_commitgraph__validate_corrupt(void)",
            " {",
            " \tgit_repository *repo;",
            " \tstruct git_commit_graph *cgraph;",
            " \tint fd = -1;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tgit_commit_graph_open_options opts = GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT;",
            "+#endif",
            "+",
            " \tcl_fixture_sandbox(\"testrepo.git\");",
            " \tcl_git_pass(git_repository_open(&repo, cl_git_sandbox_path(1, \"testrepo.git\", NULL)));",
            " ",
            " \t/* corrupt commit graph checksum at the end of the file */",
            " \tcl_assert((fd = p_open(cl_git_sandbox_path(0, \"testrepo.git\", \"objects\", \"info\", \"commit-graph\", NULL), O_WRONLY)) > 0);",
            " \tcl_assert(p_lseek(fd, -5, SEEK_END) > 0);",
            " \tcl_must_pass(p_write(fd, \"\\0\\0\", 2));",
            " \tcl_must_pass(p_close(fd));",
            " ",
            " \t/* git_commit_graph_open() calls git_commit_graph_validate() */",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_fail(git_commit_graph_open(&cgraph, cl_git_sandbox_path(1, \"testrepo.git\", \"objects\", NULL), GIT_OID_SHA1));",
            "+\tcl_git_fail(git_commit_graph_open(&cgraph, cl_git_sandbox_path(1, \"testrepo.git\", \"objects\", NULL), &opts));",
            " #else",
            " \tcl_git_fail(git_commit_graph_open(&cgraph, cl_git_sandbox_path(1, \"testrepo.git\", \"objects\", NULL)));",
            " #endif",
            " ",
            " \tgit_commit_graph_free(cgraph);",
            " \tgit_repository_free(repo);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/graph/reachable_from_any.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/graph/reachable_from_any.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/graph/reachable_from_any.c",
            "@@ -227,10 +227,10 @@",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            " \tgit_vector_foreach (&mc.commits, child_idx, child_commit)",
            " \t\tgit_commit_free(child_commit);",
            " \tgit_bitvec_free(&reachable);",
            "-\tgit_vector_free(&mc.commits);",
            "+\tgit_vector_dispose(&mc.commits);",
            " \tgit_odb_free(mc.db);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/index/crlf.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/index/crlf.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/index/crlf.c",
            "@@ -186,15 +186,15 @@",
            " ",
            " \t\tgit__free(basename);",
            " ",
            " \t\tif (skip)",
            " \t\t\tcontinue;",
            " \t\tp_unlink(fn);",
            " \t}",
            "-\tgit_vector_free_deep(&contents);",
            "+\tgit_vector_dispose_deep(&contents);",
            " ",
            " \t/* copy input files */",
            " \tgit_fs_path_dirload(&contents, cl_fixture(\"crlf\"), 0, 0);",
            " \tgit_vector_foreach(&contents, i, fn) {",
            " \t\tchar *basename = git_fs_path_basename(fn);",
            " \t\tgit_str dest_filename = GIT_STR_INIT;",
            " ",
            "@@ -203,15 +203,15 @@",
            " \t\t\tgit_str_joinpath(&dest_filename, name, basename);",
            " \t\t\tcl_git_pass(git_futils_cp(fn, dest_filename.ptr, 0644));",
            " \t\t}",
            " ",
            " \t\tgit__free(basename);",
            " \t\tgit_str_dispose(&dest_filename);",
            " \t}",
            "-\tgit_vector_free_deep(&contents);",
            "+\tgit_vector_dispose_deep(&contents);",
            " }",
            " ",
            " void test_index_crlf__matches_core_git(void)",
            " {",
            " \tconst char *safecrlf[] = { \"true\", \"false\", \"warn\", NULL };",
            " \tconst char *autocrlf[] = { \"true\", \"false\", \"input\", NULL };",
            " \tconst char *attrs[] = { \"\", \"-crlf\", \"-text\", \"eol=crlf\", \"eol=lf\","
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/index/tests256.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/index/tests256.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/index/tests256.c",
            "@@ -674,15 +674,15 @@",
            " \tgit_index *idx;",
            " \tgit_repository *repo;",
            " \tgit_index_entry entry = {{0}};",
            " \tgit_oid tree_id;",
            " ",
            " \tcl_git_pass(git_index__new(&idx, GIT_OID_SHA256));",
            " ",
            "-\t// TODO: this one is failing",
            "+\t/* TODO: this one is failing */",
            " \tcl_git_pass(git_oid__fromstr(&entry.id, \"a8c2e0a89a9cbab77c732b6bc39b51a783e3a318a847f46cba7614cac9814291\", GIT_OID_SHA256));",
            " \tentry.path = \"foo\";",
            " \tentry.mode = GIT_FILEMODE_BLOB;",
            " \tcl_git_pass(git_index_add(idx, &entry));",
            " ",
            " \tcl_git_pass(git_repository_init_ext(&repo, \"./invalid-id\", &repo_init_opts));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/iterator/index.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/iterator/index.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/iterator/index.c",
            "@@ -623,15 +623,15 @@",
            " ",
            " \t\tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_with_dirs(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;",
            "@@ -724,15 +724,15 @@",
            " ",
            " \t\tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_with_dirs_include_trees(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;",
            "@@ -755,15 +755,15 @@",
            " \ti_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE | GIT_ITERATOR_INCLUDE_TREES;",
            " ",
            " \tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_1(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;",
            "@@ -795,15 +795,15 @@",
            " \texpect = default_icase ? 5 : 3;",
            " ",
            " \tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \texpect_iterator_items(i, expect, NULL, expect, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_2(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;",
            "@@ -837,15 +837,15 @@",
            " \texpect = default_icase ? 8 : 5;",
            " ",
            " \tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \texpect_iterator_items(i, expect, NULL, expect, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_four(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;",
            "@@ -879,15 +879,15 @@",
            " \texpect = default_icase ? 8 : 5;",
            " ",
            " \tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \texpect_iterator_items(i, expect, NULL, expect, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_icase(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;",
            "@@ -942,15 +942,15 @@",
            " \ti_opts.end = \"k/Z\";",
            " \tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \texpect_iterator_items(i, 2, NULL, 2, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            " \tcl_git_pass(git_index_set_caps(index, caps));",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__pathlist_with_directory(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_vector filelist;",
            "@@ -969,15 +969,15 @@",
            " \tcl_git_pass(git_repository_index(&index, g_repo));",
            " \tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \texpect_iterator_items(i, 4, NULL, 4, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_index_free(index);",
            " \tgit_tree_free(tree);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " static void create_paths(git_index *index, const char *root, int depth)",
            " {",
            " \tgit_str fullpath = GIT_STR_INIT;",
            " \tgit_index_entry entry;",
            " \tsize_t root_len;",
            "@@ -1127,15 +1127,15 @@",
            " ",
            " \t\tcl_git_pass(git_iterator_for_index(&i, g_repo, index, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            " \tgit_index_free(index);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_index__advance_over(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_index *index;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/iterator/tree.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/iterator/tree.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/iterator/tree.c",
            "@@ -907,15 +907,15 @@",
            " \tcl_git_pass(git_iterator_for_tree(&i, tree, &i_opts));",
            " \tdefault_icase = git_iterator_ignore_case(i);",
            " \t/* (a B c D e ==> 5) vs (B D L/1 a c e ==> 6) */",
            " \texpect = ((default_icase) ? 5 : 6);",
            " \texpect_iterator_items(i, expect, NULL, expect, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " \tgit_tree_free(tree);",
            " }",
            " ",
            " void test_iterator_tree__pathlist_icase(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            "@@ -964,15 +964,15 @@",
            " ",
            " \ti_opts.start = \"k\";",
            " \ti_opts.end = \"k/Z\";",
            " \tcl_git_pass(git_iterator_for_tree(&i, tree, &i_opts));",
            " \texpect_iterator_items(i, 2, NULL, 2, NULL);",
            " \tgit_iterator_free(i);",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " \tgit_tree_free(tree);",
            " }",
            " ",
            " void test_iterator_tree__pathlist_with_directory(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            "@@ -1017,15 +1017,15 @@",
            " \ti_opts.pathlist.count = filelist.length;",
            " ",
            " \tcl_git_pass(git_iterator_for_tree(&i, tree, &i_opts));",
            " \texpect_iterator_items(i, expected_len2, expected2, expected_len2, expected2);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_tree_free(tree);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_tree__pathlist_with_directory_include_tree_nodes(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_vector filelist;",
            "@@ -1046,15 +1046,15 @@",
            " \ti_opts.flags |= GIT_ITERATOR_DONT_IGNORE_CASE | GIT_ITERATOR_INCLUDE_TREES;",
            " ",
            " \tcl_git_pass(git_iterator_for_tree(&i, tree, &i_opts));",
            " \texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_tree_free(tree);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_tree__pathlist_no_match(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_vector filelist;",
            "@@ -1071,10 +1071,10 @@",
            " \ti_opts.pathlist.count = filelist.length;",
            " ",
            " \tcl_git_pass(git_iterator_for_tree(&i, tree, &i_opts));",
            " \tcl_assert_equal_i(GIT_ITEROVER, git_iterator_current(&entry, i));",
            " \tgit_iterator_free(i);",
            " ",
            " \tgit_tree_free(tree);",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/iterator/workdir.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/iterator/workdir.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/iterator/workdir.c",
            "@@ -913,15 +913,15 @@",
            " \t\ti_opts.flags = GIT_ITERATOR_IGNORE_CASE;",
            " ",
            " \t\tcl_git_pass(git_iterator_for_workdir(&i, g_repo, NULL, NULL, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_workdir__pathlist_with_dirs(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_vector filelist;",
            "@@ -1010,15 +1010,15 @@",
            " \t\ti_opts.flags = GIT_ITERATOR_IGNORE_CASE;",
            " ",
            " \t\tcl_git_pass(git_iterator_for_workdir(&i, g_repo, NULL, NULL, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " static void create_paths(const char *root, int depth)",
            " {",
            " \tgit_str fullpath = GIT_STR_INIT;",
            " \tsize_t root_len;",
            " \tint i;",
            "@@ -1171,15 +1171,15 @@",
            " ",
            " \t\tcl_git_pass(git_iterator_for_workdir(&i, g_repo, NULL, NULL, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tcl_assert_equal_i(14, i->stat_calls);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_workdir__bounded_submodules(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_vector filelist;",
            "@@ -1254,15 +1254,15 @@",
            " \t\ti_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;",
            " ",
            " \t\tcl_git_pass(git_iterator_for_workdir(&i, g_repo, index, head, &i_opts));",
            " \t\texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \t\tgit_iterator_free(i);",
            " \t}",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " \tgit_index_free(index);",
            " \tgit_tree_free(head);",
            " }",
            " ",
            " void test_iterator_workdir__advance_over(void)",
            " {",
            " \tgit_iterator *i;",
            "@@ -1376,15 +1376,15 @@",
            " \texpect_advance_over(i, \"dirA/\", GIT_ITERATOR_STATUS_NORMAL);",
            " \texpect_advance_over(i, \"dirB/\", GIT_ITERATOR_STATUS_NORMAL);",
            " \texpect_advance_over(i, \"dirC/\", GIT_ITERATOR_STATUS_FILTERED);",
            " \texpect_advance_over(i, \"dirD/\", GIT_ITERATOR_STATUS_NORMAL);",
            " ",
            " \tcl_git_fail_with(GIT_ITEROVER, git_iterator_advance(NULL, i));",
            " \tgit_iterator_free(i);",
            "-\tgit_vector_free(&pathlist);",
            "+\tgit_vector_dispose(&pathlist);",
            " }",
            " ",
            " void test_iterator_workdir__advance_into(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " ",
            "@@ -1443,15 +1443,15 @@",
            " \ti_opts.pathlist.count = filelist.length;",
            " \ti_opts.flags |= GIT_ITERATOR_DONT_IGNORE_CASE;",
            " ",
            " \tcl_git_pass(git_iterator_for_workdir(&i, g_repo, NULL, NULL, &i_opts));",
            " \texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \tgit_iterator_free(i);",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_workdir__pathlist_with_directory_include_trees(void)",
            " {",
            " \tgit_iterator *i;",
            " \tgit_iterator_options i_opts = GIT_ITERATOR_OPTIONS_INIT;",
            " \tgit_vector filelist;",
            "@@ -1469,15 +1469,15 @@",
            " \ti_opts.pathlist.count = filelist.length;",
            " \ti_opts.flags |= GIT_ITERATOR_DONT_IGNORE_CASE | GIT_ITERATOR_INCLUDE_TREES;",
            " ",
            " \tcl_git_pass(git_iterator_for_workdir(&i, g_repo, NULL, NULL, &i_opts));",
            " \texpect_iterator_items(i, expected_len, expected, expected_len, expected);",
            " \tgit_iterator_free(i);",
            " ",
            "-\tgit_vector_free(&filelist);",
            "+\tgit_vector_dispose(&filelist);",
            " }",
            " ",
            " void test_iterator_workdir__hash_when_requested(void)",
            " {",
            " \tgit_iterator *iter;",
            " \tconst git_index_entry *entry;",
            " \tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/mailmap/blame.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/mailmap/blame.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/mailmap/blame.c",
            "@@ -29,15 +29,15 @@",
            " ",
            " \topts.flags |= GIT_BLAME_USE_MAILMAP;",
            " ",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"file.txt\", &opts));",
            " \tcl_assert(g_blame);",
            " ",
            " \tfor (idx = 0; idx < ARRAY_SIZE(resolved); ++idx) {",
            "-\t\thunk = git_blame_get_hunk_byline(g_blame, idx + 1);",
            "+\t\thunk = git_blame_hunk_byline(g_blame, idx + 1);",
            " ",
            " \t\tcl_assert(hunk->final_signature != NULL);",
            " \t\tcl_assert(hunk->orig_signature != NULL);",
            " \t\tcl_assert_equal_s(hunk->final_signature->name, resolved[idx].real_name);",
            " \t\tcl_assert_equal_s(hunk->final_signature->email, resolved[idx].real_email);",
            " \t}",
            " }",
            "@@ -50,15 +50,15 @@",
            " ",
            " \tg_repo = cl_git_sandbox_init(\"mailmap\");",
            " ",
            " \tcl_git_pass(git_blame_file(&g_blame, g_repo, \"file.txt\", &opts));",
            " \tcl_assert(g_blame);",
            " ",
            " \tfor (idx = 0; idx < ARRAY_SIZE(resolved); ++idx) {",
            "-\t\thunk = git_blame_get_hunk_byline(g_blame, idx + 1);",
            "+\t\thunk = git_blame_hunk_byline(g_blame, idx + 1);",
            " ",
            " \t\tcl_assert(hunk->final_signature != NULL);",
            " \t\tcl_assert(hunk->orig_signature != NULL);",
            " \t\tcl_assert_equal_s(hunk->final_signature->name, resolved[idx].replace_name);",
            " \t\tcl_assert_equal_s(hunk->final_signature->email, resolved[idx].replace_email);",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/merge/workdir/dirty.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/merge/workdir/dirty.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/merge/workdir/dirty.c",
            "@@ -93,15 +93,14 @@",
            " \tgit_merge_options merge_opts = GIT_MERGE_OPTIONS_INIT;",
            " \tgit_checkout_options checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " \tint error;",
            " ",
            " \tcl_git_pass(git_oid__fromstr(&their_oids[0], MERGE_BRANCH_OID, GIT_OID_SHA1));",
            " \tcl_git_pass(git_annotated_commit_lookup(&their_head, repo, &their_oids[0]));",
            " ",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            " \terror = git_merge(repo, (const git_annotated_commit **)&their_head, 1, &merge_opts, &checkout_opts);",
            " ",
            " \tgit_annotated_commit_free(their_head);",
            " ",
            " \treturn error;",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/merge/workdir/renames.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/merge/workdir/renames.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/merge/workdir/renames.c",
            "@@ -96,15 +96,15 @@",
            " \t\t{ 0100644, \"d8fa77b6833082c1ea36b7828a582d4c43882450\", 0, \"6-both-renamed-1-to-2-ours.txt\" },",
            " \t\t{ 0100644, \"b69fe837e4cecfd4c9a40cdca7c138468687df07\", 0, \"7-both-renamed-side-2.txt\" },",
            " \t\t{ 0100644, \"b42712cfe99a1a500b2a51fe984e0b8a7702ba11\", 0, \"7-both-renamed.txt\" },",
            " \t};",
            " ",
            " \tmerge_opts.flags |= GIT_MERGE_FIND_RENAMES;",
            " \tmerge_opts.rename_threshold = 50;",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_USE_OURS;",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_USE_OURS;",
            " ",
            " \tcl_git_pass(merge_branches(repo, GIT_REFS_HEADS_DIR BRANCH_RENAME_OURS, GIT_REFS_HEADS_DIR BRANCH_RENAME_THEIRS, &merge_opts, &checkout_opts));",
            " \tcl_git_pass(git_repository_index(&index, repo));",
            " \tcl_git_pass(git_index_write(index));",
            " \tcl_assert(merge_test_workdir(repo, merge_index_entries, 20));",
            " ",
            " \tgit_index_free(index);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/merge/workdir/simple.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/merge/workdir/simple.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/merge/workdir/simple.c",
            "@@ -99,15 +99,15 @@",
            " \tgit_merge_options merge_opts = GIT_MERGE_OPTIONS_INIT;",
            " \tgit_checkout_options checkout_opts = GIT_CHECKOUT_OPTIONS_INIT;",
            " ",
            " \tcl_git_pass(git_oid__fromstr(&their_oids[0], THEIRS_SIMPLE_OID, GIT_OID_SHA1));",
            " \tcl_git_pass(git_annotated_commit_lookup(&their_heads[0], repo, &their_oids[0]));",
            " ",
            " \tmerge_opts.file_favor = merge_file_favor;",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_ALLOW_CONFLICTS |",
            "+\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_ALLOW_CONFLICTS |",
            " \t\taddl_checkout_strategy;",
            " ",
            " \tcl_git_pass(git_merge(repo, (const git_annotated_commit **)their_heads, 1, &merge_opts, &checkout_opts));",
            " ",
            " \tgit_annotated_commit_free(their_heads[0]);",
            " }",
            " ",
            "@@ -573,15 +573,15 @@",
            " ",
            " \tstruct merge_reuc_entry merge_reuc_entries[] = {",
            " \t\tAUTOMERGEABLE_REUC_ENTRY,",
            " \t\tREMOVED_IN_BRANCH_REUC_ENTRY,",
            " \t\tREMOVED_IN_MASTER_REUC_ENTRY",
            " \t};",
            " ",
            "-\tmerge_simple_branch(0, GIT_CHECKOUT_SAFE | GIT_CHECKOUT_USE_OURS);",
            "+\tmerge_simple_branch(0, GIT_CHECKOUT_USE_OURS);",
            " ",
            " \tcl_assert(merge_test_index(repo_index, merge_index_entries, 8));",
            " \tcl_assert(merge_test_reuc(repo_index, merge_reuc_entries, 3));",
            " ",
            " \tcl_assert(git_fs_path_exists(TEST_REPO_PATH \"/conflicting.txt\"));",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/network/fetchlocal.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/network/fetchlocal.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/network/fetchlocal.c",
            "@@ -104,22 +104,23 @@",
            " \tcl_assert_equal_i(18, (int)refnames.count);",
            " \tgit_strarray_dispose(&refnames);",
            " \tgit_remote_free(origin);",
            " ",
            " \tgit_repository_free(repo);",
            " }",
            " ",
            "-static int update_tips_fail_on_call(const char *ref, const git_oid *old, const git_oid *new, void *data)",
            "+static int update_refs_fail_on_call(const char *ref, const git_oid *old, const git_oid *new, git_refspec *refspec, void *data)",
            " {",
            " \tGIT_UNUSED(ref);",
            " \tGIT_UNUSED(old);",
            " \tGIT_UNUSED(new);",
            "+\tGIT_UNUSED(refspec);",
            " \tGIT_UNUSED(data);",
            " ",
            "-\tcl_fail(\"update tips called\");",
            "+\tcl_fail(\"update refs called\");",
            " \treturn 0;",
            " }",
            " ",
            " static void assert_ref_exists(git_repository *repo, const char *name)",
            " {",
            " \tgit_reference *ref;",
            " ",
            "@@ -171,30 +172,30 @@",
            " ",
            " \tcl_git_pass(git_config_delete_multivar(config, \"remote.origin.fetch\", \"refs\"));",
            " \tcl_git_pass(git_config_set_multivar(config, \"remote.origin.fetch\", \"^$\", \"refs/pull/*/head:refs/remotes/origin/pr/*\"));",
            " \tcl_git_pass(git_config_set_multivar(config, \"remote.origin.fetch\", \"^$\", \"refs/heads/*:refs/remotes/origin/*\"));",
            " ",
            " \tgit_remote_free(origin);",
            " \tcl_git_pass(git_remote_lookup(&origin, repo, GIT_REMOTE_ORIGIN));",
            "-\toptions.callbacks.update_tips = update_tips_fail_on_call;",
            "+\toptions.callbacks.update_refs = update_refs_fail_on_call;",
            " \tcl_git_pass(git_remote_fetch(origin, NULL, &options, NULL));",
            " ",
            " \tassert_ref_exists(repo, \"refs/remotes/origin/master\");",
            " \tassert_ref_exists(repo, \"refs/remotes/origin/pr/42\");",
            " \tcl_git_pass(git_reference_list(&refnames, repo));",
            " \tcl_assert_equal_i(21, (int)refnames.count);",
            " \tgit_strarray_dispose(&refnames);",
            " ",
            " \tcl_git_pass(git_config_delete_multivar(config, \"remote.origin.fetch\", \"refs\"));",
            " \tcl_git_pass(git_config_set_multivar(config, \"remote.origin.fetch\", \"^$\", \"refs/heads/*:refs/remotes/origin/*\"));",
            " \tcl_git_pass(git_config_set_multivar(config, \"remote.origin.fetch\", \"^$\", \"refs/pull/*/head:refs/remotes/origin/pr/*\"));",
            " ",
            " \tgit_remote_free(origin);",
            " \tcl_git_pass(git_remote_lookup(&origin, repo, GIT_REMOTE_ORIGIN));",
            "-\toptions.callbacks.update_tips = update_tips_fail_on_call;",
            "+\toptions.callbacks.update_refs = update_refs_fail_on_call;",
            " \tcl_git_pass(git_remote_fetch(origin, NULL, &options, NULL));",
            " ",
            " \tgit_config_free(config);",
            " \tgit_strarray_dispose(&refnames);",
            " \tgit_remote_free(origin);",
            " \tgit_repository_free(repo);",
            " }",
            "@@ -506,47 +507,128 @@",
            " \tcl_assert_equal_i(1, git_remote_prune_refs(origin));",
            " ",
            " \tgit_config_free(config);",
            " \tgit_remote_free(origin);",
            " \tgit_repository_free(repo);",
            " }",
            " ",
            "-static int update_tips_error(const char *ref, const git_oid *old, const git_oid *new, void *data)",
            "+static int update_refs_error(const char *ref, const git_oid *old, const git_oid *new, git_refspec *refspec, void *data)",
            " {",
            " \tint *callcount = (int *) data;",
            " ",
            " \tGIT_UNUSED(ref);",
            " \tGIT_UNUSED(old);",
            " \tGIT_UNUSED(new);",
            "+\tGIT_UNUSED(refspec);",
            " ",
            " \t(*callcount)++;",
            " ",
            " \treturn -1;",
            " }",
            " ",
            "-void test_network_fetchlocal__update_tips_error_is_propagated(void)",
            "+void test_network_fetchlocal__update_refs_error_is_propagated(void)",
            " {",
            " \tgit_repository *repo;",
            " \tgit_reference_iterator *iterator;",
            " \tgit_reference *ref;",
            " \tgit_remote *remote;",
            " \tgit_fetch_options options = GIT_FETCH_OPTIONS_INIT;",
            " \tint callcount = 0;",
            " ",
            " \tcl_git_pass(git_repository_init(&repo, \"foo.git\", true));",
            " \tcl_set_cleanup(cleanup_local_repo, \"foo.git\");",
            " ",
            " \tcl_git_pass(git_remote_create_with_fetchspec(&remote, repo, \"origin\", cl_git_fixture_url(\"testrepo.git\"), \"+refs/heads/*:refs/remotes/update-tips/*\"));",
            " ",
            "-\toptions.callbacks.update_tips = update_tips_error;",
            "+\toptions.callbacks.update_refs = update_refs_error;",
            " \toptions.callbacks.payload = &callcount;",
            " ",
            " \tcl_git_fail(git_remote_fetch(remote, NULL, &options, NULL));",
            " \tcl_assert_equal_i(1, callcount);",
            " ",
            " \tcl_git_pass(git_reference_iterator_glob_new(&iterator, repo, \"refs/remotes/update-tips/**/\"));",
            " \tcl_assert_equal_i(GIT_ITEROVER, git_reference_next(&ref, iterator));",
            " ",
            " \tgit_reference_iterator_free(iterator);",
            " \tgit_remote_free(remote);",
            " \tgit_repository_free(repo);",
            " }",
            "+",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+static int update_tips(const char *ref, const git_oid *old, const git_oid *new, void *data)",
            "+{",
            "+\tint *called = (int *) data;",
            "+",
            "+\tGIT_UNUSED(ref);",
            "+\tGIT_UNUSED(old);",
            "+\tGIT_UNUSED(new);",
            "+",
            "+\t(*called) += 1;",
            "+",
            "+\treturn 0;",
            "+}",
            "+",
            "+static int update_refs(const char *ref, const git_oid *old, const git_oid *new, git_refspec *spec, void *data)",
            "+{",
            "+\tint *called = (int *) data;",
            "+",
            "+\tGIT_UNUSED(ref);",
            "+\tGIT_UNUSED(old);",
            "+\tGIT_UNUSED(new);",
            "+\tGIT_UNUSED(spec);",
            "+",
            "+\t(*called) += 0x10000;",
            "+",
            "+\treturn 0;",
            "+}",
            "+#endif",
            "+",
            "+void test_network_fetchlocal__update_tips_backcompat(void)",
            "+{",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+\tgit_repository *repo;",
            "+\tgit_remote *remote;",
            "+\tgit_fetch_options options = GIT_FETCH_OPTIONS_INIT;",
            "+\tint callcount = 0;",
            "+",
            "+\tcl_git_pass(git_repository_init(&repo, \"foo.git\", true));",
            "+\tcl_set_cleanup(cleanup_local_repo, \"foo.git\");",
            "+",
            "+\tcl_git_pass(git_remote_create_with_fetchspec(&remote, repo, \"origin\", cl_git_fixture_url(\"testrepo.git\"), \"+refs/heads/*:refs/remotes/update-tips/*\"));",
            "+",
            "+\toptions.callbacks.update_tips = update_tips;",
            "+\toptions.callbacks.payload = &callcount;",
            "+",
            "+\tcl_git_pass(git_remote_fetch(remote, NULL, &options, NULL));",
            "+\tcl_assert_equal_i(0, (callcount & 0xffff0000));",
            "+\tcl_assert((callcount & 0x0000ffff) > 0);",
            "+",
            "+\tgit_remote_free(remote);",
            "+\tgit_repository_free(repo);",
            "+#endif",
            "+}",
            "+",
            "+void test_network_fetchlocal__update_refs_is_preferred(void)",
            "+{",
            "+#ifndef GIT_DEPRECATE_HARD",
            "+\tgit_repository *repo;",
            "+\tgit_remote *remote;",
            "+\tgit_fetch_options options = GIT_FETCH_OPTIONS_INIT;",
            "+\tint callcount = 0;",
            "+",
            "+\tcl_git_pass(git_repository_init(&repo, \"foo.git\", true));",
            "+\tcl_set_cleanup(cleanup_local_repo, \"foo.git\");",
            "+",
            "+\tcl_git_pass(git_remote_create_with_fetchspec(&remote, repo, \"origin\", cl_git_fixture_url(\"testrepo.git\"), \"+refs/heads/*:refs/remotes/update-tips/*\"));",
            "+",
            "+\toptions.callbacks.update_tips = update_tips;",
            "+\toptions.callbacks.update_refs = update_refs;",
            "+\toptions.callbacks.payload = &callcount;",
            "+",
            "+\tcl_git_pass(git_remote_fetch(remote, NULL, &options, NULL));",
            "+\tcl_assert_equal_i(0, (callcount & 0x0000ffff));",
            "+\tcl_assert((callcount & 0xffff0000) > 0);",
            "+",
            "+\tgit_remote_free(remote);",
            "+\tgit_repository_free(repo);",
            "+#endif",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/network/remote/local.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/network/remote/local.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/network/remote/local.c",
            "@@ -57,15 +57,15 @@",
            " \tconst git_remote_head **refs;",
            " \tsize_t refs_len;",
            " ",
            " \tconnect_to_local_repository(cl_fixture(\"testrepo.git\"));",
            " ",
            " \tcl_git_pass(git_remote_ls(&refs, &refs_len, remote));",
            " ",
            "-\tcl_assert_equal_i(refs_len, 30);",
            "+\tcl_assert_equal_i(refs_len, 31);",
            " }",
            " ",
            " void test_network_remote_local__retrieve_advertised_before_connect(void)",
            " {",
            " \tconst git_remote_head **refs;",
            " \tsize_t refs_len = 0;",
            " ",
            "@@ -81,30 +81,30 @@",
            " \tsize_t refs_len;",
            " ",
            " \tconnect_to_local_repository(cl_fixture(\"testrepo.git\"));",
            " \tgit_remote_disconnect(remote);",
            " ",
            " \tcl_git_pass(git_remote_ls(&refs, &refs_len, remote));",
            " ",
            "-\tcl_assert_equal_i(refs_len, 30);",
            "+\tcl_assert_equal_i(refs_len, 31);",
            " }",
            " ",
            " void test_network_remote_local__retrieve_advertised_references_from_spaced_repository(void)",
            " {",
            " \tconst git_remote_head **refs;",
            " \tsize_t refs_len;",
            " ",
            " \tcl_fixture_sandbox(\"testrepo.git\");",
            " \tcl_git_pass(p_rename(\"testrepo.git\", \"spaced testrepo.git\"));",
            " ",
            " \tconnect_to_local_repository(\"spaced testrepo.git\");",
            " ",
            " \tcl_git_pass(git_remote_ls(&refs, &refs_len, remote));",
            " ",
            "-\tcl_assert_equal_i(refs_len, 30);",
            "+\tcl_assert_equal_i(refs_len, 31);",
            " ",
            " \tgit_remote_free(remote);\t/* Disconnect from the \"spaced repo\" before the cleanup */",
            " \tremote = NULL;",
            " ",
            " \tcl_fixture_cleanup(\"spaced testrepo.git\");",
            " }",
            " ",
            "@@ -467,18 +467,22 @@",
            " }",
            " ",
            " void test_network_remote_local__anonymous_remote_inmemory_repo(void)",
            " {",
            " \tgit_repository *inmemory;",
            " \tgit_remote *remote;",
            " ",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tgit_repository_new_options repo_opts = GIT_REPOSITORY_NEW_OPTIONS_INIT;",
            "+#endif",
            "+",
            " \tgit_str_sets(&file_path_buf, cl_git_path_url(cl_fixture(\"testrepo.git\")));",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_repository_new(&inmemory, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_repository_new(&inmemory, &repo_opts));",
            " #else",
            " \tcl_git_pass(git_repository_new(&inmemory));",
            " #endif",
            " \tcl_git_pass(git_remote_create_anonymous(&remote, inmemory, git_str_cstr(&file_path_buf)));",
            " \tcl_git_pass(git_remote_connect(remote, GIT_DIRECTION_FETCH, NULL, NULL, NULL));",
            " \tcl_assert(git_remote_connected(remote));",
            " \tgit_remote_disconnect(remote);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/network/remote/rename.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/network/remote/rename.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/network/remote/rename.c",
            "@@ -234,12 +234,12 @@",
            " ",
            " \tref = git_vector_get(&refs, 1);",
            " \tcl_assert_equal_s(\"refs/remotes/renamed/master\", git_reference_name(ref));",
            " \tgit_oid_fmt(idstr, git_reference_target(ref));",
            " \tcl_assert_equal_s(\"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\", idstr);",
            " \tgit_reference_free(ref);",
            " ",
            "-\tgit_vector_free(&refs);",
            "+\tgit_vector_dispose(&refs);",
            " ",
            " \tcl_git_fail_with(GIT_ITEROVER, git_branch_next(&ref, &btype, iter));",
            " \tgit_branch_iterator_free(iter);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/object/shortid.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/object/shortid.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/object/shortid.c",
            "@@ -1,20 +1,19 @@",
            " #include \"clar_libgit2.h\"",
            " ",
            " git_repository *_repo;",
            " ",
            " void test_object_shortid__initialize(void)",
            " {",
            "-\tcl_git_pass(git_repository_open(&_repo, cl_fixture(\"duplicate.git\")));",
            "+\t_repo = cl_git_sandbox_init(\"duplicate.git\");",
            " }",
            " ",
            " void test_object_shortid__cleanup(void)",
            " {",
            "-\tgit_repository_free(_repo);",
            "-\t_repo = NULL;",
            "+\tcl_git_sandbox_cleanup();",
            " }",
            " ",
            " void test_object_shortid__select(void)",
            " {",
            " \tgit_oid full;",
            " \tgit_object *obj;",
            " \tgit_buf shorty = {0};",
            "@@ -45,7 +44,57 @@",
            " \tcl_git_pass(git_object_short_id(&shorty, obj));",
            " \tcl_assert_equal_i(9, shorty.size);",
            " \tcl_assert_equal_s(\"dea509d0b\", shorty.ptr);",
            " \tgit_object_free(obj);",
            " ",
            " \tgit_buf_dispose(&shorty);",
            " }",
            "+",
            "+void test_object_shortid__core_abbrev(void)",
            "+{",
            "+\tgit_oid full;",
            "+\tgit_object *obj;",
            "+\tgit_buf shorty = {0};",
            "+\tgit_config *cfg;",
            "+",
            "+\tcl_git_pass(git_repository_config(&cfg, _repo));",
            "+\tgit_oid__fromstr(&full, \"ce013625030ba8dba906f756967f9e9ca394464a\", GIT_OID_SHA1);",
            "+\tcl_git_pass(git_object_lookup(&obj, _repo, &full, GIT_OBJECT_ANY));",
            "+",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"auto\"));",
            "+\tcl_git_pass(git_object_short_id(&shorty, obj));",
            "+\tcl_assert_equal_i(7, shorty.size);",
            "+\tcl_assert_equal_s(\"ce01362\", shorty.ptr);",
            "+",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"off\"));",
            "+\tcl_git_pass(git_object_short_id(&shorty, obj));",
            "+\tcl_assert_equal_i(40, shorty.size);",
            "+\tcl_assert_equal_s(\"ce013625030ba8dba906f756967f9e9ca394464a\", shorty.ptr);",
            "+",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"false\"));",
            "+\tcl_git_pass(git_object_short_id(&shorty, obj));",
            "+\tcl_assert_equal_i(40, shorty.size);",
            "+\tcl_assert_equal_s(\"ce013625030ba8dba906f756967f9e9ca394464a\", shorty.ptr);",
            "+",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"99\"));",
            "+\tcl_git_pass(git_object_short_id(&shorty, obj));",
            "+\tcl_assert_equal_i(40, shorty.size);",
            "+\tcl_assert_equal_s(\"ce013625030ba8dba906f756967f9e9ca394464a\", shorty.ptr);",
            "+",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"4\"));",
            "+\tcl_git_pass(git_object_short_id(&shorty, obj));",
            "+\tcl_assert_equal_i(4, shorty.size);",
            "+\tcl_assert_equal_s(\"ce01\", shorty.ptr);",
            "+",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"0\"));",
            "+\tcl_git_fail(git_object_short_id(&shorty, obj));",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"3\"));",
            "+\tcl_git_fail(git_object_short_id(&shorty, obj));",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"invalid\"));",
            "+\tcl_git_fail(git_object_short_id(&shorty, obj));",
            "+\tcl_git_pass(git_config_set_string(cfg, \"core.abbrev\", \"true\"));",
            "+\tcl_git_fail(git_object_short_id(&shorty, obj));",
            "+",
            "+\tgit_object_free(obj);",
            "+\tgit_buf_dispose(&shorty);",
            "+\tgit_config_free(cfg);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/odb/alternates.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/odb/alternates.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/odb/alternates.c",
            "@@ -74,7 +74,43 @@",
            " ",
            " \t/* Now load the last one and see if we can find an object from testrepo.git */",
            " \tcl_git_pass(git_repository_open(&repo, paths[ARRAY_SIZE(paths)-1]));",
            " \tgit_oid__fromstr(&oid, \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", GIT_OID_SHA1);",
            " \tcl_git_fail(git_commit_lookup(&commit, repo, &oid));",
            " \tgit_repository_free(repo);",
            " }",
            "+",
            "+void test_odb_alternates__relative(void)",
            "+{",
            "+\tgit_commit *commit;",
            "+\tgit_oid oid;",
            "+",
            "+\t/* Set the alternate A -> testrepo.git */",
            "+\tinit_linked_repo(paths[0], cl_fixture(\"testrepo.git\"));",
            "+",
            "+\t/* Set the alternate B -> A */",
            "+\tinit_linked_repo(paths[1], paths[0]);",
            "+\t/* Set the alternate C -> B */",
            "+\tinit_linked_repo(paths[2], paths[1]);",
            "+",
            "+\t/* Use a relative alternates path for B -> A */",
            "+\tcl_git_pass(git_fs_path_prettify(&filepath, paths[1], NULL));",
            "+\tcl_git_pass(git_str_joinpath(&filepath, filepath.ptr, \"objects/info/alternates\"));",
            "+",
            "+\tcl_git_pass(git_filebuf_open(&file, git_str_cstr(&filepath), 0, 0666));",
            "+\tgit_filebuf_printf(&file, \"../../%s/objects\\n\", paths[0]);",
            "+\tcl_git_pass(git_filebuf_commit(&file));",
            "+",
            "+\t/* Now load B and see if we can find an object from testrepo.git */",
            "+\tcl_git_pass(git_repository_open(&repo, paths[1]));",
            "+\tgit_oid__fromstr(&oid, \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", GIT_OID_SHA1);",
            "+\tcl_git_pass(git_commit_lookup(&commit, repo, &oid));",
            "+\tgit_commit_free(commit);",
            "+\tgit_repository_free(repo);",
            "+",
            "+\t/* Now load C and see if we can find an object from testrepo.git */",
            "+\tcl_git_pass(git_repository_open(&repo, paths[2]));",
            "+\tgit_oid__fromstr(&oid, \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", GIT_OID_SHA1);",
            "+\tcl_git_pass(git_commit_lookup(&commit, repo, &oid));",
            "+\tgit_commit_free(commit);",
            "+\tgit_repository_free(repo);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/odb/backend/loose.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/odb/backend/loose.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/odb/backend/loose.c",
            "@@ -17,15 +17,15 @@",
            " \tcl_git_pass(git_odb_backend_loose(&backend, \"testrepo.git/objects\", NULL));",
            " #else",
            " \tcl_git_pass(git_odb_backend_loose(&backend, \"testrepo.git/objects\", 0, 0, 0, 0));",
            " #endif",
            " ",
            " \tcl_git_pass(git_odb__new(&_odb, NULL));",
            " \tcl_git_pass(git_odb_add_backend(_odb, backend, 10));",
            "-\tcl_git_pass(git_repository__wrap_odb(&_repo, _odb, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_repository_wrap_odb(&_repo, _odb));",
            " }",
            " ",
            " void test_odb_backend_loose__cleanup(void)",
            " {",
            " \tgit_odb_free(_odb);",
            " \tgit_repository_free(_repo);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/odb/backend/mempack.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/odb/backend/mempack.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/odb/backend/mempack.c",
            "@@ -4,23 +4,22 @@",
            " #include \"backend_helpers.h\"",
            " #include \"git2/sys/mempack.h\"",
            " ",
            " static git_odb *_odb;",
            " static git_oid _oid;",
            " static git_odb_object *_obj;",
            " static git_repository *_repo;",
            "+static git_odb_backend *_backend;",
            " ",
            " void test_odb_backend_mempack__initialize(void)",
            " {",
            "-\tgit_odb_backend *backend;",
            "-",
            "-\tcl_git_pass(git_mempack_new(&backend));",
            "+\tcl_git_pass(git_mempack_new(&_backend));",
            " \tcl_git_pass(git_odb__new(&_odb, NULL));",
            "-\tcl_git_pass(git_odb_add_backend(_odb, backend, 10));",
            "-\tcl_git_pass(git_repository__wrap_odb(&_repo, _odb, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_odb_add_backend(_odb, _backend, 10));",
            "+\tcl_git_pass(git_repository_wrap_odb(&_repo, _odb));",
            " }",
            " ",
            " void test_odb_backend_mempack__cleanup(void)",
            " {",
            " \tgit_odb_object_free(_obj);",
            " \tgit_odb_free(_odb);",
            " \tgit_repository_free(_repo);",
            "@@ -55,7 +54,29 @@",
            " void test_odb_backend_mempack__blob_create_from_buffer_succeeds(void)",
            " {",
            " \tconst char *data = \"data\";",
            " ",
            " \tcl_git_pass(git_blob_create_from_buffer(&_oid, _repo, data, strlen(data) + 1));",
            " \tcl_assert(git_odb_exists(_odb, &_oid) == 1);",
            " }",
            "+",
            "+void test_odb_backend_mempack__empty_object_count_succeeds(void)",
            "+{",
            "+\tsize_t count;",
            "+\tcl_git_pass(git_mempack_object_count(&count, _backend));",
            "+\tcl_assert_equal_sz(0, count);",
            "+}",
            "+",
            "+void test_odb_backend_mempack__object_count_succeeds(void)",
            "+{",
            "+\tconst char *data = \"data\";",
            "+\tsize_t count;",
            "+\tcl_git_pass(git_odb_write(&_oid, _odb, data, strlen(data) + 1, GIT_OBJECT_BLOB));",
            "+\tcl_git_pass(git_mempack_object_count(&count, _backend));",
            "+\tcl_assert_equal_sz(1, count);",
            "+}",
            "+",
            "+void test_odb_backend_mempack__object_count_fails(void)",
            "+{",
            "+\tsize_t count;",
            "+\tcl_git_fail_with(-1, git_mempack_object_count(&count, 0));",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/odb/backend/nobackend.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/odb/backend/nobackend.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/odb/backend/nobackend.c",
            "@@ -8,15 +8,19 @@",
            " void test_odb_backend_nobackend__initialize(void)",
            " {",
            " \tgit_config *config;",
            " \tgit_odb *odb;",
            " \tgit_refdb *refdb;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_repository_new(&_repo, GIT_OID_SHA1));",
            "+\tgit_repository_new_options repo_opts = GIT_REPOSITORY_NEW_OPTIONS_INIT;",
            "+",
            "+\trepo_opts.oid_type = GIT_OID_SHA1;",
            "+",
            "+\tcl_git_pass(git_repository_new(&_repo, &repo_opts));",
            " #else",
            " \tcl_git_pass(git_repository_new(&_repo));",
            " #endif",
            " \tcl_git_pass(git_config_new(&config));",
            " \tcl_git_pass(git_odb__new(&odb, NULL));",
            " \tcl_git_pass(git_refdb_new(&refdb, _repo));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/badssl.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/badssl.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/badssl.c",
            "@@ -69,7 +69,15 @@",
            " ",
            " \tif (!g_has_ssl)",
            " \t\tcl_skip();",
            " ",
            " \tcl_git_fail(git_clone(&g_repo, \"https://rc4.badssl.com/fake.git\", \"./fake\", NULL));",
            " \tcl_git_fail(git_clone(&g_repo, \"https://rc4.badssl.com/fake.git\", \"./fake\", &opts));",
            " }",
            "+",
            "+void test_online_badssl__sslv3(void)",
            "+{",
            "+\tif (!g_has_ssl)",
            "+\t\tcl_skip();",
            "+",
            "+\tcl_git_fail(git_clone(&g_repo, \"https://mailserv.baehal.com/fake.git\", \"./fake\", NULL));",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/clone.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/clone.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/clone.c",
            "@@ -69,15 +69,14 @@",
            " \tgit_fetch_options dummy_fetch = GIT_FETCH_OPTIONS_INIT;",
            " ",
            " \tg_repo = NULL;",
            " ",
            " \tmemset(&g_options, 0, sizeof(git_clone_options));",
            " \tg_options.version = GIT_CLONE_OPTIONS_VERSION;",
            " \tg_options.checkout_opts = dummy_opts;",
            "-\tg_options.checkout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            " \tg_options.fetch_opts = dummy_fetch;",
            " \tg_options.fetch_opts.callbacks.certificate_check = ssl_cert;",
            " ",
            " \t_remote_url = cl_getenv(\"GITTEST_REMOTE_URL\");",
            " \t_remote_user = cl_getenv(\"GITTEST_REMOTE_USER\");",
            " \t_remote_pass = cl_getenv(\"GITTEST_REMOTE_PASS\");",
            " \t_remote_branch = cl_getenv(\"GITTEST_REMOTE_BRANCH\");",
            "@@ -245,15 +244,14 @@",
            " void test_online_clone__can_checkout_a_cloned_repo(void)",
            " {",
            " \tgit_str path = GIT_STR_INIT;",
            " \tgit_reference *head, *remote_head;",
            " \tbool checkout_progress_cb_was_called = false,",
            " \t\t  fetch_progress_cb_was_called = false;",
            " ",
            "-\tg_options.checkout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            " \tg_options.checkout_opts.progress_cb = &checkout_progress;",
            " \tg_options.checkout_opts.progress_payload = &checkout_progress_cb_was_called;",
            " \tg_options.fetch_opts.callbacks.transfer_progress = &fetch_progress;",
            " \tg_options.fetch_opts.callbacks.payload = &fetch_progress_cb_was_called;",
            " ",
            " \tcl_git_pass(git_clone(&g_repo, LIVE_REPO_URL, \"./foo\", &g_options));",
            " ",
            "@@ -315,27 +313,27 @@",
            " \tgit_reference_free(head);",
            " \tgit_repository_free(g_repo);",
            " \tg_repo = NULL;",
            " ",
            " \tcl_fixture_cleanup(\"./foo.git\");",
            " }",
            " ",
            "-static int update_tips(const char *refname, const git_oid *a, const git_oid *b, void *payload)",
            "+static int update_refs(const char *refname, const git_oid *a, const git_oid *b, git_refspec *spec, void *payload)",
            " {",
            " \tint *callcount = (int*)payload;",
            "-\tGIT_UNUSED(refname); GIT_UNUSED(a); GIT_UNUSED(b);",
            "+\tGIT_UNUSED(refname); GIT_UNUSED(a); GIT_UNUSED(b); GIT_UNUSED(spec);",
            " \t*callcount = *callcount + 1;",
            " \treturn 0;",
            " }",
            " ",
            " void test_online_clone__custom_remote_callbacks(void)",
            " {",
            " \tint callcount = 0;",
            " ",
            "-\tg_options.fetch_opts.callbacks.update_tips = update_tips;",
            "+\tg_options.fetch_opts.callbacks.update_refs = update_refs;",
            " \tg_options.fetch_opts.callbacks.payload = &callcount;",
            " ",
            " \tcl_git_pass(git_clone(&g_repo, LIVE_REPO_URL, \"./foo\", &g_options));",
            " \tcl_assert(callcount > 0);",
            " }",
            " ",
            " void test_online_clone__custom_headers(void)",
            "@@ -661,29 +659,47 @@",
            " \t\t_github_ssh_pubkey,",
            " \t\t_github_ssh_privkey,",
            " \t\t_github_ssh_passphrase);",
            " }",
            " ",
            " void test_online_clone__ssh_github(void)",
            " {",
            "-#if !defined(GIT_SSH) || !defined(GIT_SSH_MEMORY_CREDENTIALS)",
            "+#if !defined(GIT_SSH) || !defined(GIT_SSH_LIBSSH2_MEMORY_CREDENTIALS)",
            " \tclar__skip();",
            " #endif",
            " ",
            " \tif (!_github_ssh_pubkey || !_github_ssh_privkey)",
            " \t\tclar__skip();",
            " ",
            " \tcl_fake_homedir(NULL);",
            " ",
            " \tg_options.fetch_opts.callbacks.credentials = github_credentials;",
            " \tg_options.fetch_opts.callbacks.certificate_check = succeed_certificate_check;",
            " ",
            " \tcl_git_pass(git_clone(&g_repo, SSH_REPO_URL, \"./foo\", &g_options));",
            " }",
            " ",
            "+void test_online_clone__ssh_github_shallow(void)",
            "+{",
            "+#if !defined(GIT_SSH) || !defined(GIT_SSH_LIBSSH2_MEMORY_CREDENTIALS)",
            "+\tclar__skip();",
            "+#endif",
            "+",
            "+\tif (!_github_ssh_pubkey || !_github_ssh_privkey)",
            "+\t\tclar__skip();",
            "+",
            "+\tcl_fake_homedir(NULL);",
            "+",
            "+\tg_options.fetch_opts.callbacks.credentials = github_credentials;",
            "+\tg_options.fetch_opts.callbacks.certificate_check = succeed_certificate_check;",
            "+\tg_options.fetch_opts.depth = 1;",
            "+",
            "+\tcl_git_pass(git_clone(&g_repo, SSH_REPO_URL, \"./foo\", &g_options));",
            "+}",
            "+",
            " void test_online_clone__ssh_auth_methods(void)",
            " {",
            " \tint with_user;",
            " ",
            " #ifndef GIT_SSH_LIBSSH2",
            " \tclar__skip();",
            " #endif",
            "@@ -702,15 +718,15 @@",
            " ",
            " /*",
            "  * Ensure that the certificate check callback is still called, and",
            "  * can accept a host key that is not in the known hosts file.",
            "  */",
            " void test_online_clone__ssh_certcheck_accepts_unknown(void)",
            " {",
            "-#if !defined(GIT_SSH_LIBSSH2) || !defined(GIT_SSH_MEMORY_CREDENTIALS)",
            "+#if !defined(GIT_SSH_LIBSSH2) || !defined(GIT_SSH_LIBSSH2_MEMORY_CREDENTIALS)",
            " \tclar__skip();",
            " #endif",
            " ",
            " \tif (!_github_ssh_pubkey || !_github_ssh_privkey)",
            " \t\tclar__skip();",
            " ",
            " \tcl_fake_homedir(NULL);",
            "@@ -731,15 +747,15 @@",
            "  * Ensure that the known hosts file is read and the certificate check",
            "  * callback is still called after that.",
            "  */",
            " void test_online_clone__ssh_certcheck_override_knownhosts(void)",
            " {",
            " \tgit_str knownhostsfile = GIT_STR_INIT;",
            " ",
            "-#if !defined(GIT_SSH) || !defined(GIT_SSH_MEMORY_CREDENTIALS)",
            "+#if !defined(GIT_SSH) || !defined(GIT_SSH_LIBSSH2_MEMORY_CREDENTIALS)",
            " \tclar__skip();",
            " #endif",
            " ",
            " \tif (!_github_ssh_pubkey || !_github_ssh_privkey || !_github_ssh_remotehostkey)",
            " \t\tclar__skip();",
            " ",
            " \tg_options.fetch_opts.callbacks.credentials = github_credentials;",
            "@@ -925,15 +941,15 @@",
            " ",
            " \tgit_error_set(GIT_ERROR_NET, \"unexpected cred type\");",
            " \treturn -1;",
            " }",
            " ",
            " void test_online_clone__ssh_memory_auth(void)",
            " {",
            "-#ifndef GIT_SSH_MEMORY_CREDENTIALS",
            "+#ifndef GIT_SSH_LIBSSH2_MEMORY_CREDENTIALS",
            " \tclar__skip();",
            " #endif",
            " \tif (!_remote_url || !_remote_user || !_remote_ssh_privkey || strncmp(_remote_url, \"ssh://\", 5) != 0)",
            " \t\tclar__skip();",
            " ",
            " \tg_options.fetch_opts.callbacks.credentials = ssh_memory_cred_cb;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/customcert.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/customcert.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/customcert.c",
            "@@ -1,68 +1,79 @@",
            "+#include \"clar.h\"",
            " #include \"clar_libgit2.h\"",
            " ",
            " #include \"path.h\"",
            " #include \"git2/clone.h\"",
            " #include \"git2/cred_helpers.h\"",
            " #include \"remote.h\"",
            " #include \"futils.h\"",
            " #include \"refs.h\"",
            "+#include \"str.h\"",
            "+#include \"streams/openssl.h\"",
            "+",
            "+#if (GIT_OPENSSL && !GIT_OPENSSL_DYNAMIC)",
            "+# include <openssl/ssl.h>",
            "+# include <openssl/err.h>",
            "+# include <openssl/x509v3.h>",
            "+#endif",
            " ",
            " /*",
            "- * Certificate one is in the `certs` folder; certificate two is in the",
            "- * `self-signed.pem` file.",
            "+ * Certificates for https://test.libgit2.org/ are in the `certs` folder.",
            "  */",
            "+#define CUSTOM_CERT_DIR \"certs\"",
            "+",
            " #define CUSTOM_CERT_ONE_URL \"https://test.libgit2.org:1443/anonymous/test.git\"",
            "-#define CUSTOM_CERT_ONE_PATH \"certs\"",
            "+#define CUSTOM_CERT_ONE_PATH \"one\"",
            " ",
            " #define CUSTOM_CERT_TWO_URL \"https://test.libgit2.org:2443/anonymous/test.git\"",
            "-#define CUSTOM_CERT_TWO_FILE \"self-signed.pem\"",
            "+#define CUSTOM_CERT_TWO_FILE \"two.pem\"",
            "+",
            "+#define CUSTOM_CERT_THREE_URL \"https://test.libgit2.org:3443/anonymous/test.git\"",
            "+#define CUSTOM_CERT_THREE_FILE \"three.pem.raw\"",
            " ",
            " #if (GIT_OPENSSL || GIT_MBEDTLS)",
            " static git_repository *g_repo;",
            "-static int initialized = false;",
            " #endif",
            " ",
            " void test_online_customcert__initialize(void)",
            " {",
            " #if (GIT_OPENSSL || GIT_MBEDTLS)",
            "+\tgit_str path = GIT_STR_INIT, file = GIT_STR_INIT;",
            "+\tchar cwd[GIT_PATH_MAX];",
            "+",
            " \tg_repo = NULL;",
            " ",
            "-\tif (!initialized) {",
            "-\t\tgit_str path = GIT_STR_INIT, file = GIT_STR_INIT;",
            "-\t\tchar cwd[GIT_PATH_MAX];",
            "-",
            "-\t\tcl_fixture_sandbox(CUSTOM_CERT_ONE_PATH);",
            "-\t\tcl_fixture_sandbox(CUSTOM_CERT_TWO_FILE);",
            "-",
            "-\t\tcl_must_pass(p_getcwd(cwd, GIT_PATH_MAX));",
            "-\t\tcl_git_pass(git_str_joinpath(&path, cwd, CUSTOM_CERT_ONE_PATH));",
            "-\t\tcl_git_pass(git_str_joinpath(&file, cwd, CUSTOM_CERT_TWO_FILE));",
            "-",
            "-\t\tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_SSL_CERT_LOCATIONS,",
            "-\t\t                             file.ptr, path.ptr));",
            "-\t\tinitialized = true;",
            "+\tcl_fixture_sandbox(CUSTOM_CERT_DIR);",
            " ",
            "-\t\tgit_str_dispose(&file);",
            "-\t\tgit_str_dispose(&path);",
            "-\t}",
            "+\tcl_must_pass(p_getcwd(cwd, GIT_PATH_MAX));",
            "+\tcl_git_pass(git_str_join_n(&path, '/', 3, cwd, CUSTOM_CERT_DIR, CUSTOM_CERT_ONE_PATH));",
            "+\tcl_git_pass(git_str_join_n(&file, '/', 3, cwd, CUSTOM_CERT_DIR, CUSTOM_CERT_TWO_FILE));",
            "+",
            "+\tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_SSL_CERT_LOCATIONS,",
            "+\t                             file.ptr, path.ptr));",
            "+",
            "+\tgit_str_dispose(&file);",
            "+\tgit_str_dispose(&path);",
            " #endif",
            " }",
            " ",
            " void test_online_customcert__cleanup(void)",
            " {",
            " #if (GIT_OPENSSL || GIT_MBEDTLS)",
            " \tif (g_repo) {",
            " \t\tgit_repository_free(g_repo);",
            " \t\tg_repo = NULL;",
            " \t}",
            " ",
            " \tcl_fixture_cleanup(\"./cloned\");",
            "-\tcl_fixture_cleanup(CUSTOM_CERT_ONE_PATH);",
            "-\tcl_fixture_cleanup(CUSTOM_CERT_TWO_FILE);",
            "+\tcl_fixture_cleanup(CUSTOM_CERT_DIR);",
            "+#endif",
            "+",
            "+#ifdef GIT_OPENSSL",
            "+\tgit_openssl__reset_context();",
            " #endif",
            " }",
            " ",
            " void test_online_customcert__file(void)",
            " {",
            " #if (GIT_OPENSSL || GIT_MBEDTLS)",
            " \tcl_git_pass(git_clone(&g_repo, CUSTOM_CERT_ONE_URL, \"./cloned\", NULL));",
            "@@ -73,7 +84,38 @@",
            " void test_online_customcert__path(void)",
            " {",
            " #if (GIT_OPENSSL || GIT_MBEDTLS)",
            " \tcl_git_pass(git_clone(&g_repo, CUSTOM_CERT_TWO_URL, \"./cloned\", NULL));",
            " \tcl_assert(git_fs_path_exists(\"./cloned/master.txt\"));",
            " #endif",
            " }",
            "+",
            "+void test_online_customcert__raw_x509(void)",
            "+{",
            "+#if (GIT_OPENSSL && !GIT_OPENSSL_DYNAMIC)",
            "+\tX509* x509_cert = NULL;",
            "+\tchar cwd[GIT_PATH_MAX];",
            "+\tgit_str raw_file = GIT_STR_INIT,",
            "+\t\traw_file_data = GIT_STR_INIT,",
            "+\t\traw_cert = GIT_STR_INIT;",
            "+\tconst unsigned char *raw_cert_bytes = NULL;",
            "+",
            "+\tcl_must_pass(p_getcwd(cwd, GIT_PATH_MAX));",
            "+",
            "+\tcl_git_pass(git_str_join_n(&raw_file, '/', 3, cwd, CUSTOM_CERT_DIR, CUSTOM_CERT_THREE_FILE));",
            "+",
            "+\tcl_git_pass(git_futils_readbuffer(&raw_file_data, git_str_cstr(&raw_file)));",
            "+\tcl_git_pass(git_str_decode_base64(&raw_cert, git_str_cstr(&raw_file_data), git_str_len(&raw_file_data)));",
            "+",
            "+\traw_cert_bytes = (const unsigned char *)git_str_cstr(&raw_cert);",
            "+\tx509_cert = d2i_X509(NULL, &raw_cert_bytes, git_str_len(&raw_cert));",
            "+\tcl_git_pass(git_libgit2_opts(GIT_OPT_ADD_SSL_X509_CERT, x509_cert));",
            "+\tX509_free(x509_cert);",
            "+",
            "+\tcl_git_pass(git_clone(&g_repo, CUSTOM_CERT_THREE_URL, \"./cloned\", NULL));",
            "+\tcl_assert(git_fs_path_exists(\"./cloned/master.txt\"));",
            "+",
            "+\tgit_str_dispose(&raw_cert);",
            "+\tgit_str_dispose(&raw_file_data);",
            "+\tgit_str_dispose(&raw_file);",
            "+#endif",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/fetch.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/fetch.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/fetch.c",
            "@@ -35,17 +35,21 @@",
            " \tgit__free(_remote_proxy_host);",
            " \tgit__free(_remote_proxy_user);",
            " \tgit__free(_remote_proxy_pass);",
            " \tgit__free(_remote_redirect_initial);",
            " \tgit__free(_remote_redirect_subsequent);",
            " }",
            " ",
            "-static int update_tips(const char *refname, const git_oid *a, const git_oid *b, void *data)",
            "+static int update_refs(const char *refname, const git_oid *a, const git_oid *b, git_refspec *spec, void *data)",
            " {",
            "-\tGIT_UNUSED(refname); GIT_UNUSED(a); GIT_UNUSED(b); GIT_UNUSED(data);",
            "+\tGIT_UNUSED(refname);",
            "+\tGIT_UNUSED(a);",
            "+\tGIT_UNUSED(b);",
            "+\tGIT_UNUSED(spec);",
            "+\tGIT_UNUSED(data);",
            " ",
            " \t++counter;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            " static int progress(const git_indexer_progress *stats, void *payload)",
            "@@ -58,15 +62,15 @@",
            " static void do_fetch(const char *url, git_remote_autotag_option_t flag, int n)",
            " {",
            " \tgit_remote *remote;",
            " \tgit_fetch_options options = GIT_FETCH_OPTIONS_INIT;",
            " \tsize_t bytes_received = 0;",
            " ",
            " \toptions.callbacks.transfer_progress = progress;",
            "-\toptions.callbacks.update_tips = update_tips;",
            "+\toptions.callbacks.update_refs = update_refs;",
            " \toptions.callbacks.payload = &bytes_received;",
            " \toptions.download_tags = flag;",
            " \tcounter = 0;",
            " ",
            " \tcl_git_pass(git_remote_create(&remote, _repo, \"test\", url));",
            " \tcl_git_pass(git_remote_fetch(remote, NULL, &options, NULL));",
            " \tcl_assert_equal_i(counter, n);",
            "@@ -159,15 +163,15 @@",
            " \tcl_git_pass(git_remote_lookup(&remote, _repository, \"origin\"));",
            " \tcl_git_pass(git_remote_connect(remote, GIT_DIRECTION_FETCH, NULL, NULL, NULL));",
            " ",
            " \tcl_assert_equal_i(false, invoked);",
            " ",
            " \toptions.callbacks.transfer_progress = &transferProgressCallback;",
            " \toptions.callbacks.payload = &invoked;",
            "-\toptions.callbacks.update_tips = update_tips;",
            "+\toptions.callbacks.update_refs = update_refs;",
            " \tcl_git_pass(git_remote_download(remote, NULL, &options));",
            " ",
            " \tcl_assert_equal_i(false, invoked);",
            " ",
            " \tcl_git_pass(git_remote_update_tips(remote, &options.callbacks, GIT_REMOTE_UPDATE_FETCHHEAD, options.download_tags, NULL));",
            " \tcl_assert_equal_i(0, counter);",
            " ",
            "@@ -197,15 +201,15 @@",
            " \tcl_git_pass(git_remote_lookup(&remote, _repository, \"origin\"));",
            " \tcl_git_pass(git_remote_connect(remote, GIT_DIRECTION_FETCH, NULL, NULL, NULL));",
            " ",
            " \tcl_assert_equal_i(false, invoked);",
            " ",
            " \toptions.callbacks.transfer_progress = &transferProgressCallback;",
            " \toptions.callbacks.payload = &invoked;",
            "-\toptions.callbacks.update_tips = update_tips;",
            "+\toptions.callbacks.update_refs = update_refs;",
            " \tcl_git_pass(git_remote_download(remote, NULL, &options));",
            " ",
            " \tcl_assert_equal_i(false, invoked);",
            " ",
            " \tcl_git_pass(git_remote_update_tips(remote, &options.callbacks, GIT_REMOTE_UPDATE_REPORT_UNCHANGED, options.download_tags, NULL));",
            " \tcl_assert(counter > 0);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/fetchhead.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/fetchhead.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/fetchhead.c",
            "@@ -8,20 +8,17 @@",
            " #define LIVE_REPO_URL \"https://github.com/libgit2/TestGitRepository\"",
            " ",
            " static git_repository *g_repo;",
            " static git_clone_options g_options;",
            " ",
            " void test_online_fetchhead__initialize(void)",
            " {",
            "-\tgit_fetch_options dummy_fetch = GIT_FETCH_OPTIONS_INIT;",
            " \tg_repo = NULL;",
            " ",
            "-\tmemset(&g_options, 0, sizeof(git_clone_options));",
            "-\tg_options.version = GIT_CLONE_OPTIONS_VERSION;",
            "-\tg_options.fetch_opts = dummy_fetch;",
            "+\tgit_clone_options_init(&g_options, GIT_CLONE_OPTIONS_VERSION);",
            " }",
            " ",
            " void test_online_fetchhead__cleanup(void)",
            " {",
            " \tif (g_repo) {",
            " \t\tgit_repository_free(g_repo);",
            " \t\tg_repo = NULL;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/push.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/push.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/push.c",
            "@@ -161,15 +161,15 @@",
            " \tgit_vector_foreach(actual, i, iter) {",
            " \t\tpush_status *s = (push_status *)iter;",
            " \t\tgit__free(s->ref);",
            " \t\tgit__free(s->msg);",
            " \t\tgit__free(s);",
            " \t}",
            " ",
            "-\tgit_vector_free(actual);",
            "+\tgit_vector_dispose(actual);",
            " }",
            " ",
            " /**",
            "  * Verifies that after git_push_finish(), refs on a remote have the expected",
            "  * names, oids, and order.",
            "  *",
            "  * @param remote remote to verify",
            "@@ -268,15 +268,15 @@",
            " failed:",
            " \tif (failed)",
            " \t\tcl_fail(git_str_cstr(&msg));",
            " ",
            " \tgit_vector_foreach(&actual_refs, i, actual_ref)",
            " \t\tgit__free(actual_ref);",
            " ",
            "-\tgit_vector_free(&actual_refs);",
            "+\tgit_vector_dispose(&actual_refs);",
            " \tgit_str_dispose(&msg);",
            " \tgit_buf_dispose(&ref_name);",
            " }",
            " ",
            " static void verify_update_tips_callback(git_remote *remote, expected_ref expected_refs[], size_t expected_refs_len)",
            " {",
            " \tgit_refspec *fetch_spec;",
            "@@ -412,15 +412,15 @@",
            " \t\t};",
            " ",
            " \t\tmemcpy(&push_opts.callbacks, &_record_cbs, sizeof(git_remote_callbacks));",
            " \t\tcl_git_pass(git_remote_upload(_remote, &arr, &push_opts));",
            " \t}",
            " ",
            " \tgit_remote_disconnect(_remote);",
            "-\tgit_vector_free_deep(&delete_specs);",
            "+\tgit_vector_dispose_deep(&delete_specs);",
            " ",
            " \t/* Now that we've deleted everything, fetch from the remote */",
            " \tmemcpy(&fetch_opts.callbacks, &_record_cbs, sizeof(git_remote_callbacks));",
            " \tcl_git_pass(git_remote_fetch(_remote, NULL, &fetch_opts, NULL));",
            " }",
            " ",
            " void test_online_push__cleanup(void)"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/push_util.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/push_util.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/push_util.c",
            "@@ -20,30 +20,32 @@",
            " \tsize_t i;",
            " \tupdated_tip *tip;",
            " \tpush_status *status;",
            " ",
            " \tgit_vector_foreach(&data->updated_tips, i, tip)",
            " \t\tupdated_tip_free(tip);",
            " ",
            "-\tgit_vector_free(&data->updated_tips);",
            "+\tgit_vector_dispose(&data->updated_tips);",
            " ",
            " \tgit_vector_foreach(&data->statuses, i, status)",
            " \t\tpush_status_free(status);",
            " ",
            "-\tgit_vector_free(&data->statuses);",
            "+\tgit_vector_dispose(&data->statuses);",
            " ",
            " \tdata->pack_progress_calls = 0;",
            " \tdata->transfer_progress_calls = 0;",
            " }",
            " ",
            "-int record_update_tips_cb(const char *refname, const git_oid *a, const git_oid *b, void *data)",
            "+int record_update_refs_cb(const char *refname, const git_oid *a, const git_oid *b, git_refspec *spec, void *data)",
            " {",
            " \tupdated_tip *t;",
            " \trecord_callbacks_data *record_data = (record_callbacks_data *)data;",
            " ",
            "+\tGIT_UNUSED(spec);",
            "+",
            " \tcl_assert(t = git__calloc(1, sizeof(*t)));",
            " ",
            " \tcl_assert(t->name = git__strdup(refname));",
            " \tgit_oid_cpy(&t->old_oid, a);",
            " \tgit_oid_cpy(&t->new_oid, b);",
            " ",
            " \tgit_vector_insert(&record_data->updated_tips, t);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/push_util.h",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/push_util.h",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/push_util.h",
            "@@ -8,15 +8,15 @@",
            " ",
            " /**",
            "  * Macro for initializing git_remote_callbacks to use test helpers that",
            "  * record data in a record_callbacks_data instance.",
            "  * @param data pointer to a record_callbacks_data instance",
            "  */",
            " #define RECORD_CALLBACKS_INIT(data) \\",
            "-\t{ GIT_REMOTE_CALLBACKS_VERSION, NULL, NULL, cred_acquire_cb, NULL, NULL, record_update_tips_cb, NULL, NULL, NULL, NULL, NULL, NULL, data, NULL }",
            "+\t{ GIT_REMOTE_CALLBACKS_VERSION, NULL, NULL, cred_acquire_cb, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, data, NULL, record_update_refs_cb }",
            " ",
            " typedef struct {",
            " \tchar *name;",
            " \tgit_oid old_oid;",
            " \tgit_oid new_oid;",
            " } updated_tip;",
            " ",
            "@@ -46,15 +46,15 @@",
            " void record_callbacks_data_clear(record_callbacks_data *data);",
            " ",
            " /**",
            "  * Callback for git_remote_update_tips that records updates",
            "  *",
            "  * @param data (git_vector *) of updated_tip instances",
            "  */",
            "-int record_update_tips_cb(const char *refname, const git_oid *a, const git_oid *b, void *data);",
            "+int record_update_refs_cb(const char *refname, const git_oid *a, const git_oid *b, git_refspec *spec, void *data);",
            " ",
            " /**",
            "  * Create a set of refspecs that deletes each of the inputs",
            "  *",
            "  * @param out the vector in which to store the refspecs",
            "  * @param heads the remote heads",
            "  * @param heads_len the size of the array"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/online/shallow.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/online/shallow.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/online/shallow.c",
            "@@ -161,14 +161,60 @@",
            " ",
            " \tgit_remote_free(origin);",
            " \tgit_str_dispose(&path);",
            " \tgit_revwalk_free(walk);",
            " \tgit_repository_free(repo);",
            " }",
            " ",
            "+void test_online_shallow__deepen_full(void)",
            "+{",
            "+\tgit_str path = GIT_STR_INIT;",
            "+\tgit_repository *repo;",
            "+\tgit_revwalk *walk;",
            "+\tgit_clone_options clone_opts = GIT_CLONE_OPTIONS_INIT;",
            "+\tgit_fetch_options fetch_opts = GIT_FETCH_OPTIONS_INIT;",
            "+\tgit_remote *origin = NULL;",
            "+\tgit_oid oid;",
            "+\tgit_oid *roots;",
            "+\tsize_t roots_len;",
            "+\tsize_t num_commits = 0;",
            "+\tint error = 0;",
            "+",
            "+\tclone_opts.fetch_opts.depth = 7;",
            "+\tclone_opts.remote_cb = remote_single_branch;",
            "+",
            "+\tgit_str_joinpath(&path, clar_sandbox_path(), \"deepen_full\");",
            "+\tcl_git_pass(git_clone(&repo, \"https://github.com/libgit2/TestGitRepository\", git_str_cstr(&path), &clone_opts));",
            "+\tcl_assert_equal_b(true, git_repository_is_shallow(repo));",
            "+",
            "+\tfetch_opts.depth = 8;",
            "+\tcl_git_pass(git_remote_lookup(&origin, repo, \"origin\"));",
            "+\tcl_git_pass(git_remote_fetch(origin, NULL, &fetch_opts, NULL));",
            "+\tcl_assert_equal_b(false, git_repository_is_shallow(repo));",
            "+",
            "+\tcl_git_pass(git_repository__shallow_roots(&roots, &roots_len, repo));",
            "+\tcl_assert_equal_i(0, roots_len);",
            "+",
            "+\tgit_revwalk_new(&walk, repo);",
            "+\tgit_revwalk_push_head(walk);",
            "+",
            "+\twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            "+\t\tnum_commits++;",
            "+\t}",
            "+",
            "+\tcl_assert_equal_i(num_commits, 21);",
            "+\tcl_assert_equal_i(error, GIT_ITEROVER);",
            "+",
            "+\tgit__free(roots);",
            "+\tgit_remote_free(origin);",
            "+\tgit_str_dispose(&path);",
            "+\tgit_revwalk_free(walk);",
            "+\tgit_repository_free(repo);",
            "+}",
            "+",
            " void test_online_shallow__deepen_six(void)",
            " {",
            " \tgit_str path = GIT_STR_INIT;",
            " \tgit_repository *repo;",
            " \tgit_revwalk *walk;",
            " \tgit_clone_options clone_opts = GIT_CLONE_OPTIONS_INIT;",
            " \tgit_fetch_options fetch_opts = GIT_FETCH_OPTIONS_INIT;",
            "@@ -238,18 +284,23 @@",
            " ",
            " \tfetch_opts.depth = 4;",
            " \tcl_git_pass(git_remote_lookup(&origin, repo, \"origin\"));",
            " \tcl_git_pass(git_remote_fetch(origin, NULL, &fetch_opts, NULL));",
            " \tcl_assert_equal_b(true, git_repository_is_shallow(repo));",
            " ",
            " \tcl_git_pass(git_repository__shallow_roots(&roots, &roots_len, repo));",
            "-\tcl_assert_equal_i(3, roots_len);",
            "-\tcl_assert_equal_s(\"d86a2aada2f5e7ccf6f11880bfb9ab404e8a8864\", git_oid_tostr_s(&roots[0]));",
            "-\tcl_assert_equal_s(\"59706a11bde2b9899a278838ef20a97e8f8795d2\", git_oid_tostr_s(&roots[1]));",
            "+\tcl_assert_equal_i(6, roots_len);",
            "+\t/* roots added during initial clone, not removed as not encountered during fetch */",
            "+\tcl_assert_equal_s(\"c070ad8c08840c8116da865b2d65593a6bb9cd2a\", git_oid_tostr_s(&roots[0]));",
            "+\tcl_assert_equal_s(\"0966a434eb1a025db6b71485ab63a3bfbea520b6\", git_oid_tostr_s(&roots[1]));",
            "+\tcl_assert_equal_s(\"83834a7afdaa1a1260568567f6ad90020389f664\", git_oid_tostr_s(&roots[3]));",
            "+\t/* roots added during fetch */",
            " \tcl_assert_equal_s(\"bab66b48f836ed950c99134ef666436fb07a09a0\", git_oid_tostr_s(&roots[2]));",
            "+\tcl_assert_equal_s(\"59706a11bde2b9899a278838ef20a97e8f8795d2\", git_oid_tostr_s(&roots[4]));",
            "+\tcl_assert_equal_s(\"d86a2aada2f5e7ccf6f11880bfb9ab404e8a8864\", git_oid_tostr_s(&roots[5]));",
            " ",
            " \tgit_revwalk_new(&walk, repo);",
            " \tgit_revwalk_push_head(walk);",
            " ",
            " \twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            " \t\tnum_commits++;",
            " \t}",
            "@@ -259,7 +310,144 @@",
            " ",
            " \tgit__free(roots);",
            " \tgit_remote_free(origin);",
            " \tgit_str_dispose(&path);",
            " \tgit_revwalk_free(walk);",
            " \tgit_repository_free(repo);",
            " }",
            "+",
            "+void test_online_shallow__preserve_unrelated_roots(void)",
            "+{",
            "+\tgit_str path = GIT_STR_INIT;",
            "+\tgit_repository *repo;",
            "+\tgit_revwalk *walk;",
            "+\tgit_fetch_options fetch_opts = GIT_FETCH_OPTIONS_INIT;",
            "+\tgit_remote *origin = NULL;",
            "+\tgit_strarray refspecs;",
            "+\tgit_oid oid;",
            "+\tgit_oid *roots;",
            "+\tsize_t roots_len;",
            "+\tsize_t num_commits = 0;",
            "+\tint error = 0;",
            "+\tgit_oid first_oid;",
            "+\tgit_oid second_oid;",
            "+\tgit_oid third_oid;",
            "+\tchar *first_commit = \"c070ad8c08840c8116da865b2d65593a6bb9cd2a\";",
            "+\tchar *second_commit = \"6e1475206e57110fcef4b92320436c1e9872a322\";",
            "+\tchar *third_commit = \"7f822839a2fe9760f386cbbbcb3f92c5fe81def7\";",
            "+",
            "+#ifdef GIT_EXPERIMENTAL_SHA256",
            "+\tcl_git_pass(git_oid_fromstr(&first_oid, first_commit, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_oid_fromstr(&second_oid, second_commit, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_oid_fromstr(&third_oid, third_commit, GIT_OID_SHA1));",
            "+#else",
            "+\tcl_git_pass(git_oid_fromstr(&first_oid, first_commit));",
            "+\tcl_git_pass(git_oid_fromstr(&second_oid, second_commit));",
            "+\tcl_git_pass(git_oid_fromstr(&third_oid, third_commit));",
            "+#endif",
            "+",
            "+\t/* setup empty repository without cloning */",
            "+\tgit_str_joinpath(&path, clar_sandbox_path(), \"preserve_unrelated_roots\");",
            "+\tcl_git_pass(git_repository_init(&repo, git_str_cstr(&path), true));",
            "+\tcl_git_pass(git_remote_create(&origin, repo, \"origin\", \"https://github.com/libgit2/TestGitRepository\"));",
            "+\tcl_assert_equal_b(false, git_repository_is_shallow(repo));",
            "+",
            "+\t/* shallow fetch for first commit */",
            "+\tfetch_opts.depth = 1;",
            "+\trefspecs.strings = &first_commit;",
            "+\trefspecs.count = 1;",
            "+\tcl_git_pass(git_remote_fetch(origin, &refspecs, &fetch_opts, NULL));",
            "+\tcl_assert_equal_b(true, git_repository_is_shallow(repo));",
            "+",
            "+\tcl_git_pass(git_repository__shallow_roots(&roots, &roots_len, repo));",
            "+\tcl_assert_equal_i(1, roots_len);",
            "+\tcl_assert_equal_s(\"c070ad8c08840c8116da865b2d65593a6bb9cd2a\", git_oid_tostr_s(&roots[0]));",
            "+",
            "+\tcl_git_pass(git_revwalk_new(&walk, repo));",
            "+\tcl_git_pass(git_revwalk_push(walk, &first_oid));",
            "+\twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            "+\t\tnum_commits++;",
            "+\t}",
            "+\tcl_assert_equal_i(num_commits, 1);",
            "+\tcl_assert_equal_i(error, GIT_ITEROVER);",
            "+",
            "+\t/* shallow fetch for second commit */",
            "+\tfetch_opts.depth = 1;",
            "+\trefspecs.strings = &second_commit;",
            "+\trefspecs.count = 1;",
            "+\tcl_git_pass(git_remote_fetch(origin, &refspecs, &fetch_opts, NULL));",
            "+\tcl_assert_equal_b(true, git_repository_is_shallow(repo));",
            "+",
            "+\tgit__free(roots);",
            "+\tcl_git_pass(git_repository__shallow_roots(&roots, &roots_len, repo));",
            "+\tcl_assert_equal_i(2, roots_len);",
            "+\tcl_assert_equal_s(\"c070ad8c08840c8116da865b2d65593a6bb9cd2a\", git_oid_tostr_s(&roots[0]));",
            "+\tcl_assert_equal_s(\"6e1475206e57110fcef4b92320436c1e9872a322\", git_oid_tostr_s(&roots[1]));",
            "+",
            "+\tgit_revwalk_free(walk);",
            "+\tcl_git_pass(git_revwalk_new(&walk, repo));",
            "+\tcl_git_pass(git_revwalk_push(walk, &second_oid));",
            "+\tnum_commits = 0;",
            "+\twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            "+\t\tnum_commits++;",
            "+\t}",
            "+\tcl_assert_equal_i(error, GIT_ITEROVER);",
            "+\tcl_assert_equal_i(num_commits, 1);",
            "+",
            "+\t/* fetch full history for third commit, includes first commit which should be removed from shallow roots */",
            "+\tfetch_opts.depth = 100;",
            "+\trefspecs.strings = &third_commit;",
            "+\trefspecs.count = 1;",
            "+\tcl_git_pass(git_remote_fetch(origin, &refspecs, &fetch_opts, NULL));",
            "+\tcl_assert_equal_b(true, git_repository_is_shallow(repo));",
            "+",
            "+\tgit__free(roots);",
            "+\tcl_git_pass(git_repository__shallow_roots(&roots, &roots_len, repo));",
            "+\tcl_assert_equal_i(1, roots_len);",
            "+\tcl_assert_equal_s(\"6e1475206e57110fcef4b92320436c1e9872a322\", git_oid_tostr_s(&roots[0]));",
            "+",
            "+\tgit_revwalk_free(walk);",
            "+\tcl_git_pass(git_revwalk_new(&walk, repo));",
            "+\tcl_git_pass(git_revwalk_push(walk, &third_oid));",
            "+\tnum_commits = 0;",
            "+\twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            "+\t\tnum_commits++;",
            "+\t}",
            "+\tcl_assert_equal_i(error, GIT_ITEROVER);",
            "+\tcl_assert_equal_i(num_commits, 12);",
            "+",
            "+\tcl_git_pass(git_revwalk_reset(walk));",
            "+\tcl_git_pass(git_revwalk_push(walk, &second_oid));",
            "+\tnum_commits = 0;",
            "+\twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            "+\t\tnum_commits++;",
            "+\t}",
            "+\tcl_assert_equal_i(error, GIT_ITEROVER);",
            "+\tcl_assert_equal_i(num_commits, 1);",
            "+",
            "+\t/* unshallow repository without specifying any refspec */",
            "+\tfetch_opts.depth = GIT_FETCH_DEPTH_UNSHALLOW;",
            "+\tcl_git_pass(git_remote_fetch(origin, NULL, &fetch_opts, NULL));",
            "+\tcl_assert_equal_b(false, git_repository_is_shallow(repo));",
            "+",
            "+\tgit__free(roots);",
            "+\tcl_git_pass(git_repository__shallow_roots(&roots, &roots_len, repo));",
            "+\tcl_assert_equal_i(0, roots_len);",
            "+",
            "+\tgit_revwalk_free(walk);",
            "+\tcl_git_pass(git_revwalk_new(&walk, repo));",
            "+\tcl_git_pass(git_revwalk_push(walk, &first_oid));",
            "+\tcl_git_pass(git_revwalk_push(walk, &second_oid));",
            "+\tcl_git_pass(git_revwalk_push(walk, &third_oid));",
            "+\tnum_commits = 0;",
            "+\twhile ((error = git_revwalk_next(&oid, walk)) == GIT_OK) {",
            "+\t\tnum_commits++;",
            "+\t}",
            "+\tcl_assert_equal_i(error, GIT_ITEROVER);",
            "+\tcl_assert_equal_i(num_commits, 18);",
            "+",
            "+\tgit__free(roots);",
            "+\tgit_remote_free(origin);",
            "+\tgit_str_dispose(&path);",
            "+\tgit_revwalk_free(walk);",
            "+\tgit_repository_free(repo);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/pack/filelimit.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/pack/filelimit.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/pack/filelimit.c",
            "@@ -4,15 +4,15 @@",
            " #include <git2.h>",
            " #include \"git2/sys/commit.h\"",
            " #include \"git2/sys/mempack.h\"",
            " ",
            " static size_t expected_open_mwindow_files = 0;",
            " static size_t original_mwindow_file_limit = 0;",
            " ",
            "-extern git_mutex git__mwindow_mutex;",
            "+extern git_mutex git_mwindow__mutex;",
            " extern git_mwindow_ctl git_mwindow__mem_ctl;",
            " ",
            " void test_pack_filelimit__initialize_tiny(void)",
            " {",
            " \texpected_open_mwindow_files = 1;",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_GET_MWINDOW_FILE_LIMIT, &original_mwindow_file_limit));",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_MWINDOW_FILE_LIMIT, expected_open_mwindow_files));",
            "@@ -116,21 +116,21 @@",
            " ",
            " \t/* Walking the repository requires eventually opening each of the packfiles. */",
            " \ti = 0;",
            " \twhile (git_revwalk_next(&id, walk) == 0)",
            " \t\t++i;",
            " \tcl_assert_equal_i(commit_count, i);",
            " ",
            "-\tcl_git_pass(git_mutex_lock(&git__mwindow_mutex));",
            "+\tcl_git_pass(git_mutex_lock(&git_mwindow__mutex));",
            " \t/*",
            " \t * Adding an assert while holding a lock will cause the whole process to",
            " \t * deadlock. Copy the value and do the assert after releasing the lock.",
            " \t */",
            " \topen_windows = ctl->open_windows;",
            "-\tcl_git_pass(git_mutex_unlock(&git__mwindow_mutex));",
            "+\tcl_git_pass(git_mutex_unlock(&git_mwindow__mutex));",
            " ",
            " \tcl_assert_equal_i(expected_open_mwindow_files, open_windows);",
            " ",
            " \tgit_str_dispose(&path);",
            " \tgit_revwalk_free(walk);",
            " \tgit_repository_free(repo);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/pack/indexer.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/pack/indexer.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/pack/indexer.c",
            "@@ -97,15 +97,15 @@",
            " ",
            " void test_pack_indexer__out_of_order(void)",
            " {",
            " \tgit_indexer *idx = 0;",
            " \tgit_indexer_progress stats = { 0 };",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(",
            " \t\tidx, out_of_order_pack, out_of_order_pack_len, &stats));",
            " \tcl_git_pass(git_indexer_commit(idx, &stats));",
            "@@ -119,15 +119,15 @@",
            " ",
            " void test_pack_indexer__missing_trailer(void)",
            " {",
            " \tgit_indexer *idx = 0;",
            " \tgit_indexer_progress stats = { 0 };",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(",
            " \t\tidx, missing_trailer_pack, missing_trailer_pack_len, &stats));",
            " \tcl_git_fail(git_indexer_commit(idx, &stats));",
            "@@ -140,15 +140,15 @@",
            " ",
            " void test_pack_indexer__leaky(void)",
            " {",
            " \tgit_indexer *idx = 0;",
            " \tgit_indexer_progress stats = { 0 };",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(",
            " \t\tidx, leaky_pack, leaky_pack_len, &stats));",
            " \tcl_git_fail(git_indexer_commit(idx, &stats));",
            "@@ -174,15 +174,15 @@",
            " \t/* Store the missing base into your ODB so the indexer can fix the pack */",
            " \tcl_git_pass(git_odb_write(&id, odb, base_obj, base_obj_len, GIT_OBJECT_BLOB));",
            " \tgit_oid__fromstr(&should_id, \"e68fe8129b546b101aee9510c5328e7f21ca1d18\", GIT_OID_SHA1);",
            " \tcl_assert_equal_oid(&should_id, &id);",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " \topts.odb = odb;",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, &opts));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", &opts));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, odb, &opts));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(idx, thin_pack, thin_pack_len, &stats));",
            " \tcl_git_pass(git_indexer_commit(idx, &stats));",
            " ",
            "@@ -211,15 +211,15 @@",
            " ",
            " \t\tfd = p_open(name, O_RDONLY);",
            " \t\tcl_assert(fd != -1);",
            " ",
            " \t\tcl_git_pass(p_stat(name, &st));",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\t\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\t\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \t\tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \t\tread = p_read(fd, buffer, sizeof(buffer));",
            " \t\tcl_assert(read != -1);",
            " \t\tp_close(fd);",
            "@@ -251,15 +251,16 @@",
            " \t/* Store the missing base into your ODB so the indexer can fix the pack */",
            " \tcl_git_pass(git_odb_write(&id, odb, base_obj, base_obj_len, GIT_OBJECT_BLOB));",
            " \tgit_oid__fromstr(&should_id, \"e68fe8129b546b101aee9510c5328e7f21ca1d18\", GIT_OID_SHA1);",
            " \tcl_assert_equal_oid(&should_id, &id);",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            " \topts.odb = odb;",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, &opts));",
            "+\topts.oid_type = GIT_OID_SHA1;",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", &opts));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, odb, &opts));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(",
            " \t\tidx, corrupt_thin_pack, corrupt_thin_pack_len, &stats));",
            " \tcl_git_fail(git_indexer_commit(idx, &stats));",
            "@@ -277,15 +278,15 @@",
            " \tgit_indexer_options opts = GIT_INDEXER_OPTIONS_INIT;",
            " \tgit_indexer *idx = 0;",
            " \tgit_indexer_progress stats = { 0 };",
            " ",
            " \topts.verify = 1;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, &opts));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", &opts));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, &opts));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(",
            " \t\tidx, incomplete_pack, incomplete_pack_len, &stats));",
            " \tcl_git_fail(git_indexer_commit(idx, &stats));",
            "@@ -302,15 +303,15 @@",
            " \tgit_indexer_options opts = GIT_INDEXER_OPTIONS_INIT;",
            " \tgit_indexer *idx = 0;",
            " \tgit_indexer_progress stats = { 0 };",
            " ",
            " \topts.verify = 1;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, &opts));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", &opts));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, &opts));",
            " #endif",
            " ",
            " \tcl_git_pass(git_indexer_append(",
            " \t\tidx, out_of_order_pack, out_of_order_pack_len, &stats));",
            " \tcl_git_pass(git_indexer_commit(idx, &stats));",
            "@@ -350,15 +351,15 @@",
            " \t/* Precondition: there are no temporary files. */",
            " \tcl_git_pass(git_str_sets(&path, clar_sandbox_path()));",
            " \tcl_git_pass(find_tmp_file_recurs(&first_tmp_file, &path));",
            " \tgit_str_dispose(&path);",
            " \tcl_assert(git_str_len(&first_tmp_file) == 0);",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tgit_indexer_free(idx);",
            " ",
            " \tcl_git_pass(git_str_sets(&path, clar_sandbox_path()));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/pack/midx.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/pack/midx.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/pack/midx.c",
            "@@ -55,15 +55,15 @@",
            " \tgit_str expected_midx = GIT_STR_INIT, path = GIT_STR_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&repo, cl_fixture(\"testrepo.git\")));",
            " ",
            " \tcl_git_pass(git_str_joinpath(&path, git_repository_path(repo), \"objects/pack\"));",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_midx_writer_new(&w, git_str_cstr(&path), GIT_OID_SHA1));",
            "+\tcl_git_pass(git_midx_writer_new(&w, git_str_cstr(&path), NULL));",
            " #else",
            " \tcl_git_pass(git_midx_writer_new(&w, git_str_cstr(&path)));",
            " #endif",
            " ",
            " \tcl_git_pass(git_midx_writer_add(w, \"pack-d7c6adf9f61318f041845b01440d09aa7a91e1b5.idx\"));",
            " \tcl_git_pass(git_midx_writer_add(w, \"pack-d85f5d483273108c9d8dd0e4728ccf0b2982423a.idx\"));",
            " \tcl_git_pass(git_midx_writer_add(w, \"pack-a81e489679b7d3418f9ab594bda8ceb37dd4c695.idx\"));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/pack/packbuilder.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/pack/packbuilder.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/pack/packbuilder.c",
            "@@ -38,15 +38,15 @@",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS, false));",
            " ",
            " \tif (_commits_is_initialized) {",
            " \t\t_commits_is_initialized = 0;",
            " \t\tgit_vector_foreach(&_commits, i, o) {",
            " \t\t\tgit__free(o);",
            " \t\t}",
            "-\t\tgit_vector_free(&_commits);",
            "+\t\tgit_vector_dispose(&_commits);",
            " \t}",
            " ",
            " \tgit_packbuilder_free(_packbuilder);",
            " \t_packbuilder = NULL;",
            " ",
            " \tgit_revwalk_free(_revwalker);",
            " \t_revwalker = NULL;",
            "@@ -98,15 +98,15 @@",
            " {",
            " \tgit_indexer_progress stats;",
            " \tgit_str buf = GIT_STR_INIT, path = GIT_STR_INIT;",
            " ",
            " \tseed_packbuilder();",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&_indexer, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&_indexer, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&_indexer, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tcl_git_pass(git_packbuilder_foreach(_packbuilder, feed_indexer, &stats));",
            " \tcl_git_pass(git_indexer_commit(_indexer, &stats));",
            " ",
            "@@ -257,15 +257,15 @@",
            " void test_pack_packbuilder__foreach(void)",
            " {",
            " \tgit_indexer *idx;",
            " ",
            " \tseed_packbuilder();",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tcl_git_pass(git_packbuilder_foreach(_packbuilder, foreach_cb, idx));",
            " \tcl_git_pass(git_indexer_commit(idx, &_stats));",
            " \tgit_indexer_free(idx);",
            "@@ -281,15 +281,15 @@",
            " void test_pack_packbuilder__foreach_with_cancel(void)",
            " {",
            " \tgit_indexer *idx;",
            " ",
            " \tseed_packbuilder();",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_indexer_new(&idx, \".\", GIT_OID_SHA1, NULL));",
            "+\tcl_git_pass(git_indexer_new(&idx, \".\", NULL));",
            " #else",
            " \tcl_git_pass(git_indexer_new(&idx, \".\", 0, NULL, NULL));",
            " #endif",
            " ",
            " \tcl_git_fail_with(",
            " \t\tgit_packbuilder_foreach(_packbuilder, foreach_cancel_cb, idx), -1111);",
            " \tgit_indexer_free(idx);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/pack/sharing.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/pack/sharing.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/pack/sharing.c",
            "@@ -1,42 +1,37 @@",
            " #include \"clar_libgit2.h\"",
            " #include <git2.h>",
            "-#include \"strmap.h\"",
            " #include \"mwindow.h\"",
            " #include \"pack.h\"",
            "+#include \"hashmap.h\"",
            " ",
            "-extern git_strmap *git__pack_cache;",
            "+extern git_mwindow_packmap git_mwindow__pack_cache;",
            " ",
            " void test_pack_sharing__open_two_repos(void)",
            " {",
            " \tgit_repository *repo1, *repo2;",
            " \tgit_object *obj1, *obj2;",
            " \tgit_oid id;",
            "-\tsize_t pos;",
            "-\tvoid *data;",
            "-\tint error;",
            "+\tstruct git_pack_file *pack;",
            "+\tgit_hashmap_iter_t iter = GIT_HASHMAP_ITER_INIT;",
            " ",
            " \tcl_git_pass(git_repository_open(&repo1, cl_fixture(\"testrepo.git\")));",
            " \tcl_git_pass(git_repository_open(&repo2, cl_fixture(\"testrepo.git\")));",
            " ",
            " \tgit_oid__fromstr(&id, \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", GIT_OID_SHA1);",
            " ",
            " \tcl_git_pass(git_object_lookup(&obj1, repo1, &id, GIT_OBJECT_ANY));",
            " \tcl_git_pass(git_object_lookup(&obj2, repo2, &id, GIT_OBJECT_ANY));",
            " ",
            "-\tpos = 0;",
            "-\twhile ((error = git_strmap_iterate(&data, git__pack_cache, &pos, NULL)) == 0) {",
            "-\t\tstruct git_pack_file *pack = (struct git_pack_file *) data;",
            "-",
            "+\twhile (git_mwindow_packmap_iterate(&iter, NULL, &pack, &git_mwindow__pack_cache) == 0)",
            " \t\tcl_assert_equal_i(2, pack->refcount.val);",
            "-\t}",
            " ",
            "-\tcl_assert_equal_i(3, git_strmap_size(git__pack_cache));",
            "+\tcl_assert_equal_i(3, git_mwindow_packmap_size(&git_mwindow__pack_cache));",
            " ",
            " \tgit_object_free(obj1);",
            " \tgit_object_free(obj2);",
            " \tgit_repository_free(repo1);",
            " \tgit_repository_free(repo2);",
            " ",
            " \t/* we don't want to keep the packs open after the repos go away */",
            "-\tcl_assert_equal_i(0, git_strmap_size(git__pack_cache));",
            "+\tcl_assert_equal_i(0, git_mwindow_packmap_size(&git_mwindow__pack_cache));",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/perf/helper__perf__do_merge.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/perf/helper__perf__do_merge.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/perf/helper__perf__do_merge.c",
            "@@ -22,21 +22,20 @@",
            " \tperf_timer t_total = PERF_TIMER_INIT;",
            " \tperf_timer t_clone = PERF_TIMER_INIT;",
            " \tperf_timer t_checkout = PERF_TIMER_INIT;",
            " \tperf_timer t_merge = PERF_TIMER_INIT;",
            " ",
            " \tperf__timer__start(&t_total);",
            " ",
            "-\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_SAFE;",
            " \tclone_opts.checkout_opts = checkout_opts;",
            " ",
            " \tperf__timer__start(&t_clone);",
            " \tcl_git_pass(git_clone(&g_repo, fixture, test_name, &clone_opts));",
            " \tperf__timer__stop(&t_clone);",
            "-\t",
            "+",
            " \tgit_oid__fromstr(&oid_a, id_a, GIT_OID_SHA1);",
            " \tcl_git_pass(git_commit_lookup(&commit_a, g_repo, &oid_a));",
            " \tcl_git_pass(git_branch_create(&ref_branch_a, g_repo,",
            " \t\t\t\t\t\t\t\t  \"A\", commit_a,",
            " \t\t\t\t\t\t\t\t  0));",
            " ",
            " \tperf__timer__start(&t_checkout);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/refs/iterator.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/refs/iterator.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/refs/iterator.c",
            "@@ -92,15 +92,15 @@",
            " \tgit_vector_foreach(names, i, ref) {",
            " \t\tcl_assert(expected[i] != NULL);",
            " \t\tcl_assert_equal_s(expected[i], ref->name);",
            " \t\tgit_reference_free(ref);",
            " \t}",
            " \tcl_assert(expected[i] == NULL);",
            " ",
            "-\tgit_vector_free(names);",
            "+\tgit_vector_dispose(names);",
            " }",
            " ",
            " void test_refs_iterator__list(void)",
            " {",
            " \tgit_reference_iterator *iter;",
            " \tgit_vector output;",
            " \tgit_reference *ref;",
            "@@ -125,15 +125,15 @@",
            " {",
            " \tgit_reference_iterator *iter;",
            " \tgit_odb *odb;",
            " \tgit_reference *ref;",
            " \tgit_repository *empty;",
            " ",
            " \tcl_git_pass(git_odb__new(&odb, NULL));",
            "-\tcl_git_pass(git_repository__wrap_odb(&empty, odb, GIT_OID_SHA1));",
            "+\tcl_git_pass(git_repository_wrap_odb(&empty, odb));",
            " ",
            " \tcl_git_pass(git_reference_iterator_new(&iter, empty));",
            " \tcl_assert_equal_i(GIT_ITEROVER, git_reference_next(&ref, iter));",
            " ",
            " \tgit_reference_iterator_free(iter);",
            " \tgit_odb_free(odb);",
            " \tgit_repository_free(empty);",
            "@@ -218,15 +218,15 @@",
            " ",
            " \tgit_vector_foreach(&output, i, name) {",
            " \t\tcl_assert(refnames[i] != NULL);",
            " \t\tcl_assert_equal_s(refnames[i], name);",
            " \t\tgit__free(name);",
            " \t}",
            " ",
            "-\tgit_vector_free(&output);",
            "+\tgit_vector_dispose(&output);",
            " }",
            " ",
            " static int refs_foreach_name_cancel_cb(const char *name, void *payload)",
            " {",
            " \tint *cancel_after = payload;",
            " \tif (!*cancel_after)",
            " \t\treturn -333;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/refs/normalize.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/refs/normalize.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/refs/normalize.c",
            "@@ -225,16 +225,14 @@",
            " \t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"refs/heads/master..pu\");",
            " ",
            " /* NoMagicRefCharacters */",
            " \tensure_refname_invalid(",
            " \t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"refs/heads/master^\");",
            " \tensure_refname_invalid(",
            " \t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"refs/heads/^master\");",
            "-\tensure_refname_invalid(",
            "-\t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"^refs/heads/master\");",
            " ",
            " \tensure_refname_invalid(",
            " \t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"refs/heads/master~\");",
            " \tensure_refname_invalid(",
            " \t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"refs/heads/~master\");",
            " \tensure_refname_invalid(",
            " \t\tGIT_REFERENCE_FORMAT_ALLOW_ONELEVEL, \"~refs/heads/master\");",
            "@@ -395,7 +393,17 @@",
            " \t\tONE_LEVEL_AND_REFSPEC, \"*/foo/*\");",
            " ",
            " \tensure_refname_invalid(",
            " \t\tGIT_REFERENCE_FORMAT_REFSPEC_PATTERN, \"*/*/foo\");",
            " \tensure_refname_invalid(",
            " \t\tONE_LEVEL_AND_REFSPEC, \"*/*/foo\");",
            " }",
            "+",
            "+void test_refs_normalize__negative_refspec_pattern(void)",
            "+{",
            "+\tensure_refname_normalized(",
            "+\t\tGIT_REFERENCE_FORMAT_REFSPEC_PATTERN, \"^foo/bar\", \"^foo/bar\");",
            "+\tensure_refname_normalized(",
            "+\t\tGIT_REFERENCE_FORMAT_REFSPEC_PATTERN, \"^foo/bar/*\", \"^foo/bar/*\");",
            "+\tensure_refname_invalid(",
            "+\t\tGIT_REFERENCE_FORMAT_REFSPEC_PATTERN, \"foo/^bar\");",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/refs/tags/name.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/refs/tags/name.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/refs/tags/name.c",
            "@@ -7,11 +7,13 @@",
            " \treturn valid;",
            " }",
            " ",
            " void test_refs_tags_name__is_name_valid(void)",
            " {",
            " \tcl_assert_equal_i(true, name_is_valid(\"sometag\"));",
            " \tcl_assert_equal_i(true, name_is_valid(\"test/sometag\"));",
            "+\tcl_assert_equal_i(true, name_is_valid(\"test/HEAD\"));",
            " ",
            " \tcl_assert_equal_i(false, name_is_valid(\"\"));",
            " \tcl_assert_equal_i(false, name_is_valid(\"-dash\"));",
            "+\tcl_assert_equal_i(false, name_is_valid(\"HEAD\"));",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/remote/fetch.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/remote/fetch.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/remote/fetch.c",
            "@@ -6,16 +6,19 @@",
            " static git_repository *repo1;",
            " static git_repository *repo2;",
            " static char* repo1_path;",
            " static char* repo2_path;",
            " ",
            " static const char *REPO1_REFNAME = \"refs/heads/main\";",
            " static const char *REPO2_REFNAME = \"refs/remotes/repo1/main\";",
            "+static const char *REPO1_UNDERSCORE_REFNAME = \"refs/heads/_branch\";",
            "+static const char *REPO2_UNDERSCORE_REFNAME = \"refs/remotes/repo1/_branch\";",
            " static char *FORCE_FETCHSPEC = \"+refs/heads/main:refs/remotes/repo1/main\";",
            " static char *NON_FORCE_FETCHSPEC = \"refs/heads/main:refs/remotes/repo1/main\";",
            "+static char *NEGATIVE_SPEC = \"^refs/heads/_*\";",
            " ",
            " void test_remote_fetch__initialize(void) {",
            " \tgit_config *c;",
            " \tgit_str repo1_path_buf = GIT_STR_INIT;",
            " \tgit_str repo2_path_buf = GIT_STR_INIT;",
            " \tconst char *sandbox = clar_sandbox_path();",
            " ",
            "@@ -166,7 +169,65 @@",
            " \t/* assert that the reference in repo2 has changed */",
            " \tcl_git_pass(git_reference_lookup(&ref, repo2, REPO2_REFNAME));",
            " \ttarget = git_reference_target(ref);",
            " \tcl_assert_equal_b(git_oid_cmp(target, &commit1id), 0);",
            " ",
            " \tgit_reference_free(ref);",
            " }",
            "+",
            "+/**",
            "+ * This checks that negative refspecs are respected when fetching. We create a",
            "+ * repository with a '_' prefixed reference. A second repository is configured",
            "+ * with a negative refspec to ignore any refs prefixed with '_' and fetch the",
            "+ * first repository into the second.",
            "+ *",
            "+ * @param commit1id A pointer to an OID which will be populated with the first",
            "+ *                  commit.",
            "+ */",
            "+static void do_fetch_repo_with_ref_matching_negative_refspec(git_oid *commit1id) {",
            "+\t/* create a commit in repo 1 and a reference to it with '_' prefix */",
            "+\t{",
            "+\t\tgit_oid empty_tree_id;",
            "+\t\tgit_tree *empty_tree;",
            "+\t\tgit_signature *sig;",
            "+\t\tgit_treebuilder *tb;",
            "+\t\tcl_git_pass(git_treebuilder_new(&tb, repo1, NULL));",
            "+\t\tcl_git_pass(git_treebuilder_write(&empty_tree_id, tb));",
            "+\t\tcl_git_pass(git_tree_lookup(&empty_tree, repo1, &empty_tree_id));",
            "+\t\tcl_git_pass(git_signature_default(&sig, repo1));",
            "+\t\tcl_git_pass(git_commit_create(commit1id, repo1, REPO1_UNDERSCORE_REFNAME, sig,",
            "+\t\t\t\t\tsig, NULL, \"one\", empty_tree, 0, NULL));",
            "+",
            "+\t\tgit_tree_free(empty_tree);",
            "+\t\tgit_signature_free(sig);",
            "+\t\tgit_treebuilder_free(tb);",
            "+\t}",
            "+",
            "+\t/* fetch the remote with negative refspec for references prefixed with '_' */",
            "+\t{",
            "+\t\tchar *refspec_strs = { NEGATIVE_SPEC };",
            "+\t\tgit_strarray refspecs = { &refspec_strs, 1 };",
            "+",
            "+\t\tgit_remote *remote;",
            "+",
            "+\t\tcl_git_pass(git_remote_create_anonymous(&remote, repo2,",
            "+\t\t\t\t\tgit_repository_path(repo1)));",
            "+\t\tcl_git_pass(git_remote_fetch(remote, &refspecs, NULL, \"some message\"));",
            "+",
            "+\t\tgit_remote_free(remote);",
            "+\t}",
            "+}",
            "+",
            "+void test_remote_fetch__skip_negative_refspec_match(void) {",
            "+\tgit_oid commit1id;",
            "+\tgit_reference *ref1;",
            "+\tgit_reference *ref2;",
            "+",
            "+\tdo_fetch_repo_with_ref_matching_negative_refspec(&commit1id);",
            "+",
            "+\t/* assert that the reference in exists in repo1 but not in repo2 */",
            "+\tcl_git_pass(git_reference_lookup(&ref1, repo1, REPO1_UNDERSCORE_REFNAME));",
            "+\tcl_assert_equal_b(git_reference_lookup(&ref2, repo2, REPO2_UNDERSCORE_REFNAME), GIT_ENOTFOUND);",
            "+",
            "+\tgit_reference_free(ref1);",
            "+\tgit_reference_free(ref2);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/repo/extensions.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/repo/extensions.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/repo/extensions.c",
            "@@ -66,7 +66,17 @@",
            " \tcl_git_pass(git_libgit2_opts(GIT_OPT_SET_EXTENSIONS, in, ARRAY_SIZE(in)));",
            " ",
            " \tcl_git_pass(git_repository_open(&extended, \"empty_bare.git\"));",
            " \tcl_assert(git_repository_path(extended) != NULL);",
            " \tcl_assert(git__suffixcmp(git_repository_path(extended), \"/\") == 0);",
            " \tgit_repository_free(extended);",
            " }",
            "+",
            "+void test_repo_extensions__preciousobjects(void)",
            "+{",
            "+\tgit_repository *extended = NULL;",
            "+",
            "+\tcl_repo_set_string(repo, \"extensions.preciousObjects\", \"true\");",
            "+",
            "+\tcl_git_pass(git_repository_open(&extended, \"empty_bare.git\"));",
            "+\tgit_repository_free(extended);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/repo/init.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/repo/init.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/repo/init.c",
            "@@ -485,15 +485,15 @@",
            " \t/* Verify that the gitlink and worktree entries are relative */",
            " ",
            " \t/* Verify worktree */",
            " \tassert_config_entry_value(g_repo, \"core.worktree\", \"../c_wd/\");",
            " ",
            " \t/* Verify gitlink */",
            " \tcl_git_pass(git_futils_readbuffer(&dot_git_content, \"root/b/c_wd/.git\"));",
            "-\tcl_assert_equal_s(\"gitdir: ../my_repository/\", dot_git_content.ptr);",
            "+\tcl_assert_equal_s(\"gitdir: ../my_repository/\\n\", dot_git_content.ptr);",
            " ",
            " \tgit_str_dispose(&dot_git_content);",
            " \tcleanup_repository(\"root\");",
            " }",
            " ",
            " void test_repo_init__relative_gitdir_2(void)",
            " {",
            "@@ -522,15 +522,15 @@",
            " \t/* Verify that the gitlink and worktree entries are relative */",
            " ",
            " \t/* Verify worktree */",
            " \tassert_config_entry_value(g_repo, \"core.worktree\", \"../c_wd/\");",
            " ",
            " \t/* Verify gitlink */",
            " \tcl_git_pass(git_futils_readbuffer(&dot_git_content, \"root/b/c_wd/.git\"));",
            "-\tcl_assert_equal_s(\"gitdir: ../my_repository/\", dot_git_content.ptr);",
            "+\tcl_assert_equal_s(\"gitdir: ../my_repository/\\n\", dot_git_content.ptr);",
            " ",
            " \tgit_str_dispose(&dot_git_content);",
            " \tcleanup_repository(\"root\");",
            " }",
            " ",
            " void test_repo_init__can_reinit_an_initialized_repository(void)",
            " {"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/repo/new.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/repo/new.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/repo/new.c",
            "@@ -2,30 +2,38 @@",
            " #include \"git2/sys/repository.h\"",
            " ",
            " void test_repo_new__has_nothing(void)",
            " {",
            " \tgit_repository *repo;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_repository_new(&repo, GIT_OID_SHA1));",
            "+\tgit_repository_new_options repo_opts = GIT_REPOSITORY_NEW_OPTIONS_INIT;",
            "+",
            "+\trepo_opts.oid_type = GIT_OID_SHA1;",
            "+",
            "+\tcl_git_pass(git_repository_new(&repo, &repo_opts));",
            " #else",
            " \tcl_git_pass(git_repository_new(&repo));",
            " #endif",
            " \tcl_assert_equal_b(true, git_repository_is_bare(repo));",
            " \tcl_assert_equal_p(NULL, git_repository_path(repo));",
            " \tcl_assert_equal_p(NULL, git_repository_workdir(repo));",
            " \tgit_repository_free(repo);",
            " }",
            " ",
            " void test_repo_new__is_bare_until_workdir_set(void)",
            " {",
            " \tgit_repository *repo;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_repository_new(&repo, GIT_OID_SHA1));",
            "+\tgit_repository_new_options repo_opts = GIT_REPOSITORY_NEW_OPTIONS_INIT;",
            "+",
            "+\trepo_opts.oid_type = GIT_OID_SHA1;",
            "+",
            "+\tcl_git_pass(git_repository_new(&repo, &repo_opts));",
            " #else",
            " \tcl_git_pass(git_repository_new(&repo));",
            " #endif",
            " \tcl_assert_equal_b(true, git_repository_is_bare(repo));",
            " ",
            " \tcl_git_pass(git_repository_set_workdir(repo, clar_sandbox_path(), 0));",
            " \tcl_assert_equal_b(false, git_repository_is_bare(repo));",
            "@@ -34,29 +42,36 @@",
            " }",
            " ",
            " void test_repo_new__sha1(void)",
            " {",
            " \tgit_repository *repo;",
            " ",
            " #ifdef GIT_EXPERIMENTAL_SHA256",
            "-\tcl_git_pass(git_repository_new(&repo, GIT_OID_SHA1));",
            "+\tgit_repository_new_options repo_opts = GIT_REPOSITORY_NEW_OPTIONS_INIT;",
            "+",
            "+\trepo_opts.oid_type = GIT_OID_SHA1;",
            "+",
            "+\tcl_git_pass(git_repository_new(&repo, &repo_opts));",
            " #else",
            " \tcl_git_pass(git_repository_new(&repo));",
            " #endif",
            " \tcl_assert_equal_i(GIT_OID_SHA1, git_repository_oid_type(repo));",
            " ",
            " \tgit_repository_free(repo);",
            " }",
            " ",
            " void test_repo_new__sha256(void)",
            " {",
            " #ifndef GIT_EXPERIMENTAL_SHA256",
            " \tcl_skip();",
            " #else",
            " \tgit_repository *repo;",
            "+\tgit_repository_new_options repo_opts = GIT_REPOSITORY_NEW_OPTIONS_INIT;",
            "+",
            "+\trepo_opts.oid_type = GIT_OID_SHA256;",
            " ",
            "-\tcl_git_pass(git_repository_new(&repo, GIT_OID_SHA256));",
            "+\tcl_git_pass(git_repository_new(&repo, &repo_opts));",
            " \tcl_assert_equal_i(GIT_OID_SHA256, git_repository_oid_type(repo));",
            " ",
            " \tgit_repository_free(repo);",
            " #endif",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/repo/pathspec.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/repo/pathspec.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/repo/pathspec.c",
            "@@ -379,7 +379,37 @@",
            " \tcl_assert(!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"two\"));",
            " \tcl_assert(git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"two*\"));",
            " \tcl_assert(!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"anyfour\"));",
            " \tcl_assert(git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"*four\"));",
            " ",
            " \tgit_pathspec_free(ps);",
            " }",
            "+",
            "+void test_repo_pathspec__starstar(void)",
            "+{",
            "+\tstatic char *strings[] = { \"**/foo\", \"**/bar/baz\" };",
            "+\tgit_strarray s = { strings, ARRAY_SIZE(strings) };",
            "+\tgit_pathspec *ps;",
            "+",
            "+\tcl_git_pass(git_pathspec_new(&ps, &s));",
            "+",
            "+\t/* \"**\" \"/foo\" does *not* match top-level \"foo\" */",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"fooz\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"bar\"));",
            "+",
            "+\tcl_assert(git_pathspec_matches_path(ps, 0, \"asdf/foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"asdf/fooz\"));",
            "+\tcl_assert(git_pathspec_matches_path(ps, 0, \"a/b/c/foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"a/b/c/fooz\"));",
            "+",
            "+\tcl_assert(git_pathspec_matches_path(ps, 0, \"bar/foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"bar/baz\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, 0, \"bar/foo/baz\"));",
            "+",
            "+\tcl_assert(!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"asdf/foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"a/b/c/foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"bar/foo\"));",
            "+\tcl_assert(!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, \"bar/baz\"));",
            "+",
            "+\tgit_pathspec_free(ps);",
            "+}"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/repo/setters.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/repo/setters.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/repo/setters.c",
            "@@ -52,15 +52,15 @@",
            " ",
            " \tcl_git_pass(git_repository_set_workdir(repo, \"./new_workdir\", true));",
            " ",
            " \tcl_assert(git_fs_path_isfile(\"./new_workdir/.git\"));",
            " ",
            " \tcl_git_pass(git_futils_readbuffer(&content, \"./new_workdir/.git\"));",
            " \tcl_assert(git__prefixcmp(git_str_cstr(&content), \"gitdir: \") == 0);",
            "-\tcl_assert(git__suffixcmp(git_str_cstr(&content), \"testrepo.git/\") == 0);",
            "+\tcl_assert(git__suffixcmp(git_str_cstr(&content), \"testrepo.git/\\n\") == 0);",
            " \tgit_str_dispose(&content);",
            " ",
            " \tcl_git_pass(git_repository_config(&cfg, repo));",
            " \tcl_git_pass(git_config_get_string_buf(&buf, cfg, \"core.worktree\"));",
            " \tcl_assert(git__suffixcmp(buf.ptr, \"new_workdir/\") == 0);",
            " ",
            " \tgit_buf_dispose(&buf);"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/repo/template.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/repo/template.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/repo/template.c",
            "@@ -224,16 +224,15 @@",
            " ",
            " void test_repo_template__extended_with_template_and_shared_mode(void)",
            " {",
            " \tgit_repository_init_options opts = GIT_REPOSITORY_INIT_OPTIONS_INIT;",
            " \tconst char *repo_path;",
            " \tint filemode;",
            " ",
            "-\topts.flags = GIT_REPOSITORY_INIT_MKPATH |",
            "-\t\tGIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE;",
            "+\topts.flags = GIT_REPOSITORY_INIT_MKPATH;",
            " \topts.template_path = \"template\";",
            " \topts.mode = GIT_REPOSITORY_INIT_SHARED_GROUP;",
            " ",
            " \tsetup_templates(\"template\", false);",
            " \tsetup_repo(\"init_shared_from_tpl\", &opts);",
            " ",
            " \tfilemode = cl_repo_get_bool(_repo, \"core.filemode\");"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/revert/workdir.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/revert/workdir.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/revert/workdir.c",
            "@@ -370,15 +370,15 @@",
            " \tstruct merge_index_entry merge_filesystem_entries[] = {",
            " \t\t{ 0100644, \"caf99de3a49827117bb66721010eac461b06a80c\", 0, \"file1.txt\" },",
            " \t\t{ 0100644, \"0ab09ea6d4c3634bdf6c221626d8b6f7dd890767\", 0, \"file2.txt\" },",
            " \t\t{ 0100644, \"f4e107c230d08a60fb419d19869f1f282b272d9c\", 0, \"file3.txt\" },",
            " \t\t{ 0100644, \"0f5bfcf58c558d865da6be0281d7795993646cee\", 0, \"file6.txt\" },",
            " \t};",
            " ",
            "-\topts.checkout_opts.checkout_strategy = GIT_CHECKOUT_SAFE | GIT_CHECKOUT_USE_OURS;",
            "+\topts.checkout_opts.checkout_strategy = GIT_CHECKOUT_USE_OURS;",
            " ",
            " \tgit_oid__fromstr(&head_oid, \"72333f47d4e83616630ff3b0ffe4c0faebcc3c45\", GIT_OID_SHA1);",
            " \tcl_git_pass(git_commit_lookup(&head, repo, &head_oid));",
            " \tcl_git_pass(git_reset(repo, (git_object *)head, GIT_RESET_HARD, NULL));",
            " ",
            " \tgit_oid__fromstr(&revert_oid, \"d1d403d22cbe24592d725f442835cf46fe60c8ac\", GIT_OID_SHA1);",
            " \tcl_git_pass(git_commit_lookup(&commit, repo, &revert_oid));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/submodule/add.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/submodule/add.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/submodule/add.c",
            "@@ -56,15 +56,15 @@",
            " \tcl_git_pass(git_repository_open(&repo, \"submod2/\" \"sm_libgit2\"));",
            " ",
            " \t/* Verify worktree path is relative */",
            " \tassert_config_entry_value(repo, \"core.worktree\", \"../../../sm_libgit2/\");",
            " ",
            " \t/* Verify gitdir path is relative */",
            " \tcl_git_pass(git_futils_readbuffer(&dot_git_content, \"submod2/\" \"sm_libgit2\" \"/.git\"));",
            "-\tcl_assert_equal_s(\"gitdir: ../.git/modules/sm_libgit2/\", dot_git_content.ptr);",
            "+\tcl_assert_equal_s(\"gitdir: ../.git/modules/sm_libgit2/\\n\", dot_git_content.ptr);",
            " ",
            " \tgit_repository_free(repo);",
            " \tgit_str_dispose(&dot_git_content);",
            " ",
            " \t/* add a submodule not using a gitlink */",
            " ",
            " \tcl_git_pass("
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/submodule/repository_init.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/submodule/repository_init.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/submodule/repository_init.c",
            "@@ -20,15 +20,15 @@",
            " \tcl_git_pass(git_submodule_repo_init(&repo, sm, 1));",
            " ",
            " \t/* Verify worktree */",
            " \tassert_config_entry_value(repo, \"core.worktree\", \"../../../sm_gitmodules_only/\");",
            " ",
            " \t/* Verify gitlink */",
            " \tcl_git_pass(git_futils_readbuffer(&dot_git_content, \"submod2/\" \"sm_gitmodules_only\" \"/.git\"));",
            "-\tcl_assert_equal_s(\"gitdir: ../.git/modules/sm_gitmodules_only/\", dot_git_content.ptr);",
            "+\tcl_assert_equal_s(\"gitdir: ../.git/modules/sm_gitmodules_only/\\n\", dot_git_content.ptr);",
            " ",
            " \tcl_assert(git_fs_path_isfile(\"submod2/\" \"sm_gitmodules_only\" \"/.git\"));",
            " ",
            " \tcl_assert(git_fs_path_isdir(\"submod2/.git/modules\"));",
            " \tcl_assert(git_fs_path_isdir(\"submod2/.git/modules/\" \"sm_gitmodules_only\"));",
            " \tcl_assert(git_fs_path_isfile(\"submod2/.git/modules/\" \"sm_gitmodules_only\" \"/HEAD\"));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/submodule/update.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/submodule/update.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/submodule/update.c",
            "@@ -26,15 +26,15 @@",
            " \t\tGIT_ERROR,",
            " \t\tgit_submodule_update(sm, 0, &update_options));",
            " ",
            " \tgit_submodule_free(sm);",
            " }",
            " ",
            " struct update_submodule_cb_payload {",
            "-\tint update_tips_called;",
            "+\tint update_refs_called;",
            " \tint checkout_progress_called;",
            " \tint checkout_notify_called;",
            " };",
            " ",
            " static void checkout_progress_cb(",
            " \tconst char *path,",
            " \tsize_t completed_steps,",
            "@@ -67,23 +67,24 @@",
            " \tGIT_UNUSED(workdir);",
            " ",
            " \tupdate_payload->checkout_notify_called = 1;",
            " ",
            " \treturn 0;",
            " }",
            " ",
            "-static int update_tips(const char *refname, const git_oid *a, const git_oid *b, void *data)",
            "+static int update_refs(const char *refname, const git_oid *a, const git_oid *b, git_refspec *spec, void *data)",
            " {",
            " \tstruct update_submodule_cb_payload *update_payload = data;",
            " ",
            " \tGIT_UNUSED(refname);",
            " \tGIT_UNUSED(a);",
            " \tGIT_UNUSED(b);",
            "+\tGIT_UNUSED(spec);",
            " ",
            "-\tupdate_payload->update_tips_called = 1;",
            "+\tupdate_payload->update_refs_called = 1;",
            " ",
            " \treturn 1;",
            " }",
            " ",
            " void test_submodule_update__update_submodule(void)",
            " {",
            " \tgit_submodule *sm;",
            "@@ -92,15 +93,15 @@",
            " \tstruct update_submodule_cb_payload update_payload = { 0 };",
            " ",
            " \tg_repo = setup_fixture_submodule_simple();",
            " ",
            " \tupdate_options.checkout_opts.progress_cb = checkout_progress_cb;",
            " \tupdate_options.checkout_opts.progress_payload = &update_payload;",
            " ",
            "-\tupdate_options.fetch_opts.callbacks.update_tips = update_tips;",
            "+\tupdate_options.fetch_opts.callbacks.update_refs = update_refs;",
            " \tupdate_options.fetch_opts.callbacks.payload = &update_payload;",
            " ",
            " \t/* get the submodule */",
            " \tcl_git_pass(git_submodule_lookup(&sm, g_repo, \"testrepo\"));",
            " ",
            " \t/* verify the initial state of the submodule */",
            " \tcl_git_pass(git_submodule_status(&submodule_status, g_repo, \"testrepo\", GIT_SUBMODULE_IGNORE_UNSPECIFIED));",
            "@@ -122,15 +123,15 @@",
            " ",
            " \tcl_assert(git_oid_streq(git_submodule_head_id(sm), \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\") == 0);",
            " \tcl_assert(git_oid_streq(git_submodule_wd_id(sm), \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\") == 0);",
            " \tcl_assert(git_oid_streq(git_submodule_index_id(sm), \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\") == 0);",
            " ",
            " \t/* verify that the expected callbacks have been called. */",
            " \tcl_assert_equal_i(1, update_payload.checkout_progress_called);",
            "-\tcl_assert_equal_i(1, update_payload.update_tips_called);",
            "+\tcl_assert_equal_i(1, update_payload.update_refs_called);",
            " ",
            " \tgit_submodule_free(sm);",
            " }",
            " ",
            " void test_submodule_update__update_submodule_with_path(void)",
            " {",
            " \tgit_submodule *sm;",
            "@@ -139,15 +140,15 @@",
            " \tstruct update_submodule_cb_payload update_payload = { 0 };",
            " ",
            " \tg_repo = setup_fixture_submodule_with_path();",
            " ",
            " \tupdate_options.checkout_opts.progress_cb = checkout_progress_cb;",
            " \tupdate_options.checkout_opts.progress_payload = &update_payload;",
            " ",
            "-\tupdate_options.fetch_opts.callbacks.update_tips = update_tips;",
            "+\tupdate_options.fetch_opts.callbacks.update_refs = update_refs;",
            " \tupdate_options.fetch_opts.callbacks.payload = &update_payload;",
            " ",
            " \t/* get the submodule */",
            " \tcl_git_pass(git_submodule_lookup(&sm, g_repo, \"testrepo\"));",
            " ",
            " \t/* verify the initial state of the submodule */",
            " \tcl_git_pass(git_submodule_status(&submodule_status, g_repo, \"testrepo\", GIT_SUBMODULE_IGNORE_UNSPECIFIED));",
            "@@ -169,15 +170,15 @@",
            " ",
            " \tcl_assert(git_oid_streq(git_submodule_head_id(sm), \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\") == 0);",
            " \tcl_assert(git_oid_streq(git_submodule_wd_id(sm), \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\") == 0);",
            " \tcl_assert(git_oid_streq(git_submodule_index_id(sm), \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\") == 0);",
            " ",
            " \t/* verify that the expected callbacks have been called. */",
            " \tcl_assert_equal_i(1, update_payload.checkout_progress_called);",
            "-\tcl_assert_equal_i(1, update_payload.update_tips_called);",
            "+\tcl_assert_equal_i(1, update_payload.update_refs_called);",
            " ",
            " \tgit_submodule_free(sm);",
            " }",
            " ",
            " void test_submodule_update__update_and_init_submodule(void)",
            " {",
            " \tgit_submodule *sm;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/libgit2/transport/register.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/libgit2/transport/register.c",
            "+++ /home/libgit2-1.9.1/tests/libgit2/transport/register.c",
            "@@ -140,14 +140,15 @@",
            " \t(*t->called)++;",
            " \tif (strcmp(proxy_url, opts.proxy_opts.url) == 0)",
            " \t\t(*t->called)++;",
            " ",
            " \tgit_remote_connect_options_dispose(&opts);",
            " ",
            " \t*out = git__calloc(1, sizeof(git_smart_subtransport_stream));",
            "+\tGIT_ERROR_CHECK_ALLOC(*out);",
            " \t(*out)->subtransport = transport;",
            " \t(*out)->read = custom_subtransport_stream__read;",
            " \t(*out)->write = custom_subtransport_stream__write;",
            " \t(*out)->free = custom_subtransport_stream__free;",
            " ",
            " \treturn ret;",
            " }",
            "@@ -165,14 +166,15 @@",
            " ",
            " \tgit__free(transport);",
            " }",
            " ",
            " static int custom_transport_callback(git_smart_subtransport **out, git_transport *owner, void *param)",
            " {",
            " \tstruct custom_subtransport *subtransport = git__calloc(1, sizeof(struct custom_subtransport));",
            "+\tGIT_ERROR_CHECK_ALLOC(subtransport);",
            " \tsubtransport->called = (int *)param;",
            " \tsubtransport->owner = owner;",
            " \tsubtransport->subtransport.action = custom_subtransport__action;",
            " \tsubtransport->subtransport.close = custom_subtransport__close;",
            " \tsubtransport->subtransport.free = custom_subtransport__free;",
            " ",
            " \t*out = &subtransport->subtransport;"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/util/process/env.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/util/process/env.c",
            "+++ /home/libgit2-1.9.1/tests/util/process/env.c",
            "@@ -15,15 +15,15 @@",
            " #endif",
            " ",
            " \tcl_git_pass(git_vector_init(&env_result, 32, git__strcmp_cb));",
            " }",
            " ",
            " void test_process_env__cleanup(void)",
            " {",
            "-\tgit_vector_free(&env_result);",
            "+\tgit_vector_dispose(&env_result);",
            " \tgit_str_dispose(&accumulator);",
            " \tgit_str_dispose(&env_cmd);",
            " }",
            " ",
            " static void run_env(const char **env_array, size_t env_len, bool exclude_env)",
            " {",
            " \tconst char *args_array[] = { env_cmd.ptr };"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/util/url/parse.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/util/url/parse.c",
            "+++ /home/libgit2-1.9.1/tests/util/url/parse.c",
            "@@ -23,84 +23,105 @@",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://example.com/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_implied_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://example.com\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_numeric(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://8888888/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"8888888\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_implied_root_custom_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://example.com:42\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"42\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            "+}",
            "+",
            "+void test_url_parse__specified_default_port(void)",
            "+{",
            "+\tcl_git_pass(git_net_url_parse(&conndata, \"http://example.com:80/\"));",
            "+\tcl_assert_equal_s(conndata.scheme, \"http\");",
            "+\tcl_assert_equal_s(conndata.host, \"example.com\");",
            "+\tcl_assert_equal_s(conndata.port, \"80\");",
            "+\tcl_assert_equal_s(conndata.path, \"/\");",
            "+\tcl_assert_equal_p(conndata.username, NULL);",
            "+\tcl_assert_equal_p(conndata.password, NULL);",
            "+\tcl_assert_equal_p(conndata.query, NULL);",
            "+\tcl_assert_equal_p(conndata.fragment, NULL);",
            "+\tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_implied_root_empty_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://example.com:\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_encoded_password(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass%2fis%40bad@hostname.com:1234/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            "@@ -108,14 +129,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"1234\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass/is@bad\");",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user@example.com/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            "@@ -123,14 +145,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_user_pass(void)",
            " {",
            " \t/* user:pass@hostname.tld/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass@example.com/resource\"));",
            "@@ -139,14 +162,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_port(void)",
            " {",
            " \t/* hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://example.com:9191/resource\"));",
            "@@ -155,28 +179,30 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_empty_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://example.com:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__hostname_user_port(void)",
            " {",
            " \t/* user@hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user@example.com:9191/resource\"));",
            "@@ -185,14 +211,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_user_pass_port(void)",
            " {",
            " \t/* user:pass@hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass@example.com:9191/resource\"));",
            "@@ -201,14 +228,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_user_pass_port_query(void)",
            " {",
            " \t/* user:pass@hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass@example.com:9191/resource?query=q&foo=bar&z=asdf\"));",
            "@@ -217,14 +245,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_s(conndata.query, \"query=q&foo=bar&z=asdf\");",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_user_pass_port_fragment(void)",
            " {",
            " \t/* user:pass@hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass@example.com:9191/resource#fragment\"));",
            "@@ -233,14 +262,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_s(conndata.fragment, \"fragment\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__hostname_user_pass_port_query_fragment(void)",
            " {",
            " \t/* user:pass@hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass@example.com:9191/resource?query=q&foo=bar&z=asdf#fragment\"));",
            "@@ -249,14 +279,15 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_s(conndata.query, \"query=q&foo=bar&z=asdf\");",
            " \tcl_assert_equal_s(conndata.fragment, \"fragment\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__fragment_with_question_mark(void)",
            " {",
            " \t/* user:pass@hostname.tld:port/resource */",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\t\t\"https://user:pass@example.com:9191/resource#fragment_with?question_mark\"));",
            "@@ -265,318 +296,343 @@",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_s(conndata.fragment, \"fragment_with?question_mark\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " /* IPv4 addresses */",
            " ",
            " void test_url_parse__ipv4_trivial(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://192.168.1.1/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://192.168.1.1/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_implied_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://192.168.1.1\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_implied_root_custom_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://192.168.1.1:42\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"42\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv4_implied_root_empty_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://192.168.1.1:\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_encoded_password(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user:pass%2fis%40bad@192.168.1.1:1234/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"1234\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass/is@bad\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv4_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user@192.168.1.1/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_user_pass(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user:pass@192.168.1.1/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://192.168.1.1:9191/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv4_empty_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://192.168.1.1:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv4_user_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user@192.168.1.1:9191/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv4_user_pass_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user:pass@192.168.1.1:9191/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.1.1\");",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " /* IPv6 addresses */",
            " ",
            " void test_url_parse__ipv6_trivial(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://[fe80::dcad:beff:fe00:0001]/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://[fe80::dcad:beff:fe00:0001]/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_implied_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://[fe80::dcad:beff:fe00:0001]\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_implied_root_custom_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://[fe80::dcad:beff:fe00:0001]:42\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"42\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv6_implied_root_empty_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://[fe80::dcad:beff:fe00:0001]:\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_encoded_password(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user:pass%2fis%40bad@[fe80::dcad:beff:fe00:0001]:1234/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"1234\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass/is@bad\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv6_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user@[fe80::dcad:beff:fe00:0001]/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_user_pass(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user:pass@[fe80::dcad:beff:fe00:0001]/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://[fe80::dcad:beff:fe00:0001]:9191/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv6_empty_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://[fe80::dcad:beff:fe00:0001]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__ipv6_user_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user@[fe80::dcad:beff:fe00:0001]:9191/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv6_user_pass_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata,",
            " \t\t\"https://user:pass@[fe80::dcad:beff:fe00:0001]:9191/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80::dcad:beff:fe00:0001\");",
            " \tcl_assert_equal_s(conndata.port, \"9191\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"user\");",
            " \tcl_assert_equal_s(conndata.password, \"pass\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ipv6_invalid_addresses(void)",
            " {",
            " \t/* Opening bracket missing */",
            " \tcl_git_fail_with(GIT_EINVALIDSPEC, git_net_url_parse(&conndata,",
            " \t\t\"http://fe80::dcad:beff:fe00:0001]/resource\"));",
            "@@ -677,94 +733,102 @@",
            " \tcl_assert_equal_s(conndata.port, NULL);",
            " \tcl_assert_equal_s(conndata.path, \"//example.com/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_p(conndata.query, NULL);",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__invalid_scheme_is_relative(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"foo!bar://host:42/path/to/project?query_string=yes\"));",
            " \tcl_assert_equal_p(conndata.scheme, NULL);",
            " \tcl_assert_equal_p(conndata.host, NULL);",
            " \tcl_assert_equal_p(conndata.port, NULL);",
            " \tcl_assert_equal_s(conndata.path, \"foo!bar://host:42/path/to/project\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_s(conndata.query, \"query_string=yes\");",
            " \tcl_assert_equal_p(conndata.fragment, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__scheme_case_is_normalized(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"GIT+SSH://host:42/path/to/project\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"git+ssh\");",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__nonhierarchical_scheme(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"mailto:foobar@example.com\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"mailto\");",
            " \tcl_assert_equal_p(conndata.host, NULL);",
            " \tcl_assert_equal_p(conndata.port, NULL);",
            " \tcl_assert_equal_s(conndata.path, \"foobar@example.com\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__no_scheme_relative_path(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"path\"));",
            " \tcl_assert_equal_p(conndata.scheme, NULL);",
            " \tcl_assert_equal_p(conndata.host, NULL);",
            " \tcl_assert_equal_p(conndata.port, NULL);",
            " \tcl_assert_equal_s(conndata.path, \"path\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__no_scheme_absolute_path(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"/path\"));",
            " \tcl_assert_equal_p(conndata.scheme, NULL);",
            " \tcl_assert_equal_p(conndata.host, NULL);",
            " \tcl_assert_equal_p(conndata.port, NULL);",
            " \tcl_assert_equal_s(conndata.path, \"/path\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__empty_path(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"mailto:\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"mailto\");",
            " \tcl_assert_equal_p(conndata.host, NULL);",
            " \tcl_assert_equal_p(conndata.port, NULL);",
            " \tcl_assert_equal_s(conndata.path, NULL);",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__empty_path_with_empty_authority(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"http://\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"http\");",
            " \tcl_assert_equal_p(conndata.host, NULL);",
            " \tcl_assert_equal_s(conndata.port, \"80\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_parse__http_follows_the_rfc(void)",
            " {",
            " \tcl_git_fail(git_net_url_parse(&conndata, \"https://my.email.address@gmail.com@source.developers.google.com:4433/p/my-project/r/my-repository\"));",
            " }",
            " ",
            "@@ -774,32 +838,35 @@",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"source.developers.google.com\");",
            " \tcl_assert_equal_s(conndata.port, \"2022\");",
            " \tcl_assert_equal_s(conndata.path, \"/p/my-project/r/my-repository\");",
            " \tcl_assert_equal_s(conndata.username, \"my.email.address@gmail.com\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__ssh_with_password_from_terrible_google_rfc_violating_products(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"ssh://my.email.address@gmail.com:seekret@source.developers.google.com:2022/p/my-project/r/my-repository\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"source.developers.google.com\");",
            " \tcl_assert_equal_s(conndata.port, \"2022\");",
            " \tcl_assert_equal_s(conndata.path, \"/p/my-project/r/my-repository\");",
            " \tcl_assert_equal_s(conndata.username, \"my.email.address@gmail.com\");",
            " \tcl_assert_equal_s(conndata.password, \"seekret\");",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_parse__spaces_in_the_name(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse(&conndata, \"https://libgit2@dev.azure.com/libgit2/test/_git/spaces%20in%20the%20name\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"https\");",
            " \tcl_assert_equal_s(conndata.host, \"dev.azure.com\");",
            " \tcl_assert_equal_s(conndata.port, \"443\");",
            " \tcl_assert_equal_s(conndata.path, \"/libgit2/test/_git/spaces%20in%20the%20name\");",
            " \tcl_assert_equal_s(conndata.username, \"libgit2\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/util/url/scp.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/util/url/scp.c",
            "+++ /home/libgit2-1.9.1/tests/util/url/scp.c",
            "@@ -21,242 +21,275 @@",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__hostname_bracketed(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[example.com]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__hostname_root(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"example.com:/\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__hostname_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"git@example.com:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__hostname_user_bracketed(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[git@example.com]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__hostname_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[example.com:42]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"42\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            "+}",
            "+",
            "+void test_url_scp__hostname_specified_default_port(void)",
            "+{",
            "+\tcl_git_pass(git_net_url_parse_scp(&conndata, \"[example.com:22]:/resource\"));",
            "+\tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            "+\tcl_assert_equal_s(conndata.host, \"example.com\");",
            "+\tcl_assert_equal_s(conndata.port, \"22\");",
            "+\tcl_assert_equal_s(conndata.path, \"/resource\");",
            "+\tcl_assert_equal_p(conndata.username, NULL);",
            "+\tcl_assert_equal_p(conndata.password, NULL);",
            "+\tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__hostname_user_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[git@example.com:42]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"example.com\");",
            " \tcl_assert_equal_s(conndata.port, \"42\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__ipv4_trivial(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"192.168.99.88:/resource/a/b/c\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.99.88\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/a/b/c\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__ipv4_bracketed(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[192.168.99.88]:/resource/a/b/c\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.99.88\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/a/b/c\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__ipv4_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"git@192.168.99.88:/resource/a/b/c\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.99.88\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/a/b/c\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__ipv4_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[192.168.99.88:1111]:/resource/a/b/c\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.99.88\");",
            " \tcl_assert_equal_s(conndata.port, \"1111\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/a/b/c\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__ipv4_user_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[git@192.168.99.88:1111]:/resource/a/b/c\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"192.168.99.88\");",
            " \tcl_assert_equal_s(conndata.port, \"1111\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/a/b/c\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__ipv6_trivial(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[fe80::dcad:beff:fe00:0001]:/resource/foo\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"[fe80::dcad:beff:fe00:0001]\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/foo\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__ipv6_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"git@[fe80::dcad:beff:fe00:0001]:/resource/foo\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"[fe80::dcad:beff:fe00:0001]\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/foo\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__ipv6_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[[fe80::dcad:beff:fe00:0001]:99]:/resource/foo\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"[fe80::dcad:beff:fe00:0001]\");",
            " \tcl_assert_equal_s(conndata.port, \"99\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/foo\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__ipv6_user_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[git@[fe80::dcad:beff:fe00:0001]:99]:/resource/foo\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"[fe80::dcad:beff:fe00:0001]\");",
            " \tcl_assert_equal_s(conndata.port, \"99\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/foo\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 0);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__hexhost_and_port(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[fe:22]:/resource/foo\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"fe\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"/resource/foo\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 1);",
            " }",
            " ",
            " void test_url_scp__malformed_ipv6_one(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"fe80::dcad:beff:fe00:0001]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"fe80\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \":dcad:beff:fe00:0001]:/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__malformed_ipv6_two(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"[fe80::dcad:beff:fe00:0001]:42]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"[fe80::dcad:beff:fe00:0001]\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"42]:/resource\");",
            " \tcl_assert_equal_p(conndata.username, NULL);",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__malformed_ipv6_with_user(void)",
            " {",
            " \tcl_git_pass(git_net_url_parse_scp(&conndata, \"git@[fe80::dcad:beff:fe00:0001]:42]:/resource\"));",
            " \tcl_assert_equal_s(conndata.scheme, \"ssh\");",
            " \tcl_assert_equal_s(conndata.host, \"[fe80::dcad:beff:fe00:0001]\");",
            " \tcl_assert_equal_s(conndata.port, \"22\");",
            " \tcl_assert_equal_s(conndata.path, \"42]:/resource\");",
            " \tcl_assert_equal_s(conndata.username, \"git\");",
            " \tcl_assert_equal_p(conndata.password, NULL);",
            " \tcl_assert_equal_i(git_net_url_is_default_port(&conndata), 1);",
            "+\tcl_assert_equal_i(conndata.port_specified, 0);",
            " }",
            " ",
            " void test_url_scp__invalid_addresses(void)",
            " {",
            " \t/* Path is required */",
            " \tcl_git_fail_with(GIT_EINVALIDSPEC, git_net_url_parse_scp(&conndata,",
            " \t\t\"example.com\"));"
          ]
        },
        {
          "file": "/home/libgit2-1.9.1/tests/util/vector.c",
          "change": [
            "--- /home/libgit2-1.8.2-rc1/tests/util/vector.c",
            "+++ /home/libgit2-1.9.1/tests/util/vector.c",
            "@@ -8,30 +8,30 @@",
            " {",
            " \tgit_vector x;",
            " \tint i;",
            " \tcl_git_pass(git_vector_init(&x, 1, NULL));",
            " \tfor (i = 0; i < 10; ++i) {",
            " \t\tgit_vector_insert(&x, (void*) 0xabc);",
            " \t}",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " ",
            " /* don't read past array bounds on remove() */",
            " void test_vector__1(void)",
            " {",
            " \tgit_vector x;",
            " \t/* make initial capacity exact for our insertions. */",
            " \tcl_git_pass(git_vector_init(&x, 3, NULL));",
            " \tgit_vector_insert(&x, (void*) 0xabc);",
            " \tgit_vector_insert(&x, (void*) 0xdef);",
            " \tgit_vector_insert(&x, (void*) 0x123);",
            " ",
            " \tgit_vector_remove(&x, 0); /* used to read past array bounds. */",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " ",
            " static int test_cmp(const void *a, const void *b)",
            " {",
            " \treturn *(const int *)a - *(const int *)b;",
            " }",
            "@@ -55,15 +55,15 @@",
            " \tcl_git_pass(git_vector_insert(&x, ptrs[0]));",
            " \tcl_git_pass(git_vector_insert(&x, ptrs[1]));",
            " \tcl_assert(x.length == 5);",
            " ",
            " \tgit_vector_uniq(&x, NULL);",
            " \tcl_assert(x.length == 2);",
            " ",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " ",
            " \tgit__free(ptrs[0]);",
            " \tgit__free(ptrs[1]);",
            " }",
            " ",
            " ",
            " static int compare_them(const void *a, const void *b)",
            "@@ -87,15 +87,15 @@",
            " \t}",
            " ",
            " \tcl_assert(x.length == 10);",
            " \tfor (i = 0; i < 10; ++i) {",
            " \t\tcl_assert(git_vector_get(&x, i) == (void*)(i + 1));",
            " \t}",
            " ",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " /* insert_sorted with duplicates */",
            " void test_vector__4(void)",
            " {",
            " \tgit_vector x;",
            " \tintptr_t i;",
            "@@ -118,15 +118,15 @@",
            " \t}",
            " ",
            " \tcl_assert(x.length == 20);",
            " \tfor (i = 0; i < 20; ++i) {",
            " \t\tcl_assert(git_vector_get(&x, i) == (void*)(i / 2 + 1));",
            " \t}",
            " ",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " typedef struct {",
            " \tint content;",
            " \tint count;",
            " } my_struct;",
            " ",
            "@@ -185,15 +185,15 @@",
            " ",
            " \tfor (i = 0; i < 10; ++i) {",
            " \t\tcl_assert(((my_struct *)git_vector_get(&x, i))->content == i);",
            " \t\tgit__free(git_vector_get(&x, i));",
            " \t\t_struct_count--;",
            " \t}",
            " ",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " static int remove_ones(const git_vector *v, size_t idx, void *p)",
            " {",
            " \tGIT_UNUSED(p);",
            " \treturn (git_vector_get(v, idx) == (void *)0x001);",
            " }",
            "@@ -270,15 +270,15 @@",
            " \tgit_vector_insert(&x, (void*) 0x002);",
            " \tgit_vector_insert(&x, (void*) 0x003);",
            " ",
            " \tcl_assert(x.length == 4);",
            " \tgit_vector_remove_matching(&x, remove_ones, NULL);",
            " \tcl_assert(x.length == 4);",
            " ",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " static void assert_vector(git_vector *x, void *expected[], size_t len)",
            " {",
            " \tsize_t i;",
            " ",
            " \tcl_assert_equal_i(len, x->length);",
            "@@ -372,15 +372,15 @@",
            " ",
            " \tgit_vector_remove_range(&x, 1, 1);",
            " \tassert_vector(&x, expectedB, ARRAY_SIZE(expectedB));",
            " ",
            " \tgit_vector_remove_range(&x, 0, 1);",
            " \tassert_vector(&x, NULL, 0);",
            " ",
            "-\tgit_vector_free(&x);",
            "+\tgit_vector_dispose(&x);",
            " }",
            " ",
            " void test_vector__reverse(void)",
            " {",
            " \tgit_vector v = GIT_VECTOR_INIT;",
            " \tsize_t i;",
            " ",
            "@@ -403,15 +403,15 @@",
            " \t\tcl_git_pass(git_vector_insert(&v, in2[i]));",
            " ",
            " \tgit_vector_reverse(&v);",
            " ",
            " \tfor (i = 0; i < 5; i++)",
            " \t\tcl_assert_equal_p(out2[i], git_vector_get(&v, i));",
            " ",
            "-\tgit_vector_free(&v);",
            "+\tgit_vector_dispose(&v);",
            " }",
            " ",
            " void test_vector__dup_empty_vector(void)",
            " {",
            " \tgit_vector v = GIT_VECTOR_INIT;",
            " \tgit_vector dup = GIT_VECTOR_INIT;",
            " \tint dummy;",
            "@@ -422,9 +422,9 @@",
            " \tcl_assert_equal_i(0, dup._alloc_size);",
            " \tcl_assert_equal_i(0, dup.length);",
            " ",
            " \tcl_git_pass(git_vector_insert(&dup, &dummy));",
            " \tcl_assert_equal_i(8, dup._alloc_size);",
            " \tcl_assert_equal_i(1, dup.length);",
            " ",
            "-\tgit_vector_free(&dup);",
            "+\tgit_vector_dispose(&dup);",
            " }"
          ]
        }
      ]
    }
  }
}