{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:ac609fad-e977-42a0-9d63-3a82af13256a",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T12:42:46-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "a8edb89334cd021a",
      "type": "file",
      "name": "libplctag-2.6.7/"
    }
  },
  "components": [
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=fa2e67b8c20f75f3",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/download-artifact@v4?package-id=2ce9720038f244a5",
      "type": "library",
      "name": "actions/download-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/download-artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/download-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download-artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-artifact@v4?package-id=2350aa1781db3f76",
      "type": "library",
      "name": "actions/upload-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/ilammy/msvc-dev-cmd@v1?package-id=770980fe33b4e86e",
      "type": "library",
      "name": "ilammy/msvc-dev-cmd",
      "version": "v1",
      "cpe": "cpe:2.3:a:ilammy\\/msvc-dev-cmd:ilammy\\/msvc-dev-cmd:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/ilammy/msvc-dev-cmd@v1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc-dev-cmd:ilammy\\/msvc_dev_cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc_dev_cmd:ilammy\\/msvc-dev-cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc_dev_cmd:ilammy\\/msvc_dev_cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc-dev:ilammy\\/msvc-dev-cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc-dev:ilammy\\/msvc_dev_cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc_dev:ilammy\\/msvc-dev-cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc_dev:ilammy\\/msvc_dev_cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc:ilammy\\/msvc-dev-cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ilammy\\/msvc:ilammy\\/msvc_dev_cmd:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/softprops/action-gh-release@v2?package-id=4bb9607b02ac661f",
      "type": "library",
      "name": "softprops/action-gh-release",
      "version": "v2",
      "cpe": "cpe:2.3:a:softprops\\/action-gh-release:softprops\\/action-gh-release:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/softprops/action-gh-release@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action-gh-release:softprops\\/action_gh_release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action_gh_release:softprops\\/action-gh-release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action_gh_release:softprops\\/action_gh_release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action-gh:softprops\\/action-gh-release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action-gh:softprops\\/action_gh_release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action_gh:softprops\\/action-gh-release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action_gh:softprops\\/action_gh_release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action:softprops\\/action-gh-release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:softprops\\/action:softprops\\/action_gh_release:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "7561d461b00ff11d",
      "type": "file",
      "name": "/home/libplctag-2.6.7/.github/workflows/ci.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "5042180b16c6209e36abd07aa52a7dd90ab3c2a4"
        },
        {
          "alg": "SHA-256",
          "content": "0dd28792ef95b63aa37c47916b8f4776825a4213e20028d4b0664023acd95339"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/libplctag-2.6.2",
      "New file": [
        "/home/libplctag-2.6.7/src/examples/compat_utils.c",
        "/home/libplctag-2.6.7/src/examples/compat_utils.h",
        "/home/libplctag-2.6.7/src/examples/list_tags_omron_incomplete.c",
        "/home/libplctag-2.6.7/src/examples/stress_rc_mem.c",
        "/home/libplctag-2.6.7/src/examples/tag_rw_deprecated.c",
        "/home/libplctag-2.6.7/src/examples/test_array_notation.c",
        "/home/libplctag-2.6.7/src/examples/test_emulator_performance.c",
        "/home/libplctag-2.6.7/src/examples/test_event.c",
        "/home/libplctag-2.6.7/src/examples/test_indexed_tags.c",
        "/home/libplctag-2.6.7/src/examples/test_reconnect_after_outage.c",
        "/home/libplctag-2.6.7/src/examples/trigger_double_free.c",
        "/home/libplctag-2.6.7/src/libplctag/lib/init.c",
        "/home/libplctag-2.6.7/src/libplctag/lib/init.h",
        "/home/libplctag-2.6.7/src/libplctag/lib/lib.c",
        "/home/libplctag-2.6.7/src/libplctag/lib/libplctag.h",
        "/home/libplctag-2.6.7/src/libplctag/lib/tag.h",
        "/home/libplctag-2.6.7/src/libplctag/lib/version.c",
        "/home/libplctag-2.6.7/src/libplctag/lib/version.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/ab.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/ab_common.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/ab_common.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/cip.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/cip.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/defs.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_cip.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_cip.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_cip_special.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_cip_special.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_lgx_pccc.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_lgx_pccc.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_plc5_dhp.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_plc5_dhp.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_plc5_pccc.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_plc5_pccc.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_slc_dhp.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_slc_dhp.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_slc_pccc.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/eip_slc_pccc.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/error_codes.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/error_codes.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/pccc.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/pccc.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/session.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/session.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/ab/tag.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/mb/modbus.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/mb/modbus.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/cip.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/cip.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/conn.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/conn.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/defs.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron_common.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron_common.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron_raw_tag.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron_raw_tag.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron_standard_tag.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/omron_standard_tag.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/omron/tag.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/system/system.c",
        "/home/libplctag-2.6.7/src/libplctag/protocols/system/system.h",
        "/home/libplctag-2.6.7/src/libplctag/protocols/system/tag.h",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/memory.c",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/memory.h",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/mutex.c",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/mutex.h",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/result.h",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/thread.c",
        "/home/libplctag-2.6.7/src/tests/ab_server/src/thread.h",
        "/home/libplctag-2.6.7/src/tests/modbus_server/modbus_server.c",
        "/home/libplctag-2.6.7/src/utils/atomic_utils.c",
        "/home/libplctag-2.6.7/src/utils/atomic_utils.h",
        "/home/libplctag-2.6.7/src/utils/attr.c",
        "/home/libplctag-2.6.7/src/utils/attr.h",
        "/home/libplctag-2.6.7/src/utils/byteorder.h",
        "/home/libplctag-2.6.7/src/utils/debug.c",
        "/home/libplctag-2.6.7/src/utils/debug.h",
        "/home/libplctag-2.6.7/src/utils/hash.c",
        "/home/libplctag-2.6.7/src/utils/hash.h",
        "/home/libplctag-2.6.7/src/utils/hashtable.c",
        "/home/libplctag-2.6.7/src/utils/hashtable.h",
        "/home/libplctag-2.6.7/src/utils/macros.h",
        "/home/libplctag-2.6.7/src/utils/random_utils.c",
        "/home/libplctag-2.6.7/src/utils/random_utils.h",
        "/home/libplctag-2.6.7/src/utils/rc.c",
        "/home/libplctag-2.6.7/src/utils/rc.h",
        "/home/libplctag-2.6.7/src/utils/vector.c",
        "/home/libplctag-2.6.7/src/utils/vector.h"
      ],
      "Deleted file": [
        "/home/libplctag-2.6.2/src/examples/list_tags_omron.c",
        "/home/libplctag-2.6.2/src/examples/tag_rw.c",
        "/home/libplctag-2.6.2/src/examples/test_event_windows.c",
        "/home/libplctag-2.6.2/src/examples/test_many_tag_perf.c",
        "/home/libplctag-2.6.2/src/examples/utils.h",
        "/home/libplctag-2.6.2/src/examples/utils_posix.c",
        "/home/libplctag-2.6.2/src/examples/utils_windows.c",
        "/home/libplctag-2.6.2/src/lib/init.c",
        "/home/libplctag-2.6.2/src/lib/init.h",
        "/home/libplctag-2.6.2/src/lib/lib.c",
        "/home/libplctag-2.6.2/src/lib/libplctag.h",
        "/home/libplctag-2.6.2/src/lib/tag.h",
        "/home/libplctag-2.6.2/src/lib/version.c",
        "/home/libplctag-2.6.2/src/protocols/ab/ab.h",
        "/home/libplctag-2.6.2/src/protocols/ab/ab_common.c",
        "/home/libplctag-2.6.2/src/protocols/ab/ab_common.h",
        "/home/libplctag-2.6.2/src/protocols/ab/cip.c",
        "/home/libplctag-2.6.2/src/protocols/ab/cip.h",
        "/home/libplctag-2.6.2/src/protocols/ab/defs.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_cip.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_cip.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_cip_special.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_cip_special.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_lgx_pccc.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_lgx_pccc.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_plc5_dhp.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_plc5_dhp.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_plc5_pccc.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_plc5_pccc.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_slc_dhp.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_slc_dhp.h",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_slc_pccc.c",
        "/home/libplctag-2.6.2/src/protocols/ab/eip_slc_pccc.h",
        "/home/libplctag-2.6.2/src/protocols/ab/error_codes.c",
        "/home/libplctag-2.6.2/src/protocols/ab/error_codes.h",
        "/home/libplctag-2.6.2/src/protocols/ab/pccc.c",
        "/home/libplctag-2.6.2/src/protocols/ab/pccc.h",
        "/home/libplctag-2.6.2/src/protocols/ab/session.c",
        "/home/libplctag-2.6.2/src/protocols/ab/session.h",
        "/home/libplctag-2.6.2/src/protocols/ab/tag.h",
        "/home/libplctag-2.6.2/src/protocols/mb/modbus.c",
        "/home/libplctag-2.6.2/src/protocols/mb/modbus.h",
        "/home/libplctag-2.6.2/src/protocols/omron/cip.c",
        "/home/libplctag-2.6.2/src/protocols/omron/cip.h",
        "/home/libplctag-2.6.2/src/protocols/omron/conn.c",
        "/home/libplctag-2.6.2/src/protocols/omron/conn.h",
        "/home/libplctag-2.6.2/src/protocols/omron/defs.h",
        "/home/libplctag-2.6.2/src/protocols/omron/omron.h",
        "/home/libplctag-2.6.2/src/protocols/omron/omron_common.c",
        "/home/libplctag-2.6.2/src/protocols/omron/omron_common.h",
        "/home/libplctag-2.6.2/src/protocols/omron/omron_raw_tag.c",
        "/home/libplctag-2.6.2/src/protocols/omron/omron_raw_tag.h",
        "/home/libplctag-2.6.2/src/protocols/omron/omron_standard_tag.c",
        "/home/libplctag-2.6.2/src/protocols/omron/omron_standard_tag.h",
        "/home/libplctag-2.6.2/src/protocols/omron/tag.h",
        "/home/libplctag-2.6.2/src/protocols/system/system.c",
        "/home/libplctag-2.6.2/src/protocols/system/system.h",
        "/home/libplctag-2.6.2/src/protocols/system/tag.h",
        "/home/libplctag-2.6.2/src/tests/modbus_server.py",
        "/home/libplctag-2.6.2/src/util/atomic_int.c",
        "/home/libplctag-2.6.2/src/util/atomic_int.h",
        "/home/libplctag-2.6.2/src/util/attr.c",
        "/home/libplctag-2.6.2/src/util/attr.h",
        "/home/libplctag-2.6.2/src/util/byteorder.h",
        "/home/libplctag-2.6.2/src/util/debug.c",
        "/home/libplctag-2.6.2/src/util/debug.h",
        "/home/libplctag-2.6.2/src/util/hash.c",
        "/home/libplctag-2.6.2/src/util/hash.h",
        "/home/libplctag-2.6.2/src/util/hashtable.c",
        "/home/libplctag-2.6.2/src/util/hashtable.h",
        "/home/libplctag-2.6.2/src/util/macros.h",
        "/home/libplctag-2.6.2/src/util/rc.c",
        "/home/libplctag-2.6.2/src/util/rc.h",
        "/home/libplctag-2.6.2/src/util/vector.c",
        "/home/libplctag-2.6.2/src/util/vector.h"
      ],
      "Modified file": [
        {
          "file": "/home/libplctag-2.6.7/src/contrib/cli/cli.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/contrib/cli/cli.c",
            "+++ /home/libplctag-2.6.7/src/contrib/cli/cli.c",
            "@@ -1,359 +1,332 @@",
            "-#include <stdio.h>",
            "-#include <stdlib.h>",
            "-#include <stdbool.h>",
            "-#include <stdint.h>",
            "-#include <ctype.h>",
            "-#include <inttypes.h>",
            "-#include \"../lib/libplctag.h\"",
            " #include \"./cli.h\"",
            "-#include \"./getline.h\"",
            " #include \"../examples/utils.h\"",
            " #include \"../util/debug.h\"",
            "+#include \"./getline.h\"",
            "+#include <ctype.h>",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdbool.h>",
            "+#include <stdint.h>",
            "+#include <stdio.h>",
            "+#include <stdlib.h>",
            " ",
            " /* globals here */",
            " struct tags *tags = NULL;",
            " cli_request_t cli_request = {",
            "-    \"ab_eip\",",
            "-    \"127.0.0.1\",",
            "-    \"1,0\",",
            "-    \"controllogix\",",
            "-    READ,",
            "-    500,",
            "-    1, // DEBUG_ERROR",
            "+    \"ab_eip\", \"127.0.0.1\", \"1,0\", \"controllogix\", READ, 500,",
            "+    1,  // DEBUG_ERROR",
            "     \"\",",
            "-    false // offline",
            "+    false  // offline",
            " };",
            " ",
            "-void usage(void)",
            "-{",
            "+void usage(void) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"Usage:\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\tLIBPLCTAG CLI.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\tThis is a command-line interface to access tags/registers, in PLCs supported by libplctag.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\tcli {--read | --write | --watch} {-protocol} {-ip} {-path} {-plc}\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t\\t[-debug] [-interval] [-attributes] [-offline]\\n\");",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\tCLI Action (Required):\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\t--read\\t\\t- Perform a one-shot READ operation.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t--write\\t\\t- Perform a one-shot WRITE operation.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t--watch\\t\\t- Perform a continuous WATCH operation at the specified interval.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-h | --help\\t- Prints the Usage details.\\n\");",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\tLIBPLCTAG Parameters (Required):\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\t-protocol\\t- type of plc protocol. (default: ab_eip)\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-ip\\t\\t- network address for the host PLC. (default: 127.0.0.1)\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-path\\t\\t- routing path for the Tags. (default: 1,0)\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-plc\\t\\t- type of the PLC. (default: controllogix)\\n\");",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\tLIBPLCTAG Parameters (Optional):\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\n\\t-debug\\t\\t- logging output level. (default: 1)\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-interval\\t- interval in ms for WATCH operation. (default: 500)\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-attributes\\t- additional attributes. (default: '')\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stdout, \"\\t-offline\\t- operation mode. (default: false)\\n\");",
            " ",
            "     fflush(stdout);",
            " }",
            " ",
            "-int parse_args(int argc, char *argv[])",
            "-{",
            "-    if (argc < 2) {",
            "+int parse_args(int argc, char *argv[]) {",
            "+    if(argc < 2) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"ERROR: invalid number of arguments.\\n\");",
            "         fflush(stderr);",
            "         return -1;",
            "     }",
            " ",
            "     int i = 0;",
            " ",
            "     char *operation = argv[++i];",
            "-    if (!strcmp(operation, \"--read\")) {",
            "+    if(!strcmp(operation, \"--read\")) {",
            "         cli_request.operation = READ;",
            "-    } else if (!strcmp(operation, \"--write\")) {",
            "+    } else if(!strcmp(operation, \"--write\")) {",
            "         cli_request.operation = WRITE;",
            "-    } else if (!strcmp(operation, \"--watch\")) {",
            "-         cli_request.operation = WATCH;",
            "-    } else if (!strcmp(operation, \"--help\") || !strcmp(operation, \"-h\")) {",
            "+    } else if(!strcmp(operation, \"--watch\")) {",
            "+        cli_request.operation = WATCH;",
            "+    } else if(!strcmp(operation, \"--help\") || !strcmp(operation, \"-h\")) {",
            "         usage();",
            "         exit(0);",
            "     } else {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"ERROR: invalid PLC operation.\\n\");",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"INFO: Use one of --read, --write, --watch.\\n\");",
            "         fflush(stderr);",
            "         return -1;",
            "     }",
            " ",
            "     char *param;",
            "     char *val;",
            "-    while (++i < argc) {",
            "+    while(++i < argc) {",
            "         param = strtok(argv[i], \"=\");",
            "         val = strtok(NULL, \"\");",
            " ",
            "-        if (!strcmp(param, \"-protocol\")) {",
            "+        if(!strcmp(param, \"-protocol\")) {",
            "             cli_request.protocol = val;",
            "-            if (!strcmp(val, \"modbus_tcp\")) {",
            "+            if(!strcmp(val, \"modbus_tcp\")) {",
            "                 cli_request.plc = NULL;",
            "                 cli_request.path = \"0\";",
            "             }",
            "-        } else if (!strcmp(param, \"-ip\")) {",
            "+        } else if(!strcmp(param, \"-ip\")) {",
            "             cli_request.ip = val;",
            "-        } else if (!strcmp(param, \"-path\")) {",
            "+        } else if(!strcmp(param, \"-path\")) {",
            "             cli_request.path = val;",
            "-        } else if (!strcmp(param, \"-plc\")) {",
            "+        } else if(!strcmp(param, \"-plc\")) {",
            "             cli_request.plc = val;",
            "-        } else if (!strcmp(param, \"-debug\")) {",
            "+        } else if(!strcmp(param, \"-debug\")) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(val, \"%d\", &cli_request.debug_level);",
            "-        } else if (!strcmp(param, \"-interval\")) {",
            "+        } else if(!strcmp(param, \"-interval\")) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(val, \"%d\", &cli_request.interval);",
            "-        } else if (!strcmp(param, \"-attributes\")) {",
            "+        } else if(!strcmp(param, \"-attributes\")) {",
            "             cli_request.attributes = val;",
            "-        } else if (!strcmp(param, \"-offline\")) {",
            "-            if (!strcmp(val, \"true\")) {",
            "+        } else if(!strcmp(param, \"-offline\")) {",
            "+            if(!strcmp(val, \"true\")) {",
            "                 cli_request.offline = true;",
            "-            } else if (!strcmp(val, \"false\")) {",
            "+            } else if(!strcmp(val, \"false\")) {",
            "                 cli_request.offline = false;",
            "             } else {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"ERROR: invalid parameter value for offline.\");",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"INFO: Supported values 'true' or 'false'.\");",
            "                 fflush(stderr);",
            "             }",
            "         } else {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"ERROR: invalid PLC parameter: %s.\\n\", param);",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"INFO: Supported params -protocol, -ip, -path, -plc, -debug, -interval, -attributes, -offline.\\n\");",
            "             fflush(stderr);",
            "             return -1;",
            "         }",
            "     }",
            " ",
            "     return 0;",
            " }",
            " ",
            "-void print_request()",
            "-{",
            "+void print_request(void) {",
            "     pdebug(DEBUG_INFO, \"Running with params:\");",
            "     pdebug(DEBUG_INFO, \"Protocol: %s\", cli_request.protocol);",
            "     pdebug(DEBUG_INFO, \"IP: %s\", cli_request.ip);",
            "     pdebug(DEBUG_INFO, \"Path: %s\", cli_request.path);",
            "     pdebug(DEBUG_INFO, \"PLC: %s\", cli_request.plc);",
            "-    switch (cli_request.operation) {",
            "-    case READ:",
            "-        pdebug(DEBUG_INFO, \"Operation: READ.\");",
            "-        break;",
            "-    case WRITE:",
            "-        pdebug(DEBUG_INFO, \"Operation: WRITE.\");",
            "-        break;",
            "-    case WATCH:",
            "-        pdebug(DEBUG_INFO, \"Operation: WATCH.\");",
            "-        break;",
            "-    default:",
            "-        pdebug(DEBUG_INFO, \"Operation: INVALID.\");",
            "-        break;",
            "+    switch(cli_request.operation) {",
            "+        case READ: pdebug(DEBUG_INFO, \"Operation: READ.\"); break;",
            "+        case WRITE: pdebug(DEBUG_INFO, \"Operation: WRITE.\"); break;",
            "+        case WATCH: pdebug(DEBUG_INFO, \"Operation: WATCH.\"); break;",
            "+        default: pdebug(DEBUG_INFO, \"Operation: INVALID.\"); break;",
            "     }",
            "     pdebug(DEBUG_INFO, \"Interval: %d\", cli_request.interval);",
            "     pdebug(DEBUG_INFO, \"Debug Level: %d\", cli_request.debug_level);",
            "     pdebug(DEBUG_INFO, \"Additional Attributes: %s\", cli_request.attributes);",
            "     pdebug(DEBUG_INFO, \"Offline: %s\", btoa(cli_request.offline));",
            " }",
            " ",
            "-int is_comment(const char *line)",
            "-{",
            "+int is_comment(const char *line) {",
            "     int i = 0;",
            " ",
            "     /* scan past the first whitespace */",
            "-    for(i=0; line[i] && isspace(line[i]); i++);",
            "+    for(i = 0; line[i] && isspace(line[i]); i++);",
            " ",
            "     return (line[i] == '#') ? 1 : 0;",
            " }",
            " ",
            "-void trim_line(char *line)",
            "-{",
            "+void trim_line(char *line) {",
            "     int len = 0;",
            " ",
            "-    if(!line || strlen(line) == 0) {",
            "-        return;",
            "-    }",
            "+    if(!line || strlen(line) == 0) { return; }",
            " ",
            "     len = (int)strlen(line);",
            " ",
            "-    while(len>0 && line[len - 1] == '\\n') {",
            "+    while(len > 0 && line[len - 1] == '\\n') {",
            "         line[len - 1] = 0;",
            "         len--;",
            "     }",
            " }",
            " ",
            "-tag_line_parts_t split_string(const char *str, const char *sep)",
            "-{",
            "-    int sub_str_count=0;",
            "+tag_line_parts_t split_string(const char *str, const char *sep) {",
            "+    int sub_str_count = 0;",
            "     int size = 0;",
            "     const char *sub;",
            "     const char *tmp;",
            "     char **res = NULL;",
            "     tag_line_parts_t tag_line_parts_t = {NULL, -1};",
            " ",
            "     /* first, count the sub strings */",
            "     tmp = str;",
            "-    sub = strstr(tmp,sep);",
            "+    sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front, ignore that. */",
            "-        if(sub != tmp) {",
            "-            sub_str_count++;",
            "-        }",
            "+        if(sub != tmp) { sub_str_count++; }",
            " ",
            "         tmp = sub + strlen(sep);",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "-    if(tmp && *tmp && (!sub || !*sub)) {",
            "-        sub_str_count++;",
            "-    }",
            "+    if(tmp && *tmp && (!sub || !*sub)) { sub_str_count++; }",
            " ",
            "     tag_line_parts_t.num_parts = sub_str_count;",
            " ",
            "     /* calculate total size for string plus pointers */",
            "-    size = (int)(sizeof(char *)*((size_t)sub_str_count+1))+(int)strlen(str)+1;",
            "+    size = (int)(sizeof(char *) * ((size_t)sub_str_count + 1)) + (int)strlen(str) + 1;",
            " ",
            "     /* allocate enough memory */",
            "     res = malloc((size_t)size);",
            "-    if(!res) {",
            "-        return tag_line_parts_t;",
            "-    }",
            "+    if(!res) { return tag_line_parts_t; }",
            " ",
            "     /* calculate the beginning of the string */",
            "-    tmp = (char *)res + sizeof(char *) * (size_t)(sub_str_count+1);",
            "+    tmp = (char *)res + sizeof(char *) * (size_t)(sub_str_count + 1);",
            " ",
            "     /* copy the string into the new buffer past the first part with the array of char pointers. */",
            "-    strncpy((char *)tmp, str, (size_t)(size - ((char*)tmp - (char*)res)));",
            "+    // NOLINTNEXTLINE",
            "+    strncpy((char *)tmp, str, (size_t)(size - ((char *)tmp - (char *)res)));",
            " ",
            "     /* set up the pointers */",
            "-    sub_str_count=0;",
            "-    sub = strstr(tmp,sep);",
            "+    sub_str_count = 0;",
            "+    sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front, ignore that. */",
            "         if(sub != tmp) {",
            "             /* store the pointer */",
            "             res[sub_str_count] = (char *)tmp;",
            " ",
            "             sub_str_count++;",
            "         }",
            " ",
            "         /* zero out the separator chars */",
            "-        memset((char*)sub, 0, strlen(sep));",
            "+        // NOLINTNEXTLINE",
            "+        memset((char *)sub, 0, strlen(sep));",
            " ",
            "         /* point past the separator (now zero) */",
            "         tmp = sub + strlen(sep);",
            " ",
            "         /* find the next separator */",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "     /* if there is a chunk at the end, store it. */",
            "-    if(tmp && *tmp && (!sub || !*sub)) {",
            "-        res[sub_str_count] = (char*)tmp;",
            "-    }",
            "+    if(tmp && *tmp && (!sub || !*sub)) { res[sub_str_count] = (char *)tmp; }",
            " ",
            "     tag_line_parts_t.parts = res;",
            " ",
            "     return tag_line_parts_t;",
            " }",
            " ",
            " int validate_line(tag_line_parts_t tag_line_parts) {",
            "-    char req_params[4][10] =",
            "-    {",
            "-        \"key\",",
            "-        \"type\",",
            "-        \"path\",",
            "-        \"value\"",
            "-    };",
            "+    char req_params[4][10] = {\"key\", \"type\", \"path\", \"value\"};",
            " ",
            "     int required = 3;",
            "-    if (cli_request.operation == WRITE) required = 4;",
            "+    if(cli_request.operation == WRITE) { required = 4; }",
            " ",
            "     bool found = false;",
            "     int j;",
            "     char *part;",
            "-    for(int i=0; i < required; i++) {",
            "+    for(int i = 0; i < required; i++) {",
            "         j = 0;",
            "         while(j < tag_line_parts.num_parts) {",
            "             part = strdup(tag_line_parts.parts[j]);",
            "-            if (!strcmp(req_params[i], strtok(part, \"=\"))) {",
            "+            if(!strcmp(req_params[i], strtok(part, \"=\"))) {",
            "                 found = true;",
            "                 break;",
            "             }",
            "             ++j;",
            "         }",
            "-        if (!found) {",
            "+        if(!found) {",
            "             pdebug(DEBUG_ERROR, \"Line missing: %s\", req_params[i]);",
            "             return -1;",
            "         }",
            "         found = false;",
            "     }",
            " ",
            "     free(part);",
            "     return 0;",
            " }",
            " ",
            " void print_tag(tag_t *tag) {",
            "     pdebug(DEBUG_INFO, \"Tag created:\");",
            "     pdebug(DEBUG_INFO, \"Key: %s\", tag->key);",
            "-    switch (tag->type) {",
            "-    case t_UINT64:",
            "-        pdebug(DEBUG_INFO, \"Type: uint64.\");",
            "-        break;",
            "-    case t_INT64:",
            "-        pdebug(DEBUG_INFO, \"Type: int64.\");",
            "-        break;",
            "-    case t_UINT32:",
            "-        pdebug(DEBUG_INFO, \"Type: uint32.\");",
            "-        break;",
            "-    case t_INT32:",
            "-        pdebug(DEBUG_INFO, \"Type: int32.\");",
            "-        break;",
            "-    case t_UINT16:",
            "-        pdebug(DEBUG_INFO, \"Type: uint16.\");",
            "-        break;",
            "-    case t_INT16:",
            "-        pdebug(DEBUG_INFO, \"Type: int16.\");",
            "-        break;",
            "-    case t_UINT8:",
            "-        pdebug(DEBUG_INFO, \"Type: uint8.\");",
            "-        break;",
            "-    case t_INT8:",
            "-        pdebug(DEBUG_INFO, \"Type: int8.\");",
            "-        break;",
            "-    case t_FLOAT64:",
            "-        pdebug(DEBUG_INFO, \"Type: float64.\");",
            "-        break;",
            "-    case t_FLOAT32:",
            "-        pdebug(DEBUG_INFO, \"Type: float32.\");",
            "-        break;",
            "-    case t_BOOL:",
            "-        pdebug(DEBUG_INFO, \"Type: bool.\");",
            "-        break;",
            "-    default:",
            "-        pdebug(DEBUG_INFO, \"Type: INVALID.\");",
            "-        break;",
            "+    switch(tag->type) {",
            "+        case t_UINT64: pdebug(DEBUG_INFO, \"Type: uint64.\"); break;",
            "+        case t_INT64: pdebug(DEBUG_INFO, \"Type: int64.\"); break;",
            "+        case t_UINT32: pdebug(DEBUG_INFO, \"Type: uint32.\"); break;",
            "+        case t_INT32: pdebug(DEBUG_INFO, \"Type: int32.\"); break;",
            "+        case t_UINT16: pdebug(DEBUG_INFO, \"Type: uint16.\"); break;",
            "+        case t_INT16: pdebug(DEBUG_INFO, \"Type: int16.\"); break;",
            "+        case t_UINT8: pdebug(DEBUG_INFO, \"Type: uint8.\"); break;",
            "+        case t_INT8: pdebug(DEBUG_INFO, \"Type: int8.\"); break;",
            "+        case t_FLOAT64: pdebug(DEBUG_INFO, \"Type: float64.\"); break;",
            "+        case t_FLOAT32: pdebug(DEBUG_INFO, \"Type: float32.\"); break;",
            "+        case t_BOOL: pdebug(DEBUG_INFO, \"Type: bool.\"); break;",
            "+        default: pdebug(DEBUG_INFO, \"Type: INVALID.\"); break;",
            "     }",
            "     pdebug(DEBUG_INFO, \"Path: %s\", tag->path);",
            "     pdebug(DEBUG_INFO, \"Bit: %d\", tag->bit);",
            "     pdebug(DEBUG_INFO, \"Offset: %d\", tag->offset);",
            "     pdebug(DEBUG_INFO, \"Watch: %s\", btoa(tag->watch));",
            " }",
            " ",
            "-int process_line(const char *line, tag_t *tag)",
            "-{",
            "+int process_line(const char *line, tag_t *tag) {",
            "     tag_line_parts_t tag_line_parts;",
            " ",
            "+    if(line == NULL) { return -1; }",
            "+",
            "     tag_line_parts = split_string(line, \",\");",
            "     if(tag_line_parts.num_parts < 0) {",
            "         pdebug(DEBUG_ERROR, \"Splitting string failed for string %s!\", line);",
            "         return -1;",
            "     }",
            " ",
            "     /* check if the relevant parameters are there or not */",
            "-    if (validate_line(tag_line_parts) != 0) {",
            "+    if(validate_line(tag_line_parts) != 0) {",
            "         pdebug(DEBUG_ERROR, \"Line does not contain enough parts. Line: %s\", line);",
            "         return -1;",
            "     }",
            " ",
            "     pdebug(DEBUG_INFO, \"Line validated!\");",
            " ",
            "     /* setup all the associated tag values here. */",
            "@@ -368,96 +341,108 @@",
            "     char *type = NULL;",
            "     char *write_val = NULL;",
            " ",
            "     int i = 0;",
            "     char *part = NULL;",
            "     char *param = NULL;",
            "     char *val = NULL;",
            "-    while (i < tag_line_parts.num_parts) {",
            "+    while(i < tag_line_parts.num_parts) {",
            "         part = strdup(tag_line_parts.parts[i]);",
            "         pdebug(DEBUG_INFO, \"Part: %s\", part);",
            "         param = strtok(part, \"=\");",
            "         val = strtok(NULL, \"\");",
            "         pdebug(DEBUG_INFO, \"[Param, Value]: [%s, %s]\", param, val);",
            " ",
            "         if(!strcmp(\"key\", param)) {",
            "             tag->key = strdup(val);",
            "-        } else if (!strcmp(\"type\", param)) {",
            "+        } else if(!strcmp(\"type\", param)) {",
            "             type = val;",
            "-        } else if (!strcmp(\"value\", param)) {",
            "+        } else if(!strcmp(\"value\", param)) {",
            "             write_val = val;",
            "-        } else if (!strcmp(\"bit\", param)) {",
            "+        } else if(!strcmp(\"bit\", param)) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(val, \"%d\", &tag->bit);",
            "-        } else if (!strcmp(\"offset\", param)) {",
            "+        } else if(!strcmp(\"offset\", param)) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(val, \"%d\", &tag->offset);",
            "-        } else if (!strcmp(\"path\", param)) {",
            "+        } else if(!strcmp(\"path\", param)) {",
            "             tag->path = strdup(val);",
            "         } else {",
            "             pdebug(DEBUG_ERROR, \"Unknown param %s!\", param);",
            "             return -1;",
            "         }",
            " ",
            "         ++i;",
            "     }",
            " ",
            "     pdebug(DEBUG_INFO, \"Parsing tag type now...\");",
            "     if(!strcmp(\"uint64\", type)) {",
            "         tag->type = t_UINT64;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNu64, &tag->write_val.UINT64_val);",
            "         }",
            "     } else if(!strcmp(\"int64\", type)) {",
            "         tag->type = t_INT64;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNi64, &tag->write_val.INT64_val);",
            "         }",
            "     } else if(!strcmp(\"uint32\", type)) {",
            "         tag->type = t_UINT32;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNu32, &tag->write_val.UINT32_val);",
            "         }",
            "     } else if(!strcmp(\"int32\", type)) {",
            "         tag->type = t_INT32;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNi32, &tag->write_val.INT32_val);",
            "         }",
            "     } else if(!strcmp(\"uint16\", type)) {",
            "         tag->type = t_UINT16;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNu16, &tag->write_val.UINT16_val);",
            "         }",
            "     } else if(!strcmp(\"int16\", type)) {",
            "         tag->type = t_INT16;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNi16, &tag->write_val.INT16_val);",
            "         }",
            "     } else if(!strcmp(\"uint8\", type)) {",
            "         tag->type = t_UINT8;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNu8, &tag->write_val.UINT8_val);",
            "         }",
            "     } else if(!strcmp(\"int8\", type)) {",
            "         tag->type = t_INT8;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%\" SCNi8, &tag->write_val.INT8_val);",
            "         }",
            "     } else if(!strcmp(\"float64\", type)) {",
            "         tag->type = t_FLOAT64;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%lf\", &tag->write_val.FLOAT64_val);",
            "         }",
            "     } else if(!strcmp(\"float32\", type)) {",
            "         tag->type = t_FLOAT32;",
            "-        if (cli_request.operation == WRITE) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            // NOLINTNEXTLINE",
            "             sscanf(write_val, \"%f\", &tag->write_val.FLOAT32_val);",
            "         }",
            "     } else if(!strcmp(\"bool\", type)) {",
            "         tag->type = t_BOOL;",
            "-        if (cli_request.operation == WRITE) {",
            "-            if (!strcmp(\"true\", write_val)) {",
            "+        if(cli_request.operation == WRITE) {",
            "+            if(!strcmp(\"true\", write_val)) {",
            "                 tag->write_val.BOOL_val = true;",
            "             } else {",
            "                 tag->write_val.BOOL_val = false;",
            "             }",
            "         }",
            "     } else {",
            "         pdebug(DEBUG_ERROR, \"Unknown data type for %s!\", type);",
            "@@ -467,26 +452,25 @@",
            "     free(tag_line_parts.parts);",
            "     print_tag(tag);",
            "     pdebug(DEBUG_INFO, \"Line processed!\");",
            " ",
            "     return 0;",
            " }",
            " ",
            "-void add_tag(int tag_handle, tag_t tag)",
            "-{",
            "+void add_tag(int tag_handle, tag_t tag) {",
            "     struct tags *t;",
            " ",
            "     t = malloc(sizeof(struct tags));",
            "     t->tag_handle = tag_handle;",
            "     t->tag = tag;",
            "+    // NOLINTNEXTLINE",
            "     HASH_ADD_INT(tags, tag_handle, t);",
            " }",
            " ",
            "-int check_tags()",
            "-{",
            "+int check_tags(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     struct tags *t;",
            " ",
            "     for(t = tags; t != NULL; t = t->hh.next) {",
            "         rc = plc_tag_status(t->tag_handle);",
            " ",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "@@ -494,55 +478,48 @@",
            "             return rc;",
            "         }",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            "-int process_tags()",
            "-{",
            "+int process_tags(void) {",
            "     char *line = NULL;",
            "     size_t line_len = 0;",
            "-    char *tag_path = (char *) malloc(1024);",
            "+    char *tag_path = (char *)malloc(1024);",
            " ",
            "-    while (getline(&line, &line_len, stdin) > 0) {",
            "-        if (is_comment(line)) {",
            "-            continue;",
            "-        }",
            "+    while(getline(&line, &line_len, stdin) > 0) {",
            "+        if(is_comment(line)) { continue; }",
            " ",
            "-        if (!strcmp(line, \"break\\n\")) {",
            "-            break;",
            "-        }",
            "+        if(!strcmp(line, \"break\\n\")) { break; }",
            " ",
            "         tag_t tag;",
            "         trim_line(line);",
            "         pdebug(DEBUG_INFO, \"Trimmed Line: %s\", line);",
            "         /* ignore lines that can't be processed */",
            "-        if (process_line(line, &tag) == -1) {",
            "-            continue;",
            "-        }",
            "+        if(process_line(line, &tag) == -1) { continue; }",
            " ",
            "-        switch (cli_request.operation) {",
            "-        case WATCH:",
            "-            sprintf(tag_path, TAG_PATH_AUTO_READ_SYNC, cli_request.protocol,",
            "-                cli_request.ip, cli_request.path, cli_request.plc,",
            "-                cli_request.debug_level, cli_request.interval, tag.path,",
            "-                cli_request.attributes);",
            "-            break;",
            "-        default:",
            "-            sprintf(tag_path, TAG_PATH, cli_request.protocol,",
            "-                cli_request.ip, cli_request.path, cli_request.plc,",
            "-                cli_request.debug_level, tag.path, cli_request.attributes);",
            "-            break;",
            "+        switch(cli_request.operation) {",
            "+            case WATCH:",
            "+                // NOLINTNEXTLINE",
            "+                snprintf(tag_path, 1024, TAG_PATH_AUTO_READ_SYNC, cli_request.protocol, cli_request.ip, cli_request.path,",
            "+                         cli_request.plc, cli_request.debug_level, cli_request.interval, tag.path, cli_request.attributes);",
            "+                break;",
            "+            default:",
            "+                // NOLINTNEXTLINE",
            "+                snprintf(tag_path, 1024, TAG_PATH, cli_request.protocol, cli_request.ip, cli_request.path, cli_request.plc,",
            "+                         cli_request.debug_level, tag.path, cli_request.attributes);",
            "+                break;",
            "         }",
            " ",
            "         pdebug(DEBUG_INFO, \"%s\", tag_path);",
            "         int tag_handle = plc_tag_create(tag_path, 0);",
            "-        if (tag_handle < 0) {",
            "-            pdebug(DEBUG_ERROR, \"Error, %s, creating tag %s with string %s!\", plc_tag_decode_error(tag_handle), tag.key, tag_path);",
            "+        if(tag_handle < 0) {",
            "+            pdebug(DEBUG_ERROR, \"Error, %s, creating tag %s with string %s!\", plc_tag_decode_error(tag_handle), tag.key,",
            "+                   tag_path);",
            "             free(tag_path);",
            "             free(line);",
            "             return -1;",
            "         }",
            " ",
            "         add_tag(tag_handle, tag);",
            "     }",
            "@@ -550,176 +527,196 @@",
            "     free(tag_path);",
            "     free(line);",
            "     pdebug(DEBUG_INFO, \"DONE processing tags.\");",
            "     return 0;",
            " }",
            " ",
            " int get_tag(int32_t tag_handle, tag_t *tag) {",
            "-    switch (tag->type) {",
            "-    case t_UINT64:",
            "-        tag->val.UINT64_val = plc_tag_get_uint64(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.UINT64_val = tag->val.UINT64_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu64\"}\\n\", tag->key, tag->val.UINT64_val);",
            "-            fflush(stdout);",
            "+    switch(tag->type) {",
            "+        case t_UINT64:",
            "+            tag->val.UINT64_val = plc_tag_get_uint64(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.UINT64_val = tag->val.UINT64_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu64 \"}\\n\", tag->key, tag->val.UINT64_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.UINT64_val != tag->last_val.UINT64_val) {",
            "+                tag->last_val.UINT64_val = tag->val.UINT64_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu64 \"}\\n\", tag->key, tag->val.UINT64_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.UINT64_val != tag->last_val.UINT64_val) {",
            "-            tag->last_val.UINT64_val = tag->val.UINT64_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu64\"}\\n\", tag->key, tag->val.UINT64_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_INT64:",
            "-        tag->val.INT64_val = plc_tag_get_int64(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.INT64_val = tag->val.INT64_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi64\"}\\n\", tag->key, tag->val.INT64_val);",
            "-            fflush(stdout);",
            "+        case t_INT64:",
            "+            tag->val.INT64_val = plc_tag_get_int64(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.INT64_val = tag->val.INT64_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi64 \"}\\n\", tag->key, tag->val.INT64_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.INT64_val != tag->last_val.INT64_val) {",
            "+                tag->last_val.INT64_val = tag->val.INT64_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi64 \"}\\n\", tag->key, tag->val.INT64_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.INT64_val != tag->last_val.INT64_val) {",
            "-            tag->last_val.INT64_val = tag->val.INT64_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi64\"}\\n\", tag->key, tag->val.INT64_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_UINT32:",
            "-        tag->val.UINT32_val = plc_tag_get_uint32(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.UINT32_val = tag->val.UINT32_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu32\"}\\n\", tag->key, tag->val.UINT32_val);",
            "-            fflush(stdout);",
            "+        case t_UINT32:",
            "+            tag->val.UINT32_val = plc_tag_get_uint32(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.UINT32_val = tag->val.UINT32_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu32 \"}\\n\", tag->key, tag->val.UINT32_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.UINT32_val != tag->last_val.UINT32_val) {",
            "+                tag->last_val.UINT32_val = tag->val.UINT32_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu32 \"}\\n\", tag->key, tag->val.UINT32_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.UINT32_val != tag->last_val.UINT32_val) {",
            "-            tag->last_val.UINT32_val = tag->val.UINT32_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu32\"}\\n\", tag->key, tag->val.UINT32_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_INT32:",
            "-        tag->val.INT32_val = plc_tag_get_int32(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.INT32_val = tag->val.INT32_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi32\"}\\n\", tag->key, tag->val.INT32_val);",
            "-            fflush(stdout);",
            "+        case t_INT32:",
            "+            tag->val.INT32_val = plc_tag_get_int32(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.INT32_val = tag->val.INT32_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi32 \"}\\n\", tag->key, tag->val.INT32_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.INT32_val != tag->last_val.INT32_val) {",
            "+                tag->last_val.INT32_val = tag->val.INT32_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi32 \"}\\n\", tag->key, tag->val.INT32_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.INT32_val != tag->last_val.INT32_val) {",
            "-            tag->last_val.INT32_val = tag->val.INT32_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi32\"}\\n\", tag->key, tag->val.INT32_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_UINT16:",
            "-        tag->val.UINT16_val = plc_tag_get_uint16(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.UINT16_val = tag->val.UINT16_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu16\"}\\n\", tag->key, tag->val.UINT16_val);",
            "-            fflush(stdout);",
            "+        case t_UINT16:",
            "+            tag->val.UINT16_val = plc_tag_get_uint16(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.UINT16_val = tag->val.UINT16_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu16 \"}\\n\", tag->key, tag->val.UINT16_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.UINT16_val != tag->last_val.UINT16_val) {",
            "+                tag->last_val.UINT16_val = tag->val.UINT16_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu16 \"}\\n\", tag->key, tag->val.UINT16_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.UINT16_val != tag->last_val.UINT16_val) {",
            "-            tag->last_val.UINT16_val = tag->val.UINT16_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu16\"}\\n\", tag->key, tag->val.UINT16_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_INT16:",
            "-        tag->val.INT16_val = plc_tag_get_int16(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.INT16_val = tag->val.INT16_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi16\"}\\n\", tag->key, tag->val.INT16_val);",
            "-            fflush(stdout);",
            "+        case t_INT16:",
            "+            tag->val.INT16_val = plc_tag_get_int16(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.INT16_val = tag->val.INT16_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi16 \"}\\n\", tag->key, tag->val.INT16_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.INT16_val != tag->last_val.INT16_val) {",
            "+                tag->last_val.INT16_val = tag->val.INT16_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi16 \"}\\n\", tag->key, tag->val.UINT16_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.INT16_val != tag->last_val.INT16_val) {",
            "-            tag->last_val.INT16_val = tag->val.INT16_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi16\"}\\n\", tag->key, tag->val.UINT16_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_UINT8:",
            "-        tag->val.UINT8_val = plc_tag_get_uint8(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.UINT8_val = tag->val.UINT8_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu8\"}\\n\", tag->key, tag->val.UINT8_val);",
            "-            fflush(stdout);",
            "+        case t_UINT8:",
            "+            tag->val.UINT8_val = plc_tag_get_uint8(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.UINT8_val = tag->val.UINT8_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu8 \"}\\n\", tag->key, tag->val.UINT8_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.UINT8_val != tag->last_val.UINT8_val) {",
            "+                tag->last_val.UINT8_val = tag->val.UINT8_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIu8 \"}\\n\", tag->key, tag->val.UINT8_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.UINT8_val != tag->last_val.UINT8_val) {",
            "-            tag->last_val.UINT8_val = tag->val.UINT8_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIu8\"}\\n\", tag->key, tag->val.UINT8_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_INT8:",
            "-        tag->val.INT8_val = plc_tag_get_int8(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.INT8_val = tag->val.INT8_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi8\"}\\n\", tag->key, tag->val.INT8_val);",
            "-            fflush(stdout);",
            "+        case t_INT8:",
            "+            tag->val.INT8_val = plc_tag_get_int8(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.INT8_val = tag->val.INT8_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi8 \"}\\n\", tag->key, tag->val.INT8_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.INT8_val != tag->last_val.INT8_val) {",
            "+                tag->last_val.INT8_val = tag->val.INT8_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%\" PRIi8 \"}\\n\", tag->key, tag->val.INT8_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.INT8_val != tag->last_val.INT8_val) {",
            "-            tag->last_val.INT8_val = tag->val.INT8_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%\" PRIi8\"}\\n\", tag->key, tag->val.INT8_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_FLOAT64:",
            "-        tag->val.FLOAT64_val = plc_tag_get_float64(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.FLOAT64_val = tag->val.FLOAT64_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%lf}\\n\", tag->key, tag->val.FLOAT64_val);",
            "-            fflush(stdout);",
            "+        case t_FLOAT64:",
            "+            tag->val.FLOAT64_val = plc_tag_get_float64(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.FLOAT64_val = tag->val.FLOAT64_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%lf}\\n\", tag->key, tag->val.FLOAT64_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.FLOAT64_val != tag->last_val.FLOAT64_val) {",
            "+                tag->last_val.FLOAT64_val = tag->val.FLOAT64_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%lf}\\n\", tag->key, tag->val.FLOAT64_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.FLOAT64_val != tag->last_val.FLOAT64_val) {",
            "-            tag->last_val.FLOAT64_val = tag->val.FLOAT64_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%lf}\\n\", tag->key, tag->val.FLOAT64_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_FLOAT32:",
            "-        tag->val.FLOAT32_val = plc_tag_get_float32(tag_handle, tag->offset);",
            "-        if (!tag->watch) {",
            "-            tag->last_val.FLOAT32_val = tag->val.FLOAT32_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%f}\\n\", tag->key, tag->val.FLOAT32_val);",
            "-            fflush(stdout);",
            "+        case t_FLOAT32:",
            "+            tag->val.FLOAT32_val = plc_tag_get_float32(tag_handle, tag->offset);",
            "+            if(!tag->watch) {",
            "+                tag->last_val.FLOAT32_val = tag->val.FLOAT32_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%f}\\n\", tag->key, tag->val.FLOAT32_val);",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.FLOAT32_val != tag->last_val.FLOAT32_val) {",
            "+                tag->last_val.FLOAT32_val = tag->val.FLOAT32_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%f}\\n\", tag->key, tag->val.FLOAT32_val);",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.FLOAT32_val != tag->last_val.FLOAT32_val) {",
            "-            tag->last_val.FLOAT32_val = tag->val.FLOAT32_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%f}\\n\", tag->key, tag->val.FLOAT32_val);",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    case t_BOOL:",
            "-        if (tag->bit == -1) {",
            "-            tag->val.BOOL_val = plc_tag_get_uint8(tag_handle, tag->offset);",
            "-        } else {",
            "-            tag->val.BOOL_val = plc_tag_get_bit(tag_handle, tag->bit);",
            "-        }",
            "-        if (!tag->watch) {",
            "-            tag->last_val.BOOL_val = tag->val.BOOL_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%s}\\n\", tag->key, btoa(tag->val.BOOL_val));",
            "-            fflush(stdout);",
            "+        case t_BOOL:",
            "+            if(tag->bit == -1) {",
            "+                tag->val.BOOL_val = plc_tag_get_uint8(tag_handle, tag->offset);",
            "+            } else {",
            "+                tag->val.BOOL_val = plc_tag_get_bit(tag_handle, tag->bit);",
            "+            }",
            "+            if(!tag->watch) {",
            "+                tag->last_val.BOOL_val = tag->val.BOOL_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%s}\\n\", tag->key, btoa(tag->val.BOOL_val));",
            "+                fflush(stdout);",
            "+                break;",
            "+            }",
            "+            if(tag->val.BOOL_val != tag->last_val.BOOL_val) {",
            "+                tag->last_val.BOOL_val = tag->val.BOOL_val;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%s}\\n\", tag->key, btoa(tag->val.BOOL_val));",
            "+                fflush(stdout);",
            "+            }",
            "             break;",
            "-        }",
            "-        if (tag->val.BOOL_val != tag->last_val.BOOL_val) {",
            "-            tag->last_val.BOOL_val = tag->val.BOOL_val;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%s}\\n\", tag->key, btoa(tag->val.BOOL_val));",
            "-            fflush(stdout);",
            "-        }",
            "-        break;",
            "-    default:",
            "-        return PLCTAG_ERR_BAD_STATUS;",
            "-        break;",
            "+        default: return PLCTAG_ERR_BAD_STATUS; break;",
            "     }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " int read_tags(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "@@ -730,152 +727,128 @@",
            "         if(rc != PLCTAG_STATUS_PENDING) {",
            "             pdebug(DEBUG_ERROR, \"Unable to read tag %s!\", plc_tag_decode_error(rc));",
            "             return rc;",
            "         }",
            "     }",
            " ",
            "     /* wait for all tags to be ready */",
            "-    while(check_tags() == PLCTAG_STATUS_PENDING){",
            "+    while(check_tags() == PLCTAG_STATUS_PENDING) {",
            "         pdebug(DEBUG_INFO, \"Waiting for tags to be ready...\");",
            "-        util_sleep_ms(1);",
            "+        thrd_sleep_ms(10, NULL);",
            "     }",
            " ",
            "     for(t = tags; t != NULL; t = t->hh.next) {",
            "         rc = get_tag(t->tag_handle, &t->tag);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "             pdebug(DEBUG_ERROR, \"Unable to parse value of tag %s!\", plc_tag_decode_error(rc));",
            "             return rc;",
            "         }",
            "     }",
            " ",
            "     return 0;",
            " }",
            " ",
            " int set_tag(int32_t tag_handle, tag_t *tag) {",
            "-    switch (tag->type) {",
            "-    case t_UINT64:",
            "-        plc_tag_set_uint64(tag_handle, tag->offset, tag->write_val.UINT64_val);",
            "-        break;",
            "-    case t_INT64:",
            "-        plc_tag_set_int64(tag_handle, tag->offset, tag->write_val.INT64_val);",
            "-        break;",
            "-    case t_UINT32:",
            "-        plc_tag_set_uint32(tag_handle, tag->offset, tag->write_val.UINT32_val);",
            "-        break;",
            "-    case t_INT32:",
            "-        plc_tag_set_int32(tag_handle, tag->offset, tag->write_val.INT32_val);",
            "-        break;",
            "-    case t_UINT16:",
            "-        plc_tag_set_uint16(tag_handle, tag->offset, tag->write_val.UINT16_val);",
            "-        break;",
            "-    case t_INT16:",
            "-        plc_tag_set_int16(tag_handle, tag->offset, tag->write_val.INT16_val);",
            "-        break;",
            "-    case t_UINT8:",
            "-        plc_tag_set_uint8(tag_handle, tag->offset, tag->write_val.UINT8_val);",
            "-        break;",
            "-    case t_INT8:",
            "-        plc_tag_set_int8(tag_handle, tag->offset, tag->write_val.INT8_val);",
            "-        break;",
            "-    case t_FLOAT64:",
            "-        plc_tag_set_float64(tag_handle, tag->offset, tag->write_val.FLOAT64_val);",
            "-        break;",
            "-    case t_FLOAT32:",
            "-        plc_tag_set_float32(tag_handle, tag->offset, tag->write_val.FLOAT32_val);",
            "-        break;",
            "-    case t_BOOL:",
            "-        if (tag->bit == -1) {",
            "-            plc_tag_set_uint8(tag_handle, tag->offset, tag->write_val.BOOL_val);",
            "+    switch(tag->type) {",
            "+        case t_UINT64: plc_tag_set_uint64(tag_handle, tag->offset, tag->write_val.UINT64_val); break;",
            "+        case t_INT64: plc_tag_set_int64(tag_handle, tag->offset, tag->write_val.INT64_val); break;",
            "+        case t_UINT32: plc_tag_set_uint32(tag_handle, tag->offset, tag->write_val.UINT32_val); break;",
            "+        case t_INT32: plc_tag_set_int32(tag_handle, tag->offset, tag->write_val.INT32_val); break;",
            "+        case t_UINT16: plc_tag_set_uint16(tag_handle, tag->offset, tag->write_val.UINT16_val); break;",
            "+        case t_INT16: plc_tag_set_int16(tag_handle, tag->offset, tag->write_val.INT16_val); break;",
            "+        case t_UINT8: plc_tag_set_uint8(tag_handle, tag->offset, tag->write_val.UINT8_val); break;",
            "+        case t_INT8: plc_tag_set_int8(tag_handle, tag->offset, tag->write_val.INT8_val); break;",
            "+        case t_FLOAT64: plc_tag_set_float64(tag_handle, tag->offset, tag->write_val.FLOAT64_val); break;",
            "+        case t_FLOAT32: plc_tag_set_float32(tag_handle, tag->offset, tag->write_val.FLOAT32_val); break;",
            "+        case t_BOOL:",
            "+            if(tag->bit == -1) {",
            "+                plc_tag_set_uint8(tag_handle, tag->offset, tag->write_val.BOOL_val);",
            "+                break;",
            "+            }",
            "+            plc_tag_set_bit(tag_handle, tag->bit, tag->write_val.BOOL_val);",
            "             break;",
            "-        }",
            "-        plc_tag_set_bit(tag_handle, tag->bit, tag->write_val.BOOL_val);",
            "-        break;",
            "-    default:",
            "-        return PLCTAG_ERR_BAD_STATUS;",
            "-        break;",
            "+        default: return PLCTAG_ERR_BAD_STATUS; break;",
            "     }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " int verify_write_tags(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     struct tags *t;",
            " ",
            "     for(t = tags; t != NULL; t = t->hh.next) {",
            "-        switch (t->tag.type) {",
            "-        case t_UINT64:",
            "-            if (t->tag.last_val.UINT64_val != t->tag.write_val.UINT64_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_INT64:",
            "-            if (t->tag.last_val.INT64_val != t->tag.write_val.INT64_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_UINT32:",
            "-            if (t->tag.last_val.UINT32_val != t->tag.write_val.UINT32_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_INT32:",
            "-            if (t->tag.last_val.INT32_val != t->tag.write_val.INT32_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_UINT16:",
            "-            if (t->tag.last_val.UINT16_val != t->tag.write_val.UINT16_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_INT16:",
            "-            if (t->tag.last_val.INT16_val != t->tag.write_val.INT16_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_UINT8:",
            "-            if (t->tag.last_val.UINT8_val != t->tag.write_val.UINT8_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_INT8:",
            "-            if (t->tag.last_val.INT8_val != t->tag.write_val.INT8_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_FLOAT64:",
            "-            if (t->tag.last_val.FLOAT64_val != t->tag.write_val.FLOAT64_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_FLOAT32:",
            "-            if (t->tag.last_val.FLOAT32_val != t->tag.write_val.FLOAT32_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        case t_BOOL:",
            "-            if (t->tag.last_val.BOOL_val != t->tag.write_val.BOOL_val) {",
            "-                pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "-                return PLCTAG_ERR_BAD_STATUS;",
            "-            }",
            "-            break;",
            "-        default:",
            "-            return PLCTAG_ERR_BAD_STATUS;",
            "-            break;",
            "+        switch(t->tag.type) {",
            "+            case t_UINT64:",
            "+                if(t->tag.last_val.UINT64_val != t->tag.write_val.UINT64_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_INT64:",
            "+                if(t->tag.last_val.INT64_val != t->tag.write_val.INT64_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_UINT32:",
            "+                if(t->tag.last_val.UINT32_val != t->tag.write_val.UINT32_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_INT32:",
            "+                if(t->tag.last_val.INT32_val != t->tag.write_val.INT32_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_UINT16:",
            "+                if(t->tag.last_val.UINT16_val != t->tag.write_val.UINT16_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_INT16:",
            "+                if(t->tag.last_val.INT16_val != t->tag.write_val.INT16_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_UINT8:",
            "+                if(t->tag.last_val.UINT8_val != t->tag.write_val.UINT8_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_INT8:",
            "+                if(t->tag.last_val.INT8_val != t->tag.write_val.INT8_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_FLOAT64:",
            "+                if(t->tag.last_val.FLOAT64_val != t->tag.write_val.FLOAT64_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_FLOAT32:",
            "+                if(t->tag.last_val.FLOAT32_val != t->tag.write_val.FLOAT32_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            case t_BOOL:",
            "+                if(t->tag.last_val.BOOL_val != t->tag.write_val.BOOL_val) {",
            "+                    pdebug(DEBUG_ERROR, \"Unable to write value of tag %s!\", t->tag.key);",
            "+                    return PLCTAG_ERR_BAD_STATUS;",
            "+                }",
            "+                break;",
            "+            default: return PLCTAG_ERR_BAD_STATUS; break;",
            "         }",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            " int write_tags(void) {",
            "@@ -892,57 +865,47 @@",
            "         if(rc != PLCTAG_STATUS_PENDING) {",
            "             pdebug(DEBUG_ERROR, \"Unable to read tag %s!\", plc_tag_decode_error(rc));",
            "             return rc;",
            "         }",
            "     }",
            " ",
            "     /* wait for all tags to be ready */",
            "-    while(check_tags() == PLCTAG_STATUS_PENDING){",
            "+    while(check_tags() == PLCTAG_STATUS_PENDING) {",
            "         pdebug(DEBUG_INFO, \"Waiting for tags to be ready...\");",
            "-        util_sleep_ms(1);",
            "+        thrd_sleep_ms(10, NULL);",
            "     }",
            " ",
            "     read_tags();",
            " ",
            "     rc = verify_write_tags();",
            "-    if (rc != PLCTAG_STATUS_OK) {",
            "+    if(rc != PLCTAG_STATUS_OK) {",
            "         pdebug(DEBUG_ERROR, \"Unable to write value to tags %s!\", plc_tag_decode_error(rc));",
            "         return rc;",
            "     }",
            " ",
            "     return 0;",
            " }",
            " ",
            " void tag_callback(int32_t tag_handle, int event, int status) {",
            "     /* get that tag associated with the handle */",
            "     struct tags *t;",
            "     HASH_FIND_INT(tags, &tag_handle, t);",
            " ",
            "     /* handle the events. */",
            "     switch(event) {",
            "-    case PLCTAG_EVENT_ABORTED:",
            "-        pdebug(DEBUG_INFO, \"tag(%s): Tag operation was aborted!\", t->tag.key);",
            "-        break;",
            "-    case PLCTAG_EVENT_DESTROYED:",
            "-        pdebug(DEBUG_INFO, \"tag(%s): Tag was destroyed.\", t->tag.key);",
            "-        break;",
            "-    case PLCTAG_EVENT_READ_COMPLETED:",
            "-        get_tag(tag_handle, &t->tag);",
            "-        pdebug(DEBUG_INFO, \"tag(%s): Tag read operation completed with status %s.\", t->tag.key, plc_tag_decode_error(status));",
            "-        break;",
            "-    case PLCTAG_EVENT_READ_STARTED:",
            "-        pdebug(DEBUG_INFO, \"tag(%s): Tag read operation started.\", t->tag.key);",
            "-        break;",
            "-    case PLCTAG_EVENT_WRITE_COMPLETED:",
            "-        break;",
            "-    case PLCTAG_EVENT_WRITE_STARTED:",
            "-        break;",
            "-    default:",
            "-        pdebug(DEBUG_INFO, \"tag(%s): Unexpected event %d!\", t->tag.key, event);",
            "-        break;",
            "+        case PLCTAG_EVENT_ABORTED: pdebug(DEBUG_INFO, \"tag(%s): Tag operation was aborted!\", t->tag.key); break;",
            "+        case PLCTAG_EVENT_DESTROYED: pdebug(DEBUG_INFO, \"tag(%s): Tag was destroyed.\", t->tag.key); break;",
            "+        case PLCTAG_EVENT_READ_COMPLETED:",
            "+            get_tag(tag_handle, &t->tag);",
            "+            pdebug(DEBUG_INFO, \"tag(%s): Tag read operation completed with status %s.\", t->tag.key, plc_tag_decode_error(status));",
            "+            break;",
            "+        case PLCTAG_EVENT_READ_STARTED: pdebug(DEBUG_INFO, \"tag(%s): Tag read operation started.\", t->tag.key); break;",
            "+        case PLCTAG_EVENT_WRITE_COMPLETED: break;",
            "+        case PLCTAG_EVENT_WRITE_STARTED: break;",
            "+        default: pdebug(DEBUG_INFO, \"tag(%s): Unexpected event %d!\", t->tag.key, event); break;",
            "     }",
            " }",
            " ",
            " int watch_tags(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     struct tags *t;",
            " ",
            "@@ -952,17 +915,15 @@",
            "         rc = plc_tag_register_callback(t->tag_handle, tag_callback);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "             pdebug(DEBUG_ERROR, \"Unable to register callback for tag %s!\", plc_tag_decode_error(rc));",
            "             return rc;",
            "         }",
            "     }",
            " ",
            "-    while(true){",
            "-        util_sleep_ms(1000);",
            "-    }",
            "+    while(true) { thrd_sleep_ms(1000, NULL); }",
            " ",
            "     return 0;",
            " }",
            " ",
            " int destroy_tags(void) {",
            "     struct tags *t;",
            "     int rc = PLCTAG_STATUS_OK;",
            "@@ -980,90 +941,90 @@",
            " ",
            " int do_offline(void) {",
            "     struct tags *t = tags;",
            "     int val = 0;",
            " ",
            "     pdebug(DEBUG_INFO, \"Running offline!\");",
            " ",
            "-    switch (cli_request.operation) {",
            "-    case READ:",
            "-        fprintf(stdout, \"{}\\n\");",
            "-        fflush(stdout);",
            "-        break;",
            "-    case WRITE:",
            "-        fprintf(stdout, \"{}\\n\");",
            "-        fflush(stdout);",
            "-        break;",
            "-    case WATCH:",
            "-        while (true) {",
            "-            ++val;",
            "-            val = val%10;",
            "-            fprintf(stdout, \"{\\\"%s\\\":%d}\\n\", t->tag.key, val);",
            "+    switch(cli_request.operation) {",
            "+        case READ:",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stdout, \"{}\\n\");",
            "             fflush(stdout);",
            "-            util_sleep_ms(2000);",
            "-        }",
            "-        break;",
            "-    default:",
            "-        break;",
            "+            break;",
            "+        case WRITE:",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stdout, \"{}\\n\");",
            "+            fflush(stdout);",
            "+            break;",
            "+        case WATCH:",
            "+            while(true) {",
            "+                ++val;",
            "+                val = val % 10;",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stdout, \"{\\\"%s\\\":%d}\\n\", t->tag.key, val);",
            "+                fflush(stdout);",
            "+                thrd_sleep_ms(2000, NULL);",
            "+            }",
            "+            break;",
            "+        default: break;",
            "     }",
            " ",
            "     return 0;",
            " }",
            " ",
            "-int main(int argc, char *argv[])",
            "-{",
            "-    if (parse_args(argc, argv) == -1) {",
            "+int main(int argc, char *argv[]) {",
            "+    if(parse_args(argc, argv) == -1) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"ERROR: invalid arguments.\\n\");",
            "         fflush(stderr);",
            "         usage();",
            "         exit(1);",
            "     }",
            " ",
            "     plc_tag_set_debug_level(cli_request.debug_level);",
            " ",
            "     print_request();",
            " ",
            "-    if (process_tags() != PLCTAG_STATUS_OK) {",
            "+    if(process_tags() != PLCTAG_STATUS_OK) {",
            "         pdebug(DEBUG_ERROR, \"Could not process tags.\");",
            "         exit(1);",
            "     }",
            " ",
            "-    if (cli_request.offline) {",
            "-        exit(do_offline());",
            "-    }",
            "+    if(cli_request.offline) { exit(do_offline()); }",
            " ",
            "     /* wait for all tags to be ready */",
            "-    while(check_tags() == PLCTAG_STATUS_PENDING){",
            "+    while(check_tags() == PLCTAG_STATUS_PENDING) {",
            "         pdebug(DEBUG_INFO, \"Waiting for tags to be ready...\");",
            "-        util_sleep_ms(1);",
            "+        thrd_sleep_ms(10, NULL);",
            "     }",
            " ",
            "-    switch (cli_request.operation) {",
            "-    case READ:",
            "-        if (read_tags() != PLCTAG_STATUS_OK) {",
            "-            pdebug(DEBUG_ERROR, \"Tag read failed.\");",
            "-            exit(1);",
            "-        }",
            "-        break;",
            "-    case WRITE:",
            "-        if (write_tags() != PLCTAG_STATUS_OK) {",
            "-            pdebug(DEBUG_ERROR, \"Tag write failed.\");",
            "-            exit(1);",
            "-        }",
            "-        break;",
            "-    case WATCH:",
            "-        if (read_tags() != PLCTAG_STATUS_OK) {",
            "-            pdebug(DEBUG_ERROR, \"Tag read failed.\");",
            "-            exit(1);",
            "-        }",
            "-        watch_tags();",
            "-        break;",
            "-    default:",
            "-        break;",
            "+    switch(cli_request.operation) {",
            "+        case READ:",
            "+            if(read_tags() != PLCTAG_STATUS_OK) {",
            "+                pdebug(DEBUG_ERROR, \"Tag read failed.\");",
            "+                exit(1);",
            "+            }",
            "+            break;",
            "+        case WRITE:",
            "+            if(write_tags() != PLCTAG_STATUS_OK) {",
            "+                pdebug(DEBUG_ERROR, \"Tag write failed.\");",
            "+                exit(1);",
            "+            }",
            "+            break;",
            "+        case WATCH:",
            "+            if(read_tags() != PLCTAG_STATUS_OK) {",
            "+                pdebug(DEBUG_ERROR, \"Tag read failed.\");",
            "+                exit(1);",
            "+            }",
            "+            watch_tags();",
            "+            break;",
            "+        default: break;",
            "     }",
            " ",
            "     destroy_tags();",
            "     plc_tag_shutdown();",
            " ",
            "     pdebug(DEBUG_INFO, \"DONE.\");",
            "     exit(0);",
            " }",
            "+// NOLINTNEXTLINE"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/contrib/cli/cli.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/contrib/cli/cli.h",
            "+++ /home/libplctag-2.6.7/src/contrib/cli/cli.h",
            "@@ -1,11 +1,13 @@",
            " #pragma once",
            " ",
            " #include \"./uthash.h\"",
            " ",
            "+#include <stdbool.h>",
            "+",
            " /* tag paths */",
            " #define TAG_PATH                  \"protocol=%s&gateway=%s&path=%s&plc=%s&debug=%d&name=%s%s\"",
            " #define TAG_PATH_AUTO_READ_SYNC   \"protocol=%s&gateway=%s&path=%s&plc=%s&debug=%d&auto_sync_read_ms=%d&name=%s%s\"",
            " #define DATA_TIMEOUT              5000",
            " ",
            " /* bool utils */",
            " #define btoa(x) ( (x) ? \"true\" : \"false\" )",
            "@@ -37,17 +39,17 @@",
            " } tag_line_parts_t;",
            " ",
            " /* data types */",
            " typedef enum {",
            "     t_UINT64, t_INT64,",
            "     t_UINT32, t_INT32,",
            "     t_UINT16, t_INT16,",
            "-    t_UINT8, t_INT8, ",
            "-    t_FLOAT64, t_FLOAT32, ",
            "-    t_BOOL ",
            "+    t_UINT8, t_INT8,",
            "+    t_FLOAT64, t_FLOAT32,",
            "+    t_BOOL",
            " } data_type_t;",
            " ",
            " /* tag definition */",
            " typedef struct {",
            "     const char *key;",
            "     data_type_t type;",
            "     const char *path;",
            "@@ -74,16 +76,16 @@",
            "     int tag_handle;",
            "     tag_t tag;",
            "     UT_hash_handle hh;",
            " };",
            " ",
            " void usage(void);",
            " int parse_args(int argc, char *argv[]);",
            "-void print_request();",
            "-int process_tags();",
            "+void print_request(void);",
            "+int process_tags(void);",
            " int is_comment(const char *line);",
            " void trim_line(char *line);",
            " tag_line_parts_t split_string(const char *str, const char *sep);",
            " int process_line(const char *line, tag_t *tag);",
            " int validate_line(tag_line_parts_t tag_line_parts);",
            " void print_tag(tag_t *tag);",
            " void add_tag(int32_t tag_handle, tag_t tag);"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/contrib/cli/uthash.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/contrib/cli/uthash.h",
            "+++ /home/libplctag-2.6.7/src/contrib/cli/uthash.h",
            "@@ -22,787 +22,755 @@",
            " */",
            " ",
            " #ifndef UTHASH_H",
            " #define UTHASH_H",
            " ",
            " #define UTHASH_VERSION 2.3.0",
            " ",
            "-#include <string.h>   /* memcmp, memset, strlen */",
            "-#include <stddef.h>   /* ptrdiff_t */",
            "-#include <stdlib.h>   /* exit */",
            "+#include <stddef.h> /* ptrdiff_t */",
            "+#include <stdlib.h> /* exit */",
            "+#include <string.h> /* memcmp, memset, strlen */",
            " ",
            " #if defined(HASH_DEFINE_OWN_STDINT) && HASH_DEFINE_OWN_STDINT",
            " /* This codepath is provided for backward compatibility, but I plan to remove it. */",
            "-#warning \"HASH_DEFINE_OWN_STDINT is deprecated; please use HASH_NO_STDINT instead\"",
            "+#    warning \"HASH_DEFINE_OWN_STDINT is deprecated; please use HASH_NO_STDINT instead\"",
            " typedef unsigned int uint32_t;",
            " typedef unsigned char uint8_t;",
            " #elif defined(HASH_NO_STDINT) && HASH_NO_STDINT",
            " #else",
            "-#include <stdint.h>   /* uint8_t, uint32_t */",
            "+#    include <stdint.h> /* uint8_t, uint32_t */",
            " #endif",
            " ",
            " /* These macros use decltype or the earlier __typeof GNU extension.",
            "    As decltype is only available in newer compilers (VS2010 or gcc 4.3+",
            "    when compiling c++ source) this code uses whatever method is needed",
            "    or, for VS2008 where neither is available, uses casting workarounds. */",
            " #if !defined(DECLTYPE) && !defined(NO_DECLTYPE)",
            "-#if defined(_MSC_VER)   /* MS compiler */",
            "-#if _MSC_VER >= 1600 && defined(__cplusplus)  /* VS2010 or newer in C++ mode */",
            "-#define DECLTYPE(x) (decltype(x))",
            "-#else                   /* VS2008 or older (or VS2010 in C mode) */",
            "-#define NO_DECLTYPE",
            "-#endif",
            "-#elif defined(__BORLANDC__) || defined(__ICCARM__) || defined(__LCC__) || defined(__WATCOMC__)",
            "-#define NO_DECLTYPE",
            "-#else                   /* GNU, Sun and other compilers */",
            "-#define DECLTYPE(x) (__typeof(x))",
            "-#endif",
            "+#    if defined(_MSC_VER)                            /* MS compiler */",
            "+#        if _MSC_VER >= 1600 && defined(__cplusplus) /* VS2010 or newer in C++ mode */",
            "+#            define DECLTYPE(x) (decltype(x))",
            "+#        else /* VS2008 or older (or VS2010 in C mode) */",
            "+#            define NO_DECLTYPE",
            "+#        endif",
            "+#    elif defined(__BORLANDC__) || defined(__ICCARM__) || defined(__LCC__) || defined(__WATCOMC__)",
            "+#        define NO_DECLTYPE",
            "+#    else /* GNU, Sun and other compilers */",
            "+#        define DECLTYPE(x) (__typeof(x))",
            "+#    endif",
            " #endif",
            " ",
            " #ifdef NO_DECLTYPE",
            "-#define DECLTYPE(x)",
            "-#define DECLTYPE_ASSIGN(dst,src)                                                 \\",
            "-do {                                                                             \\",
            "-  char **_da_dst = (char**)(&(dst));                                             \\",
            "-  *_da_dst = (char*)(src);                                                       \\",
            "-} while (0)",
            "+#    define DECLTYPE(x)",
            "+#    define DECLTYPE_ASSIGN(dst, src)           \\",
            "+        do {                                    \\",
            "+            char **_da_dst = (char **)(&(dst)); \\",
            "+            *_da_dst = (char *)(src);           \\",
            "+        } while(0)",
            " #else",
            "-#define DECLTYPE_ASSIGN(dst,src)                                                 \\",
            "-do {                                                                             \\",
            "-  (dst) = DECLTYPE(dst)(src);                                                    \\",
            "-} while (0)",
            "+#    define DECLTYPE_ASSIGN(dst, src) \\",
            "+        do { (dst) = DECLTYPE(dst)(src); } while(0)",
            " #endif",
            " ",
            " #ifndef uthash_malloc",
            "-#define uthash_malloc(sz) malloc(sz)      /* malloc fcn                      */",
            "+#    define uthash_malloc(sz) malloc(sz) /* malloc fcn                      */",
            " #endif",
            " #ifndef uthash_free",
            "-#define uthash_free(ptr,sz) free(ptr)     /* free fcn                        */",
            "+#    define uthash_free(ptr, sz) free(ptr) /* free fcn                        */",
            " #endif",
            " #ifndef uthash_bzero",
            "-#define uthash_bzero(a,n) memset(a,'\\0',n)",
            "+#    define uthash_bzero(a, n) memset(a, '\\0', n)",
            " #endif",
            " #ifndef uthash_strlen",
            "-#define uthash_strlen(s) strlen(s)",
            "+#    define uthash_strlen(s) strlen(s)",
            " #endif",
            " ",
            " #ifndef HASH_FUNCTION",
            "-#define HASH_FUNCTION(keyptr,keylen,hashv) HASH_JEN(keyptr, keylen, hashv)",
            "+#    define HASH_FUNCTION(keyptr, keylen, hashv) HASH_JEN(keyptr, keylen, hashv)",
            " #endif",
            " ",
            " #ifndef HASH_KEYCMP",
            "-#define HASH_KEYCMP(a,b,n) memcmp(a,b,n)",
            "+#    define HASH_KEYCMP(a, b, n) memcmp(a, b, n)",
            " #endif",
            " ",
            " #ifndef uthash_noexpand_fyi",
            "-#define uthash_noexpand_fyi(tbl)          /* can be defined to log noexpand  */",
            "+#    define uthash_noexpand_fyi(tbl) /* can be defined to log noexpand  */",
            " #endif",
            " #ifndef uthash_expand_fyi",
            "-#define uthash_expand_fyi(tbl)            /* can be defined to log expands   */",
            "+#    define uthash_expand_fyi(tbl) /* can be defined to log expands   */",
            " #endif",
            " ",
            " #ifndef HASH_NONFATAL_OOM",
            "-#define HASH_NONFATAL_OOM 0",
            "+#    define HASH_NONFATAL_OOM 0",
            " #endif",
            " ",
            " #if HASH_NONFATAL_OOM",
            " /* malloc failures can be recovered from */",
            " ",
            "-#ifndef uthash_nonfatal_oom",
            "-#define uthash_nonfatal_oom(obj) do {} while (0)    /* non-fatal OOM error */",
            "-#endif",
            "-",
            "-#define HASH_RECORD_OOM(oomed) do { (oomed) = 1; } while (0)",
            "-#define IF_HASH_NONFATAL_OOM(x) x",
            "+#    ifndef uthash_nonfatal_oom",
            "+#        define uthash_nonfatal_oom(obj) \\",
            "+            do {                         \\",
            "+            } while(0) /* non-fatal OOM error */",
            "+#    endif",
            "+",
            "+#    define HASH_RECORD_OOM(oomed) \\",
            "+        do { (oomed) = 1; } while(0)",
            "+#    define IF_HASH_NONFATAL_OOM(x) x",
            " ",
            " #else",
            " /* malloc failures result in lost memory, hash tables are unusable */",
            " ",
            "-#ifndef uthash_fatal",
            "-#define uthash_fatal(msg) exit(-1)        /* fatal OOM error */",
            "-#endif",
            "+#    ifndef uthash_fatal",
            "+#        define uthash_fatal(msg) exit(-1) /* fatal OOM error */",
            "+#    endif",
            " ",
            "-#define HASH_RECORD_OOM(oomed) uthash_fatal(\"out of memory\")",
            "-#define IF_HASH_NONFATAL_OOM(x)",
            "+#    define HASH_RECORD_OOM(oomed) uthash_fatal(\"out of memory\")",
            "+#    define IF_HASH_NONFATAL_OOM(x)",
            " ",
            " #endif",
            " ",
            " /* initial number of buckets */",
            " #define HASH_INITIAL_NUM_BUCKETS 32U     /* initial number of buckets        */",
            " #define HASH_INITIAL_NUM_BUCKETS_LOG2 5U /* lg2 of initial number of buckets */",
            " #define HASH_BKT_CAPACITY_THRESH 10U     /* expand when bucket count reaches */",
            " ",
            " /* calculate the element whose hash handle address is hhp */",
            "-#define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))",
            "+#define ELMT_FROM_HH(tbl, hhp) ((void *)(((char *)(hhp)) - ((tbl)->hho)))",
            " /* calculate the hash handle from element address elp */",
            "-#define HH_FROM_ELMT(tbl,elp) ((UT_hash_handle*)(void*)(((char*)(elp)) + ((tbl)->hho)))",
            "+#define HH_FROM_ELMT(tbl, elp) ((UT_hash_handle *)(void *)(((char *)(elp)) + ((tbl)->hho)))",
            " ",
            "-#define HASH_ROLLBACK_BKT(hh, head, itemptrhh)                                   \\",
            "-do {                                                                             \\",
            "-  struct UT_hash_handle *_hd_hh_item = (itemptrhh);                              \\",
            "-  unsigned _hd_bkt;                                                              \\",
            "-  HASH_TO_BKT(_hd_hh_item->hashv, (head)->hh.tbl->num_buckets, _hd_bkt);         \\",
            "-  (head)->hh.tbl->buckets[_hd_bkt].count++;                                      \\",
            "-  _hd_hh_item->hh_next = NULL;                                                   \\",
            "-  _hd_hh_item->hh_prev = NULL;                                                   \\",
            "-} while (0)",
            "-",
            "-#define HASH_VALUE(keyptr,keylen,hashv)                                          \\",
            "-do {                                                                             \\",
            "-  HASH_FUNCTION(keyptr, keylen, hashv);                                          \\",
            "-} while (0)",
            "-",
            "-#define HASH_FIND_BYHASHVALUE(hh,head,keyptr,keylen,hashval,out)                 \\",
            "-do {                                                                             \\",
            "-  (out) = NULL;                                                                  \\",
            "-  if (head) {                                                                    \\",
            "-    unsigned _hf_bkt;                                                            \\",
            "-    HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _hf_bkt);                  \\",
            "-    if (HASH_BLOOM_TEST((head)->hh.tbl, hashval) != 0) {                         \\",
            "-      HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ], keyptr, keylen, hashval, out); \\",
            "-    }                                                                            \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "-",
            "-#define HASH_FIND(hh,head,keyptr,keylen,out)                                     \\",
            "-do {                                                                             \\",
            "-  (out) = NULL;                                                                  \\",
            "-  if (head) {                                                                    \\",
            "-    unsigned _hf_hashv;                                                          \\",
            "-    HASH_VALUE(keyptr, keylen, _hf_hashv);                                       \\",
            "-    HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, _hf_hashv, out);             \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_ROLLBACK_BKT(hh, head, itemptrhh)                                 \\",
            "+    do {                                                                       \\",
            "+        struct UT_hash_handle *_hd_hh_item = (itemptrhh);                      \\",
            "+        unsigned _hd_bkt;                                                      \\",
            "+        HASH_TO_BKT(_hd_hh_item->hashv, (head)->hh.tbl->num_buckets, _hd_bkt); \\",
            "+        (head)->hh.tbl->buckets[_hd_bkt].count++;                              \\",
            "+        _hd_hh_item->hh_next = NULL;                                           \\",
            "+        _hd_hh_item->hh_prev = NULL;                                           \\",
            "+    } while(0)",
            "+",
            "+#define HASH_VALUE(keyptr, keylen, hashv) \\",
            "+    do { HASH_FUNCTION(keyptr, keylen, hashv); } while(0)",
            "+",
            "+#define HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, hashval, out)                                                 \\",
            "+    do {                                                                                                              \\",
            "+        (out) = NULL;                                                                                                 \\",
            "+        if(head) {                                                                                                    \\",
            "+            unsigned _hf_bkt;                                                                                         \\",
            "+            HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _hf_bkt);                                               \\",
            "+            if(HASH_BLOOM_TEST((head)->hh.tbl, hashval) != 0) {                                                       \\",
            "+                HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[_hf_bkt], keyptr, keylen, hashval, out); \\",
            "+            }                                                                                                         \\",
            "+        }                                                                                                             \\",
            "+    } while(0)",
            "+",
            "+#define HASH_FIND(hh, head, keyptr, keylen, out)                             \\",
            "+    do {                                                                     \\",
            "+        (out) = NULL;                                                        \\",
            "+        if(head) {                                                           \\",
            "+            unsigned _hf_hashv;                                              \\",
            "+            HASH_VALUE(keyptr, keylen, _hf_hashv);                           \\",
            "+            HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, _hf_hashv, out); \\",
            "+        }                                                                    \\",
            "+    } while(0)",
            " ",
            " #ifdef HASH_BLOOM",
            "-#define HASH_BLOOM_BITLEN (1UL << HASH_BLOOM)",
            "-#define HASH_BLOOM_BYTELEN (HASH_BLOOM_BITLEN/8UL) + (((HASH_BLOOM_BITLEN%8UL)!=0UL) ? 1UL : 0UL)",
            "-#define HASH_BLOOM_MAKE(tbl,oomed)                                               \\",
            "-do {                                                                             \\",
            "-  (tbl)->bloom_nbits = HASH_BLOOM;                                               \\",
            "-  (tbl)->bloom_bv = (uint8_t*)uthash_malloc(HASH_BLOOM_BYTELEN);                 \\",
            "-  if (!(tbl)->bloom_bv) {                                                        \\",
            "-    HASH_RECORD_OOM(oomed);                                                      \\",
            "-  } else {                                                                       \\",
            "-    uthash_bzero((tbl)->bloom_bv, HASH_BLOOM_BYTELEN);                           \\",
            "-    (tbl)->bloom_sig = HASH_BLOOM_SIGNATURE;                                     \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "-",
            "-#define HASH_BLOOM_FREE(tbl)                                                     \\",
            "-do {                                                                             \\",
            "-  uthash_free((tbl)->bloom_bv, HASH_BLOOM_BYTELEN);                              \\",
            "-} while (0)",
            "+#    define HASH_BLOOM_BITLEN (1UL << HASH_BLOOM)",
            "+#    define HASH_BLOOM_BYTELEN (HASH_BLOOM_BITLEN / 8UL) + (((HASH_BLOOM_BITLEN % 8UL) != 0UL) ? 1UL : 0UL)",
            "+#    define HASH_BLOOM_MAKE(tbl, oomed)                                     \\",
            "+        do {                                                                \\",
            "+            (tbl)->bloom_nbits = HASH_BLOOM;                                \\",
            "+            (tbl)->bloom_bv = (uint8_t *)uthash_malloc(HASH_BLOOM_BYTELEN); \\",
            "+            if(!(tbl)->bloom_bv) {                                          \\",
            "+                HASH_RECORD_OOM(oomed);                                     \\",
            "+            } else {                                                        \\",
            "+                uthash_bzero((tbl)->bloom_bv, HASH_BLOOM_BYTELEN);          \\",
            "+                (tbl)->bloom_sig = HASH_BLOOM_SIGNATURE;                    \\",
            "+            }                                                               \\",
            "+        } while(0)",
            "+",
            "+#    define HASH_BLOOM_FREE(tbl) \\",
            "+        do { uthash_free((tbl)->bloom_bv, HASH_BLOOM_BYTELEN); } while(0)",
            " ",
            "-#define HASH_BLOOM_BITSET(bv,idx) (bv[(idx)/8U] |= (1U << ((idx)%8U)))",
            "-#define HASH_BLOOM_BITTEST(bv,idx) (bv[(idx)/8U] & (1U << ((idx)%8U)))",
            "+#    define HASH_BLOOM_BITSET(bv, idx) (bv[(idx) / 8U] |= (1U << ((idx) % 8U)))",
            "+#    define HASH_BLOOM_BITTEST(bv, idx) (bv[(idx) / 8U] & (1U << ((idx) % 8U)))",
            " ",
            "-#define HASH_BLOOM_ADD(tbl,hashv)                                                \\",
            "-  HASH_BLOOM_BITSET((tbl)->bloom_bv, ((hashv) & (uint32_t)((1UL << (tbl)->bloom_nbits) - 1U)))",
            "+#    define HASH_BLOOM_ADD(tbl, hashv) \\",
            "+        HASH_BLOOM_BITSET((tbl)->bloom_bv, ((hashv) & (uint32_t)((1UL << (tbl)->bloom_nbits) - 1U)))",
            " ",
            "-#define HASH_BLOOM_TEST(tbl,hashv)                                               \\",
            "-  HASH_BLOOM_BITTEST((tbl)->bloom_bv, ((hashv) & (uint32_t)((1UL << (tbl)->bloom_nbits) - 1U)))",
            "+#    define HASH_BLOOM_TEST(tbl, hashv) \\",
            "+        HASH_BLOOM_BITTEST((tbl)->bloom_bv, ((hashv) & (uint32_t)((1UL << (tbl)->bloom_nbits) - 1U)))",
            " ",
            " #else",
            "-#define HASH_BLOOM_MAKE(tbl,oomed)",
            "-#define HASH_BLOOM_FREE(tbl)",
            "-#define HASH_BLOOM_ADD(tbl,hashv)",
            "-#define HASH_BLOOM_TEST(tbl,hashv) (1)",
            "-#define HASH_BLOOM_BYTELEN 0U",
            "-#endif",
            "-",
            "-#define HASH_MAKE_TABLE(hh,head,oomed)                                           \\",
            "-do {                                                                             \\",
            "-  (head)->hh.tbl = (UT_hash_table*)uthash_malloc(sizeof(UT_hash_table));         \\",
            "-  if (!(head)->hh.tbl) {                                                         \\",
            "-    HASH_RECORD_OOM(oomed);                                                      \\",
            "-  } else {                                                                       \\",
            "-    uthash_bzero((head)->hh.tbl, sizeof(UT_hash_table));                         \\",
            "-    (head)->hh.tbl->tail = &((head)->hh);                                        \\",
            "-    (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                      \\",
            "-    (head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;            \\",
            "-    (head)->hh.tbl->hho = (char*)(&(head)->hh) - (char*)(head);                  \\",
            "-    (head)->hh.tbl->buckets = (UT_hash_bucket*)uthash_malloc(                    \\",
            "-        HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket));               \\",
            "-    (head)->hh.tbl->signature = HASH_SIGNATURE;                                  \\",
            "-    if (!(head)->hh.tbl->buckets) {                                              \\",
            "-      HASH_RECORD_OOM(oomed);                                                    \\",
            "-      uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                        \\",
            "-    } else {                                                                     \\",
            "-      uthash_bzero((head)->hh.tbl->buckets,                                      \\",
            "-          HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket));             \\",
            "-      HASH_BLOOM_MAKE((head)->hh.tbl, oomed);                                    \\",
            "-      IF_HASH_NONFATAL_OOM(                                                      \\",
            "-        if (oomed) {                                                             \\",
            "-          uthash_free((head)->hh.tbl->buckets,                                   \\",
            "-              HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));           \\",
            "-          uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                    \\",
            "-        }                                                                        \\",
            "-      )                                                                          \\",
            "-    }                                                                            \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "-",
            "-#define HASH_REPLACE_BYHASHVALUE_INORDER(hh,head,fieldname,keylen_in,hashval,add,replaced,cmpfcn) \\",
            "-do {                                                                             \\",
            "-  (replaced) = NULL;                                                             \\",
            "-  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \\",
            "-  if (replaced) {                                                                \\",
            "-    HASH_DELETE(hh, head, replaced);                                             \\",
            "-  }                                                                              \\",
            "-  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn); \\",
            "-} while (0)",
            "-",
            "-#define HASH_REPLACE_BYHASHVALUE(hh,head,fieldname,keylen_in,hashval,add,replaced) \\",
            "-do {                                                                             \\",
            "-  (replaced) = NULL;                                                             \\",
            "-  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \\",
            "-  if (replaced) {                                                                \\",
            "-    HASH_DELETE(hh, head, replaced);                                             \\",
            "-  }                                                                              \\",
            "-  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add); \\",
            "-} while (0)",
            "-",
            "-#define HASH_REPLACE(hh,head,fieldname,keylen_in,add,replaced)                   \\",
            "-do {                                                                             \\",
            "-  unsigned _hr_hashv;                                                            \\",
            "-  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \\",
            "-  HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced); \\",
            "-} while (0)",
            "-",
            "-#define HASH_REPLACE_INORDER(hh,head,fieldname,keylen_in,add,replaced,cmpfcn)    \\",
            "-do {                                                                             \\",
            "-  unsigned _hr_hashv;                                                            \\",
            "-  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \\",
            "-  HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced, cmpfcn); \\",
            "-} while (0)",
            "-",
            "-#define HASH_APPEND_LIST(hh, head, add)                                          \\",
            "-do {                                                                             \\",
            "-  (add)->hh.next = NULL;                                                         \\",
            "-  (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);           \\",
            "-  (head)->hh.tbl->tail->next = (add);                                            \\",
            "-  (head)->hh.tbl->tail = &((add)->hh);                                           \\",
            "-} while (0)",
            "-",
            "-#define HASH_AKBI_INNER_LOOP(hh,head,add,cmpfcn)                                 \\",
            "-do {                                                                             \\",
            "-  do {                                                                           \\",
            "-    if (cmpfcn(DECLTYPE(head)(_hs_iter), add) > 0) {                             \\",
            "-      break;                                                                     \\",
            "-    }                                                                            \\",
            "-  } while ((_hs_iter = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->next));           \\",
            "-} while (0)",
            "+#    define HASH_BLOOM_MAKE(tbl, oomed)",
            "+#    define HASH_BLOOM_FREE(tbl)",
            "+#    define HASH_BLOOM_ADD(tbl, hashv)",
            "+#    define HASH_BLOOM_TEST(tbl, hashv) (1)",
            "+#    define HASH_BLOOM_BYTELEN 0U",
            "+#endif",
            "+",
            "+#define HASH_MAKE_TABLE(hh, head, oomed)                                                                                         \\",
            "+    do {                                                                                                                         \\",
            "+        (head)->hh.tbl = (UT_hash_table *)uthash_malloc(sizeof(UT_hash_table));                                                  \\",
            "+        if(!(head)->hh.tbl) {                                                                                                    \\",
            "+            HASH_RECORD_OOM(oomed);                                                                                              \\",
            "+        } else {                                                                                                                 \\",
            "+            uthash_bzero((head)->hh.tbl, sizeof(UT_hash_table));                                                                 \\",
            "+            (head)->hh.tbl->tail = &((head)->hh);                                                                                \\",
            "+            (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                                                              \\",
            "+            (head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;                                                    \\",
            "+            (head)->hh.tbl->hho = (char *)(&(head)->hh) - (char *)(head);                                                        \\",
            "+            (head)->hh.tbl->buckets = (UT_hash_bucket *)uthash_malloc(HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket)); \\",
            "+            (head)->hh.tbl->signature = HASH_SIGNATURE;                                                                          \\",
            "+            if(!(head)->hh.tbl->buckets) {                                                                                       \\",
            "+                HASH_RECORD_OOM(oomed);                                                                                          \\",
            "+                uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                                                              \\",
            "+            } else {                                                                                                             \\",
            "+                uthash_bzero((head)->hh.tbl->buckets, HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket));                 \\",
            "+                HASH_BLOOM_MAKE((head)->hh.tbl, oomed);                                                                          \\",
            "+                IF_HASH_NONFATAL_OOM(if(oomed) {                                                                                 \\",
            "+                    uthash_free((head)->hh.tbl->buckets, HASH_INITIAL_NUM_BUCKETS * sizeof(struct UT_hash_bucket));              \\",
            "+                    uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                                                          \\",
            "+                })                                                                                                               \\",
            "+            }                                                                                                                    \\",
            "+        }                                                                                                                        \\",
            "+    } while(0)",
            "+",
            "+#define HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, hashval, add, replaced, cmpfcn)     \\",
            "+    do {                                                                                                     \\",
            "+        (replaced) = NULL;                                                                                   \\",
            "+        HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced);                  \\",
            "+        if(replaced) { HASH_DELETE(hh, head, replaced); }                                                    \\",
            "+        HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn); \\",
            "+    } while(0)",
            "+",
            "+#define HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, hashval, add, replaced)     \\",
            "+    do {                                                                                     \\",
            "+        (replaced) = NULL;                                                                   \\",
            "+        HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced);  \\",
            "+        if(replaced) { HASH_DELETE(hh, head, replaced); }                                    \\",
            "+        HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add); \\",
            "+    } while(0)",
            "+",
            "+#define HASH_REPLACE(hh, head, fieldname, keylen_in, add, replaced)                         \\",
            "+    do {                                                                                    \\",
            "+        unsigned _hr_hashv;                                                                 \\",
            "+        HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                              \\",
            "+        HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced); \\",
            "+    } while(0)",
            "+",
            "+#define HASH_REPLACE_INORDER(hh, head, fieldname, keylen_in, add, replaced, cmpfcn)                         \\",
            "+    do {                                                                                                    \\",
            "+        unsigned _hr_hashv;                                                                                 \\",
            "+        HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                                              \\",
            "+        HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced, cmpfcn); \\",
            "+    } while(0)",
            "+",
            "+#define HASH_APPEND_LIST(hh, head, add)                                      \\",
            "+    do {                                                                     \\",
            "+        (add)->hh.next = NULL;                                               \\",
            "+        (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail); \\",
            "+        (head)->hh.tbl->tail->next = (add);                                  \\",
            "+        (head)->hh.tbl->tail = &((add)->hh);                                 \\",
            "+    } while(0)",
            "+",
            "+#define HASH_AKBI_INNER_LOOP(hh, head, add, cmpfcn)                         \\",
            "+    do {                                                                    \\",
            "+        do {                                                                \\",
            "+            if(cmpfcn(DECLTYPE(head)(_hs_iter), add) > 0) { break; }        \\",
            "+        } while((_hs_iter = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->next)); \\",
            "+    } while(0)",
            " ",
            " #ifdef NO_DECLTYPE",
            "-#undef HASH_AKBI_INNER_LOOP",
            "-#define HASH_AKBI_INNER_LOOP(hh,head,add,cmpfcn)                                 \\",
            "-do {                                                                             \\",
            "-  char *_hs_saved_head = (char*)(head);                                          \\",
            "-  do {                                                                           \\",
            "-    DECLTYPE_ASSIGN(head, _hs_iter);                                             \\",
            "-    if (cmpfcn(head, add) > 0) {                                                 \\",
            "-      DECLTYPE_ASSIGN(head, _hs_saved_head);                                     \\",
            "-      break;                                                                     \\",
            "-    }                                                                            \\",
            "-    DECLTYPE_ASSIGN(head, _hs_saved_head);                                       \\",
            "-  } while ((_hs_iter = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->next));           \\",
            "-} while (0)",
            "+#    undef HASH_AKBI_INNER_LOOP",
            "+#    define HASH_AKBI_INNER_LOOP(hh, head, add, cmpfcn)                         \\",
            "+        do {                                                                    \\",
            "+            char *_hs_saved_head = (char *)(head);                              \\",
            "+            do {                                                                \\",
            "+                DECLTYPE_ASSIGN(head, _hs_iter);                                \\",
            "+                if(cmpfcn(head, add) > 0) {                                     \\",
            "+                    DECLTYPE_ASSIGN(head, _hs_saved_head);                      \\",
            "+                    break;                                                      \\",
            "+                }                                                               \\",
            "+                DECLTYPE_ASSIGN(head, _hs_saved_head);                          \\",
            "+            } while((_hs_iter = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->next)); \\",
            "+        } while(0)",
            " #endif",
            " ",
            " #if HASH_NONFATAL_OOM",
            " ",
            "-#define HASH_ADD_TO_TABLE(hh,head,keyptr,keylen_in,hashval,add,oomed)            \\",
            "-do {                                                                             \\",
            "-  if (!(oomed)) {                                                                \\",
            "-    unsigned _ha_bkt;                                                            \\",
            "-    (head)->hh.tbl->num_items++;                                                 \\",
            "-    HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);                  \\",
            "-    HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], hh, &(add)->hh, oomed);    \\",
            "-    if (oomed) {                                                                 \\",
            "-      HASH_ROLLBACK_BKT(hh, head, &(add)->hh);                                   \\",
            "-      HASH_DELETE_HH(hh, head, &(add)->hh);                                      \\",
            "-      (add)->hh.tbl = NULL;                                                      \\",
            "-      uthash_nonfatal_oom(add);                                                  \\",
            "-    } else {                                                                     \\",
            "-      HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                   \\",
            "-      HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                \\",
            "-    }                                                                            \\",
            "-  } else {                                                                       \\",
            "-    (add)->hh.tbl = NULL;                                                        \\",
            "-    uthash_nonfatal_oom(add);                                                    \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#    define HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, oomed)           \\",
            "+        do {                                                                              \\",
            "+            if(!(oomed)) {                                                                \\",
            "+                unsigned _ha_bkt;                                                         \\",
            "+                (head)->hh.tbl->num_items++;                                              \\",
            "+                HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);               \\",
            "+                HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], hh, &(add)->hh, oomed); \\",
            "+                if(oomed) {                                                               \\",
            "+                    HASH_ROLLBACK_BKT(hh, head, &(add)->hh);                              \\",
            "+                    HASH_DELETE_HH(hh, head, &(add)->hh);                                 \\",
            "+                    (add)->hh.tbl = NULL;                                                 \\",
            "+                    uthash_nonfatal_oom(add);                                             \\",
            "+                } else {                                                                  \\",
            "+                    HASH_BLOOM_ADD((head)->hh.tbl, hashval);                              \\",
            "+                    HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                           \\",
            "+                }                                                                         \\",
            "+            } else {                                                                      \\",
            "+                (add)->hh.tbl = NULL;                                                     \\",
            "+                uthash_nonfatal_oom(add);                                                 \\",
            "+            }                                                                             \\",
            "+        } while(0)",
            " ",
            " #else",
            " ",
            "-#define HASH_ADD_TO_TABLE(hh,head,keyptr,keylen_in,hashval,add,oomed)            \\",
            "-do {                                                                             \\",
            "-  unsigned _ha_bkt;                                                              \\",
            "-  (head)->hh.tbl->num_items++;                                                   \\",
            "-  HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);                    \\",
            "-  HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], hh, &(add)->hh, oomed);      \\",
            "-  HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                       \\",
            "-  HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                    \\",
            "-} while (0)",
            "+#    define HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, oomed)       \\",
            "+        do {                                                                          \\",
            "+            unsigned _ha_bkt;                                                         \\",
            "+            (head)->hh.tbl->num_items++;                                              \\",
            "+            HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);               \\",
            "+            HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], hh, &(add)->hh, oomed); \\",
            "+            HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                  \\",
            "+            HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                               \\",
            "+        } while(0)",
            "+",
            "+#endif",
            "+",
            "+",
            "+#define HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, hashval, add, cmpfcn) \\",
            "+    do {                                                                                       \\",
            "+        IF_HASH_NONFATAL_OOM(int _ha_oomed = 0;)                                               \\",
            "+        (add)->hh.hashv = (hashval);                                                           \\",
            "+        (add)->hh.key = (char *)(keyptr);                                                      \\",
            "+        (add)->hh.keylen = (unsigned)(keylen_in);                                              \\",
            "+        if(!(head)) {                                                                          \\",
            "+            (add)->hh.next = NULL;                                                             \\",
            "+            (add)->hh.prev = NULL;                                                             \\",
            "+            HASH_MAKE_TABLE(hh, add, _ha_oomed);                                               \\",
            "+            IF_HASH_NONFATAL_OOM(if(!_ha_oomed) { )                                    \\",
            "+      (head) = (add);                                                                          \\",
            "+    IF_HASH_NONFATAL_OOM(                                                                      \\",
            "+            })                                                                                 \\",
            "+        } else {                                                                               \\",
            "+            void *_hs_iter = (head);                                                           \\",
            "+            (add)->hh.tbl = (head)->hh.tbl;                                                    \\",
            "+            HASH_AKBI_INNER_LOOP(hh, head, add, cmpfcn);                                       \\",
            "+            if(_hs_iter) {                                                                     \\",
            "+                (add)->hh.next = _hs_iter;                                                     \\",
            "+                if(((add)->hh.prev = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->prev)) {          \\",
            "+                    HH_FROM_ELMT((head)->hh.tbl, (add)->hh.prev)->next = (add);                \\",
            "+                } else {                                                                       \\",
            "+                    (head) = (add);                                                            \\",
            "+                }                                                                              \\",
            "+                HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->prev = (add);                          \\",
            "+            } else {                                                                           \\",
            "+                HASH_APPEND_LIST(hh, head, add);                                               \\",
            "+            }                                                                                  \\",
            "+        }                                                                                      \\",
            "+        HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, _ha_oomed);               \\",
            "+        HASH_FSCK(hh, head, \"HASH_ADD_KEYPTR_BYHASHVALUE_INORDER\");                            \\",
            "+    } while(0)",
            "+",
            "+#define HASH_ADD_KEYPTR_INORDER(hh, head, keyptr, keylen_in, add, cmpfcn)                         \\",
            "+    do {                                                                                          \\",
            "+        unsigned _hs_hashv;                                                                       \\",
            "+        HASH_VALUE(keyptr, keylen_in, _hs_hashv);                                                 \\",
            "+        HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, _hs_hashv, add, cmpfcn); \\",
            "+    } while(0)",
            "+",
            "+#define HASH_ADD_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, hashval, add, cmpfcn) \\",
            "+    HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn)",
            "+",
            "+#define HASH_ADD_INORDER(hh, head, fieldname, keylen_in, add, cmpfcn) \\",
            "+    HASH_ADD_KEYPTR_INORDER(hh, head, &((add)->fieldname), keylen_in, add, cmpfcn)",
            "+",
            "+#define HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, hashval, add)   \\",
            "+    do {                                                                         \\",
            "+        IF_HASH_NONFATAL_OOM(int _ha_oomed = 0;)                                 \\",
            "+        (add)->hh.hashv = (hashval);                                             \\",
            "+        (add)->hh.key = (const void *)(keyptr);                                  \\",
            "+        (add)->hh.keylen = (unsigned)(keylen_in);                                \\",
            "+        if(!(head)) {                                                            \\",
            "+            (add)->hh.next = NULL;                                               \\",
            "+            (add)->hh.prev = NULL;                                               \\",
            "+            HASH_MAKE_TABLE(hh, add, _ha_oomed);                                 \\",
            "+            IF_HASH_NONFATAL_OOM(if(!_ha_oomed) { )                                    \\",
            "+      (head) = (add);                                                            \\",
            "+    IF_HASH_NONFATAL_OOM(                                                        \\",
            "+            })                                                                   \\",
            "+        } else {                                                                 \\",
            "+            (add)->hh.tbl = (head)->hh.tbl;                                      \\",
            "+            HASH_APPEND_LIST(hh, head, add);                                     \\",
            "+        }                                                                        \\",
            "+        HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, _ha_oomed); \\",
            "+        HASH_FSCK(hh, head, \"HASH_ADD_KEYPTR_BYHASHVALUE\");                      \\",
            "+    } while(0)",
            "+",
            "+#define HASH_ADD_KEYPTR(hh, head, keyptr, keylen_in, add)                         \\",
            "+    do {                                                                          \\",
            "+        unsigned _ha_hashv;                                                       \\",
            "+        HASH_VALUE(keyptr, keylen_in, _ha_hashv);                                 \\",
            "+        HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, _ha_hashv, add); \\",
            "+    } while(0)",
            " ",
            "-#endif",
            "+#define HASH_ADD_BYHASHVALUE(hh, head, fieldname, keylen_in, hashval, add) \\",
            "+    HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add)",
            " ",
            "+#define HASH_ADD(hh, head, fieldname, keylen_in, add) HASH_ADD_KEYPTR(hh, head, &((add)->fieldname), keylen_in, add)",
            " ",
            "-#define HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh,head,keyptr,keylen_in,hashval,add,cmpfcn) \\",
            "-do {                                                                             \\",
            "-  IF_HASH_NONFATAL_OOM( int _ha_oomed = 0; )                                     \\",
            "-  (add)->hh.hashv = (hashval);                                                   \\",
            "-  (add)->hh.key = (char*) (keyptr);                                              \\",
            "-  (add)->hh.keylen = (unsigned) (keylen_in);                                     \\",
            "-  if (!(head)) {                                                                 \\",
            "-    (add)->hh.next = NULL;                                                       \\",
            "-    (add)->hh.prev = NULL;                                                       \\",
            "-    HASH_MAKE_TABLE(hh, add, _ha_oomed);                                         \\",
            "-    IF_HASH_NONFATAL_OOM( if (!_ha_oomed) { )                                    \\",
            "-      (head) = (add);                                                            \\",
            "-    IF_HASH_NONFATAL_OOM( } )                                                    \\",
            "-  } else {                                                                       \\",
            "-    void *_hs_iter = (head);                                                     \\",
            "-    (add)->hh.tbl = (head)->hh.tbl;                                              \\",
            "-    HASH_AKBI_INNER_LOOP(hh, head, add, cmpfcn);                                 \\",
            "-    if (_hs_iter) {                                                              \\",
            "-      (add)->hh.next = _hs_iter;                                                 \\",
            "-      if (((add)->hh.prev = HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->prev)) {     \\",
            "-        HH_FROM_ELMT((head)->hh.tbl, (add)->hh.prev)->next = (add);              \\",
            "-      } else {                                                                   \\",
            "-        (head) = (add);                                                          \\",
            "-      }                                                                          \\",
            "-      HH_FROM_ELMT((head)->hh.tbl, _hs_iter)->prev = (add);                      \\",
            "-    } else {                                                                     \\",
            "-      HASH_APPEND_LIST(hh, head, add);                                           \\",
            "-    }                                                                            \\",
            "-  }                                                                              \\",
            "-  HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, _ha_oomed);       \\",
            "-  HASH_FSCK(hh, head, \"HASH_ADD_KEYPTR_BYHASHVALUE_INORDER\");                    \\",
            "-} while (0)",
            "-",
            "-#define HASH_ADD_KEYPTR_INORDER(hh,head,keyptr,keylen_in,add,cmpfcn)             \\",
            "-do {                                                                             \\",
            "-  unsigned _hs_hashv;                                                            \\",
            "-  HASH_VALUE(keyptr, keylen_in, _hs_hashv);                                      \\",
            "-  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, _hs_hashv, add, cmpfcn); \\",
            "-} while (0)",
            "-",
            "-#define HASH_ADD_BYHASHVALUE_INORDER(hh,head,fieldname,keylen_in,hashval,add,cmpfcn) \\",
            "-  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn)",
            "-",
            "-#define HASH_ADD_INORDER(hh,head,fieldname,keylen_in,add,cmpfcn)                 \\",
            "-  HASH_ADD_KEYPTR_INORDER(hh, head, &((add)->fieldname), keylen_in, add, cmpfcn)",
            "-",
            "-#define HASH_ADD_KEYPTR_BYHASHVALUE(hh,head,keyptr,keylen_in,hashval,add)        \\",
            "-do {                                                                             \\",
            "-  IF_HASH_NONFATAL_OOM( int _ha_oomed = 0; )                                     \\",
            "-  (add)->hh.hashv = (hashval);                                                   \\",
            "-  (add)->hh.key = (const void*) (keyptr);                                        \\",
            "-  (add)->hh.keylen = (unsigned) (keylen_in);                                     \\",
            "-  if (!(head)) {                                                                 \\",
            "-    (add)->hh.next = NULL;                                                       \\",
            "-    (add)->hh.prev = NULL;                                                       \\",
            "-    HASH_MAKE_TABLE(hh, add, _ha_oomed);                                         \\",
            "-    IF_HASH_NONFATAL_OOM( if (!_ha_oomed) { )                                    \\",
            "-      (head) = (add);                                                            \\",
            "-    IF_HASH_NONFATAL_OOM( } )                                                    \\",
            "-  } else {                                                                       \\",
            "-    (add)->hh.tbl = (head)->hh.tbl;                                              \\",
            "-    HASH_APPEND_LIST(hh, head, add);                                             \\",
            "-  }                                                                              \\",
            "-  HASH_ADD_TO_TABLE(hh, head, keyptr, keylen_in, hashval, add, _ha_oomed);       \\",
            "-  HASH_FSCK(hh, head, \"HASH_ADD_KEYPTR_BYHASHVALUE\");                            \\",
            "-} while (0)",
            "-",
            "-#define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                            \\",
            "-do {                                                                             \\",
            "-  unsigned _ha_hashv;                                                            \\",
            "-  HASH_VALUE(keyptr, keylen_in, _ha_hashv);                                      \\",
            "-  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, _ha_hashv, add);      \\",
            "-} while (0)",
            "-",
            "-#define HASH_ADD_BYHASHVALUE(hh,head,fieldname,keylen_in,hashval,add)            \\",
            "-  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add)",
            "-",
            "-#define HASH_ADD(hh,head,fieldname,keylen_in,add)                                \\",
            "-  HASH_ADD_KEYPTR(hh, head, &((add)->fieldname), keylen_in, add)",
            "-",
            "-#define HASH_TO_BKT(hashv,num_bkts,bkt)                                          \\",
            "-do {                                                                             \\",
            "-  bkt = ((hashv) & ((num_bkts) - 1U));                                           \\",
            "-} while (0)",
            "+#define HASH_TO_BKT(hashv, num_bkts, bkt) \\",
            "+    do { bkt = ((hashv) & ((num_bkts) - 1U)); } while(0)",
            " ",
            " /* delete \"delptr\" from the hash table.",
            "  * \"the usual\" patch-up process for the app-order doubly-linked-list.",
            "  * The use of _hd_hh_del below deserves special explanation.",
            "  * These used to be expressed using (delptr) but that led to a bug",
            "  * if someone used the same symbol for the head and deletee, like",
            "  *  HASH_DELETE(hh,users,users);",
            "  * We want that to work, but by changing the head (users) below",
            "  * we were forfeiting our ability to further refer to the deletee (users)",
            "  * in the patch-up process. Solution: use scratch space to",
            "  * copy the deletee pointer, then the latter references are via that",
            "  * scratch pointer rather than through the repointed (users) symbol.",
            "  */",
            "-#define HASH_DELETE(hh,head,delptr)                                              \\",
            "-    HASH_DELETE_HH(hh, head, &(delptr)->hh)",
            "+#define HASH_DELETE(hh, head, delptr) HASH_DELETE_HH(hh, head, &(delptr)->hh)",
            " ",
            "-#define HASH_DELETE_HH(hh,head,delptrhh)                                         \\",
            "-do {                                                                             \\",
            "-  struct UT_hash_handle *_hd_hh_del = (delptrhh);                                \\",
            "-  if ((_hd_hh_del->prev == NULL) && (_hd_hh_del->next == NULL)) {                \\",
            "-    HASH_BLOOM_FREE((head)->hh.tbl);                                             \\",
            "-    uthash_free((head)->hh.tbl->buckets,                                         \\",
            "-                (head)->hh.tbl->num_buckets * sizeof(struct UT_hash_bucket));    \\",
            "-    uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                          \\",
            "-    (head) = NULL;                                                               \\",
            "-  } else {                                                                       \\",
            "-    unsigned _hd_bkt;                                                            \\",
            "-    if (_hd_hh_del == (head)->hh.tbl->tail) {                                    \\",
            "-      (head)->hh.tbl->tail = HH_FROM_ELMT((head)->hh.tbl, _hd_hh_del->prev);     \\",
            "-    }                                                                            \\",
            "-    if (_hd_hh_del->prev != NULL) {                                              \\",
            "-      HH_FROM_ELMT((head)->hh.tbl, _hd_hh_del->prev)->next = _hd_hh_del->next;   \\",
            "-    } else {                                                                     \\",
            "-      DECLTYPE_ASSIGN(head, _hd_hh_del->next);                                   \\",
            "-    }                                                                            \\",
            "-    if (_hd_hh_del->next != NULL) {                                              \\",
            "-      HH_FROM_ELMT((head)->hh.tbl, _hd_hh_del->next)->prev = _hd_hh_del->prev;   \\",
            "-    }                                                                            \\",
            "-    HASH_TO_BKT(_hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt);        \\",
            "-    HASH_DEL_IN_BKT((head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del);               \\",
            "-    (head)->hh.tbl->num_items--;                                                 \\",
            "-  }                                                                              \\",
            "-  HASH_FSCK(hh, head, \"HASH_DELETE_HH\");                                         \\",
            "-} while (0)",
            "+#define HASH_DELETE_HH(hh, head, delptrhh)                                                                                    \\",
            "+    do {                                                                                                                      \\",
            "+        struct UT_hash_handle *_hd_hh_del = (delptrhh);                                                                       \\",
            "+        if((_hd_hh_del->prev == NULL) && (_hd_hh_del->next == NULL)) {                                                        \\",
            "+            HASH_BLOOM_FREE((head)->hh.tbl);                                                                                  \\",
            "+            uthash_free((head)->hh.tbl->buckets, (head)->hh.tbl->num_buckets * sizeof(struct UT_hash_bucket));                \\",
            "+            uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                                                               \\",
            "+            (head) = NULL;                                                                                                    \\",
            "+        } else {                                                                                                              \\",
            "+            unsigned _hd_bkt;                                                                                                 \\",
            "+            if(_hd_hh_del == (head)->hh.tbl->tail) { (head)->hh.tbl->tail = HH_FROM_ELMT((head)->hh.tbl, _hd_hh_del->prev); } \\",
            "+            if(_hd_hh_del->prev != NULL) {                                                                                    \\",
            "+                HH_FROM_ELMT((head)->hh.tbl, _hd_hh_del->prev)->next = _hd_hh_del->next;                                      \\",
            "+            } else {                                                                                                          \\",
            "+                DECLTYPE_ASSIGN(head, _hd_hh_del->next);                                                                      \\",
            "+            }                                                                                                                 \\",
            "+            if(_hd_hh_del->next != NULL) { HH_FROM_ELMT((head)->hh.tbl, _hd_hh_del->next)->prev = _hd_hh_del->prev; }         \\",
            "+            HASH_TO_BKT(_hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt);                                             \\",
            "+            HASH_DEL_IN_BKT((head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del);                                                    \\",
            "+            (head)->hh.tbl->num_items--;                                                                                      \\",
            "+        }                                                                                                                     \\",
            "+        HASH_FSCK(hh, head, \"HASH_DELETE_HH\");                                                                                \\",
            "+    } while(0)",
            " ",
            " /* convenience forms of HASH_FIND/HASH_ADD/HASH_DEL */",
            "-#define HASH_FIND_STR(head,findstr,out)                                          \\",
            "-do {                                                                             \\",
            "-    unsigned _uthash_hfstr_keylen = (unsigned)uthash_strlen(findstr);            \\",
            "-    HASH_FIND(hh, head, findstr, _uthash_hfstr_keylen, out);                     \\",
            "-} while (0)",
            "-#define HASH_ADD_STR(head,strfield,add)                                          \\",
            "-do {                                                                             \\",
            "-    unsigned _uthash_hastr_keylen = (unsigned)uthash_strlen((add)->strfield);    \\",
            "-    HASH_ADD(hh, head, strfield[0], _uthash_hastr_keylen, add);                  \\",
            "-} while (0)",
            "-#define HASH_REPLACE_STR(head,strfield,add,replaced)                             \\",
            "-do {                                                                             \\",
            "-    unsigned _uthash_hrstr_keylen = (unsigned)uthash_strlen((add)->strfield);    \\",
            "-    HASH_REPLACE(hh, head, strfield[0], _uthash_hrstr_keylen, add, replaced);    \\",
            "-} while (0)",
            "-#define HASH_FIND_INT(head,findint,out)                                          \\",
            "-    HASH_FIND(hh,head,findint,sizeof(int),out)",
            "-#define HASH_ADD_INT(head,intfield,add)                                          \\",
            "-    HASH_ADD(hh,head,intfield,sizeof(int),add)",
            "-#define HASH_REPLACE_INT(head,intfield,add,replaced)                             \\",
            "-    HASH_REPLACE(hh,head,intfield,sizeof(int),add,replaced)",
            "-#define HASH_FIND_PTR(head,findptr,out)                                          \\",
            "-    HASH_FIND(hh,head,findptr,sizeof(void *),out)",
            "-#define HASH_ADD_PTR(head,ptrfield,add)                                          \\",
            "-    HASH_ADD(hh,head,ptrfield,sizeof(void *),add)",
            "-#define HASH_REPLACE_PTR(head,ptrfield,add,replaced)                             \\",
            "-    HASH_REPLACE(hh,head,ptrfield,sizeof(void *),add,replaced)",
            "-#define HASH_DEL(head,delptr)                                                    \\",
            "-    HASH_DELETE(hh,head,delptr)",
            "+#define HASH_FIND_STR(head, findstr, out)                                 \\",
            "+    do {                                                                  \\",
            "+        unsigned _uthash_hfstr_keylen = (unsigned)uthash_strlen(findstr); \\",
            "+        HASH_FIND(hh, head, findstr, _uthash_hfstr_keylen, out);          \\",
            "+    } while(0)",
            "+#define HASH_ADD_STR(head, strfield, add)                                         \\",
            "+    do {                                                                          \\",
            "+        unsigned _uthash_hastr_keylen = (unsigned)uthash_strlen((add)->strfield); \\",
            "+        HASH_ADD(hh, head, strfield[0], _uthash_hastr_keylen, add);               \\",
            "+    } while(0)",
            "+#define HASH_REPLACE_STR(head, strfield, add, replaced)                           \\",
            "+    do {                                                                          \\",
            "+        unsigned _uthash_hrstr_keylen = (unsigned)uthash_strlen((add)->strfield); \\",
            "+        HASH_REPLACE(hh, head, strfield[0], _uthash_hrstr_keylen, add, replaced); \\",
            "+    } while(0)",
            "+#define HASH_FIND_INT(head, findint, out) HASH_FIND(hh, head, findint, sizeof(int), out)",
            "+#define HASH_ADD_INT(head, intfield, add) HASH_ADD(hh, head, intfield, sizeof(int), add)",
            "+#define HASH_REPLACE_INT(head, intfield, add, replaced) HASH_REPLACE(hh, head, intfield, sizeof(int), add, replaced)",
            "+#define HASH_FIND_PTR(head, findptr, out) HASH_FIND(hh, head, findptr, sizeof(void *), out)",
            "+#define HASH_ADD_PTR(head, ptrfield, add) HASH_ADD(hh, head, ptrfield, sizeof(void *), add)",
            "+#define HASH_REPLACE_PTR(head, ptrfield, add, replaced) HASH_REPLACE(hh, head, ptrfield, sizeof(void *), add, replaced)",
            "+#define HASH_DEL(head, delptr) HASH_DELETE(hh, head, delptr)",
            " ",
            " /* HASH_FSCK checks hash integrity on every add/delete when HASH_DEBUG is defined.",
            "  * This is for uthash developer only; it compiles away if HASH_DEBUG isn't defined.",
            "  */",
            " #ifdef HASH_DEBUG",
            "-#include <stdio.h>   /* fprintf, stderr */",
            "-#define HASH_OOPS(...) do { fprintf(stderr, __VA_ARGS__); exit(-1); } while (0)",
            "-#define HASH_FSCK(hh,head,where)                                                 \\",
            "-do {                                                                             \\",
            "-  struct UT_hash_handle *_thh;                                                   \\",
            "-  if (head) {                                                                    \\",
            "-    unsigned _bkt_i;                                                             \\",
            "-    unsigned _count = 0;                                                         \\",
            "-    char *_prev;                                                                 \\",
            "-    for (_bkt_i = 0; _bkt_i < (head)->hh.tbl->num_buckets; ++_bkt_i) {           \\",
            "-      unsigned _bkt_count = 0;                                                   \\",
            "-      _thh = (head)->hh.tbl->buckets[_bkt_i].hh_head;                            \\",
            "-      _prev = NULL;                                                              \\",
            "-      while (_thh) {                                                             \\",
            "-        if (_prev != (char*)(_thh->hh_prev)) {                                   \\",
            "-          HASH_OOPS(\"%s: invalid hh_prev %p, actual %p\\n\",                       \\",
            "-              (where), (void*)_thh->hh_prev, (void*)_prev);                      \\",
            "-        }                                                                        \\",
            "-        _bkt_count++;                                                            \\",
            "-        _prev = (char*)(_thh);                                                   \\",
            "-        _thh = _thh->hh_next;                                                    \\",
            "-      }                                                                          \\",
            "-      _count += _bkt_count;                                                      \\",
            "-      if ((head)->hh.tbl->buckets[_bkt_i].count !=  _bkt_count) {                \\",
            "-        HASH_OOPS(\"%s: invalid bucket count %u, actual %u\\n\",                    \\",
            "-            (where), (head)->hh.tbl->buckets[_bkt_i].count, _bkt_count);         \\",
            "-      }                                                                          \\",
            "-    }                                                                            \\",
            "-    if (_count != (head)->hh.tbl->num_items) {                                   \\",
            "-      HASH_OOPS(\"%s: invalid hh item count %u, actual %u\\n\",                     \\",
            "-          (where), (head)->hh.tbl->num_items, _count);                           \\",
            "-    }                                                                            \\",
            "-    _count = 0;                                                                  \\",
            "-    _prev = NULL;                                                                \\",
            "-    _thh =  &(head)->hh;                                                         \\",
            "-    while (_thh) {                                                               \\",
            "-      _count++;                                                                  \\",
            "-      if (_prev != (char*)_thh->prev) {                                          \\",
            "-        HASH_OOPS(\"%s: invalid prev %p, actual %p\\n\",                            \\",
            "-            (where), (void*)_thh->prev, (void*)_prev);                           \\",
            "-      }                                                                          \\",
            "-      _prev = (char*)ELMT_FROM_HH((head)->hh.tbl, _thh);                         \\",
            "-      _thh = (_thh->next ? HH_FROM_ELMT((head)->hh.tbl, _thh->next) : NULL);     \\",
            "-    }                                                                            \\",
            "-    if (_count != (head)->hh.tbl->num_items) {                                   \\",
            "-      HASH_OOPS(\"%s: invalid app item count %u, actual %u\\n\",                    \\",
            "-          (where), (head)->hh.tbl->num_items, _count);                           \\",
            "-    }                                                                            \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#    include <stdio.h> /* fprintf, stderr */",
            "+#    define HASH_OOPS(...)                \\",
            "+        do {                              \\",
            "+            fprintf(stderr, __VA_ARGS__); \\",
            "+            exit(-1);                     \\",
            "+        } while(0)",
            "+",
            "+#    define HASH_FSCK(hh, head, where)                                                                                        \\",
            "+        do {                                                                                                                  \\",
            "+            struct UT_hash_handle *_thh;                                                                                      \\",
            "+            if(head) {                                                                                                        \\",
            "+                unsigned _bkt_i;                                                                                              \\",
            "+                unsigned _count = 0;                                                                                          \\",
            "+                char *_prev;                                                                                                  \\",
            "+                for(_bkt_i = 0; _bkt_i < (head)->hh.tbl->num_buckets; ++_bkt_i) {                                             \\",
            "+                    unsigned _bkt_count = 0;                                                                                  \\",
            "+                    _thh = (head)->hh.tbl->buckets[_bkt_i].hh_head;                                                           \\",
            "+                    _prev = NULL;                                                                                             \\",
            "+                    while(_thh) {                                                                                             \\",
            "+                        if(_prev != (char *)(_thh->hh_prev)) {                                                                \\",
            "+                            HASH_OOPS(\"%s: invalid hh_prev %p, actual %p\\n\", (where), (void *)_thh->hh_prev, (void *)_prev);  \\",
            "+                        }                                                                                                     \\",
            "+                        _bkt_count++;                                                                                         \\",
            "+                        _prev = (char *)(_thh);                                                                               \\",
            "+                        _thh = _thh->hh_next;                                                                                 \\",
            "+                    }                                                                                                         \\",
            "+                    _count += _bkt_count;                                                                                     \\",
            "+                    if((head)->hh.tbl->buckets[_bkt_i].count != _bkt_count) {                                                 \\",
            "+                        HASH_OOPS(\"%s: invalid bucket count %u, actual %u\\n\", (where), (head)->hh.tbl->buckets[_bkt_i].count, \\",
            "+                                  _bkt_count);                                                                                \\",
            "+                    }                                                                                                         \\",
            "+                }                                                                                                             \\",
            "+                if(_count != (head)->hh.tbl->num_items) {                                                                     \\",
            "+                    HASH_OOPS(\"%s: invalid hh item count %u, actual %u\\n\", (where), (head)->hh.tbl->num_items, _count);       \\",
            "+                }                                                                                                             \\",
            "+                _count = 0;                                                                                                   \\",
            "+                _prev = NULL;                                                                                                 \\",
            "+                _thh = &(head)->hh;                                                                                           \\",
            "+                while(_thh) {                                                                                                 \\",
            "+                    _count++;                                                                                                 \\",
            "+                    if(_prev != (char *)_thh->prev) {                                                                         \\",
            "+                        HASH_OOPS(\"%s: invalid prev %p, actual %p\\n\", (where), (void *)_thh->prev, (void *)_prev);            \\",
            "+                    }                                                                                                         \\",
            "+                    _prev = (char *)ELMT_FROM_HH((head)->hh.tbl, _thh);                                                       \\",
            "+                    _thh = (_thh->next ? HH_FROM_ELMT((head)->hh.tbl, _thh->next) : NULL);                                    \\",
            "+                }                                                                                                             \\",
            "+                if(_count != (head)->hh.tbl->num_items) {                                                                     \\",
            "+                    HASH_OOPS(\"%s: invalid app item count %u, actual %u\\n\", (where), (head)->hh.tbl->num_items, _count);      \\",
            "+                }                                                                                                             \\",
            "+            }                                                                                                                 \\",
            "+        } while(0)",
            " #else",
            "-#define HASH_FSCK(hh,head,where)",
            "+#    define HASH_FSCK(hh, head, where)",
            " #endif",
            " ",
            " /* When compiled with -DHASH_EMIT_KEYS, length-prefixed keys are emitted to",
            "  * the descriptor to which this macro is defined for tuning the hash function.",
            "  * The app can #include <unistd.h> to get the prototype for write(2). */",
            " #ifdef HASH_EMIT_KEYS",
            "-#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                                   \\",
            "-do {                                                                             \\",
            "-  unsigned _klen = fieldlen;                                                     \\",
            "-  write(HASH_EMIT_KEYS, &_klen, sizeof(_klen));                                  \\",
            "-  write(HASH_EMIT_KEYS, keyptr, (unsigned long)fieldlen);                        \\",
            "-} while (0)",
            "+#    define HASH_EMIT_KEY(hh, head, keyptr, fieldlen)               \\",
            "+        do {                                                        \\",
            "+            unsigned _klen = fieldlen;                              \\",
            "+            write(HASH_EMIT_KEYS, &_klen, sizeof(_klen));           \\",
            "+            write(HASH_EMIT_KEYS, keyptr, (unsigned long)fieldlen); \\",
            "+        } while(0)",
            " #else",
            "-#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)",
            "+#    define HASH_EMIT_KEY(hh, head, keyptr, fieldlen)",
            " #endif",
            " ",
            " /* The Bernstein hash function, used in Perl prior to v5.6. Note (x<<5+x)=x*33. */",
            "-#define HASH_BER(key,keylen,hashv)                                               \\",
            "-do {                                                                             \\",
            "-  unsigned _hb_keylen = (unsigned)keylen;                                        \\",
            "-  const unsigned char *_hb_key = (const unsigned char*)(key);                    \\",
            "-  (hashv) = 0;                                                                   \\",
            "-  while (_hb_keylen-- != 0U) {                                                   \\",
            "-    (hashv) = (((hashv) << 5) + (hashv)) + *_hb_key++;                           \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_BER(key, keylen, hashv)                                                     \\",
            "+    do {                                                                                 \\",
            "+        unsigned _hb_keylen = (unsigned)keylen;                                          \\",
            "+        const unsigned char *_hb_key = (const unsigned char *)(key);                     \\",
            "+        (hashv) = 0;                                                                     \\",
            "+        while(_hb_keylen-- != 0U) { (hashv) = (((hashv) << 5) + (hashv)) + *_hb_key++; } \\",
            "+    } while(0)",
            " ",
            " ",
            " /* SAX/FNV/OAT/JEN hash functions are macro variants of those listed at",
            "  * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx */",
            "-#define HASH_SAX(key,keylen,hashv)                                               \\",
            "-do {                                                                             \\",
            "-  unsigned _sx_i;                                                                \\",
            "-  const unsigned char *_hs_key = (const unsigned char*)(key);                    \\",
            "-  hashv = 0;                                                                     \\",
            "-  for (_sx_i=0; _sx_i < keylen; _sx_i++) {                                       \\",
            "-    hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                       \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_SAX(key, keylen, hashv)                                                                       \\",
            "+    do {                                                                                                   \\",
            "+        unsigned _sx_i;                                                                                    \\",
            "+        const unsigned char *_hs_key = (const unsigned char *)(key);                                       \\",
            "+        hashv = 0;                                                                                         \\",
            "+        for(_sx_i = 0; _sx_i < keylen; _sx_i++) { hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i]; } \\",
            "+    } while(0)",
            " /* FNV-1a variation */",
            "-#define HASH_FNV(key,keylen,hashv)                                               \\",
            "-do {                                                                             \\",
            "-  unsigned _fn_i;                                                                \\",
            "-  const unsigned char *_hf_key = (const unsigned char*)(key);                    \\",
            "-  (hashv) = 2166136261U;                                                         \\",
            "-  for (_fn_i=0; _fn_i < keylen; _fn_i++) {                                       \\",
            "-    hashv = hashv ^ _hf_key[_fn_i];                                              \\",
            "-    hashv = hashv * 16777619U;                                                   \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "-",
            "-#define HASH_OAT(key,keylen,hashv)                                               \\",
            "-do {                                                                             \\",
            "-  unsigned _ho_i;                                                                \\",
            "-  const unsigned char *_ho_key=(const unsigned char*)(key);                      \\",
            "-  hashv = 0;                                                                     \\",
            "-  for(_ho_i=0; _ho_i < keylen; _ho_i++) {                                        \\",
            "-      hashv += _ho_key[_ho_i];                                                   \\",
            "-      hashv += (hashv << 10);                                                    \\",
            "-      hashv ^= (hashv >> 6);                                                     \\",
            "-  }                                                                              \\",
            "-  hashv += (hashv << 3);                                                         \\",
            "-  hashv ^= (hashv >> 11);                                                        \\",
            "-  hashv += (hashv << 15);                                                        \\",
            "-} while (0)",
            "-",
            "-#define HASH_JEN_MIX(a,b,c)                                                      \\",
            "-do {                                                                             \\",
            "-  a -= b; a -= c; a ^= ( c >> 13 );                                              \\",
            "-  b -= c; b -= a; b ^= ( a << 8 );                                               \\",
            "-  c -= a; c -= b; c ^= ( b >> 13 );                                              \\",
            "-  a -= b; a -= c; a ^= ( c >> 12 );                                              \\",
            "-  b -= c; b -= a; b ^= ( a << 16 );                                              \\",
            "-  c -= a; c -= b; c ^= ( b >> 5 );                                               \\",
            "-  a -= b; a -= c; a ^= ( c >> 3 );                                               \\",
            "-  b -= c; b -= a; b ^= ( a << 10 );                                              \\",
            "-  c -= a; c -= b; c ^= ( b >> 15 );                                              \\",
            "-} while (0)",
            "-",
            "-#define HASH_JEN(key,keylen,hashv)                                               \\",
            "-do {                                                                             \\",
            "-  unsigned _hj_i,_hj_j,_hj_k;                                                    \\",
            "-  unsigned const char *_hj_key=(unsigned const char*)(key);                      \\",
            "-  hashv = 0xfeedbeefu;                                                           \\",
            "-  _hj_i = _hj_j = 0x9e3779b9u;                                                   \\",
            "-  _hj_k = (unsigned)(keylen);                                                    \\",
            "-  while (_hj_k >= 12U) {                                                         \\",
            "-    _hj_i +=    (_hj_key[0] + ( (unsigned)_hj_key[1] << 8 )                      \\",
            "-        + ( (unsigned)_hj_key[2] << 16 )                                         \\",
            "-        + ( (unsigned)_hj_key[3] << 24 ) );                                      \\",
            "-    _hj_j +=    (_hj_key[4] + ( (unsigned)_hj_key[5] << 8 )                      \\",
            "-        + ( (unsigned)_hj_key[6] << 16 )                                         \\",
            "-        + ( (unsigned)_hj_key[7] << 24 ) );                                      \\",
            "-    hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] << 8 )                         \\",
            "-        + ( (unsigned)_hj_key[10] << 16 )                                        \\",
            "-        + ( (unsigned)_hj_key[11] << 24 ) );                                     \\",
            "-                                                                                 \\",
            "-     HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                          \\",
            "-                                                                                 \\",
            "-     _hj_key += 12;                                                              \\",
            "-     _hj_k -= 12U;                                                               \\",
            "-  }                                                                              \\",
            "-  hashv += (unsigned)(keylen);                                                   \\",
            "-  switch ( _hj_k ) {                                                             \\",
            "-    case 11: hashv += ( (unsigned)_hj_key[10] << 24 ); /* FALLTHROUGH */         \\",
            "-    case 10: hashv += ( (unsigned)_hj_key[9] << 16 );  /* FALLTHROUGH */         \\",
            "-    case 9:  hashv += ( (unsigned)_hj_key[8] << 8 );   /* FALLTHROUGH */         \\",
            "-    case 8:  _hj_j += ( (unsigned)_hj_key[7] << 24 );  /* FALLTHROUGH */         \\",
            "-    case 7:  _hj_j += ( (unsigned)_hj_key[6] << 16 );  /* FALLTHROUGH */         \\",
            "-    case 6:  _hj_j += ( (unsigned)_hj_key[5] << 8 );   /* FALLTHROUGH */         \\",
            "-    case 5:  _hj_j += _hj_key[4];                      /* FALLTHROUGH */         \\",
            "-    case 4:  _hj_i += ( (unsigned)_hj_key[3] << 24 );  /* FALLTHROUGH */         \\",
            "-    case 3:  _hj_i += ( (unsigned)_hj_key[2] << 16 );  /* FALLTHROUGH */         \\",
            "-    case 2:  _hj_i += ( (unsigned)_hj_key[1] << 8 );   /* FALLTHROUGH */         \\",
            "-    case 1:  _hj_i += _hj_key[0];                      /* FALLTHROUGH */         \\",
            "-    default: ;                                                                   \\",
            "-  }                                                                              \\",
            "-  HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                             \\",
            "-} while (0)",
            "+#define HASH_FNV(key, keylen, hashv)                                 \\",
            "+    do {                                                             \\",
            "+        unsigned _fn_i;                                              \\",
            "+        const unsigned char *_hf_key = (const unsigned char *)(key); \\",
            "+        (hashv) = 2166136261U;                                       \\",
            "+        for(_fn_i = 0; _fn_i < keylen; _fn_i++) {                    \\",
            "+            hashv = hashv ^ _hf_key[_fn_i];                          \\",
            "+            hashv = hashv * 16777619U;                               \\",
            "+        }                                                            \\",
            "+    } while(0)",
            "+",
            "+#define HASH_OAT(key, keylen, hashv)                                 \\",
            "+    do {                                                             \\",
            "+        unsigned _ho_i;                                              \\",
            "+        const unsigned char *_ho_key = (const unsigned char *)(key); \\",
            "+        hashv = 0;                                                   \\",
            "+        for(_ho_i = 0; _ho_i < keylen; _ho_i++) {                    \\",
            "+            hashv += _ho_key[_ho_i];                                 \\",
            "+            hashv += (hashv << 10);                                  \\",
            "+            hashv ^= (hashv >> 6);                                   \\",
            "+        }                                                            \\",
            "+        hashv += (hashv << 3);                                       \\",
            "+        hashv ^= (hashv >> 11);                                      \\",
            "+        hashv += (hashv << 15);                                      \\",
            "+    } while(0)",
            "+",
            "+#define HASH_JEN_MIX(a, b, c) \\",
            "+    do {                      \\",
            "+        a -= b;               \\",
            "+        a -= c;               \\",
            "+        a ^= (c >> 13);       \\",
            "+        b -= c;               \\",
            "+        b -= a;               \\",
            "+        b ^= (a << 8);        \\",
            "+        c -= a;               \\",
            "+        c -= b;               \\",
            "+        c ^= (b >> 13);       \\",
            "+        a -= b;               \\",
            "+        a -= c;               \\",
            "+        a ^= (c >> 12);       \\",
            "+        b -= c;               \\",
            "+        b -= a;               \\",
            "+        b ^= (a << 16);       \\",
            "+        c -= a;               \\",
            "+        c -= b;               \\",
            "+        c ^= (b >> 5);        \\",
            "+        a -= b;               \\",
            "+        a -= c;               \\",
            "+        a ^= (c >> 3);        \\",
            "+        b -= c;               \\",
            "+        b -= a;               \\",
            "+        b ^= (a << 10);       \\",
            "+        c -= a;               \\",
            "+        c -= b;               \\",
            "+        c ^= (b >> 15);       \\",
            "+    } while(0)",
            "+",
            "+#define HASH_JEN(key, keylen, hashv)                                                                                             \\",
            "+    do {                                                                                                                         \\",
            "+        unsigned _hj_i, _hj_j, _hj_k;                                                                                            \\",
            "+        unsigned const char *_hj_key = (unsigned const char *)(key);                                                             \\",
            "+        hashv = 0xfeedbeefu;                                                                                                     \\",
            "+        _hj_i = _hj_j = 0x9e3779b9u;                                                                                             \\",
            "+        _hj_k = (unsigned)(keylen);                                                                                              \\",
            "+        while(_hj_k >= 12U) {                                                                                                    \\",
            "+            _hj_i += (_hj_key[0] + ((unsigned)_hj_key[1] << 8) + ((unsigned)_hj_key[2] << 16) + ((unsigned)_hj_key[3] << 24));   \\",
            "+            _hj_j += (_hj_key[4] + ((unsigned)_hj_key[5] << 8) + ((unsigned)_hj_key[6] << 16) + ((unsigned)_hj_key[7] << 24));   \\",
            "+            hashv += (_hj_key[8] + ((unsigned)_hj_key[9] << 8) + ((unsigned)_hj_key[10] << 16) + ((unsigned)_hj_key[11] << 24)); \\",
            "+                                                                                                                                 \\",
            "+            HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                                                                   \\",
            "+                                                                                                                                 \\",
            "+            _hj_key += 12;                                                                                                       \\",
            "+            _hj_k -= 12U;                                                                                                        \\",
            "+        }                                                                                                                        \\",
            "+        hashv += (unsigned)(keylen);                                                                                             \\",
            "+        switch(_hj_k) {                                                                                                          \\",
            "+            case 11: hashv += ((unsigned)_hj_key[10] << 24); /* FALLTHROUGH */                                                   \\",
            "+            case 10: hashv += ((unsigned)_hj_key[9] << 16);  /* FALLTHROUGH */                                                   \\",
            "+            case 9: hashv += ((unsigned)_hj_key[8] << 8);    /* FALLTHROUGH */                                                   \\",
            "+            case 8: _hj_j += ((unsigned)_hj_key[7] << 24);   /* FALLTHROUGH */                                                   \\",
            "+            case 7: _hj_j += ((unsigned)_hj_key[6] << 16);   /* FALLTHROUGH */                                                   \\",
            "+            case 6: _hj_j += ((unsigned)_hj_key[5] << 8);    /* FALLTHROUGH */                                                   \\",
            "+            case 5: _hj_j += _hj_key[4];                     /* FALLTHROUGH */                                                   \\",
            "+            case 4: _hj_i += ((unsigned)_hj_key[3] << 24);   /* FALLTHROUGH */                                                   \\",
            "+            case 3: _hj_i += ((unsigned)_hj_key[2] << 16);   /* FALLTHROUGH */                                                   \\",
            "+            case 2: _hj_i += ((unsigned)_hj_key[1] << 8);    /* FALLTHROUGH */                                                   \\",
            "+            case 1: _hj_i += _hj_key[0];                     /* FALLTHROUGH */                                                   \\",
            "+            default:;                                                                                                            \\",
            "+        }                                                                                                                        \\",
            "+        HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                                                                       \\",
            "+    } while(0)",
            " ",
            " /* The Paul Hsieh hash function */",
            " #undef get16bits",
            "-#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__)             \\",
            "-  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)",
            "-#define get16bits(d) (*((const uint16_t *) (d)))",
            "-#endif",
            "-",
            "-#if !defined (get16bits)",
            "-#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)             \\",
            "-                       +(uint32_t)(((const uint8_t *)(d))[0]) )",
            "-#endif",
            "-#define HASH_SFH(key,keylen,hashv)                                               \\",
            "-do {                                                                             \\",
            "-  unsigned const char *_sfh_key=(unsigned const char*)(key);                     \\",
            "-  uint32_t _sfh_tmp, _sfh_len = (uint32_t)keylen;                                \\",
            "-                                                                                 \\",
            "-  unsigned _sfh_rem = _sfh_len & 3U;                                             \\",
            "-  _sfh_len >>= 2;                                                                \\",
            "-  hashv = 0xcafebabeu;                                                           \\",
            "-                                                                                 \\",
            "-  /* Main loop */                                                                \\",
            "-  for (;_sfh_len > 0U; _sfh_len--) {                                             \\",
            "-    hashv    += get16bits (_sfh_key);                                            \\",
            "-    _sfh_tmp  = ((uint32_t)(get16bits (_sfh_key+2)) << 11) ^ hashv;              \\",
            "-    hashv     = (hashv << 16) ^ _sfh_tmp;                                        \\",
            "-    _sfh_key += 2U*sizeof (uint16_t);                                            \\",
            "-    hashv    += hashv >> 11;                                                     \\",
            "-  }                                                                              \\",
            "-                                                                                 \\",
            "-  /* Handle end cases */                                                         \\",
            "-  switch (_sfh_rem) {                                                            \\",
            "-    case 3: hashv += get16bits (_sfh_key);                                       \\",
            "-            hashv ^= hashv << 16;                                                \\",
            "-            hashv ^= (uint32_t)(_sfh_key[sizeof (uint16_t)]) << 18;              \\",
            "-            hashv += hashv >> 11;                                                \\",
            "-            break;                                                               \\",
            "-    case 2: hashv += get16bits (_sfh_key);                                       \\",
            "-            hashv ^= hashv << 11;                                                \\",
            "-            hashv += hashv >> 17;                                                \\",
            "-            break;                                                               \\",
            "-    case 1: hashv += *_sfh_key;                                                  \\",
            "-            hashv ^= hashv << 10;                                                \\",
            "-            hashv += hashv >> 1;                                                 \\",
            "-            break;                                                               \\",
            "-    default: ;                                                                   \\",
            "-  }                                                                              \\",
            "-                                                                                 \\",
            "-  /* Force \"avalanching\" of final 127 bits */                                    \\",
            "-  hashv ^= hashv << 3;                                                           \\",
            "-  hashv += hashv >> 5;                                                           \\",
            "-  hashv ^= hashv << 4;                                                           \\",
            "-  hashv += hashv >> 17;                                                          \\",
            "-  hashv ^= hashv << 25;                                                          \\",
            "-  hashv += hashv >> 6;                                                           \\",
            "-} while (0)",
            "+#if(defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) || defined(_MSC_VER) || defined(__BORLANDC__) \\",
            "+    || defined(__TURBOC__)",
            "+#    define get16bits(d) (*((const uint16_t *)(d)))",
            "+#endif",
            "+",
            "+#if !defined(get16bits)",
            "+#    define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8) + (uint32_t)(((const uint8_t *)(d))[0]))",
            "+#endif",
            "+#define HASH_SFH(key, keylen, hashv)                                        \\",
            "+    do {                                                                    \\",
            "+        unsigned const char *_sfh_key = (unsigned const char *)(key);       \\",
            "+        uint32_t _sfh_tmp, _sfh_len = (uint32_t)keylen;                     \\",
            "+                                                                            \\",
            "+        unsigned _sfh_rem = _sfh_len & 3U;                                  \\",
            "+        _sfh_len >>= 2;                                                     \\",
            "+        hashv = 0xcafebabeu;                                                \\",
            "+                                                                            \\",
            "+        /* Main loop */                                                     \\",
            "+        for(; _sfh_len > 0U; _sfh_len--) {                                  \\",
            "+            hashv += get16bits(_sfh_key);                                   \\",
            "+            _sfh_tmp = ((uint32_t)(get16bits(_sfh_key + 2)) << 11) ^ hashv; \\",
            "+            hashv = (hashv << 16) ^ _sfh_tmp;                               \\",
            "+            _sfh_key += 2U * sizeof(uint16_t);                              \\",
            "+            hashv += hashv >> 11;                                           \\",
            "+        }                                                                   \\",
            "+                                                                            \\",
            "+        /* Handle end cases */                                              \\",
            "+        switch(_sfh_rem) {                                                  \\",
            "+            case 3:                                                         \\",
            "+                hashv += get16bits(_sfh_key);                               \\",
            "+                hashv ^= hashv << 16;                                       \\",
            "+                hashv ^= (uint32_t)(_sfh_key[sizeof(uint16_t)]) << 18;      \\",
            "+                hashv += hashv >> 11;                                       \\",
            "+                break;                                                      \\",
            "+            case 2:                                                         \\",
            "+                hashv += get16bits(_sfh_key);                               \\",
            "+                hashv ^= hashv << 11;                                       \\",
            "+                hashv += hashv >> 17;                                       \\",
            "+                break;                                                      \\",
            "+            case 1:                                                         \\",
            "+                hashv += *_sfh_key;                                         \\",
            "+                hashv ^= hashv << 10;                                       \\",
            "+                hashv += hashv >> 1;                                        \\",
            "+                break;                                                      \\",
            "+            default:;                                                       \\",
            "+        }                                                                   \\",
            "+                                                                            \\",
            "+        /* Force \"avalanching\" of final 127 bits */                         \\",
            "+        hashv ^= hashv << 3;                                                \\",
            "+        hashv += hashv >> 5;                                                \\",
            "+        hashv ^= hashv << 4;                                                \\",
            "+        hashv += hashv >> 17;                                               \\",
            "+        hashv ^= hashv << 25;                                               \\",
            "+        hashv += hashv >> 6;                                                \\",
            "+    } while(0)",
            " ",
            " /* iterate over items in a known bucket to find desired item */",
            "-#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,hashval,out)               \\",
            "-do {                                                                             \\",
            "-  if ((head).hh_head != NULL) {                                                  \\",
            "-    DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (head).hh_head));                     \\",
            "-  } else {                                                                       \\",
            "-    (out) = NULL;                                                                \\",
            "-  }                                                                              \\",
            "-  while ((out) != NULL) {                                                        \\",
            "-    if ((out)->hh.hashv == (hashval) && (out)->hh.keylen == (keylen_in)) {       \\",
            "-      if (HASH_KEYCMP((out)->hh.key, keyptr, keylen_in) == 0) {                  \\",
            "-        break;                                                                   \\",
            "-      }                                                                          \\",
            "-    }                                                                            \\",
            "-    if ((out)->hh.hh_next != NULL) {                                             \\",
            "-      DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (out)->hh.hh_next));                \\",
            "-    } else {                                                                     \\",
            "-      (out) = NULL;                                                              \\",
            "-    }                                                                            \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_FIND_IN_BKT(tbl, hh, head, keyptr, keylen_in, hashval, out)          \\",
            "+    do {                                                                          \\",
            "+        if((head).hh_head != NULL) {                                              \\",
            "+            DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (head).hh_head));              \\",
            "+        } else {                                                                  \\",
            "+            (out) = NULL;                                                         \\",
            "+        }                                                                         \\",
            "+        while((out) != NULL) {                                                    \\",
            "+            if((out)->hh.hashv == (hashval) && (out)->hh.keylen == (keylen_in)) { \\",
            "+                if(HASH_KEYCMP((out)->hh.key, keyptr, keylen_in) == 0) { break; } \\",
            "+            }                                                                     \\",
            "+            if((out)->hh.hh_next != NULL) {                                       \\",
            "+                DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (out)->hh.hh_next));       \\",
            "+            } else {                                                              \\",
            "+                (out) = NULL;                                                     \\",
            "+            }                                                                     \\",
            "+        }                                                                         \\",
            "+    } while(0)",
            " ",
            " /* add an item to a bucket  */",
            "-#define HASH_ADD_TO_BKT(head,hh,addhh,oomed)                                     \\",
            "-do {                                                                             \\",
            "-  UT_hash_bucket *_ha_head = &(head);                                            \\",
            "-  _ha_head->count++;                                                             \\",
            "-  (addhh)->hh_next = _ha_head->hh_head;                                          \\",
            "-  (addhh)->hh_prev = NULL;                                                       \\",
            "-  if (_ha_head->hh_head != NULL) {                                               \\",
            "-    _ha_head->hh_head->hh_prev = (addhh);                                        \\",
            "-  }                                                                              \\",
            "-  _ha_head->hh_head = (addhh);                                                   \\",
            "-  if ((_ha_head->count >= ((_ha_head->expand_mult + 1U) * HASH_BKT_CAPACITY_THRESH)) \\",
            "-      && !(addhh)->tbl->noexpand) {                                              \\",
            "-    HASH_EXPAND_BUCKETS(addhh,(addhh)->tbl, oomed);                              \\",
            "-    IF_HASH_NONFATAL_OOM(                                                        \\",
            "-      if (oomed) {                                                               \\",
            "-        HASH_DEL_IN_BKT(head,addhh);                                             \\",
            "-      }                                                                          \\",
            "-    )                                                                            \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_ADD_TO_BKT(head, hh, addhh, oomed)                                                                         \\",
            "+    do {                                                                                                                \\",
            "+        UT_hash_bucket *_ha_head = &(head);                                                                             \\",
            "+        _ha_head->count++;                                                                                              \\",
            "+        (addhh)->hh_next = _ha_head->hh_head;                                                                           \\",
            "+        (addhh)->hh_prev = NULL;                                                                                        \\",
            "+        if(_ha_head->hh_head != NULL) { _ha_head->hh_head->hh_prev = (addhh); }                                         \\",
            "+        _ha_head->hh_head = (addhh);                                                                                    \\",
            "+        if((_ha_head->count >= ((_ha_head->expand_mult + 1U) * HASH_BKT_CAPACITY_THRESH)) && !(addhh)->tbl->noexpand) { \\",
            "+            HASH_EXPAND_BUCKETS(addhh, (addhh)->tbl, oomed);                                                            \\",
            "+            IF_HASH_NONFATAL_OOM(if(oomed) { HASH_DEL_IN_BKT(head, addhh); })                                           \\",
            "+        }                                                                                                               \\",
            "+    } while(0)",
            " ",
            " /* remove an item from a given bucket */",
            "-#define HASH_DEL_IN_BKT(head,delhh)                                              \\",
            "-do {                                                                             \\",
            "-  UT_hash_bucket *_hd_head = &(head);                                            \\",
            "-  _hd_head->count--;                                                             \\",
            "-  if (_hd_head->hh_head == (delhh)) {                                            \\",
            "-    _hd_head->hh_head = (delhh)->hh_next;                                        \\",
            "-  }                                                                              \\",
            "-  if ((delhh)->hh_prev) {                                                        \\",
            "-    (delhh)->hh_prev->hh_next = (delhh)->hh_next;                                \\",
            "-  }                                                                              \\",
            "-  if ((delhh)->hh_next) {                                                        \\",
            "-    (delhh)->hh_next->hh_prev = (delhh)->hh_prev;                                \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_DEL_IN_BKT(head, delhh)                                               \\",
            "+    do {                                                                           \\",
            "+        UT_hash_bucket *_hd_head = &(head);                                        \\",
            "+        _hd_head->count--;                                                         \\",
            "+        if(_hd_head->hh_head == (delhh)) { _hd_head->hh_head = (delhh)->hh_next; } \\",
            "+        if((delhh)->hh_prev) { (delhh)->hh_prev->hh_next = (delhh)->hh_next; }     \\",
            "+        if((delhh)->hh_next) { (delhh)->hh_next->hh_prev = (delhh)->hh_prev; }     \\",
            "+    } while(0)",
            " ",
            " /* Bucket expansion has the effect of doubling the number of buckets",
            "  * and redistributing the items into the new buckets. Ideally the",
            "  * items will distribute more or less evenly into the new buckets",
            "  * (the extent to which this is true is a measure of the quality of",
            "  * the hash function as it applies to the key domain).",
            "  *",
            "@@ -825,312 +793,284 @@",
            "  * But now we have improved things a bit by recognizing that b is",
            "  * always a power of two. We keep its base 2 log handy (call it lb),",
            "  * so now we can write this with a bit shift and logical AND:",
            "  *",
            "  *      ceil(n/b) = (n>>lb) + ( (n & (b-1)) ? 1:0)",
            "  *",
            "  */",
            "-#define HASH_EXPAND_BUCKETS(hh,tbl,oomed)                                        \\",
            "-do {                                                                             \\",
            "-  unsigned _he_bkt;                                                              \\",
            "-  unsigned _he_bkt_i;                                                            \\",
            "-  struct UT_hash_handle *_he_thh, *_he_hh_nxt;                                   \\",
            "-  UT_hash_bucket *_he_new_buckets, *_he_newbkt;                                  \\",
            "-  _he_new_buckets = (UT_hash_bucket*)uthash_malloc(                              \\",
            "-           sizeof(struct UT_hash_bucket) * (tbl)->num_buckets * 2U);             \\",
            "-  if (!_he_new_buckets) {                                                        \\",
            "-    HASH_RECORD_OOM(oomed);                                                      \\",
            "-  } else {                                                                       \\",
            "-    uthash_bzero(_he_new_buckets,                                                \\",
            "-        sizeof(struct UT_hash_bucket) * (tbl)->num_buckets * 2U);                \\",
            "-    (tbl)->ideal_chain_maxlen =                                                  \\",
            "-       ((tbl)->num_items >> ((tbl)->log2_num_buckets+1U)) +                      \\",
            "-       ((((tbl)->num_items & (((tbl)->num_buckets*2U)-1U)) != 0U) ? 1U : 0U);    \\",
            "-    (tbl)->nonideal_items = 0;                                                   \\",
            "-    for (_he_bkt_i = 0; _he_bkt_i < (tbl)->num_buckets; _he_bkt_i++) {           \\",
            "-      _he_thh = (tbl)->buckets[ _he_bkt_i ].hh_head;                             \\",
            "-      while (_he_thh != NULL) {                                                  \\",
            "-        _he_hh_nxt = _he_thh->hh_next;                                           \\",
            "-        HASH_TO_BKT(_he_thh->hashv, (tbl)->num_buckets * 2U, _he_bkt);           \\",
            "-        _he_newbkt = &(_he_new_buckets[_he_bkt]);                                \\",
            "-        if (++(_he_newbkt->count) > (tbl)->ideal_chain_maxlen) {                 \\",
            "-          (tbl)->nonideal_items++;                                               \\",
            "-          if (_he_newbkt->count > _he_newbkt->expand_mult * (tbl)->ideal_chain_maxlen) { \\",
            "-            _he_newbkt->expand_mult++;                                           \\",
            "-          }                                                                      \\",
            "-        }                                                                        \\",
            "-        _he_thh->hh_prev = NULL;                                                 \\",
            "-        _he_thh->hh_next = _he_newbkt->hh_head;                                  \\",
            "-        if (_he_newbkt->hh_head != NULL) {                                       \\",
            "-          _he_newbkt->hh_head->hh_prev = _he_thh;                                \\",
            "-        }                                                                        \\",
            "-        _he_newbkt->hh_head = _he_thh;                                           \\",
            "-        _he_thh = _he_hh_nxt;                                                    \\",
            "-      }                                                                          \\",
            "-    }                                                                            \\",
            "-    uthash_free((tbl)->buckets, (tbl)->num_buckets * sizeof(struct UT_hash_bucket)); \\",
            "-    (tbl)->num_buckets *= 2U;                                                    \\",
            "-    (tbl)->log2_num_buckets++;                                                   \\",
            "-    (tbl)->buckets = _he_new_buckets;                                            \\",
            "-    (tbl)->ineff_expands = ((tbl)->nonideal_items > ((tbl)->num_items >> 1)) ?   \\",
            "-        ((tbl)->ineff_expands+1U) : 0U;                                          \\",
            "-    if ((tbl)->ineff_expands > 1U) {                                             \\",
            "-      (tbl)->noexpand = 1;                                                       \\",
            "-      uthash_noexpand_fyi(tbl);                                                  \\",
            "-    }                                                                            \\",
            "-    uthash_expand_fyi(tbl);                                                      \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_EXPAND_BUCKETS(hh, tbl, oomed)                                                                              \\",
            "+    do {                                                                                                                 \\",
            "+        unsigned _he_bkt;                                                                                                \\",
            "+        unsigned _he_bkt_i;                                                                                              \\",
            "+        struct UT_hash_handle *_he_thh, *_he_hh_nxt;                                                                     \\",
            "+        UT_hash_bucket *_he_new_buckets, *_he_newbkt;                                                                    \\",
            "+        _he_new_buckets = (UT_hash_bucket *)uthash_malloc(sizeof(struct UT_hash_bucket) * (tbl)->num_buckets * 2U);      \\",
            "+        if(!_he_new_buckets) {                                                                                           \\",
            "+            HASH_RECORD_OOM(oomed);                                                                                      \\",
            "+        } else {                                                                                                         \\",
            "+            uthash_bzero(_he_new_buckets, sizeof(struct UT_hash_bucket) * (tbl)->num_buckets * 2U);                      \\",
            "+            (tbl)->ideal_chain_maxlen = ((tbl)->num_items >> ((tbl)->log2_num_buckets + 1U))                             \\",
            "+                                        + ((((tbl)->num_items & (((tbl)->num_buckets * 2U) - 1U)) != 0U) ? 1U : 0U);     \\",
            "+            (tbl)->nonideal_items = 0;                                                                                   \\",
            "+            for(_he_bkt_i = 0; _he_bkt_i < (tbl)->num_buckets; _he_bkt_i++) {                                            \\",
            "+                _he_thh = (tbl)->buckets[_he_bkt_i].hh_head;                                                             \\",
            "+                while(_he_thh != NULL) {                                                                                 \\",
            "+                    _he_hh_nxt = _he_thh->hh_next;                                                                       \\",
            "+                    HASH_TO_BKT(_he_thh->hashv, (tbl)->num_buckets * 2U, _he_bkt);                                       \\",
            "+                    _he_newbkt = &(_he_new_buckets[_he_bkt]);                                                            \\",
            "+                    if(++(_he_newbkt->count) > (tbl)->ideal_chain_maxlen) {                                              \\",
            "+                        (tbl)->nonideal_items++;                                                                         \\",
            "+                        if(_he_newbkt->count > _he_newbkt->expand_mult * (tbl)->ideal_chain_maxlen) {                    \\",
            "+                            _he_newbkt->expand_mult++;                                                                   \\",
            "+                        }                                                                                                \\",
            "+                    }                                                                                                    \\",
            "+                    _he_thh->hh_prev = NULL;                                                                             \\",
            "+                    _he_thh->hh_next = _he_newbkt->hh_head;                                                              \\",
            "+                    if(_he_newbkt->hh_head != NULL) { _he_newbkt->hh_head->hh_prev = _he_thh; }                          \\",
            "+                    _he_newbkt->hh_head = _he_thh;                                                                       \\",
            "+                    _he_thh = _he_hh_nxt;                                                                                \\",
            "+                }                                                                                                        \\",
            "+            }                                                                                                            \\",
            "+            uthash_free((tbl)->buckets, (tbl)->num_buckets * sizeof(struct UT_hash_bucket));                             \\",
            "+            (tbl)->num_buckets *= 2U;                                                                                    \\",
            "+            (tbl)->log2_num_buckets++;                                                                                   \\",
            "+            (tbl)->buckets = _he_new_buckets;                                                                            \\",
            "+            (tbl)->ineff_expands = ((tbl)->nonideal_items > ((tbl)->num_items >> 1)) ? ((tbl)->ineff_expands + 1U) : 0U; \\",
            "+            if((tbl)->ineff_expands > 1U) {                                                                              \\",
            "+                (tbl)->noexpand = 1;                                                                                     \\",
            "+                uthash_noexpand_fyi(tbl);                                                                                \\",
            "+            }                                                                                                            \\",
            "+            uthash_expand_fyi(tbl);                                                                                      \\",
            "+        }                                                                                                                \\",
            "+    } while(0)",
            " ",
            " ",
            " /* This is an adaptation of Simon Tatham's O(n log(n)) mergesort */",
            " /* Note that HASH_SORT assumes the hash handle name to be hh.",
            "  * HASH_SRT was added to allow the hash handle name to be passed in. */",
            "-#define HASH_SORT(head,cmpfcn) HASH_SRT(hh,head,cmpfcn)",
            "-#define HASH_SRT(hh,head,cmpfcn)                                                 \\",
            "-do {                                                                             \\",
            "-  unsigned _hs_i;                                                                \\",
            "-  unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize;               \\",
            "-  struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail;            \\",
            "-  if (head != NULL) {                                                            \\",
            "-    _hs_insize = 1;                                                              \\",
            "-    _hs_looping = 1;                                                             \\",
            "-    _hs_list = &((head)->hh);                                                    \\",
            "-    while (_hs_looping != 0U) {                                                  \\",
            "-      _hs_p = _hs_list;                                                          \\",
            "-      _hs_list = NULL;                                                           \\",
            "-      _hs_tail = NULL;                                                           \\",
            "-      _hs_nmerges = 0;                                                           \\",
            "-      while (_hs_p != NULL) {                                                    \\",
            "-        _hs_nmerges++;                                                           \\",
            "-        _hs_q = _hs_p;                                                           \\",
            "-        _hs_psize = 0;                                                           \\",
            "-        for (_hs_i = 0; _hs_i < _hs_insize; ++_hs_i) {                           \\",
            "-          _hs_psize++;                                                           \\",
            "-          _hs_q = ((_hs_q->next != NULL) ?                                       \\",
            "-            HH_FROM_ELMT((head)->hh.tbl, _hs_q->next) : NULL);                   \\",
            "-          if (_hs_q == NULL) {                                                   \\",
            "-            break;                                                               \\",
            "-          }                                                                      \\",
            "-        }                                                                        \\",
            "-        _hs_qsize = _hs_insize;                                                  \\",
            "-        while ((_hs_psize != 0U) || ((_hs_qsize != 0U) && (_hs_q != NULL))) {    \\",
            "-          if (_hs_psize == 0U) {                                                 \\",
            "-            _hs_e = _hs_q;                                                       \\",
            "-            _hs_q = ((_hs_q->next != NULL) ?                                     \\",
            "-              HH_FROM_ELMT((head)->hh.tbl, _hs_q->next) : NULL);                 \\",
            "-            _hs_qsize--;                                                         \\",
            "-          } else if ((_hs_qsize == 0U) || (_hs_q == NULL)) {                     \\",
            "-            _hs_e = _hs_p;                                                       \\",
            "-            if (_hs_p != NULL) {                                                 \\",
            "-              _hs_p = ((_hs_p->next != NULL) ?                                   \\",
            "-                HH_FROM_ELMT((head)->hh.tbl, _hs_p->next) : NULL);               \\",
            "-            }                                                                    \\",
            "-            _hs_psize--;                                                         \\",
            "-          } else if ((cmpfcn(                                                    \\",
            "-                DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl, _hs_p)),             \\",
            "-                DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl, _hs_q))              \\",
            "-                )) <= 0) {                                                       \\",
            "-            _hs_e = _hs_p;                                                       \\",
            "-            if (_hs_p != NULL) {                                                 \\",
            "-              _hs_p = ((_hs_p->next != NULL) ?                                   \\",
            "-                HH_FROM_ELMT((head)->hh.tbl, _hs_p->next) : NULL);               \\",
            "-            }                                                                    \\",
            "-            _hs_psize--;                                                         \\",
            "-          } else {                                                               \\",
            "-            _hs_e = _hs_q;                                                       \\",
            "-            _hs_q = ((_hs_q->next != NULL) ?                                     \\",
            "-              HH_FROM_ELMT((head)->hh.tbl, _hs_q->next) : NULL);                 \\",
            "-            _hs_qsize--;                                                         \\",
            "-          }                                                                      \\",
            "-          if ( _hs_tail != NULL ) {                                              \\",
            "-            _hs_tail->next = ((_hs_e != NULL) ?                                  \\",
            "-              ELMT_FROM_HH((head)->hh.tbl, _hs_e) : NULL);                       \\",
            "-          } else {                                                               \\",
            "-            _hs_list = _hs_e;                                                    \\",
            "-          }                                                                      \\",
            "-          if (_hs_e != NULL) {                                                   \\",
            "-            _hs_e->prev = ((_hs_tail != NULL) ?                                  \\",
            "-              ELMT_FROM_HH((head)->hh.tbl, _hs_tail) : NULL);                    \\",
            "-          }                                                                      \\",
            "-          _hs_tail = _hs_e;                                                      \\",
            "-        }                                                                        \\",
            "-        _hs_p = _hs_q;                                                           \\",
            "-      }                                                                          \\",
            "-      if (_hs_tail != NULL) {                                                    \\",
            "-        _hs_tail->next = NULL;                                                   \\",
            "-      }                                                                          \\",
            "-      if (_hs_nmerges <= 1U) {                                                   \\",
            "-        _hs_looping = 0;                                                         \\",
            "-        (head)->hh.tbl->tail = _hs_tail;                                         \\",
            "-        DECLTYPE_ASSIGN(head, ELMT_FROM_HH((head)->hh.tbl, _hs_list));           \\",
            "-      }                                                                          \\",
            "-      _hs_insize *= 2U;                                                          \\",
            "-    }                                                                            \\",
            "-    HASH_FSCK(hh, head, \"HASH_SRT\");                                             \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "+#define HASH_SORT(head, cmpfcn) HASH_SRT(hh, head, cmpfcn)",
            "+#define HASH_SRT(hh, head, cmpfcn)                                                                                  \\",
            "+    do {                                                                                                            \\",
            "+        unsigned _hs_i;                                                                                             \\",
            "+        unsigned _hs_looping, _hs_nmerges, _hs_insize, _hs_psize, _hs_qsize;                                        \\",
            "+        struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail;                                         \\",
            "+        if(head != NULL) {                                                                                          \\",
            "+            _hs_insize = 1;                                                                                         \\",
            "+            _hs_looping = 1;                                                                                        \\",
            "+            _hs_list = &((head)->hh);                                                                               \\",
            "+            while(_hs_looping != 0U) {                                                                              \\",
            "+                _hs_p = _hs_list;                                                                                   \\",
            "+                _hs_list = NULL;                                                                                    \\",
            "+                _hs_tail = NULL;                                                                                    \\",
            "+                _hs_nmerges = 0;                                                                                    \\",
            "+                while(_hs_p != NULL) {                                                                              \\",
            "+                    _hs_nmerges++;                                                                                  \\",
            "+                    _hs_q = _hs_p;                                                                                  \\",
            "+                    _hs_psize = 0;                                                                                  \\",
            "+                    for(_hs_i = 0; _hs_i < _hs_insize; ++_hs_i) {                                                   \\",
            "+                        _hs_psize++;                                                                                \\",
            "+                        _hs_q = ((_hs_q->next != NULL) ? HH_FROM_ELMT((head)->hh.tbl, _hs_q->next) : NULL);         \\",
            "+                        if(_hs_q == NULL) { break; }                                                                \\",
            "+                    }                                                                                               \\",
            "+                    _hs_qsize = _hs_insize;                                                                         \\",
            "+                    while((_hs_psize != 0U) || ((_hs_qsize != 0U) && (_hs_q != NULL))) {                            \\",
            "+                        if(_hs_psize == 0U) {                                                                       \\",
            "+                            _hs_e = _hs_q;                                                                          \\",
            "+                            _hs_q = ((_hs_q->next != NULL) ? HH_FROM_ELMT((head)->hh.tbl, _hs_q->next) : NULL);     \\",
            "+                            _hs_qsize--;                                                                            \\",
            "+                        } else if((_hs_qsize == 0U) || (_hs_q == NULL)) {                                           \\",
            "+                            _hs_e = _hs_p;                                                                          \\",
            "+                            if(_hs_p != NULL) {                                                                     \\",
            "+                                _hs_p = ((_hs_p->next != NULL) ? HH_FROM_ELMT((head)->hh.tbl, _hs_p->next) : NULL); \\",
            "+                            }                                                                                       \\",
            "+                            _hs_psize--;                                                                            \\",
            "+                        } else if((cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl, _hs_p)),                      \\",
            "+                                          DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl, _hs_q))))                     \\",
            "+                                  <= 0) {                                                                           \\",
            "+                            _hs_e = _hs_p;                                                                          \\",
            "+                            if(_hs_p != NULL) {                                                                     \\",
            "+                                _hs_p = ((_hs_p->next != NULL) ? HH_FROM_ELMT((head)->hh.tbl, _hs_p->next) : NULL); \\",
            "+                            }                                                                                       \\",
            "+                            _hs_psize--;                                                                            \\",
            "+                        } else {                                                                                    \\",
            "+                            _hs_e = _hs_q;                                                                          \\",
            "+                            _hs_q = ((_hs_q->next != NULL) ? HH_FROM_ELMT((head)->hh.tbl, _hs_q->next) : NULL);     \\",
            "+                            _hs_qsize--;                                                                            \\",
            "+                        }                                                                                           \\",
            "+                        if(_hs_tail != NULL) {                                                                      \\",
            "+                            _hs_tail->next = ((_hs_e != NULL) ? ELMT_FROM_HH((head)->hh.tbl, _hs_e) : NULL);        \\",
            "+                        } else {                                                                                    \\",
            "+                            _hs_list = _hs_e;                                                                       \\",
            "+                        }                                                                                           \\",
            "+                        if(_hs_e != NULL) {                                                                         \\",
            "+                            _hs_e->prev = ((_hs_tail != NULL) ? ELMT_FROM_HH((head)->hh.tbl, _hs_tail) : NULL);     \\",
            "+                        }                                                                                           \\",
            "+                        _hs_tail = _hs_e;                                                                           \\",
            "+                    }                                                                                               \\",
            "+                    _hs_p = _hs_q;                                                                                  \\",
            "+                }                                                                                                   \\",
            "+                if(_hs_tail != NULL) { _hs_tail->next = NULL; }                                                     \\",
            "+                if(_hs_nmerges <= 1U) {                                                                             \\",
            "+                    _hs_looping = 0;                                                                                \\",
            "+                    (head)->hh.tbl->tail = _hs_tail;                                                                \\",
            "+                    DECLTYPE_ASSIGN(head, ELMT_FROM_HH((head)->hh.tbl, _hs_list));                                  \\",
            "+                }                                                                                                   \\",
            "+                _hs_insize *= 2U;                                                                                   \\",
            "+            }                                                                                                       \\",
            "+            HASH_FSCK(hh, head, \"HASH_SRT\");                                                                        \\",
            "+        }                                                                                                           \\",
            "+    } while(0)",
            " ",
            " /* This function selects items from one hash into another hash.",
            "  * The end result is that the selected items have dual presence",
            "  * in both hashes. There is no copy of the items made; rather",
            "  * they are added into the new hash through a secondary hash",
            "  * hash handle that must be present in the structure. */",
            "-#define HASH_SELECT(hh_dst, dst, hh_src, src, cond)                              \\",
            "-do {                                                                             \\",
            "-  unsigned _src_bkt, _dst_bkt;                                                   \\",
            "-  void *_last_elt = NULL, *_elt;                                                 \\",
            "-  UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL;                         \\",
            "-  ptrdiff_t _dst_hho = ((char*)(&(dst)->hh_dst) - (char*)(dst));                 \\",
            "-  if ((src) != NULL) {                                                           \\",
            "-    for (_src_bkt=0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) {    \\",
            "-      for (_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head;               \\",
            "-        _src_hh != NULL;                                                         \\",
            "-        _src_hh = _src_hh->hh_next) {                                            \\",
            "-        _elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh);                         \\",
            "-        if (cond(_elt)) {                                                        \\",
            "-          IF_HASH_NONFATAL_OOM( int _hs_oomed = 0; )                             \\",
            "-          _dst_hh = (UT_hash_handle*)(void*)(((char*)_elt) + _dst_hho);          \\",
            "-          _dst_hh->key = _src_hh->key;                                           \\",
            "-          _dst_hh->keylen = _src_hh->keylen;                                     \\",
            "-          _dst_hh->hashv = _src_hh->hashv;                                       \\",
            "-          _dst_hh->prev = _last_elt;                                             \\",
            "-          _dst_hh->next = NULL;                                                  \\",
            "-          if (_last_elt_hh != NULL) {                                            \\",
            "-            _last_elt_hh->next = _elt;                                           \\",
            "-          }                                                                      \\",
            "-          if ((dst) == NULL) {                                                   \\",
            "-            DECLTYPE_ASSIGN(dst, _elt);                                          \\",
            "-            HASH_MAKE_TABLE(hh_dst, dst, _hs_oomed);                             \\",
            "-            IF_HASH_NONFATAL_OOM(                                                \\",
            "-              if (_hs_oomed) {                                                   \\",
            "-                uthash_nonfatal_oom(_elt);                                       \\",
            "-                (dst) = NULL;                                                    \\",
            "-                continue;                                                        \\",
            "-              }                                                                  \\",
            "-            )                                                                    \\",
            "-          } else {                                                               \\",
            "-            _dst_hh->tbl = (dst)->hh_dst.tbl;                                    \\",
            "-          }                                                                      \\",
            "-          HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt);      \\",
            "-          HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt], hh_dst, _dst_hh, _hs_oomed); \\",
            "-          (dst)->hh_dst.tbl->num_items++;                                        \\",
            "-          IF_HASH_NONFATAL_OOM(                                                  \\",
            "-            if (_hs_oomed) {                                                     \\",
            "-              HASH_ROLLBACK_BKT(hh_dst, dst, _dst_hh);                           \\",
            "-              HASH_DELETE_HH(hh_dst, dst, _dst_hh);                              \\",
            "-              _dst_hh->tbl = NULL;                                               \\",
            "-              uthash_nonfatal_oom(_elt);                                         \\",
            "-              continue;                                                          \\",
            "-            }                                                                    \\",
            "-          )                                                                      \\",
            "-          HASH_BLOOM_ADD(_dst_hh->tbl, _dst_hh->hashv);                          \\",
            "-          _last_elt = _elt;                                                      \\",
            "-          _last_elt_hh = _dst_hh;                                                \\",
            "-        }                                                                        \\",
            "-      }                                                                          \\",
            "-    }                                                                            \\",
            "-  }                                                                              \\",
            "-  HASH_FSCK(hh_dst, dst, \"HASH_SELECT\");                                         \\",
            "-} while (0)",
            "-",
            "-#define HASH_CLEAR(hh,head)                                                      \\",
            "-do {                                                                             \\",
            "-  if ((head) != NULL) {                                                          \\",
            "-    HASH_BLOOM_FREE((head)->hh.tbl);                                             \\",
            "-    uthash_free((head)->hh.tbl->buckets,                                         \\",
            "-                (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket));      \\",
            "-    uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                          \\",
            "-    (head) = NULL;                                                               \\",
            "-  }                                                                              \\",
            "-} while (0)",
            "-",
            "-#define HASH_OVERHEAD(hh,head)                                                   \\",
            "- (((head) != NULL) ? (                                                           \\",
            "- (size_t)(((head)->hh.tbl->num_items   * sizeof(UT_hash_handle))   +             \\",
            "-          ((head)->hh.tbl->num_buckets * sizeof(UT_hash_bucket))   +             \\",
            "-           sizeof(UT_hash_table)                                   +             \\",
            "-           (HASH_BLOOM_BYTELEN))) : 0U)",
            "+#define HASH_SELECT(hh_dst, dst, hh_src, src, cond)                                                                        \\",
            "+    do {                                                                                                                   \\",
            "+        unsigned _src_bkt, _dst_bkt;                                                                                       \\",
            "+        void *_last_elt = NULL, *_elt;                                                                                     \\",
            "+        UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh = NULL;                                                           \\",
            "+        ptrdiff_t _dst_hho = ((char *)(&(dst)->hh_dst) - (char *)(dst));                                                   \\",
            "+        if((src) != NULL) {                                                                                                \\",
            "+            for(_src_bkt = 0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) {                                     \\",
            "+                for(_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head; _src_hh != NULL; _src_hh = _src_hh->hh_next) { \\",
            "+                    _elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh);                                                       \\",
            "+                    if(cond(_elt)) {                                                                                       \\",
            "+                        IF_HASH_NONFATAL_OOM(int _hs_oomed = 0;)                                                           \\",
            "+                        _dst_hh = (UT_hash_handle *)(void *)(((char *)_elt) + _dst_hho);                                   \\",
            "+                        _dst_hh->key = _src_hh->key;                                                                       \\",
            "+                        _dst_hh->keylen = _src_hh->keylen;                                                                 \\",
            "+                        _dst_hh->hashv = _src_hh->hashv;                                                                   \\",
            "+                        _dst_hh->prev = _last_elt;                                                                         \\",
            "+                        _dst_hh->next = NULL;                                                                              \\",
            "+                        if(_last_elt_hh != NULL) { _last_elt_hh->next = _elt; }                                            \\",
            "+                        if((dst) == NULL) {                                                                                \\",
            "+                            DECLTYPE_ASSIGN(dst, _elt);                                                                    \\",
            "+                            HASH_MAKE_TABLE(hh_dst, dst, _hs_oomed);                                                       \\",
            "+                            IF_HASH_NONFATAL_OOM(if(_hs_oomed) {                                                           \\",
            "+                                uthash_nonfatal_oom(_elt);                                                                 \\",
            "+                                (dst) = NULL;                                                                              \\",
            "+                                continue;                                                                                  \\",
            "+                            })                                                                                             \\",
            "+                        } else {                                                                                           \\",
            "+                            _dst_hh->tbl = (dst)->hh_dst.tbl;                                                              \\",
            "+                        }                                                                                                  \\",
            "+                        HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt);                                  \\",
            "+                        HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt], hh_dst, _dst_hh, _hs_oomed);                      \\",
            "+                        (dst)->hh_dst.tbl->num_items++;                                                                    \\",
            "+                        IF_HASH_NONFATAL_OOM(if(_hs_oomed) {                                                               \\",
            "+                            HASH_ROLLBACK_BKT(hh_dst, dst, _dst_hh);                                                       \\",
            "+                            HASH_DELETE_HH(hh_dst, dst, _dst_hh);                                                          \\",
            "+                            _dst_hh->tbl = NULL;                                                                           \\",
            "+                            uthash_nonfatal_oom(_elt);                                                                     \\",
            "+                            continue;                                                                                      \\",
            "+                        })                                                                                                 \\",
            "+                        HASH_BLOOM_ADD(_dst_hh->tbl, _dst_hh->hashv);                                                      \\",
            "+                        _last_elt = _elt;                                                                                  \\",
            "+                        _last_elt_hh = _dst_hh;                                                                            \\",
            "+                    }                                                                                                      \\",
            "+                }                                                                                                          \\",
            "+            }                                                                                                              \\",
            "+        }                                                                                                                  \\",
            "+        HASH_FSCK(hh_dst, dst, \"HASH_SELECT\");                                                                             \\",
            "+    } while(0)",
            "+",
            "+#define HASH_CLEAR(hh, head)                                                                                   \\",
            "+    do {                                                                                                       \\",
            "+        if((head) != NULL) {                                                                                   \\",
            "+            HASH_BLOOM_FREE((head)->hh.tbl);                                                                   \\",
            "+            uthash_free((head)->hh.tbl->buckets, (head)->hh.tbl->num_buckets * sizeof(struct UT_hash_bucket)); \\",
            "+            uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                                                \\",
            "+            (head) = NULL;                                                                                     \\",
            "+        }                                                                                                      \\",
            "+    } while(0)",
            "+",
            "+#define HASH_OVERHEAD(hh, head)                                                                                                  \\",
            "+    (((head) != NULL) ?                                                                                                          \\",
            "+         ((size_t)(((head)->hh.tbl->num_items * sizeof(UT_hash_handle)) + ((head)->hh.tbl->num_buckets * sizeof(UT_hash_bucket)) \\",
            "+                   + sizeof(UT_hash_table) + (HASH_BLOOM_BYTELEN))) :                                                            \\",
            "+         0U)",
            " ",
            " #ifdef NO_DECLTYPE",
            "-#define HASH_ITER(hh,head,el,tmp)                                                \\",
            "-for(((el)=(head)), ((*(char**)(&(tmp)))=(char*)((head!=NULL)?(head)->hh.next:NULL)); \\",
            "-  (el) != NULL; ((el)=(tmp)), ((*(char**)(&(tmp)))=(char*)((tmp!=NULL)?(tmp)->hh.next:NULL)))",
            "+#    define HASH_ITER(hh, head, el, tmp)                                                                               \\",
            "+        for(((el) = (head)), ((*(char **)(&(tmp))) = (char *)((head != NULL) ? (head)->hh.next : NULL)); (el) != NULL; \\",
            "+            ((el) = (tmp)), ((*(char **)(&(tmp))) = (char *)((tmp != NULL) ? (tmp)->hh.next : NULL)))",
            " #else",
            "-#define HASH_ITER(hh,head,el,tmp)                                                \\",
            "-for(((el)=(head)), ((tmp)=DECLTYPE(el)((head!=NULL)?(head)->hh.next:NULL));      \\",
            "-  (el) != NULL; ((el)=(tmp)), ((tmp)=DECLTYPE(el)((tmp!=NULL)?(tmp)->hh.next:NULL)))",
            "+#    define HASH_ITER(hh, head, el, tmp)                                                                    \\",
            "+        for(((el) = (head)), ((tmp) = DECLTYPE(el)((head != NULL) ? (head)->hh.next : NULL)); (el) != NULL; \\",
            "+            ((el) = (tmp)), ((tmp) = DECLTYPE(el)((tmp != NULL) ? (tmp)->hh.next : NULL)))",
            " #endif",
            " ",
            " /* obtain a count of items in the hash */",
            "-#define HASH_COUNT(head) HASH_CNT(hh,head)",
            "-#define HASH_CNT(hh,head) ((head != NULL)?((head)->hh.tbl->num_items):0U)",
            "+#define HASH_COUNT(head) HASH_CNT(hh, head)",
            "+#define HASH_CNT(hh, head) ((head != NULL) ? ((head)->hh.tbl->num_items) : 0U)",
            " ",
            " typedef struct UT_hash_bucket {",
            "-   struct UT_hash_handle *hh_head;",
            "-   unsigned count;",
            "+    struct UT_hash_handle *hh_head;",
            "+    unsigned count;",
            " ",
            "-   /* expand_mult is normally set to 0. In this situation, the max chain length",
            "-    * threshold is enforced at its default value, HASH_BKT_CAPACITY_THRESH. (If",
            "-    * the bucket's chain exceeds this length, bucket expansion is triggered).",
            "-    * However, setting expand_mult to a non-zero value delays bucket expansion",
            "-    * (that would be triggered by additions to this particular bucket)",
            "-    * until its chain length reaches a *multiple* of HASH_BKT_CAPACITY_THRESH.",
            "-    * (The multiplier is simply expand_mult+1). The whole idea of this",
            "-    * multiplier is to reduce bucket expansions, since they are expensive, in",
            "-    * situations where we know that a particular bucket tends to be overused.",
            "-    * It is better to let its chain length grow to a longer yet-still-bounded",
            "-    * value, than to do an O(n) bucket expansion too often.",
            "-    */",
            "-   unsigned expand_mult;",
            "+    /* expand_mult is normally set to 0. In this situation, the max chain length",
            "+     * threshold is enforced at its default value, HASH_BKT_CAPACITY_THRESH. (If",
            "+     * the bucket's chain exceeds this length, bucket expansion is triggered).",
            "+     * However, setting expand_mult to a non-zero value delays bucket expansion",
            "+     * (that would be triggered by additions to this particular bucket)",
            "+     * until its chain length reaches a *multiple* of HASH_BKT_CAPACITY_THRESH.",
            "+     * (The multiplier is simply expand_mult+1). The whole idea of this",
            "+     * multiplier is to reduce bucket expansions, since they are expensive, in",
            "+     * situations where we know that a particular bucket tends to be overused.",
            "+     * It is better to let its chain length grow to a longer yet-still-bounded",
            "+     * value, than to do an O(n) bucket expansion too often.",
            "+     */",
            "+    unsigned expand_mult;",
            " ",
            " } UT_hash_bucket;",
            " ",
            " /* random signature used only to find hash tables in external analysis */",
            " #define HASH_SIGNATURE 0xa0111fe1u",
            " #define HASH_BLOOM_SIGNATURE 0xb12220f2u",
            " ",
            " typedef struct UT_hash_table {",
            "-   UT_hash_bucket *buckets;",
            "-   unsigned num_buckets, log2_num_buckets;",
            "-   unsigned num_items;",
            "-   struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */",
            "-   ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */",
            "-",
            "-   /* in an ideal situation (all buckets used equally), no bucket would have",
            "-    * more than ceil(#items/#buckets) items. that's the ideal chain length. */",
            "-   unsigned ideal_chain_maxlen;",
            "-",
            "-   /* nonideal_items is the number of items in the hash whose chain position",
            "-    * exceeds the ideal chain maxlen. these items pay the penalty for an uneven",
            "-    * hash distribution; reaching them in a chain traversal takes >ideal steps */",
            "-   unsigned nonideal_items;",
            "-",
            "-   /* ineffective expands occur when a bucket doubling was performed, but",
            "-    * afterward, more than half the items in the hash had nonideal chain",
            "-    * positions. If this happens on two consecutive expansions we inhibit any",
            "-    * further expansion, as it's not helping; this happens when the hash",
            "-    * function isn't a good fit for the key domain. When expansion is inhibited",
            "-    * the hash will still work, albeit no longer in constant time. */",
            "-   unsigned ineff_expands, noexpand;",
            "+    UT_hash_bucket *buckets;",
            "+    unsigned num_buckets, log2_num_buckets;",
            "+    unsigned num_items;",
            "+    struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */",
            "+    ptrdiff_t hho;               /* hash handle offset (byte pos of hash handle in element */",
            "+",
            "+    /* in an ideal situation (all buckets used equally), no bucket would have",
            "+     * more than ceil(#items/#buckets) items. that's the ideal chain length. */",
            "+    unsigned ideal_chain_maxlen;",
            "+",
            "+    /* nonideal_items is the number of items in the hash whose chain position",
            "+     * exceeds the ideal chain maxlen. these items pay the penalty for an uneven",
            "+     * hash distribution; reaching them in a chain traversal takes >ideal steps */",
            "+    unsigned nonideal_items;",
            "+",
            "+    /* ineffective expands occur when a bucket doubling was performed, but",
            "+     * afterward, more than half the items in the hash had nonideal chain",
            "+     * positions. If this happens on two consecutive expansions we inhibit any",
            "+     * further expansion, as it's not helping; this happens when the hash",
            "+     * function isn't a good fit for the key domain. When expansion is inhibited",
            "+     * the hash will still work, albeit no longer in constant time. */",
            "+    unsigned ineff_expands, noexpand;",
            " ",
            "-   uint32_t signature; /* used only to find hash tables in external analysis */",
            "+    uint32_t signature; /* used only to find hash tables in external analysis */",
            " #ifdef HASH_BLOOM",
            "-   uint32_t bloom_sig; /* used only to test bloom exists in external analysis */",
            "-   uint8_t *bloom_bv;",
            "-   uint8_t bloom_nbits;",
            "+    uint32_t bloom_sig; /* used only to test bloom exists in external analysis */",
            "+    uint8_t *bloom_bv;",
            "+    uint8_t bloom_nbits;",
            " #endif",
            " ",
            " } UT_hash_table;",
            " ",
            " typedef struct UT_hash_handle {",
            "-   struct UT_hash_table *tbl;",
            "-   void *prev;                       /* prev element in app order      */",
            "-   void *next;                       /* next element in app order      */",
            "-   struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */",
            "-   struct UT_hash_handle *hh_next;   /* next hh in bucket order        */",
            "-   const void *key;                  /* ptr to enclosing struct's key  */",
            "-   unsigned keylen;                  /* enclosing struct's key len     */",
            "-   unsigned hashv;                   /* result of hash-fcn(key)        */",
            "+    struct UT_hash_table *tbl;",
            "+    void *prev;                     /* prev element in app order      */",
            "+    void *next;                     /* next element in app order      */",
            "+    struct UT_hash_handle *hh_prev; /* previous hh in bucket order    */",
            "+    struct UT_hash_handle *hh_next; /* next hh in bucket order        */",
            "+    const void *key;                /* ptr to enclosing struct's key  */",
            "+    unsigned keylen;                /* enclosing struct's key len     */",
            "+    unsigned hashv;                 /* result of hash-fcn(key)        */",
            " } UT_hash_handle;",
            " ",
            " #endif /* UTHASH_H */"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/async.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/async.c",
            "+++ /home/libplctag-2.6.7/src/examples/async.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,64 +28,70 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "-",
            " /*",
            "  * This example reads from a large DINT array.  It creates many tags that each read from one element of the",
            "  * array. It fires off all the tags at once and waits for them to complete the reads. In this case, it waits",
            "  * a fixed amount of time and then tries to read the tags.",
            "  */",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include <string.h>",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " #define TAG_ATTRIBS \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=LGX&elem_type=DINT&elem_count=%d&name=TestBigArray[%d]\"",
            "-#define NUM_TAGS  (30)",
            "+#define NUM_TAGS (30)",
            " #define NUM_ELEMS (1000)",
            " #define DATA_TIMEOUT (5000)",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag[NUM_TAGS];",
            "     int rc;",
            "     int i;",
            "-    int64_t timeout = DATA_TIMEOUT + util_time_ms();",
            "+    int64_t timeout = DATA_TIMEOUT + compat_time_ms();",
            "     int failed = 0;",
            "     int done = 0;",
            "     int64_t start = 0;",
            "     int64_t end = 0;",
            "     int num_elems_per_tag = NUM_ELEMS / NUM_TAGS;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     do {",
            "         /* create the tags */",
            "-        for(i=0; i< NUM_TAGS; i++) {",
            "-            char tmp_tag_path[256] = {0,};",
            "-            snprintf_platform(tmp_tag_path, sizeof tmp_tag_path,TAG_ATTRIBS, num_elems_per_tag, i);",
            "+        for(i = 0; i < NUM_TAGS; i++) {",
            "+            char tmp_tag_path[256] = {",
            "+                0,",
            "+            };",
            "+",
            "+            // NOLINTNEXTLINE",
            "+            compat_snprintf(tmp_tag_path, sizeof tmp_tag_path, TAG_ATTRIBS, num_elems_per_tag, i);",
            " ",
            "-            fprintf(stderr, \"Attempting to create tag with attribute string '%s'\\n\",tmp_tag_path);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Attempting to create tag with attribute string '%s'\\n\", tmp_tag_path);",
            " ",
            "-            tag[i]  = plc_tag_create(tmp_tag_path, 0);",
            "+            tag[i] = plc_tag_create(tmp_tag_path, 0);",
            " ",
            "             if(tag[i] < 0) {",
            "-                fprintf(stderr,\"Error %s: could not create tag %d\\n\",plc_tag_decode_error(tag[i]), i);",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Error %s: could not create tag %d\\n\", plc_tag_decode_error(tag[i]), i);",
            "                 tag[i] = 0;",
            "                 failed = 1;",
            "             }",
            "         }",
            " ",
            "         /* did any tags fail? */",
            "         if(failed) {",
            "@@ -93,84 +99,80 @@",
            "             break;",
            "         }",
            " ",
            "         /* wait for all the tags to complete creation. */",
            "         do {",
            "             done = 1;",
            " ",
            "-            for(i=0; i < NUM_TAGS; i++) {",
            "+            for(i = 0; i < NUM_TAGS; i++) {",
            "                 rc = plc_tag_status(tag[i]);",
            "-                if(rc != PLCTAG_STATUS_OK) {",
            "-                    done = 0;",
            "-                }",
            "+                if(rc != PLCTAG_STATUS_OK) { done = 0; }",
            "             }",
            " ",
            "-            if(!done) {",
            "-                util_sleep_ms(1);",
            "-            }",
            "-        } while(timeout > util_time_ms() && !done) ;",
            "+            if(!done) { compat_sleep_ms(10, NULL); }",
            "+        } while(timeout > compat_time_ms() && !done);",
            " ",
            "         if(!done) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Timeout waiting for tags to be ready!\\n\");",
            "             rc = PLCTAG_ERR_TIMEOUT;",
            "             break;",
            "         }",
            " ",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         /* get the data */",
            "-        for(i=0; i < NUM_TAGS; i++) {",
            "+        for(i = 0; i < NUM_TAGS; i++) {",
            "             rc = plc_tag_read(tag[i], 0);",
            " ",
            "             if(rc != PLCTAG_STATUS_OK && rc != PLCTAG_STATUS_PENDING) {",
            "-                fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "                 break;",
            "             }",
            "         }",
            " ",
            "         /* wait for all to finish */",
            "         do {",
            "             done = 1;",
            " ",
            "-            for(i=0; i < NUM_TAGS; i++) {",
            "+            for(i = 0; i < NUM_TAGS; i++) {",
            "                 rc = plc_tag_status(tag[i]);",
            "-                if(rc != PLCTAG_STATUS_OK) {",
            "-                    done = 0;",
            "-                }",
            "+                if(rc != PLCTAG_STATUS_OK) { done = 0; }",
            "             }",
            " ",
            "-            if(!done) {",
            "-                util_sleep_ms(1);",
            "-            }",
            "-        } while(timeout > util_time_ms() && !done);",
            "+            if(!done) { compat_sleep_ms(10, NULL); }",
            "+        } while(timeout > compat_time_ms() && !done);",
            " ",
            "         if(!done) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Timeout waiting for tags to finish reading!\\n\");",
            "             rc = PLCTAG_ERR_TIMEOUT;",
            "             break;",
            "         }",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "         /* get any data we can */",
            "-        for(i=0; i < NUM_TAGS; i++) {",
            "+        for(i = 0; i < NUM_TAGS; i++) {",
            "             /* read complete! */",
            "-            fprintf(stderr,\"Tag %d data[0]=%d\\n\",i,plc_tag_get_int32(tag[i],0));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Tag %d data[0]=%d\\n\", i, plc_tag_get_int32(tag[i], 0));",
            "         }",
            "     } while(0);",
            " ",
            " ",
            "     /* we are done */",
            "-    for(i=0; i < NUM_TAGS; i++) {",
            "-        if(tag[i] != 0) {",
            "-            plc_tag_destroy(tag[i]);",
            "-        }",
            "+    for(i = 0; i < NUM_TAGS; i++) {",
            "+        if(tag[i] != 0) { plc_tag_destroy(tag[i]); }",
            "     }",
            " ",
            "     if(rc == PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Read %d tags in %dms\\n\", NUM_TAGS, (int)(end - start));",
            "     } else {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error found: %s\\n\", plc_tag_decode_error(rc));",
            "     }",
            " ",
            "     return rc;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/async_stress.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/async_stress.c",
            "+++ /home/libplctag-2.6.7/src/examples/async_stress.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -29,347 +29,283 @@",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            " /*",
            "- * This example reads a small set of tags repeatedly as fast as possible.  It does not destroy the tags on errors, but simply calls",
            "- * plc_tag_abort() and retries.",
            "+ * This example reads a small set of tags repeatedly as fast as possible.  It does not destroy the tags on errors, but simply",
            "+ * calls plc_tag_abort() and retries.",
            "  *",
            "  * Use ^C to terminate.",
            "  */",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            "-#include <string.h>",
            " #include <stdlib.h>",
            "-#include <inttypes.h>",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    #include <Windows.h>",
            "-#else",
            "-    #include <signal.h>",
            "-#endif",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include <string.h>",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,4,0",
            "+#define REQUIRED_VERSION 2, 4, 0",
            " ",
            " #define DATA_TIMEOUT (5000)",
            " #define TAG_CREATE_TIMEOUT (5000)",
            " #define RETRY_TIMEOUT (10000)",
            " ",
            " #define DEFAULT_TAG_PATH \"protocol=modbus-tcp&gateway=10.206.1.59:5020&path=0&elem_count=2&name=hr10\"",
            "-#define DEFAULT_THREAD_COUNT (10)",
            " ",
            " ",
            "-void usage(void)",
            "-{",
            "-    printf(\"Usage:\\n \"",
            "+void usage(void) {",
            "+    printf(",
            "+        \"Usage:\\n \"",
            "         \"async_stress <num tags> <path>\\n\"",
            "         \"  <num_tags> - The number of tags to use in the test.\\n\"",
            "         \"  <path> - The tag path to use.\\n\"",
            "         \"\\n\"",
            "         \"Example: async_stress 14 'protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=test_tag'\\n\");",
            " ",
            "     exit(PLCTAG_ERR_BAD_PARAM);",
            " }",
            " ",
            "+static volatile int done = 0;",
            " ",
            "-",
            "-#ifdef _WIN32",
            "-volatile int done = 0;",
            "-",
            "-/* straight from MS' web site :-) */",
            "-BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)",
            "-{",
            "-    switch (fdwCtrlType)",
            "-    {",
            "-        // Handle the CTRL-C signal.",
            "-    case CTRL_C_EVENT:",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-        // CTRL-CLOSE: confirm that the user wants to exit.",
            "-    case CTRL_CLOSE_EVENT:",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-        // Pass other signals to the next handler.",
            "-    case CTRL_BREAK_EVENT:",
            "-        done = 1;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_LOGOFF_EVENT:",
            "-        done = 1;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_SHUTDOWN_EVENT:",
            "-        done = 1;",
            "-        return FALSE;",
            "-",
            "-    default:",
            "-        return FALSE;",
            "-    }",
            "-}",
            "-",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))",
            "-    {",
            "-        printf(\"\\nERROR: Could not set control handler!\\n\");",
            "-        usage();",
            "-    }",
            "-}",
            "-",
            "-#else",
            "-volatile sig_atomic_t done = 0;",
            "-",
            "-void SIGINT_handler(int not_used)",
            "-{",
            "-    (void)not_used;",
            "-",
            "-    done = 1;",
            "-}",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    struct sigaction act;",
            "-",
            "-    /* set up signal handler. */",
            "-    memset(&act, 0, sizeof(act));",
            "-    act.sa_handler = SIGINT_handler;",
            "-    sigaction(SIGINT, &act, NULL);",
            "-}",
            "-",
            "-#endif",
            "-",
            "-",
            "+static void interrupt_handler(void) { done = 1; }",
            " ",
            " static int read_tags(int32_t *tags, int32_t *statuses, int num_tags, int timeout_ms);",
            " static int wait_for_tags(int32_t *tags, int32_t *statuses, int num_tags, int timeout_ms);",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int32_t *tags = NULL;",
            "     int *statuses = NULL;",
            "     int num_tags = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int i = 0;",
            "     int64_t start = 0;",
            "     int64_t end = 0;",
            "     int64_t total_ms = 0;",
            "     int64_t min_ms = INT64_MAX;",
            "     int64_t max_ms = 0;",
            "     int64_t iteration = 1;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* check the command line arguments */",
            "     if(argc != 3) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Must have number of tags and tag path!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     num_tags = atoi(argv[1]);",
            " ",
            "     if(num_tags <= 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Number of tags must be greater than zero!\\n\");",
            "         usage();",
            "     }",
            " ",
            "-    tags = calloc(sizeof(*tags), (size_t)(unsigned int)num_tags);",
            "+    tags = calloc((size_t)(unsigned int)num_tags, sizeof(*tags));",
            "     if(!tags) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error allocating tags array!\\n\");",
            "         exit(PLCTAG_ERR_NO_MEM);",
            "     }",
            " ",
            "-    statuses = calloc(sizeof(*statuses), (size_t)(unsigned int)num_tags);",
            "+    statuses = calloc((size_t)(unsigned int)num_tags, sizeof(*statuses));",
            "     if(!statuses) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error allocating status array!\\n\");",
            "         free(tags);",
            "         exit(PLCTAG_ERR_NO_MEM);",
            "     }",
            " ",
            "     /* set up handler for ^C etc. */",
            "-    setup_break_handler();",
            "+    compat_set_interrupt_handler(interrupt_handler);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Hit ^C to terminate the test.\\n\");",
            " ",
            "-    start = util_time_ms();",
            "+    start = compat_time_ms();",
            " ",
            "     /* create the tags */",
            "-    for(i=0; i< num_tags && !done; i++) {",
            "-        tags[i]  = plc_tag_create(argv[2], 0);",
            "+    for(i = 0; i < num_tags && !done; i++) {",
            "+        tags[i] = plc_tag_create(argv[2], 0);",
            "         statuses[i] = plc_tag_status(tags[i]);",
            " ",
            "         if(tags[i] < 0) {",
            "-            fprintf(stderr,\"Error %s: could not create tag %d\\n\", plc_tag_decode_error(tags[i]), i);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error %s: could not create tag %d\\n\", plc_tag_decode_error(tags[i]), i);",
            "             done = 1;",
            "         }",
            "     }",
            " ",
            "     if(!done) {",
            "         rc = wait_for_tags(tags, statuses, num_tags, TAG_CREATE_TIMEOUT);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            for(int i=0; i<num_tags; i++) {",
            "+            for(int i = 0; i < num_tags; i++) {",
            "                 if(statuses[i] != PLCTAG_STATUS_OK) {",
            "+                    // NOLINTNEXTLINE",
            "                     fprintf(stderr, \"Creation of tag %d failed with status %s!\\n\", i, plc_tag_decode_error(statuses[i]));",
            "                 }",
            " ",
            "                 plc_tag_destroy(tags[i]);",
            "             }",
            " ",
            "             done = 1;",
            "         }",
            "     }",
            " ",
            "-    end = util_time_ms();",
            "+    end = compat_time_ms();",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Creation of %d tags took %dms.\\n\", num_tags, (int)(end - start));",
            " ",
            "     /* read in a loop until ^C pressed */",
            "     while(!done) {",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         rc = read_tags(tags, statuses, num_tags, DATA_TIMEOUT);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "             int need_sleep = 0;",
            " ",
            "-            for(int i=0; i<num_tags; i++) {",
            "+            for(int i = 0; i < num_tags; i++) {",
            "                 if(statuses[i] != PLCTAG_STATUS_OK) {",
            "                     if(statuses[i] != PLCTAG_ERR_TIMEOUT) {",
            "+                        // NOLINTNEXTLINE",
            "                         fprintf(stderr, \"Tag %d read failed with status %s!\\n\", i, plc_tag_decode_error(statuses[i]));",
            "                         done = 1;",
            "                     } else {",
            "+                        // NOLINTNEXTLINE",
            "                         fprintf(stderr, \"Tag %d read failed with a timeout, will retry.\\n\", i);",
            "                         plc_tag_abort(tags[i]);",
            "                         need_sleep = 1;",
            "                     }",
            "                 }",
            "             }",
            " ",
            "-            if(need_sleep) {",
            "-                need_sleep = 0;",
            "-                util_sleep_ms(10); /* give the background thread time to process the abort. */",
            "-            }",
            "+            if(need_sleep) { compat_sleep_ms(10, NULL); /* give the background thread time to process the abort. */ }",
            "         }",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "         /* count up the total ms */",
            "         total_ms += (end - start);",
            " ",
            "         /* calculate the min and max time */",
            "-        if(max_ms < (end - start)) {",
            "-            max_ms = end - start;",
            "-        }",
            "+        if(max_ms < (end - start)) { max_ms = end - start; }",
            " ",
            "-        if(min_ms > (end - start)) {",
            "-            min_ms = end - start;",
            "-        }",
            "+        if(min_ms > (end - start)) { min_ms = end - start; }",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Read of %d tags took %dms.\\n\", num_tags, (int)(end - start));",
            " ",
            "         /* test */",
            "-        //util_sleep_ms(5);",
            "+        // thrd_sleep_ms(5);",
            " ",
            "         iteration++;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Program terminated!\\n\");",
            " ",
            "     /* we are done */",
            "-    for(i=0; i < num_tags; i++) {",
            "-        plc_tag_destroy(tags[i]);",
            "-    }",
            "+    for(i = 0; i < num_tags; i++) { plc_tag_destroy(tags[i]); }",
            " ",
            "     free(tags);",
            "     free(statuses);",
            " ",
            "-    fprintf(stderr,\"--- Ran %\" PRId64 \" iterations with a total io time of %\" PRId64 \"ms and min/avg/max of %\" PRId64 \"ms/%\" PRId64 \"ms/%\" PRId64 \"ms.\\n\", iteration, total_ms, min_ms, total_ms/iteration, max_ms);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr,",
            "+            \"--- Ran %\" PRId64 \" iterations with a total io time of %\" PRId64 \"ms and min/avg/max of %\" PRId64 \"ms/%\" PRId64",
            "+            \"ms/%\" PRId64 \"ms.\\n\",",
            "+            iteration, total_ms, min_ms, total_ms / iteration, max_ms);",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-int read_tags(int32_t *tags, int *statuses, int num_tags, int timeout_ms)",
            "-{",
            "+int read_tags(int32_t *tags, int *statuses, int num_tags, int timeout_ms) {",
            "     if(timeout_ms <= 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Timeout to read_tags() must be greater than zero!\\n\");",
            " ",
            "         return PLCTAG_ERR_BAD_PARAM;",
            "     }",
            " ",
            "     /* start the read. */",
            "-    for(int i=0; i<num_tags; i++) {",
            "+    for(int i = 0; i < num_tags; i++) {",
            "         statuses[i] = plc_tag_read(tags[i], 0);",
            " ",
            "         /* if any failed, we need to abort the request. */",
            "         if(statuses[i] != PLCTAG_STATUS_OK && statuses[i] != PLCTAG_STATUS_PENDING) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"1 Calling plc_tag_abort() on tag %d!\\n\", i);",
            "             plc_tag_abort(tags[i]);",
            "         }",
            "     }",
            " ",
            "     return wait_for_tags(tags, statuses, num_tags, timeout_ms);",
            " }",
            " ",
            " ",
            "-int wait_for_tags(int32_t *tags, int *statuses, int num_tags, int timeout_ms)",
            "-{",
            "-    int64_t end_timeout = (int64_t)timeout_ms + util_time_ms();",
            "+int wait_for_tags(int32_t *tags, int *statuses, int num_tags, int timeout_ms) {",
            "+    int64_t end_timeout = (int64_t)timeout_ms + compat_time_ms();",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int tags_pending = 0;",
            " ",
            "     /* the statuses must be primed before calling this function! */",
            "     do {",
            "         /* check the pending tags. */",
            "         tags_pending = 0;",
            "-        for(int i=0; i<num_tags; i++) {",
            "+        for(int i = 0; i < num_tags; i++) {",
            "             if(statuses[i] == PLCTAG_STATUS_PENDING) {",
            "                 statuses[i] = plc_tag_status(tags[i]);",
            " ",
            "                 /* still pending? */",
            "                 if(statuses[i] == PLCTAG_STATUS_PENDING) {",
            "                     tags_pending++;",
            "                 } else if(statuses[i] != PLCTAG_STATUS_OK) {",
            "                     /* not good, some sort of error! */",
            " ",
            "+                    // NOLINTNEXTLINE",
            "                     fprintf(stderr, \"Tag %d failed with status %s!\\n\", i, plc_tag_decode_error(statuses[i]));",
            " ",
            "+                    // NOLINTNEXTLINE",
            "                     fprintf(stderr, \"2 Calling plc_tag_abort() on tag %d!\\n\", i);",
            "                     plc_tag_abort(tags[i]);",
            "                 }",
            "             }",
            "         }",
            " ",
            "         /* anything left to do? */",
            "         if(tags_pending > 0) {",
            "             /* yes, there is, delay a bit. */",
            "-            util_sleep_ms(1);",
            "+            compat_sleep_ms(10, NULL);",
            "         }",
            "-    } while(tags_pending > 0 && end_timeout > util_time_ms() && !done);",
            "+    } while(tags_pending > 0 && end_timeout > compat_time_ms() && !done);",
            " ",
            "     rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* did any tags time out? */",
            "-    if(end_timeout <= util_time_ms()) {",
            "-        for(int i=0; i<num_tags; i++) {",
            "+    if(end_timeout <= compat_time_ms()) {",
            "+        for(int i = 0; i < num_tags; i++) {",
            "             if(statuses[i] == PLCTAG_STATUS_PENDING) {",
            "                 /* we timed out, so abort and mark the status. */",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Timed out, calling plc_tag_abort() on tag %d!\\n\", i);",
            "                 plc_tag_abort(tags[i]);",
            " ",
            "                 statuses[i] = PLCTAG_ERR_TIMEOUT;",
            " ",
            "                 rc = PLCTAG_ERR_PARTIAL;",
            "             } else if(statuses[i] != PLCTAG_STATUS_OK) {"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/barcode_test.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/barcode_test.c",
            "+++ /home/libplctag-2.6.7/src/examples/barcode_test.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,47 +28,51 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            " #include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdint.h>",
            "-#include \"../lib/libplctag.h\"",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TIMEOUT_MS (15000) /* a loooooong timeout */",
            " ",
            " #define NEW_BARCODE \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=1&elem_count=1&name=new_barcode\"",
            " #define BARCODE_PROCESSED \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=1&elem_count=1&name=barcode_processed\"",
            " #define BARCODE \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=88&elem_count=1&name=barcode\"",
            " ",
            "-#define TRY(f) if((rc = (f)) != PLCTAG_STATUS_OK) { printf(\"ERROR: \" #f \" failed with error %s!\\n\", plc_tag_decode_error(rc)); break; }",
            "+#define TRY(f)                                                                     \\",
            "+    if((rc = (f)) != PLCTAG_STATUS_OK) {                                           \\",
            "+        printf(\"ERROR: \" #f \" failed with error %s!\\n\", plc_tag_decode_error(rc)); \\",
            "+        break;                                                                     \\",
            "+    }",
            " ",
            " static int wait_for_new_barcode(void);",
            " static int read_barcode(void);",
            " static int mark_barcode_processed(void);",
            " ",
            "-int main(int argc, const char **argv)",
            "-{",
            "+int main(int argc, const char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    int64_t last_read = util_time_ms();",
            "+    int64_t last_read = compat_time_ms();",
            "     int64_t first_read = last_read;",
            " ",
            "     (void)argc;",
            "     (void)argv;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            " ",
            "     while(1) {",
            "         int64_t new_time;",
            "@@ -77,70 +81,68 @@",
            " ",
            "         TRY(wait_for_new_barcode())",
            " ",
            "         TRY(read_barcode())",
            " ",
            "         TRY(mark_barcode_processed())",
            " ",
            "-        new_time = util_time_ms();",
            "+        new_time = compat_time_ms();",
            " ",
            "         diff_time = new_time - last_read;",
            "         total_time = new_time - first_read;",
            " ",
            "         printf(\"Iteration took %\" PRId64 \"ms, total elapsed time is %\" PRId64 \"ms.\\n\", diff_time, total_time);",
            " ",
            "         last_read = new_time;",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int wait_for_new_barcode(void)",
            "-{",
            "+int wait_for_new_barcode(void) {",
            "     static int32_t new_barcode_tag = 0;",
            "     int rc = PLCTAG_STATUS_PENDING;",
            " ",
            "     if(new_barcode_tag <= 0) {",
            "         new_barcode_tag = plc_tag_create(NEW_BARCODE, TIMEOUT_MS);",
            " ",
            "         if(new_barcode_tag < 0) {",
            "             printf(\"ERROR: error creating tag for new_barcode!\\n\");",
            "             return new_barcode_tag;",
            "         }",
            "     }",
            " ",
            "-    rc = PLCTAG_STATUS_PENDING;",
            "     do {",
            "         uint8_t flag_val = 0;",
            " ",
            "         /* read the tag. */",
            "         TRY(plc_tag_read(new_barcode_tag, TIMEOUT_MS))",
            " ",
            "         /* get the flag value */",
            "         if((flag_val = plc_tag_get_uint8(new_barcode_tag, 0)) != UINT8_MAX) {",
            "             if(flag_val) {",
            "                 rc = PLCTAG_STATUS_OK;",
            "             } else {",
            "                 rc = PLCTAG_STATUS_PENDING;",
            "-                util_sleep_ms(4000);",
            "+                compat_sleep_ms(4000, NULL);",
            "             }",
            "         }",
            "     } while(rc == PLCTAG_STATUS_PENDING);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int read_barcode(void)",
            "-{",
            "+int read_barcode(void) {",
            "     static int32_t barcode_tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    char barcode_buf[85] = {0,};",
            "+    char barcode_buf[85] = {",
            "+        0,",
            "+    };",
            " ",
            "     if(barcode_tag <= 0) {",
            "         barcode_tag = plc_tag_create(BARCODE, TIMEOUT_MS);",
            " ",
            "         if(barcode_tag < 0) {",
            "             printf(\"ERROR: error creating tag for barcode!\\n\");",
            "             return barcode_tag;",
            "@@ -163,17 +165,15 @@",
            "     /* print out the barcode */",
            "     printf(\"Got barcode: %s\\n\", barcode_buf);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int mark_barcode_processed(void)",
            "-{",
            "+int mark_barcode_processed(void) {",
            "     static int32_t barcode_processed_tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     if(barcode_processed_tag <= 0) {",
            "         barcode_processed_tag = plc_tag_create(BARCODE_PROCESSED, TIMEOUT_MS);",
            " ",
            "         if(barcode_processed_tag < 0) {"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/busy_test.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/busy_test.c",
            "+++ /home/libplctag-2.6.7/src/examples/busy_test.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -35,149 +35,146 @@",
            " /*",
            "  * This example reads from a large DINT array.  It creates many tags that each read from one element of the",
            "  * array. It fires off all the tags at once and waits for them to complete the reads. In this case, it waits",
            "  * a fixed amount of time and then tries to read the tags.",
            "  */",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include <string.h>",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_ATTRIBS \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=LGX&elem_type=DINT&elem_count=%d&name=TestBigArray[%d]\"",
            "-#define NUM_TAGS  (5)",
            "+#define NUM_TAGS (5)",
            " #define NUM_ELEMS (10)",
            " #define DATA_TIMEOUT (1000)",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag[NUM_TAGS];",
            "     int rc;",
            "     int i;",
            "-    int64_t timeout = DATA_TIMEOUT + util_time_ms();",
            "+    int64_t timeout = DATA_TIMEOUT + compat_time_ms();",
            "     int done = 0;",
            "     int64_t start = 0;",
            "     int64_t end = 0;",
            "     int num_elems_per_tag = NUM_ELEMS / NUM_TAGS;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "-    fprintf(stderr, \"Using library version %d.%d.%d.\\n\",",
            "-                                            plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_minor\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Using library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "+            plc_tag_get_int_attribute(0, \"version_minor\", -1), plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            " ",
            "     /* turn off debugging output. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* create the tags */",
            "-    for(i=0; i< NUM_TAGS; i++) {",
            "-        char tmp_tag_path[256] = {0,};",
            "-        snprintf_platform(tmp_tag_path, sizeof tmp_tag_path,TAG_ATTRIBS, num_elems_per_tag, i);",
            "+    for(i = 0; i < NUM_TAGS; i++) {",
            "+        char tmp_tag_path[256] = {",
            "+            0,",
            "+        };",
            " ",
            "-        fprintf(stderr, \"Attempting to create tag with attribute string '%s'\\n\",tmp_tag_path);",
            "+        // NOLINTNEXTLINE",
            "+        compat_snprintf(tmp_tag_path, sizeof tmp_tag_path, TAG_ATTRIBS, num_elems_per_tag, i);",
            " ",
            "-        tag[i]  = plc_tag_create(tmp_tag_path, 0);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Attempting to create tag with attribute string '%s'\\n\", tmp_tag_path);",
            "+",
            "+        tag[i] = plc_tag_create(tmp_tag_path, 0);",
            " ",
            "         if(tag[i] < 0) {",
            "-            fprintf(stderr,\"Error %s: could not create tag %d\\n\",plc_tag_decode_error(tag[i]), i);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error %s: could not create tag %d\\n\", plc_tag_decode_error(tag[i]), i);",
            "         }",
            "     }",
            " ",
            "     /* wait for all the tags to complete creation. */",
            "     do {",
            "         done = 1;",
            " ",
            "-        for(i=0; i < NUM_TAGS; i++) {",
            "+        for(i = 0; i < NUM_TAGS; i++) {",
            "             rc = plc_tag_status(tag[i]);",
            "-            if(rc != PLCTAG_STATUS_OK) {",
            "-                done = 0;",
            "-            }",
            "+            if(rc != PLCTAG_STATUS_OK) { done = 0; }",
            "         }",
            " ",
            "-        if(!done) {",
            "-            util_sleep_ms(1);",
            "-        }",
            "-    } while(timeout > util_time_ms() && !done) ;",
            "+        if(!done) { compat_sleep_ms(10, NULL); }",
            "+    } while(timeout > compat_time_ms() && !done);",
            " ",
            "     if(!done) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Timeout waiting for tags to be ready!\\n\");",
            " ",
            "-        for(i=0; i < NUM_TAGS; i++) {",
            "-            plc_tag_destroy(tag[i]);",
            "-        }",
            "+        for(i = 0; i < NUM_TAGS; i++) { plc_tag_destroy(tag[i]); }",
            " ",
            "         return 1;",
            "     }",
            " ",
            "-    start = util_time_ms();",
            "+    start = compat_time_ms();",
            " ",
            "     /* get the data */",
            "-    for(i=0; i < NUM_TAGS; i++) {",
            "+    for(i = 0; i < NUM_TAGS; i++) {",
            "         rc = plc_tag_read(tag[i], 0);",
            "         if(rc != PLCTAG_STATUS_OK && rc != PLCTAG_STATUS_PENDING) {",
            "-            fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            " ",
            "             return 0;",
            "         }",
            " ",
            "         /* try to read again without aborting.  Should get a PLCTAG_ERR_BUSY error. */",
            "         rc = plc_tag_read(tag[i], 0);",
            "         if(rc != PLCTAG_ERR_BUSY) {",
            "-            fprintf(stderr,\"ERROR: Expected PLCTAG_ERR_BUSY, got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: Expected PLCTAG_ERR_BUSY, got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            " ",
            "             return 0;",
            "         }",
            "-",
            "     }",
            " ",
            "     /* wait for all to finish */",
            "     do {",
            "         done = 1;",
            " ",
            "-        for(i=0; i < NUM_TAGS; i++) {",
            "+        for(i = 0; i < NUM_TAGS; i++) {",
            "             rc = plc_tag_status(tag[i]);",
            "-            if(rc != PLCTAG_STATUS_OK) {",
            "-                done = 0;",
            "-            }",
            "+            if(rc != PLCTAG_STATUS_OK) { done = 0; }",
            "         }",
            " ",
            "-        if(!done) {",
            "-            util_sleep_ms(1);",
            "-        }",
            "-    } while(timeout > util_time_ms() && !done);",
            "+        if(!done) { compat_sleep_ms(10, NULL); }",
            "+    } while(timeout > compat_time_ms() && !done);",
            " ",
            "     if(!done) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Timeout waiting for tags to finish reading!\\n\");",
            " ",
            "-        for(i=0; i < NUM_TAGS; i++) {",
            "-            plc_tag_destroy(tag[i]);",
            "-        }",
            "+        for(i = 0; i < NUM_TAGS; i++) { plc_tag_destroy(tag[i]); }",
            " ",
            "         return 1;",
            "     }",
            " ",
            "-    end = util_time_ms();",
            "+    end = compat_time_ms();",
            " ",
            "     /* get any data we can */",
            "-    for(i=0; i < NUM_TAGS; i++) {",
            "+    for(i = 0; i < NUM_TAGS; i++) {",
            "         /* read complete! */",
            "-        fprintf(stderr,\"Tag %d data[0]=%d\\n\",i,plc_tag_get_int32(tag[i],0));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Tag %d data[0]=%d\\n\", i, plc_tag_get_int32(tag[i], 0));",
            "     }",
            " ",
            " ",
            "     /* we are done */",
            "-    for(i=0; i < NUM_TAGS; i++) {",
            "-        plc_tag_destroy(tag[i]);",
            "-    }",
            "+    for(i = 0; i < NUM_TAGS; i++) { plc_tag_destroy(tag[i]); }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Read %d tags in %dms\\n\", NUM_TAGS, (int)(end - start));",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/data_dumper.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/data_dumper.c",
            "+++ /home/libplctag-2.6.7/src/examples/data_dumper.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,36 +28,32 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "-#include <stdio.h>",
            "+#include \"compat_utils.h\"",
            " #include <ctype.h>",
            "-#include <unistd.h>",
            "-#include <time.h>",
            "-#include <string.h>",
            "-#include <sys/time.h>",
            "-#include <sys/select.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdio.h>",
            " #include <stdlib.h>",
            "-#include <signal.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include <string.h>",
            "+#include <time.h>",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 6, 4",
            " ",
            " #define MAX_TAGS 5000",
            " #define RECONNECT_DELAY_MS 5000",
            " ",
            " ",
            "-typedef enum { UNKNOWN = 0, DINT, INT, SINT, REAL } data_type_t;",
            "+typedef enum { UNKNOWN = 0, i32_type, i16_type, i8_type, f32_type } data_type_t;",
            " ",
            " struct {",
            "-    const char *name;",
            "+    char *name;",
            "     int rpi;",
            "     int64_t next_read;",
            "     int32_t tag_id;",
            "     int reading;",
            "     data_type_t data_type;",
            "     union {",
            "         int32_t DINT_val;",
            "@@ -66,228 +62,236 @@",
            "         float REAL_val;",
            "     } val;",
            " } tags[MAX_TAGS];",
            " ",
            " int num_tags = 0;",
            " ",
            " ",
            "-volatile sig_atomic_t terminate = 0;",
            "-",
            "+volatile int terminate = 0;",
            " ",
            " ",
            "-int is_comment(const char *line)",
            "-{",
            "+int is_comment(const char *line) {",
            "     int i = 0;",
            " ",
            "     /* scan past the first whitespace */",
            "-    for(i=0; line[i] && isspace(line[i]); i++);",
            "+    for(i = 0; line[i] && isspace(line[i]); i++);",
            " ",
            "     return (line[i] == '#') ? 1 : 0;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-char **split_string(const char *str, const char *sep)",
            "-{",
            "-    size_t sub_str_count=0;",
            "+char **split_string(const char *str, const char *sep) {",
            "+    size_t sub_str_count = 0;",
            "     size_t source_size = 0;",
            "     size_t result_size = 0;",
            "     const char *sub;",
            "     const char *tmp;",
            "     char **res = NULL;",
            " ",
            "     /* first, count the sub strings */",
            "     tmp = str;",
            "     sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front. */",
            "-        if(sub != tmp) {",
            "-            sub_str_count++;",
            "-        }",
            "+        if(sub != tmp) { sub_str_count++; }",
            " ",
            "         tmp = sub + strlen(sep);",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "-    if(tmp && *tmp && (!sub || !*sub)) {",
            "-        sub_str_count++;",
            "-    }",
            "+    if(tmp && *tmp && (!sub || !*sub)) { sub_str_count++; }",
            " ",
            "     /* calculate total size for string plus pointers */",
            "     source_size = strlen(str) + 1;",
            "-    result_size = (sizeof(char *)*(sub_str_count+1)) + source_size;",
            "+    result_size = (sizeof(char *) * (sub_str_count + 1)) + source_size;",
            " ",
            "     /* allocate enough memory */",
            "     res = malloc(result_size);",
            "-    if(!res) {",
            "-        return NULL;",
            "-    }",
            "+    if(!res) { return NULL; }",
            " ",
            "     /* calculate the beginning of the string */",
            "-    tmp = (char *)res + (sizeof(char *) * (size_t)(sub_str_count+1));",
            "+    tmp = (char *)res + (sizeof(char *) * (size_t)(sub_str_count + 1));",
            " ",
            "     /* copy the string into the new buffer past the first part with the array of char pointers. */",
            "+    // NOLINTNEXTLINE",
            "     strcpy((char *)tmp, str);",
            " ",
            "     /* set up the pointers */",
            "-    sub_str_count=0;",
            "+    sub_str_count = 0;",
            "     sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front */",
            "         if(sub != tmp) {",
            "             /* store the pointer */",
            "             res[sub_str_count] = (char *)tmp;",
            " ",
            "             sub_str_count++;",
            "         }",
            " ",
            "         /* zero out the separator chars */",
            "-        memset((char*)sub, 0, strlen(sep));",
            "+        // NOLINTNEXTLINE",
            "+        memset((char *)sub, 0, strlen(sep));",
            " ",
            "         /* point past the separator (now zero) */",
            "         tmp = sub + strlen(sep);",
            " ",
            "         /* find the next separator */",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "     /* if there is a chunk at the end, store it. */",
            "-    if(tmp && *tmp && (!sub || !*sub)) {",
            "-        res[sub_str_count] = (char*)tmp;",
            "-    }",
            "+    if(tmp && *tmp && (!sub || !*sub)) { res[sub_str_count] = (char *)tmp; }",
            " ",
            "     return res;",
            " }",
            " ",
            " ",
            " /*",
            "  * line format:",
            "  *",
            "  * <name>\\t<type>\\t<rpi>\\t<tag string>",
            "  */",
            "-int process_line(const char *line)",
            "-{",
            "+int process_line(const char *line) {",
            "+    int rc = PLCTAG_STATUS_OK;",
            "     char **parts = NULL;",
            " ",
            "-    parts = split_string(line, \"\\t\");",
            "-    if(!parts) {",
            "-        fprintf(stderr,\"Splitting string failed for string %s!\", line);",
            "-        return PLCTAG_ERR_BAD_CONFIG;",
            "-    }",
            "-",
            "-    /* make sure we got 4 pieces. */",
            "-    for(int i=0; i < 4; i++) {",
            "-        if(parts[i] == NULL) {",
            "-            fprintf(stderr, \"Line does not contain enough parts. Line: %s\\n\", line);",
            "-            return PLCTAG_ERR_BAD_CONFIG;",
            "+    do {",
            "+        parts = split_string(line, \"\\t\");",
            "+        if(!parts) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Splitting string failed for string %s!\", line);",
            "+            rc = PLCTAG_ERR_BAD_CONFIG;",
            "+            break;",
            "         }",
            "-    }",
            " ",
            "-    tags[num_tags].name = strdup(parts[0]);",
            "-",
            "-    if(strcasecmp(\"dint\",parts[1]) == 0) {",
            "-        tags[num_tags].data_type = DINT;",
            "-    } else if(strcasecmp(\"int\", parts[1]) == 0) {",
            "-        tags[num_tags].data_type = INT;",
            "-    } else if(strcasecmp(\"sint\", parts[1]) == 0) {",
            "-        tags[num_tags].data_type = SINT;",
            "-    } else if(strcasecmp(\"real\", parts[1]) == 0) {",
            "-        tags[num_tags].data_type = REAL;",
            "-    } else {",
            "-        fprintf(stderr, \"Unknown data type for %s!\\n\", parts[1]);",
            "-        return PLCTAG_ERR_BAD_CONFIG;",
            "-    }",
            " ",
            "-    tags[num_tags].rpi = atoi(parts[2]);",
            "-    tags[num_tags].next_read = 0;",
            "-    tags[num_tags].tag_id = plc_tag_create(parts[3], 0); /* create async */",
            "+        /* make sure we got 4 pieces. */",
            "+        for(int i = 0; i < 4; i++) {",
            "+            if(parts[i] == NULL) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Line does not contain enough parts. Line: %s\\n\", line);",
            "+                free(parts);",
            "+                parts = NULL;",
            "+                rc = PLCTAG_ERR_BAD_CONFIG;",
            "+                break;",
            "+            }",
            "+        }",
            "+",
            "+        /* if we dropped out of the for loop, we still need to drop out of the do/while. */",
            "+        if(rc != PLCTAG_STATUS_OK) { break; }",
            "+",
            "+        tags[num_tags].name = strdup(parts[0]);",
            " ",
            "-    if(tags[num_tags].tag_id < 0) {",
            "-        fprintf(stderr, \"Error, %s, creating tag %s with string %s!\\n\", plc_tag_decode_error(tags[num_tags].tag_id), tags[num_tags].name, parts[3]);",
            "+        if(compat_strcasecmp(\"dint\", parts[1]) == 0) {",
            "+            tags[num_tags].data_type = i32_type;",
            "+        } else if(compat_strcasecmp(\"int\", parts[1]) == 0) {",
            "+            tags[num_tags].data_type = i16_type;",
            "+        } else if(compat_strcasecmp(\"sint\", parts[1]) == 0) {",
            "+            tags[num_tags].data_type = i8_type;",
            "+        } else if(compat_strcasecmp(\"real\", parts[1]) == 0) {",
            "+            tags[num_tags].data_type = f32_type;",
            "+        } else {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Unknown data type for %s!\\n\", parts[1]);",
            "+            rc = PLCTAG_ERR_BAD_CONFIG;",
            "+            break;",
            "+        }",
            "+",
            "+        tags[num_tags].rpi = atoi(parts[2]);",
            "+        tags[num_tags].next_read = 0;",
            "+        tags[num_tags].tag_id = plc_tag_create(parts[3], 0); /* create async */",
            "+",
            "+        if(tags[num_tags].tag_id < 0) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error, %s, creating tag %s with string %s!\\n\", plc_tag_decode_error(tags[num_tags].tag_id),",
            "+                    tags[num_tags].name, parts[3]);",
            "+            rc = tags[num_tags].tag_id;",
            "+        }",
            "+    } while(0);",
            "+",
            "+    if(parts) {",
            "         free(parts);",
            "-        return tags[num_tags].tag_id;",
            "+        parts = NULL;",
            "     }",
            " ",
            "-    //printf(\"Tag %d has name %s, type %s, RPI %d, and tag string %s\\n\",num_tags, parts[0], parts[1], tags[num_tags].rpi, parts[3]);",
            "-",
            "-    free(parts);",
            "+    if(rc != PLCTAG_STATUS_OK) {",
            "+        free(tags[num_tags].name);",
            "+    } else {",
            "+        num_tags++;",
            "+    }",
            " ",
            "-    num_tags++;",
            "+    // printf(\"Tag %d has name %s, type %s, RPI %d, and tag string %s\\n\",num_tags, parts[0], parts[1], tags[num_tags].rpi,",
            "+    // parts[3]);",
            " ",
            "-    return PLCTAG_STATUS_OK;",
            "+    return rc;",
            " }",
            " ",
            " ",
            "-void trim_line(char *line)",
            "-{",
            "+void trim_line(char *line) {",
            "     int len = 0;",
            " ",
            "-    if(!line || strlen(line) == 0) {",
            "-        return;",
            "-    }",
            "+    if(!line || strlen(line) == 0) { return; }",
            " ",
            "     len = (int)strlen(line);",
            " ",
            "-    while(len>0 && line[len - 1] == '\\n') {",
            "+    while(len > 0 && line[len - 1] == '\\n') {",
            "         line[len - 1] = 0;",
            "         len--;",
            "     }",
            " }",
            " ",
            " ",
            "-int read_config(const char *config_filename)",
            "-{",
            "+int read_config(const char *config_filename) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     FILE *config = NULL;",
            "-    char line[1024] = {0,};",
            "+    char line[1024] = {",
            "+        0,",
            "+    };",
            "     int line_num = 0;",
            " ",
            "-//    printf(\"Reading config file %s.\\n\", config_filename);",
            "+    //    printf(\"Reading config file %s.\\n\", config_filename);",
            " ",
            "     /* open the config file */",
            "-    config = fopen(config_filename,\"r\");",
            "+    config = fopen(config_filename, \"r\");",
            "     if(!config) {",
            "-        fprintf(stderr,\"Unable to open config file %s!\\n\", config_filename);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to open config file %s!\\n\", config_filename);",
            "         return PLCTAG_ERR_NOT_FOUND;",
            "     }",
            " ",
            "     /* read all the lines */",
            "-    while (fgets(line, sizeof(line), config)) {",
            "+    while(fgets(line, sizeof(line), config)) {",
            "         line_num++;",
            " ",
            "         trim_line(line);",
            " ",
            "-//        printf(\"Processing line %d: %s\\n\", line_num, line);",
            "+        //        printf(\"Processing line %d: %s\\n\", line_num, line);",
            " ",
            "         /* skip blank lines and comments */",
            "-        if(strlen(line) < 25 || is_comment(line)) {",
            "-            continue;",
            "-        }",
            "+        if(strlen(line) < 25 || is_comment(line)) { continue; }",
            " ",
            "         if((rc = process_line(line)) != PLCTAG_STATUS_OK) {",
            "-            fprintf(stderr,\"Error, %s, processing config file on line %d!\\n\", plc_tag_decode_error(rc), line_num);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error, %s, processing config file on line %d!\\n\", plc_tag_decode_error(rc), line_num);",
            "             fclose(config);",
            "             return rc;",
            "         }",
            "     }",
            " ",
            "     fclose(config);",
            " ",
            "     printf(\"Read %d tags from the config file.\\n\", num_tags);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-FILE *check_log_file()",
            "-{",
            "+FILE *check_log_file(void) {",
            "     static int log_year = 0;",
            "     static int log_month = 0;",
            "     static int log_day = 0;",
            "     static FILE *log = NULL;",
            "     time_t t = time(NULL);",
            "     struct tm *tm_struct;",
            " ",
            "@@ -297,283 +301,277 @@",
            "     if(log_year != tm_struct->tm_year || log_month != tm_struct->tm_mon || log_day != tm_struct->tm_mday) {",
            "         char log_file_name[128];",
            " ",
            "         log_year = tm_struct->tm_year;",
            "         log_month = tm_struct->tm_mon;",
            "         log_day = tm_struct->tm_mday;",
            " ",
            "-        snprintf(log_file_name, sizeof(log_file_name),\"log-%04d-%02d-%02d.log\", 1900+log_year, log_month, log_day);",
            "-        if(log) {",
            "-            fclose(log);",
            "-        }",
            "+        // NOLINTNEXTLINE",
            "+        snprintf(log_file_name, sizeof(log_file_name), \"log-%04d-%02d-%02d.log\", 1900 + log_year, log_month, log_day);",
            "+        if(log) { fclose(log); }",
            " ",
            "-        log = fopen(log_file_name,\"a\");",
            "+        log = fopen(log_file_name, \"a\");",
            "     }",
            " ",
            "     return log;",
            " }",
            " ",
            " ",
            "-",
            "-int make_prefix(char *prefix_buf, int prefix_buf_size)",
            "-{",
            "+int make_prefix(char *prefix_buf, int prefix_buf_size) {",
            "     struct tm t;",
            "     time_t epoch;",
            "     int64_t epoch_ms;",
            "     int remainder_ms;",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* make sure we have room, MAGIC */",
            "-    if(prefix_buf_size < 37) {",
            "-        return PLCTAG_ERR_TOO_SMALL;",
            "-    }",
            "+    if(prefix_buf_size < 37) { return PLCTAG_ERR_TOO_SMALL; }",
            " ",
            "     /* build the prefix */",
            " ",
            "     /* get the time parts */",
            "-    epoch_ms = util_time_ms();",
            "-    epoch = (time_t)(epoch_ms/1000);",
            "+    epoch_ms = compat_time_ms();",
            "+    epoch = (time_t)(epoch_ms / 1000);",
            "     remainder_ms = (int)(epoch_ms % 1000);",
            " ",
            "     /* FIXME - should capture error return! */",
            "-    localtime_r(&epoch,&t);",
            "+    localtime_r(&epoch, &t);",
            " ",
            "     /* create the prefix and format for the file entry. */",
            "-    rc = snprintf(prefix_buf, (size_t)prefix_buf_size,\"%04d-%02d-%02d %02d:%02d:%02d.%03d\",",
            "-                  t.tm_year+1900,t.tm_mon,t.tm_mday,t.tm_hour,t.tm_min,t.tm_sec,remainder_ms);",
            "+    // NOLINTNEXTLINE",
            "+    rc = snprintf(prefix_buf, (size_t)prefix_buf_size, \"%04d-%02d-%02d %02d:%02d:%02d.%03d\", t.tm_year + 1900, t.tm_mon,",
            "+                  t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, remainder_ms);",
            " ",
            "     /* enforce zero string termination */",
            "     if(rc > 1 && rc < prefix_buf_size) {",
            "         prefix_buf[rc] = 0;",
            "     } else {",
            "         prefix_buf[prefix_buf_size - 1] = 0;",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int log_data()",
            "-{",
            "+int log_data(void) {",
            "     FILE *log = check_log_file();",
            "     char timestamp_buf[128];",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     if(!log) {",
            "-        fprintf(stderr,\"Error opening log file!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error opening log file!\\n\");",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     rc = make_prefix(timestamp_buf, sizeof(timestamp_buf));",
            "     if(rc < 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to make prefix, error %s!\\n\", plc_tag_decode_error(rc));",
            "         return rc;",
            "     }",
            " ",
            "-    for(int tag=0; tag < num_tags; tag++) {",
            "+    for(int tag = 0; tag < num_tags; tag++) {",
            "         /* skip if this tag is not being read. */",
            "-        if(!tags[tag].reading) {",
            "-            continue;",
            "-        }",
            "+        if(!tags[tag].reading) { continue; }",
            " ",
            "-        fprintf(log,\"%s,%s\",timestamp_buf, tags[tag].name);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(log, \"%s,%s\", timestamp_buf, tags[tag].name);",
            " ",
            "         switch(tags[tag].data_type) {",
            "-        case DINT:",
            "-            fprintf(log,\",%d\\n\",plc_tag_get_int32(tags[tag].tag_id,0));",
            "-            break;",
            "-",
            "-        case INT:",
            "-            fprintf(log,\",%d\\n\",plc_tag_get_int16(tags[tag].tag_id,0));",
            "-            break;",
            "-",
            "-        case SINT:",
            "-            fprintf(log,\",%d\\n\",plc_tag_get_int8(tags[tag].tag_id,0));",
            "-            break;",
            "-",
            "-        case REAL:",
            "-            fprintf(log,\",%f\\n\",plc_tag_get_float32(tags[tag].tag_id,0));",
            "-            break;",
            "-",
            "-        default:",
            "-            fprintf(stderr,\"Unknown datatype (%d) for tag %d!\\n\", tags[tag].data_type, tag);",
            "-            return PLCTAG_ERR_BAD_CONFIG;",
            "-            break;",
            "+            case i32_type:",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(log, \",%d\\n\", plc_tag_get_int32(tags[tag].tag_id, 0));",
            "+                break;",
            "+",
            "+            case i16_type:",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(log, \",%d\\n\", plc_tag_get_int16(tags[tag].tag_id, 0));",
            "+                break;",
            "+",
            "+            case i8_type:",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(log, \",%d\\n\", plc_tag_get_int8(tags[tag].tag_id, 0));",
            "+                break;",
            "+",
            "+            case f32_type:",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(log, \",%f\\n\", plc_tag_get_float32(tags[tag].tag_id, 0));",
            "+                break;",
            "+",
            "+            default:",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Unknown datatype (%d) for tag %d!\\n\", tags[tag].data_type, tag);",
            "+                return PLCTAG_ERR_BAD_CONFIG;",
            "+                break;",
            "         }",
            "     }",
            " ",
            "     fflush(log);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            " /* loop while any tag is still in PLCTAG_STATUS_PENDING status */",
            "-int check_tags()",
            "-{",
            "+int check_tags(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     for(int t = 0; t < num_tags; t++) {",
            "         rc = plc_tag_status(tags[t].tag_id);",
            " ",
            "-        if(rc != PLCTAG_STATUS_OK) {",
            "-            return rc;",
            "-        }",
            "+        if(rc != PLCTAG_STATUS_OK) { return rc; }",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-void destroy_tags()",
            "-{",
            "-    for(int t=0; t<num_tags; t++) {",
            "+void destroy_tags(void) {",
            "+    for(int t = 0; t < num_tags; t++) {",
            "         if(tags[t].name) {",
            "-            free((char*)tags[t].name);",
            "+            free((char *)tags[t].name);",
            "             plc_tag_destroy(tags[t].tag_id);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-int start_reads()",
            "-{",
            "-    int64_t now = util_time_ms();",
            "+int start_reads(void) {",
            "+    int64_t now = compat_time_ms();",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* kick off any reads that need to happen */",
            "-    for(int t=0; t<num_tags; t++) {",
            "+    for(int t = 0; t < num_tags; t++) {",
            "         /* trigger a read if the interval is overdue. */",
            "         if(tags[t].next_read < now) {",
            "             tags[t].next_read = now + tags[t].rpi;",
            " ",
            "             tags[t].reading = 1;",
            " ",
            "             rc = plc_tag_read(tags[t].tag_id, 0);",
            "             if(rc != PLCTAG_STATUS_PENDING) {",
            "-                fprintf(stderr,\"Unable to start reading tag %s!\\n\", plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Unable to start reading tag %s!\\n\", plc_tag_decode_error(rc));",
            "                 destroy_tags();",
            "                 return rc;",
            "             }",
            "         } else {",
            "             /* this tag is not being read. */",
            "             tags[t].reading = 0;",
            "         }",
            "     }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-void SIGINT_handler(int not_used)",
            "-{",
            "-    (void)not_used;",
            "-",
            "-    terminate = 1;",
            "-}",
            "+void interrupt_handler(void) { terminate = 1; }",
            " ",
            "-void usage(void)",
            "-{",
            "+void usage(void) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Usage: data_dumper <config file>\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"The config file must contain tab-delimited rows in the following format:\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"\\t<name>\\\\t<type>\\\\t<rpi>\\\\t<tag string>\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"\\t<name> = a name used when outputting the data.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"\\t<type> = The type of the tag.  One of 'dint', 'int', 'sint', 'real'.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"\\t<rpi> = The number of milliseconds between reads of the tag.\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"\\t<tag string> = The tag attribute string for this tag.  E.g.:\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"\\t\\tprotocol=ab-eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=4&elem_count=10&name=TestDINTArray[0]\\n\");",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Example:\\n\");",
            "-    fprintf(stderr, \"TestData\\tdint\\t100\\tprotocol=ab-eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=4&elem_count=10&name=TestDINTArray[0]\\n\");",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(",
            "+        stderr,",
            "+        \"TestData\\tdint\\t100\\tprotocol=ab-eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=4&elem_count=10&name=TestDINTArray[0]\\n\");",
            " }",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc;",
            "-    struct sigaction act;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* set up signal handler first. */",
            "-    act.sa_handler = SIGINT_handler;",
            "-    sigaction(SIGINT, &act, NULL);",
            "+    compat_set_interrupt_handler(interrupt_handler);",
            " ",
            "+    /* clear the array of tags. */",
            "+    // NOLINTNEXTLINE",
            "     memset(&tags, 0, sizeof(tags));",
            " ",
            "     if(argc < 2) {",
            "         usage();",
            " ",
            "         return 1;",
            "     }",
            " ",
            "     if((rc = read_config(argv[1])) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Unable to read config or set up tags. %s!\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to read config or set up tags. %s!\\n\", plc_tag_decode_error(rc));",
            "         destroy_tags();",
            "         return 1;",
            "     }",
            " ",
            "     /* wait for all tags to be ready */",
            "-    while((rc = check_tags()) == PLCTAG_STATUS_PENDING) {",
            "-        util_sleep_ms(1);",
            "-    }",
            "+    while((rc = check_tags()) == PLCTAG_STATUS_PENDING) { compat_sleep_ms(10, NULL); }",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error waiting for tags to finish being set up, %s!\\n\", plc_tag_decode_error(rc));",
            "         destroy_tags();",
            "         return 1;",
            "     }",
            " ",
            "     while(!terminate) {",
            "         int num_tags_read = 0;",
            "         int64_t start, end;",
            " ",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         rc = start_reads();",
            " ",
            "         if(rc == PLCTAG_STATUS_OK) {",
            "             /* reads kicked off successfully */",
            " ",
            "             /* wait for the reads to complete */",
            "-            while((rc = check_tags()) == PLCTAG_STATUS_PENDING) {",
            "-                util_sleep_ms(1);",
            "-            }",
            "+            while((rc = check_tags()) == PLCTAG_STATUS_PENDING) { compat_sleep_ms(10, NULL); }",
            " ",
            "-            end = util_time_ms();",
            "+            end = compat_time_ms();",
            " ",
            "             if(rc == PLCTAG_STATUS_OK) {",
            "                 /* tags are ready. */",
            " ",
            "-                for(int t=0; t<num_tags; t++) {",
            "-                    if(tags[t].reading) {",
            "-                        num_tags_read++;",
            "-                    }",
            "+                for(int t = 0; t < num_tags; t++) {",
            "+                    if(tags[t].reading) { num_tags_read++; }",
            "                 }",
            " ",
            "-                if(num_tags_read > 0) {",
            "-                    printf(\"Read %d tags in %dms\\n\", num_tags_read, (int)(end-start));",
            "-                }",
            "+                if(num_tags_read > 0) { printf(\"Read %d tags in %dms\\n\", num_tags_read, (int)(end - start)); }",
            " ",
            "                 rc = log_data();",
            "             }",
            "         }",
            " ",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "             /* delay a long delay to let the library reconnect. */",
            "-            util_sleep_ms(RECONNECT_DELAY_MS);",
            "+            compat_sleep_ms(RECONNECT_DELAY_MS, NULL);",
            "         } else {",
            "             /* delay a tiny bit. */",
            "-            util_sleep_ms(1);",
            "+            compat_sleep_ms(10, NULL);",
            "         }",
            "     }",
            " ",
            "     printf(\"Terminating!\\n\");",
            " ",
            "     destroy_tags();"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/list_tags_logix.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/list_tags_logix.c",
            "+++ /home/libplctag-2.6.7/src/examples/list_tags_logix.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,22 +28,22 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,4,0",
            "+#define REQUIRED_VERSION 2, 4, 0",
            " ",
            " #define TAG_STRING_SIZE (200)",
            " #define TAG_STRING_TEMPLATE \"protocol=ab-eip&gateway=%s&path=%s&plc=ControlLogix&name=\"",
            " #define TIMEOUT_MS 5000",
            " ",
            " ",
            " #define TYPE_IS_STRUCT ((uint16_t)0x8000)",
            "@@ -52,17 +52,14 @@",
            " #define TYPE_UDT_ID_MASK ((uint16_t)0x0FFF)",
            " #define TAG_DIM_MASK ((uint16_t)0x6000)",
            " ",
            " ",
            " #define MAX_UDTS (1 << 12)",
            " ",
            " ",
            "-",
            "-",
            "-",
            " struct program_entry_s {",
            "     struct program_entry_s *next;",
            "     char *program_name;",
            " };",
            " ",
            " struct tag_entry_s {",
            "     struct tag_entry_s *next;",
            "@@ -92,122 +89,140 @@",
            "     uint16_t num_fields;",
            "     uint16_t struct_handle;",
            "     uint32_t instance_size;",
            "     struct udt_field_entry_s fields[];",
            " };",
            " ",
            " ",
            "-",
            "-",
            " static void usage(void);",
            " static char *setup_tag_string(int argc, char **argv);",
            " static int open_tag(char *base, char *tag_name);",
            " static int get_tag_list(int32_t tag_id, struct tag_entry_s **tag_list, struct tag_entry_s *parent);",
            " static void print_element_type(uint16_t element_type);",
            "-static int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list, struct tag_entry_s *parent);",
            "+static int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list,",
            "+                             struct tag_entry_s *parent);",
            " static int get_udt_definition(char *base, uint16_t udt_id);",
            " ",
            " ",
            " /* a local cache of all found UDT definitions. */",
            "-static struct udt_entry_s *udts[MAX_UDTS] = { NULL };",
            "+static struct udt_entry_s *udts[MAX_UDTS] = {NULL};",
            " static uint16_t udts_to_process[MAX_UDTS] = {0};",
            " static int last_udt = 0;",
            " static int current_udt = 0;",
            " ",
            " ",
            " static int debug_level = PLCTAG_DEBUG_NONE;",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     char *host = NULL;",
            "     char *path = NULL;",
            "     char *tag_string_base = NULL;",
            "     int32_t controller_listing_tag = 0;",
            "     int32_t program_listing_tag = 0;",
            "     struct tag_entry_s *tag_list = NULL;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION,",
            "+                version_major, version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "-    plc_tag_set_debug_level(PLCTAG_DEBUG_ERROR);",
            "+    plc_tag_set_debug_level(PLCTAG_DEBUG_WARN);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     /* clear the UDTs. */",
            "-    for(int index = 0; index < MAX_UDTS; index++) {",
            "-        udts[index] = NULL;",
            "-    }",
            "+    for(int index = 0; index < MAX_UDTS; index++) { udts[index] = NULL; }",
            " ",
            "     debug_level = plc_tag_get_int_attribute(0, \"debug\", PLCTAG_DEBUG_NONE);",
            " ",
            "     tag_string_base = setup_tag_string(argc, argv);",
            "     if(tag_string_base == NULL) {",
            "-        fprintf(stderr,\"Unable to set up the tag string base!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to set up the tag string base!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     /* this means that the args are right. */",
            "     host = argv[1];",
            "     path = argv[2];",
            " ",
            "     /* set up the tag for the listing first. */",
            "     controller_listing_tag = open_tag(tag_string_base, \"@tags\");",
            "     if(controller_listing_tag <= 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to create listing tag, error %s!\\n\", plc_tag_decode_error(controller_listing_tag));",
            "         usage();",
            "     }",
            " ",
            "     /* get the list of controller tags. */",
            "     rc = get_tag_list(controller_listing_tag, &tag_list, NULL);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to get tag list or no tags visible in the target PLC, error %s!\\n\", plc_tag_decode_error(rc));",
            "         usage();",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Controller tag listing tag ID: %d\\n\", controller_listing_tag);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Controller tag listing tag ID: %d\\n\", controller_listing_tag);",
            "+    }",
            " ",
            "     /*",
            "      * now loop through the tags and get the list for the program tags.",
            "      *",
            "      * This is safe because we push the new tags on the front of the list and",
            "      * so do not change any existing tag in the list.",
            "      */",
            "     for(struct tag_entry_s *entry = tag_list; entry; entry = entry->next) {",
            "         if(strncmp(entry->name, \"Program:\", strlen(\"Program:\")) == 0) {",
            "             char buf[256] = {0};",
            " ",
            "             /* this is a program tag, check for its tags. */",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Getting tags for program \\\"%s\\\".\\n\", entry->name);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Getting tags for program \\\"%s\\\".\\n\", entry->name);",
            "+            }",
            " ",
            "+            // NOLINTNEXTLINE",
            "             snprintf(buf, sizeof(buf), \"%s.@tags\", entry->name);",
            " ",
            "             program_listing_tag = open_tag(tag_string_base, buf);",
            "             if(program_listing_tag <= 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to create listing tag, error %s!\\n\", plc_tag_decode_error(program_listing_tag));",
            "                 usage();",
            "             }",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            }",
            " ",
            "             rc = get_tag_list(program_listing_tag, &tag_list, entry);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "-                fprintf(stderr, \"Unable to get program tag list or no tags visible in the target PLC, error %s!\\n\", plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Unable to get program tag list or no tags visible in the target PLC, error %s!\\n\",",
            "+                        plc_tag_decode_error(rc));",
            "                 usage();",
            "             }",
            " ",
            "             plc_tag_destroy(program_listing_tag);",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Destroying program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Destroying program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            }",
            "         }",
            "     }",
            " ",
            "     /* loop through the tags and get the UDT information. */",
            "     for(struct tag_entry_s *entry = tag_list; entry; entry = entry->next) {",
            "         /* check the type of the tag's element type. */",
            "         uint16_t element_type = entry->type;",
            "@@ -217,37 +232,44 @@",
            "             uint16_t udt_id = element_type & TYPE_UDT_ID_MASK;",
            " ",
            "             udts_to_process[last_udt] = udt_id;",
            "             last_udt++;",
            " ",
            "             if(last_udt >= MAX_UDTS) {",
            "                 plc_tag_destroy(controller_listing_tag);",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"More than %d UDTs are requested!\\n\", MAX_UDTS);",
            "                 usage();",
            "             }",
            "         }",
            "     }",
            " ",
            "     /* get all the UDTs that we have touched. Note that this can add UDTs to the stack to process! */",
            "     while(current_udt < last_udt) {",
            "         uint16_t udt_id = udts_to_process[current_udt];",
            " ",
            "         /* see if we already have it. */",
            "         if(udts[udt_id] == NULL) {",
            "             rc = get_udt_definition(tag_string_base, udt_id);",
            "             if(rc == PLCTAG_ERR_UNSUPPORTED) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"This kind of PLC does not support UDT introspection.\\n\");",
            "                 break;",
            "             } else if(rc != PLCTAG_STATUS_OK) {",
            "                 plc_tag_destroy(controller_listing_tag);",
            "-                fprintf(stderr, \"Unable to get UDT template ID %u, error %s!\\n\", (unsigned int)(udt_id), plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Unable to get UDT template ID %u, error %s!\\n\", (unsigned int)(udt_id),",
            "+                        plc_tag_decode_error(rc));",
            "                 usage();",
            "             }",
            "         } else {",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Already have UDT (%04x) %s.\\n\", (unsigned int)udt_id, udts[udt_id]->name);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Already have UDT (%04x) %s.\\n\", (unsigned int)udt_id, udts[udt_id]->name);",
            "+            }",
            "         }",
            " ",
            "         current_udt++;",
            "     }",
            " ",
            " ",
            "     /* output all the tags. */",
            "@@ -255,59 +277,57 @@",
            "         if(!tag->parent) {",
            "             printf(\"Tag \\\"%s\", tag->name);",
            "         } else {",
            "             printf(\"Tag \\\"%s.%s\", tag->parent->name, tag->name);",
            "         }",
            " ",
            "         switch(tag->num_dimensions) {",
            "-            case 1:",
            "-                printf(\"[%d]\", tag->dimensions[0]);",
            "-                break;",
            "+            case 1: printf(\"[%d]\", tag->dimensions[0]); break;",
            " ",
            "-            case 2:",
            "-                printf(\"[%d,%d]\", tag->dimensions[0], tag->dimensions[1]);",
            "-                break;",
            "+            case 2: printf(\"[%d,%d]\", tag->dimensions[0], tag->dimensions[1]); break;",
            " ",
            "-            case 3:",
            "-                printf(\"[%d,%d,%d]\", tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]);",
            "-                break;",
            "+            case 3: printf(\"[%d,%d,%d]\", tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]); break;",
            " ",
            "-            default:",
            "-                break;",
            "+            default: break;",
            "         }",
            " ",
            "         /* handle the type. */",
            "         printf(\"\\\" \");",
            "         printf(\"Instance 0x%04x \", tag->instance_id);",
            "         print_element_type(tag->type);",
            "         printf(\".  \");",
            " ",
            "         /* print the tag string */",
            "         if(!tag->parent) {",
            "-            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&path=%s&plc=ControlLogix&elem_size=%u&elem_count=%u&name=%s\\\"\\n\", host, path, tag->elem_size, tag->elem_count, tag->name);",
            "+            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&path=%s&plc=ControlLogix&elem_size=%u&elem_count=%u&name=%s\\\"\\n\",",
            "+                   host, path, tag->elem_size, tag->elem_count, tag->name);",
            "         } else {",
            "-            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&path=%s&plc=ControlLogix&elem_size=%u&elem_count=%u&name=%s.%s\\\"\\n\", host, path, tag->elem_size, tag->elem_count, tag->parent->name, tag->name);",
            "+            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&path=%s&plc=ControlLogix&elem_size=%u&elem_count=%u&name=%s.%s\\\"\\n\",",
            "+                   host, path, tag->elem_size, tag->elem_count, tag->parent->name, tag->name);",
            "         }",
            "     }",
            " ",
            "     printf(\"UDTs:\\n\");",
            " ",
            "     /* print out all the UDTs */",
            "-    for(int index=0; index < MAX_UDTS; index++) {",
            "+    for(int index = 0; index < MAX_UDTS; index++) {",
            "         struct udt_entry_s *udt = udts[index];",
            " ",
            "         if(udt) {",
            "             if(udt->name) {",
            "-                printf(\" UDT %s (ID %x, %d bytes, struct handle %x):\\n\", udt->name, (unsigned int)(udt->id), (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "+                printf(\" UDT %s (ID %x, %d bytes, struct handle %x):\\n\", udt->name, (unsigned int)(udt->id),",
            "+                       (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "             } else {",
            "-                printf(\" UDT *UNNAMED* (ID %x, %d bytes, struct handle %x):\\n\", (unsigned int)(udt->id), (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "+                printf(\" UDT *UNNAMED* (ID %x, %d bytes, struct handle %x):\\n\", (unsigned int)(udt->id),",
            "+                       (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "             }",
            "             for(int field_index = 0; field_index < udt->num_fields; field_index++) {",
            "                 if(udt->fields[field_index].name) {",
            "-                    printf(\"    Field %d: %s, offset %d\", field_index, udt->fields[field_index].name, udt->fields[field_index].offset);",
            "+                    printf(\"    Field %d: %s, offset %d\", field_index, udt->fields[field_index].name,",
            "+                           udt->fields[field_index].offset);",
            "                 } else {",
            "                     printf(\"    Field %d: *UNNAMED*, offset %d\", field_index, udt->fields[field_index].offset);",
            "                 }",
            " ",
            "                 /* is it a bit? */",
            "                 if(udt->fields[field_index].type == 0xC1) {",
            "                     /* bit type, the metadata is the bit number. */",
            "@@ -339,28 +359,24 @@",
            "             free(tag->name);",
            "             tag->name = NULL;",
            "         }",
            " ",
            "         free(tag);",
            "     }",
            " ",
            "-    for(int index=0; index < MAX_UDTS; index++) {",
            "+    for(int index = 0; index < MAX_UDTS; index++) {",
            "         struct udt_entry_s *udt = udts[index];",
            " ",
            "         if(udt) {",
            "-            if(udt->name) {",
            "-                free(udt->name);",
            "-            }",
            "+            if(udt->name) { free(udt->name); }",
            " ",
            "-            for(int field_index=0; field_index < udt->num_fields; field_index++) {",
            "+            for(int field_index = 0; field_index < udt->num_fields; field_index++) {",
            "                 struct udt_field_entry_s *field = &(udt->fields[field_index]);",
            " ",
            "-                if(field->name) {",
            "-                    free(field->name);",
            "-                }",
            "+                if(field->name) { free(field->name); }",
            "             }",
            " ",
            "             free(udt);",
            " ",
            "             udts[index] = NULL;",
            "         }",
            "     }",
            "@@ -372,123 +388,137 @@",
            " ",
            "     printf(\"SUCCESS!\\n\");",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-void usage()",
            "-{",
            "+void usage(void) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Usage: list_tags <PLC IP> <PLC path>\\nExample: list_tags 10.1.2.3 1,0\\n\");",
            "     exit(1);",
            " }",
            " ",
            "-char *setup_tag_string(int argc, char **argv)",
            "-{",
            "-    char tag_string[TAG_STRING_SIZE+1] = {0};",
            "+char *setup_tag_string(int argc, char **argv) {",
            "+    char tag_string[TAG_STRING_SIZE + 1] = {0};",
            "     const char *gateway = NULL;",
            "     const char *path = NULL;",
            " ",
            "-    if(argc < 3) {",
            "-        usage();",
            "-    }",
            "+    if(argc < 3) { usage(); }",
            " ",
            "     if(!argv[1] || strlen(argv[1]) == 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Hostname or IP address must not be zero length!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     gateway = argv[1];",
            " ",
            "     if(!argv[2] || strlen(argv[2]) == 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"PLC path must not be zero length!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     path = argv[2];",
            " ",
            "     /* build the tag string. */",
            "+    // NOLINTNEXTLINE",
            "     snprintf(tag_string, TAG_STRING_SIZE, TAG_STRING_TEMPLATE, gateway, path);",
            " ",
            "     /* FIXME - check size! */",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    }",
            " ",
            "     return strdup(tag_string);",
            " }",
            " ",
            " ",
            "-",
            "-int open_tag(char *base, char *tag_name)",
            "-{",
            "+int open_tag(char *base, char *tag_name) {",
            "     int32_t tag = PLCTAG_ERR_CREATE;",
            "-    char tag_string[TAG_STRING_SIZE+1] = {0,};",
            "+    char tag_string[TAG_STRING_SIZE + 1] = {",
            "+        0,",
            "+    };",
            " ",
            "     /* build the tag string. */",
            "+    // NOLINTNEXTLINE",
            "     strncpy(tag_string, base, TAG_STRING_SIZE);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     strncat(tag_string, tag_name, TAG_STRING_SIZE);",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    }",
            " ",
            "     tag = plc_tag_create(tag_string, TIMEOUT_MS);",
            "     if(tag < 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to open tag!  Return code %s\\n\", plc_tag_decode_error(tag));",
            "         usage();",
            "     }",
            " ",
            "     return tag;",
            " }",
            " ",
            " ",
            "-int get_tag_list(int32_t tag, struct tag_entry_s **tag_list, struct tag_entry_s *parent)",
            "-{",
            "+int get_tag_list(int32_t tag, struct tag_entry_s **tag_list, struct tag_entry_s *parent) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     uint16_t last_tag_entry_id = 0;",
            "     int payload_size = 0;",
            "     int offset = 0;",
            " ",
            "     /* go get it. */",
            "     rc = plc_tag_read(tag, TIMEOUT_MS);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to send CIP request!\\n\", plc_tag_decode_error(rc));",
            "         usage();",
            "     }",
            " ",
            "     /* process the raw data. */",
            "     payload_size = plc_tag_get_size(tag);",
            "     if(payload_size < 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error getting payload size!\\n\");",
            "         usage();",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Listing tag read, result of size %d.\\n\", payload_size);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Listing tag read, result of size %d.\\n\", payload_size);",
            "+    }",
            " ",
            "     /* check the payload size. */",
            "     if(payload_size < 4) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unexpectedly small payload size %d!\\n\", payload_size);",
            "         usage();",
            "     }",
            " ",
            "     /* process each entry */",
            "     do {",
            "         rc = process_tag_entry(tag, &offset, &last_tag_entry_id, tag_list, parent);",
            "     } while(rc == PLCTAG_STATUS_OK && offset < payload_size);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list, struct tag_entry_s *parent)",
            "-{",
            "+int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list,",
            "+                      struct tag_entry_s *parent) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     uint16_t tag_type = 0;",
            "     uint16_t element_length = 0;",
            "-    uint16_t array_dims[3] = {0,};",
            "+    uint16_t array_dims[3] = {",
            "+        0,",
            "+    };",
            "     int tag_name_len = 0;",
            "     char *tag_name = NULL;",
            "     struct tag_entry_s *tag_entry = NULL;",
            " ",
            "     /* each entry looks like this:",
            "         uint32_t instance_id    monotonically increasing but not contiguous",
            "         uint16_t symbol_type    type of the symbol.",
            "@@ -517,72 +547,85 @@",
            "     /* get the tag name length. */",
            "     tag_name_len = plc_tag_get_string_length(tag, *offset);",
            "     // *offset += 2;",
            " ",
            "     /* allocate space for the the tag name.  Add one for the zero termination. */",
            "     tag_name = calloc((size_t)(unsigned int)(tag_name_len + 1), 1);",
            "     if(!tag_name) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate memory for the tag name!\\n\");",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "     rc = plc_tag_get_string(tag, *offset, tag_name, tag_name_len + 1);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to get tag name string, error %s!\\n\", plc_tag_decode_error(rc));",
            "         free(tag_name);",
            "         return rc;",
            "     }",
            " ",
            "     /* skip past the string. */",
            "     (*offset) += plc_tag_get_string_total_length(tag, *offset);",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Tag %s, string length: %d.\\n\", tag_name, (int)(unsigned int)strlen(tag_name));",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Tag %s, string length: %d.\\n\", tag_name, (int)(unsigned int)strlen(tag_name));",
            "+    }",
            " ",
            "     /* allocate the new tag entry. */",
            "     tag_entry = calloc(1, sizeof(*tag_entry));",
            " ",
            "     if(!tag_entry) {",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Unable to allocate memory for tag entry!\\n\");",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Unable to allocate memory for tag entry!\\n\");",
            "+        }",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Found tag name=%s, tag instance ID=%x, tag type=%x, element length (in bytes) = %d, array dimensions = (%d, %d, %d)\\n\", tag_name, *last_tag_id, tag_type, (int)element_length, (int)array_dims[0], (int)array_dims[1], (int)array_dims[2]);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(",
            "+            stderr,",
            "+            \"Found tag name=%s, tag instance ID=%x, tag type=%x, element length (in bytes) = %d, array dimensions = (%d, %d, %d)\\n\",",
            "+            tag_name, *last_tag_id, tag_type, (int)element_length, (int)array_dims[0], (int)array_dims[1], (int)array_dims[2]);",
            "+    }",
            " ",
            "     /* fill in the fields. */",
            "     tag_entry->instance_id = *last_tag_id;",
            "     tag_entry->name = tag_name;",
            "     tag_entry->parent = parent;",
            "     tag_entry->type = tag_type;",
            "     tag_entry->elem_size = element_length;",
            "     tag_entry->num_dimensions = (uint16_t)((tag_type & TAG_DIM_MASK) >> 13);",
            "     tag_entry->dimensions[0] = array_dims[0];",
            "     tag_entry->dimensions[1] = array_dims[1];",
            "     tag_entry->dimensions[2] = array_dims[2];",
            " ",
            "     /* calculate the element count. */",
            "     tag_entry->elem_count = 1;",
            "-    for(uint16_t i=0; i < tag_entry->num_dimensions; i++) {",
            "+    for(uint16_t i = 0; i < tag_entry->num_dimensions; i++) {",
            "         tag_entry->elem_count = (uint16_t)((uint16_t)tag_entry->elem_count * (uint16_t)(tag_entry->dimensions[i]));",
            "     }",
            " ",
            "     /* link it up to the list */",
            "     tag_entry->next = *tag_list;",
            "     *tag_list = tag_entry;",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-void print_element_type(uint16_t element_type)",
            "-{",
            "+void print_element_type(uint16_t element_type) {",
            "     if(element_type & TYPE_IS_SYSTEM) {",
            "         printf(\"element type SYSTEM (0x%04x)\", (unsigned int)(element_type));",
            "     } else if(element_type & TYPE_IS_STRUCT) {",
            "-        printf(\"element type UDT (0x%04x) %s\", (unsigned int)(element_type), udts[(size_t)(unsigned int)(element_type & TYPE_UDT_ID_MASK)]->name);",
            "+        printf(\"element type UDT (0x%04x) %s\", (unsigned int)(element_type),",
            "+               udts[(size_t)(unsigned int)(element_type & TYPE_UDT_ID_MASK)]->name);",
            "     } else {",
            "         uint16_t atomic_type = element_type & 0xFF; /* MAGIC */",
            "         const char *type = NULL;",
            " ",
            "         switch(atomic_type) {",
            "             case 0xC1: type = \"BOOL: Boolean value\"; break;",
            "             case 0xC2: type = \"SINT: Signed 8-bit integer value\"; break;",
            "@@ -621,27 +664,28 @@",
            "         } else {",
            "             printf(\"UNKNOWN TYPE 0x%04x\", (unsigned int)element_type);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-int encode_request_prefix(const char *name, uint8_t *buffer, int *encoded_size)",
            "-{",
            "+int encode_request_prefix(const char *name, uint8_t *buffer, int *encoded_size) {",
            "     int symbol_length_index = 0;",
            "     /* start with the symbolic type identifier */",
            "     *encoded_size = 0;",
            "-    buffer[*encoded_size] = (uint8_t)(unsigned int)0x91; (*encoded_size)++;",
            "+    buffer[*encoded_size] = (uint8_t)(unsigned int)0x91;",
            "+    (*encoded_size)++;",
            " ",
            "     /* dummy value for the encoded length */",
            "     symbol_length_index = *encoded_size;",
            "-    buffer[*encoded_size] = (uint8_t)(unsigned int)0; (*encoded_size)++;",
            "+    buffer[*encoded_size] = (uint8_t)(unsigned int)0;",
            "+    (*encoded_size)++;",
            " ",
            "     /* copy the string. */",
            "-    for(int index=0; index < (int)(unsigned int)strlen(name); index++) {",
            "+    for(int index = 0; index < (int)(unsigned int)strlen(name); index++) {",
            "         buffer[*encoded_size] = (uint8_t)name[index];",
            "         (*encoded_size)++;",
            "     }",
            " ",
            "     /* backfill the encoded size */",
            "     buffer[symbol_length_index] = (uint8_t)(unsigned int)(strlen(name));",
            " ",
            "@@ -651,57 +695,62 @@",
            "         (*encoded_size)++;",
            "     }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int get_udt_definition(char *tag_string_base, uint16_t udt_id)",
            "-{",
            "+int get_udt_definition(char *tag_string_base, uint16_t udt_id) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int32_t udt_info_tag = 0;",
            "     int tag_size = 0;",
            "     char buf[32] = {0};",
            "     int offset = 0;",
            "     uint16_t template_id = 0;",
            "     uint16_t num_members = 0;",
            "     uint16_t struct_handle = 0;",
            "     uint32_t udt_instance_size = 0;",
            "-    //uint32_t member_desc_size = 0;",
            "+    // uint32_t member_desc_size = 0;",
            "     int name_len = 0;",
            "     char *name_str = NULL;",
            "     int name_index = 0;",
            "     int field_index = 0;",
            " ",
            "     /* memoize, check to see if we have this type already. */",
            "-    if(udts[udt_id]) {",
            "-        return PLCTAG_STATUS_OK;",
            "-    }",
            "+    if(udts[udt_id]) { return PLCTAG_STATUS_OK; }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     snprintf(buf, sizeof(buf), \"@udt/%u\", (unsigned int)udt_id);",
            " ",
            "     udt_info_tag = open_tag(tag_string_base, buf);",
            "     if(udt_info_tag < 0) {",
            "         if(udt_info_tag == PLCTAG_ERR_UNSUPPORTED) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"This PLC type does not support listing UDT definitions.\\n\");",
            "             return PLCTAG_ERR_UNSUPPORTED;",
            "         }",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to open UDT info tag, error %s!\\n\", plc_tag_decode_error(udt_info_tag));",
            "         usage();",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"UDT info tag ID: %d\\n\", udt_info_tag);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"UDT info tag ID: %d\\n\", udt_info_tag);",
            "+    }",
            " ",
            "     rc = plc_tag_read(udt_info_tag, TIMEOUT_MS);",
            "     if(rc == PLCTAG_ERR_UNSUPPORTED) {",
            "         plc_tag_destroy(udt_info_tag);",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"UDT tag introspection is not supported on this PLC.\\n\");",
            "         return rc;",
            "     } else if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s while trying to read UDT info!\\n\", plc_tag_decode_error(rc));",
            "         usage();",
            "     }",
            " ",
            "     tag_size = plc_tag_get_size(udt_info_tag);",
            " ",
            "     /* the format in the tag buffer is:",
            "@@ -727,42 +776,45 @@",
            "      * N x field names",
            "      *     int8_t string - zero-terminated.",
            "      *",
            "      */",
            " ",
            "     /* get the ID, number of members and the instance size. */",
            "     template_id = plc_tag_get_uint16(udt_info_tag, 0);",
            "-    //member_desc_size = plc_tag_get_uint32(udt_info_tag, 2);",
            "+    // member_desc_size = plc_tag_get_uint32(udt_info_tag, 2);",
            "     udt_instance_size = plc_tag_get_uint32(udt_info_tag, 6);",
            "     num_members = plc_tag_get_uint16(udt_info_tag, 10);",
            "     struct_handle = plc_tag_get_uint16(udt_info_tag, 12);",
            " ",
            "     /* skip past this header. */",
            "     offset = 14;",
            " ",
            "     /* just a sanity check */",
            "     if(template_id != udt_id) {",
            "-        fprintf(stderr, \"The ID, %x, of the UDT we are reading is not the same as the UDT ID we requested, %x!\\n\",(unsigned int)template_id, (unsigned int)udt_id);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"The ID, %x, of the UDT we are reading is not the same as the UDT ID we requested, %x!\\n\",",
            "+                (unsigned int)template_id, (unsigned int)udt_id);",
            "         usage();",
            "     }",
            " ",
            "     /* allocate a UDT struct with this info. */",
            "     udts[(size_t)udt_id] = calloc(1, sizeof(struct udt_entry_s) + (sizeof(struct udt_field_entry_s) * num_members));",
            "     if(!udts[(size_t)udt_id]) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate a new UDT definition structure!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     udts[(size_t)udt_id]->id = udt_id;",
            "     udts[(size_t)udt_id]->num_fields = num_members;",
            "     udts[(size_t)udt_id]->struct_handle = struct_handle;",
            "     udts[(size_t)udt_id]->instance_size = udt_instance_size;",
            " ",
            "     /* first section is the field type and size info for all fields. */",
            "-    for(int field_index=0; field_index < udts[udt_id]->num_fields; field_index++) {",
            "+    for(int field_index = 0; field_index < udts[udt_id]->num_fields; field_index++) {",
            "         uint16_t field_metadata = 0;",
            "         uint16_t field_element_type = 0;",
            "         uint32_t field_offset = 0;",
            " ",
            "         field_metadata = plc_tag_get_uint16(udt_info_tag, offset);",
            "         offset += 2;",
            " ",
            "@@ -784,140 +836,180 @@",
            "                 udts_to_process[last_udt] = child_udt;",
            "                 last_udt++;",
            "             }",
            "         }",
            "     }",
            " ",
            "     if(debug_level >= PLCTAG_DEBUG_DETAIL) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Offset after reading field descriptors: %d.\\n\", offset);",
            "     }",
            " ",
            "     /*",
            "      * then get the template/UDT name.   This is weird.",
            "      * Scan until we see a 0x3B, semicolon, byte.   That is the end of the",
            "      * template name.   Actually we should look for \";n\" but the semicolon",
            "      * seems to be enough for now.",
            "      */",
            " ",
            "     /* first get the zero-terminated string length */",
            "     name_len = plc_tag_get_string_length(udt_info_tag, offset);",
            "-    if(name_len <=0 || name_len >= 256) {",
            "+    if(name_len <= 0 || name_len >= 256) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unexpected raw UDT name length: %d!\\n\", name_len);",
            "-        //usage();",
            "+        // usage();",
            "     }",
            " ",
            "     /* create a string for this. */",
            "     name_str = calloc((size_t)(name_len + 1), (size_t)1);",
            "     if(!name_str) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate UDT name string!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     /* copy the name */",
            "     rc = plc_tag_get_string(udt_info_tag, offset, name_str, name_len + 1);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s retrieving UDT name string from the tag!\\n\", plc_tag_decode_error(rc));",
            "         free(name_str);",
            "         usage();",
            "     }",
            " ",
            "     /* zero terminate the name when we hit the first semicolon. */",
            "-    for(name_index = 0; name_index < name_len && name_str[name_index] != ';'; name_index++) { };",
            "+    for(name_index = 0; name_index < name_len && name_str[name_index] != ';'; name_index++) {};",
            " ",
            "-    if(name_str[name_index] == ';') {",
            "-        name_str[name_index] = 0;",
            "-    }",
            "+    if(name_str[name_index] == ';') { name_str[name_index] = 0; }",
            " ",
            "     /* check the name length again. */",
            "     name_len = (int)(unsigned int)strlen(name_str);",
            "-    if(name_len ==0 || name_len >= 256) {",
            "+    if(name_len == 0 || name_len >= 256) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unexpected UDT name length: %d!\\n\", name_len);",
            "     }",
            " ",
            "     udts[udt_id]->name = name_str;",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Getting data from UDT \\\"%s\\\".\\n\", udts[udt_id]->name);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Getting data from UDT \\\"%s\\\".\\n\", udts[udt_id]->name);",
            "+    }",
            " ",
            "     /* skip past the UDT name. */",
            "     offset += plc_tag_get_string_total_length(udt_info_tag, offset);",
            " ",
            "     /*",
            "      * This is the second section of the data, the field names.   They appear",
            "      * to be zero terminated.",
            "      */",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Getting %d field names for UDT %s.\\n\", udts[udt_id]->num_fields, udts[udt_id]->name);",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"offset=%u, tag_size=%u.\\n\", offset, tag_size);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Getting %d field names for UDT %s.\\n\", udts[udt_id]->num_fields, udts[udt_id]->name);",
            "+    }",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"offset=%u, tag_size=%u.\\n\", offset, tag_size);",
            "+    }",
            " ",
            "     /* loop over all fields and get name strings.  They are zero terminated. */",
            "-    for(field_index=0; field_index < udts[udt_id]->num_fields && offset < tag_size; field_index++) {",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Getting name for field %u.\\n\", field_index);",
            "+    for(field_index = 0; field_index < udts[udt_id]->num_fields && offset < tag_size; field_index++) {",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Getting name for field %u.\\n\", field_index);",
            "+        }",
            " ",
            "         /* first get the zero-terminated string length */",
            "         name_len = plc_tag_get_string_length(udt_info_tag, offset);",
            "-        if(name_len <0 || name_len >= 256) {",
            "+        if(name_len < 0 || name_len >= 256) {",
            "             plc_tag_destroy(udt_info_tag);",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unexpected UDT field name length: %d!\\n\", name_len);",
            "             usage();",
            "         }",
            " ",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"The name for field %u is %u characters long.\\n\", field_index, name_len);",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"The name for field %u is %u characters long.\\n\", field_index, name_len);",
            "+        }",
            " ",
            "         /* create a string for this. */",
            "         if(name_len > 0) {",
            "             name_str = calloc((size_t)(name_len + 1), (size_t)1);",
            "             if(!name_str) {",
            "                 plc_tag_destroy(udt_info_tag);",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to allocate UDT field name string!\\n\");",
            "                 usage();",
            "             }",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"The string for field %u is at %p.\\n\", field_index, (void *)name_str);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"The string for field %u is at %p.\\n\", field_index, (void *)name_str);",
            "+            }",
            " ",
            "             /* copy the name */",
            "             rc = plc_tag_get_string(udt_info_tag, offset, name_str, name_len + 1);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 plc_tag_destroy(udt_info_tag);",
            "+",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Error %s retrieving UDT field name string from the tag!\\n\", plc_tag_decode_error(rc));",
            "+",
            "                 free(name_str);",
            "+",
            "                 usage();",
            "             }",
            " ",
            "             udts[udt_id]->fields[field_index].name = name_str;",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"UDT field %d is \\\"%s\\\".\\n\", field_index, udts[udt_id]->fields[field_index].name);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"UDT field %d is \\\"%s\\\".\\n\", field_index, udts[udt_id]->fields[field_index].name);",
            "+            }",
            " ",
            "             offset += plc_tag_get_string_total_length(udt_info_tag, offset);",
            "         } else {",
            "             /* field name was zero length. */",
            "             udts[udt_id]->fields[field_index].name = NULL;",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"UDT field %d is not named.\\n\", field_index);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"UDT field %d is not named.\\n\", field_index);",
            "+            }",
            " ",
            "             /*",
            "              * The string is either zero length in which case we need to bump past the null",
            "              * terminator or it is at the end of the tag and we need to step past the edge.",
            "              */",
            "             offset++;",
            "         }",
            "     }",
            " ",
            "     /* sanity check */",
            "     if(offset != tag_size) {",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Processed %d bytes out of %d bytes.\\n\", offset, tag_size);",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Processed %d bytes out of %d bytes.\\n\", offset, tag_size);",
            "+        }",
            "     }",
            " ",
            "     /* if we had a system tag, we might not have the full set of member/field names.  Fill in the gaps. */",
            "     for(; field_index < udts[udt_id]->num_fields; field_index++) {",
            "-            /* field name was zero length. */",
            "-            udts[udt_id]->fields[field_index].name = NULL;",
            "+        /* field name was zero length. */",
            "+        udts[udt_id]->fields[field_index].name = NULL;",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"UDT field %d is not named.\\n\", field_index);",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"UDT field %d is not named.\\n\", field_index);",
            "+        }",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Destroying UDT info tag: %d\\n\", udt_info_tag);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Destroying UDT info tag: %d\\n\", udt_info_tag);",
            "+    }",
            "     plc_tag_destroy(udt_info_tag);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/list_tags_micro8x0.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/list_tags_micro8x0.c",
            "+++ /home/libplctag-2.6.7/src/examples/list_tags_micro8x0.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,22 +28,22 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,4,9",
            "+#define REQUIRED_VERSION 2, 4, 9",
            " ",
            " #define TAG_STRING_SIZE (200)",
            " #define TAG_STRING_TEMPLATE \"protocol=ab-eip&gateway=%s&plc=Micro800&name=\"",
            " #define TIMEOUT_MS 5000",
            " ",
            " ",
            " #define TYPE_IS_STRUCT ((uint16_t)0x8000)",
            "@@ -52,17 +52,14 @@",
            " #define TYPE_UDT_ID_MASK ((uint16_t)0x0FFF)",
            " #define TAG_DIM_MASK ((uint16_t)0x6000)",
            " ",
            " ",
            " #define MAX_UDTS (1 << 12)",
            " ",
            " ",
            "-",
            "-",
            "-",
            " struct program_entry_s {",
            "     struct program_entry_s *next;",
            "     char *program_name;",
            " };",
            " ",
            " struct tag_entry_s {",
            "     struct tag_entry_s *next;",
            "@@ -92,120 +89,137 @@",
            "     uint16_t num_fields;",
            "     uint16_t struct_handle;",
            "     uint32_t instance_size;",
            "     struct udt_field_entry_s fields[];",
            " };",
            " ",
            " ",
            "-",
            "-",
            " static void usage(void);",
            " static char *setup_tag_string(int argc, char **argv);",
            " static int open_tag(char *base, char *tag_name);",
            " static int get_tag_list(int32_t tag_id, struct tag_entry_s **tag_list, struct tag_entry_s *parent);",
            " static void print_element_type(uint16_t element_type);",
            "-static int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list, struct tag_entry_s *parent);",
            "+static int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list,",
            "+                             struct tag_entry_s *parent);",
            " static int get_udt_definition(char *base, uint16_t udt_id);",
            " ",
            " ",
            " /* a local cache of all found UDT definitions. */",
            "-static struct udt_entry_s *udts[MAX_UDTS] = { NULL };",
            "+static struct udt_entry_s *udts[MAX_UDTS] = {NULL};",
            " static uint16_t udts_to_process[MAX_UDTS] = {0};",
            " static int last_udt = 0;",
            " static int current_udt = 0;",
            " ",
            " ",
            " static int debug_level = PLCTAG_DEBUG_NONE;",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     char *host = NULL;",
            "     char *tag_string_base = NULL;",
            "     int32_t controller_listing_tag = 0;",
            "     int32_t program_listing_tag = 0;",
            "     struct tag_entry_s *tag_list = NULL;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION,",
            "+                version_major, version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_ERROR);",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     /* clear the UDTs. */",
            "-    for(int index = 0; index < MAX_UDTS; index++) {",
            "-        udts[index] = NULL;",
            "-    }",
            "+    for(int index = 0; index < MAX_UDTS; index++) { udts[index] = NULL; }",
            " ",
            "     debug_level = plc_tag_get_int_attribute(0, \"debug\", PLCTAG_DEBUG_NONE);",
            " ",
            "     tag_string_base = setup_tag_string(argc, argv);",
            "     if(tag_string_base == NULL) {",
            "-        fprintf(stderr,\"Unable to set up the tag string base!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to set up the tag string base!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     /* this means that the args are right. */",
            "     host = argv[1];",
            " ",
            "     /* set up the tag for the listing first. */",
            "     controller_listing_tag = open_tag(tag_string_base, \"@tags\");",
            "     if(controller_listing_tag <= 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to create listing tag, error %s!\\n\", plc_tag_decode_error(controller_listing_tag));",
            "         usage();",
            "     }",
            " ",
            "     /* get the list of controller tags. */",
            "     rc = get_tag_list(controller_listing_tag, &tag_list, NULL);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to get tag list or no tags visible in the target PLC, error %s!\\n\", plc_tag_decode_error(rc));",
            "         usage();",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Controller tag listing tag ID: %d\\n\", controller_listing_tag);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Controller tag listing tag ID: %d\\n\", controller_listing_tag);",
            "+    }",
            " ",
            "     /*",
            "      * now loop through the tags and get the list for the program tags.",
            "      *",
            "      * This is safe because we push the new tags on the front of the list and",
            "      * so do not change any existing tag in the list.",
            "      */",
            "     for(struct tag_entry_s *entry = tag_list; entry; entry = entry->next) {",
            "         if(strncmp(entry->name, \"Program:\", strlen(\"Program:\")) == 0) {",
            "             char buf[256] = {0};",
            " ",
            "             /* this is a program tag, check for its tags. */",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Getting tags for program \\\"%s\\\".\\n\", entry->name);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Getting tags for program \\\"%s\\\".\\n\", entry->name);",
            "+            }",
            " ",
            "+            // NOLINTNEXTLINE",
            "             snprintf(buf, sizeof(buf), \"%s.@tags\", entry->name);",
            " ",
            "             program_listing_tag = open_tag(tag_string_base, buf);",
            "             if(program_listing_tag <= 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to create listing tag, error %s!\\n\", plc_tag_decode_error(program_listing_tag));",
            "                 usage();",
            "             }",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            }",
            " ",
            "             rc = get_tag_list(program_listing_tag, &tag_list, entry);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "-                fprintf(stderr, \"Unable to get program tag list or no tags visible in the target PLC, error %s!\\n\", plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Unable to get program tag list or no tags visible in the target PLC, error %s!\\n\",",
            "+                        plc_tag_decode_error(rc));",
            "                 usage();",
            "             }",
            " ",
            "             plc_tag_destroy(program_listing_tag);",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Destroying program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Destroying program tag listing tag ID: %d\\n\", program_listing_tag);",
            "+            }",
            "         }",
            "     }",
            " ",
            "     /* loop through the tags and get the UDT information. */",
            "     for(struct tag_entry_s *entry = tag_list; entry; entry = entry->next) {",
            "         /* check the type of the tag's element type. */",
            "         uint16_t element_type = entry->type;",
            "@@ -215,37 +229,44 @@",
            "             uint16_t udt_id = element_type & TYPE_UDT_ID_MASK;",
            " ",
            "             udts_to_process[last_udt] = udt_id;",
            "             last_udt++;",
            " ",
            "             if(last_udt >= MAX_UDTS) {",
            "                 plc_tag_destroy(controller_listing_tag);",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"More than %d UDTs are requested!\\n\", MAX_UDTS);",
            "                 usage();",
            "             }",
            "         }",
            "     }",
            " ",
            "     /* get all the UDTs that we have touched. Note that this can add UDTs to the stack to process! */",
            "     while(current_udt < last_udt) {",
            "         uint16_t udt_id = udts_to_process[current_udt];",
            " ",
            "         /* see if we already have it. */",
            "         if(udts[udt_id] == NULL) {",
            "             rc = get_udt_definition(tag_string_base, udt_id);",
            "             if(rc == PLCTAG_ERR_UNSUPPORTED) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"This kind of PLC does not support UDT introspection.\\n\");",
            "                 break;",
            "             } else if(rc != PLCTAG_STATUS_OK) {",
            "                 plc_tag_destroy(controller_listing_tag);",
            "-                fprintf(stderr, \"Unable to get UDT template ID %u, error %s!\\n\", (unsigned int)(udt_id), plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Unable to get UDT template ID %u, error %s!\\n\", (unsigned int)(udt_id),",
            "+                        plc_tag_decode_error(rc));",
            "                 usage();",
            "             }",
            "         } else {",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Already have UDT (%04x) %s.\\n\", (unsigned int)udt_id, udts[udt_id]->name);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Already have UDT (%04x) %s.\\n\", (unsigned int)udt_id, udts[udt_id]->name);",
            "+            }",
            "         }",
            " ",
            "         current_udt++;",
            "     }",
            " ",
            " ",
            "     /* output all the tags. */",
            "@@ -253,59 +274,57 @@",
            "         if(!tag->parent) {",
            "             printf(\"Tag \\\"%s\", tag->name);",
            "         } else {",
            "             printf(\"Tag \\\"%s.%s\", tag->parent->name, tag->name);",
            "         }",
            " ",
            "         switch(tag->num_dimensions) {",
            "-            case 1:",
            "-                printf(\"[%d]\", tag->dimensions[0]);",
            "-                break;",
            "+            case 1: printf(\"[%d]\", tag->dimensions[0]); break;",
            " ",
            "-            case 2:",
            "-                printf(\"[%d,%d]\", tag->dimensions[0], tag->dimensions[1]);",
            "-                break;",
            "+            case 2: printf(\"[%d,%d]\", tag->dimensions[0], tag->dimensions[1]); break;",
            " ",
            "-            case 3:",
            "-                printf(\"[%d,%d,%d]\", tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]);",
            "-                break;",
            "+            case 3: printf(\"[%d,%d,%d]\", tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]); break;",
            " ",
            "-            default:",
            "-                break;",
            "+            default: break;",
            "         }",
            " ",
            "         /* handle the type. */",
            "         printf(\"\\\" \");",
            "         printf(\"Instance %04x \", tag->instance_id);",
            "         print_element_type(tag->type);",
            "         printf(\".  \");",
            " ",
            "         /* print the tag string */",
            "         if(!tag->parent) {",
            "-            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&plc=Micro800&elem_size=%u&elem_count=%u&name=%s\\\"\\n\", host, tag->elem_size, tag->elem_count, tag->name);",
            "+            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&plc=Micro800&elem_size=%u&elem_count=%u&name=%s\\\"\\n\", host,",
            "+                   tag->elem_size, tag->elem_count, tag->name);",
            "         } else {",
            "-            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&plc=Micro800&elem_size=%u&elem_count=%u&name=%s.%s\\\"\\n\", host, tag->elem_size, tag->elem_count, tag->parent->name, tag->name);",
            "+            printf(\"tag string = \\\"protocol=ab-eip&gateway=%s&plc=Micro800&elem_size=%u&elem_count=%u&name=%s.%s\\\"\\n\", host,",
            "+                   tag->elem_size, tag->elem_count, tag->parent->name, tag->name);",
            "         }",
            "     }",
            " ",
            "     printf(\"UDTs:\\n\");",
            " ",
            "     /* print out all the UDTs */",
            "-    for(int index=0; index < MAX_UDTS; index++) {",
            "+    for(int index = 0; index < MAX_UDTS; index++) {",
            "         struct udt_entry_s *udt = udts[index];",
            " ",
            "         if(udt) {",
            "             if(udt->name) {",
            "-                printf(\" UDT %s (ID %x, %d bytes, struct handle %x):\\n\", udt->name, (unsigned int)(udt->id), (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "+                printf(\" UDT %s (ID %x, %d bytes, struct handle %x):\\n\", udt->name, (unsigned int)(udt->id),",
            "+                       (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "             } else {",
            "-                printf(\" UDT *UNNAMED* (ID %x, %d bytes, struct handle %x):\\n\", (unsigned int)(udt->id), (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "+                printf(\" UDT *UNNAMED* (ID %x, %d bytes, struct handle %x):\\n\", (unsigned int)(udt->id),",
            "+                       (int)(unsigned int)udt->instance_size, (int)(unsigned int)udt->struct_handle);",
            "             }",
            "             for(int field_index = 0; field_index < udt->num_fields; field_index++) {",
            "                 if(udt->fields[field_index].name) {",
            "-                    printf(\"    Field %d: %s, offset %d\", field_index, udt->fields[field_index].name, udt->fields[field_index].offset);",
            "+                    printf(\"    Field %d: %s, offset %d\", field_index, udt->fields[field_index].name,",
            "+                           udt->fields[field_index].offset);",
            "                 } else {",
            "                     printf(\"    Field %d: *UNNAMED*, offset %d\", field_index, udt->fields[field_index].offset);",
            "                 }",
            " ",
            "                 /* is it a bit? */",
            "                 if(udt->fields[field_index].type == 0xC1) {",
            "                     /* bit type, the metadata is the bit number. */",
            "@@ -337,28 +356,24 @@",
            "             free(tag->name);",
            "             tag->name = NULL;",
            "         }",
            " ",
            "         free(tag);",
            "     }",
            " ",
            "-    for(int index=0; index < MAX_UDTS; index++) {",
            "+    for(int index = 0; index < MAX_UDTS; index++) {",
            "         struct udt_entry_s *udt = udts[index];",
            " ",
            "         if(udt) {",
            "-            if(udt->name) {",
            "-                free(udt->name);",
            "-            }",
            "+            if(udt->name) { free(udt->name); }",
            " ",
            "-            for(int field_index=0; field_index < udt->num_fields; field_index++) {",
            "+            for(int field_index = 0; field_index < udt->num_fields; field_index++) {",
            "                 struct udt_field_entry_s *field = &(udt->fields[field_index]);",
            " ",
            "-                if(field->name) {",
            "-                    free(field->name);",
            "-                }",
            "+                if(field->name) { free(field->name); }",
            "             }",
            " ",
            "             free(udt);",
            " ",
            "             udts[index] = NULL;",
            "         }",
            "     }",
            "@@ -370,123 +385,128 @@",
            " ",
            "     printf(\"SUCCESS!\\n\");",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-void usage()",
            "-{",
            "+void usage(void) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Usage: list_tags_micro8x0 <PLC IP>\\nExample: list_tags_micro8x0 10.1.2.3\\n\");",
            "     exit(1);",
            " }",
            " ",
            "-char *setup_tag_string(int argc, char **argv)",
            "-{",
            "-    char tag_string[TAG_STRING_SIZE+1] = {0};",
            "+char *setup_tag_string(int argc, char **argv) {",
            "+    char tag_string[TAG_STRING_SIZE + 1] = {0};",
            "     const char *gateway = NULL;",
            "-    const char *path = NULL;",
            " ",
            "-    if(argc < 2) {",
            "-        usage();",
            "-    }",
            "+    if(argc < 2) { usage(); }",
            " ",
            "     if(!argv[1] || strlen(argv[1]) == 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Hostname or IP address must not be zero length!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     gateway = argv[1];",
            " ",
            "-    // if(!argv[2] || strlen(argv[2]) == 0) {",
            "-    //     fprintf(stderr, \"PLC path must not be zero length!\\n\");",
            "-    //     usage();",
            "-    // }",
            "-",
            "-    path = argv[2];",
            "-",
            "     /* build the tag string. */",
            "+    // NOLINTNEXTLINE",
            "     snprintf(tag_string, TAG_STRING_SIZE, TAG_STRING_TEMPLATE, gateway);",
            " ",
            "     /* FIXME - check size! */",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    }",
            " ",
            "     return strdup(tag_string);",
            " }",
            " ",
            " ",
            "-",
            "-int open_tag(char *base, char *tag_name)",
            "-{",
            "+int open_tag(char *base, char *tag_name) {",
            "     int32_t tag = PLCTAG_ERR_CREATE;",
            "-    char tag_string[TAG_STRING_SIZE+1] = {0,};",
            "+    char tag_string[TAG_STRING_SIZE + 1] = {",
            "+        0,",
            "+    };",
            " ",
            "     /* build the tag string. */",
            "+    // NOLINTNEXTLINE",
            "     strncpy(tag_string, base, TAG_STRING_SIZE);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     strncat(tag_string, tag_name, TAG_STRING_SIZE);",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Using tag string \\\"%s\\\".\\n\", tag_string);",
            "+    }",
            " ",
            "     tag = plc_tag_create(tag_string, TIMEOUT_MS);",
            "     if(tag < 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to open tag!  Return code %s\\n\", plc_tag_decode_error(tag));",
            "         usage();",
            "     }",
            " ",
            "     return tag;",
            " }",
            " ",
            " ",
            "-int get_tag_list(int32_t tag, struct tag_entry_s **tag_list, struct tag_entry_s *parent)",
            "-{",
            "+int get_tag_list(int32_t tag, struct tag_entry_s **tag_list, struct tag_entry_s *parent) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     uint16_t last_tag_entry_id = 0;",
            "     int payload_size = 0;",
            "     int offset = 0;",
            " ",
            "     /* go get it. */",
            "     rc = plc_tag_read(tag, TIMEOUT_MS);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to send CIP request!\\n\", plc_tag_decode_error(rc));",
            "         usage();",
            "     }",
            " ",
            "     /* process the raw data. */",
            "     payload_size = plc_tag_get_size(tag);",
            "     if(payload_size < 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error getting payload size!\\n\");",
            "         usage();",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Listing tag read, result of size %d.\\n\", payload_size);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Listing tag read, result of size %d.\\n\", payload_size);",
            "+    }",
            " ",
            "     /* check the payload size. */",
            "     if(payload_size < 4) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unexpectedly small payload size %d!\\n\", payload_size);",
            "         usage();",
            "     }",
            " ",
            "     /* process each entry */",
            "     do {",
            "         rc = process_tag_entry(tag, &offset, &last_tag_entry_id, tag_list, parent);",
            "     } while(rc == PLCTAG_STATUS_OK && offset < payload_size);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list, struct tag_entry_s *parent)",
            "-{",
            "+int process_tag_entry(int32_t tag, int *offset, uint16_t *last_tag_id, struct tag_entry_s **tag_list,",
            "+                      struct tag_entry_s *parent) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     uint16_t tag_type = 0;",
            "     uint16_t element_length = 0;",
            "-    uint16_t array_dims[3] = {0,};",
            "+    uint16_t array_dims[3] = {",
            "+        0,",
            "+    };",
            "     int tag_name_len = 0;",
            "     char *tag_name = NULL;",
            "     struct tag_entry_s *tag_entry = NULL;",
            " ",
            "     /* each entry looks like this:",
            "         uint32_t instance_id    monotonically increasing but not contiguous",
            "         uint16_t symbol_type    type of the symbol.",
            "@@ -515,72 +535,85 @@",
            "     /* get the tag name length. */",
            "     tag_name_len = plc_tag_get_string_length(tag, *offset);",
            "     // *offset += 2;",
            " ",
            "     /* allocate space for the the tag name.  Add one for the zero termination. */",
            "     tag_name = calloc((size_t)(unsigned int)(tag_name_len + 1), 1);",
            "     if(!tag_name) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate memory for the tag name!\\n\");",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "     rc = plc_tag_get_string(tag, *offset, tag_name, tag_name_len + 1);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to get tag name string, error %s!\\n\", plc_tag_decode_error(rc));",
            "         free(tag_name);",
            "         return rc;",
            "     }",
            " ",
            "     /* skip past the string. */",
            "     (*offset) += plc_tag_get_string_total_length(tag, *offset);",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Tag %s, string length: %d.\\n\", tag_name, (int)(unsigned int)strlen(tag_name));",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Tag %s, string length: %d.\\n\", tag_name, (int)(unsigned int)strlen(tag_name));",
            "+    }",
            " ",
            "     /* allocate the new tag entry. */",
            "     tag_entry = calloc(1, sizeof(*tag_entry));",
            " ",
            "     if(!tag_entry) {",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Unable to allocate memory for tag entry!\\n\");",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Unable to allocate memory for tag entry!\\n\");",
            "+        }",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Found tag name=%s, tag instance ID=%x, tag type=%x, element length (in bytes) = %d, array dimensions = (%d, %d, %d)\\n\", tag_name, *last_tag_id, tag_type, (int)element_length, (int)array_dims[0], (int)array_dims[1], (int)array_dims[2]);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(",
            "+            stderr,",
            "+            \"Found tag name=%s, tag instance ID=%x, tag type=%x, element length (in bytes) = %d, array dimensions = (%d, %d, %d)\\n\",",
            "+            tag_name, *last_tag_id, tag_type, (int)element_length, (int)array_dims[0], (int)array_dims[1], (int)array_dims[2]);",
            "+    }",
            " ",
            "     /* fill in the fields. */",
            "     tag_entry->instance_id = *last_tag_id;",
            "     tag_entry->name = tag_name;",
            "     tag_entry->parent = parent;",
            "     tag_entry->type = tag_type;",
            "     tag_entry->elem_size = element_length;",
            "     tag_entry->num_dimensions = (uint16_t)((tag_type & TAG_DIM_MASK) >> 13);",
            "     tag_entry->dimensions[0] = array_dims[0];",
            "     tag_entry->dimensions[1] = array_dims[1];",
            "     tag_entry->dimensions[2] = array_dims[2];",
            " ",
            "     /* calculate the element count. */",
            "     tag_entry->elem_count = 1;",
            "-    for(uint16_t i=0; i < tag_entry->num_dimensions; i++) {",
            "+    for(uint16_t i = 0; i < tag_entry->num_dimensions; i++) {",
            "         tag_entry->elem_count = (uint16_t)((uint16_t)tag_entry->elem_count * (uint16_t)(tag_entry->dimensions[i]));",
            "     }",
            " ",
            "     /* link it up to the list */",
            "     tag_entry->next = *tag_list;",
            "     *tag_list = tag_entry;",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-void print_element_type(uint16_t element_type)",
            "-{",
            "+void print_element_type(uint16_t element_type) {",
            "     if(element_type & TYPE_IS_SYSTEM) {",
            "         printf(\"element type SYSTEM (0x%04x)\", (unsigned int)(element_type));",
            "     } else if(element_type & TYPE_IS_STRUCT) {",
            "-        printf(\"element type UDT (0x%04x) %s\", (unsigned int)(element_type), udts[(size_t)(unsigned int)(element_type & TYPE_UDT_ID_MASK)]->name);",
            "+        printf(\"element type UDT (0x%04x) %s\", (unsigned int)(element_type),",
            "+               udts[(size_t)(unsigned int)(element_type & TYPE_UDT_ID_MASK)]->name);",
            "     } else {",
            "         uint16_t atomic_type = element_type & 0xFF; /* MAGIC */",
            "         const char *type = NULL;",
            " ",
            "         switch(atomic_type) {",
            "             case 0xC1: type = \"BOOL: Boolean value\"; break;",
            "             case 0xC2: type = \"SINT: Signed 8-bit integer value\"; break;",
            "@@ -619,27 +652,28 @@",
            "         } else {",
            "             printf(\"UNKNOWN TYPE 0x%04x\", (unsigned int)element_type);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-int encode_request_prefix(const char *name, uint8_t *buffer, int *encoded_size)",
            "-{",
            "+int encode_request_prefix(const char *name, uint8_t *buffer, int *encoded_size) {",
            "     int symbol_length_index = 0;",
            "     /* start with the symbolic type identifier */",
            "     *encoded_size = 0;",
            "-    buffer[*encoded_size] = (uint8_t)(unsigned int)0x91; (*encoded_size)++;",
            "+    buffer[*encoded_size] = (uint8_t)(unsigned int)0x91;",
            "+    (*encoded_size)++;",
            " ",
            "     /* dummy value for the encoded length */",
            "     symbol_length_index = *encoded_size;",
            "-    buffer[*encoded_size] = (uint8_t)(unsigned int)0; (*encoded_size)++;",
            "+    buffer[*encoded_size] = (uint8_t)(unsigned int)0;",
            "+    (*encoded_size)++;",
            " ",
            "     /* copy the string. */",
            "-    for(int index=0; index < (int)(unsigned int)strlen(name); index++) {",
            "+    for(int index = 0; index < (int)(unsigned int)strlen(name); index++) {",
            "         buffer[*encoded_size] = (uint8_t)name[index];",
            "         (*encoded_size)++;",
            "     }",
            " ",
            "     /* backfill the encoded size */",
            "     buffer[symbol_length_index] = (uint8_t)(unsigned int)(strlen(name));",
            " ",
            "@@ -649,57 +683,62 @@",
            "         (*encoded_size)++;",
            "     }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int get_udt_definition(char *tag_string_base, uint16_t udt_id)",
            "-{",
            "+int get_udt_definition(char *tag_string_base, uint16_t udt_id) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int32_t udt_info_tag = 0;",
            "     int tag_size = 0;",
            "     char buf[32] = {0};",
            "     int offset = 0;",
            "     uint16_t template_id = 0;",
            "     uint16_t num_members = 0;",
            "     uint16_t struct_handle = 0;",
            "     uint32_t udt_instance_size = 0;",
            "-    //uint32_t member_desc_size = 0;",
            "+    // uint32_t member_desc_size = 0;",
            "     int name_len = 0;",
            "     char *name_str = NULL;",
            "     int name_index = 0;",
            "     int field_index = 0;",
            " ",
            "     /* memoize, check to see if we have this type already. */",
            "-    if(udts[udt_id]) {",
            "-        return PLCTAG_STATUS_OK;",
            "-    }",
            "+    if(udts[udt_id]) { return PLCTAG_STATUS_OK; }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     snprintf(buf, sizeof(buf), \"@udt/%u\", (unsigned int)udt_id);",
            " ",
            "     udt_info_tag = open_tag(tag_string_base, buf);",
            "     if(udt_info_tag < 0) {",
            "         if(udt_info_tag == PLCTAG_ERR_UNSUPPORTED) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"This PLC type does not support listing UDT definitions.\\n\");",
            "             return PLCTAG_ERR_UNSUPPORTED;",
            "         }",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to open UDT info tag, error %s!\\n\", plc_tag_decode_error(udt_info_tag));",
            "         usage();",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"UDT info tag ID: %d\\n\", udt_info_tag);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"UDT info tag ID: %d\\n\", udt_info_tag);",
            "+    }",
            " ",
            "     rc = plc_tag_read(udt_info_tag, TIMEOUT_MS);",
            "     if(rc == PLCTAG_ERR_UNSUPPORTED) {",
            "         plc_tag_destroy(udt_info_tag);",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"UDT tag introspection is not supported on this PLC.\\n\");",
            "         return rc;",
            "     } else if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s while trying to read UDT info!\\n\", plc_tag_decode_error(rc));",
            "         usage();",
            "     }",
            " ",
            "     tag_size = plc_tag_get_size(udt_info_tag);",
            " ",
            "     /* the format in the tag buffer is:",
            "@@ -725,42 +764,45 @@",
            "      * N x field names",
            "      *     int8_t string - zero-terminated.",
            "      *",
            "      */",
            " ",
            "     /* get the ID, number of members and the instance size. */",
            "     template_id = plc_tag_get_uint16(udt_info_tag, 0);",
            "-    //member_desc_size = plc_tag_get_uint32(udt_info_tag, 2);",
            "+    // member_desc_size = plc_tag_get_uint32(udt_info_tag, 2);",
            "     udt_instance_size = plc_tag_get_uint32(udt_info_tag, 6);",
            "     num_members = plc_tag_get_uint16(udt_info_tag, 10);",
            "     struct_handle = plc_tag_get_uint16(udt_info_tag, 12);",
            " ",
            "     /* skip past this header. */",
            "     offset = 14;",
            " ",
            "     /* just a sanity check */",
            "     if(template_id != udt_id) {",
            "-        fprintf(stderr, \"The ID, %x, of the UDT we are reading is not the same as the UDT ID we requested, %x!\\n\",(unsigned int)template_id, (unsigned int)udt_id);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"The ID, %x, of the UDT we are reading is not the same as the UDT ID we requested, %x!\\n\",",
            "+                (unsigned int)template_id, (unsigned int)udt_id);",
            "         usage();",
            "     }",
            " ",
            "     /* allocate a UDT struct with this info. */",
            "     udts[(size_t)udt_id] = calloc(1, sizeof(struct udt_entry_s) + (sizeof(struct udt_field_entry_s) * num_members));",
            "     if(!udts[(size_t)udt_id]) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate a new UDT definition structure!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     udts[(size_t)udt_id]->id = udt_id;",
            "     udts[(size_t)udt_id]->num_fields = num_members;",
            "     udts[(size_t)udt_id]->struct_handle = struct_handle;",
            "     udts[(size_t)udt_id]->instance_size = udt_instance_size;",
            " ",
            "     /* first section is the field type and size info for all fields. */",
            "-    for(int field_index=0; field_index < udts[udt_id]->num_fields; field_index++) {",
            "+    for(int field_index = 0; field_index < udts[udt_id]->num_fields; field_index++) {",
            "         uint16_t field_metadata = 0;",
            "         uint16_t field_element_type = 0;",
            "         uint32_t field_offset = 0;",
            " ",
            "         field_metadata = plc_tag_get_uint16(udt_info_tag, offset);",
            "         offset += 2;",
            " ",
            "@@ -782,140 +824,177 @@",
            "                 udts_to_process[last_udt] = child_udt;",
            "                 last_udt++;",
            "             }",
            "         }",
            "     }",
            " ",
            "     if(debug_level >= PLCTAG_DEBUG_DETAIL) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Offset after reading field descriptors: %d.\\n\", offset);",
            "     }",
            " ",
            "     /*",
            "      * then get the template/UDT name.   This is weird.",
            "      * Scan until we see a 0x3B, semicolon, byte.   That is the end of the",
            "      * template name.   Actually we should look for \";n\" but the semicolon",
            "      * seems to be enough for now.",
            "      */",
            " ",
            "     /* first get the zero-terminated string length */",
            "     name_len = plc_tag_get_string_length(udt_info_tag, offset);",
            "-    if(name_len <=0 || name_len >= 256) {",
            "+    if(name_len <= 0 || name_len >= 256) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unexpected raw UDT name length: %d!\\n\", name_len);",
            "-        //usage();",
            "+        // usage();",
            "     }",
            " ",
            "     /* create a string for this. */",
            "     name_str = calloc((size_t)(name_len + 1), (size_t)1);",
            "     if(!name_str) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate UDT name string!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     /* copy the name */",
            "     rc = plc_tag_get_string(udt_info_tag, offset, name_str, name_len + 1);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s retrieving UDT name string from the tag!\\n\", plc_tag_decode_error(rc));",
            "         free(name_str);",
            "         usage();",
            "     }",
            " ",
            "     /* zero terminate the name when we hit the first semicolon. */",
            "-    for(name_index = 0; name_index < name_len && name_str[name_index] != ';'; name_index++) { };",
            "+    for(name_index = 0; name_index < name_len && name_str[name_index] != ';'; name_index++) {};",
            " ",
            "-    if(name_str[name_index] == ';') {",
            "-        name_str[name_index] = 0;",
            "-    }",
            "+    if(name_str[name_index] == ';') { name_str[name_index] = 0; }",
            " ",
            "     /* check the name length again. */",
            "     name_len = (int)(unsigned int)strlen(name_str);",
            "-    if(name_len ==0 || name_len >= 256) {",
            "+    if(name_len == 0 || name_len >= 256) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unexpected UDT name length: %d!\\n\", name_len);",
            "     }",
            " ",
            "     udts[udt_id]->name = name_str;",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Getting data from UDT \\\"%s\\\".\\n\", udts[udt_id]->name);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Getting data from UDT \\\"%s\\\".\\n\", udts[udt_id]->name);",
            "+    }",
            " ",
            "     /* skip past the UDT name. */",
            "     offset += plc_tag_get_string_total_length(udt_info_tag, offset);",
            " ",
            "     /*",
            "      * This is the second section of the data, the field names.   They appear",
            "      * to be zero terminated.",
            "      */",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Getting %d field names for UDT %s.\\n\", udts[udt_id]->num_fields, udts[udt_id]->name);",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"offset=%u, tag_size=%u.\\n\", offset, tag_size);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Getting %d field names for UDT %s.\\n\", udts[udt_id]->num_fields, udts[udt_id]->name);",
            "+    }",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"offset=%u, tag_size=%u.\\n\", offset, tag_size);",
            "+    }",
            " ",
            "     /* loop over all fields and get name strings.  They are zero terminated. */",
            "-    for(field_index=0; field_index < udts[udt_id]->num_fields && offset < tag_size; field_index++) {",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Getting name for field %u.\\n\", field_index);",
            "+    for(field_index = 0; field_index < udts[udt_id]->num_fields && offset < tag_size; field_index++) {",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Getting name for field %u.\\n\", field_index);",
            "+        }",
            " ",
            "         /* first get the zero-terminated string length */",
            "         name_len = plc_tag_get_string_length(udt_info_tag, offset);",
            "-        if(name_len <0 || name_len >= 256) {",
            "+        if(name_len < 0 || name_len >= 256) {",
            "             plc_tag_destroy(udt_info_tag);",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unexpected UDT field name length: %d!\\n\", name_len);",
            "             usage();",
            "         }",
            " ",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"The name for field %u is %u characters long.\\n\", field_index, name_len);",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"The name for field %u is %u characters long.\\n\", field_index, name_len);",
            "+        }",
            " ",
            "         /* create a string for this. */",
            "         if(name_len > 0) {",
            "             name_str = calloc((size_t)(name_len + 1), (size_t)1);",
            "             if(!name_str) {",
            "                 plc_tag_destroy(udt_info_tag);",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to allocate UDT field name string!\\n\");",
            "                 usage();",
            "             }",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"The string for field %u is at %p.\\n\", field_index, (void *)name_str);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"The string for field %u is at %p.\\n\", field_index, (void *)name_str);",
            "+            }",
            " ",
            "             /* copy the name */",
            "             rc = plc_tag_get_string(udt_info_tag, offset, name_str, name_len + 1);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 plc_tag_destroy(udt_info_tag);",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Error %s retrieving UDT field name string from the tag!\\n\", plc_tag_decode_error(rc));",
            "                 free(name_str);",
            "                 usage();",
            "             }",
            " ",
            "             udts[udt_id]->fields[field_index].name = name_str;",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"UDT field %d is \\\"%s\\\".\\n\", field_index, udts[udt_id]->fields[field_index].name);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"UDT field %d is \\\"%s\\\".\\n\", field_index, udts[udt_id]->fields[field_index].name);",
            "+            }",
            " ",
            "             offset += plc_tag_get_string_total_length(udt_info_tag, offset);",
            "         } else {",
            "             /* field name was zero length. */",
            "             udts[udt_id]->fields[field_index].name = NULL;",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"UDT field %d is not named.\\n\", field_index);",
            "+            if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"UDT field %d is not named.\\n\", field_index);",
            "+            }",
            " ",
            "             /*",
            "              * The string is either zero length in which case we need to bump past the null",
            "              * terminator or it is at the end of the tag and we need to step past the edge.",
            "              */",
            "             offset++;",
            "         }",
            "     }",
            " ",
            "     /* sanity check */",
            "     if(offset != tag_size) {",
            "-        if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"Processed %d bytes out of %d bytes.\\n\", offset, tag_size);",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Processed %d bytes out of %d bytes.\\n\", offset, tag_size);",
            "+        }",
            "     }",
            " ",
            "     /* if we had a system tag, we might not have the full set of member/field names.  Fill in the gaps. */",
            "     for(; field_index < udts[udt_id]->num_fields; field_index++) {",
            "-            /* field name was zero length. */",
            "-            udts[udt_id]->fields[field_index].name = NULL;",
            "+        /* field name was zero length. */",
            "+        udts[udt_id]->fields[field_index].name = NULL;",
            " ",
            "-            if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr,  \"UDT field %d is not named.\\n\", field_index);",
            "+        if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"UDT field %d is not named.\\n\", field_index);",
            "+        }",
            "     }",
            " ",
            "-    if(debug_level >= PLCTAG_DEBUG_INFO) fprintf(stderr, \"Destroying UDT info tag: %d\\n\", udt_info_tag);",
            "+    if(debug_level >= PLCTAG_DEBUG_INFO) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Destroying UDT info tag: %d\\n\", udt_info_tag);",
            "+    }",
            "     plc_tag_destroy(udt_info_tag);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/multithread.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/multithread.c",
            "+++ /home/libplctag-2.6.7/src/examples/multithread.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,28 +27,22 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            "-#include <string.h>",
            " #include <stdlib.h>",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-#include <Windows.h>",
            "-#else",
            "-#include <pthread.h>",
            "-#include <signal.h>",
            "-#endif",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include <string.h>",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=TestDINTArray[0]\"",
            " #define ELEM_COUNT 1",
            " #define ELEM_SIZE 4",
            " #define DATA_TIMEOUT 500",
            " ",
            " #define MAX_THREADS (300)",
            "@@ -56,113 +50,38 @@",
            " /*",
            "  * This test program creates a lot of threads that read the same tag in",
            "  * the plc.  They all hit the exact same underlying tag data structure.",
            "  * This tests, to some extent, whether the library can handle multi-threaded",
            "  * access.",
            "  */",
            " ",
            "-",
            "-",
            "-#if defined(WIN32) || defined(_WIN32)",
            " volatile int done = 0;",
            " ",
            "-/* straight from MS' web site :-) */",
            "-BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)",
            "-{",
            "-    switch (fdwCtrlType)",
            "-    {",
            "-        // Handle the CTRL-C signal.",
            "-    case CTRL_C_EVENT:",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-        // CTRL-CLOSE: confirm that the user wants to exit.",
            "-    case CTRL_CLOSE_EVENT:",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-        // Pass other signals to the next handler.",
            "-    case CTRL_BREAK_EVENT:",
            "-        done = 1;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_LOGOFF_EVENT:",
            "-        done = 1;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_SHUTDOWN_EVENT:",
            "-        done = 1;",
            "-        return FALSE;",
            "-",
            "-    default:",
            "-        return FALSE;",
            "-    }",
            "-}",
            "-",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))",
            "-    {",
            "-        printf(\"\\nERROR: Could not set control handler!\\n\");",
            "-    }",
            "-}",
            "-",
            "-#else",
            "-volatile sig_atomic_t done = 0;",
            "-",
            "-void SIGINT_handler(int not_used)",
            "-{",
            "-    (void)not_used;",
            "-",
            "-    done = 1;",
            "-}",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    struct sigaction act;",
            "-",
            "-    /* set up signal handler. */",
            "-    memset(&act, 0, sizeof(act));",
            "-    act.sa_handler = SIGINT_handler;",
            "-    sigaction(SIGINT, &act, NULL);",
            "-}",
            "-",
            "-#endif",
            "-",
            "-",
            "-",
            "-",
            "+void interrupt_handler(void) { done = 1; }",
            " ",
            " ",
            " /* global to cheat on passing it to threads. */",
            " volatile int32_t tag;",
            " ",
            " ",
            "-",
            " /*",
            "  * Thread function.  Just read until killed.",
            "  */",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-DWORD __stdcall thread_func(LPVOID data)",
            "-#else",
            "-void *thread_func(void *data)",
            "-#endif",
            "-{",
            "+void *thread_func(void *data) {",
            "     int tid = (int)(intptr_t)data;",
            "     int rc;",
            "     int value;",
            " ",
            "     while(!done) {",
            "         int64_t start;",
            "         int64_t end;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         /* use do/while to allow easy exit without return */",
            "         do {",
            "             rc = plc_tag_lock(tag);",
            " ",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1000;",
            "@@ -170,128 +89,112 @@",
            "             }",
            " ",
            "             rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1001;",
            "             } else {",
            "-                value = (int)plc_tag_get_int32(tag,0);",
            "+                value = (int)plc_tag_get_int32(tag, 0);",
            " ",
            "                 /* increment the value */",
            "                 value = (value > 500 ? 0 : value + 1);",
            " ",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Thread %d setting tag to value %d.\\n\", tid, value);",
            " ",
            "                 /* yes, we should be checking this return value too... */",
            "                 plc_tag_set_int32(tag, 0, (int32_t)value);",
            " ",
            "                 /* write the value */",
            "                 rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "             }",
            " ",
            "             /* yes, we should look at the return value */",
            "             plc_tag_unlock(tag);",
            " ",
            "             /* give up the CPU */",
            "-            util_sleep_ms(10);",
            "+            compat_sleep_ms(10, NULL);",
            "         } while(0);",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "-        fprintf(stderr,\"Thread %d got result %d with return code %s in %dms\\n\",tid,value,plc_tag_decode_error(rc),(int)(end-start));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Thread %d got result %d with return code %s in %dms\\n\", tid, value, plc_tag_decode_error(rc),",
            "+                (int)(end - start));",
            " ",
            "-        util_sleep_ms(1);",
            "+        compat_sleep_ms(10, NULL);",
            "     }",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    return (DWORD)0;",
            "-#else",
            "-    return NULL;",
            "-#endif",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    HANDLE thread[MAX_THREADS];",
            "-#else",
            "-    pthread_t thread[MAX_THREADS];",
            "-#endif",
            "+    compat_thread_t thread[MAX_THREADS];",
            "     int num_threads;",
            "     int thread_id = 0;",
            " ",
            "-    /* set up handler for ^C etc. */",
            "-    setup_break_handler();",
            "+    /* Set up the signal handler */",
            "+    compat_set_interrupt_handler(interrupt_handler);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Hit ^C to terminate the test.\\n\");",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     if(argc != 2) {",
            "-        fprintf(stderr,\"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\",argc);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\", argc);",
            "         return 0;",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "-    num_threads = (int)strtol(argv[1],NULL, 10);",
            "+    num_threads = (int)strtol(argv[1], NULL, 10);",
            " ",
            "     if(num_threads < 1 || num_threads > MAX_THREADS) {",
            "-        fprintf(stderr,\"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",num_threads, argv[1]);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",",
            "+                num_threads, argv[1]);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the read threads */",
            "-    fprintf(stderr,\"Creating %d threads.\\n\",num_threads);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Creating %d threads.\\n\", num_threads);",
            " ",
            "-    for(thread_id=0; thread_id < num_threads; thread_id++) {",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        thread[thread_id] = CreateThread(",
            "-                                        NULL,                       /* default security attributes */",
            "-                                        0,                          /* use default stack size      */",
            "-                                        thread_func,                /* thread function             */",
            "-                                        (void *)(intptr_t)thread_id,/* argument to thread function */",
            "-                                        (DWORD)0,                   /* use default creation flags  */",
            "-                                        (LPDWORD)NULL);              /* do not need thread ID       */",
            "-#else",
            "-        pthread_create(&thread[thread_id], NULL, thread_func, (void *)(intptr_t)thread_id);",
            "-#endif",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "+        compat_thread_create(&thread[thread_id], thread_func, (void *)(intptr_t)thread_id);",
            "     }",
            " ",
            "     /* wait until ^C */",
            "-    while(!done) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(!done) { compat_sleep_ms(100, NULL); }",
            " ",
            "-    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        WaitForSingleObject(thread[thread_id], (DWORD)INFINITE);",
            "-#else",
            "-        pthread_join(thread[thread_id], NULL);",
            "-#endif",
            "-    }",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) { compat_thread_join(thread[thread_id], NULL); }",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/multithread_cached_read.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/multithread_cached_read.c",
            "+++ /home/libplctag-2.6.7/src/examples/multithread_cached_read.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,27 +28,25 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdint.h>",
            " #include <stdio.h>",
            "-#include <unistd.h>",
            " #include <stdlib.h>",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            "-#include <inttypes.h>",
            "-#include <sys/time.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            "-#define TAG_PATH \"protocol=ab_eip&gateway=10.17.45.37&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=DataIn_Frm_Sched[1]&read_cache_ms=100\"",
            "+#define TAG_PATH \\",
            "+    \"protocol=ab_eip&gateway=10.17.45.37&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=DataIn_Frm_Sched[1]&read_cache_ms=100\"",
            " #define ELEM_COUNT 1",
            " #define ELEM_SIZE 4",
            " #define DATA_TIMEOUT 500",
            " ",
            " #define MAX_THREADS (300)",
            " ",
            " /*",
            "@@ -60,31 +58,32 @@",
            " ",
            " ",
            " /* global to cheat on passing it to threads. */",
            " volatile int32_t tag;",
            " volatile int done = 0;",
            " ",
            " ",
            "+void handle_done(void) { done = 1; }",
            "+",
            " ",
            " /*",
            "  * Thread function.  Just read until killed.",
            "  */",
            " ",
            "-void *thread_func(void *data)",
            "-{",
            "+void *thread_func(void *data) {",
            "     int tid = (int)(intptr_t)data;",
            "     int rc;",
            "     int value;",
            " ",
            "     while(!done) {",
            "         int64_t start;",
            "         int64_t end;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         /* use do/while to allow easy exit without return */",
            "         do {",
            "             rc = plc_tag_lock(tag);",
            " ",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1000;",
            "@@ -92,87 +91,93 @@",
            "             }",
            " ",
            "             rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1001;",
            "             } else {",
            "-                value = (int)plc_tag_get_int32(tag,0);",
            "+                value = (int)plc_tag_get_int32(tag, 0);",
            "             }",
            " ",
            "             /* yes, we should look at the return value */",
            "             plc_tag_unlock(tag);",
            "         } while(0);",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "-        fprintf(stderr,\"%\" PRId64 \" Thread %d got result %d with return code %s in %dms\\n\",util_time_ms(),tid,value,plc_tag_decode_error(rc),(int)(end-start));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"%\" PRId64 \" Thread %d got result %d with return code %s in %dms\\n\", compat_time_ms(), tid, value,",
            "+                plc_tag_decode_error(rc), (int)(end - start));",
            " ",
            "-        util_sleep_ms(1);",
            "+        /* this is really too low */",
            "+        compat_sleep_ms(10, NULL);",
            "     }",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    pthread_t thread[MAX_THREADS];",
            "+    compat_thread_t thread[MAX_THREADS];",
            "     int num_threads;",
            "     int thread_id = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     if(argc != 2) {",
            "-        fprintf(stderr,\"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\",argc);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\", argc);",
            "         return 0;",
            "     }",
            " ",
            "-    num_threads = (int)strtol(argv[1],NULL, 10);",
            "+    num_threads = (int)strtol(argv[1], NULL, 10);",
            " ",
            "     if(num_threads < 1 || num_threads > MAX_THREADS) {",
            "-        fprintf(stderr,\"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",num_threads, argv[1]);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",",
            "+                num_threads, argv[1]);",
            "         return 0;",
            "     }",
            " ",
            "+    /* set up done handler */",
            "+    compat_set_interrupt_handler(handle_done);",
            "+",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the read threads */",
            "-    fprintf(stderr,\"Creating %d threads.\\n\",num_threads);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Creating %d threads.\\n\", num_threads);",
            " ",
            "-    for(thread_id=0; thread_id < num_threads; thread_id++) {",
            "-        pthread_create(&thread[thread_id], NULL, thread_func, (void *)(intptr_t)thread_id);",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "+        compat_thread_create(&thread[thread_id], thread_func, (void *)(intptr_t)thread_id);",
            "     }",
            " ",
            "     /* wait until ^C */",
            "-    while(1) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(!done) { compat_sleep_ms(100, NULL); }",
            " ",
            "-    done = 1;",
            "-",
            "-    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "-        pthread_join(thread[thread_id], NULL);",
            "-    }",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) { compat_thread_join(thread[thread_id], NULL); }",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/multithread_plc5.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/multithread_plc5.c",
            "+++ /home/libplctag-2.6.7/src/examples/multithread_plc5.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,23 +27,21 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdint.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            "-#include <sys/time.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.38&plc=PLC5&elem_size=4&elem_count=1&name=F8:10\"",
            " #define ELEM_COUNT 1",
            " #define ELEM_SIZE 4",
            " #define DATA_TIMEOUT 5000",
            " ",
            " #define MAX_THREADS (300)",
            "@@ -62,40 +60,39 @@",
            " volatile int32_t tag = 0;",
            " volatile int done = 0;",
            " ",
            " /*",
            "  * Thread function.  Just read until killed.",
            "  */",
            " ",
            "-void *thread_func(void *data)",
            "-{",
            "+void *thread_func(void *data) {",
            "     int tid = (int)(intptr_t)data;",
            "     int rc;",
            "     float value;",
            " ",
            "     while(!done) {",
            "         int64_t start;",
            "         int64_t end;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         /* use do/while to allow easy exit without return */",
            "         do {",
            "             rc = plc_tag_lock(tag);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1000;",
            "                 break; /* punt, no lock */",
            "             }",
            " ",
            "             rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1001;",
            "             } else {",
            "-                value =  plc_tag_get_float32(tag,0);",
            "+                value = plc_tag_get_float32(tag, 0);",
            " ",
            "                 /* increment the value */",
            "                 value = (float)(value > 500.0 ? 0.0 : value + 1.5);",
            " ",
            "                 /* yes, we should be checking this return value too... */",
            "                 plc_tag_set_float32(tag, 0, value);",
            " ",
            "@@ -103,82 +100,86 @@",
            "                 rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "             }",
            " ",
            "             /* yes, we should look at the return value */",
            "             plc_tag_unlock(tag);",
            "         } while(0);",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "-        fprintf(stderr,\"Thread %d got result %f with return code %s in %dms\\n\",tid,value,plc_tag_decode_error(rc),(int)(end-start));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Thread %d got result %f with return code %s in %dms\\n\", tid, value, plc_tag_decode_error(rc),",
            "+                (int)(end - start));",
            " ",
            "         /* no short sleeps, this is a PLC5 */",
            "-        util_sleep_ms(10);",
            "+        compat_sleep_ms(10, NULL);",
            "     }",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    pthread_t thread[MAX_THREADS];",
            "+    compat_thread_t thread[MAX_THREADS];",
            "     int num_threads;",
            "     int thread_id = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     if(argc != 2) {",
            "-        fprintf(stderr,\"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\",argc);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\", argc);",
            "         return 0;",
            "     }",
            " ",
            "-    num_threads = (int)strtol(argv[1],NULL, 10);",
            "+    num_threads = (int)strtol(argv[1], NULL, 10);",
            " ",
            "     if(num_threads < 1 || num_threads > MAX_THREADS) {",
            "-        fprintf(stderr,\"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",num_threads, argv[1]);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",",
            "+                num_threads, argv[1]);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the read threads */",
            " ",
            "-    fprintf(stderr,\"Creating %d threads.\\n\",num_threads);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Creating %d threads.\\n\", num_threads);",
            " ",
            "-    for(thread_id=0; thread_id < num_threads; thread_id++) {",
            "-        pthread_create(&thread[thread_id], NULL, thread_func, (void *)(intptr_t)thread_id);",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "+        compat_thread_create(&thread[thread_id], thread_func, (void *)(intptr_t)thread_id);",
            "     }",
            " ",
            "-    /* wait until ^C */",
            "-    while(1) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    /* FIXME - set up interrupt handler */",
            "+    while(1) { compat_sleep_ms(100, NULL); }",
            " ",
            "     done = 1;",
            " ",
            "-    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "-        pthread_join(thread[thread_id], NULL);",
            "-    }",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) { compat_thread_join(thread[thread_id], NULL); }",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/multithread_plc5_dhp.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/multithread_plc5_dhp.c",
            "+++ /home/libplctag-2.6.7/src/examples/multithread_plc5_dhp.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,23 +27,21 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdint.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            "-#include <sys/time.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.39&path=1,2,A:27:1&cpu=plc5&elem_count=1&elem_size=2&name=N7:0&debug=4\"",
            " #define ELEM_COUNT 1",
            " #define ELEM_SIZE 2",
            " #define DATA_TIMEOUT 5000",
            " ",
            " #define MAX_THREADS (5)",
            "@@ -62,40 +60,39 @@",
            " volatile int32_t tag = 0;",
            " volatile int done = 0;",
            " ",
            " /*",
            "  * Thread function.  Just read until killed.",
            "  */",
            " ",
            "-void *thread_func(void *data)",
            "-{",
            "+void *thread_func(void *data) {",
            "     int tid = (int)(intptr_t)data;",
            "     int rc;",
            "     float value;",
            " ",
            "     while(!done) {",
            "         int64_t start;",
            "         int64_t end;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         /* use do/while to allow easy exit without return */",
            "         do {",
            "             rc = plc_tag_lock(tag);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1000;",
            "                 break; /* punt, no lock */",
            "             }",
            " ",
            "             rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "                 value = 1001;",
            "             } else {",
            "-                value =  plc_tag_get_float32(tag,0);",
            "+                value = plc_tag_get_float32(tag, 0);",
            " ",
            "                 /* increment the value */",
            "                 value = (float)(value > 500.0 ? 0.0 : value + 1.5);",
            " ",
            "                 /* yes, we should be checking this return value too... */",
            "                 plc_tag_set_float32(tag, 0, value);",
            " ",
            "@@ -103,82 +100,86 @@",
            "                 rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "             }",
            " ",
            "             /* yes, we should look at the return value */",
            "             plc_tag_unlock(tag);",
            "         } while(0);",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "-        fprintf(stderr,\"Thread %d got result %f with return code %s in %dms\\n\",tid,value,plc_tag_decode_error(rc),(int)(end-start));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Thread %d got result %f with return code %s in %dms\\n\", tid, value, plc_tag_decode_error(rc),",
            "+                (int)(end - start));",
            " ",
            "         /* no short sleeps, this is a PLC5 */",
            "-        util_sleep_ms(10);",
            "+        compat_sleep_ms(10, NULL);",
            "     }",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    pthread_t thread[MAX_THREADS];",
            "+    compat_thread_t thread[MAX_THREADS];",
            "     int num_threads;",
            "     int thread_id = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     if(argc != 2) {",
            "-        fprintf(stderr,\"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\",argc);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Must provide number of threads to run (between 1 and 300) argc=%d!\\n\", argc);",
            "         return 0;",
            "     }",
            " ",
            "-    num_threads = (int)strtol(argv[1],NULL, 10);",
            "+    num_threads = (int)strtol(argv[1], NULL, 10);",
            " ",
            "     if(num_threads < 1 || num_threads > MAX_THREADS) {",
            "-        fprintf(stderr,\"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",num_threads, argv[1]);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: %d (%s) is not a valid number. Must provide number of threads to run (between 1 and 300)!\\n\",",
            "+                num_threads, argv[1]);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* create the read threads */",
            " ",
            "-    fprintf(stderr,\"Creating %d threads.\\n\",num_threads);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Creating %d threads.\\n\", num_threads);",
            " ",
            "-    for(thread_id=0; thread_id < num_threads; thread_id++) {",
            "-        pthread_create(&thread[thread_id], NULL, thread_func, (void *)(intptr_t)thread_id);",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "+        compat_thread_create(&thread[thread_id], thread_func, (void *)(intptr_t)thread_id);",
            "     }",
            " ",
            "-    /* wait until ^C */",
            "-    while(1) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    /* FIXME - set up interrupt handler */",
            "+    while(1) { compat_sleep_ms(100, NULL); }",
            " ",
            "     done = 1;",
            " ",
            "-    for(thread_id = 0; thread_id < num_threads; thread_id++) {",
            "-        pthread_join(thread[thread_id], NULL);",
            "-    }",
            "+    for(thread_id = 0; thread_id < num_threads; thread_id++) { compat_thread_join(thread[thread_id], NULL); }",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/plc5.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/plc5.c",
            "+++ /home/libplctag-2.6.7/src/examples/plc5.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,115 +28,121 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,16",
            "+#define REQUIRED_VERSION 2, 1, 16",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.38&cpu=PLC5&elem_count=5&name=F8:10\"",
            " #define ELEM_COUNT 5",
            " #define ELEM_SIZE 4",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int file_type = 0;",
            "     int i;",
            " ",
            "     (void)argc;",
            "     (void)argv;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "-    fprintf(stderr, \"Using library version %d.%d.%d.\\n\",",
            "-                                            plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_minor\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Using library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "+            plc_tag_get_int_attribute(0, \"version_minor\", -1), plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            " ",
            "     /* turn off debugging output. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if(plc_tag_status(tag) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        fprintf(stderr,\"data[%d]=%f\\n\",i,plc_tag_get_float32(tag,(i*ELEM_SIZE)));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%f\\n\", i, plc_tag_get_float32(tag, (i * ELEM_SIZE)));",
            "     }",
            " ",
            "     /* now test a write */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        float val = plc_tag_get_float32(tag,(i*ELEM_SIZE));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        float val = plc_tag_get_float32(tag, (i * ELEM_SIZE));",
            " ",
            "-        val = val+1.5f;",
            "+        val = val + 1.5f;",
            " ",
            "-        fprintf(stderr,\"Setting element %d to %f\\n\",i,val);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Setting element %d to %f\\n\", i, val);",
            " ",
            "-        plc_tag_set_float32(tag,(i*ELEM_SIZE),val);",
            "+        plc_tag_set_float32(tag, (i * ELEM_SIZE), val);",
            "     }",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            " ",
            "     /* get the data again*/",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        fprintf(stderr,\"data[%d]=%f\\n\",i,plc_tag_get_float32(tag,(i*ELEM_SIZE)));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%f\\n\", i, plc_tag_get_float32(tag, (i * ELEM_SIZE)));",
            "     }",
            " ",
            "     /* see what the data type is */",
            "     file_type = plc_tag_get_int_attribute(tag, \"elem_type\", -1);",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Reported data file type is 0x%02x.\\n\", file_type);",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/simple.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/simple.c",
            "+++ /home/libplctag-2.6.7/src/examples/simple.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,101 +28,107 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,4,0",
            "+#define REQUIRED_VERSION 2, 4, 0",
            " ",
            " /* test against a DINT array. */",
            " #define TAG_PATH \"protocol=ab-eip&gateway=127.0.0.1&path=1,0&cpu=LGX&elem_count=10&name=TestBigArray\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int i;",
            "     int elem_size = 0;",
            "     int elem_count = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 1;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* get the tag size and element size. Do this _AFTER_ reading the tag otherwise we may not know how big the tag is! */",
            "     elem_size = plc_tag_get_int_attribute(tag, \"elem_size\", 0);",
            "     elem_count = plc_tag_get_int_attribute(tag, \"elem_count\", 0);",
            " ",
            "-    fprintf(stderr,\"Tag has %d elements each of %d bytes.\\n\", elem_count, elem_size);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Tag has %d elements each of %d bytes.\\n\", elem_count, elem_size);",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < elem_count; i++) {",
            "-        fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int32(tag,(i*elem_size)));",
            "+    for(i = 0; i < elem_count; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int32(tag, (i * elem_size)));",
            "     }",
            " ",
            "     /* now test a write */",
            "-    for(i=0; i < elem_count; i++) {",
            "-        int32_t val = plc_tag_get_int32(tag,(i*elem_size));",
            "+    for(i = 0; i < elem_count; i++) {",
            "+        int32_t val = plc_tag_get_int32(tag, (i * elem_size));",
            " ",
            "-        val = val+1;",
            "+        val = val + 1;",
            " ",
            "-        fprintf(stderr,\"Setting element %d to %d\\n\",i,val);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Setting element %d to %d\\n\", i, val);",
            " ",
            "-        plc_tag_set_int32(tag,(i*elem_size),val);",
            "+        plc_tag_set_int32(tag, (i * elem_size), val);",
            "     }",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to write the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to write the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* get the data again*/",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < elem_count; i++) {",
            "-        fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int32(tag,(i*elem_size)));",
            "+    for(i = 0; i < elem_count; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int32(tag, (i * elem_size)));",
            "     }",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/simple_cpp.cpp",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/simple_cpp.cpp",
            "+++ /home/libplctag-2.6.7/src/examples/simple_cpp.cpp",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,35 +27,34 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=LGX&elem_count=10&name=TestDINTArray\"",
            " #define ELEM_COUNT 10",
            " #define ELEM_SIZE 4",
            " #define DATA_TIMEOUT 5000",
            " ",
            " /*",
            "  * There really isn't much to this example other than it being compiled",
            "  * by g++ instead of gcc.  This is just to test that the API functions are",
            "  * correctly exported for C++ code.",
            "  */",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main() {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int i;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "@@ -63,71 +62,65 @@",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(rc));",
            "+        fprintf(stderr, \"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int32(tag,(i*ELEM_SIZE)));",
            "-    }",
            "+    for(i = 0; i < ELEM_COUNT; i++) { fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int32(tag, (i * ELEM_SIZE))); }",
            " ",
            "     /* now test a write */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        int32_t val = plc_tag_get_int32(tag,(i*ELEM_SIZE));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        int32_t val = plc_tag_get_int32(tag, (i * ELEM_SIZE));",
            " ",
            "-        val = val+1;",
            "+        val = val + 1;",
            " ",
            "-        fprintf(stderr,\"Setting element %d to %d\\n\",i,val);",
            "+        fprintf(stderr, \"Setting element %d to %d\\n\", i, val);",
            " ",
            "-        plc_tag_set_int32(tag,(i*ELEM_SIZE),val);",
            "+        plc_tag_set_int32(tag, (i * ELEM_SIZE), val);",
            "     }",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to write the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        fprintf(stderr, \"ERROR: Unable to write the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            " ",
            "     /* get the data again*/",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int32(tag,(i*ELEM_SIZE)));",
            "-    }",
            "+    for(i = 0; i < ELEM_COUNT; i++) { fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int32(tag, (i * ELEM_SIZE))); }",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/simple_dual.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/simple_dual.c",
            "+++ /home/libplctag-2.6.7/src/examples/simple_dual.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,193 +28,207 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " /*",
            "  * This tests the use of simultaneous connected (DH+ to a PLC) and unconnected messages (to an LGX).  The first",
            "  * sets up a connection object and uses different packet formats.  The second uses UCMM and uses the usual",
            "  * unconnected packet format.",
            "  */",
            " ",
            "-#define REQUIRED_VERSION 2,1,19",
            "+#define REQUIRED_VERSION 2, 1, 19",
            " ",
            " // #define TAG_PATH1 \"protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=10&name=TestDINTArray&debug=1\"",
            " // #define TAG_PATH2 \"protocol=ab_eip&gateway=10.206.1.39&path=1,2,A:27:1&cpu=plc5&elem_count=4&elem_size=4&name=F8:0&debug=1\"",
            " ",
            " #define TAG_PATH2 \"protocol=ab_eip&gateway=10.206.1.38&path=0&plc=plc5&elem_size=4&elem_count=1&name=F8:0\"",
            " #define TAG_PATH1 \"protocol=ab_eip&gateway=10.206.1.38&plc=plc5&elem_size=2&elem_count=1&name=N7:0\"",
            " ",
            " ",
            " #define DATA_TIMEOUT 1000",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag1 = 0;",
            "     int32_t tag2 = 0;",
            "-    int rc1,rc2;",
            "+    int rc1, rc2;",
            "     int i;",
            "     int elem_size = 0;",
            "     int elem_count = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* set debug level if we need it. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* create the tag, async */",
            "     tag1 = plc_tag_create(TAG_PATH1, 0);",
            "     tag2 = plc_tag_create(TAG_PATH2, 0);",
            " ",
            "     /* everything OK? */",
            "     if(plc_tag_status(tag1) != PLCTAG_STATUS_OK && plc_tag_status(tag1) != PLCTAG_STATUS_PENDING) {",
            "-        fprintf(stderr,\"ERROR, %s: Could not create tag 1!\\n\", plc_tag_decode_error(plc_tag_status(tag1)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR, %s: Could not create tag 1!\\n\", plc_tag_decode_error(plc_tag_status(tag1)));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return plc_tag_status(tag1);",
            "     }",
            " ",
            "     if(plc_tag_status(tag2) != PLCTAG_STATUS_OK && plc_tag_status(tag2) != PLCTAG_STATUS_PENDING) {",
            "-        fprintf(stderr,\"ERROR, %s: Could not create tag 2!\\n\", plc_tag_decode_error(plc_tag_status(tag2)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR, %s: Could not create tag 2!\\n\", plc_tag_decode_error(plc_tag_status(tag2)));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return plc_tag_status(tag2);",
            "     }",
            " ",
            "     /* brute force wait for tags to finish setting up */",
            "-    util_sleep_ms(DATA_TIMEOUT);",
            "+    compat_sleep_ms(DATA_TIMEOUT, NULL);",
            " ",
            "     rc1 = plc_tag_status(tag1);",
            "     rc2 = plc_tag_status(tag2);",
            " ",
            "     if(rc1 != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag 1 internal state. %s\\n\", plc_tag_decode_error(rc1));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag 1 internal state. %s\\n\", plc_tag_decode_error(rc1));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return rc1;",
            "     }",
            " ",
            "     if(rc2 != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag 2 internal state. %s\\n\", plc_tag_decode_error(rc2));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag 2 internal state. %s\\n\", plc_tag_decode_error(rc2));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return rc2;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc2 = plc_tag_read(tag2, 0);",
            "     rc1 = plc_tag_read(tag1, 0);",
            " ",
            "     if(rc1 != PLCTAG_STATUS_OK && rc1 != PLCTAG_STATUS_PENDING) {",
            "-        fprintf(stderr,\"ERROR: Unable to start reading the tag 1 data! Got error code %d: %s\\n\",rc1, plc_tag_decode_error(rc1));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to start reading the tag 1 data! Got error code %d: %s\\n\", rc1, plc_tag_decode_error(rc1));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return rc1;",
            "     }",
            " ",
            "     if(rc2 != PLCTAG_STATUS_OK && rc2 != PLCTAG_STATUS_PENDING) {",
            "-        fprintf(stderr,\"ERROR: Unable to start reading the tag 2 data! Got error code %d: %s\\n\",rc2, plc_tag_decode_error(rc2));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to start reading the tag 2 data! Got error code %d: %s\\n\", rc2, plc_tag_decode_error(rc2));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return rc2;",
            "     }",
            " ",
            "     /* let the reads complete */",
            "-    util_sleep_ms(DATA_TIMEOUT);",
            "+    compat_sleep_ms(DATA_TIMEOUT, NULL);",
            " ",
            "     rc1 = plc_tag_status(tag1);",
            "     rc2 = plc_tag_status(tag2);",
            " ",
            "     if(rc1 != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the tag 1 data! Got error code %d: %s\\n\",rc1, plc_tag_decode_error(rc1));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the tag 1 data! Got error code %d: %s\\n\", rc1, plc_tag_decode_error(rc1));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return rc1;",
            "     }",
            " ",
            "     if(rc2 != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the tag 2 data! Got error code %d: %s\\n\",rc2, plc_tag_decode_error(rc2));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the tag 2 data! Got error code %d: %s\\n\", rc2, plc_tag_decode_error(rc2));",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return rc2;",
            "     }",
            " ",
            " ",
            "     /* print out the data for tag 1 */",
            "     elem_count = plc_tag_get_int_attribute(tag1, \"elem_count\", 0);",
            "     if(elem_count == 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Tag element count is zero!\\n\");",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return PLCTAG_ERR_NO_DATA;",
            "     }",
            " ",
            "-    elem_size = plc_tag_get_size(tag1)/elem_count;",
            "+    elem_size = plc_tag_get_size(tag1) / elem_count;",
            " ",
            "-    for(i=0; i < elem_count; i++) {",
            "+    for(i = 0; i < elem_count; i++) {",
            "         switch(elem_size) {",
            "             case 1:",
            "-                fprintf(stderr,\"tag 1 data[%d]=%d\\n\",i,plc_tag_get_int8(tag1,(i*1)));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"tag 1 data[%d]=%d\\n\", i, plc_tag_get_int8(tag1, (i * 1)));",
            "                 break;",
            " ",
            "             case 2:",
            "-                fprintf(stderr,\"tag 1 data[%d]=%d\\n\",i,plc_tag_get_int16(tag1,(i*2)));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"tag 1 data[%d]=%d\\n\", i, plc_tag_get_int16(tag1, (i * 2)));",
            "                 break;",
            " ",
            "             case 4:",
            "-                fprintf(stderr,\"tag 1 data[%d]=%f\\n\",i,plc_tag_get_float32(tag1,(i*4)));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"tag 1 data[%d]=%f\\n\", i, plc_tag_get_float32(tag1, (i * 4)));",
            "                 break;",
            " ",
            "             default:",
            "-                fprintf(stderr, \"Unsupported size %d!\", elem_size);",
            "+                // NOLINTNEXTLINE",
            "                 plc_tag_destroy(tag1);",
            "                 plc_tag_destroy(tag2);",
            "                 return PLCTAG_ERR_NO_DATA;",
            "                 break;",
            "         }",
            "     }",
            " ",
            "     /* print out the data for tag 2 */",
            "     elem_count = plc_tag_get_int_attribute(tag2, \"elem_count\", 0);",
            "     if(elem_count == 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Tag element count is zero!\\n\");",
            "         plc_tag_destroy(tag1);",
            "         plc_tag_destroy(tag2);",
            "         return PLCTAG_ERR_NO_DATA;",
            "     }",
            " ",
            "-    elem_size = plc_tag_get_size(tag2)/elem_count;",
            "+    elem_size = plc_tag_get_size(tag2) / elem_count;",
            " ",
            "-    for(i=0; i < elem_count; i++) {",
            "+    for(i = 0; i < elem_count; i++) {",
            "         switch(elem_size) {",
            "-            case 1:",
            "-                fprintf(stderr,\"tag 2 data[%d]=%d\\n\",i,plc_tag_get_int8(tag2,(i*1)));",
            "+            case 1:  // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"tag 2 data[%d]=%d\\n\", i, plc_tag_get_int8(tag2, (i * 1)));",
            "                 break;",
            " ",
            "-            case 2:",
            "-                fprintf(stderr,\"tag 2 data[%d]=%d\\n\",i,plc_tag_get_int16(tag2,(i*2)));",
            "+            case 2:  // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"tag 2 data[%d]=%d\\n\", i, plc_tag_get_int16(tag2, (i * 2)));",
            "                 break;",
            " ",
            "-            case 4:",
            "-                fprintf(stderr,\"tag 2 data[%d]=%f\\n\",i,plc_tag_get_float32(tag2,(i*4)));",
            "+            case 4:  // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"tag 2 data[%d]=%f\\n\", i, plc_tag_get_float32(tag2, (i * 4)));",
            "                 break;",
            " ",
            "             default:",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unsupported size %d!\", elem_size);",
            "                 plc_tag_destroy(tag1);",
            "                 plc_tag_destroy(tag2);",
            "                 return PLCTAG_ERR_NO_DATA;",
            "                 break;",
            "         }",
            "     }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/slc500.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/slc500.c",
            "+++ /home/libplctag-2.6.7/src/examples/slc500.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,99 +27,105 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.26&cpu=SLC&elem_size=2&elem_count=1&name=N7:0&debug=1\"",
            " #define ELEM_COUNT 1",
            " #define ELEM_SIZE 2",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int i;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     if(plc_tag_status(tag) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state.  Error %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state.  Error %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int16(tag,(i*ELEM_SIZE)));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int16(tag, (i * ELEM_SIZE)));",
            "     }",
            " ",
            "     /* now test a write */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        int16_t val = plc_tag_get_int16(tag,(i*ELEM_SIZE));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        int16_t val = plc_tag_get_int16(tag, (i * ELEM_SIZE));",
            " ",
            "         val++;",
            " ",
            "-        fprintf(stderr,\"Setting element %d to %d\\n\",i,val);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Setting element %d to %d\\n\", i, val);",
            " ",
            "-        plc_tag_set_int16(tag,(i*ELEM_SIZE),val);",
            "+        plc_tag_set_int16(tag, (i * ELEM_SIZE), val);",
            "     }",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            " ",
            "     /* get the data again*/",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i=0; i < ELEM_COUNT; i++) {",
            "-        fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int16(tag,(i*ELEM_SIZE)));",
            "+    for(i = 0; i < ELEM_COUNT; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int16(tag, (i * ELEM_SIZE)));",
            "     }",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/stress_api_lock.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/stress_api_lock.c",
            "+++ /home/libplctag-2.6.7/src/examples/stress_api_lock.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,176 +28,176 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdint.h>",
            " #include <stdio.h>",
            "-#include <unistd.h>",
            " #include <stdlib.h>",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            "-#include <sys/time.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=TestDINTArray[4]&debug=4\"",
            " ",
            " #define DATA_TIMEOUT 1500",
            " ",
            " ",
            "-",
            " /*",
            "  * This test program creates a lot of threads that read the same tag in",
            "  * the plc.  They all hit the exact same underlying tag data structure.",
            "  * This tests, to some extent, whether the library can handle multi-threaded",
            "  * access.",
            "  */",
            " ",
            " ",
            " /* global to cheat on passing it to threads. */",
            " volatile int done = 0;",
            " volatile int32_t tag = 0;",
            " ",
            " ",
            "-",
            "-",
            "-static int open_tag(const char *tag_str)",
            "-{",
            "+static int open_tag(const char *tag_str) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int32_t tag = plc_tag_create(tag_str, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return PLCTAG_ERR_CREATE;",
            "     } else {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"INFO: Tag created with status %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error %s setting up tag internal state.\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error %s setting up tag internal state.\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "     return tag;",
            " }",
            " ",
            " ",
            "-",
            "-void *test_tag(void *data)",
            "-{",
            "+void *test_tag(void *data) {",
            "     int tid = (int)(intptr_t)data;",
            "     int iteration = 1;",
            " ",
            "     while(!done) {",
            "         int rc = PLCTAG_STATUS_OK;",
            "         int32_t value = 0;",
            "         int64_t start = 0;",
            "         int64_t end = 0;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         /* read the tag */",
            "         rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            fprintf(stderr,\"Test %d, terminating test, read resulted in error %s\\n\", tid, plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Test %d, terminating test, read resulted in error %s\\n\", tid, plc_tag_decode_error(rc));",
            "             done = 1;",
            "         } else {",
            "-            value = plc_tag_get_int32(tag,0);",
            "+            value = plc_tag_get_int32(tag, 0);",
            " ",
            "             /* increment the value, keep it in bounds of 0-499 */",
            "             value = (value >= (int32_t)500 ? (int32_t)0 : value + (int32_t)1);",
            " ",
            "             /* yes, we should be checking this return value too... */",
            "             plc_tag_set_int32(tag, 0, value);",
            " ",
            "             /* write the value */",
            "             rc = plc_tag_write(tag, DATA_TIMEOUT);",
            " ",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "-                fprintf(stderr,\"Test %d, terminating test, write resulted in error %s\\n\", tid, plc_tag_decode_error(rc));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Test %d, terminating test, write resulted in error %s\\n\", tid, plc_tag_decode_error(rc));",
            "                 done = 1;",
            "             } else {",
            "-                fprintf(stderr,\"Test %d, iteration %d, got result %d with return code %s in %dms\\n\",tid, iteration, value, plc_tag_decode_error(rc), (int)(end-start));",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(stderr, \"Test %d, iteration %d, got result %d with return code %s in %dms\\n\", tid, iteration, value,",
            "+                        plc_tag_decode_error(rc), (int)(end - start));",
            "             }",
            "         }",
            " ",
            "         iteration++;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Test %d terminating.\\n\", tid);",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-",
            " #define MAX_THREADS (100)",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "-    pthread_t threads[MAX_THREADS];",
            "+int main(int argc, char **argv) {",
            "+    compat_thread_t threads[MAX_THREADS];",
            "     int64_t start_time;",
            "     int64_t end_time;",
            "-    int64_t seconds = 30;  /* default 30 seconds */",
            "+    int64_t seconds = 30; /* default 30 seconds */",
            "     int num_threads = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "-    if(argc==2) {",
            "+    if(argc == 2) {",
            "         num_threads = atoi(argv[1]);",
            "     } else {",
            "-        fprintf(stderr,\"Usage: stress_api_lock <num threads>\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Usage: stress_api_lock <num threads>\\n\");",
            "         return 0;",
            "     }",
            " ",
            "     tag = open_tag(TAG_PATH);",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"Unable to create tag! %s\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to create tag! %s\\n\", plc_tag_decode_error(tag));",
            "         return 1;",
            "     }",
            " ",
            "     /* create the test threads */",
            "-    for(int tid=0; tid < num_threads  && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Creating serial test thread (Test #%d).\\n\", tid);",
            "-        pthread_create(&threads[tid], NULL, &test_tag, (void *)(intptr_t)tid);",
            "+        compat_thread_create(&threads[tid], test_tag, (void *)(intptr_t)tid);",
            "     }",
            " ",
            "-    start_time = util_time_ms();",
            "+    start_time = compat_time_ms();",
            "     end_time = start_time + (seconds * 1000);",
            " ",
            "-    while(!done && util_time_ms() < end_time) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(!done && compat_time_ms() < end_time) { compat_sleep_ms(100, NULL); }",
            " ",
            "     if(done) {",
            "-        fprintf(stderr,\"Test FAILED!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Test FAILED!\\n\");",
            "     } else {",
            "-        fprintf(stderr,\"Test SUCCEEDED!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Test SUCCEEDED!\\n\");",
            "     }",
            " ",
            "     done = 1;",
            " ",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-        pthread_join(threads[tid], NULL);",
            "-    }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) { compat_thread_join(threads[tid], NULL); }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"All test threads terminated.\\n\");",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/stress_test.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/stress_test.c",
            "+++ /home/libplctag-2.6.7/src/examples/stress_test.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,298 +28,296 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <signal.h>",
            "+#include <stdint.h>",
            " #include <stdio.h>",
            "-#include <unistd.h>",
            " #include <stdlib.h>",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            " #include <string.h>",
            "-#include <sys/time.h>",
            "-#include <signal.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 6, 4",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=TestDINTArray[%d]&debug=3\"",
            " ",
            " #define DATA_TIMEOUT (2000)",
            " #define TAG_CREATE_TIMEOUT (5000)",
            " #define RETRY_TIMEOUT (10000)",
            " ",
            " ",
            "-",
            " /*",
            "  * This test program creates a lot of threads that read the same tag in",
            "  * the plc.  They all hit the exact same underlying tag data structure.",
            "  * This tests, to some extent, whether the library can handle multi-threaded",
            "  * access.",
            "  */",
            " ",
            " ",
            "-",
            " typedef struct {",
            "     int tid;",
            "     int num_elems;",
            " } thread_args;",
            " ",
            " ",
            " /* global to cheat on passing it to threads. */",
            " volatile int done = 0;",
            " ",
            " ",
            "-static FILE *open_log(int tid)",
            "-{",
            "-    char buf[60] = {0,};",
            "+static FILE *open_log(int tid) {",
            "+    char buf[60] = {",
            "+        0,",
            "+    };",
            " ",
            "-    snprintf(buf, sizeof(buf), \"test-%d.log\", tid);",
            "+    // NOLINTNEXTLINE",
            "+    snprintf(buf, sizeof(buf), \"stress-test-%d.log\", tid);",
            " ",
            "-    return fopen(buf,\"w\");",
            "+    return fopen(buf, \"w\");",
            " }",
            " ",
            "-static void close_log(FILE *log)",
            "-{",
            "+static void close_log(FILE *log) {",
            "     fflush(log);",
            "     fclose(log);",
            " }",
            " ",
            " ",
            "-static int wait_ms(int timeout_ms)",
            "-{",
            "+static int wait_ms(int timeout_ms) {",
            "     int64_t timeout = 0;",
            " ",
            "-    timeout = util_time_ms() + timeout_ms;",
            "-    while(!done && timeout > util_time_ms()) {",
            "-        util_sleep_ms(5);",
            "-    }",
            "+    timeout = compat_time_ms() + timeout_ms;",
            "+    while(!done && timeout > compat_time_ms()) { compat_sleep_ms(5, NULL); }",
            " ",
            "     if(!done) {",
            "         return PLCTAG_STATUS_OK;",
            "     } else {",
            "         return PLCTAG_ERR_ABORT;",
            "     }",
            " }",
            " ",
            " ",
            "-static int32_t open_tag(FILE *log, int tid, int num_elems)",
            "-{",
            "+static int32_t open_tag(FILE *log, int tid, int num_elems) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    static const char *tag_str = \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=4&elem_count=%d&name=TestBigArray[%d]&debug=4\";",
            "-    char buf[250] = {0,};",
            "+    static const char *tag_str =",
            "+        \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=lgx&elem_size=4&elem_count=%d&name=TestBigArray[%d]&debug=4\";",
            "+    char buf[250] = {",
            "+        0,",
            "+    };",
            "     int32_t tag = 0;",
            " ",
            "-    snprintf(buf, sizeof(buf), tag_str, num_elems, (tid-1)*num_elems);",
            "+    // NOLINTNEXTLINE",
            "+    snprintf(buf, sizeof(buf), tag_str, num_elems, (tid - 1) * num_elems);",
            " ",
            "-    fprintf(log,\"--- Test %d, Creating tag (%d, %d) with string %s\\n\", tid, tid, num_elems, buf);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(log, \"--- Test %d, Creating tag (%d, %d) with string %s\\n\", tid, tid, num_elems, buf);",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(buf, TAG_CREATE_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(log,\"!!! Test %d, could not create tag. error %s!\\n\", tid, plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(log, \"!!! Test %d, could not create tag. error %s!\\n\", tid, plc_tag_decode_error(tag));",
            "         return tag;",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(log,\"!!! Test %d, error %s setting up tag internal state.\\n\", tid, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(log, \"!!! Test %d, error %s setting up tag internal state.\\n\", tid, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "     return tag;",
            " }",
            " ",
            " ",
            "-static void *test_cip(void *data)",
            "-{",
            "+static void *test_cip(void *data) {",
            "     thread_args *args = (thread_args *)data;",
            "     int tid = args->tid;",
            "     int num_elems = args->num_elems;",
            "     int32_t value = 0;",
            "     int64_t total_io_time = 0;",
            "     int32_t tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int iteration = 1;",
            "     int first_time = 1;",
            "     FILE *log = NULL;",
            "-    int start_index = (tid-1)*num_elems;",
            "+    int start_index = (tid - 1) * num_elems;",
            " ",
            "     /* a hack to allow threads to start. */",
            "-    util_sleep_ms(tid);",
            "+    compat_sleep_ms((uint32_t)tid, NULL);",
            " ",
            "     log = open_log(tid);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"--- Test %d updating %d elements starting at index %d.\\n\", tid, num_elems, start_index);",
            "+    // NOLINTNEXTLINE",
            "     fprintf(log, \"--- Test %d updating %d elements starting at index %d.\\n\", tid, num_elems, start_index);",
            " ",
            "     while(!done) {",
            "         int64_t start = 0;",
            "         int64_t end = 0;",
            " ",
            "         while(tag <= 0 && !done) {",
            "-            if(!first_time) {",
            "-                wait_ms(RETRY_TIMEOUT);",
            "-            }",
            "+            if(!first_time) { wait_ms(RETRY_TIMEOUT); }",
            " ",
            "             first_time = 0;",
            " ",
            "             tag = open_tag(log, tid, num_elems);",
            "             if(tag < 0) {",
            "-                fprintf(log,\"!!! Test %d, iteration %d, Error (%s) creating tag!  Retrying in %dms.\", tid, iteration, plc_tag_decode_error(tag), RETRY_TIMEOUT);",
            "+                // NOLINTNEXTLINE",
            "+                fprintf(log, \"!!! Test %d, iteration %d, Error (%s) creating tag!  Retrying in %dms.\", tid, iteration,",
            "+                        plc_tag_decode_error(tag), RETRY_TIMEOUT);",
            "             }",
            "         }",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         do {",
            "             rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(log, \"!!! Test %d, iteration %d, read failed with error %s\\n\", tid, iteration, plc_tag_decode_error(rc));",
            "                 break;",
            "             }",
            " ",
            "-            for(int i=0; i < num_elems; i++) {",
            "-                value = plc_tag_get_int32(tag,i*4);",
            "+            for(int i = 0; i < num_elems; i++) {",
            "+                value = plc_tag_get_int32(tag, i * 4);",
            " ",
            "                 /* increment the value, keep it in bounds of 0-499 */",
            "                 value = (value >= (int32_t)500 ? (int32_t)0 : value + (int32_t)1);",
            " ",
            "                 /* yes, we should be checking this return value too... */",
            "-                plc_tag_set_int32(tag, i*4, value);",
            "+                plc_tag_set_int32(tag, i * 4, value);",
            "             }",
            " ",
            "             /* write the value */",
            "             rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(log, \"!!! Test %d, iteration %d, write failed with error %s\\n\", tid, iteration, plc_tag_decode_error(rc));",
            "                 break;",
            "             }",
            "         } while(0);",
            " ",
            "-        end = util_time_ms();",
            "+        end = compat_time_ms();",
            " ",
            "         total_io_time += (end - start);",
            " ",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            fprintf(log,\"!!! Test %d, iteration %d, error %s, will retry in %dms.\\n\", tid, iteration, plc_tag_decode_error(rc), RETRY_TIMEOUT);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(log, \"!!! Test %d, iteration %d, error %s, will retry in %dms.\\n\", tid, iteration, plc_tag_decode_error(rc),",
            "+                    RETRY_TIMEOUT);",
            " ",
            "             wait_ms(RETRY_TIMEOUT);",
            "         } else {",
            "-            fprintf(log, \"*** Test %d, iteration %d updated %d elements in %dms.\\n\", tid, iteration, num_elems, (int)(end-start));",
            "-            util_sleep_ms(1);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(log, \"*** Test %d, iteration %d updated %d elements in %dms.\\n\", tid, iteration, num_elems,",
            "+                    (int)(end - start));",
            "+            compat_sleep_ms(10, NULL);",
            "         }",
            " ",
            "         iteration++;",
            "     }",
            " ",
            "-    if(tag > 0) {",
            "-        plc_tag_destroy(tag);",
            "-        tag = 0;",
            "-    }",
            "+    if(tag > 0) { plc_tag_destroy(tag); }",
            " ",
            "-    fprintf(log, \"*** Test %d terminating after %d iterations and an average of %dms per iteration.\\n\", tid, iteration, (int)(total_io_time/iteration));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(log, \"*** Test %d terminating after %d iterations and an average of %dms per iteration.\\n\", tid, iteration,",
            "+            (int)(total_io_time / iteration));",
            " ",
            "     close_log(log);",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-",
            "-void sigpipe_handler(int unused)",
            "-{",
            "-    (void)unused;",
            "-    done = 1;",
            "-}",
            "-",
            "+static void interrupt_handler(void) { done = 1; }",
            " ",
            " ",
            " #define MAX_THREADS (100)",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "-    pthread_t threads[MAX_THREADS];",
            "+int main(int argc, char **argv) {",
            "+    compat_thread_t threads[MAX_THREADS];",
            "     int64_t start_time;",
            "     int64_t end_time;",
            "     int num_threads = 0;",
            "     int seconds = 0;",
            "     int num_elems = 0;",
            "     int success = 0;",
            "     thread_args args[MAX_THREADS];",
            "-    struct sigaction sigpipe;",
            " ",
            "-    memset(&sigpipe, 0, sizeof(sigpipe));",
            "-",
            "-    sigpipe.sa_handler = sigpipe_handler;",
            "+    compat_set_interrupt_handler(interrupt_handler);",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "-    /* catch broken pipe signals */",
            "-    sigaction(SIGPIPE, &sigpipe, NULL);",
            "-",
            "     if(argc == 4) {",
            "         num_threads = atoi(argv[1]);",
            "         num_elems = atoi(argv[2]);",
            "         seconds = atoi(argv[3]);",
            "     } else {",
            "-        fprintf(stderr,\"Usage: stress_test <num threads> <elements per thread> <seconds to run>\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Usage: stress_test <num threads> <elements per thread> <seconds to run>\\n\");",
            "         return 1;",
            "     }",
            " ",
            "     if(num_threads > MAX_THREADS) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Too many threads.  A maximum of %d threads are supported.\\n\", MAX_THREADS);",
            "         return 1;",
            "     }",
            " ",
            "     if(num_threads * num_elems > 1000) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"#threads * #elems must be less than 1000.\\n\");",
            "         return 1;",
            "     }",
            " ",
            "-    fprintf(stderr, \"--- starting run with %d threads each handling %d elements running for %d seconds\\n\", num_threads, num_elems, seconds);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"--- starting run with %d threads each handling %d elements running for %d seconds\\n\", num_threads, num_elems,",
            "+            seconds);",
            " ",
            "     /* create the test threads */",
            "-    for(int tid=0; tid < num_threads  && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "         args[tid].tid = num_threads - tid;",
            "         args[tid].num_elems = num_elems;",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"--- Creating serial test thread %d with %d elements.\\n\", args[tid].tid, args[tid].num_elems);",
            " ",
            "-        pthread_create(&threads[tid], NULL, &test_cip, &args[tid]);",
            "+        compat_thread_create(&threads[tid], test_cip, &args[tid]);",
            "     }",
            " ",
            "-    start_time = util_time_ms();",
            "+    start_time = compat_time_ms();",
            "     end_time = start_time + (int64_t)(seconds * 1000);",
            " ",
            "-    while(!done && util_time_ms() < end_time) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(!done && compat_time_ms() < end_time) { compat_sleep_ms(100, NULL); }",
            " ",
            "     success = !done;",
            " ",
            "     done = 1;",
            " ",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-        pthread_join(threads[tid], NULL);",
            "-    }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) { compat_thread_join(threads[tid], NULL); }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"--- All test threads terminated.\\n\");",
            " ",
            "     if(!success) {",
            "-        fprintf(stderr,\"*** Test FAILED!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"*** Test FAILED!\\n\");",
            "     } else {",
            "-        fprintf(stderr,\"*** Test SUCCEEDED!\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"*** Test SUCCEEDED!\\n\");",
            "     }",
            " ",
            "     return 0;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/string_non_standard_udt.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/string_non_standard_udt.c",
            "+++ /home/libplctag-2.6.7/src/examples/string_non_standard_udt.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2022 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,19 +28,19 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " /*",
            " ",
            " This example shows how to access non-standard strings for which you are using a user-defined UDT.   This UDT",
            " must have roughly the same definition as a string, with different lengths.",
            " ",
            " In this example, we want to read an array of user-defined string-like UDTs.  The array is defined as:",
            "@@ -73,55 +73,57 @@",
            " We add these to the tag string that was constructed by the tag listing program:",
            " ",
            " \"protocol=ab-eip&gateway=10.206.1.39&path=1,0&plc=ControlLogix&elem_size=20&elem_count=228&name=CB_Rpt&str_count_word_bytes=4&str_is_byte_swapped=0&str_is_counted=1&str_is_fixed_length=1&str_is_zero_terminated=0&str_max_capacity=16&str_pad_bytes=0&str_total_length=20\"",
            " ",
            " */",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,2,0",
            "+#define REQUIRED_VERSION 2, 2, 0",
            " ",
            "-static const char *tag_string = \"protocol=ab-eip&gateway=10.206.1.39&path=1,0&plc=ControlLogix&elem_size=20&elem_count=228&name=CB_Rpt&str_count_word_bytes=4&str_is_byte_swapped=0&str_is_counted=1&str_is_fixed_length=1&str_is_zero_terminated=0&str_max_capacity=16&str_pad_bytes=0&str_total_length=20\";",
            "+static const char *tag_string =",
            "+    \"protocol=ab-eip&gateway=10.206.1.39&path=1,0&plc=ControlLogix&elem_size=20&elem_count=228&name=CB_Rpt&str_count_word_bytes=4&str_is_byte_swapped=0&str_is_counted=1&str_is_fixed_length=1&str_is_zero_terminated=0&str_max_capacity=16&str_pad_bytes=0&str_total_length=20\";",
            " ",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int str_num = 1;",
            "     int offset = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         return 1;",
            "     }",
            " ",
            "-    fprintf(stderr, \"Using library version %d.%d.%d.\\n\",",
            "-                                            plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_minor\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Using library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "+            plc_tag_get_int_attribute(0, \"version_minor\", -1), plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            " ",
            "     /* turn off debugging output. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "     tag = plc_tag_create(tag_string, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error creating tag! Error %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error creating tag! Error %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data for tag! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data for tag! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "     /* print out the data */",
            "     offset = 0;",
            "     str_num = 1;",
            "@@ -132,28 +134,31 @@",
            "     while(offset < plc_tag_get_size(tag)) {",
            "         char *str = NULL;",
            "         int str_size = plc_tag_get_string_length(tag, offset);",
            "         int str_buf_size = str_size + 1; /* +1 for the nul termination character. */",
            " ",
            "         str = (char *)malloc((size_t)(unsigned int)str_buf_size);",
            "         if(!str) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unable to allocate memory for the string %d of the tag!\\n\", str_num);",
            "             plc_tag_destroy(tag);",
            "             return PLCTAG_ERR_NO_MEM;",
            "         }",
            " ",
            "         /* read the string into the buffer */",
            "         rc = plc_tag_get_string(tag, offset, str, str_buf_size);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unable to get string %d of tag, got error %s!\\n\", str_num, plc_tag_decode_error(rc));",
            "             free(str);",
            "             plc_tag_destroy(tag);",
            "             return rc;",
            "         }",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"tag string %d (%u chars) = '%s'\\n\", str_num, (unsigned int)strlen(str), str);",
            " ",
            "         free(str);",
            " ",
            "         str_num++;",
            " ",
            "         /* this gets the total length of the string in the buffer, including count word, nul termination, padding etc. */",
            "@@ -161,9 +166,7 @@",
            "     }",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/string_standard.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/string_standard.c",
            "+++ /home/libplctag-2.6.7/src/examples/string_standard.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,19 +28,19 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " /*",
            " ",
            " This example shows the use of standard strings for a ControlLogix and for a PLC-5.   The string definitions are",
            " the standard string types:",
            " ",
            " - for ControlLogix, this is a 4-byte count word followed by 82 bytes of character data followed by 2 bytes of padding.",
            "@@ -56,86 +56,90 @@",
            " ",
            " For PLC-5, SLC 500 and MicroLogix, the defaults here are fine.  For Control/CompactLogix, make sure that you are using",
            " the standard STRING type.   If you are not, this code WILL NOT WORK.",
            " ",
            " */",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,2,0",
            "+#define REQUIRED_VERSION 2, 2, 0",
            " ",
            " static const char *tag_strings[] = {",
            "     \"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&elem_size=88&elem_count=11&name=barcodes\",",
            "-    \"protocol=ab_eip&gateway=10.206.1.38&plc=plc5&elem_count=2&name=ST18:0\"",
            "-};",
            "+    \"protocol=ab_eip&gateway=10.206.1.38&plc=plc5&elem_count=2&name=ST18:0\"};",
            " ",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int str_num = 1;",
            "     int offset = 0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         return 1;",
            "     }",
            " ",
            "-    fprintf(stderr, \"Using library version %d.%d.%d.\\n\",",
            "-                                            plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_minor\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Using library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "+            plc_tag_get_int_attribute(0, \"version_minor\", -1), plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            " ",
            "     /* turn off debugging output. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "     /* loop over the tag strings. */",
            "-    for(int i=0; i < (int)(unsigned int)(sizeof(tag_strings)/sizeof(tag_strings[0])); i++) {",
            "+    for(int i = 0; i < (int)(unsigned int)(sizeof(tag_strings) / sizeof(tag_strings[0])); i++) {",
            "         tag = plc_tag_create(tag_strings[i], DATA_TIMEOUT);",
            " ",
            "         /* everything OK? */",
            "         if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-            fprintf(stderr,\"Error creating tag %d! Error %s\\n\", i, plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error creating tag %d! Error %s\\n\", i, plc_tag_decode_error(rc));",
            "             plc_tag_destroy(tag);",
            "             return rc;",
            "         }",
            " ",
            "         /* get the data */",
            "         rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            fprintf(stderr,\"ERROR: Unable to read the data for tag %d! Got error code %d: %s\\n\", i, rc, plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: Unable to read the data for tag %d! Got error code %d: %s\\n\", i, rc,",
            "+                    plc_tag_decode_error(rc));",
            "             plc_tag_destroy(tag);",
            "             return rc;",
            "         }",
            " ",
            "         /* print out the data */",
            "         offset = 0;",
            "         str_num = 1;",
            "         while(offset < plc_tag_get_size(tag)) {",
            "             char *str = NULL;",
            "             int str_cap = plc_tag_get_string_length(tag, offset) + 1; /* +1 for the zero termination. */",
            " ",
            "             str = malloc((size_t)(unsigned int)str_cap);",
            "             if(!str) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to allocate memory for the string %d of tag %d!\\n\", str_num, i);",
            "                 plc_tag_destroy(tag);",
            "                 return PLCTAG_ERR_NO_MEM;",
            "             }",
            " ",
            "             rc = plc_tag_get_string(tag, offset, str, str_cap);",
            "             if(rc != PLCTAG_STATUS_OK) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to get string %d of tag %d, got error %s!\\n\", str_num, i, plc_tag_decode_error(rc));",
            "                 free(str);",
            "                 plc_tag_destroy(tag);",
            "                 return rc;",
            "             }",
            " ",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"tag %d string %d (%u chars) = '%s'\\n\", i, str_num, (unsigned int)strlen(str), str);",
            " ",
            "             free(str);",
            " ",
            "             str_num++;",
            " ",
            "             offset += plc_tag_get_string_total_length(tag, offset);",
            "@@ -143,9 +147,7 @@",
            " ",
            "         /* we are done */",
            "         plc_tag_destroy(tag);",
            "     }",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/tag_rw2.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/tag_rw2.c",
            "+++ /home/libplctag-2.6.7/src/examples/tag_rw2.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,28 +28,40 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            " #include <ctype.h>",
            " #include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdarg.h>",
            " #include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include <time.h>",
            "-#include <stdarg.h>",
            " #include <string.h>",
            "-#include <lib/libplctag.h>",
            "-#include \"utils.h\"",
            "+#include <time.h>",
            " ",
            " typedef enum {",
            "-    TYPE_BIT, TYPE_I8, TYPE_U8, TYPE_I16, TYPE_U16, TYPE_I32, TYPE_U32, TYPE_I64, TYPE_U64,",
            "-    TYPE_F32, TYPE_F64, TYPE_STRING, TYPE_META, TYPE_RAW",
            "+    TYPE_BIT,",
            "+    TYPE_I8,",
            "+    TYPE_U8,",
            "+    TYPE_I16,",
            "+    TYPE_U16,",
            "+    TYPE_I32,",
            "+    TYPE_U32,",
            "+    TYPE_I64,",
            "+    TYPE_U64,",
            "+    TYPE_F32,",
            "+    TYPE_F64,",
            "+    TYPE_STRING,",
            "+    TYPE_META,",
            "+    TYPE_RAW",
            " } element_type_t;",
            " ",
            " struct run_args {",
            "     char *tag_string;",
            "     int32_t tag;",
            "     int timeout;",
            "     int debug;",
            "@@ -67,54 +79,50 @@",
            "         float *f32;",
            "         double *f64;",
            "         char **string;",
            "         void *dummy;",
            "     } write_vals;",
            " };",
            " ",
            "-#define REQUIRED_VERSION 2,2,1",
            "+#define REQUIRED_VERSION 2, 2, 1",
            " #define DEFAULT_TIMEOUT (5000)",
            " ",
            " ",
            " static void usage(void);",
            " static void parse_args(int argc, char **argv, struct run_args *args);",
            " static void parse_type(char *type_str, struct run_args *args);",
            " static void parse_write_vals(char *write_vals, struct run_args *args);",
            " static void dump_values(struct run_args *args);",
            " static void cleanup(struct run_args *args);",
            " static void update_values(struct run_args *args);",
            " ",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     struct run_args args;",
            " ",
            "     /* zero out all the bytes of args. */",
            "+    // NOLINTNEXTLINE",
            "     memset(&args, 0, sizeof(args));",
            " ",
            "     /* make sure we have the required library version */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "         printf(\"Library version %d.%d.%d requested, but linked library version is not compatible!\\n\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* output the version we are using. */",
            "-    printf(\"Library version %d.%d.%d.\\n\",",
            "-                            plc_tag_get_int_attribute(0, \"version_major\", 0),",
            "-                            plc_tag_get_int_attribute(0, \"version_minor\", 0),",
            "-                            plc_tag_get_int_attribute(0, \"version_patch\", 0));",
            "+    printf(\"Library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", 0),",
            "+           plc_tag_get_int_attribute(0, \"version_minor\", 0), plc_tag_get_int_attribute(0, \"version_patch\", 0));",
            " ",
            "     /* parse the argument list. */",
            "     parse_args(argc, argv, &args);",
            " ",
            "     /* set the debug level if it was set in the command line parameters. */",
            "-    if(args.debug > 0) {",
            "-        plc_tag_set_debug_level(args.debug);",
            "-    }",
            "+    if(args.debug > 0) { plc_tag_set_debug_level(args.debug); }",
            " ",
            "     /* set up a scope to fake local exceptions. */",
            "     do {",
            "         args.tag = plc_tag_create(args.tag_string, args.timeout);",
            "         if(plc_tag_status(args.tag) != PLCTAG_STATUS_OK) {",
            "             printf(\"ERROR: Error creating tag %s!\\n\", plc_tag_decode_error(args.tag));",
            "             rc = args.tag;",
            "@@ -169,101 +177,99 @@",
            " ",
            "     cleanup(&args);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-void usage(void)",
            "-{",
            "-    printf( \"Usage:\\n \"",
            "-            \"tag_rw2 --type=<type> --tag=<tag string> [--write=<vals>] [--timeout=<timeout>] [--debug=<debug>] \\n\"",
            "-            \"\\n\"",
            "-            \"  <type>    - type is one of 'bit', 'uint8', 'sint8', 'uint16', 'sint16', \\n \"",
            "-            \"              'uint32', 'sint32', 'real32', 'real64', 'string' or 'metadata'.  \\n\"",
            "-            \"              The type is the type of the data to be read/written to the named tag.\\n\"",
            "-            \"              The types starting with 'u' are unsigned and with 's' are signed.\\n\"",
            "-            \"              For floating point, use 'real32' or 'real64'.  The 'metadata' type\\n\"",
            "-            \"              returns information about the raw (device) tag type data, the size of\\n\"",
            "-            \"              a single element and the number of elements that were requested, not the\\n\"",
            "-            \"              actual size of the tag in the device!\\n\"",
            "-            \"\\n\"",
            "-            \"  <tag string> - The path to the device containing the named data.  This value may need to\\n\"",
            "-            \"              be quoted.   Use double quotes on Windows and single quotes on Unix-like systems.\\n\"",
            "-            \"\\n\"",
            "-\t\t\t\"  <vals>    - The value(s) to write.  Must be formatted appropriately\\n\"",
            "-\t\t\t\"              for the data type.  Multiple values are comma separated. Optional.\\n\"",
            "-            \"\\n\"",
            "-            \"  <timeout> - Set the timeout to this number of milliseconds.  Default is 5000.  Optional.\\n\"",
            "-            \"\\n\"",
            "-\t\t\t\"  <debug>   - Set the debug level.   Values 1-5.\\n\"",
            "-\t\t\t\"              1 - output debug info only on fatal errors.\\n\"",
            "-\t\t\t\"              2 - output debug info for warnings and errors.\\n\"",
            "-\t\t\t\"              3 - output debug info for informative messages, warnings and errors.\\n\"",
            "-\t\t\t\"              4 - output debug info for detailed status messages, informative messages, warnings and errors.\\n\"",
            "-\t\t\t\"              5 - turn on all debugging output.  Not recommended.\\n\"",
            "-\t\t\t\"              This field is optional.\\n\"",
            "-\t\t\t\"\\n\"",
            "-            \"Example: tag_rw2 --type=uint32 '--tag=protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=ControlLogix&elem_count=2&name=pcomm_test_dint_array' --debug=4 --write=12,34 --timeout=1000\\n\"",
            "-            \"Note: Use double quotes \\\"\\\" for the attribute string in Windows.\\n\");",
            "+void usage(void) {",
            "+    printf(",
            "+        \"Usage:\\n \"",
            "+        \"tag_rw2 --type=<type> --tag=<tag string> [--write=<vals>] [--timeout=<timeout>] [--debug=<debug>] \\n\"",
            "+        \"\\n\"",
            "+        \"  <type>    - type is one of 'bit', 'uint8', 'sint8', 'uint16', 'sint16', \\n \"",
            "+        \"              'uint32', 'sint32', 'real32', 'real64', 'string' or 'metadata'.  \\n\"",
            "+        \"              The type is the type of the data to be read/written to the named tag.\\n\"",
            "+        \"              The types starting with 'u' are unsigned and with 's' are signed.\\n\"",
            "+        \"              For floating point, use 'real32' or 'real64'.  The 'metadata' type\\n\"",
            "+        \"              returns information about the raw (device) tag type data, the size of\\n\"",
            "+        \"              a single element and the number of elements that were requested, not the\\n\"",
            "+        \"              actual size of the tag in the device!\\n\"",
            "+        \"\\n\"",
            "+        \"  <tag string> - The path to the device containing the named data.  This value may need to\\n\"",
            "+        \"              be quoted.   Use double quotes on Windows and single quotes on Unix-like systems.\\n\"",
            "+        \"\\n\"",
            "+        \"  <vals>    - The value(s) to write.  Must be formatted appropriately\\n\"",
            "+        \"              for the data type.  Multiple values are comma separated. Optional.\\n\"",
            "+        \"\\n\"",
            "+        \"  <timeout> - Set the timeout to this number of milliseconds.  Default is 5000.  Optional.\\n\"",
            "+        \"\\n\"",
            "+        \"  <debug>   - Set the debug level.   Values 1-5.\\n\"",
            "+        \"              1 - output debug info only on fatal errors.\\n\"",
            "+        \"              2 - output debug info for warnings and errors.\\n\"",
            "+        \"              3 - output debug info for informative messages, warnings and errors.\\n\"",
            "+        \"              4 - output debug info for detailed status messages, informative messages, warnings and errors.\\n\"",
            "+        \"              5 - turn on all debugging output.  Not recommended.\\n\"",
            "+        \"              This field is optional.\\n\"",
            "+        \"\\n\"",
            "+        \"Example: tag_rw2 --type=uint32 '--tag=protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=ControlLogix&elem_count=2&name=pcomm_test_dint_array' --debug=4 --write=12,34 --timeout=1000\\n\"",
            "+        \"Note: Use double quotes \\\"\\\" for the attribute string in Windows.\\n\");",
            " ",
            "     exit(1);",
            " }",
            " ",
            " ",
            "-void parse_args(int argc, char **argv, struct run_args *args)",
            "-{",
            "+void parse_args(int argc, char **argv, struct run_args *args) {",
            "     int i = 0;",
            "     bool has_type = false;",
            "     bool has_tag = false;",
            "     bool has_debug = false;",
            "     bool has_timeout = false;",
            "     bool has_write_vals = false;",
            "     char *write_vals = NULL;",
            " ",
            "     /* argv[0] is the tag_rw2 command itself. */",
            "     for(i = 1; i < argc; i++) {",
            " ",
            "         /* DEBUG */",
            "         printf(\"Processing argument %d \\\"%s\\\".\\n\", i, argv[i]);",
            " ",
            "-        if(strncmp(argv[i],\"--type=\", 7) == 0) {",
            "+        if(strncmp(argv[i], \"--type=\", 7) == 0) {",
            "             /* type argument. */",
            " ",
            "             if(has_type) {",
            "                 printf(\"ERROR: The type argument can only appear once!\\n\");",
            "                 cleanup(args);",
            "                 usage();",
            "             }",
            " ",
            "             has_type = true;",
            " ",
            "             parse_type(&(argv[i][7]), args);",
            "-        } else if(strncmp(argv[i],\"--tag=\", 6) == 0) {",
            "+        } else if(strncmp(argv[i], \"--tag=\", 6) == 0) {",
            "             if(has_tag) {",
            "                 printf(\"ERROR: Only one tag argument may be present!\\n\");",
            "                 cleanup(args);",
            "                 usage();",
            "             }",
            " ",
            "             args->tag_string = &(argv[i][6]);",
            " ",
            "             has_tag = true;",
            "-        } else if(strncmp(argv[i],\"--debug=\", 8) == 0) {",
            "+        } else if(strncmp(argv[i], \"--debug=\", 8) == 0) {",
            "             if(has_debug) {",
            "                 printf(\"ERROR: Only one debug argument may be present!\\n\");",
            "                 cleanup(args);",
            "                 usage();",
            "             }",
            " ",
            "             args->debug = atoi(&(argv[i][8]));",
            " ",
            "             has_debug = true;",
            "-        } else if(strncmp(argv[i],\"--timeout=\", 10) == 0) {",
            "+        } else if(strncmp(argv[i], \"--timeout=\", 10) == 0) {",
            "             if(has_timeout) {",
            "                 printf(\"ERROR: Only one timeout argument may be present!\\n\");",
            "                 cleanup(args);",
            "                 usage();",
            "             }",
            " ",
            "             args->timeout = atoi(&(argv[i][10]));",
            "@@ -271,15 +277,15 @@",
            "             if(args->timeout <= 0) {",
            "                 printf(\"ERROR: timeout value must be greater than zero and is in milliseconds!\\n\");",
            "                 cleanup(args);",
            "                 usage();",
            "             }",
            " ",
            "             has_timeout = true;",
            "-        } else if(strncmp(argv[i],\"--write=\", 8) == 0) {",
            "+        } else if(strncmp(argv[i], \"--write=\", 8) == 0) {",
            "             if(has_write_vals) {",
            "                 printf(\"ERROR: Only one write value(s) argument may be present!\\n\");",
            "                 cleanup(args);",
            "                 usage();",
            "             }",
            " ",
            "             write_vals = &(argv[i][8]);",
            "@@ -299,21 +305,17 @@",
            " ",
            "     if(!has_type) {",
            "         printf(\"ERROR: you must have a type argument!\\n\");",
            "         cleanup(args);",
            "         usage();",
            "     }",
            " ",
            "-    if(!has_debug) {",
            "-        args->debug = 0;",
            "-    }",
            "+    if(!has_debug) { args->debug = 0; }",
            " ",
            "-    if(!has_timeout) {",
            "-        args->timeout = DEFAULT_TIMEOUT;",
            "-    }",
            "+    if(!has_timeout) { args->timeout = DEFAULT_TIMEOUT; }",
            " ",
            "     /* handle any write arguments */",
            "     if(has_write_vals) {",
            "         parse_write_vals(write_vals, args);",
            "     } else {",
            "         args->write_val_count = 0;",
            "     }",
            "@@ -323,59 +325,56 @@",
            "         printf(\"ERROR: You may not treat a bit tag as an array!\\n\");",
            "         cleanup(args);",
            "         usage();",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-void parse_type(char *type_str, struct run_args *args)",
            "-{",
            "-    if(strcasecmp(type_str, \"bit\") == 0) {",
            "+void parse_type(char *type_str, struct run_args *args) {",
            "+    if(compat_strcasecmp(type_str, \"bit\") == 0) {",
            "         args->element_type = TYPE_BIT;",
            "-    } else if(strcasecmp(type_str, \"sint8\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"sint8\") == 0) {",
            "         args->element_type = TYPE_I8;",
            "-    } else if(strcasecmp(type_str, \"uint8\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"uint8\") == 0) {",
            "         args->element_type = TYPE_U8;",
            "-    } else if(strcasecmp(type_str, \"sint16\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"sint16\") == 0) {",
            "         args->element_type = TYPE_I16;",
            "-    } else if(strcasecmp(type_str, \"uint16\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"uint16\") == 0) {",
            "         args->element_type = TYPE_U16;",
            "-    } else if(strcasecmp(type_str, \"sint32\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"sint32\") == 0) {",
            "         args->element_type = TYPE_I32;",
            "-    } else if(strcasecmp(type_str, \"uint32\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"uint32\") == 0) {",
            "         args->element_type = TYPE_U32;",
            "-    } else if(strcasecmp(type_str, \"sint64\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"sint64\") == 0) {",
            "         args->element_type = TYPE_I64;",
            "-    } else if(strcasecmp(type_str, \"uint64\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"uint64\") == 0) {",
            "         args->element_type = TYPE_U64;",
            "-    } else if(strcasecmp(type_str, \"real32\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"real32\") == 0) {",
            "         args->element_type = TYPE_F32;",
            "-    } else if(strcasecmp(type_str, \"real64\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"real64\") == 0) {",
            "         args->element_type = TYPE_F64;",
            "-    } else if(strcasecmp(type_str, \"string\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"string\") == 0) {",
            " ",
            "         /* DEBUG */",
            "         printf(\"Setting type to TYPE_STRING.\\n\");",
            " ",
            "         args->element_type = TYPE_STRING;",
            "-    } else if(strcasecmp(type_str, \"metadata\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"metadata\") == 0) {",
            "         args->element_type = TYPE_META;",
            "-    } else if(strcasecmp(type_str, \"raw\") == 0) {",
            "+    } else if(compat_strcasecmp(type_str, \"raw\") == 0) {",
            "         args->element_type = TYPE_RAW;",
            "     } else {",
            "         printf(\"ERROR: Unknown type %s!\\n\", type_str);",
            "         cleanup(args);",
            "         usage();",
            "     }",
            " }",
            " ",
            " ",
            "-void parse_write_vals(char *write_vals, struct run_args *args)",
            "-{",
            "+void parse_write_vals(char *write_vals, struct run_args *args) {",
            "     int num_vals = 0;",
            "     int len = 0;",
            "     int val_start = -1;",
            "     int elem_index = 0;",
            "     char *tmp_vals = NULL;",
            " ",
            "     /* check the value string */",
            "@@ -401,17 +400,15 @@",
            "     val_start = -1;",
            "     for(int i = 0; i < len; i++) {",
            "         if(tmp_vals[i] == ',') {",
            "             num_vals++;",
            "             tmp_vals[i] = 0; /* terminate that value string */",
            "         } else {",
            "             /* see if we have noted the first part of the string. */",
            "-            if(val_start == -1) {",
            "-                val_start = i;",
            "-            }",
            "+            if(val_start == -1) { val_start = i; }",
            "         }",
            "     }",
            " ",
            "     /* DEBUG */",
            "     printf(\"Number of write args %d.\\n\", num_vals);",
            " ",
            "     args->write_val_count = num_vals;",
            "@@ -426,310 +423,301 @@",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "                     if(args->element_type != TYPE_RAW) {",
            "-                        if(sscanf_platform(&(tmp_vals[val_start]), \"%\" SCNu8 \"\", &(args->write_vals.u8[elem_index])) != 1) {",
            "+                        // NOLINTNEXTLINE",
            "+                        if(compat_sscanf(&(tmp_vals[val_start]), \"%\" SCNu8 \"\", &(args->write_vals.u8[elem_index])) != 1) {",
            "                             printf(\"ERROR: bad format for unsigned 8-bit integer for write value.\\n\");",
            "                             cleanup(args);",
            "                             usage();",
            "                         }",
            "                     } else {",
            "-                        if(sscanf_platform(&(tmp_vals[val_start]), \"%\" SCNx8 \"\", &(args->write_vals.u8[elem_index])) != 1) {",
            "+                        // NOLINTNEXTLINE",
            "+                        if(compat_sscanf(&(tmp_vals[val_start]), \"%\" SCNx8 \"\", &(args->write_vals.u8[elem_index])) != 1) {",
            "                             printf(\"ERROR: bad format for unsigned 8-bit integer for write value.\\n\");",
            "                             cleanup(args);",
            "                             usage();",
            "                         }",
            "                         // FIXME",
            "                         printf(\"Got hex %x\\n\", args->write_vals.u8[elem_index]);",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_I8:",
            "             args->write_vals.i8 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(int8_t));",
            "             if(!args->write_vals.i8) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&tmp_vals[val_start], \"%\" SCNd8 \"\", &(args->write_vals.i8[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&tmp_vals[val_start], \"%\" SCNd8 \"\", &(args->write_vals.i8[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for signed 8-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_U16:",
            "             args->write_vals.u16 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(uint16_t));",
            "             if(!args->write_vals.u16) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&(tmp_vals[val_start]), \"%\" SCNu16 \"\", &(args->write_vals.u16[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&(tmp_vals[val_start]), \"%\" SCNu16 \"\", &(args->write_vals.u16[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for unsigned 16-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_I16:",
            "             args->write_vals.i16 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(int16_t));",
            "             if(!args->write_vals.i16) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&tmp_vals[val_start], \"%\" SCNd16 \"\", &(args->write_vals.i16[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&tmp_vals[val_start], \"%\" SCNd16 \"\", &(args->write_vals.i16[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for signed 16-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_U32:",
            "             args->write_vals.u32 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(uint32_t));",
            "             if(!args->write_vals.u32) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&(tmp_vals[val_start]), \"%\" SCNu32 \"\", &(args->write_vals.u32[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&(tmp_vals[val_start]), \"%\" SCNu32 \"\", &(args->write_vals.u32[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for unsigned 32-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_I32:",
            "             args->write_vals.i32 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(int32_t));",
            "             if(!args->write_vals.i32) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&tmp_vals[val_start], \"%\" SCNd32 \"\", &(args->write_vals.i32[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&tmp_vals[val_start], \"%\" SCNd32 \"\", &(args->write_vals.i32[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for signed 32-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_U64:",
            "             args->write_vals.u64 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(uint64_t));",
            "             if(!args->write_vals.u64) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&(tmp_vals[val_start]), \"%\" SCNu64 \"\", &(args->write_vals.u64[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&(tmp_vals[val_start]), \"%\" SCNu64 \"\", &(args->write_vals.u64[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for unsigned 64-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_I64:",
            "             args->write_vals.i64 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(int64_t));",
            "             if(!args->write_vals.i64) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&tmp_vals[val_start], \"%\" SCNd64 \"\", &(args->write_vals.i64[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&tmp_vals[val_start], \"%\" SCNd64 \"\", &(args->write_vals.i64[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for signed 64-bit integer for write value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_F32:",
            "             args->write_vals.f32 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(float));",
            "             if(!args->write_vals.f32) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&(tmp_vals[val_start]), \"%f\", &(args->write_vals.f32[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&(tmp_vals[val_start]), \"%f\", &(args->write_vals.f32[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for 32-bit floating point value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_F64:",
            "             args->write_vals.f64 = calloc((size_t)(unsigned int)args->write_val_count, sizeof(double));",
            "             if(!args->write_vals.f64) {",
            "                 printf(\"ERROR: Unable to allocate value array for write values!\");",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "-                    if(sscanf_platform(&tmp_vals[val_start], \"%lf\", &(args->write_vals.f64[elem_index])) != 1) {",
            "+                    // NOLINTNEXTLINE",
            "+                    if(compat_sscanf(&tmp_vals[val_start], \"%lf\", &(args->write_vals.f64[elem_index])) != 1) {",
            "                         printf(\"ERROR: bad format for 64-bit floating point value.\\n\");",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_STRING:",
            "             args->write_vals.string = calloc((size_t)(unsigned int)args->write_val_count, sizeof(char *));",
            "             if(!args->write_vals.string) {",
            "@@ -737,30 +725,28 @@",
            "                 cleanup(args);",
            "                 exit(1);",
            "             }",
            " ",
            "             /* go through the strings. */",
            "             val_start = -1;",
            "             elem_index = 0;",
            "-            for(int i=0; i < len; i++) {",
            "+            for(int i = 0; i < len; i++) {",
            "                 if(val_start == -1 && tmp_vals[i] != 0) {",
            "                     val_start = i;",
            " ",
            "                     if((args->write_vals.string[elem_index] = strdup(&tmp_vals[val_start])) == NULL) {",
            "                         printf(\"ERROR: Unable to allocate string copy for write argument %d!\\n\", elem_index);",
            "                         cleanup(args);",
            "                         usage();",
            "                     }",
            " ",
            "                     elem_index++;",
            "                 }",
            " ",
            "-                if(tmp_vals[i] == 0) {",
            "-                    val_start = -1;",
            "-                }",
            "+                if(tmp_vals[i] == 0) { val_start = -1; }",
            "             }",
            " ",
            "             break;",
            " ",
            "         case TYPE_META:",
            "             printf(\"ERROR: Cannot write tag metadata!\\n\");",
            "             cleanup(args);",
            "@@ -771,32 +757,28 @@",
            "         default:",
            "             printf(\"ERROR: Unknown data type (%d)!\\n\", args->element_type);",
            "             cleanup(args);",
            "             usage();",
            "             break;",
            "     }",
            " ",
            "-    if(tmp_vals) {",
            "-        free(tmp_vals);",
            "-    }",
            "+    if(tmp_vals) { free(tmp_vals); }",
            " }",
            " ",
            " ",
            "-static int filter_printable_u8_data(uint8_t val)",
            "-{",
            "+static int filter_printable_u8_data(uint8_t val) {",
            "     if(val >= 0x20 && val <= 0x7E) {",
            "         return (int)val;",
            "     } else {",
            "         return (int)' ';",
            "     }",
            " }",
            " ",
            " ",
            "-void dump_values(struct run_args *args)",
            "-{",
            "+void dump_values(struct run_args *args) {",
            "     int item_index = 0;",
            "     int offset = 0;",
            "     int32_t tag = args->tag;",
            "     uint8_t tmp_u8;",
            " ",
            "     /* display the data */",
            "     if(args->element_type == TYPE_BIT) {",
            "@@ -816,118 +798,124 @@",
            "         item_index = 0;",
            "         offset = 0;",
            "         while(offset < len) {",
            "             switch(args->element_type) {",
            "                 case TYPE_RAW:",
            "                 case TYPE_U8:",
            "                     tmp_u8 = plc_tag_get_uint8(tag, offset);",
            "-                    printf(\"data[%d]=%\" PRIu8 \" (0x%02\" PRIx8 \") '%c'\\n\", item_index, tmp_u8, tmp_u8, filter_printable_u8_data(tmp_u8));",
            "+                    printf(\"data[%d]=%\" PRIu8 \" (0x%02\" PRIx8 \") '%c'\\n\", item_index, tmp_u8, tmp_u8,",
            "+                           filter_printable_u8_data(tmp_u8));",
            "                     offset += 1;",
            "                     break;",
            " ",
            "                 case TYPE_U16:",
            "-                    printf(\"data[%d]=%\" PRIu16 \" (0x%04\" PRIx16 \")\\n\", item_index, plc_tag_get_uint16(tag, offset),plc_tag_get_uint16(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRIu16 \" (0x%04\" PRIx16 \")\\n\", item_index, plc_tag_get_uint16(tag, offset),",
            "+                           plc_tag_get_uint16(tag, offset));",
            "                     offset += 2;",
            "                     break;",
            " ",
            "                 case TYPE_U32:",
            "-                    printf(\"data[%d]=%\" PRIu32 \" (0x%08\" PRIx32 \")\\n\",item_index, plc_tag_get_uint32(tag, offset), plc_tag_get_uint32(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRIu32 \" (0x%08\" PRIx32 \")\\n\", item_index, plc_tag_get_uint32(tag, offset),",
            "+                           plc_tag_get_uint32(tag, offset));",
            "                     offset += 4;",
            "                     break;",
            " ",
            "                 case TYPE_U64:",
            "-                    printf(\"data[%d]=%\" PRIu64 \" (0x%016\" PRIx64 \")\\n\", item_index, plc_tag_get_uint64(tag, offset),plc_tag_get_uint64(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRIu64 \" (0x%016\" PRIx64 \")\\n\", item_index, plc_tag_get_uint64(tag, offset),",
            "+                           plc_tag_get_uint64(tag, offset));",
            "                     offset += 8;",
            "                     break;",
            " ",
            "                 case TYPE_I8:",
            "-                    printf(\"data[%d]=%\" PRId8 \" (0x02%\" PRIx8 \")\\n\", item_index, plc_tag_get_int8(tag, offset),plc_tag_get_int8(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRId8 \" (0x02%\" PRIx8 \")\\n\", item_index, plc_tag_get_int8(tag, offset),",
            "+                           plc_tag_get_int8(tag, offset));",
            "                     offset += 1;",
            "                     break;",
            " ",
            "                 case TYPE_I16:",
            "-                    printf(\"data[%d]=%\" PRId16 \" (0x%04\" PRIx16 \")\\n\", item_index, plc_tag_get_int16(tag, offset),plc_tag_get_int16(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRId16 \" (0x%04\" PRIx16 \")\\n\", item_index, plc_tag_get_int16(tag, offset),",
            "+                           plc_tag_get_int16(tag, offset));",
            "                     offset += 2;",
            "                     break;",
            " ",
            "                 case TYPE_I32:",
            "-                    printf(\"data[%d]=%\" PRId32 \" (0x%08\" PRIx32 \")\\n\", item_index, plc_tag_get_int32(tag, offset),plc_tag_get_int32(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRId32 \" (0x%08\" PRIx32 \")\\n\", item_index, plc_tag_get_int32(tag, offset),",
            "+                           plc_tag_get_int32(tag, offset));",
            "                     offset += 4;",
            "                     break;",
            " ",
            "                 case TYPE_I64:",
            "-                    printf(\"data[%d]=%\" PRId64 \" (0x%016\" PRIx64 \")\\n\", item_index, plc_tag_get_int64(tag, offset),plc_tag_get_int64(tag, offset));",
            "+                    printf(\"data[%d]=%\" PRId64 \" (0x%016\" PRIx64 \")\\n\", item_index, plc_tag_get_int64(tag, offset),",
            "+                           plc_tag_get_int64(tag, offset));",
            "                     offset += 8;",
            "                     break;",
            " ",
            "                 case TYPE_F32:",
            "                     printf(\"data[%d]=%f\\n\", item_index, plc_tag_get_float32(tag, offset));",
            "                     offset += 4;",
            "                     break;",
            " ",
            "                 case TYPE_F64:",
            "                     printf(\"data[%d]=%lf\\n\", item_index, plc_tag_get_float64(tag, offset));",
            "                     offset += 8;",
            "                     break;",
            " ",
            "-                case TYPE_STRING:",
            "-                    {",
            "-                        int str_len = plc_tag_get_string_length(tag, offset);",
            "-                        char *str = NULL;",
            "-                        int rc = PLCTAG_STATUS_OK;",
            "-",
            "-                        if(str_len > 0) {",
            "-                            str = calloc((size_t)(unsigned int)(str_len+1), sizeof(char));",
            "-                            if(!str) {",
            "-                                printf(\"ERROR: Unable to allocate temporary buffer to output string!\\n\");",
            "-                                cleanup(args);",
            "-                                exit(1);",
            "-                            }",
            "-",
            "-                            rc = plc_tag_get_string(tag, offset, str, str_len);",
            "-                            if(rc != PLCTAG_STATUS_OK) {",
            "-                                printf(\"ERROR: Unable to get string %d, error: %s!\\n\", item_index, plc_tag_decode_error(rc));",
            "-                                cleanup(args);",
            "-                                exit(1);",
            "-                            }",
            "-",
            "-                            printf(\"data[%d]=\\\"%s\\\"\\n\", item_index, str);",
            "-",
            "-                            free(str);",
            "-                        } else if(str_len == 0) {",
            "-                            printf(\"data[%d]=\\\"\\\"\\n\", item_index);",
            "-                        } else {",
            "-                            printf(\"Error getting string length for item %d!  Got error value %s!\", item_index, plc_tag_decode_error(str_len));",
            "+                case TYPE_STRING: {",
            "+                    int str_len = plc_tag_get_string_length(tag, offset);",
            "+                    char *str = NULL;",
            "+                    int rc = PLCTAG_STATUS_OK;",
            "+",
            "+                    if(str_len > 0) {",
            "+                        str = calloc((size_t)(unsigned int)(str_len + 1), sizeof(char));",
            "+                        if(!str) {",
            "+                            printf(\"ERROR: Unable to allocate temporary buffer to output string!\\n\");",
            "+                            cleanup(args);",
            "+                            exit(1);",
            "+                        }",
            "+",
            "+                        rc = plc_tag_get_string(tag, offset, str, str_len);",
            "+                        if(rc != PLCTAG_STATUS_OK) {",
            "+                            printf(\"ERROR: Unable to get string %d, error: %s!\\n\", item_index, plc_tag_decode_error(rc));",
            "+                            cleanup(args);",
            "+                            exit(1);",
            "                         }",
            "+",
            "+                        printf(\"data[%d]=\\\"%s\\\"\\n\", item_index, str);",
            "+",
            "+                        free(str);",
            "+                    } else if(str_len == 0) {",
            "+                        printf(\"data[%d]=\\\"\\\"\\n\", item_index);",
            "+                    } else {",
            "+                        printf(\"Error getting string length for item %d!  Got error value %s!\", item_index,",
            "+                               plc_tag_decode_error(str_len));",
            "                     }",
            "+                }",
            " ",
            "                     offset += plc_tag_get_string_total_length(tag, offset);",
            " ",
            "                     break;",
            " ",
            "-                case TYPE_META:",
            "-                    {",
            "-                        int element_size = plc_tag_get_int_attribute(tag, \"elem_size\", 0);",
            "-                        int element_count = plc_tag_get_int_attribute(tag, \"elem_count\", 0);",
            "-                        uint8_t tag_type_data[32];",
            "-                        int type_data_size = plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", &tag_type_data[0], (int)(unsigned int)sizeof(tag_type_data));",
            "-",
            "-                        if(type_data_size < 0) {",
            "-                            printf(\"ERROR: error %s getting tag type information!\\n\", plc_tag_decode_error(type_data_size));",
            "-                            cleanup(args);",
            "-                            exit(1);",
            "-                        }",
            "+                case TYPE_META: {",
            "+                    int element_size = plc_tag_get_int_attribute(tag, \"elem_size\", 0);",
            "+                    int element_count = plc_tag_get_int_attribute(tag, \"elem_count\", 0);",
            "+                    uint8_t tag_type_data[32];",
            "+                    int type_data_size = plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", &tag_type_data[0],",
            "+                                                                          (int)(unsigned int)sizeof(tag_type_data));",
            " ",
            "-                        printf(\"Tag raw type data: \");",
            "-                        for(int i=0; i < type_data_size; i++) {",
            "-                            printf(\" 0x%02x\", tag_type_data[i]);",
            "-                        }",
            "-                        printf(\"\\nTag element size: %d\\nTag element count: %d\\n\", element_size, element_count);",
            "+                    if(type_data_size < 0) {",
            "+                        printf(\"ERROR: error %s getting tag type information!\\n\", plc_tag_decode_error(type_data_size));",
            "+                        cleanup(args);",
            "+                        exit(1);",
            "                     }",
            " ",
            "+                    printf(\"Tag raw type data: \");",
            "+                    for(int i = 0; i < type_data_size; i++) { printf(\" 0x%02x\", tag_type_data[i]); }",
            "+                    printf(\"\\nTag element size: %d\\nTag element count: %d\\n\", element_size, element_count);",
            "+                }",
            "+",
            "                     /* skip the whole tag. */",
            "                     offset += plc_tag_get_size(tag);",
            " ",
            "                     break;",
            " ",
            "                 default:",
            "                     printf(\"ERROR: Unsupported tag type %d!\\n\", args->element_type);",
            "@@ -938,22 +926,21 @@",
            " ",
            "             item_index++;",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-void cleanup(struct run_args *args)",
            "-{",
            "+void cleanup(struct run_args *args) {",
            "     plc_tag_destroy(args->tag);",
            "     args->tag = 0;",
            " ",
            "     if(args->write_val_count > 0) {",
            "         if(args->element_type == TYPE_STRING && args->write_vals.string) {",
            "-            for(int i=0; i < args->write_val_count; i++) {",
            "+            for(int i = 0; i < args->write_val_count; i++) {",
            "                 free(args->write_vals.string[i]);",
            "                 args->write_vals.string[i] = NULL;",
            "             }",
            " ",
            "             free(args->write_vals.string);",
            "             args->write_vals.string = NULL;",
            "         } else {",
            "@@ -964,17 +951,15 @@",
            "         }",
            " ",
            "         args->write_val_count = 0;",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-void update_values(struct run_args *args)",
            "-{",
            "+void update_values(struct run_args *args) {",
            "     int item_index = 0;",
            "     int offset = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int32_t tag = args->tag;",
            " ",
            "     /* update the data */",
            "     if(args->element_type == TYPE_BIT) {",
            "@@ -1090,36 +1075,36 @@",
            "                         printf(\"Error returned while trying to write 64-bit floating point value of entry %d!\\n\", item_index);",
            "                         cleanup(args);",
            "                         exit(1);",
            "                     }",
            "                     offset += 8;",
            "                     break;",
            " ",
            "-                case TYPE_STRING:",
            "-                    {",
            "-                        int str_len = (int)(unsigned int)strlen(args->write_vals.string[item_index]);",
            "-                        int str_capacity = plc_tag_get_string_capacity(tag, offset);",
            "-",
            "-                        /* clamp the length. */",
            "-                        if(str_len > str_capacity) {",
            "-                            printf(\"Warning: truncating string %d, \\\"%s\\\", to fit fixed string capacity!\\n\", item_index, args->write_vals.string[item_index]);",
            "-                            str_len = str_capacity;",
            "+                case TYPE_STRING: {",
            "+                    int str_len = (int)(unsigned int)strlen(args->write_vals.string[item_index]);",
            "+                    int str_capacity = plc_tag_get_string_capacity(tag, offset);",
            "+",
            "+                    /* clamp the length. */",
            "+                    if(str_len > str_capacity) {",
            "+                        printf(\"Warning: truncating string %d, \\\"%s\\\", to fit fixed string capacity!\\n\", item_index,",
            "+                               args->write_vals.string[item_index]);",
            "+                        str_len = str_capacity;",
            " ",
            "-                            /* zero terminate it at the new shorter length */",
            "-                            args->write_vals.string[item_index][str_len] = 0;",
            "-                        }",
            "+                        /* zero terminate it at the new shorter length */",
            "+                        args->write_vals.string[item_index][str_len] = 0;",
            "+                    }",
            " ",
            "-                        /* set the string. */",
            "-                        rc = plc_tag_set_string(tag, offset, args->write_vals.string[item_index]);",
            "-                        if(rc != PLCTAG_STATUS_OK) {",
            "-                            printf(\"Error while setting the string %d, error: %s!\\n\", item_index, plc_tag_decode_error(rc));",
            "-                            cleanup(args);",
            "-                            exit(1);",
            "-                        }",
            "+                    /* set the string. */",
            "+                    rc = plc_tag_set_string(tag, offset, args->write_vals.string[item_index]);",
            "+                    if(rc != PLCTAG_STATUS_OK) {",
            "+                        printf(\"Error while setting the string %d, error: %s!\\n\", item_index, plc_tag_decode_error(rc));",
            "+                        cleanup(args);",
            "+                        exit(1);",
            "                     }",
            "+                }",
            " ",
            "                     offset += plc_tag_get_string_total_length(tag, offset);",
            " ",
            "                     break;",
            " ",
            "                 case TYPE_META:",
            "                     printf(\"ERROR: Metadata cannot be written!\\n\");"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_alternate_tag_listing.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_alternate_tag_listing.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_alternate_tag_listing.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2024 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,346 +28,357 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "-#include <stdbool.h>",
            "+#include \"compat_utils.h\"",
            " #include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " ",
            " /*",
            "  * This is a partial example of how we might do a lighter weight retrieval of tag",
            "  * information.   Most of the tag data comes in on demand rather than all at once.",
            "  */",
            " ",
            "-#define REQUIRED_VERSION 2,4,0",
            "+#define REQUIRED_VERSION 2, 4, 0",
            " ",
            " #define TAG_STRING \"protocol=ab-eip&gateway=10.206.1.40&path=1,0&plc=ControlLogix&name=@raw\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " enum {",
            "     Get_Attributes_All = 0x01,",
            "     Get_Attribute_List = 0x03,",
            "     Get_Attribute_Single = 0x0E,",
            "     Find_Next_Object_Instance = 0x11,",
            "     Symbolic_Translation = 0x4B,",
            "     Get_All_Tags_Attributes = 0x55,",
            " } cip_commands;",
            " ",
            " ",
            "-static int set_tag_data(int32_t tag, uint8_t *data, size_t raw_data_size)",
            "-{",
            "+static int set_tag_data(int32_t tag, uint8_t *data, size_t raw_data_size) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int data_size = (int)(unsigned int)raw_data_size;",
            " ",
            "     rc = plc_tag_set_size(tag, data_size);",
            "     if(rc < 0) {",
            "-        printf( \"\\nERROR: Unable to set the payload size on the tag %s!\\n\", plc_tag_decode_error(rc));",
            "+        printf(\"\\nERROR: Unable to set the payload size on the tag %s!\\n\", plc_tag_decode_error(rc));",
            "         return rc;",
            "     }",
            " ",
            "     rc = PLCTAG_STATUS_OK;",
            " ",
            "-    for(int i=0; i < data_size && rc == PLCTAG_STATUS_OK; i++) {",
            "+    for(int i = 0; i < data_size && rc == PLCTAG_STATUS_OK; i++) {",
            "         // printf(\"*** Setting index %d to %x.\\n\", i, (int)(unsigned int)get_attribute_list[i]);",
            "         rc = plc_tag_set_uint8(tag, i, data[i]);",
            " ",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            printf( \"\\nERROR: %s (%d) Unable to set the payload data in the tag at location %d!\\n\", plc_tag_decode_error(rc), rc, i);",
            "+            printf(\"\\nERROR: %s (%d) Unable to set the payload data in the tag at location %d!\\n\", plc_tag_decode_error(rc), rc,",
            "+                   i);",
            "         }",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            "-int print_tag_data(int32_t tag)",
            "-{",
            "+int print_tag_data(int32_t tag) {",
            "     int size = plc_tag_get_size(tag);",
            "     if(size < 0) {",
            "-        printf( \"\\nERROR: Unable to get the payload size on the tag %s!\\n\", plc_tag_decode_error(size));",
            "+        printf(\"\\nERROR: Unable to get the payload size on the tag %s!\\n\", plc_tag_decode_error(size));",
            "         return size;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(int i=0; i < size; i++) {",
            "+    for(int i = 0; i < size; i++) {",
            "         uint8_t data = plc_tag_get_uint8(tag, i);",
            "         printf(\" %02x\", (unsigned int)data);",
            "     }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int send_tag_data(int32_t tag, uint8_t *data, size_t data_size)",
            "-{",
            "+int send_tag_data(int32_t tag, uint8_t *data, size_t data_size) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     do {",
            "         /* copy data into the tag buffer */",
            "         rc = set_tag_data(tag, data, data_size);",
            "-        if(rc != PLCTAG_STATUS_OK)  {",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "             printf(\"\\nERROR: Unable to set the request data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "             break;",
            "         }",
            " ",
            "         printf(\"\\n\\tSending data: \");",
            " ",
            "         print_tag_data(tag);",
            " ",
            "         /* get the data, Write is the only action supported. */",
            "         rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            printf(\"\\nERROR: Unable to send the raw request! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+            printf(\"\\nERROR: Unable to send the raw request! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "             break;",
            "         }",
            " ",
            "         printf(\"\\n\\tReceived response data: \");",
            " ",
            "         rc = print_tag_data(tag);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            printf(\"\\nERROR: Unable to print the response! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+            printf(\"\\nERROR: Unable to print the response! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "             break;",
            "         }",
            "     } while(0);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int32_t get_tag_instance_counts(int32_t tag, uint16_t *num_instances, uint16_t *max_id)",
            "-{",
            "+int32_t get_tag_instance_counts(int32_t tag, uint16_t *num_instances, uint16_t *max_id) {",
            "     int32_t rc = PLCTAG_STATUS_OK;",
            "     uint8_t request[] = {",
            "-                            (uint8_t)Get_Attribute_List,",
            "-                            0x02,",
            "-                            0x20,",
            "-                            0x6B,       // Tag Manager class",
            "-                            0x24,",
            "-                            0x00,       // no instance, point to the class itself.",
            "-                            0x02, 0x00, // ask for two attributes",
            "-                            0x02, 0x00, // Attr: max instance ID",
            "-                            0x03, 0x00, // Attr: number of instances",
            "-                        };",
            "+        (uint8_t)Get_Attribute_List,",
            "+        0x02,",
            "+        0x20,",
            "+        0x6B,  // Tag Manager class",
            "+        0x24,",
            "+        0x00,  // no instance, point to the class itself.",
            "+        0x02,",
            "+        0x00,  // ask for two attributes",
            "+        0x02,",
            "+        0x00,  // Attr: max instance ID",
            "+        0x03,",
            "+        0x00,  // Attr: number of instances",
            "+    };",
            " ",
            "     do {",
            "-            rc = send_tag_data(tag, request, sizeof(request));",
            "-            if(rc != PLCTAG_STATUS_OK) break;",
            "+        rc = send_tag_data(tag, request, sizeof(request));",
            "+        if(rc != PLCTAG_STATUS_OK) { break; }",
            " ",
            "-            /* did we get enough data? */",
            "-            if(plc_tag_get_size(tag) >= 4) {",
            "-                uint8_t cip_status = plc_tag_get_uint8(tag, 2);",
            "-",
            "-                if(cip_status != 0) {",
            "-                    printf(\"ERROR: CIP command failed on remote PLC with error code %x!\", (unsigned int)cip_status);",
            "-                    rc = PLCTAG_ERR_REMOTE_ERR;",
            "-                    break;",
            "-                }",
            "-            } else {",
            "-                printf(\"ERROR: Insufficient data returned in CIP response to get full CIP header!\");",
            "-                rc = PLCTAG_ERR_TOO_SMALL;",
            "+        /* did we get enough data? */",
            "+        if(plc_tag_get_size(tag) >= 4) {",
            "+            uint8_t cip_status = plc_tag_get_uint8(tag, 2);",
            "+",
            "+            if(cip_status != 0) {",
            "+                printf(\"ERROR: CIP command failed on remote PLC with error code %x!\", (unsigned int)cip_status);",
            "+                rc = PLCTAG_ERR_REMOTE_ERR;",
            "                 break;",
            "             }",
            "+        } else {",
            "+            printf(\"ERROR: Insufficient data returned in CIP response to get full CIP header!\");",
            "+            rc = PLCTAG_ERR_TOO_SMALL;",
            "+            break;",
            "+        }",
            " ",
            "-            if(plc_tag_get_size(tag) >= 22) {",
            "-                uint16_t attrib_count = plc_tag_get_uint16(tag, 4);",
            "-                uint16_t attrib_max_instance_id = plc_tag_get_uint16(tag, 6);",
            "-                uint16_t attrib_max_instance_status = plc_tag_get_uint16(tag, 8);",
            "-                uint16_t attrib_max_instance_val = plc_tag_get_uint32(tag, 10);",
            "-                uint16_t attrib_num_instances_id = plc_tag_get_uint16(tag, 14);",
            "-                uint16_t attrib_num_instances_status = plc_tag_get_uint16(tag, 16);",
            "-                uint16_t attrib_num_instances_val = plc_tag_get_uint32(tag, 18);",
            "-",
            "-                /* ",
            "-                 * note that if we had any failure of an attribute retrieval, it ",
            "-                 * would result in a status of partial failure at the command",
            "-                 * level with a status of 0x1e.   Then each field that failed would",
            "-                 * have a status such as 0x14 (not found/does not exist).",
            "-                 */",
            "-",
            "-                *num_instances = attrib_num_instances_val;",
            "-                *max_id = attrib_max_instance_val;",
            "-            } else {",
            "-                printf(\"ERROR: Insufficient data returned in CIP response to get all attribute values!\");",
            "-                rc = PLCTAG_ERR_TOO_SMALL;",
            "-                break;",
            "-            }",
            "+        if(plc_tag_get_size(tag) >= 22) {",
            "+            uint16_t attrib_count = plc_tag_get_uint16(tag, 4);",
            "+            uint16_t attrib_max_instance_id = plc_tag_get_uint16(tag, 6);",
            "+            uint16_t attrib_max_instance_status = plc_tag_get_uint16(tag, 8);",
            "+            uint32_t attrib_max_instance_val = plc_tag_get_uint32(tag, 10);",
            "+            uint16_t attrib_num_instances_id = plc_tag_get_uint16(tag, 14);",
            "+            uint16_t attrib_num_instances_status = plc_tag_get_uint16(tag, 16);",
            "+            uint32_t attrib_num_instances_val = plc_tag_get_uint32(tag, 18);",
            "+",
            "+            (void)attrib_count;",
            "+            (void)attrib_max_instance_id;",
            "+            (void)attrib_max_instance_status;",
            "+            (void)attrib_num_instances_id;",
            "+            (void)attrib_num_instances_status;",
            "+",
            "+            /*",
            "+             * note that if we had any failure of an attribute retrieval, it",
            "+             * would result in a status of partial failure at the command",
            "+             * level with a status of 0x1e.   Then each field that failed would",
            "+             * have a status such as 0x14 (not found/does not exist).",
            "+             */",
            "+",
            "+            *num_instances = (uint16_t)attrib_num_instances_val;",
            "+            *max_id = (uint16_t)attrib_max_instance_val;",
            "+        } else {",
            "+            printf(\"ERROR: Insufficient data returned in CIP response to get all attribute values!\");",
            "+            rc = PLCTAG_ERR_TOO_SMALL;",
            "+            break;",
            "+        }",
            "     } while(0);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            " /**",
            "  * @brief Get the remaining tag info for this specific tag instance.",
            "- * ",
            "+ *",
            "  * We have the ID and the tag name string.  We just need the rest of the",
            "  * type information.",
            "- * ",
            "- * @param tag ",
            "- * @param tag_instance_id ",
            "- * @param tag_name ",
            "- * @param tag_type ",
            "- * @return int32_t ",
            "+ *",
            "+ * @param tag",
            "+ * @param tag_instance_id",
            "+ * @param tag_name",
            "+ * @param tag_type",
            "+ * @return int32_t",
            "  */",
            "-int32_t get_tag_full_info(int32_t tag, uint16_t tag_instance_id, const char **tag_name, uint16_t *tag_type)",
            "-{",
            "+int32_t get_tag_full_info(int32_t tag, uint16_t tag_instance_id, const char **tag_name, uint16_t *tag_type) {",
            "     int32_t rc = PLCTAG_STATUS_OK;",
            "     uint8_t request[] = {",
            "-                            (uint8_t)Get_Attribute_List,",
            "-                            0x03,",
            "-                            0x20,",
            "-                            0x6B,       // Tag Manager class",
            "-                            0x25, 0x00,",
            "-                            0x00, 0x00, // instance ID.",
            "-                            0x03, 0x00, // ask for several attributes",
            "-                            0x02, 0x00, // Attr: UINT - tag type information",
            "-                            0x08, 0x00, // Attr: 3xDINT - tag array dimensions",
            "-                            0x07, 0x00, // Attr: DINT Element size in bytes",
            "-                        };",
            "+        (uint8_t)Get_Attribute_List,",
            "+        0x03,",
            "+        0x20,",
            "+        0x6B,  // Tag Manager class",
            "+        0x25,",
            "+        0x00,",
            "+        0x00,",
            "+        0x00,  // instance ID.",
            "+        0x03,",
            "+        0x00,  // ask for several attributes",
            "+        0x02,",
            "+        0x00,  // Attr: UINT - tag type information",
            "+        0x08,",
            "+        0x00,  // Attr: 3xDINT - tag array dimensions",
            "+        0x07,",
            "+        0x00,  // Attr: DINT Element size in bytes",
            "+    };",
            "+",
            "+    (void)tag_name;",
            "+    (void)tag_type;",
            "+",
            " ",
            "     do {",
            "-            /* plug in the instance ID */",
            "-            request[6] = (uint8_t)(tag_instance_id & 0x00FF);",
            "-            request[7] = (uint8_t)((tag_instance_id & 0xFF00) >> 8);",
            "-",
            "-            rc = send_tag_data(tag, request, sizeof(request));",
            "-            if(rc != PLCTAG_STATUS_OK) break;",
            "-",
            "-            /* did we get enough data? */",
            "-            if(plc_tag_get_size(tag) >= 4) {",
            "-                uint8_t cip_status = plc_tag_get_uint8(tag, 2);",
            "-",
            "-                if(cip_status != 0) {",
            "-                    printf(\"\\nERROR: CIP command failed on remote PLC with error code %x!\", (unsigned int)cip_status);",
            "-                    rc = PLCTAG_ERR_REMOTE_ERR;",
            "-                    break;",
            "-                }",
            "-            } else {",
            "-                printf(\"ERROR: Insufficient data returned in CIP response to get full CIP header!\");",
            "-                rc = PLCTAG_ERR_TOO_SMALL;",
            "+        /* plug in the instance ID */",
            "+        request[6] = (uint8_t)(tag_instance_id & 0x00FF);",
            "+        request[7] = (uint8_t)((tag_instance_id & 0xFF00) >> 8);",
            "+",
            "+        rc = send_tag_data(tag, request, sizeof(request));",
            "+        if(rc != PLCTAG_STATUS_OK) { break; }",
            "+",
            "+        /* did we get enough data? */",
            "+        if(plc_tag_get_size(tag) >= 4) {",
            "+            uint8_t cip_status = plc_tag_get_uint8(tag, 2);",
            "+",
            "+            if(cip_status != 0) {",
            "+                printf(\"\\nERROR: CIP command failed on remote PLC with error code %x!\", (unsigned int)cip_status);",
            "+                rc = PLCTAG_ERR_REMOTE_ERR;",
            "                 break;",
            "             }",
            "+        } else {",
            "+            printf(\"ERROR: Insufficient data returned in CIP response to get full CIP header!\");",
            "+            rc = PLCTAG_ERR_TOO_SMALL;",
            "+            break;",
            "+        }",
            " ",
            "-            /* TODO - add decoding for the other fields */",
            "+        /* TODO - add decoding for the other fields */",
            "     } while(0);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            " /**",
            "  * @brief Get minimal tag information on all tags",
            "- * ",
            "+ *",
            "  * This just gets the ID and the tag name string, for all tags in the PLC.",
            "- * ",
            "- * @param tag ",
            "- * @param tag_instance_id ",
            "- * @return int32_t ",
            "+ *",
            "+ * @param tag",
            "+ * @param tag_instance_id",
            "+ * @return int32_t",
            "  */",
            "-int32_t get_all_tags(int32_t tag, uint16_t tag_instance_id)",
            "-{",
            "+int32_t get_all_tags(int32_t tag, uint16_t tag_instance_id) {",
            "     int32_t rc = PLCTAG_STATUS_OK;",
            "     uint8_t request[] = {",
            "-                            (uint8_t)Get_All_Tags_Attributes,",
            "-                            0x03,",
            "-                            0x20,",
            "-                            0x6B,       // Tag Manager class",
            "-                            0x25, 0x00, ",
            "-                            0x01, 0x00,",
            "-                            0x01, 0x00, // ask for several attributes",
            "-                            0x01, 0x00, // Attr: INT counted string, Tag name",
            "-                        };",
            "+        (uint8_t)Get_All_Tags_Attributes,",
            "+        0x03,",
            "+        0x20,",
            "+        0x6B,  // Tag Manager class",
            "+        0x25,",
            "+        0x00,",
            "+        0x01,",
            "+        0x00,",
            "+        0x01,",
            "+        0x00,  // ask for several attributes",
            "+        0x01,",
            "+        0x00,  // Attr: INT counted string, Tag name",
            "+    };",
            " ",
            "     do {",
            "-            /* plug in the instance ID */",
            "-            request[6] = (uint8_t)(tag_instance_id & 0x00FF);",
            "-            request[7] = (uint8_t)((tag_instance_id & 0xFF00) >> 8);",
            "-",
            "-            rc = send_tag_data(tag, request, sizeof(request));",
            "-            if(rc != PLCTAG_STATUS_OK) break;",
            "-",
            "-            /* did we get enough data? */",
            "-            if(plc_tag_get_size(tag) >= 4) {",
            "-                uint8_t cip_status = plc_tag_get_uint8(tag, 2);",
            "-",
            "-                if(cip_status != 0) {",
            "-                    printf(\"\\nERROR: CIP command failed on remote PLC with error code %x!\", (unsigned int)cip_status);",
            "-                    rc = PLCTAG_ERR_REMOTE_ERR;",
            "-                    break;",
            "-                }",
            "-            } else {",
            "-                printf(\"ERROR: Insufficient data returned in CIP response to get full CIP header!\");",
            "-                rc = PLCTAG_ERR_TOO_SMALL;",
            "+        /* plug in the instance ID */",
            "+        request[6] = (uint8_t)(tag_instance_id & 0x00FF);",
            "+        request[7] = (uint8_t)((tag_instance_id & 0xFF00) >> 8);",
            "+",
            "+        rc = send_tag_data(tag, request, sizeof(request));",
            "+        if(rc != PLCTAG_STATUS_OK) { break; }",
            "+",
            "+        /* did we get enough data? */",
            "+        if(plc_tag_get_size(tag) >= 4) {",
            "+            uint8_t cip_status = plc_tag_get_uint8(tag, 2);",
            "+",
            "+            if(cip_status != 0) {",
            "+                printf(\"\\nERROR: CIP command failed on remote PLC with error code %x!\", (unsigned int)cip_status);",
            "+                rc = PLCTAG_ERR_REMOTE_ERR;",
            "                 break;",
            "             }",
            "+        } else {",
            "+            printf(\"ERROR: Insufficient data returned in CIP response to get full CIP header!\");",
            "+            rc = PLCTAG_ERR_TOO_SMALL;",
            "+            break;",
            "+        }",
            "     } while(0);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    int size = 0;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "     uint16_t num_instances = 0;",
            "     uint16_t max_id = 0;",
            "-    uint16_t instance_id = (uint16_t)0;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major,",
            "+               version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     do {",
            "         /* create the tag */",
            "         tag = plc_tag_create(TAG_STRING, DATA_TIMEOUT);",
            "         if(tag < 0) {",
            "             printf(\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "-            rc = tag;",
            "             break;",
            "         }",
            " ",
            "         rc = get_tag_instance_counts(tag, &num_instances, &max_id);",
            "         if(rc < 0) {",
            "             printf(\"ERROR %s: Could not get the number of tag instances!\\n\", plc_tag_decode_error(rc));",
            "-            break;            ",
            "+            break;",
            "         }",
            " ",
            "-        printf(\"\\nThe PLC has %\"PRIu16\" tags and a maximum tag ID of %\"PRIu16\".\\n\", num_instances, max_id);",
            "+        printf(\"\\nThe PLC has %\" PRIu16 \" tags and a maximum tag ID of %\" PRIu16 \".\\n\", num_instances, max_id);",
            " ",
            "         rc = get_all_tags(tag, (uint16_t)1);",
            "         if(rc < 0) {",
            "             printf(\"ERROR %s: Could not get the number of tag instances!\\n\", plc_tag_decode_error(rc));",
            "-            break;            ",
            "+            break;",
            "         }",
            "-        ",
            "+",
            "         /* TODO - do something with this data */",
            " ",
            " ",
            "     } while(0);",
            " ",
            "-    if(tag > 0) {",
            "-        plc_tag_destroy(tag);",
            "-    }",
            "+    if(tag > 0) { plc_tag_destroy(tag); }",
            " ",
            "     printf(\"\\n\\n********* Complete *********!\\n\");",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_auto_sync.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_auto_sync.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_auto_sync.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,196 +28,213 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <stdint.h>",
            " #include <stdio.h>",
            "-#include <unistd.h>",
            " #include <stdlib.h>",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            "-#include <inttypes.h>",
            "-#include <sys/time.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,4,7",
            "-#define TAG_ATTRIBS \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=LGX&elem_type=DINT&elem_count=1&name=TestBigArray[4]&auto_sync_read_ms=200&auto_sync_write_ms=20\"",
            "+#define REQUIRED_VERSION 2, 4, 7",
            "+#define TAG_ATTRIBS \\",
            "+    \"protocol=ab_eip&gateway=127.0.0.1&path=1,0&cpu=ControlLogix&elem_type=DINT&elem_count=1&name=TestBigArray[4]&auto_sync_read_ms=200&auto_sync_write_ms=20\"",
            " #define DATA_TIMEOUT (5000)",
            " #define RUN_PERIOD (10000)",
            " #define READ_SLEEP_MS (100)",
            " #define WRITE_SLEEP_MS (300)",
            " ",
            " #define READ_PERIOD_MS (200)",
            " ",
            " static volatile int read_start_count = 0;",
            " static volatile int read_complete_count = 0;",
            " static volatile int write_start_count = 0;",
            " static volatile int write_complete_count = 0;",
            " ",
            " ",
            "-void *reader_function(void *tag_arg)",
            "-{",
            "+void *reader_function(void *tag_arg) {",
            "     int32_t tag = (int32_t)(intptr_t)tag_arg;",
            "-    int64_t start_time = util_time_ms();",
            "+    int64_t start_time = compat_time_ms();",
            "     int64_t run_until = start_time + RUN_PERIOD;",
            "     int iteration = 1;",
            " ",
            "-    while(run_until > util_time_ms()) {",
            "+    while(run_until > compat_time_ms()) {",
            "         int32_t val = plc_tag_get_int32(tag, 0);",
            " ",
            "-        fprintf(stderr, \"READER: Iteration %d, got value: %d at time %\" PRId64 \"\\n\", iteration++, val, util_time_ms()-start_time);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"READER: Iteration %d, got value: %d at time %\" PRId64 \"\\n\", iteration++, val,",
            "+                compat_time_ms() - start_time);",
            " ",
            "-        util_sleep_ms(READ_SLEEP_MS);",
            "+        compat_sleep_ms(READ_SLEEP_MS, NULL);",
            "     }",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-void *writer_function(void *tag_arg)",
            "-{",
            "+void *writer_function(void *tag_arg) {",
            "     int32_t tag = (int32_t)(intptr_t)tag_arg;",
            "-    int64_t start_time = util_time_ms();",
            "+    int64_t start_time = compat_time_ms();",
            "     int64_t run_until = start_time + RUN_PERIOD;",
            "     int iteration = 1;",
            " ",
            "-    util_sleep_ms(WRITE_SLEEP_MS);",
            "+    compat_sleep_ms(WRITE_SLEEP_MS, NULL);",
            " ",
            "-    while(run_until > util_time_ms()) {",
            "+    while(run_until > compat_time_ms()) {",
            "         int32_t val = plc_tag_get_int32(tag, 0);",
            "-        int32_t new_val = ((val+1) > 499) ? 0 : (val+1);",
            "+        int32_t new_val = ((val + 1) > 499) ? 0 : (val + 1);",
            " ",
            "         /* write the value */",
            "         plc_tag_set_int32(tag, 0, new_val);",
            " ",
            "-        fprintf(stderr, \"WRITER: Iteration %d, wrote value: %d at time %\" PRId64 \"\\n\", iteration++, new_val, util_time_ms()-start_time);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"WRITER: Iteration %d, wrote value: %d at time %\" PRId64 \"\\n\", iteration++, new_val,",
            "+                compat_time_ms() - start_time);",
            " ",
            "-        util_sleep_ms(WRITE_SLEEP_MS);",
            "+        compat_sleep_ms(WRITE_SLEEP_MS, NULL);",
            "     }",
            " ",
            "-    return NULL;",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-void tag_callback(int32_t tag_id, int event, int status)",
            "-{",
            "+void tag_callback(int32_t tag_id, int event, int status) {",
            "     /* handle the events. */",
            "     switch(event) {",
            "         case PLCTAG_EVENT_ABORTED:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %d automatic operation was aborted!\\n\", tag_id);",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_CREATED:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag was creation finished.\\n\");",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_DESTROYED:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag was destroyed.\\n\");",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_COMPLETED:",
            "             read_complete_count++;",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %d automatic read operation completed with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_STARTED:",
            "             read_start_count++;",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %d automatic read operation started with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_COMPLETED:",
            "             write_complete_count++;",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %d automatic write operation completed with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_STARTED:",
            "             write_start_count++;",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %d automatic write operation started with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "         default:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unexpected event %d on tag %d!\\n\", event, tag_id);",
            "             break;",
            "-",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int32_t tag = 0;",
            "-    pthread_t read_thread, write_thread;",
            "+    compat_thread_t read_thread, write_thread;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            " ",
            "-    (void)argc;",
            "-    (void)argv;",
            "-",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\\n\", REQUIRED_VERSION);",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Available library version is %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            "         exit(1);",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_WARN);",
            " ",
            "     tag = plc_tag_create(TAG_ATTRIBS, DATA_TIMEOUT);",
            "     if(tag < 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error, %s, creating tag!\\n\", plc_tag_decode_error(tag));",
            "         return 1;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Tag status %s.\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            " ",
            "     /* register the callback */",
            "     rc = plc_tag_register_callback(tag, tag_callback);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to register callback for tag %s!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Ready to start threads.\\n\");",
            " ",
            "     /* create the threads. */",
            "-    pthread_create(&read_thread, NULL, reader_function, (void *)(intptr_t)tag);",
            "-    pthread_create(&write_thread, NULL, writer_function, (void *)(intptr_t)tag);",
            "+    compat_thread_create(&read_thread, reader_function, (void *)(intptr_t)tag);",
            "+    compat_thread_create(&write_thread, writer_function, (void *)(intptr_t)tag);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Waiting for threads to quit.\\n\");",
            " ",
            "-    pthread_join(read_thread, NULL);",
            "-    pthread_join(write_thread, NULL);",
            "+    compat_thread_join(read_thread, NULL);",
            "+    compat_thread_join(write_thread, NULL);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Done.\\n\");",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     /* check the results. */",
            "-    fprintf(stderr, \"Total reads triggered %d, finished %d, and total expected %d.\\n\", read_start_count, read_complete_count, RUN_PERIOD/READ_PERIOD_MS);",
            "-    fprintf(stderr, \"Total writes triggered %d, finished %d, and total expected %d.\\n\", write_start_count, write_complete_count, RUN_PERIOD/WRITE_SLEEP_MS);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Total reads triggered %d, finished %d, and total expected %d.\\n\", read_start_count, read_complete_count,",
            "+            RUN_PERIOD / READ_PERIOD_MS);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Total writes triggered %d, finished %d, and total expected %d.\\n\", write_start_count, write_complete_count,",
            "+            RUN_PERIOD / WRITE_SLEEP_MS);",
            " ",
            "     rc = 0;",
            " ",
            "-    if(abs((RUN_PERIOD/READ_PERIOD_MS) - read_start_count) > 3) {",
            "-        fprintf(stderr, \"Number of reads, %d, not close to the expected number, %d!\\n\", read_start_count, (RUN_PERIOD/READ_PERIOD_MS));",
            "+    if(abs((RUN_PERIOD / READ_PERIOD_MS) - read_start_count) > 3) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Number of reads, %d, not close to the expected number, %d!\\n\", read_start_count,",
            "+                (RUN_PERIOD / READ_PERIOD_MS));",
            "         rc = 1;",
            "     }",
            " ",
            "-    if(abs((RUN_PERIOD/WRITE_SLEEP_MS) - write_start_count) > 3) {",
            "-        fprintf(stderr, \"Number of writes, %d, not close to the expected number, %d!\\n\", write_start_count, (RUN_PERIOD/WRITE_SLEEP_MS));",
            "+    if(abs((RUN_PERIOD / WRITE_SLEEP_MS) - write_start_count) > 3) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Number of writes, %d, not close to the expected number, %d!\\n\", write_start_count,",
            "+                (RUN_PERIOD / WRITE_SLEEP_MS));",
            "         rc = 1;",
            "     }",
            " ",
            "     return rc;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_callback.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_callback.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_callback.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2022 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,113 +28,102 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " ",
            " #define REQUIRED_VERSION 2, 5, 0",
            " ",
            " #define TAG_PATH \"protocol=ab-eip&gateway=127.0.0.1&path=1,0&cpu=LGX&elem_count=10&name=TestBigArray\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " typedef int32_t DINT;",
            " ",
            " static volatile DINT *TestDINTArray = NULL;",
            " ",
            "-void tag_callback(int32_t tag_id, int event, int status)",
            "-{",
            "+void tag_callback(int32_t tag_id, int event, int status) {",
            "     /* handle the events. */",
            "     switch(event) {",
            "-    case PLCTAG_EVENT_ABORTED:",
            "-        printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status));",
            "-        break;",
            "-",
            "-    case PLCTAG_EVENT_CREATED:",
            "-        printf(\"Tag created with status %s.\\n\", plc_tag_decode_error(status));",
            "-        break;",
            "-",
            "-    case PLCTAG_EVENT_DESTROYED:",
            "-        if(TestDINTArray) {",
            "-            free((void *)TestDINTArray);",
            "-            TestDINTArray = NULL;",
            "-        }",
            "-        printf(\"Tag was destroyed with status %s.\\n\", plc_tag_decode_error(status));",
            "-        break;",
            "-",
            "-    case PLCTAG_EVENT_READ_COMPLETED:",
            "-        if(status == PLCTAG_STATUS_OK && TestDINTArray) {",
            "-            int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "-            int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            "+        case PLCTAG_EVENT_ABORTED: printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status)); break;",
            " ",
            "-            for(int i = 0; i < elem_count; i++) {",
            "-                TestDINTArray[i] = plc_tag_get_int32(tag_id, (i * elem_size));",
            "+        case PLCTAG_EVENT_CREATED: printf(\"Tag created with status %s.\\n\", plc_tag_decode_error(status)); break;",
            "+",
            "+        case PLCTAG_EVENT_DESTROYED:",
            "+            if(TestDINTArray) {",
            "+                free((void *)TestDINTArray);",
            "+                TestDINTArray = NULL;",
            "+            }",
            "+            printf(\"Tag was destroyed with status %s.\\n\", plc_tag_decode_error(status));",
            "+            break;",
            "+",
            "+        case PLCTAG_EVENT_READ_COMPLETED:",
            "+            if(status == PLCTAG_STATUS_OK && TestDINTArray) {",
            "+                int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "+                int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            "+",
            "+                for(int i = 0; i < elem_count; i++) { TestDINTArray[i] = plc_tag_get_int32(tag_id, (i * elem_size)); }",
            "             }",
            "-        }",
            " ",
            "-        printf(\"Tag read operation completed with status %s.\\n\", plc_tag_decode_error(status));",
            "+            printf(\"Tag read operation completed with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "-        break;",
            "+            break;",
            " ",
            "-    case PLCTAG_EVENT_READ_STARTED:",
            "-        printf(\"Tag read operation started with status %s.\\n\", plc_tag_decode_error(status));",
            "-        break;",
            "+        case PLCTAG_EVENT_READ_STARTED:",
            "+            printf(\"Tag read operation started with status %s.\\n\", plc_tag_decode_error(status));",
            "+            break;",
            " ",
            "-    case PLCTAG_EVENT_WRITE_COMPLETED:",
            "-        printf(\"Tag write operation completed with status %s!\\n\", plc_tag_decode_error(status));",
            "-        break;",
            "+        case PLCTAG_EVENT_WRITE_COMPLETED:",
            "+            printf(\"Tag write operation completed with status %s!\\n\", plc_tag_decode_error(status));",
            "+            break;",
            " ",
            "-    case PLCTAG_EVENT_WRITE_STARTED:",
            "-        if(status == PLCTAG_STATUS_OK && TestDINTArray) {",
            "-            int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "-            int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            "+        case PLCTAG_EVENT_WRITE_STARTED:",
            "+            if(status == PLCTAG_STATUS_OK && TestDINTArray) {",
            "+                int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "+                int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-            for(int i = 0; i < elem_count; i++) {",
            "-                plc_tag_set_int32(tag_id, (i * elem_size), TestDINTArray[i]);",
            "+                for(int i = 0; i < elem_count; i++) { plc_tag_set_int32(tag_id, (i * elem_size), TestDINTArray[i]); }",
            "             }",
            "-        }",
            " ",
            "-        printf(\"Tag write operation started with status %s.\\n\", plc_tag_decode_error(status));",
            "+            printf(\"Tag write operation started with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "-        break;",
            "+            break;",
            " ",
            "-    default:",
            "-        printf(\"Unexpected event %d!\\n\", event);",
            "-        break;",
            "+        default: printf(\"Unexpected event %d!\\n\", event); break;",
            "     }",
            " }",
            " ",
            " ",
            "-void log_callback(int32_t tag_id, int debug_level, const char *message)",
            "-{",
            "+void log_callback(int32_t tag_id, int debug_level, const char *message) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Log message of level %d for tag %d: %s\", debug_level, tag_id, message);",
            " }",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int i;",
            "     int elem_count = 0;",
            "     int elem_size = 0;",
            "     int64_t start = 0;",
            "     int64_t end = 0;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major,",
            "+               version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     /* set up the logger. */",
            "     printf(\"Setting up logger callback.\\n\");",
            "@@ -239,22 +228,18 @@",
            "         printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            " ",
            "         return 1;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]);",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]); }",
            " ",
            "     /* now test a write */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        TestDINTArray[i]++;",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { TestDINTArray[i]++; }",
            " ",
            "     printf(\"Turn off logging.\\n\");",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "         printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "@@ -269,23 +254,21 @@",
            "         printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            " ",
            "         return 1;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]);",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]); }",
            " ",
            "     /* test a timeout. */",
            "     printf(\"Testing timeout behavior.\\n\");",
            "-    start = util_time_ms();",
            "+    start = compat_time_ms();",
            "     rc = plc_tag_read(tag, 1);",
            "-    end = util_time_ms();",
            "+    end = compat_time_ms();",
            " ",
            "     if(rc != PLCTAG_ERR_TIMEOUT) {",
            "         printf(\"Expected PLCTAG_ERR_TIMEOUT, got %s in %dms!\\n\", plc_tag_decode_error(rc), (int)(end - start));",
            "         plc_tag_destroy(tag);",
            " ",
            "         return 1;",
            "     }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_callback_ex.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_callback_ex.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_callback_ex.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2022 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,282 +27,267 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " ",
            "-#define REQUIRED_VERSION 2, 5, 0",
            "+#define REQUIRED_VERSION 2, 6, 4",
            " ",
            " #define TAG_PATH \"protocol=ab-eip&gateway=127.0.0.1&path=1,0&cpu=LGX&elem_count=10&name=TestBigArray\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " typedef int32_t DINT;",
            " ",
            "-/* this is the WRONG way to do cross-thread communication! */",
            "-static volatile int event_order_problem = 0;",
            "-",
            "-",
            "-void tag_callback(int32_t tag_id, int event, int status, void *userdata)",
            "-{",
            "+void tag_callback(int32_t tag_id, int event, int status, void *userdata) {",
            "     static int create_seen = 0; /* this is HORRIBLY unsafe for threading! */",
            "-    DINT *data = (DINT *)userdata;",
            "+    DINT **data_ptr = (DINT **)userdata;",
            "+    DINT *data = *data_ptr; /* better pass a valid pointer! s*/",
            " ",
            "     /* handle the events. */",
            "     switch(event) {",
            "-        case PLCTAG_EVENT_ABORTED:",
            "-            printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status));",
            "-            break;",
            "+        case PLCTAG_EVENT_ABORTED: printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status)); break;",
            " ",
            "         case PLCTAG_EVENT_CREATED:",
            "             printf(\"Tag created with status %s.\\n\", plc_tag_decode_error(status));",
            "             create_seen = 1;",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_DESTROYED:",
            "             printf(\"Tag was destroyed with status %s.\\n\", plc_tag_decode_error(status));",
            "             if(data) {",
            "                 free((void *)data);",
            "+                *data_ptr = NULL;",
            "             }",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_COMPLETED:",
            "             if(!create_seen) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Tag read operation completed before create was complete!\\n\");",
            "                 plc_tag_destroy(tag_id);",
            "                 exit(1);",
            "             }",
            " ",
            "             if(status == PLCTAG_STATUS_OK && data) {",
            "                 int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "                 int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-                for(int i = 0; i < elem_count; i++) {",
            "-                    data[i] = plc_tag_get_int32(tag_id, (i * elem_size));",
            "-                }",
            "+                for(int i = 0; i < elem_count; i++) { data[i] = plc_tag_get_int32(tag_id, (i * elem_size)); }",
            "             }",
            " ",
            "             printf(\"Tag read operation completed with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_STARTED:",
            "             if(!create_seen) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Tag read operation started before create was complete!\\n\");",
            "                 plc_tag_destroy(tag_id);",
            "                 exit(1);",
            "             }",
            "-            ",
            "+",
            "             printf(\"Tag read operation started with status %s.\\n\", plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_COMPLETED:",
            "             printf(\"Tag write operation completed with status %s!\\n\", plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_STARTED:",
            "             if(status == PLCTAG_STATUS_OK && data) {",
            "                 int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "                 int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-                for(int i = 0; i < elem_count; i++) {",
            "-                    plc_tag_set_int32(tag_id, (i * elem_size), data[i]);",
            "-                }",
            "+                for(int i = 0; i < elem_count; i++) { plc_tag_set_int32(tag_id, (i * elem_size), data[i]); }",
            "             }",
            " ",
            "             printf(\"Tag write operation started with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "-        default:",
            "-            printf(\"Unexpected event %d!\\n\", event);",
            "-            break;",
            "+        default: printf(\"Unexpected event %d!\\n\", event); break;",
            "     }",
            " }",
            " ",
            " ",
            "-void log_callback(int32_t tag_id, int debug_level, const char *message)",
            "-{",
            "+void log_callback(int32_t tag_id, int debug_level, const char *message) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Log message of level %d for tag %d: %s\", debug_level, tag_id, message);",
            " }",
            " ",
            " ",
            "-int main(int argc, const char **argv)",
            "-{",
            "+int main(int argc, const char **argv) {",
            "     int32_t tag = 0;",
            "-    int rc;",
            "-    int i;",
            "+    int rc = PLCTAG_STATUS_OK;",
            "+    int i = 0;",
            "     int elem_count = 10;",
            "     int elem_size = 4;",
            "     int64_t start = 0;",
            "     int64_t end = 0;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "     DINT *TestDINTArray = NULL;",
            " ",
            "     (void)argc;",
            "     (void)argv;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major,",
            "+               version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "-    TestDINTArray = calloc((size_t)elem_size, (size_t)elem_count);",
            "-    if(!TestDINTArray) {",
            "-        printf(\"Unable to allocate memory for tag array!\\n\");",
            "-        return 1;",
            "-    }",
            "+    do {",
            "+        TestDINTArray = calloc((size_t)elem_size, (size_t)elem_count);",
            "+        if(!TestDINTArray) {",
            "+            printf(\"Unable to allocate memory for tag array!\\n\");",
            "+            break;",
            "+        }",
            " ",
            "-    /* set up the logger. */",
            "-    printf(\"Setting up logger callback.\\n\");",
            "-    rc = plc_tag_register_logger(log_callback);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: %s: Could not register log callback!\\n\", plc_tag_decode_error(rc));",
            "-        return 1;",
            "-    }",
            "+        /* set up the logger. */",
            "+        printf(\"Setting up logger callback.\\n\");",
            "+        rc = plc_tag_register_logger(log_callback);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: %s: Could not register log callback!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* try again to see if we get the right error. */",
            "-    printf(\"Testing duplicate logger callback registration.\\n\");",
            "-    rc = plc_tag_register_logger(log_callback);",
            "-    if(rc != PLCTAG_ERR_DUPLICATE) {",
            "-        printf(\"ERROR: %s: Did not get PLCTAG_ERR_DUPLICATE when registering the logger again!\\n\", plc_tag_decode_error(rc));",
            "-        return 1;",
            "-    }",
            "+        /* try again to see if we get the right error. */",
            "+        printf(\"Testing duplicate logger callback registration.\\n\");",
            "+        rc = plc_tag_register_logger(log_callback);",
            "+        if(rc != PLCTAG_ERR_DUPLICATE) {",
            "+            printf(\"ERROR: %s: Did not get PLCTAG_ERR_DUPLICATE when registering the logger again!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* Remove the logger. */",
            "-    printf(\"Testing logger callback unregister.\\n\");",
            "-    rc = plc_tag_unregister_logger();",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: %s: Got error when unregistering the log callback!\\n\", plc_tag_decode_error(rc));",
            "-        return 1;",
            "-    }",
            "+        /* Remove the logger. */",
            "+        printf(\"Testing logger callback unregister.\\n\");",
            "+        rc = plc_tag_unregister_logger();",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: %s: Got error when unregistering the log callback!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* Remove the logger again. */",
            "-    printf(\"Testing duplicate logger callback unregistration.\\n\");",
            "-    rc = plc_tag_unregister_logger();",
            "-    if(rc != PLCTAG_ERR_NOT_FOUND) {",
            "-        printf(\"ERROR: %s: Did not get PLCTAG_ERR_NOT_FOUND when unregistering the logger again!\\n\", plc_tag_decode_error(rc));",
            "-        return 1;",
            "-    }",
            "+        /* Remove the logger again. */",
            "+        printf(\"Testing duplicate logger callback unregistration.\\n\");",
            "+        rc = plc_tag_unregister_logger();",
            "+        if(rc != PLCTAG_ERR_NOT_FOUND) {",
            "+            printf(\"ERROR: %s: Did not get PLCTAG_ERR_NOT_FOUND when unregistering the logger again!\\n\",",
            "+                   plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* set up the logger again. */",
            "-    rc = plc_tag_register_logger(log_callback);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: %s: Could not register log callback after removing it!\\n\", plc_tag_decode_error(rc));",
            "-        return 1;",
            "-    }",
            "+        /* set up the logger again. */",
            "+        rc = plc_tag_register_logger(log_callback);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: %s: Could not register log callback after removing it!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            "+        plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "-    /* create the tag */",
            "-    tag = plc_tag_create_ex(TAG_PATH, tag_callback, TestDINTArray, DATA_TIMEOUT);",
            "-    if(tag < 0) {",
            "-        printf(\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "-        return 1;",
            "-    }",
            "+        /* create the tag */",
            "+        tag = plc_tag_create_ex(TAG_PATH, tag_callback, &TestDINTArray, DATA_TIMEOUT);",
            "+        if(tag < 0) {",
            "+            printf(\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+            break;",
            "+        }",
            " ",
            "-    printf(\"Removing logger callback.  Should see regular logging output now.\\n\");",
            "-    rc = plc_tag_unregister_logger();",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: %s: Got error when removing the logger callback!\\n\", plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        printf(\"Removing logger callback.  Should see regular logging output now.\\n\");",
            "+        rc = plc_tag_unregister_logger();",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: %s: Got error when removing the logger callback!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* test registering the callback again, should be an error */",
            "-    rc = plc_tag_register_callback_ex(tag, tag_callback, TestDINTArray);",
            "-    if(rc != PLCTAG_ERR_DUPLICATE) {",
            "-        printf(\"Got incorrect status when registering callback twice %s!\\n\", plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        /* test registering the callback again, should be an error */",
            "+        rc = plc_tag_register_callback_ex(tag, tag_callback, TestDINTArray);",
            "+        if(rc != PLCTAG_ERR_DUPLICATE) {",
            "+            printf(\"Got incorrect status when registering callback twice %s!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* get the data */",
            "-    rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        /* get the data */",
            "+        rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]);",
            "-    }",
            "+        /* print out the data */",
            "+        for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]); }",
            " ",
            "-    /* now test a write */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        TestDINTArray[i]++;",
            "-    }",
            "+        /* now test a write */",
            "+        for(i = 0; i < elem_count; i++) { TestDINTArray[i]++; }",
            " ",
            "-    printf(\"Turn off logging.\\n\");",
            "-    plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            "+        printf(\"Turn off logging.\\n\");",
            "+        plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "-    rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* get the data again*/",
            "-    rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        /* get the data again*/",
            "+        rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]);",
            "-    }",
            "+        /* print out the data */",
            "+        for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, TestDINTArray[i]); }",
            " ",
            "-    /* test a timeout. */",
            "-    printf(\"Testing timeout behavior.\\n\");",
            "-    start = util_time_ms();",
            "-    rc = plc_tag_read(tag, 1);",
            "-    end = util_time_ms();",
            "-",
            "-    if(rc != PLCTAG_ERR_TIMEOUT) {",
            "-        printf(\"Expected PLCTAG_ERR_TIMEOUT, got %s in %dms!\\n\", plc_tag_decode_error(rc), (int)(end - start));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        /* test a timeout. */",
            "+        printf(\"Testing timeout behavior.\\n\");",
            "+        start = compat_time_ms();",
            "+        rc = plc_tag_read(tag, 1); /* This might not work against the emulator.  It is too fast! */",
            "+        end = compat_time_ms();",
            " ",
            "-    /* test an abort. */",
            "-    printf(\"Testing abort behavior.\\n\");",
            "-    rc = plc_tag_read(tag, 0);",
            "-    if(rc != PLCTAG_STATUS_PENDING) {",
            "-        printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        if(rc != PLCTAG_ERR_TIMEOUT) {",
            "+            printf(\"Expected PLCTAG_ERR_TIMEOUT, got %s in %dms!\\n\", plc_tag_decode_error(rc), (int)(end - start));",
            "+            break;",
            "+        }",
            " ",
            "-    rc = plc_tag_abort(tag);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: Unable to abort the read, error %s\\n\", plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return 1;",
            "-    }",
            "+        /* test an abort. */",
            "+        printf(\"Testing abort behavior.\\n\");",
            "+        rc = plc_tag_read(tag, 0);",
            "+        if(rc != PLCTAG_STATUS_PENDING) {",
            "+            printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /*",
            "-     * we do not need to free the array TestDINTArray because the callback will do",
            "-     * it when the tag is destroyed.",
            "-     */",
            "-    plc_tag_destroy(tag);",
            "+        rc = plc_tag_abort(tag);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            printf(\"ERROR: Unable to abort the read, error %s\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+    } while(0);",
            " ",
            "-    printf(\"SUCCESS!\\n\");",
            "+    if(tag != 0) { plc_tag_destroy(tag); }",
            " ",
            "-    return 0;",
            "+    if(TestDINTArray) {",
            "+        free((void *)TestDINTArray);",
            "+        TestDINTArray = NULL;",
            "+    }",
            "+",
            "+    if(rc == PLCTAG_STATUS_OK) {",
            "+        printf(\"SUCCESS!\\n\");",
            "+        return 0;",
            "+    } else {",
            "+        printf(\"FAILURE %s!\\n\", plc_tag_decode_error(rc));",
            "+        return 1;",
            "+    }",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_callback_ex_logix.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_callback_ex_logix.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_callback_ex_logix.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2022 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,74 +27,69 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stddef.h>",
            "-#include <stdlib.h>",
            " #include <stdio.h>",
            "+#include <stdlib.h>",
            " ",
            " #define REQUIRED_VERSION 2, 5, 0",
            " ",
            " #define TAG_PATH \"protocol=ab-eip&gateway=127.0.0.1&path=1,0&cpu=LGX&elem_count=10&name=TestBigArray\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " typedef int32_t TAG_ELEMENT;",
            " ",
            " ",
            "-void tag_callback(int32_t tag_id, int event, int status, void *userdata)",
            "-{",
            "+void tag_callback(int32_t tag_id, int event, int status, void *userdata) {",
            "     static int create_seen = 0; /* this is HORRIBLY unsafe for threading! */",
            "     TAG_ELEMENT *data = (TAG_ELEMENT *)userdata;",
            " ",
            "     /* handle the events. */",
            "     switch(event) {",
            "-        case PLCTAG_EVENT_ABORTED:",
            "-            printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status));",
            "-            break;",
            "+        case PLCTAG_EVENT_ABORTED: printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status)); break;",
            " ",
            "         case PLCTAG_EVENT_CREATED:",
            "             printf(\"Tag created with status %s.\\n\", plc_tag_decode_error(status));",
            "             create_seen = 1;",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_DESTROYED:",
            "             printf(\"Tag was destroyed with status %s.\\n\", plc_tag_decode_error(status));",
            "-            if(data) {",
            "-                free((void *)data);",
            "-            }",
            "+            if(data) { free((void *)data); }",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_COMPLETED:",
            "             if(!create_seen) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Tag read operation completed before create was complete!\\n\");",
            "                 plc_tag_destroy(tag_id);",
            "                 exit(1);",
            "             }",
            " ",
            "             if(status == PLCTAG_STATUS_OK && data) {",
            "                 int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "                 int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-                for(int i = 0; i < elem_count; i++) {",
            "-                    data[i] = plc_tag_get_int32(tag_id, (i * elem_size));",
            "-                }",
            "+                for(int i = 0; i < elem_count; i++) { data[i] = plc_tag_get_int32(tag_id, (i * elem_size)); }",
            "             }",
            " ",
            "             printf(\"Tag read operation completed with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_STARTED:",
            "             if(!create_seen) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Tag read operation started before create was complete!\\n\");",
            "                 plc_tag_destroy(tag_id);",
            "                 exit(1);",
            "             }",
            " ",
            "             printf(\"Tag read operation started with status %s.\\n\", plc_tag_decode_error(status));",
            "             break;",
            "@@ -104,80 +99,73 @@",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_STARTED:",
            "             if(status == PLCTAG_STATUS_OK && data) {",
            "                 int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "                 int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-                for(int i = 0; i < elem_count; i++) {",
            "-                    plc_tag_set_int32(tag_id, (i * elem_size), data[i]);",
            "-                }",
            "+                for(int i = 0; i < elem_count; i++) { plc_tag_set_int32(tag_id, (i * elem_size), data[i]); }",
            "             }",
            " ",
            "             printf(\"Tag write operation started with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "-        default:",
            "-            printf(\"Unexpected event %d!\\n\", event);",
            "-            break;",
            "+        default: printf(\"Unexpected event %d!\\n\", event); break;",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-void wait_for_ok(int32_t tag, int32_t timeout_ms)",
            "-{",
            "+void wait_for_ok(int32_t tag, int32_t timeout_ms) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    int64_t timeout_time = timeout_ms + util_time_ms();",
            "+    int64_t timeout_time = timeout_ms + compat_time_ms();",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"wait_for_ok() starting.\\n\");",
            " ",
            "     do {",
            "         rc = plc_tag_status(tag);",
            " ",
            "         if(rc == PLCTAG_STATUS_PENDING) {",
            "-            util_sleep_ms(20);",
            "+            compat_sleep_ms(20, NULL);",
            " ",
            "-            if(timeout_time < util_time_ms()) {",
            "-                rc = PLCTAG_ERR_TIMEOUT;",
            "-            }",
            "+            if(timeout_time < compat_time_ms()) { rc = PLCTAG_ERR_TIMEOUT; }",
            "         }",
            "     } while(rc == PLCTAG_STATUS_PENDING);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"wait_for_ok(): Error %s returned on tag operation.!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         exit(1);",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"wait_for_ok() done.\\n\");",
            " }",
            " ",
            " ",
            "-int main(int argc, const char **argv)",
            "-{",
            "+int main(int argc, const char **argv) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int i;",
            "     int elem_count = 10;",
            "     int elem_size = 4;",
            "-    int64_t start = 0;",
            "-    int64_t end = 0;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "     TAG_ELEMENT *tag_element_array = NULL;",
            " ",
            "     (void)argc;",
            "     (void)argv;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major,",
            "+               version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     tag_element_array = (TAG_ELEMENT *)calloc((size_t)elem_size, (size_t)elem_count);",
            "     if(!tag_element_array) {",
            "@@ -207,22 +195,18 @@",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Waiting for tag read to complete.\\n\");",
            "     wait_for_ok(tag, DATA_TIMEOUT);",
            " ",
            "     /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, tag_element_array[i]);",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, tag_element_array[i]); }",
            " ",
            "     /* now test a write */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        tag_element_array[i]++;",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { tag_element_array[i]++; }",
            " ",
            "     printf(\"Writing tag data.\\n\");",
            "     rc = plc_tag_write(tag, 0);",
            "     if(rc != PLCTAG_STATUS_PENDING) {",
            "         printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "@@ -240,17 +224,15 @@",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Waiting for tag read to complete.\\n\");",
            "     wait_for_ok(tag, DATA_TIMEOUT);",
            " ",
            "     /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, tag_element_array[i]);",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, tag_element_array[i]); }",
            " ",
            "     /*",
            "      * we do not need to free the array tag_element_array because the callback will do",
            "      * it when the tag is destroyed.",
            "      */",
            "     plc_tag_destroy(tag);"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_callback_ex_modbus.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_callback_ex_modbus.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_callback_ex_modbus.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2022 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,74 +27,69 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stddef.h>",
            "-#include <stdlib.h>",
            " #include <stdio.h>",
            "+#include <stdlib.h>",
            " ",
            " #define REQUIRED_VERSION 2, 5, 0",
            " ",
            " #define TAG_PATH \"protocol=modbus-tcp&gateway=127.0.0.1:5020&path=0&elem_count=10&name=hr1\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " typedef int16_t TAG_ELEMENT;",
            " ",
            " ",
            "-void tag_callback(int32_t tag_id, int event, int status, void *userdata)",
            "-{",
            "+void tag_callback(int32_t tag_id, int event, int status, void *userdata) {",
            "     static int create_seen = 0; /* this is HORRIBLY unsafe for threading! */",
            "     TAG_ELEMENT *data = (TAG_ELEMENT *)userdata;",
            " ",
            "     /* handle the events. */",
            "     switch(event) {",
            "-        case PLCTAG_EVENT_ABORTED:",
            "-            printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status));",
            "-            break;",
            "+        case PLCTAG_EVENT_ABORTED: printf(\"Tag operation was aborted with status %s!\\n\", plc_tag_decode_error(status)); break;",
            " ",
            "         case PLCTAG_EVENT_CREATED:",
            "             printf(\"Tag created with status %s.\\n\", plc_tag_decode_error(status));",
            "             create_seen = 1;",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_DESTROYED:",
            "             printf(\"Tag was destroyed with status %s.\\n\", plc_tag_decode_error(status));",
            "-            if(data) {",
            "-                free((void *)data);",
            "-            }",
            "+            if(data) { free((void *)data); }",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_COMPLETED:",
            "             if(!create_seen) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Tag read operation completed before create was complete!\\n\");",
            "                 plc_tag_destroy(tag_id);",
            "                 exit(1);",
            "             }",
            " ",
            "             if(status == PLCTAG_STATUS_OK && data) {",
            "                 int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "                 int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-                for(int i = 0; i < elem_count; i++) {",
            "-                    data[i] = plc_tag_get_int16(tag_id, (i * elem_size));",
            "-                }",
            "+                for(int i = 0; i < elem_count; i++) { data[i] = plc_tag_get_int16(tag_id, (i * elem_size)); }",
            "             }",
            " ",
            "             printf(\"Tag read operation completed with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_STARTED:",
            "             if(!create_seen) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Tag read operation started before create was complete!\\n\");",
            "                 plc_tag_destroy(tag_id);",
            "                 exit(1);",
            "             }",
            " ",
            "             printf(\"Tag read operation started with status %s.\\n\", plc_tag_decode_error(status));",
            "             break;",
            "@@ -104,80 +99,70 @@",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_STARTED:",
            "             if(status == PLCTAG_STATUS_OK && data) {",
            "                 int elem_count = plc_tag_get_int_attribute(tag_id, \"elem_count\", -1);",
            "                 int elem_size = plc_tag_get_int_attribute(tag_id, \"elem_size\", 0);",
            " ",
            "-                for(int i = 0; i < elem_count; i++) {",
            "-                    plc_tag_set_int16(tag_id, (i * elem_size), data[i]);",
            "-                }",
            "+                for(int i = 0; i < elem_count; i++) { plc_tag_set_int16(tag_id, (i * elem_size), data[i] + 1); }",
            "             }",
            " ",
            "             printf(\"Tag write operation started with status %s.\\n\", plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "-        default:",
            "-            printf(\"Unexpected event %d!\\n\", event);",
            "-            break;",
            "+        default: printf(\"Unexpected event %d!\\n\", event); break;",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-void wait_for_ok(int32_t tag, int32_t timeout_ms)",
            "-{",
            "+void wait_for_ok(int32_t tag, int32_t timeout_ms) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    int64_t timeout_time = timeout_ms + util_time_ms();",
            "+    int64_t timeout_time = timeout_ms + compat_time_ms();",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"wait_for_ok() starting.\\n\");",
            " ",
            "     do {",
            "         rc = plc_tag_status(tag);",
            " ",
            "         if(rc == PLCTAG_STATUS_PENDING) {",
            "-            util_sleep_ms(20);",
            "+            compat_sleep_ms(20, NULL);",
            " ",
            "-            if(timeout_time < util_time_ms()) {",
            "-                rc = PLCTAG_ERR_TIMEOUT;",
            "-            }",
            "+            if(timeout_time < compat_time_ms()) { rc = PLCTAG_ERR_TIMEOUT; }",
            "         }",
            "     } while(rc == PLCTAG_STATUS_PENDING);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"wait_for_ok(): Error %s returned on tag operation.!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         exit(1);",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"wait_for_ok() done.\\n\");",
            " }",
            " ",
            " ",
            "-int main(int argc, const char **argv)",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int i;",
            "     int elem_count = 10;",
            "     int elem_size = 2;",
            "-    int64_t start = 0;",
            "-    int64_t end = 0;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "     TAG_ELEMENT *tag_element_array = NULL;",
            " ",
            "-    (void)argc;",
            "-    (void)argv;",
            "-",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major,",
            "+               version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "     tag_element_array = (TAG_ELEMENT *)calloc((size_t)elem_size, (size_t)elem_count);",
            "     if(!tag_element_array) {",
            "@@ -207,22 +192,18 @@",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Waiting for tag read to complete.\\n\");",
            "     wait_for_ok(tag, DATA_TIMEOUT);",
            " ",
            "     /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, tag_element_array[i]);",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, tag_element_array[i]); }",
            " ",
            "     /* now test a write */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        tag_element_array[i]++;",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { tag_element_array[i]++; }",
            " ",
            "     printf(\"Writing tag data.\\n\");",
            "     rc = plc_tag_write(tag, 0);",
            "     if(rc != PLCTAG_STATUS_PENDING) {",
            "         printf(\"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "@@ -240,17 +221,15 @@",
            "         return 1;",
            "     }",
            " ",
            "     printf(\"Waiting for tag read to complete.\\n\");",
            "     wait_for_ok(tag, DATA_TIMEOUT);",
            " ",
            "     /* print out the data */",
            "-    for(i = 0; i < elem_count; i++) {",
            "-        printf(\"data[%d]=%d\\n\", i, tag_element_array[i]);",
            "-    }",
            "+    for(i = 0; i < elem_count; i++) { printf(\"data[%d]=%d\\n\", i, tag_element_array[i]); }",
            " ",
            "     /*",
            "      * we do not need to free the array tag_element_array because the callback will do",
            "      * it when the tag is destroyed.",
            "      */",
            "     plc_tag_destroy(tag);"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_connection_group.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_connection_group.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_connection_group.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -35,153 +35,69 @@",
            " /*",
            "  * This example tests connection grouping.",
            "  *",
            "  * Use ^C to terminate early.",
            "  */",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            "-#include <string.h>",
            " #include <stdlib.h>",
            "-#include <inttypes.h>",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-#include <Windows.h>",
            "-#else",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            " #include <string.h>",
            "-#include <sys/time.h>",
            "-#include <signal.h>",
            "-#endif",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,4,1",
            "+#define REQUIRED_VERSION 2, 4, 1",
            " ",
            " #define DATA_TIMEOUT (5000)",
            " #define TAG_CREATE_TIMEOUT (5000)",
            " #define RETRY_TIMEOUT (10000)",
            " ",
            " #define DEFAULT_TAG_PATH \"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&name=TestDINTArray\"",
            " #define DEFAULT_THREAD_COUNT (10)",
            " ",
            " ",
            "-void usage(void)",
            "-{",
            "-    printf(\"Usage:\\n \"",
            "+void usage(void) {",
            "+    // NOLINTNEXTLINE",
            "+    printf(",
            "+        \"Usage:\\n \"",
            "         \"thread_stress <num tags> <path>\\n\"",
            "         \"  <num_tags> - The number of threads to use in the test.\\n\"",
            "         \"  <path> - The tag path to use.\\n\"",
            "         \"\\n\"",
            "         \"Example: thread_stress 14 'protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=test_tag'\\n\");",
            " ",
            "     exit(PLCTAG_ERR_BAD_PARAM);",
            " }",
            " ",
            "-",
            "-",
            "-",
            "-#ifdef _WIN32",
            " volatile int go = 0;",
            " ",
            "-/* straight from MS' web site :-) */",
            "-BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)",
            "-{",
            "-    switch (fdwCtrlType)",
            "-    {",
            "-        // Handle the CTRL-C signal.",
            "-    case CTRL_C_EVENT:",
            "-        go = 0;",
            "-        return TRUE;",
            "-",
            "-        // CTRL-CLOSE: confirm that the user wants to exit.",
            "-    case CTRL_CLOSE_EVENT:",
            "-        go = 0;",
            "-        return TRUE;",
            "-",
            "-        // Pass other signals to the next handler.",
            "-    case CTRL_BREAK_EVENT:",
            "-        go = 0;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_LOGOFF_EVENT:",
            "-        go = 0;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_SHUTDOWN_EVENT:",
            "-        go = 0;",
            "-        return FALSE;",
            "-",
            "-    default:",
            "-        return FALSE;",
            "-    }",
            "-}",
            "-",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))",
            "-    {",
            "-        printf(\"\\nERROR: Could not set control handler!\\n\");",
            "-        usage();",
            "-    }",
            "-}",
            "-",
            "-#else",
            "-volatile sig_atomic_t go = 0;",
            "-",
            "-void SIGINT_handler(int not_used)",
            "-{",
            "-    (void)not_used;",
            "-",
            "-    go = 0;",
            "-}",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    struct sigaction act;",
            "-",
            "-    /* set up signal handler. */",
            "-    memset(&act, 0, sizeof(act));",
            "-    act.sa_handler = SIGINT_handler;",
            "-    sigaction(SIGINT, &act, NULL);",
            "-}",
            "-",
            "-#endif",
            "-",
            "-",
            "+void interrupt_handler(void) { go = 0; }",
            " ",
            " ",
            " /*",
            "  * This test program creates a lot of threads that read the same tag in",
            "  * the plc.  They all hit the exact same underlying tag data structure.",
            "  * This tests whether the library can handle multi-threaded",
            "  * access and what the performance is.",
            "  */",
            " ",
            " typedef struct {",
            "-    int tid;",
            "+    int64_t max_io_time;",
            "+    int64_t min_io_time;",
            "+    int64_t total_io_time;",
            "     int32_t tag;",
            "     int group;",
            "-    int status;",
            "     int iteration;",
            "-    int64_t total_io_time;",
            "-    int64_t min_io_time;",
            "-    int64_t max_io_time;",
            "+    int status;",
            "+    int tid;",
            " } thread_args;",
            " ",
            " ",
            "-",
            "-",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-DWORD __stdcall test_runner(LPVOID data)",
            "-#else",
            "-void* test_runner(void* data)",
            "-#endif",
            "-{",
            "+void *test_runner(void *data) {",
            "     thread_args *args = (thread_args *)data;",
            "     int tid = args->tid;",
            "     int32_t tag = args->tag;",
            "     int *status = &(args->status);",
            "     int *iteration = &(args->iteration);",
            "     int64_t *total_io_time = &(args->total_io_time);",
            "     int64_t *max_io_time = &(args->max_io_time);",
            "@@ -191,223 +107,212 @@",
            "     *status = PLCTAG_STATUS_OK;",
            "     *iteration = 0;",
            "     *total_io_time = 0;",
            "     *max_io_time = 0;",
            "     *min_io_time = 1000000000L;",
            " ",
            "     /* wait until all threads ready. */",
            "-    while(!go) {",
            "-        util_sleep_ms(10);",
            "-    }",
            "+    while(!go) { compat_sleep_ms(10, NULL); }",
            " ",
            "     while(go) {",
            "         int64_t start = 0;",
            "         int64_t io_time = 0;",
            " ",
            "         (*iteration)++;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            fprintf(stderr, \"!!! Thread %d, iteration %d, read failed after %\" PRId64 \"ms  with error %s\\n\", tid, *iteration, (int64_t)(util_time_ms() - start), plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"!!! Thread %d, iteration %d, read failed after %\" PRId64 \"ms  with error %s\\n\", tid, *iteration,",
            "+                    (int64_t)(compat_time_ms() - start), plc_tag_decode_error(rc));",
            "             break;",
            "         }",
            " ",
            "-        io_time = util_time_ms() - start;",
            "+        io_time = compat_time_ms() - start;",
            " ",
            "         *total_io_time += io_time;",
            " ",
            "-        if(io_time > *max_io_time) {",
            "-            *max_io_time = io_time;",
            "-        }",
            "+        if(io_time > *max_io_time) { *max_io_time = io_time; }",
            " ",
            "-        if(io_time < *min_io_time) {",
            "-            *min_io_time = io_time;",
            "-        }",
            "+        if(io_time < *min_io_time) { *min_io_time = io_time; }",
            "     }",
            " ",
            "-    fprintf(stderr, \"*** Thread %d terminating after %d iterations and an average of %dms per iteration.\\n\", tid, *iteration, (int)(*total_io_time/(*iteration)));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"*** Thread %d terminating after %d iterations and an average of %dms per iteration.\\n\", tid, *iteration,",
            "+            (int)(*total_io_time / (*iteration)));",
            " ",
            "     fflush(stderr);",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    return (DWORD)0;",
            "-#else",
            "-    return NULL;",
            "-#endif",
            "+    return 0;",
            " }",
            " ",
            " ",
            " #define MAX_THREADS (100)",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    HANDLE thread[MAX_THREADS];",
            "-#else",
            "-    pthread_t thread[MAX_THREADS];",
            "-#endif",
            "+int main(int argc, char **argv) {",
            "+    compat_thread_t thread[MAX_THREADS];",
            "     int num_threads = 0;",
            "     int success = 0;",
            "     thread_args args[MAX_THREADS];",
            "     char *tag_string = NULL;",
            "     int64_t start = 0;",
            "     int64_t total_run_time = 0;",
            "     int count_down = 50;",
            " ",
            "     /* set up logging */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* set up handler for ^C etc. */",
            "-    setup_break_handler();",
            "+    compat_set_interrupt_handler(interrupt_handler);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Hit ^C to terminate the test.\\n\");",
            " ",
            "     if(argc == 3) {",
            "         num_threads = atoi(argv[1]);",
            "         tag_string = argv[2];",
            "     } else {",
            "-        //usage();",
            "+        // usage();",
            "         num_threads = DEFAULT_THREAD_COUNT;",
            "         tag_string = DEFAULT_TAG_PATH;",
            "     }",
            " ",
            "     if(num_threads > MAX_THREADS) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Too many threads.  A maximum of %d threads are supported.\\n\", MAX_THREADS);",
            "         usage();",
            "     }",
            " ",
            "     if(!tag_string || strlen(tag_string) < 10) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"You must provide a valid tag string.\\n\");",
            "         usage();",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"--- starting run with %d threads using tag string \\\"%s\\\".\\n\", num_threads, tag_string);",
            " ",
            "     /* create the test tags */",
            "-    for(int tid=0; tid < num_threads  && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "         int32_t tag = 0;",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"--- Creating test tag %d.\\n\", tid);",
            " ",
            "         if(tid != 0) {",
            "             tag = plc_tag_create(tag_string, TAG_CREATE_TIMEOUT);",
            "         } else {",
            "             /* make the first tag in a different connection group. */",
            "             const char *conn_grp_string = \"&connection_group_id=1\";",
            "             size_t new_string_size = strlen(tag_string) + strlen(conn_grp_string) + 1;",
            "             char *new_tag_string = (char *)calloc(1, new_string_size);",
            " ",
            "             if(new_tag_string) {",
            "+                // NOLINTNEXTLINE",
            "                 int size = snprintf(new_tag_string, new_string_size, \"%s%s\", tag_string, conn_grp_string);",
            " ",
            "-                if((size+1) == (int)(unsigned int)new_string_size) {",
            "+                if((size + 1) == (int)(unsigned int)new_string_size) {",
            "                     tag = plc_tag_create(new_tag_string, TAG_CREATE_TIMEOUT);",
            "                 } else {",
            "+                    // NOLINTNEXTLINE",
            "                     fprintf(stderr, \"New string: \\\"%s\\\".\\n\", new_tag_string);",
            "+                    // NOLINTNEXTLINE",
            "                     fprintf(stderr, \"string size %d, printed size %d.\\n\", (int)(unsigned int)new_string_size, size);",
            "-                    fprintf(stderr,\"Unable to copy new attribute to tag string!\\n\");",
            "+                    // NOLINTNEXTLINE",
            "+                    fprintf(stderr, \"Unable to copy new attribute to tag string!\\n\");",
            "                     tag = PLCTAG_ERR_CREATE;",
            "                 }",
            " ",
            "                 free(new_tag_string);",
            "             } else {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unable to allocate new tag string!\\n\");",
            "                 tag = PLCTAG_ERR_NO_MEM;",
            "             }",
            "         }",
            " ",
            "         if(tag < 0) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"!!! Failed to create tag for thread %d with error %s!\\n\", tid, plc_tag_decode_error(tag));",
            "             usage();",
            "         }",
            " ",
            "         args[tid].tid = tid;",
            "         args[tid].tag = tag;",
            "         args[tid].status = PLCTAG_STATUS_OK;",
            "         args[tid].iteration = 0;",
            "         args[tid].total_io_time = 0;",
            "         args[tid].min_io_time = 0;",
            "         args[tid].max_io_time = 0;",
            "     }",
            " ",
            "-    for(int tid=0; tid < num_threads  && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"--- Creating test thread %d.\\n\", args[tid].tid);",
            "-",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        thread[tid] = CreateThread( NULL,                       /* default security attributes */",
            "-                                    0,                          /* use default stack size      */",
            "-                                    test_runner,                /* thread function             */",
            "-                                    (LPVOID)&args[tid],         /* argument to thread function */",
            "-                                    (DWORD)0,                   /* use default creation flags  */",
            "-                                    (LPDWORD)NULL               /* do not need thread ID       */",
            "-                                  );",
            "-#else",
            "-        pthread_create(&thread[tid], NULL, test_runner, (void*)&args[tid]);",
            "-#endif",
            "+        compat_thread_create(&thread[tid], test_runner, (void *)&args[tid]);",
            "     }",
            " ",
            "     /* wait for threads to create and start. */",
            "-    util_sleep_ms(100);",
            "+    compat_sleep_ms(100, NULL);",
            " ",
            "     /* launch the threads */",
            "     go = 1;",
            " ",
            "-    start = util_time_ms();",
            "+    start = compat_time_ms();",
            " ",
            "-    while(go && (--count_down) > 0) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(go && (--count_down) > 0) { compat_sleep_ms(100, NULL); }",
            " ",
            "     go = 0;",
            " ",
            "-    total_run_time = util_time_ms() - start;",
            "+    total_run_time = compat_time_ms() - start;",
            " ",
            "     success = 1;",
            " ",
            "     /* wait for the threads to stop. */",
            "-    util_sleep_ms(100);",
            "+    compat_sleep_ms(100, NULL);",
            " ",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        WaitForSingleObject(thread[tid], (DWORD)INFINITE);",
            "-#else",
            "-        pthread_join(thread[tid], NULL);",
            "-#endif",
            "-    }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) { compat_thread_join(thread[tid], NULL); }",
            " ",
            "     /* close the tags but get the group first. */",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "         args[tid].group = plc_tag_get_int_attribute(args[tid].tag, \"connection_group_id\", -1);",
            "         plc_tag_destroy(args[tid].tag);",
            "     }",
            " ",
            "     /* check the status */",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-        if(args[tid].status != PLCTAG_STATUS_OK) {",
            "-            success = 0;",
            "-        }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "+        if(args[tid].status != PLCTAG_STATUS_OK) { success = 0; }",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"--- All test threads terminated after running %\" PRId64 \"ms.\\n\", total_run_time);",
            " ",
            "-    if(!success) {",
            "-        fprintf(stderr,\"*** Test FAILED!\\n\");",
            "-    } else {",
            "-        fprintf(stderr,\"*** Test SUCCEEDED!\\n\");",
            "-    }",
            "-",
            "     /* print out statistics. */",
            "-    for(int tid=0; tid < num_threads; tid++) {",
            "-        fprintf(stderr,\"--- Thread %d in group %d ran %d iterations with a total io time of %\" PRId64 \"ms and min/avg/max of %\" PRId64 \"ms/%\" PRId64 \"ms/%\" PRId64 \"ms.\\n\", tid, args[tid].group, args[tid].iteration, args[tid].total_io_time, args[tid].min_io_time, args[tid].total_io_time/args[tid].iteration, args[tid].max_io_time);",
            "+    for(int tid = 0; tid < num_threads; tid++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr,",
            "+                \"--- Thread %d in group %d ran %d iterations with a total io time of %\" PRId64 \"ms and min/avg/max of %\" PRId64",
            "+                \"ms/%\" PRId64 \"ms/%\" PRId64 \"ms.\\n\",",
            "+                tid, args[tid].group, args[tid].iteration, args[tid].total_io_time, args[tid].min_io_time,",
            "+                args[tid].total_io_time / args[tid].iteration, args[tid].max_io_time);",
            "     }",
            " ",
            "-    return 0;",
            "+    if(!success) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"*** Test FAILED!\\n\");",
            "+        return 1;",
            "+    } else {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"*** Test SUCCEEDED!\\n\");",
            "+        return 0;",
            "+    }",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_raw_cip.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_raw_cip.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_raw_cip.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,56 +28,41 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdbool.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,4,0",
            "+#define REQUIRED_VERSION 2, 4, 0",
            " ",
            " #define TAG_STRING \"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&name=@raw\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int size = 0;",
            "     int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "     int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "     int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "-    uint8_t raw_payload[] = { 0x55, /* list tags */",
            "-                              0x03,",
            "-                              0x20,",
            "-                              0x6b,",
            "-                              0x25,",
            "-                              0x00,",
            "-                              0x00,",
            "-                              0x00,",
            "-                              0x04,",
            "-                              0x00,",
            "-                              0x02,",
            "-                              0x00,",
            "-                              0x07,",
            "-                              0x00,",
            "-                              0x08,",
            "-                              0x00,",
            "-                              0x01,",
            "-                              0x00 };",
            "+    uint8_t raw_payload[] = {0x55, /* list tags */",
            "+                             0x03, 0x20, 0x6b, 0x25, 0x00, 0x00, 0x00, 0x04, 0x00,",
            "+                             0x02, 0x00, 0x07, 0x00, 0x08, 0x00, 0x01, 0x00};",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major, version_minor, version_patch);",
            "+        printf(\"Required compatible library version %d.%d.%d not available, found %d.%d.%d!\\n\", REQUIRED_VERSION, version_major,",
            "+               version_minor, version_patch);",
            "         return 1;",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     printf(\"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            " ",
            "@@ -90,53 +75,51 @@",
            " ",
            "     /*",
            "      * Set the tag buffer size so that we can write the request.",
            "      * Note that this returns the old size (if any) or a negative error.",
            "      */",
            "     rc = plc_tag_set_size(tag, (int)(unsigned int)sizeof(raw_payload));",
            "     if(rc < 0) {",
            "-        printf( \"Unable to set the payload size on the tag %s!\\n\", plc_tag_decode_error(rc));",
            "+        printf(\"Unable to set the payload size on the tag %s!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* set up the raw data */",
            "-    for(int i=0; i < (int)(unsigned int)sizeof(raw_payload) && rc == PLCTAG_STATUS_OK; i++) {",
            "+    for(int i = 0; i < (int)(unsigned int)sizeof(raw_payload) && rc == PLCTAG_STATUS_OK; i++) {",
            "         rc = plc_tag_set_uint8(tag, i, raw_payload[i]);",
            "     }",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        printf( \"Unable to set the payload data in the tag %s!\\n\", plc_tag_decode_error(rc));",
            "+        printf(\"Unable to set the payload data in the tag %s!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* get the data, Write is the only action supported. */",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        printf(\"ERROR: Unable to send the raw request! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        printf(\"ERROR: Unable to send the raw request! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* get the size of the returned data. */",
            "     size = plc_tag_get_size(tag);",
            "     if(size <= 0) {",
            "         printf(\"ERROR: Unable to get the data size!\\n\");",
            "         plc_tag_destroy(tag);",
            "         return 1;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(int i=0; i < size; i++) {",
            "+    for(int i = 0; i < size; i++) {",
            "         uint8_t data = plc_tag_get_uint8(tag, i);",
            "-        printf(\"data[%d]=%u (%x)\\n\",i, (unsigned int)data, (unsigned int)data);",
            "+        printf(\"data[%d]=%u (%x)\\n\", i, (unsigned int)data, (unsigned int)data);",
            "     }",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     printf(\"SUCCESS!\\n\");",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_reconnect.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_reconnect.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_reconnect.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,128 +28,126 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,10",
            "+#define REQUIRED_VERSION 2, 1, 10",
            " ",
            "-//#define TAG_PATH \"protocol=ab-eip&gateway=10.206.1.39&path=1,5&cpu=LGX&elem_size=4&elem_count=1&name=TestBigArray&debug=4\"",
            " #define TAG_PATH \"protocol=modbus-tcp&gateway=127.0.0.1:5020&path=0&elem_count=1&name=hr0\"",
            "-//#define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.38&cpu=PLC5&elem_size=2&elem_count=1&name=N7:0&debug=4\"",
            " #define ELEM_COUNT 1",
            " #define ELEM_SIZE 2",
            "-//#define ELEM_SIZE 2",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int create_tag()",
            "-{",
            "+int create_tag(void) {",
            "     int32_t tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "-        exit( -tag);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        exit(-tag);",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "-        exit( -rc);",
            "+        exit(-rc);",
            "     }",
            " ",
            "     return tag;",
            " }",
            " ",
            " ",
            "-void update_tag(int32_t tag)",
            "-{",
            "+void update_tag(int32_t tag) {",
            "     int rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "-        exit( -rc);",
            "+        exit(-rc);",
            "     }",
            " ",
            "     /* print out the data */",
            "-    for(int i=0; i < ELEM_COUNT; i++) {",
            "+    for(int i = 0; i < ELEM_COUNT; i++) {",
            "         // fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int32(tag,(i*ELEM_SIZE)));",
            "-       fprintf(stderr,\"data[%d]=%d\\n\",i,plc_tag_get_int16(tag,(i*ELEM_SIZE)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"data[%d]=%d\\n\", i, plc_tag_get_int16(tag, (i * ELEM_SIZE)));",
            "     }",
            " ",
            "     /* now test a write */",
            "-    for(int i=0; i < ELEM_COUNT; i++) {",
            "+    for(int i = 0; i < ELEM_COUNT; i++) {",
            "         // int32_t val = plc_tag_get_int32(tag,(i*ELEM_SIZE));",
            "-        int16_t val = plc_tag_get_int16(tag, (i*ELEM_SIZE));",
            "+        int16_t val = plc_tag_get_int16(tag, (i * ELEM_SIZE));",
            " ",
            "-        val = (int16_t)((int16_t)val+(int16_t)1);",
            "+        val = (int16_t)((int16_t)val + (int16_t)1);",
            " ",
            "-        fprintf(stderr,\"Setting element %d to %d\\n\",i,val);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Setting element %d to %d\\n\", i, val);",
            " ",
            "         // plc_tag_set_int32(tag,(i*ELEM_SIZE),val);",
            "-       plc_tag_set_int16(tag,(i*ELEM_SIZE),val);",
            "+        plc_tag_set_int16(tag, (i * ELEM_SIZE), val);",
            "     }",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "-        exit( -rc);",
            "+        exit(-rc);",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int main(int argc, char **argv)",
            "-{",
            "+int main(int argc, char **argv) {",
            "     int32_t tag = 0;",
            "     int wait_time_sec = 0;",
            " ",
            "     /* check library API version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            " ",
            "     if(argc == 2) {",
            "         wait_time_sec = atoi(argv[1]);",
            "     } else {",
            "-        fprintf(stderr,\"Usage: test_reconnect <number of seconds to pause>\\n\");",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Usage: test_reconnect <number of seconds to pause>\\n\");",
            "         return 1;",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* create the tag */",
            "     tag = create_tag();",
            " ",
            "     /* update the data */",
            "     update_tag(tag);",
            " ",
            "-    fprintf(stderr, \"Waiting for %dms.\\n\",(wait_time_sec*1000));",
            "-    util_sleep_ms(wait_time_sec * 1000);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Waiting for %dms.\\n\", (wait_time_sec * 1000));",
            "+    compat_sleep_ms((uint32_t)wait_time_sec * 1000, NULL);",
            " ",
            "     /* update the data again */",
            "     update_tag(tag);",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_shutdown.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_shutdown.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_shutdown.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,267 +28,236 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            "-#include <string.h>",
            " #include <stdlib.h>",
            "-#include <inttypes.h>",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-#include <Windows.h>",
            "-#else",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            " #include <string.h>",
            "-#include <sys/time.h>",
            "-#include <signal.h>",
            "-#endif",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            "-",
            " ",
            " ",
            "-#define REQUIRED_VERSION 2,5,5",
            "-#define TAG_ATTRIBS_TMPL \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=LGX&elem_type=DINT&elem_count=1&name=TestBigArray[%d]&auto_sync_read_ms=200&auto_sync_write_ms=20\"",
            "+#define REQUIRED_VERSION 2, 5, 5",
            "+#define TAG_ATTRIBS_TMPL \\",
            "+    \"protocol=ab_eip&gateway=127.0.0.1&path=1,0&plc=ControlLogix&elem_type=DINT&elem_count=1&name=TestBigArray[%d]&auto_sync_read_ms=200&auto_sync_write_ms=20\"",
            " #define DATA_TIMEOUT (5000)",
            " #define RUN_PERIOD (10000)",
            " #define READ_SLEEP_MS (100)",
            " #define WRITE_SLEEP_MS (300)",
            " ",
            " #define READ_PERIOD_MS (200)",
            " ",
            " static volatile int read_start_count = 0;",
            " static volatile int read_complete_count = 0;",
            " static volatile int write_start_count = 0;",
            " static volatile int write_complete_count = 0;",
            " ",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-DWORD __stdcall reader_function(void* tag_arg)",
            "-#else",
            "-void* reader_function(void* tag_arg)",
            "-#endif",
            "-{",
            "+static void *reader_function(void *tag_arg);",
            "+static void *writer_function(void *tag_arg);",
            "+static void tag_callback(int32_t tag_id, int event, int status, void *not_used);",
            "+",
            "+",
            "+#define NUM_TAGS (10)",
            "+",
            "+",
            "+int main(void) {",
            "+    int rc = PLCTAG_STATUS_OK;",
            "+    char tag_attr_str[sizeof(TAG_ATTRIBS_TMPL) + 10] = {0};",
            "+    compat_thread_t read_threads[NUM_TAGS];",
            "+    compat_thread_t write_threads[NUM_TAGS];",
            "+    int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "+    int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "+    int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "+",
            "+    /* check the library version. */",
            "+    if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\\n\", REQUIRED_VERSION);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Available library version is %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            "+        exit(1);",
            "+    }",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            "+",
            "+    plc_tag_set_debug_level(PLCTAG_DEBUG_WARN);",
            "+",
            "+    /* create all the tags. */",
            "+    fprintf(stderr, \"Creating tag handles \");",
            "+",
            "+    for(int i = 0; i < NUM_TAGS; i++) {",
            "+        int32_t tag_id = PLCTAG_ERR_CREATE;",
            "+",
            "+        // NOLINTNEXTLINE",
            "+        snprintf(tag_attr_str, sizeof(tag_attr_str), TAG_ATTRIBS_TMPL, (int32_t)i);",
            "+        tag_id = plc_tag_create_ex(tag_attr_str, tag_callback, NULL, DATA_TIMEOUT);",
            "+",
            "+        if(tag_id <= 0) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error %s trying to create tag %d!\\n\", plc_tag_decode_error(tag_id), i);",
            "+            plc_tag_shutdown();",
            "+            return 1;",
            "+        }",
            "+",
            "+        /* create read and write thread for this tag. */",
            "+        /* FIXME - check error returns! */",
            "+        compat_thread_create(&read_threads[i], reader_function, (void *)(intptr_t)tag_id);",
            "+        compat_thread_create(&write_threads[i], writer_function, (void *)(intptr_t)tag_id);",
            "+",
            "+        fprintf(stderr, \".\");",
            "+    }",
            "+",
            "+    fprintf(stderr, \"\\nWaiting for threads to stabilize %dms.\\n\", RUN_PERIOD / 2);",
            "+",
            "+    /* let everything run for a while */",
            "+    compat_sleep_ms(RUN_PERIOD / 2, NULL);",
            "+",
            "+    /* forcible shut down the entire library. */",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Forcing library shutdown.\\n\");",
            "+",
            "+    plc_tag_set_debug_level(PLCTAG_DEBUG_INFO);",
            "+",
            "+    plc_tag_shutdown();",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Waiting for threads to quit.\\n\");",
            "+",
            "+    for(int i = 0; i < NUM_TAGS; i++) {",
            "+        compat_thread_join(read_threads[i], NULL);",
            "+        compat_thread_join(write_threads[i], NULL);",
            "+    }",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Done.\\n\");",
            "+",
            "+    return rc;",
            "+}",
            "+",
            "+",
            "+void *reader_function(void *tag_arg) {",
            "     int32_t tag_id = (int32_t)(intptr_t)tag_arg;",
            "-    int64_t start_time = util_time_ms();",
            "+    int64_t start_time = compat_time_ms();",
            "     int64_t run_until = start_time + RUN_PERIOD;",
            "     int iteration = 1;",
            " ",
            "-    while(run_until > util_time_ms()) {",
            "+    while(run_until > compat_time_ms()) {",
            "         int status = plc_tag_status(tag_id);",
            "         int32_t val = plc_tag_get_int32(tag_id, 0);",
            " ",
            "         if(status < 0) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %\" PRId32 \" has error status %s, terminating!\\n\", tag_id, plc_tag_decode_error(status));",
            "             break;",
            "         }",
            " ",
            "-        fprintf(stderr, \"READER: Tag %\" PRId32 \" iteration %d, got value: %d at time %\" PRId64 \"\\n\", tag_id, iteration++, val, util_time_ms()-start_time);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"READER: Tag %\" PRId32 \" iteration %d, got value: %d at time %\" PRId64 \"\\n\", tag_id, iteration++, val,",
            "+                compat_time_ms() - start_time);",
            " ",
            "-        util_sleep_ms(READ_SLEEP_MS);",
            "+        compat_sleep_ms(READ_SLEEP_MS, NULL);",
            "     }",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    return (DWORD)0;",
            "-#else",
            "-    return NULL;",
            "-#endif",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Reader thread for tag ID %\" PRId32 \" exiting.\\n\", tag_id);",
            "+",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-DWORD __stdcall writer_function(void* tag_arg)",
            "-#else",
            "-void* writer_function(void* tag_arg)",
            "-#endif",
            "-{",
            "+void *writer_function(void *tag_arg) {",
            "     int32_t tag_id = (int32_t)(intptr_t)tag_arg;",
            "-    int64_t start_time = util_time_ms();",
            "+    int64_t start_time = compat_time_ms();",
            "     int64_t run_until = start_time + RUN_PERIOD;",
            "     int iteration = 1;",
            " ",
            "-    util_sleep_ms(WRITE_SLEEP_MS);",
            "+    compat_sleep_ms(WRITE_SLEEP_MS, NULL);",
            " ",
            "-    while(run_until > util_time_ms()) {",
            "+    while(run_until > compat_time_ms()) {",
            "         int32_t val = plc_tag_get_int32(tag_id, 0);",
            "-        int32_t new_val = ((val+1) > 499) ? 0 : (val+1);",
            "+        int32_t new_val = ((val + 1) > 499) ? 0 : (val + 1);",
            "         int status = plc_tag_status(tag_id);",
            " ",
            "         if(status < 0) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %\" PRId32 \" has error status %s, terminating!\\n\", tag_id, plc_tag_decode_error(status));",
            "             break;",
            "         }",
            " ",
            "         /* write the value */",
            "         plc_tag_set_int32(tag_id, 0, new_val);",
            " ",
            "-        fprintf(stderr, \"WRITER: Tag %\" PRId32 \" iteration %d, wrote value: %d at time %\" PRId64 \"\\n\", tag_id, iteration++, new_val, util_time_ms()-start_time);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"WRITER: Tag %\" PRId32 \" iteration %d, wrote value: %d at time %\" PRId64 \"\\n\", tag_id, iteration++,",
            "+                new_val, compat_time_ms() - start_time);",
            " ",
            "-        util_sleep_ms(WRITE_SLEEP_MS);",
            "+        compat_sleep_ms(WRITE_SLEEP_MS, NULL);",
            "     }",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    return (DWORD)0;",
            "-#else",
            "-    return NULL;",
            "-#endif",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Writer thread for tag ID %\" PRId32 \" exiting.\\n\", tag_id);",
            "+",
            "+    return 0;",
            " }",
            " ",
            " ",
            "-void tag_callback(int32_t tag_id, int event, int status, void *not_used)",
            "-{",
            "+void tag_callback(int32_t tag_id, int event, int status, void *not_used) {",
            "     (void)not_used;",
            " ",
            "     /* handle the events. */",
            "     switch(event) {",
            "         case PLCTAG_EVENT_CREATED:",
            "-            fprintf(stderr,\"Tag %\" PRId32 \" created.\\n\", tag_id);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Tag %\" PRId32 \" created.\\n\", tag_id);",
            "             break;",
            "-        ",
            "+",
            "         case PLCTAG_EVENT_ABORTED:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %\" PRId32 \" automatic operation was aborted!\\n\", tag_id);",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_DESTROYED:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %\" PRId32 \" was destroyed.\\n\", tag_id);",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_COMPLETED:",
            "             read_complete_count++;",
            "-            fprintf(stderr, \"Tag %\" PRId32 \" automatic read operation completed with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Tag %\" PRId32 \" automatic read operation completed with status %s.\\n\", tag_id,",
            "+                    plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_READ_STARTED:",
            "             read_start_count++;",
            "-            fprintf(stderr, \"Tag %\" PRId32 \" automatic read operation started with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Tag %\" PRId32 \" automatic read operation started with status %s.\\n\", tag_id,",
            "+                    plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_COMPLETED:",
            "             write_complete_count++;",
            "-            fprintf(stderr, \"Tag %\" PRId32 \" automatic write operation completed with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Tag %\" PRId32 \" automatic write operation completed with status %s.\\n\", tag_id,",
            "+                    plc_tag_decode_error(status));",
            "             break;",
            " ",
            "         case PLCTAG_EVENT_WRITE_STARTED:",
            "             write_start_count++;",
            "-            fprintf(stderr, \"Tag %\" PRId32 \" automatic write operation started with status %s.\\n\", tag_id, plc_tag_decode_error(status));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Tag %\" PRId32 \" automatic write operation started with status %s.\\n\", tag_id,",
            "+                    plc_tag_decode_error(status));",
            " ",
            "             break;",
            " ",
            "         default:",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Tag %\" PRId32 \" unexpected event %d!\\n\", tag_id, event);",
            "             break;",
            "-",
            "-    }",
            "-}",
            "-",
            "-",
            "-",
            "-#define NUM_TAGS (10)",
            "-",
            "-",
            "-int main(int argc, char **argv)",
            "-{",
            "-    int rc = PLCTAG_STATUS_OK;",
            "-    char tag_attr_str[sizeof(TAG_ATTRIBS_TMPL)+10] = {0};",
            "-    int32_t tags[NUM_TAGS] = {0};",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    HANDLE read_threads[NUM_TAGS];",
            "-    HANDLE write_threads[NUM_TAGS];",
            "-#else",
            "-    pthread_t read_threads[NUM_TAGS];",
            "-    pthread_t write_threads[NUM_TAGS];",
            "-#endif",
            "-    int version_major = plc_tag_get_int_attribute(0, \"version_major\", 0);",
            "-    int version_minor = plc_tag_get_int_attribute(0, \"version_minor\", 0);",
            "-    int version_patch = plc_tag_get_int_attribute(0, \"version_patch\", 0);",
            "-",
            "-    (void)argc;",
            "-    (void)argv;",
            "-",
            "-    /* check the library version. */",
            "-    if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\\n\", REQUIRED_VERSION);",
            "-        fprintf(stderr, \"Available library version is %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            "-        exit(1);",
            "-    }",
            "-",
            "-    fprintf(stderr, \"Starting with library version %d.%d.%d.\\n\", version_major, version_minor, version_patch);",
            "-",
            "-    plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            "-",
            "-    /* create all the tags. */",
            "-    for(int i=0; i<NUM_TAGS; i++) {",
            "-        int32_t tag_id = PLCTAG_ERR_CREATE;",
            "-",
            "-        snprintf(tag_attr_str, sizeof(tag_attr_str), TAG_ATTRIBS_TMPL, (int32_t)i);",
            "-        tag_id = plc_tag_create_ex(tag_attr_str, tag_callback, NULL, DATA_TIMEOUT);",
            "-",
            "-        if(tag_id <= 0) {",
            "-            fprintf(stderr, \"Error %s trying to create tag %d!\\n\", plc_tag_decode_error(tag_id), i);",
            "-            plc_tag_shutdown();",
            "-            return 1;",
            "-        }",
            "-",
            "-        /* create read and write thread for this tag. */",
            "-        /* FIXME - check error returns! */",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        read_threads[i] = CreateThread(NULL,                       /* default security attributes */",
            "-            0,                          /* use default stack size      */",
            "-            reader_function,            /* thread function             */",
            "-            (LPVOID)(intptr_t)tag_id,   /* argument to thread function */",
            "-            (DWORD)0,                   /* use default creation flags  */",
            "-            (LPDWORD)NULL               /* do not need thread ID       */",
            "-        );",
            "-#else",
            "-        pthread_create(&read_threads[i], NULL, reader_function, (void*)(intptr_t)tag_id);",
            "-#endif",
            "-",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        write_threads[i] = CreateThread(NULL,                       /* default security attributes */",
            "-            0,                          /* use default stack size      */",
            "-            writer_function,            /* thread function             */",
            "-            (LPVOID)(intptr_t)tag_id,   /* argument to thread function */",
            "-            (DWORD)0,                   /* use default creation flags  */",
            "-            (LPDWORD)NULL               /* do not need thread ID       */",
            "-        );",
            "-#else",
            "-        pthread_create(&write_threads[i], NULL, writer_function, (void*)(intptr_t)tag_id);",
            "-#endif",
            "-",
            "-        tags[i] = tag_id;",
            "-    }",
            "-",
            "-    /* let everything run for a while */",
            "-    util_sleep_ms(RUN_PERIOD/2);",
            "-",
            "-    /* forcible shut down the entire library. */",
            "-    fprintf(stderr, \"Forcing library shutdown.\\n\");",
            "-    plc_tag_shutdown();",
            "-",
            "-    fprintf(stderr, \"Waiting for threads to quit.\\n\");",
            "-",
            "-    for(int i=0; i<NUM_TAGS; i++) {",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        if (read_threads[i] != 0) {",
            "-            WaitForSingleObject(read_threads[i], (DWORD)INFINITE);",
            "-        }",
            "-#else",
            "-        pthread_join(read_threads[i], NULL);",
            "-#endif",
            "-",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        if (write_threads[i] != 0) {",
            "-            WaitForSingleObject(write_threads[i], (DWORD)INFINITE);",
            "-        }",
            "-#else",
            "-        pthread_join(write_threads[i], NULL);",
            "-#endif",
            "     }",
            "-",
            "-    fprintf(stderr, \"Done.\\n\");",
            "-",
            "-    return rc;",
            " }",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_special.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_special.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_special.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,175 +28,191 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_CREATE_TIMEOUT (100)",
            " ",
            "-int test_version(void)",
            "-{",
            "+int test_version(void) {",
            "     int32_t tag = 0;",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    char ver[16] = {0,};",
            "+    char ver[16] = {",
            "+        0,",
            "+    };",
            " ",
            "-    fprintf(stderr,\"Testing version tag.\\n\");",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Testing version tag.\\n\");",
            " ",
            "     tag = plc_tag_create(\"make=system&family=library&name=version&debug=4\", TAG_CREATE_TIMEOUT);",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return tag;",
            "     }",
            " ",
            "     plc_tag_read(tag, 0);",
            " ",
            "     rc = plc_tag_get_string(tag, 0, ver, (int)(unsigned int)sizeof(ver));",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"ERROR: %s: Could not get version string!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "-    fprintf(stderr,\"Library version %s\\n\", ver);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Library version %s\\n\", ver);",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int test_debug(void)",
            "-{",
            "+int test_debug(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int32_t tag = 0;",
            "     uint32_t old_debug, new_debug;",
            " ",
            "-    fprintf(stderr,\"Testing debug tag.\\n\");",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Testing debug tag.\\n\");",
            " ",
            "     tag = plc_tag_create(\"make=system&family=library&name=debug&debug=4\", TAG_CREATE_TIMEOUT);",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return tag;",
            "     }",
            " ",
            "     rc = plc_tag_read(tag, 0);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to read debug level!\\n\", plc_tag_decode_error(rc));",
            "         return rc;",
            "     }",
            " ",
            "-    old_debug = plc_tag_get_uint32(tag,0);",
            "+    old_debug = plc_tag_get_uint32(tag, 0);",
            " ",
            "-    fprintf(stderr,\"Current debug level is %d\\n\",old_debug);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Current debug level is %d\\n\", old_debug);",
            " ",
            "     new_debug = (old_debug == 3 ? 4 : 3);",
            " ",
            "-    fprintf(stderr,\"Changing debug level to %d\\n\", new_debug);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Changing debug level to %d\\n\", new_debug);",
            " ",
            "     plc_tag_set_uint32(tag, 0, new_debug);",
            " ",
            "     rc = plc_tag_write(tag, 0);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to write debug level!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "     rc = plc_tag_read(tag, 0);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to read debug level!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "-    new_debug = plc_tag_get_uint32(tag,0);",
            "+    new_debug = plc_tag_get_uint32(tag, 0);",
            " ",
            "     if(old_debug == 3) {",
            "         if(new_debug == 4) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"New debug level is correctly 4.\\n.\");",
            "         } else {",
            "-            fprintf(stderr,\"New debug level is %d but should be 4.\\n\", new_debug);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"New debug level is %d but should be 4.\\n\", new_debug);",
            "             plc_tag_destroy(tag);",
            "             return PLCTAG_ERR_BAD_REPLY;",
            "         }",
            "     } else {",
            "         if(new_debug == 3) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"New debug level is correctly 3.\\n.\");",
            "         } else {",
            "-            fprintf(stderr,\"New debug level is %d but should be 3.\\n\", new_debug);",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"New debug level is %d but should be 3.\\n\", new_debug);",
            "             plc_tag_destroy(tag);",
            "             return PLCTAG_ERR_BAD_DATA;",
            "         }",
            "     }",
            " ",
            "-    fprintf(stderr,\"Changing debug level back to %d\\n\", old_debug);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Changing debug level back to %d\\n\", old_debug);",
            " ",
            "     plc_tag_set_uint32(tag, 0, old_debug);",
            " ",
            "     rc = plc_tag_write(tag, 0);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to write debug level!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "     rc = plc_tag_read(tag, 0);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to read debug level!\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         return rc;",
            "     }",
            " ",
            "-    new_debug = plc_tag_get_uint32(tag,0);",
            "+    new_debug = plc_tag_get_uint32(tag, 0);",
            " ",
            "     if(old_debug == new_debug) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Correctly set debug level back to old value %d.\\n\", old_debug);",
            "     } else {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to set debug level back to old value %d, was %d!\\n\", old_debug, new_debug);",
            "         plc_tag_destroy(tag);",
            "         return PLCTAG_ERR_BAD_DATA;",
            "     }",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     rc = test_version();",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to test \\\"version\\\" special tag!\\n\", plc_tag_decode_error(rc));",
            "         return rc;",
            "     }",
            " ",
            "     rc = test_debug();",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error %s trying to test \\\"debug\\\" special tag!\\n\", plc_tag_decode_error(rc));",
            "         return rc;",
            "     }",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_string.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_string.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_string.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2022 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,150 +28,183 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " /*",
            "  * Read an array of 48 STRINGs.  Note that the actual data size of a string is 88 bytes, not 82+4.",
            "  *",
            "  * STRING types are a DINT (4 bytes) followed by 82 bytes of characters.  Then two bytes of padding.",
            "  */",
            " ",
            "-#define REQUIRED_VERSION 2,4,10",
            "+/* need at least 2.6.3 for support for allow_field_resize flag. */",
            "+#define REQUIRED_VERSION 2, 6, 3",
            " ",
            "-static const char *tag_string = \"protocol=ab-eip&gateway=10.206.1.40&path=1,0&plc=ControlLogix&name=CB_Txt[0,0]\";",
            "+static const char *tag_string1 =",
            "+    \"protocol=ab-eip&gateway=10.206.1.40&path=1,0&plc=ControlLogix&name=CB_Txt[0,0]&str_is_counted=1&str_count_word_bytes=4&str_is_fixed_length=0&str_max_capacity=16&str_total_length=0&str_pad_bytes=0\";",
            "+static const char *tag_string2 =",
            "+    \"protocol=ab-eip&gateway=10.206.1.40&path=1,0&plc=ControlLogix&name=CB_Txt[0,0]&str_is_counted=1&str_count_word_bytes=4&str_is_fixed_length=0&str_max_capacity=16&str_total_length=0&str_pad_bytes=0&allow_field_resize=1\";",
            " ",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int test_string(const char *tag_string) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int offset = 0;",
            "     int str_cap = 0;",
            "     char *str = NULL;",
            " ",
            "-    /* check the library version. */",
            "-    if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "-        return 1;",
            "-    }",
            "+    do {",
            "+        tag = plc_tag_create(tag_string, DATA_TIMEOUT);",
            " ",
            "-    fprintf(stderr, \"Using library version %d.%d.%d.\\n\",",
            "-                                            plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_minor\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            "+        /* everything OK? */",
            "+        if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error %s creating tag!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        /* get the data */",
            "+        rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error %s trying to read tag!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        /* print out the data */",
            "+        str_cap = plc_tag_get_string_length(tag, offset) + 1; /* +1 for the zero termination. */",
            "+        str = (char *)malloc((size_t)(unsigned int)str_cap);",
            "+        if(!str) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Unable to allocate memory for the string!\\n\");",
            "+            rc = PLCTAG_ERR_NO_MEM;",
            "+            break;",
            "+        }",
            "+",
            "+        rc = plc_tag_get_string(tag, offset, str, str_cap);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Error %s getting string value!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            " ",
            "-    /* turn off debugging output. */",
            "-    plc_tag_set_debug_level(PLCTAG_DEBUG_INFO);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"tag string data = '%s'\\n\", str);",
            " ",
            "-    tag = plc_tag_create(tag_string, DATA_TIMEOUT);",
            "-",
            "-    /* everything OK? */",
            "-    if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error %s creating tag!\\n\", plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return rc;",
            "-    }",
            "-",
            "-    /* get the data */",
            "-    rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Error %s trying to read tag!\\n\", plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag);",
            "-        return rc;",
            "-    }",
            "-",
            "-    /* print out the data */",
            "-    str_cap = plc_tag_get_string_length(tag, offset) + 1; /* +1 for the zero termination. */",
            "-    str = (char *)malloc((size_t)(unsigned int)str_cap);",
            "-    if(!str) {",
            "-        fprintf(stderr, \"Unable to allocate memory for the string!\\n\");",
            "-        plc_tag_destroy(tag);",
            "-        return PLCTAG_ERR_NO_MEM;",
            "-    }",
            "-",
            "-    rc = plc_tag_get_string(tag, offset, str, str_cap);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Error %s getting string value!\\n\", plc_tag_decode_error(rc));",
            "         free(str);",
            "-        plc_tag_destroy(tag);",
            "-        return rc;",
            "-    }",
            " ",
            "-    fprintf(stderr, \"tag string data = '%s'\\n\", str);",
            "+        /* now try to overwrite memory */",
            "+        str_cap = plc_tag_get_string_capacity(tag, offset) + 10;",
            "+        str = (char *)malloc((size_t)(unsigned int)str_cap);",
            "+        if(!str) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Unable to allocate memory for the string write test!\\n\");",
            "+            rc = PLCTAG_ERR_NO_MEM;",
            "+            break;",
            "+        }",
            "+",
            "+        /* clear out the string memory */",
            "+        // NOLINTNEXTLINE",
            "+        memset(str, 0, (unsigned int)str_cap);",
            "+",
            "+        /* try to write a shorter string but with a long capacity. */",
            "+",
            "+        /* put in a tiny string */",
            "+        for(int i = 0; (i < 2) && i < (str_cap - 1); i++) { str[i] = (char)(0x30 + (i % 10)); /* 01234567890123456789... */ }",
            "+",
            "+        /* try to set the string. */",
            "+        rc = plc_tag_set_string(tag, offset, str);",
            "+        if(rc == PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Setting the tiny string succeeded.\\n\");",
            "+        } else {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Got error %s setting string!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        /* put in a larger, but still valid, string */",
            "+        for(int i = 0; (i < 6) && i < (str_cap - 1); i++) { str[i] = (char)(0x30 + (i % 10)); /* 01234567890123456789... */ }",
            "+",
            "+        /* try to set the string. */",
            "+        rc = plc_tag_set_string(tag, offset, str);",
            "+        if(rc == PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Setting the small string succeeded.\\n\");",
            "+        } else {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Got error %s setting string!\\n\", plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        /* fill it completely with garbage */",
            "+        for(int i = 0; i < (str_cap - 1); i++) { str[i] = (char)(0x30 + (i % 10)); /* 01234567890123456789... */ }",
            "+",
            "+        /* try to set the string. */",
            "+        rc = plc_tag_set_string(tag, offset, str);",
            "+        if(rc == PLCTAG_ERR_TOO_LARGE) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"Correctly got error %s setting string!\\n\", plc_tag_decode_error(rc));",
            "+            rc = PLCTAG_STATUS_OK;",
            "+        } else {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(",
            "+                stderr,",
            "+                \"Should have error PLCTAG_ERR_TOO_LARGE but got %s trying to set string value with capacity longer than actual!\\n\",",
            "+                plc_tag_decode_error(rc));",
            "+            rc = PLCTAG_ERR_BAD_STATUS;",
            "+            break;",
            "+        }",
            "+    } while(0);",
            " ",
            "+    /* we are done */",
            "     free(str);",
            "+    plc_tag_destroy(tag);",
            " ",
            "-    /* now try to overwrite memory */",
            "-    str_cap = plc_tag_get_string_capacity(tag, offset) + 1;",
            "-    str = (char *)malloc((size_t)(unsigned int)str_cap);",
            "-    if(!str) {",
            "-        fprintf(stderr, \"Unable to allocate memory for the string write test!\\n\");",
            "-        plc_tag_destroy(tag);",
            "-        return PLCTAG_ERR_NO_MEM;",
            "-    }",
            "-",
            "-    /* clear out the string memory */",
            "-    memset(str, 0, (unsigned int)str_cap);",
            "+    return rc;",
            "+}",
            " ",
            "-    /* try to write a shorter string but with a long capacity. */",
            "+int main(void) {",
            "+    int rc;",
            " ",
            "-    /* put in a tiny string */",
            "-    for(int i=0; (i < 2) && i < (str_cap - 1); i++) {",
            "-        str[i] = (char)(0x30 + (i % 10)); /* 01234567890123456789... */",
            "+    /* check the library version. */",
            "+    if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "+        return 1;",
            "     }",
            " ",
            "-    /* try to set the string. */",
            "-    rc = plc_tag_set_string(tag, offset, str);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Correctly got error %s setting string!\\n\", plc_tag_decode_error(rc));",
            "-    } else {",
            "-        fprintf(stderr, \"Should have received an error trying to set string value with capacity longer than actual!\\n\");",
            "-        free(str);",
            "-        plc_tag_destroy(tag);",
            "-        return PLCTAG_ERR_BAD_STATUS;",
            "-    }",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Using library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "+            plc_tag_get_int_attribute(0, \"version_minor\", -1), plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            " ",
            "-    /* fill it completely with garbage */",
            "-    for(int i=0; i < (str_cap - 1); i++) {",
            "-        str[i] = (char)(0x30 + (i % 10)); /* 01234567890123456789... */",
            "+    /* turn off debugging output. */",
            "+    plc_tag_set_debug_level(PLCTAG_DEBUG_WARN);",
            "+",
            "+    /* we expect a failure here. */",
            "+    rc = test_string(tag_string1);",
            "+    if(rc != PLCTAG_ERR_NOT_ALLOWED) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unexpected failure error %s!\", plc_tag_decode_error(rc));",
            "+        return 1;",
            "     }",
            " ",
            "-    /* try to set the string. */",
            "-    rc = plc_tag_set_string(tag, offset, str);",
            "+    /* We expect success here */",
            "+    rc = test_string(tag_string2);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr, \"Correctly got error %s setting string!\\n\", plc_tag_decode_error(rc));",
            "-    } else {",
            "-        fprintf(stderr, \"Should have received an error trying to set string value with capacity longer than actual!\\n\");",
            "-        free(str);",
            "-        plc_tag_destroy(tag);",
            "-        return PLCTAG_ERR_BAD_STATUS;",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unexpected failure %s!\", plc_tag_decode_error(rc));",
            "+        return 1;",
            "     }",
            " ",
            "-    // /* try to write it. */",
            "-    // rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "-    // if(rc != PLCTAG_STATUS_OK) {",
            "-    //     fprintf(stderr, \"Error %s writing string!\\n\", plc_tag_decode_error(rc));",
            "-    //     free(str);",
            "-    //     plc_tag_destroy(tag);",
            "-    //     return rc;",
            "-    // }",
            "-",
            "-",
            "-    /* we are done */",
            "-    free(str);",
            "-    plc_tag_destroy(tag);",
            "-",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_tag_attributes.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_tag_attributes.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_tag_attributes.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,71 +28,67 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            " #include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <limits.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,3",
            "+#define REQUIRED_VERSION 2, 1, 3",
            " ",
            " #define TAG_PATH \"protocol=ab-eip&gateway=10.206.1.39&path=1,5&cpu=LGX&elem_count=1&name=TestDINTArray&read_cache_ms=100\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            " static void expect_match(int32_t tag, const char *attrib, int match_val);",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag;",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* turn on debugging. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         exit(1);",
            "     }",
            " ",
            "     if((rc = plc_tag_status(tag)) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(rc));",
            "         plc_tag_destroy(tag);",
            "         exit(1);",
            "     }",
            " ",
            "     printf(\"Testing library attributes.\\n\");",
            " ",
            "     expect_match(0, \"debug\", PLCTAG_DEBUG_DETAIL);",
            " ",
            "-    printf(\"\\tLibrary version from attributes %d.%d.%d\\n\",",
            "-                    plc_tag_get_int_attribute(0, \"version_major\", 0),",
            "-                    plc_tag_get_int_attribute(0, \"version_minor\", 0),",
            "-                    plc_tag_get_int_attribute(0, \"version_patch\", 0)",
            "-                    );",
            "+    printf(\"\\tLibrary version from attributes %d.%d.%d\\n\", plc_tag_get_int_attribute(0, \"version_major\", 0),",
            "+           plc_tag_get_int_attribute(0, \"version_minor\", 0), plc_tag_get_int_attribute(0, \"version_patch\", 0));",
            " ",
            "     printf(\"Testing generic tag attributes.\\n\");",
            "     expect_match(tag, \"size\", 4);",
            "     expect_match(tag, \"read_cache_ms\", 100);",
            " ",
            "     printf(\"Testing protocol-specific attributes.\\n\");",
            "     expect_match(tag, \"elem_size\", 4);",
            "@@ -104,26 +100,22 @@",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-void expect_match(int32_t tag, const char *attrib, int match_val)",
            "-{",
            "+void expect_match(int32_t tag, const char *attrib, int match_val) {",
            "     int val = plc_tag_get_int_attribute(tag, attrib, INT_MIN);",
            " ",
            "     if(val == match_val) {",
            "         printf(\"\\tOK: attribute \\\"%s\\\" = %d.\\n\", attrib, val);",
            "     } else if(val == INT_MIN) {",
            "         printf(\"\\tError getting tag attribute \\\"%s\\\".\\n\", attrib);",
            "         plc_tag_destroy(tag);",
            "         exit(1);",
            "     } else if(val != match_val) {",
            "         printf(\"\\tFAIL: attribute \\\"%s\\\" = %d, expected %d.\\n\", attrib, val, match_val);",
            "         plc_tag_destroy(tag);",
            "         exit(1);",
            "     }",
            " }",
            "-",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/test_tag_type_attribute.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/test_tag_type_attribute.c",
            "+++ /home/libplctag-2.6.7/src/examples/test_tag_type_attribute.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2024 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,26 +28,25 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,6,0",
            "+#define REQUIRED_VERSION 2, 6, 0",
            " ",
            " /* test against a DINT array. */",
            " #define DATA_TIMEOUT 5000",
            " ",
            "-int test_tag_buffer_errors(const char *tag_name, int32_t tag)",
            "-{",
            "+int test_tag_buffer_errors(const char *tag_name, int32_t tag) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     uint8_t type_buffer[32];",
            "     int type_size = 0;",
            " ",
            "     printf(\"Testing tag %s.\\n\", tag_name);",
            " ",
            "     /* get the type size */",
            "@@ -60,116 +59,136 @@",
            "         printf(\"PASSED\\n\");",
            "     }",
            " ",
            "     /* test null pointer */",
            "     printf(\"\\tTest with NULL buffer pointer: \");",
            "     rc = plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", NULL, sizeof(type_buffer));",
            "     if(rc != PLCTAG_ERR_BAD_PARAM) {",
            "-        printf(\"ERROR: getting type info with a NULL buffer pointer does not return PLCTAG_ERR_BAD_PARAM but instead returns %s!\\n\", plc_tag_decode_error(rc));",
            "+        printf(",
            "+            \"ERROR: getting type info with a NULL buffer pointer does not return PLCTAG_ERR_BAD_PARAM but instead returns %s!\\n\",",
            "+            plc_tag_decode_error(rc));",
            "         return PLCTAG_ERR_BAD_REPLY;",
            "     } else {",
            "         printf(\"PASSED\\n\");",
            "     }",
            " ",
            "     /* test zero length buffer */",
            "     printf(\"\\tTest with zero buffer length: \");",
            "     rc = plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", &(type_buffer[0]), 0);",
            "     if(rc != PLCTAG_ERR_BAD_PARAM) {",
            "-        printf(\"ERROR: getting type info with a zero length buffer does not return PLCTAG_ERR_BAD_PARAM but instead returns %s!\\n\", plc_tag_decode_error(rc));",
            "+        printf(",
            "+            \"ERROR: getting type info with a zero length buffer does not return PLCTAG_ERR_BAD_PARAM but instead returns %s!\\n\",",
            "+            plc_tag_decode_error(rc));",
            "         return PLCTAG_ERR_BAD_REPLY;",
            "     } else {",
            "         printf(\"PASSED\\n\");",
            "     }",
            " ",
            "     /* test exact buffer length */",
            "     printf(\"\\tTest with exact buffer length: \");",
            "     type_size = plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", &(type_buffer[0]), type_size);",
            "     if(type_size < 0) {",
            "         printf(\"ERROR: got error %s (%d) trying to get the attribute byte array!\\n\", plc_tag_decode_error(type_size), type_size);",
            "         return PLCTAG_ERR_BAD_REPLY;",
            "     }",
            "+",
            "     if((type_size != 2) && (type_size != 4)) {",
            "         printf(\"ERROR: expected type byte array copied length to be 2 or 4 bytes, but got %d!\\n\", type_size);",
            "         return PLCTAG_ERR_BAD_REPLY;",
            "     } else {",
            "         printf(\"PASSED\\n\");",
            "     }",
            " ",
            "     /* check the type size that comes back when the data is copied */",
            "     printf(\"\\tTest type array size after copy: \");",
            "-    type_size = plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", &(type_buffer[0]), (int)(unsigned int)sizeof(type_buffer));",
            "+    type_size =",
            "+        plc_tag_get_byte_array_attribute(tag, \"raw_tag_type_bytes\", &(type_buffer[0]), (int)(unsigned int)sizeof(type_buffer));",
            "     if((type_size != 2) && (type_size != 4)) {",
            "         printf(\"ERROR: expected type byte array copied length to be 2 or 4 bytes, but got %d!\\n\", type_size);",
            "         return PLCTAG_ERR_BAD_REPLY;",
            "     } else {",
            "         printf(\"PASSED\\n\");",
            "     }",
            " ",
            "     printf(\"\\tRetrieved tag %s native type bytes: \", tag_name);",
            "-    for(int i=0; i < type_size; i++) {",
            "-        printf(\" %02x\", (int)(unsigned int)type_buffer[i]);",
            "-    }",
            "+    for(int i = 0; i < type_size; i++) { printf(\" %02x\", (int)(unsigned int)type_buffer[i]); }",
            "     printf(\"\\n\");",
            " ",
            "-    return rc;",
            "+",
            "+    return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag1 = 0;",
            "-    int32_t tag2 = 0;    ",
            "-    int rc;",
            "+    int32_t tag2 = 0;",
            "+    int rc = PLCTAG_STATUS_OK;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "-    /* create the tag */",
            "-    tag1 = plc_tag_create(\"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&elem_count=1&name=TestBigSINTArray\", DATA_TIMEOUT);",
            "-",
            "-    /* everything OK? */",
            "-    if(tag1 < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag TestBigSINTArray!\\n\", plc_tag_decode_error(tag1));",
            "-        return 1;",
            "-    }",
            "-",
            "-    /* get the data */",
            "-    rc = plc_tag_read(tag1, DATA_TIMEOUT);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data for TestBigSINTArray! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag1);",
            "-        return 1;",
            "-    }",
            "-",
            "-    tag2 = plc_tag_create(\"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&elem_count=1&name=TestManyBOOLFields\", DATA_TIMEOUT);",
            "-",
            "-    /* everything OK? */",
            "-    if(tag2 < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag TestManyBOOLFields!\\n\", plc_tag_decode_error(tag2));",
            "-        plc_tag_destroy(tag1);",
            "-        return 1;",
            "-    }",
            "-",
            "-    /* get the data */",
            "-    rc = plc_tag_read(tag2, DATA_TIMEOUT);",
            "-    if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data for TestManyBOOLFields! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "-        plc_tag_destroy(tag1);",
            "-        plc_tag_destroy(tag2);",
            "-        return 1;",
            "-    }",
            "+    do {",
            "+        /* create the tag */",
            "+        tag1 = plc_tag_create(\"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&elem_count=1&name=TestBigSINTArray\",",
            "+                              DATA_TIMEOUT);",
            "+",
            "+        /* everything OK? */",
            "+        if(tag1 < 0) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR %s: Could not create tag TestBigSINTArray!\\n\", plc_tag_decode_error(tag1));",
            "+            break;",
            "+        }",
            "+",
            "+        /* get the data */",
            "+        rc = plc_tag_read(tag1, DATA_TIMEOUT);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: Unable to read the data for TestBigSINTArray! Got error code %d: %s\\n\", rc,",
            "+                    plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        tag2 = plc_tag_create(",
            "+            \"protocol=ab-eip&gateway=10.206.1.40&path=1,4&plc=ControlLogix&elem_count=1&name=TestManyBOOLFields\", DATA_TIMEOUT);",
            "+        if(tag2 < 0) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR %s: Could not create tag TestManyBOOLFields!\\n\", plc_tag_decode_error(tag2));",
            "+            break;",
            "+        }",
            "+",
            "+        /* get the data */",
            "+        rc = plc_tag_read(tag2, DATA_TIMEOUT);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: Unable to read the data for TestManyBOOLFields! Got error code %d: %s\\n\", rc,",
            "+                    plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        rc = test_tag_buffer_errors(\"TestBigSINTArray\", tag1);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: testing for tag buffer errors with a large SINT array failed %s!\\n\",",
            "+                    plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+",
            "+        rc = test_tag_buffer_errors(\"TestManyBOOLFields\", tag2);",
            "+        if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"ERROR: testing for tag buffer errors with a large BOOL array failed %s!\\n\",",
            "+                    plc_tag_decode_error(rc));",
            "+            break;",
            "+        }",
            "+    } while(0);",
            " ",
            "-    rc = test_tag_buffer_errors(\"TestBigSINTArray\", tag1);",
            "-    rc = test_tag_buffer_errors(\"TestManyBOOLFields\", tag2);",
            "+    if(tag1 > 0) { plc_tag_destroy(tag1); }",
            "+    if(tag2 > 0) { plc_tag_destroy(tag2); }",
            " ",
            "-    plc_tag_destroy(tag1);",
            "-    plc_tag_destroy(tag2);",
            "-",
            "-    return 0;",
            "+    return rc;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/thread_stress.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/thread_stress.c",
            "+++ /home/libplctag-2.6.7/src/examples/thread_stress.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2021 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -29,132 +29,54 @@",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            " /*",
            "- * This example reads a small set of tags repeatedly as fast as possible.  It does not destroy the tags on errors, but simply calls",
            "- * plc_tag_abort() and retries.",
            "+ * This example reads a small set of tags repeatedly as fast as possible.  It does not destroy the tags on errors, but simply",
            "+ * calls plc_tag_abort() and retries.",
            "  *",
            "  * Use ^C to terminate.",
            "  */",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <inttypes.h>",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            "-#include <string.h>",
            " #include <stdlib.h>",
            "-#include <inttypes.h>",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-#include <Windows.h>",
            "-#else",
            "-#include <pthread.h>",
            "-#include <stdint.h>",
            " #include <string.h>",
            "-#include <sys/time.h>",
            "-#include <signal.h>",
            "-#endif",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,4,1",
            "+#define REQUIRED_VERSION 2, 4, 1",
            " ",
            " #define DATA_TIMEOUT (5000)",
            " #define TAG_CREATE_TIMEOUT (5000)",
            " #define RETRY_TIMEOUT (10000)",
            " ",
            " #define DEFAULT_TAG_PATH \"protocol=modbus-tcp&gateway=10.206.1.59:5020&path=0&elem_count=2&name=hr10\"",
            " #define DEFAULT_THREAD_COUNT (10)",
            " ",
            " ",
            "-void usage(void)",
            "-{",
            "-    printf(\"Usage:\\n \"",
            "+void usage(void) {",
            "+    printf(",
            "+        \"Usage:\\n \"",
            "         \"thread_stress <num tags> <path>\\n\"",
            "         \"  <num_tags> - The number of threads to use in the test.\\n\"",
            "         \"  <path> - The tag path to use.\\n\"",
            "         \"\\n\"",
            "         \"Example: thread_stress 14 'protocol=ab_eip&gateway=10.206.1.39&path=1,0&cpu=LGX&elem_size=4&elem_count=1&name=test_tag'\\n\");",
            " ",
            "     exit(PLCTAG_ERR_BAD_PARAM);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-#ifdef _WIN32",
            " volatile int go = 0;",
            " ",
            "-/* straight from MS' web site :-) */",
            "-BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)",
            "-{",
            "-    switch (fdwCtrlType)",
            "-    {",
            "-        // Handle the CTRL-C signal.",
            "-    case CTRL_C_EVENT:",
            "-        go = 0;",
            "-        return TRUE;",
            "-",
            "-        // CTRL-CLOSE: confirm that the user wants to exit.",
            "-    case CTRL_CLOSE_EVENT:",
            "-        go = 0;",
            "-        return TRUE;",
            "-",
            "-        // Pass other signals to the next handler.",
            "-    case CTRL_BREAK_EVENT:",
            "-        go = 0;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_LOGOFF_EVENT:",
            "-        go = 0;",
            "-        return FALSE;",
            "-",
            "-    case CTRL_SHUTDOWN_EVENT:",
            "-        go = 0;",
            "-        return FALSE;",
            "-",
            "-    default:",
            "-        return FALSE;",
            "-    }",
            "-}",
            "-",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))",
            "-    {",
            "-        printf(\"\\nERROR: Could not set control handler!\\n\");",
            "-        usage();",
            "-    }",
            "-}",
            "-",
            "-#else",
            "-volatile sig_atomic_t go = 0;",
            "-",
            "-void SIGINT_handler(int not_used)",
            "-{",
            "-    (void)not_used;",
            "-",
            "-    go = 0;",
            "-}",
            "-",
            "-void setup_break_handler(void)",
            "-{",
            "-    struct sigaction act;",
            "-",
            "-    /* set up signal handler. */",
            "-    memset(&act, 0, sizeof(act));",
            "-    act.sa_handler = SIGINT_handler;",
            "-    sigaction(SIGINT, &act, NULL);",
            "-}",
            "-",
            "-#endif",
            "-",
            "-",
            "-",
            "+static void interrupt_handler(void) { go = 1; }",
            " ",
            " /*",
            "  * This test program creates a lot of threads that read the same tag in",
            "  * the plc.  They all hit the exact same underlying tag data structure.",
            "  * This tests whether the library can handle multi-threaded",
            "  * access and what the performance is.",
            "  */",
            "@@ -166,22 +88,15 @@",
            "     int iteration;",
            "     int64_t total_io_time;",
            "     int64_t min_io_time;",
            "     int64_t max_io_time;",
            " } thread_args;",
            " ",
            " ",
            "-",
            "-",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-DWORD __stdcall test_runner(LPVOID data)",
            "-#else",
            "-void* test_runner(void* data)",
            "-#endif",
            "-{",
            "+void *test_runner(void *data) {",
            "     thread_args *args = (thread_args *)data;",
            "     int tid = args->tid;",
            "     int32_t tag = args->tag;",
            "     int *status = &(args->status);",
            "     int *iteration = &(args->iteration);",
            "     int64_t *total_io_time = &(args->total_io_time);",
            "     int64_t *max_io_time = &(args->max_io_time);",
            "@@ -191,197 +106,181 @@",
            "     *status = PLCTAG_STATUS_OK;",
            "     *iteration = 0;",
            "     *total_io_time = 0;",
            "     *max_io_time = 0;",
            "     *min_io_time = 1000000000L;",
            " ",
            "     /* wait until all threads ready. */",
            "-    while(!go) {",
            "-        util_sleep_ms(10);",
            "-    }",
            "+    while(!go) { compat_sleep_ms(10, NULL); }",
            " ",
            "     while(go) {",
            "         int64_t start = 0;",
            "         int64_t io_time = 0;",
            " ",
            "         (*iteration)++;",
            " ",
            "         /* capture the starting time */",
            "-        start = util_time_ms();",
            "+        start = compat_time_ms();",
            " ",
            "         rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "-            fprintf(stderr, \"!!! Thread %d, iteration %d, read failed after %\" PRId64 \"ms  with error %s\\n\", tid, *iteration, (int64_t)(util_time_ms() - start), plc_tag_decode_error(rc));",
            "+            // NOLINTNEXTLINE",
            "+            fprintf(stderr, \"!!! Thread %d, iteration %d, read failed after %\" PRId64 \"ms  with error %s\\n\", tid, *iteration,",
            "+                    (int64_t)(compat_time_ms() - start), plc_tag_decode_error(rc));",
            "             break;",
            "         }",
            " ",
            "-        io_time = util_time_ms() - start;",
            "+        io_time = compat_time_ms() - start;",
            " ",
            "         *total_io_time += io_time;",
            " ",
            "-        if(io_time > *max_io_time) {",
            "-            *max_io_time = io_time;",
            "-        }",
            "+        if(io_time > *max_io_time) { *max_io_time = io_time; }",
            " ",
            "-        if(io_time < *min_io_time) {",
            "-            *min_io_time = io_time;",
            "-        }",
            "+        if(io_time < *min_io_time) { *min_io_time = io_time; }",
            "     }",
            " ",
            "-    fprintf(stderr, \"*** Thread %d terminating after %d iterations and an average of %dms per iteration.\\n\", tid, *iteration, (int)(*total_io_time/(*iteration)));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"*** Thread %d terminating after %d iterations and an average of %dms per iteration.\\n\", tid, *iteration,",
            "+            (int)(*total_io_time / (*iteration)));",
            " ",
            "     fflush(stderr);",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    return (DWORD)0;",
            "-#else",
            "-    return NULL;",
            "-#endif",
            "+    return 0;",
            " }",
            " ",
            " ",
            " #define MAX_THREADS (100)",
            " ",
            "-int main(int argc, char **argv)",
            "-{",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-    HANDLE thread[MAX_THREADS];",
            "-#else",
            "-    pthread_t thread[MAX_THREADS];",
            "-#endif",
            "+int main(int argc, char **argv) {",
            "+    compat_thread_t thread[MAX_THREADS];",
            "     int num_threads = 0;",
            "     int success = 0;",
            "     thread_args args[MAX_THREADS];",
            "     char *tag_string = NULL;",
            "     int64_t start = 0;",
            "     int64_t total_run_time = 0;",
            "     int count_down = 50;",
            " ",
            "     /* set up logging */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_DETAIL);",
            " ",
            "     /* check the library version. */",
            "+    // NOLINTNEXTLINE",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "-    /* set up handler for ^C etc. */",
            "-    setup_break_handler();",
            "+    /* cat ^C etc. */",
            "+    compat_set_interrupt_handler(interrupt_handler);",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Hit ^C to terminate the test.\\n\");",
            " ",
            "     if(argc == 3) {",
            "         num_threads = atoi(argv[1]);",
            "         tag_string = argv[2];",
            "     } else {",
            "-        //usage();",
            "+        // usage();",
            "         num_threads = DEFAULT_THREAD_COUNT;",
            "         tag_string = DEFAULT_TAG_PATH;",
            "     }",
            " ",
            "     if(num_threads > MAX_THREADS) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Too many threads.  A maximum of %d threads are supported.\\n\", MAX_THREADS);",
            "         usage();",
            "     }",
            " ",
            "     if(!tag_string || strlen(tag_string) < 10) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"You must provide a valid tag string.\\n\");",
            "         usage();",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"--- starting run with %d threads using tag string \\\"%s\\\".\\n\", num_threads, tag_string);",
            " ",
            "     /* create the test tags */",
            "-    for(int tid=0; tid < num_threads  && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "         int32_t tag = 0;",
            " ",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"--- Creating test tag %d.\\n\", tid);",
            " ",
            "         tag = plc_tag_create(tag_string, TAG_CREATE_TIMEOUT);",
            " ",
            "         if(tag < 0) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"!!! Failed to create tag for thread %d with error %s!\\n\", tid, plc_tag_decode_error(tag));",
            "             usage();",
            "         }",
            " ",
            "         args[tid].tid = tid;",
            "         args[tid].tag = tag;",
            "         args[tid].status = PLCTAG_STATUS_OK;",
            "         args[tid].iteration = 0;",
            "         args[tid].total_io_time = 0;",
            "         args[tid].min_io_time = 0;",
            "         args[tid].max_io_time = 0;",
            "     }",
            " ",
            "-    for(int tid=0; tid < num_threads  && tid < MAX_THREADS; tid++) {",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"--- Creating test thread %d.\\n\", args[tid].tid);",
            " ",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        thread[tid] = CreateThread( NULL,                       /* default security attributes */",
            "-                                    0,                          /* use default stack size      */",
            "-                                    test_runner,                /* thread function             */",
            "-                                    (LPVOID)&args[tid],         /* argument to thread function */",
            "-                                    (DWORD)0,                   /* use default creation flags  */",
            "-                                    (LPDWORD)NULL               /* do not need thread ID       */",
            "-                                  );",
            "-#else",
            "-        pthread_create(&thread[tid], NULL, test_runner, (void*)&args[tid]);",
            "-#endif",
            "+        compat_thread_create(&thread[tid], test_runner, (void *)&args[tid]);",
            "     }",
            " ",
            "     /* wait for threads to create and start. */",
            "-    util_sleep_ms(100);",
            "+    compat_sleep_ms(100, NULL);",
            " ",
            "     /* launch the threads */",
            "     go = 1;",
            " ",
            "-    start = util_time_ms();",
            "+    start = compat_time_ms();",
            " ",
            "-    while(go && (--count_down) > 0) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(go && (--count_down) > 0) { compat_sleep_ms(100, NULL); }",
            " ",
            "     go = 0;",
            " ",
            "-    total_run_time = util_time_ms() - start;",
            "+    total_run_time = compat_time_ms() - start;",
            " ",
            "     success = 1;",
            " ",
            "     /* FIXME - wait for the threads to stop. */",
            "-    util_sleep_ms(100);",
            "+    compat_sleep_ms(100, NULL);",
            " ",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-#if defined(WIN32) || defined(_WIN32)",
            "-        WaitForSingleObject(thread[tid], (DWORD)INFINITE);",
            "-#else",
            "-        pthread_join(thread[tid], NULL);",
            "-#endif",
            "-    }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) { compat_thread_join(thread[tid], NULL); }",
            " ",
            "     /* close the tags. */",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-        plc_tag_destroy(args[tid].tag);",
            "-    }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) { plc_tag_destroy(args[tid].tag); }",
            " ",
            "     /* check the status */",
            "-    for(int tid=0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "-        if(args[tid].status != PLCTAG_STATUS_OK) {",
            "-            success = 0;",
            "-        }",
            "+    for(int tid = 0; tid < num_threads && tid < MAX_THREADS; tid++) {",
            "+        if(args[tid].status != PLCTAG_STATUS_OK) { success = 0; }",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"--- All test threads terminated after running %\" PRId64 \"ms.\\n\", total_run_time);",
            " ",
            "-    if(!success) {",
            "-        fprintf(stderr,\"*** Test FAILED!\\n\");",
            "-    } else {",
            "-        fprintf(stderr,\"*** Test SUCCEEDED!\\n\");",
            "-    }",
            "-",
            "     /* print out statistics. */",
            "-    for(int tid=0; tid < num_threads; tid++) {",
            "-        fprintf(stderr,\"--- Thread %d ran %d iterations with a total io time of %\" PRId64 \"ms and min/avg/max of %\" PRId64 \"ms/%\" PRId64 \"ms/%\" PRId64 \"ms.\\n\", tid, args[tid].iteration, args[tid].total_io_time, args[tid].min_io_time, args[tid].total_io_time/args[tid].iteration, args[tid].max_io_time);",
            "+    for(int tid = 0; tid < num_threads; tid++) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr,",
            "+                \"--- Thread %d ran %d iterations with a total io time of %\" PRId64 \"ms and min/avg/max of %\" PRId64 \"ms/%\" PRId64",
            "+                \"ms/%\" PRId64 \"ms.\\n\",",
            "+                tid, args[tid].iteration, args[tid].total_io_time, args[tid].min_io_time,",
            "+                args[tid].total_io_time / args[tid].iteration, args[tid].max_io_time);",
            "     }",
            " ",
            "-    return 0;",
            "+    if(success) {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"*** Test SUCCEEDED!\\n\");",
            "+        return 0;",
            "+    } else {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"*** Test FAILED!\\n\");",
            "+        return -1;",
            "+    }",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/toggle_bit.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/toggle_bit.c",
            "+++ /home/libplctag-2.6.7/src/examples/toggle_bit.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,107 +28,109 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " /*",
            "  * the name TestDINTArray[3].17 picks a specific bit out of the TestDINTArray tag element 3.  This is a bit-valued tag",
            "  * and is only considered to be a single bit.",
            "  */",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.40&path=1,4&cpu=LGX&elem_size=4&elem_count=1&name=TestDINTArray[3].17\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " /*",
            "  * Read a bit value and toggle it.",
            "  */",
            " ",
            " ",
            "-",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int b;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            " ",
            "         return 0;",
            "     }",
            " ",
            "     /* let the connect succeed we hope */",
            "-    while(plc_tag_status(tag) == PLCTAG_STATUS_PENDING) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(plc_tag_status(tag) == PLCTAG_STATUS_PENDING) { compat_sleep_ms(100, NULL); }",
            " ",
            "     if(plc_tag_status(tag) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /*",
            "      * Read the bit value.   For a bit tag like this, always use offset of zero.",
            "      */",
            "     b = plc_tag_get_bit(tag, 0);",
            "-    fprintf(stderr,\"Before bool = %d\\n\", b);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Before bool = %d\\n\", b);",
            " ",
            "     plc_tag_set_bit(tag, 0, (b ? 0 : 1));",
            " ",
            "     /*",
            "      * Because this is a single bit tag, the write will use the CIP Read-Modify-Write command to safely (we hope)",
            "      * update the single bit value.",
            "      */",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            " ",
            "     /* get the data again*/",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "     b = plc_tag_get_bit(tag, 0);",
            "-    fprintf(stderr,\"After bool = %d\\n\", b);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"After bool = %d\\n\", b);",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/toggle_bool.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/toggle_bool.c",
            "+++ /home/libplctag-2.6.7/src/examples/toggle_bool.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,96 +28,97 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            "-#define REQUIRED_VERSION 2,1,0",
            "+#define REQUIRED_VERSION 2, 1, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.27&path=1,0&cpu=LGX&elem_size=1&elem_count=1&debug=1&name=pcomm_test_bool\"",
            " #define DATA_TIMEOUT 5000",
            " ",
            " /*",
            "  * Read a boolean value and toggle it.",
            "  */",
            " ",
            " ",
            "-",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int32_t tag = 0;",
            "     int rc;",
            "     int b;",
            " ",
            "     /* check the library version. */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "     /* create the tag */",
            "     tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT);",
            " ",
            "     /* everything OK? */",
            "     if(tag < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            " ",
            "         return 0;",
            "     }",
            " ",
            "     /* let the connect succeed we hope */",
            "-    while(plc_tag_status(tag) == PLCTAG_STATUS_PENDING) {",
            "-        util_sleep_ms(100);",
            "-    }",
            "+    while(plc_tag_status(tag) == PLCTAG_STATUS_PENDING) { compat_sleep_ms(100, NULL); }",
            " ",
            "     if(plc_tag_status(tag) != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Error setting up tag internal state. Error %s\\n\", plc_tag_decode_error(plc_tag_status(tag)));",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "-",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    b = plc_tag_get_uint8(tag,0);",
            "-    fprintf(stderr,\"bool = %d\\n\", b);",
            "+    b = plc_tag_get_uint8(tag, 0);",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"bool = %d\\n\", b);",
            " ",
            "     plc_tag_set_uint8(tag, 0, (b ? 0 : 255));",
            " ",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "-",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            " ",
            "     /* get the data again*/",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            " ",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stderr,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /* print out the data */",
            "-    b = plc_tag_get_uint8(tag,0);",
            "-    fprintf(stderr,\"bool = %d\\n\", b);",
            "+    b = plc_tag_get_uint8(tag, 0);",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"bool = %d\\n\", b);",
            " ",
            "     /* we are done */",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/examples/write_string.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/examples/write_string.c",
            "+++ /home/libplctag-2.6.7/src/examples/write_string.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -28,36 +28,34 @@",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            "+#include \"compat_utils.h\"",
            "+#include <libplctag/lib/libplctag.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            "-#include \"../lib/libplctag.h\"",
            "-#include \"utils.h\"",
            " ",
            " /*",
            "  * This example shows how to read and write an array of strings.",
            "  */",
            " ",
            "-#define REQUIRED_VERSION 2,2,0",
            "+#define REQUIRED_VERSION 2, 2, 0",
            " ",
            " #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.39&path=1,0&plc=ControlLogix&elem_count=6&name=Loc_Txt\"",
            "-//#define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.38&plc=plc5&elem_size=84&elem_count=2&name=ST18:0\"",
            "+// #define TAG_PATH \"protocol=ab_eip&gateway=10.206.1.38&plc=plc5&elem_size=84&elem_count=2&name=ST18:0\"",
            " ",
            " #define STRING_DATA_SIZE (82)",
            " #define DATA_TIMEOUT 5000",
            " ",
            " ",
            "-",
            "-int dump_strings(int32_t tag)",
            "-{",
            "+int dump_strings(int32_t tag) {",
            "     int str_number = 0;",
            "     int offset = 0;",
            "     int tag_size = plc_tag_get_size(tag);",
            " ",
            "     /* loop over the whole thing. */",
            "     offset = 0;",
            "     while(offset < tag_size) {",
            "@@ -69,120 +67,122 @@",
            "          * size in advance.  However, this will work regardless of the size",
            "          * of each string.",
            "          */",
            "         int str_cap = plc_tag_get_string_capacity(tag, offset) + 1;",
            "         char *str_data = malloc((size_t)(unsigned int)str_cap);",
            " ",
            "         if(!str_data) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unable to allocate buffer for string data!\\n\");",
            "             return PLCTAG_ERR_NO_MEM;",
            "         }",
            " ",
            "         str_number++;",
            " ",
            "         /* get the string length */",
            "         rc = plc_tag_get_string(tag, offset, str_data, str_cap);",
            "         if(rc != PLCTAG_STATUS_OK) {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Error getting string %d!  Got error status %s.\\n\", str_number, plc_tag_decode_error(rc));",
            "         } else {",
            "+            // NOLINTNEXTLINE",
            "             printf(\"String [%d] = \\\"%s\\\"\\n\", str_number, str_data);",
            "         }",
            " ",
            "         free(str_data);",
            " ",
            "         offset += plc_tag_get_string_total_length(tag, offset);",
            "     }",
            " ",
            "     return 0;",
            "-",
            " }",
            " ",
            " ",
            "-",
            "-void update_string(int32_t tag, int str_number, char *str)",
            "-{",
            "+void update_string(int32_t tag, int str_number, char *str) {",
            "     int rc = 0;",
            "     int str_total_length = plc_tag_get_string_total_length(tag, 0); /* assume all are the same size */",
            " ",
            "     rc = plc_tag_set_string(tag, str_total_length * str_number, str);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error setting string %d, error %s!\\n\", str_number, plc_tag_decode_error(rc));",
            "         return;",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-int main()",
            "-{",
            "+int main(void) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "-    char str[STRING_DATA_SIZE+1] = {0};",
            "+    char str[STRING_DATA_SIZE + 1] = {0};",
            "     int32_t tag = 0;",
            "     int string_count = 0;",
            " ",
            "     /* check library API version */",
            "     if(plc_tag_check_lib_version(REQUIRED_VERSION) != PLCTAG_STATUS_OK) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Required compatible library version %d.%d.%d not available!\", REQUIRED_VERSION);",
            "         exit(1);",
            "     }",
            " ",
            "-    fprintf(stderr, \"Using library version %d.%d.%d.\\n\",",
            "-                                            plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_minor\", -1),",
            "-                                            plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"Using library version %d.%d.%d.\\n\", plc_tag_get_int_attribute(0, \"version_major\", -1),",
            "+            plc_tag_get_int_attribute(0, \"version_minor\", -1), plc_tag_get_int_attribute(0, \"version_patch\", -1));",
            " ",
            "     /* set up debugging output. */",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_NONE);",
            " ",
            "     /* set up the RNG */",
            "-    srand((unsigned int)(uint64_t)util_time_ms());",
            "+    srand((unsigned int)(uint64_t)compat_time_ms());",
            " ",
            "     /* create the tag. */",
            "     if((tag = plc_tag_create(TAG_PATH, DATA_TIMEOUT)) < 0) {",
            "-        fprintf(stderr,\"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"ERROR %s: Could not create tag!\\n\", plc_tag_decode_error(tag));",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stdout,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stdout, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /* dump the \"before\" state. */",
            "     printf(\"Strings before update:\\n\");",
            "     dump_strings(tag);",
            " ",
            "     /* how many strings do we have? */",
            "     string_count = plc_tag_get_int_attribute(tag, \"elem_count\", 1);",
            " ",
            "     /* update the string. */",
            "-    for(int i=0; i < string_count; i++) {",
            "-        snprintf_platform(str, sizeof(str), \"string value for element %d is %d.\", i, (int)(rand() % 1000));",
            "+    for(int i = 0; i < string_count; i++) {",
            "+        // NOLINTNEXTLINE",
            "+        compat_snprintf(str, sizeof(str), \"string value for element %d is %d.\", i, (int)(rand() % 1000));",
            "         update_string(tag, i, str);",
            "     }",
            " ",
            "     /* write the data */",
            "     rc = plc_tag_write(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stdout,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stdout, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /* get the data again */",
            "     rc = plc_tag_read(tag, DATA_TIMEOUT);",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "-        fprintf(stdout,\"ERROR: Unable to read the data! Got error code %d: %s\\n\",rc, plc_tag_decode_error(rc));",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stdout, \"ERROR: Unable to read the data! Got error code %d: %s\\n\", rc, plc_tag_decode_error(rc));",
            "         return 0;",
            "     }",
            " ",
            "     /* dump the \"after\" state */",
            "     printf(\"\\nStrings after update:\\n\");",
            "     dump_strings(tag);",
            " ",
            "     plc_tag_destroy(tag);",
            " ",
            "     return 0;",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/platform/posix/platform.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/platform/posix/platform.c",
            "+++ /home/libplctag-2.6.7/src/platform/posix/platform.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -30,140 +30,126 @@",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " ",
            " #define _GNU_SOURCE",
            " ",
            "-#include <platform.h>",
            "-#include <unistd.h>",
            "-#include <stdlib.h>",
            "-#include <stdint.h>",
            "+#include <arpa/inet.h>",
            "+#include <errno.h>",
            "+#include <fcntl.h>",
            "+#include <inttypes.h>",
            " #include <limits.h>",
            " #include <math.h>",
            "+#include <netdb.h>",
            "+#include <netinet/in.h>",
            "+#include <platform.h>",
            "+#include <pthread.h>",
            "+#include <stdint.h>",
            "+#include <stdio.h>",
            "+#include <stdlib.h>",
            " #include <string.h>",
            " #include <strings.h>",
            "+#include <sys/socket.h>",
            " #include <sys/time.h>",
            "-#include <pthread.h>",
            "-#include <stdio.h>",
            "-#include <errno.h>",
            " #include <sys/types.h>",
            "-#include <sys/socket.h>",
            "-#include <netinet/in.h>",
            "-#include <arpa/inet.h>",
            "-#include <netdb.h>",
            "-#include <fcntl.h>",
            " #include <time.h>",
            "-#include <inttypes.h>",
            "-",
            "-#include <lib/libplctag.h>",
            "-#include <util/debug.h>",
            "+#include <unistd.h>",
            " ",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <utils/debug.h>",
            " ",
            " ",
            "-#if defined(__APPLE__) || defined(__FreeBSD__) ||  defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__) || defined(__DragonFly__)",
            "-    #define BSD_OS_TYPE",
            "-    #if defined(__APPLE__) && !defined(_DARWIN_C_SOURCE)",
            "-        #define _DARWIN_C_SOURCE _POSIX_C_SOURCE",
            "-    #endif",
            "+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__) \\",
            "+    || defined(__DragonFly__)",
            "+#    define BSD_OS_TYPE",
            "+#    if defined(__APPLE__) && !defined(_DARWIN_C_SOURCE)",
            "+#        define _DARWIN_C_SOURCE _POSIX_C_SOURCE",
            "+#    endif",
            " #endif",
            " ",
            " ",
            " /***************************************************************************",
            "  ******************************* Memory ************************************",
            "  **************************************************************************/",
            " ",
            " ",
            "-",
            " /*",
            "  * mem_alloc",
            "  *",
            "  * This is a wrapper around the platform's memory allocation routine.",
            "  * It will zero out memory before returning it.",
            "  *",
            "  * It will return NULL on failure.",
            "  */",
            "-extern void *mem_alloc(int size)",
            "-{",
            "+extern void *mem_alloc(int size) {",
            "     if(size <= 0) {",
            "         pdebug(DEBUG_WARN, \"Allocation size must be greater than zero bytes!\");",
            "         return NULL;",
            "     }",
            " ",
            "     return calloc((size_t)(unsigned int)size, 1);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * mem_realloc",
            "  *",
            "  * This is a wrapper around the platform's memory re-allocation routine.",
            "  *",
            "  * It will return NULL on failure.",
            "  */",
            "-extern void *mem_realloc(void *orig, int size)",
            "-{",
            "+extern void *mem_realloc(void *orig, int size) {",
            "     if(size <= 0) {",
            "         pdebug(DEBUG_WARN, \"New allocation size must be greater than zero bytes!\");",
            "         return NULL;",
            "     }",
            " ",
            "     return realloc(orig, (size_t)(ssize_t)size);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * mem_free",
            "  *",
            "  * Free the allocated memory passed in.  If the passed pointer is",
            "  * null, do nothing.",
            "  */",
            "-extern void mem_free(const void *mem)",
            "-{",
            "-    if(mem) {",
            "-        free((void *)mem);",
            "-    }",
            "+extern void mem_free(const void *mem) {",
            "+    if(mem) { free((void *)mem); }",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * mem_set",
            "  *",
            "  * set memory to the passed argument.",
            "  */",
            "-extern void mem_set(void *dest, int c, int size)",
            "-{",
            "+extern void mem_set(void *dest, int c, int size) {",
            "     if(!dest) {",
            "         pdebug(DEBUG_WARN, \"Destination pointer is NULL!\");",
            "         return;",
            "     }",
            " ",
            "     if(size <= 0) {",
            "         pdebug(DEBUG_WARN, \"Size to set must be a positive number!\");",
            "         return;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     memset(dest, c, (size_t)(ssize_t)size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /*",
            "  * mem_copy",
            "  *",
            "  * copy memory from one pointer to another for the passed number of bytes.",
            "  */",
            "-extern void mem_copy(void *dest, void *src, int size)",
            "-{",
            "+extern void mem_copy(void *dest, void *src, int size) {",
            "     if(!dest) {",
            "         pdebug(DEBUG_WARN, \"Destination pointer is NULL!\");",
            "         return;",
            "     }",
            " ",
            "     if(!src) {",
            "         pdebug(DEBUG_WARN, \"Source pointer is NULL!\");",
            "@@ -176,26 +162,25 @@",
            "     }",
            " ",
            "     if(size == 0) {",
            "         /* nothing to do. */",
            "         return;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     memcpy(dest, src, (size_t)(unsigned int)size);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * mem_move",
            "  *",
            "  * move memory from one pointer to another for the passed number of bytes.",
            "  */",
            "-extern void mem_move(void *dest, void *src, int size)",
            "-{",
            "+extern void mem_move(void *dest, void *src, int size) {",
            "     if(!dest) {",
            "         pdebug(DEBUG_WARN, \"Destination pointer is NULL!\");",
            "         return;",
            "     }",
            " ",
            "     if(!src) {",
            "         pdebug(DEBUG_WARN, \"Source pointer is NULL!\");",
            "@@ -208,23 +193,20 @@",
            "     }",
            " ",
            "     if(size == 0) {",
            "         /* nothing to do. */",
            "         return;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     memmove(dest, src, (size_t)(unsigned int)size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int mem_cmp(void *src1, int src1_size, void *src2, int src2_size)",
            "-{",
            "+int mem_cmp(void *src1, int src1_size, void *src2, int src2_size) {",
            "     if(!src1 || src1_size <= 0) {",
            "         if(!src2 || src2_size <= 0) {",
            "             /* both are NULL or zero length, but that is \"equal\" for our purposes. */",
            "             return 0;",
            "         } else {",
            "             /* first one is \"less\" than second. */",
            "             return -1;",
            "@@ -233,44 +215,37 @@",
            "         if(!src2 || src2_size <= 0) {",
            "             /* first is \"greater\" than second */",
            "             return 1;",
            "         } else {",
            "             /* both pointers are non-NULL and the lengths are positive. */",
            " ",
            "             /* short circuit the comparison if the blocks are different lengths */",
            "-            if(src1_size != src2_size) {",
            "-                return (src1_size - src2_size);",
            "-            }",
            "+            if(src1_size != src2_size) { return (src1_size - src2_size); }",
            " ",
            "             return memcmp(src1, src2, (size_t)(unsigned int)src1_size);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Strings ***********************************",
            "  **************************************************************************/",
            " ",
            " ",
            " /*",
            "  * str_cmp",
            "  *",
            "  * Return -1, 0, or 1 depending on whether the first string is \"less\" than the",
            "  * second, the same as the second, or \"greater\" than the second.  This routine",
            "  * just passes through to POSIX strcmp.",
            "  *",
            "  * Handle edge cases when NULL or zero length strings are passed.",
            "  */",
            "-extern int str_cmp(const char *first, const char *second)",
            "-{",
            "+extern int str_cmp(const char *first, const char *second) {",
            "     int first_zero = !str_length(first);",
            "     int second_zero = !str_length(second);",
            " ",
            "     if(first_zero) {",
            "         if(second_zero) {",
            "             pdebug(DEBUG_DETAIL, \"NULL or zero length strings passed.\");",
            "             return 0;",
            "@@ -286,27 +261,24 @@",
            "             /* both are non-zero length. */",
            "             return strcmp(first, second);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * str_cmp_i",
            "  *",
            "  * Returns -1, 0, or 1 depending on whether the first string is \"less\" than the",
            "  * second, the same as the second, or \"greater\" than the second.  The comparison",
            "  * is done case insensitive.",
            "  *",
            "  * Handle the usual edge cases.",
            "  */",
            "-extern int str_cmp_i(const char *first, const char *second)",
            "-{",
            "+extern int str_cmp_i(const char *first, const char *second) {",
            "     int first_zero = !str_length(first);",
            "     int second_zero = !str_length(second);",
            " ",
            "     if(first_zero) {",
            "         if(second_zero) {",
            "             pdebug(DEBUG_DETAIL, \"NULL or zero length strings passed.\");",
            "             return 0;",
            "@@ -316,32 +288,30 @@",
            "         }",
            "     } else {",
            "         if(second_zero) {",
            "             /* first is \"more\" than second. */",
            "             return 1;",
            "         } else {",
            "             /* both are non-zero length. */",
            "-            return strcasecmp(first,second);",
            "+            return strcasecmp(first, second);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * str_cmp_i_n",
            "  *",
            "  * Returns -1, 0, or 1 depending on whether the first string is \"less\" than the",
            "  * second, the same as the second, or \"greater\" than the second.  The comparison",
            "  * is done case insensitive.  Compares only the first count characters.",
            "  *",
            "  * It just passes this through to POSIX strncasecmp.",
            "  */",
            "-extern int str_cmp_i_n(const char *first, const char *second, int count)",
            "-{",
            "+extern int str_cmp_i_n(const char *first, const char *second, int count) {",
            "     int first_zero = !str_length(first);",
            "     int second_zero = !str_length(second);",
            " ",
            "     if(count < 0) {",
            "         pdebug(DEBUG_WARN, \"Illegal negative count!\");",
            "         return -1;",
            "     }",
            "@@ -368,25 +338,23 @@",
            "             return strncasecmp(first, second, (size_t)(unsigned int)count);",
            "         }",
            "     }",
            "     return strncasecmp(first, second, (size_t)(unsigned int)count);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * str_str_cmp_i",
            "  *",
            "  * Returns a pointer to the location of the needle string in the haystack string",
            "  * or NULL if there is no match.  The comparison is done case-insensitive.",
            "  *",
            "  * Handle the usual edge cases.",
            "  */",
            "-extern char *str_str_cmp_i(const char *haystack, const char *needle)",
            "-{",
            "+extern char *str_str_cmp_i(const char *haystack, const char *needle) {",
            "     int haystack_zero = !str_length(haystack);",
            "     int needle_zero = !str_length(needle);",
            " ",
            "     if(haystack_zero) {",
            "         pdebug(DEBUG_DETAIL, \"Haystack string is NULL or zero length.\");",
            "         return NULL;",
            "     }",
            "@@ -396,369 +364,323 @@",
            "         return NULL;",
            "     }",
            " ",
            "     return strcasestr(haystack, needle);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * str_copy",
            "  *",
            "  * Returns",
            "  */",
            "-extern int str_copy(char *dst, int dst_size, const char *src)",
            "-{",
            "-    if (!dst) {",
            "+extern int str_copy(char *dst, int dst_size, const char *src) {",
            "+    if(!dst) {",
            "         pdebug(DEBUG_WARN, \"Destination string pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if (!src) {",
            "+    if(!src) {",
            "         pdebug(DEBUG_WARN, \"Source string pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     if(dst_size <= 0) {",
            "         pdebug(DEBUG_WARN, \"Destination size is negative or zero!\");",
            "         return PLCTAG_ERR_TOO_SMALL;",
            "     }",
            " ",
            "+    // NOLINTNEXTLINE",
            "     strncpy(dst, src, (size_t)(unsigned int)dst_size);",
            "+",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            " /*",
            "  * str_length",
            "  *",
            "  * Return the length of the string.  If a null pointer is passed, return",
            "  * null.",
            "  */",
            "-extern int str_length(const char *str)",
            "-{",
            "-    if(!str) {",
            "-        return 0;",
            "-    }",
            "+extern int str_length(const char *str) {",
            "+    if(!str) { return 0; }",
            " ",
            "     return (int)strlen(str);",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * str_dup",
            "  *",
            "  * Copy the passed string and return a pointer to the copy.",
            "  * The caller is responsible for freeing the memory.",
            "  */",
            "-extern char *str_dup(const char *str)",
            "-{",
            "-    if(!str) {",
            "-        return NULL;",
            "-    }",
            "+extern char *str_dup(const char *str) {",
            "+    if(!str) { return NULL; }",
            " ",
            "     return strdup(str);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * str_to_int",
            "  *",
            "  * Convert the characters in the passed string into",
            "  * an int.  Return an int in integer in the passed",
            "  * pointer and a status from the function.",
            "  */",
            "-extern int str_to_int(const char *str, int *val)",
            "-{",
            "+extern int str_to_int(const char *str, int *val) {",
            "     char *endptr;",
            "     long int tmp_val;",
            " ",
            "-    tmp_val = strtol(str,&endptr,0);",
            "+    tmp_val = strtol(str, &endptr, 0);",
            " ",
            "-    if (errno == ERANGE && (tmp_val == LONG_MAX || tmp_val == LONG_MIN)) {",
            "-        pdebug(DEBUG_WARN,\"strtol returned %ld with errno %d\",tmp_val, errno);",
            "+    if(errno == ERANGE && (tmp_val == LONG_MAX || tmp_val == LONG_MIN)) {",
            "+        pdebug(DEBUG_WARN, \"strtol returned %ld with errno %d\", tmp_val, errno);",
            "         return -1;",
            "     }",
            " ",
            "-    if (endptr == str) {",
            "-        return -1;",
            "-    }",
            "+    if(endptr == str) { return -1; }",
            " ",
            "     /* FIXME - this will truncate long values. */",
            "     *val = (int)tmp_val;",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-extern int str_to_float(const char *str, float *val)",
            "-{",
            "+extern int str_to_float(const char *str, float *val) {",
            "     char *endptr;",
            "     float tmp_val;",
            " ",
            "-    tmp_val = strtof(str,&endptr);",
            "+    tmp_val = strtof(str, &endptr);",
            " ",
            "-    if (errno == ERANGE && (tmp_val == HUGE_VALF || tmp_val == -HUGE_VALF || tmp_val == 0)) {",
            "-        return -1;",
            "-    }",
            "+    if(errno == ERANGE && (tmp_val == HUGE_VALF || tmp_val == -HUGE_VALF || tmp_val == 0)) { return -1; }",
            " ",
            "-    if (endptr == str) {",
            "-        return -1;",
            "-    }",
            "+    if(endptr == str) { return -1; }",
            " ",
            "     /* FIXME - this will truncate long values. */",
            "     *val = tmp_val;",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-extern char **str_split(const char *str, const char *sep)",
            "-{",
            "-    int sub_str_count=0;",
            "+extern char **str_split(const char *str, const char *sep) {",
            "+    int sub_str_count = 0;",
            "     int size = 0;",
            "     const char *sub;",
            "     const char *tmp;",
            "     char **res;",
            " ",
            "     /* first, count the sub strings */",
            "     tmp = str;",
            "-    sub = strstr(tmp,sep);",
            "+    sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front, ignore that. */",
            "-        if(sub != tmp) {",
            "-            sub_str_count++;",
            "-        }",
            "+        if(sub != tmp) { sub_str_count++; }",
            " ",
            "         tmp = sub + str_length(sep);",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "-    if(tmp && *tmp && (!sub || !*sub))",
            "-        sub_str_count++;",
            "+    if(tmp && *tmp && (!sub || !*sub)) { sub_str_count++; }",
            " ",
            "     /* calculate total size for string plus pointers */",
            "-    size = ((int)sizeof(char *)*(sub_str_count+1)+str_length(str)+1);",
            "+    size = ((int)sizeof(char *) * (sub_str_count + 1) + str_length(str) + 1);",
            " ",
            "     /* allocate enough memory */",
            "     res = mem_alloc(size);",
            " ",
            "-    if(!res)",
            "-        return NULL;",
            "+    if(!res) { return NULL; }",
            " ",
            "     /* calculate the beginning of the string */",
            "-    tmp = (char *)res + sizeof(char *) * (size_t)(sub_str_count+1);",
            "+    tmp = (char *)res + sizeof(char *) * (size_t)(sub_str_count + 1);",
            " ",
            "     /* copy the string into the new buffer past the first part with the array of char pointers. */",
            "-    str_copy((char *)tmp, (int)(size - ((char*)tmp - (char*)res)), str);",
            "+    str_copy((char *)tmp, (int)(size - ((char *)tmp - (char *)res)), str);",
            " ",
            "     /* set up the pointers */",
            "-    sub_str_count=0;",
            "-    sub = strstr(tmp,sep);",
            "+    sub_str_count = 0;",
            "+    sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front, ignore that. */",
            "         if(sub != tmp) {",
            "             /* store the pointer */",
            "             res[sub_str_count] = (char *)tmp;",
            " ",
            "             sub_str_count++;",
            "         }",
            " ",
            "         /* zero out the separator chars */",
            "-        mem_set((char*)sub,0,str_length(sep));",
            "+        mem_set((char *)sub, 0, str_length(sep));",
            " ",
            "         /* point past the separator (now zero) */",
            "         tmp = sub + str_length(sep);",
            " ",
            "         /* find the next separator */",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "     /* if there is a chunk at the end, store it. */",
            "-    if(tmp && *tmp && (!sub || !*sub)) {",
            "-        res[sub_str_count] = (char*)tmp;",
            "-    }",
            "+    if(tmp && *tmp && (!sub || !*sub)) { res[sub_str_count] = (char *)tmp; }",
            " ",
            "     return res;",
            " }",
            " ",
            " ",
            "-",
            "-char *str_concat_impl(int num_args, ...)",
            "-{",
            "+char *str_concat_impl(int num_args, ...) {",
            "     va_list arg_list;",
            "     int total_length = 0;",
            "     char *result = NULL;",
            "     char *tmp = NULL;",
            " ",
            "     /* first loop to find the length */",
            "     va_start(arg_list, num_args);",
            "-    for(int i=0; i < num_args; i++) {",
            "+    for(int i = 0; i < num_args; i++) {",
            "         tmp = va_arg(arg_list, char *);",
            "-        if(tmp) {",
            "-            total_length += str_length(tmp);",
            "-        }",
            "+        if(tmp) { total_length += str_length(tmp); }",
            "     }",
            "     va_end(arg_list);",
            " ",
            "     /* make a buffer big enough */",
            "     total_length += 1;",
            " ",
            "     result = mem_alloc(total_length);",
            "     if(!result) {",
            "-        pdebug(DEBUG_ERROR,\"Unable to allocate new string buffer!\");",
            "+        pdebug(DEBUG_ERROR, \"Unable to allocate new string buffer!\");",
            "         return NULL;",
            "     }",
            " ",
            "     /* loop to copy the strings */",
            "     result[0] = 0;",
            "     va_start(arg_list, num_args);",
            "-    for(int i=0; i < num_args; i++) {",
            "+    for(int i = 0; i < num_args; i++) {",
            "         tmp = va_arg(arg_list, char *);",
            "         if(tmp) {",
            "             int len = str_length(result);",
            "             str_copy(&result[len], total_length - len, tmp);",
            "         }",
            "     }",
            "     va_end(arg_list);",
            " ",
            "     return result;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Mutexes ***********************************",
            "  **************************************************************************/",
            " ",
            " struct mutex_t {",
            "     pthread_mutex_t p_mutex;",
            "     int initialized;",
            " };",
            " ",
            "-int mutex_create(mutex_p *m)",
            "-{",
            "+int mutex_create(mutex_p *m) {",
            "     pthread_mutexattr_t mutex_attribs;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "-    if(*m) {",
            "-        pdebug(DEBUG_WARN, \"Called with non-NULL pointer!\");",
            "-    }",
            "+    if(*m) { pdebug(DEBUG_WARN, \"Called with non-NULL pointer!\"); }",
            " ",
            "     *m = (struct mutex_t *)mem_alloc(sizeof(struct mutex_t));",
            " ",
            "-    if(! *m) {",
            "-        pdebug(DEBUG_ERROR,\"null mutex pointer.\");",
            "+    if(!*m) {",
            "+        pdebug(DEBUG_ERROR, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     /* set up for recursive locking. */",
            "     pthread_mutexattr_init(&mutex_attribs);",
            "     pthread_mutexattr_settype(&mutex_attribs, PTHREAD_MUTEX_RECURSIVE);",
            " ",
            "-    if(pthread_mutex_init(&((*m)->p_mutex),&mutex_attribs)) {",
            "+    if(pthread_mutex_init(&((*m)->p_mutex), &mutex_attribs)) {",
            "         pthread_mutexattr_destroy(&mutex_attribs);",
            "         mem_free(*m);",
            "         *m = NULL;",
            "-        pdebug(DEBUG_ERROR,\"Error initializing mutex.\");",
            "+        pdebug(DEBUG_ERROR, \"Error initializing mutex.\");",
            "         return PLCTAG_ERR_MUTEX_INIT;",
            "     }",
            " ",
            "     (*m)->initialized = 1;",
            " ",
            "     pthread_mutexattr_destroy(&mutex_attribs);",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done creating mutex %p.\", *m);",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int mutex_lock_impl(const char *func, int line, mutex_p m)",
            "-{",
            "-    pdebug(DEBUG_SPEW,\"locking mutex %p, called from %s:%d.\", m, func, line);",
            "+int mutex_lock_impl(const char *func, int line, mutex_p m) {",
            "+    pdebug(DEBUG_SPEW, \"locking mutex %p, called from %s:%d.\", m, func, line);",
            " ",
            "     if(!m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(!m->initialized) {",
            "-        return PLCTAG_ERR_MUTEX_INIT;",
            "-    }",
            "+    if(!m->initialized) { return PLCTAG_ERR_MUTEX_INIT; }",
            " ",
            "     if(pthread_mutex_lock(&(m->p_mutex))) {",
            "         pdebug(DEBUG_WARN, \"error locking mutex.\");",
            "         return PLCTAG_ERR_MUTEX_LOCK;",
            "     }",
            " ",
            "-    //pdebug(DEBUG_SPEW,\"Done.\");",
            "-",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int mutex_try_lock_impl(const char *func, int line, mutex_p m)",
            "-{",
            "-    pdebug(DEBUG_SPEW,\"trying to lock mutex %p, called from %s:%d.\", m, func, line);",
            "+int mutex_try_lock_impl(const char *func, int line, mutex_p m) {",
            "+    pdebug(DEBUG_SPEW, \"trying to lock mutex %p, called from %s:%d.\", m, func, line);",
            " ",
            "     if(!m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(!m->initialized) {",
            "-        return PLCTAG_ERR_MUTEX_INIT;",
            "-    }",
            "+    if(!m->initialized) { return PLCTAG_ERR_MUTEX_INIT; }",
            " ",
            "     if(pthread_mutex_trylock(&(m->p_mutex))) {",
            "         pdebug(DEBUG_SPEW, \"error locking mutex.\");",
            "         return PLCTAG_ERR_MUTEX_LOCK;",
            "     }",
            " ",
            "     /*pdebug(DEBUG_DETAIL,\"Done.\");*/",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int mutex_unlock_impl(const char *func, int line, mutex_p m)",
            "-{",
            "-    pdebug(DEBUG_SPEW,\"unlocking mutex %p, called from %s:%d.\", m, func, line);",
            "+int mutex_unlock_impl(const char *func, int line, mutex_p m) {",
            "+    pdebug(DEBUG_SPEW, \"unlocking mutex %p, called from %s:%d.\", m, func, line);",
            " ",
            "     if(!m) {",
            "-        pdebug(DEBUG_WARN,\"null mutex pointer.\");",
            "+        pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(!m->initialized) {",
            "-        return PLCTAG_ERR_MUTEX_INIT;",
            "-    }",
            "+    if(!m->initialized) { return PLCTAG_ERR_MUTEX_INIT; }",
            " ",
            "     if(pthread_mutex_unlock(&(m->p_mutex))) {",
            "         pdebug(DEBUG_WARN, \"error unlocking mutex.\");",
            "         return PLCTAG_ERR_MUTEX_UNLOCK;",
            "     }",
            " ",
            "-    //pdebug(DEBUG_SPEW,\"Done.\");",
            "+    // pdebug(DEBUG_SPEW,\"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int mutex_destroy(mutex_p *m)",
            "-{",
            "+int mutex_destroy(mutex_p *m) {",
            "     pdebug(DEBUG_DETAIL, \"Starting to destroy mutex %p.\", m);",
            " ",
            "     if(!m || !*m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "@@ -773,19 +695,14 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Threads ***********************************",
            "  **************************************************************************/",
            " ",
            " struct thread_t {",
            "     pthread_t p_thread;",
            "     int initialized;",
            "@@ -796,28 +713,27 @@",
            "  *",
            "  * Start up a new thread.  This allocates the thread_t structure and starts",
            "  * the passed function.  The arg argument is passed to the function.",
            "  *",
            "  * TODO - use the stacksize!",
            "  */",
            " ",
            "-extern int thread_create(thread_p *t, thread_func_t func, int stacksize, void *arg)",
            "-{",
            "+extern int thread_create(thread_p *t, thread_func_t func, int stacksize, void *arg) {",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Warning: ignoring stacksize (%d) parameter.\", stacksize);",
            " ",
            "     if(!t) {",
            "         pdebug(DEBUG_WARN, \"null thread pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     *t = (thread_p)mem_alloc(sizeof(struct thread_t));",
            " ",
            "-    if(! *t) {",
            "+    if(!*t) {",
            "         pdebug(DEBUG_ERROR, \"Failed to allocate memory for thread.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     /* create a pthread.  0 means success. */",
            "     if(pthread_create(&((*t)->p_thread), NULL, func, arg)) {",
            "         pdebug(DEBUG_ERROR, \"error creating thread.\");",
            "@@ -832,28 +748,24 @@",
            " ",
            " /*",
            "  * platform_thread_stop()",
            "  *",
            "  * Stop the current thread.  Does not take arguments.  Note: the thread",
            "  * ends completely and this function does not return!",
            "  */",
            "-void thread_stop(void)",
            "-{",
            "-    pthread_exit((void*)0);",
            "-}",
            "+void thread_stop(void) { pthread_exit((void *)0); }",
            " ",
            " ",
            " /*",
            "  * thread_kill()",
            "  *",
            "  * Kill another thread.",
            "  */",
            " ",
            "-void thread_kill(thread_p t)",
            "-{",
            "+void thread_kill(thread_p t) {",
            "     if(t) {",
            " #ifdef __ANDROID__",
            "         pthread_kill(t->p_thread, 0);",
            " #else",
            "         pthread_cancel(t->p_thread);",
            " #endif /* __ANDROID__ */",
            "     }",
            "@@ -861,26 +773,25 @@",
            " ",
            " /*",
            "  * thread_join()",
            "  *",
            "  * Wait for the argument thread to stop and then continue.",
            "  */",
            " ",
            "-int thread_join(thread_p t)",
            "-{",
            "+int thread_join(thread_p t) {",
            "     void *unused;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!t) {",
            "         pdebug(DEBUG_WARN, \"null thread pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(pthread_join(t->p_thread,&unused)) {",
            "+    if(pthread_join(t->p_thread, &unused)) {",
            "         pdebug(DEBUG_ERROR, \"Error joining thread.\");",
            "         return PLCTAG_ERR_THREAD_JOIN;",
            "     }",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            "@@ -889,52 +800,45 @@",
            " ",
            " /*",
            "  * thread_detach",
            "  *",
            "  * Detach the thread.  You cannot call thread_join on a detached thread!",
            "  */",
            " ",
            "-extern int thread_detach()",
            "-{",
            "+extern int thread_detach(void) {",
            "     pthread_detach(pthread_self());",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * thread_destroy",
            "  *",
            "  * This gets rid of the resources of a thread struct.  The thread in",
            "  * question must be dead first!",
            "  */",
            "-extern int thread_destroy(thread_p *t)",
            "-{",
            "+extern int thread_destroy(thread_p *t) {",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "-    if(!t || ! *t) {",
            "+    if(!t || !*t) {",
            "         pdebug(DEBUG_WARN, \"null thread pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     mem_free(*t);",
            " ",
            "     *t = NULL;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Atomic Ops ********************************",
            "  **************************************************************************/",
            " ",
            " /*",
            "  * lock_acquire",
            "  *",
            "@@ -943,65 +847,59 @@",
            "  * Returns non-zero on success.",
            "  *",
            "  * Warning: do not pass null pointers!",
            "  */",
            " ",
            " #define ATOMIC_LOCK_VAL (1)",
            " ",
            "-extern int lock_acquire_try(lock_t *lock)",
            "-{",
            "-    int rc = __sync_lock_test_and_set((int*)lock, ATOMIC_LOCK_VAL);",
            "+extern int lock_acquire_try(lock_t *lock) {",
            "+    int rc = __sync_lock_test_and_set((int *)lock, ATOMIC_LOCK_VAL);",
            " ",
            "     if(rc != ATOMIC_LOCK_VAL) {",
            "         return 1;",
            "     } else {",
            "         return 0;",
            "     }",
            " }",
            " ",
            "-int lock_acquire(lock_t *lock)",
            "-{",
            "-    while(!lock_acquire_try(lock)) ;",
            "+int lock_acquire(lock_t *lock) {",
            "+    while(!lock_acquire_try(lock));",
            " ",
            "     return 1;",
            " }",
            " ",
            " ",
            "-extern void lock_release(lock_t *lock)",
            "-{",
            "-    __sync_lock_release((int*)lock);",
            "+extern void lock_release(lock_t *lock) {",
            "+    __sync_lock_release((int *)lock);",
            "     /*pdebug(\"released lock\");*/",
            " }",
            " ",
            " ",
            " /***************************************************************************",
            "  ************************* Condition Variables *****************************",
            "  ***************************************************************************/",
            " ",
            " struct cond_t {",
            "     pthread_mutex_t mutex;",
            "     pthread_cond_t cond;",
            "     int flag;",
            " };",
            " ",
            "-int cond_create(cond_p *c)",
            "-{",
            "+int cond_create(cond_p *c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     cond_p tmp_cond = NULL;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!c) {",
            "         pdebug(DEBUG_WARN, \"Null pointer to condition var pointer!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(*c) {",
            "-        pdebug(DEBUG_WARN, \"Condition var pointer is not null, was it not deleted first?\");",
            "-    }",
            "+    if(*c) { pdebug(DEBUG_WARN, \"Condition var pointer is not null, was it not deleted first?\"); }",
            " ",
            "     /* clear the output first. */",
            "     *c = NULL;",
            " ",
            "     tmp_cond = mem_alloc((int)(unsigned int)sizeof(*tmp_cond));",
            "     if(!tmp_cond) {",
            "         pdebug(DEBUG_WARN, \"Unable to allocate new condition var!\");",
            "@@ -1027,16 +925,15 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_wait_impl(const char *func, int line_num, cond_p c, int timeout_ms)",
            "-{",
            "+int cond_wait_impl(const char *func, int line_num, cond_p c, int timeout_ms) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int64_t start_time = time_ms();",
            "     int64_t end_time = start_time + timeout_ms;",
            "     struct timespec timeout;",
            " ",
            "     pdebug(DEBUG_SPEW, \"Starting. Called from %s:%d.\", func, line_num);",
            " ",
            "@@ -1046,15 +943,15 @@",
            "     }",
            " ",
            "     if(timeout_ms <= 0) {",
            "         pdebug(DEBUG_WARN, \"Timeout must be a positive value but was %d in call from %s:%d!\", timeout_ms, func, line_num);",
            "         return PLCTAG_ERR_BAD_PARAM;",
            "     }",
            " ",
            "-    if(pthread_mutex_lock(& (c->mutex))) {",
            "+    if(pthread_mutex_lock(&(c->mutex))) {",
            "         pdebug(DEBUG_WARN, \"Unable to lock mutex!\");",
            "         return PLCTAG_ERR_MUTEX_LOCK;",
            "     }",
            " ",
            "     /*",
            "      * set up timeout.",
            "      *",
            "@@ -1097,95 +994,92 @@",
            " ",
            "         /* clear the flag now that we've responded. */",
            "         c->flag = 0;",
            "     } else {",
            "         pdebug(DEBUG_SPEW, \"Condition wait terminated due to error or timeout for call at %s:%d.\", func, line_num);",
            "     }",
            " ",
            "-    if(pthread_mutex_unlock(& (c->mutex))) {",
            "+    if(pthread_mutex_unlock(&(c->mutex))) {",
            "         pdebug(DEBUG_WARN, \"Unable to unlock mutex!\");",
            "         return PLCTAG_ERR_MUTEX_UNLOCK;",
            "     }",
            " ",
            "     pdebug(DEBUG_SPEW, \"Done for call at %s:%d.\", func, line_num);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_signal_impl(const char *func, int line_num, cond_p c)",
            "-{",
            "+int cond_signal_impl(const char *func, int line_num, cond_p c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_SPEW, \"Starting.  Called from %s:%d.\", func, line_num);",
            " ",
            "     if(!c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null in call at %s:%d!\", func, line_num);",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(pthread_mutex_lock(& (c->mutex))) {",
            "+    if(pthread_mutex_lock(&(c->mutex))) {",
            "         pdebug(DEBUG_WARN, \"Unable to lock mutex!\");",
            "         return PLCTAG_ERR_MUTEX_LOCK;",
            "     }",
            " ",
            "     c->flag = 1;",
            " ",
            "     if(pthread_cond_signal(&(c->cond))) {",
            "         pdebug(DEBUG_WARN, \"Signal of condition var returned error %d in call at %s:%d!\", errno, func, line_num);",
            "         rc = PLCTAG_ERR_BAD_STATUS;",
            "     }",
            " ",
            "-    if(pthread_mutex_unlock(& (c->mutex))) {",
            "+    if(pthread_mutex_unlock(&(c->mutex))) {",
            "         pdebug(DEBUG_WARN, \"Unable to unlock mutex!\");",
            "         return PLCTAG_ERR_MUTEX_UNLOCK;",
            "     }",
            " ",
            "     pdebug(DEBUG_SPEW, \"Done. Called from %s:%d.\", func, line_num);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_clear_impl(const char *func, int line_num, cond_p c)",
            "-{",
            "+int cond_clear_impl(const char *func, int line_num, cond_p c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_SPEW, \"Starting.  Called from %s:%d.\", func, line_num);",
            " ",
            "     if(!c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null in call at %s:%d!\", func, line_num);",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(pthread_mutex_lock(& (c->mutex))) {",
            "+    if(pthread_mutex_lock(&(c->mutex))) {",
            "         pdebug(DEBUG_WARN, \"Unable to lock mutex!\");",
            "         return PLCTAG_ERR_MUTEX_LOCK;",
            "     }",
            " ",
            "     c->flag = 0;",
            " ",
            "-    if(pthread_mutex_unlock(& (c->mutex))) {",
            "+    if(pthread_mutex_unlock(&(c->mutex))) {",
            "         pdebug(DEBUG_WARN, \"Unable to unlock mutex!\");",
            "         return PLCTAG_ERR_MUTEX_UNLOCK;",
            "     }",
            " ",
            "     pdebug(DEBUG_SPEW, \"Done. Called from %s:%d.\", func, line_num);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_destroy(cond_p *c)",
            "-{",
            "+int cond_destroy(cond_p *c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "-    if(!c || ! *c) {",
            "+    if(!c || !*c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     pthread_cond_destroy(&((*c)->cond));",
            "     pthread_mutex_destroy(&((*c)->mutex));",
            " ",
            "@@ -1195,22 +1089,21 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            " /***************************************************************************",
            "  ******************************* Sockets ***********************************",
            "  **************************************************************************/",
            " ",
            " ",
            " #ifndef INVALID_SOCKET",
            "-#define INVALID_SOCKET (-1)",
            "+#    define INVALID_SOCKET (-1)",
            " #endif",
            " ",
            " struct sock_t {",
            "     int fd;",
            "     int wake_read_fd;",
            "     int wake_write_fd;",
            "     int port;",
            "@@ -1218,28 +1111,27 @@",
            " };",
            " ",
            " ",
            " static int sock_create_event_wakeup_channel(sock_p sock);",
            " ",
            " #define MAX_IPS (8)",
            " ",
            "-extern int socket_create(sock_p *s)",
            "-{",
            "+extern int socket_create(sock_p *s) {",
            "     int32_t rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"null socket pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     *s = (sock_p)mem_alloc(sizeof(struct sock_t));",
            " ",
            "-    if(! *s) {",
            "+    if(!*s) {",
            "         pdebug(DEBUG_ERROR, \"Failed to allocate memory for socket.\");",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "     (*s)->fd = INVALID_SOCKET;",
            "     (*s)->wake_read_fd = INVALID_SOCKET;",
            "     (*s)->wake_write_fd = INVALID_SOCKET;",
            "@@ -1253,123 +1145,120 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-int socket_connect_tcp_start(sock_p s, const char *host, int port)",
            "-{",
            "+int socket_connect_tcp_start(sock_p s, const char *host, int port) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     struct in_addr ips[MAX_IPS];",
            "     int num_ips = 0;",
            "     struct sockaddr_in gw_addr;",
            "     int sock_opt = 1;",
            "     int i = 0;",
            "     int done = 0;",
            "     int fd;",
            "     int flags;",
            "-    struct timeval timeout; /* used for timing out connections etc. */",
            "+    struct timeval timeout;  /* used for timing out connections etc. */",
            "     struct linger so_linger; /* used to set up short/no lingering after connections are close()ed. */",
            " ",
            "-    pdebug(DEBUG_DETAIL,\"Starting.\");",
            "+    pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     /* Open a socket for communication with the gateway. */",
            "     fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);",
            " ",
            "     /* check for errors */",
            "     if(fd < 0) {",
            "-        pdebug(DEBUG_ERROR,\"Socket creation failed, errno: %d\",errno);",
            "+        pdebug(DEBUG_ERROR, \"Socket creation failed, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* set up our socket to allow reuse if we crash suddenly. */",
            "     sock_opt = 1;",
            " ",
            "-    if(setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,(char*)&sock_opt,sizeof(sock_opt))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&sock_opt, sizeof(sock_opt))) {",
            "         close(fd);",
            "-        pdebug(DEBUG_ERROR, \"Error setting socket reuse option, errno: %d\",errno);",
            "+        pdebug(DEBUG_ERROR, \"Error setting socket reuse option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            " #ifdef BSD_OS_TYPE",
            "     /* The *BSD family has a different way to suppress SIGPIPE on sockets. */",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, (char*)&sock_opt, sizeof(sock_opt))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, (char *)&sock_opt, sizeof(sock_opt))) {",
            "         close(fd);",
            "         pdebug(DEBUG_ERROR, \"Error setting socket SIGPIPE suppression option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " #endif",
            " ",
            "     timeout.tv_sec = 10;",
            "     timeout.tv_usec = 0;",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout))) {",
            "         close(fd);",
            "-        pdebug(DEBUG_ERROR,\"Error setting socket receive timeout option, errno: %d\",errno);",
            "+        pdebug(DEBUG_ERROR, \"Error setting socket receive timeout option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout))) {",
            "         close(fd);",
            "-        pdebug(DEBUG_ERROR, \"Error setting socket set timeout option, errno: %d\",errno);",
            "+        pdebug(DEBUG_ERROR, \"Error setting socket set timeout option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* abort the connection immediately upon close. */",
            "     so_linger.l_onoff = 1;",
            "     so_linger.l_linger = 0;",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_LINGER,(char*)&so_linger,sizeof(so_linger))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&so_linger, sizeof(so_linger))) {",
            "         close(fd);",
            "-        pdebug(DEBUG_ERROR,\"Error setting socket close linger option, errno: %d\",errno);",
            "+        pdebug(DEBUG_ERROR, \"Error setting socket close linger option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* make the socket non-blocking. */",
            "-    flags=fcntl(fd,F_GETFL,0);",
            "-    if(flags<0) {",
            "+    flags = fcntl(fd, F_GETFL, 0);",
            "+    if(flags < 0) {",
            "         pdebug(DEBUG_ERROR, \"Error getting socket options, errno: %d\", errno);",
            "         close(fd);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* set the non-blocking flag. */",
            "     flags |= O_NONBLOCK;",
            " ",
            "-    if(fcntl(fd,F_SETFL,flags)<0) {",
            "+    if(fcntl(fd, F_SETFL, flags) < 0) {",
            "         pdebug(DEBUG_ERROR, \"Error setting socket to non-blocking, errno: %d\", errno);",
            "         close(fd);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* figure out what address we are connecting to. */",
            " ",
            "     /* try a numeric IP address conversion first. */",
            "-    if(inet_pton(AF_INET,host,(struct in_addr *)ips) > 0) {",
            "-        pdebug(DEBUG_DETAIL, \"Found numeric IP address: %s\",host);",
            "+    if(inet_pton(AF_INET, host, (struct in_addr *)ips) > 0) {",
            "+        pdebug(DEBUG_DETAIL, \"Found numeric IP address: %s\", host);",
            "         num_ips = 1;",
            "     } else {",
            "         struct addrinfo hints;",
            "         struct addrinfo *res_head = NULL;",
            "-        struct addrinfo *res=NULL;",
            "+        struct addrinfo *res = NULL;",
            "         int rc = 0;",
            " ",
            "         mem_set(&ips, 0, sizeof(ips));",
            "         mem_set(&hints, 0, sizeof(hints));",
            " ",
            "         hints.ai_socktype = SOCK_STREAM; /* TCP */",
            "-        hints.ai_family = AF_INET; /* IP V4 only */",
            "+        hints.ai_family = AF_INET;       /* IP V4 only */",
            " ",
            "-        if ((rc = getaddrinfo(host, NULL, &hints, &res_head)) != 0) {",
            "-            pdebug(DEBUG_WARN,\"Error looking up PLC IP address %s, error = %d\\n\", host, rc);",
            "+        if((rc = getaddrinfo(host, NULL, &hints, &res_head)) != 0) {",
            "+            pdebug(DEBUG_WARN, \"Error looking up PLC IP address %s, error = %d\\n\", host, rc);",
            " ",
            "-            if(res_head) {",
            "-                freeaddrinfo(res_head);",
            "-            }",
            "+            if(res_head) { freeaddrinfo(res_head); }",
            " ",
            "             close(fd);",
            "             return PLCTAG_ERR_BAD_GATEWAY;",
            "         }",
            " ",
            "         res = res_head;",
            "         for(num_ips = 0; res && num_ips < MAX_IPS; num_ips++) {",
            "@@ -1390,41 +1279,42 @@",
            "     /* now try to connect to the remote gateway.  We may need to",
            "      * try several of the IPs we have.",
            "      */",
            " ",
            "     i = 0;",
            "     done = 0;",
            " ",
            "-    memset((void *)&gw_addr,0, sizeof(gw_addr));",
            "-    gw_addr.sin_family = AF_INET ;",
            "+    // NOLINTNEXTLINE",
            "+    memset((void *)&gw_addr, 0, sizeof(gw_addr));",
            "+",
            "+    gw_addr.sin_family = AF_INET;",
            "     gw_addr.sin_port = htons((uint16_t)port);",
            " ",
            "     do {",
            "         /* try each IP until we run out or get a connection started. */",
            "         gw_addr.sin_addr.s_addr = ips[i].s_addr;",
            " ",
            "         pdebug(DEBUG_DETAIL, \"Attempting to connect to %s:%d\", inet_ntoa(*((struct in_addr *)&ips[i])), port);",
            " ",
            "         /* this is done non-blocking. Could be interrupted, so restart if needed.*/",
            "-        do {",
            "-            rc = connect(fd,(struct sockaddr *)&gw_addr,sizeof(gw_addr));",
            "-        } while(rc < 0 && errno == EINTR);",
            "+        do { rc = connect(fd, (struct sockaddr *)&gw_addr, sizeof(gw_addr)); } while(rc < 0 && errno == EINTR);",
            " ",
            "         if(rc == 0) {",
            "             /* instantly connected. */",
            "             pdebug(DEBUG_DETAIL, \"Connected instantly to %s:%d.\", inet_ntoa(*((struct in_addr *)&ips[i])), port);",
            "             done = 1;",
            "             rc = PLCTAG_STATUS_OK;",
            "         } else if(rc < 0 && (errno == EINPROGRESS)) {",
            "             /* the connection has started. */",
            "             pdebug(DEBUG_DETAIL, \"Started connecting to %s:%d successfully.\", inet_ntoa(*((struct in_addr *)&ips[i])), port);",
            "             done = 1;",
            "             rc = PLCTAG_STATUS_PENDING;",
            "-        } else  {",
            "-            pdebug(DEBUG_DETAIL, \"Attempt to connect to %s:%d failed, errno: %d\", inet_ntoa(*((struct in_addr *)&ips[i])),port, errno);",
            "+        } else {",
            "+            pdebug(DEBUG_DETAIL, \"Attempt to connect to %s:%d failed, errno: %d\", inet_ntoa(*((struct in_addr *)&ips[i])), port,",
            "+                   errno);",
            "             i++;",
            "         }",
            "     } while(!done && i < num_ips);",
            " ",
            "     if(!done) {",
            "         close(fd);",
            "         pdebug(DEBUG_ERROR, \"Unable to connect to any gateway host IP address!\");",
            "@@ -1439,46 +1329,43 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done with status %s.\", plc_tag_decode_error(rc));",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_connect_tcp_check(sock_p sock, int timeout_ms)",
            "-{",
            "+int socket_connect_tcp_check(sock_p sock, int timeout_ms) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     fd_set write_set;",
            "     struct timeval tv;",
            "     int select_rc = 0;",
            "     int sock_err = 0;",
            "     socklen_t sock_err_len = (socklen_t)(sizeof(sock_err));",
            " ",
            " ",
            "-    pdebug(DEBUG_DETAIL,\"Starting.\");",
            "+    pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!sock) {",
            "         pdebug(DEBUG_WARN, \"Null socket pointer passed!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     /* wait for the socket to be ready. */",
            "     tv.tv_sec = (time_t)(timeout_ms / 1000);",
            "     tv.tv_usec = (suseconds_t)(timeout_ms % 1000) * (suseconds_t)(1000);",
            " ",
            "     FD_ZERO(&write_set);",
            " ",
            "     FD_SET(sock->fd, &write_set);",
            " ",
            "-    select_rc = select(sock->fd+1, NULL, &write_set, NULL, &tv);",
            "+    select_rc = select(sock->fd + 1, NULL, &write_set, NULL, &tv);",
            " ",
            "     if(select_rc == 1) {",
            "         if(FD_ISSET(sock->fd, &write_set)) {",
            "             pdebug(DEBUG_DETAIL, \"Socket is probably connected.\");",
            "-            rc = PLCTAG_STATUS_OK;",
            "         } else {",
            "             pdebug(DEBUG_WARN, \"select() returned but socket is not connected!\");",
            "             return PLCTAG_ERR_BAD_REPLY;",
            "         }",
            "     } else if(select_rc == 0) {",
            "         pdebug(DEBUG_DETAIL, \"Socket connection not done yet.\");",
            "         return PLCTAG_ERR_TIMEOUT;",
            "@@ -1493,15 +1380,17 @@",
            " ",
            "             case EINTR: /* signal was caught, this should not happen! */",
            "                 pdebug(DEBUG_WARN, \"A signal was caught in select() and this should not happen!\");",
            "                 return PLCTAG_ERR_OPEN;",
            "                 break;",
            " ",
            "             case EINVAL: /* number of FDs was negative or exceeded the max allowed. */",
            "-                pdebug(DEBUG_WARN, \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "+                pdebug(",
            "+                    DEBUG_WARN,",
            "+                    \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "                 return PLCTAG_ERR_OPEN;",
            "                 break;",
            " ",
            "             case ENOMEM: /* No mem for internal tables. */",
            "                 pdebug(DEBUG_WARN, \"Insufficient memory for select() to run!\");",
            "                 return PLCTAG_ERR_NO_MEM;",
            "                 break;",
            "@@ -1514,18 +1403,15 @@",
            "     }",
            " ",
            "     /* now make absolutely sure that the connection is ready. */",
            "     rc = getsockopt(sock->fd, SOL_SOCKET, SO_ERROR, &sock_err, &sock_err_len);",
            "     if(rc == 0) {",
            "         /* sock_err has the error. */",
            "         switch(sock_err) {",
            "-            case 0:",
            "-                pdebug(DEBUG_DETAIL, \"No error, socket is connected.\");",
            "-                rc = PLCTAG_STATUS_OK;",
            "-                break;",
            "+            case 0: pdebug(DEBUG_DETAIL, \"No error, socket is connected.\"); break;",
            " ",
            "             case EBADF:",
            "                 pdebug(DEBUG_WARN, \"Socket fd is not valid!\");",
            "                 return PLCTAG_ERR_OPEN;",
            "                 break;",
            " ",
            "             case EFAULT:",
            "@@ -1565,17 +1451,15 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_wait_event(sock_p sock, int events, int timeout_ms)",
            "-{",
            "+int socket_wait_event(sock_p sock, int events, int timeout_ms) {",
            "     int result = SOCK_EVENT_NONE;",
            "     fd_set read_set;",
            "     fd_set write_set;",
            "     fd_set err_set;",
            "     int max_fd = 0;",
            "     int num_sockets = 0;",
            " ",
            "@@ -1613,21 +1497,17 @@",
            "     /* add the wake fd */",
            "     FD_SET(sock->wake_read_fd, &read_set);",
            " ",
            "     /* we always want to know about errors. */",
            "     FD_SET(sock->fd, &err_set);",
            " ",
            "     /* add more depending on the mask. */",
            "-    if(events & SOCK_EVENT_CAN_READ) {",
            "-        FD_SET(sock->fd, &read_set);",
            "-    }",
            "+    if(events & SOCK_EVENT_CAN_READ) { FD_SET(sock->fd, &read_set); }",
            " ",
            "-    if((events & SOCK_EVENT_CONNECT) || (events & SOCK_EVENT_CAN_WRITE)) {",
            "-        FD_SET(sock->fd, &write_set);",
            "-    }",
            "+    if((events & SOCK_EVENT_CONNECT) || (events & SOCK_EVENT_CAN_WRITE)) { FD_SET(sock->fd, &write_set); }",
            " ",
            "     /* calculate the timeout. */",
            "     if(timeout_ms > 0) {",
            "         struct timeval tv;",
            " ",
            "         tv.tv_sec = (time_t)(timeout_ms / 1000);",
            "         tv.tv_usec = (suseconds_t)(timeout_ms % 1000) * (suseconds_t)(1000);",
            "@@ -1638,19 +1518,18 @@",
            "     }",
            " ",
            "     if(num_sockets == 0) {",
            "         result |= (events & SOCK_EVENT_TIMEOUT);",
            "     } else if(num_sockets > 0) {",
            "         /* was there a wake up? */",
            "         if(FD_ISSET(sock->wake_read_fd, &read_set)) {",
            "-            int bytes_read = 0;",
            "             char buf[32];",
            " ",
            "             /* empty the socket. */",
            "-            while((bytes_read = (int)read(sock->wake_read_fd, &buf[0], sizeof(buf))) > 0) { }",
            "+            while((int)read(sock->wake_read_fd, &buf[0], sizeof(buf)) > 0) {}",
            " ",
            "             pdebug(DEBUG_DETAIL, \"Socket woken up.\");",
            "             result |= (events & SOCK_EVENT_WAKE_UP);",
            "         }",
            " ",
            "         /* is read ready for the main fd? */",
            "         if(FD_ISSET(sock->fd, &read_set)) {",
            "@@ -1691,15 +1570,17 @@",
            " ",
            "             case EINTR: /* signal was caught, this should not happen! */",
            "                 pdebug(DEBUG_WARN, \"A signal was caught in select() and this should not happen!\");",
            "                 return PLCTAG_ERR_BAD_CONFIG;",
            "                 break;",
            " ",
            "             case EINVAL: /* number of FDs was negative or exceeded the max allowed. */",
            "-                pdebug(DEBUG_WARN, \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "+                pdebug(",
            "+                    DEBUG_WARN,",
            "+                    \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "                 return PLCTAG_ERR_BAD_PARAM;",
            "                 break;",
            " ",
            "             case ENOMEM: /* No mem for internal tables. */",
            "                 pdebug(DEBUG_WARN, \"Insufficient memory for select() to run!\");",
            "                 return PLCTAG_ERR_NO_MEM;",
            "                 break;",
            "@@ -1713,16 +1594,15 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return result;",
            " }",
            " ",
            " ",
            "-int socket_wake(sock_p sock)",
            "-{",
            "+int socket_wake(sock_p sock) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     const char dummy_data[] = \"Dummy data.\";",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!sock) {",
            "         pdebug(DEBUG_WARN, \"Null socket pointer passed!\");",
            "@@ -1751,17 +1631,15 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_read(sock_p s, uint8_t *buf, int size, int timeout_ms)",
            "-{",
            "+int socket_read(sock_p s, uint8_t *buf, int size, int timeout_ms) {",
            "     int rc;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer is null!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -1784,26 +1662,26 @@",
            " ",
            "     /*",
            "      * Try to read immediately.   If we get data, we skip any other",
            "      * delays.   If we do not, then see if we have a timeout.",
            "      */",
            " ",
            "     /* The socket is non-blocking. */",
            "-    rc = (int)read(s->fd,buf,(size_t)size);",
            "+    rc = (int)read(s->fd, buf, (size_t)size);",
            "     if(rc < 0) {",
            "         if(errno == EAGAIN || errno == EWOULDBLOCK) {",
            "             if(timeout_ms > 0) {",
            "                 pdebug(DEBUG_DETAIL, \"Immediate read attempt did not succeed, now wait for select().\");",
            "             } else {",
            "                 pdebug(DEBUG_DETAIL, \"Read resulted in no data.\");",
            "             }",
            " ",
            "             rc = 0;",
            "         } else {",
            "-            pdebug(DEBUG_WARN,\"Socket read error: rc=%d, errno=%d\", rc, errno);",
            "+            pdebug(DEBUG_WARN, \"Socket read error: rc=%d, errno=%d\", rc, errno);",
            "             return PLCTAG_ERR_READ;",
            "         }",
            "     }",
            " ",
            "     /* only wait if we have a timeout and no error and no data. */",
            "     if(rc == 0 && timeout_ms > 0) {",
            "         fd_set read_set;",
            "@@ -1813,15 +1691,15 @@",
            "         tv.tv_sec = (time_t)(timeout_ms / 1000);",
            "         tv.tv_usec = (suseconds_t)(timeout_ms % 1000) * (suseconds_t)(1000);",
            " ",
            "         FD_ZERO(&read_set);",
            " ",
            "         FD_SET(s->fd, &read_set);",
            " ",
            "-        select_rc = select(s->fd+1, &read_set, NULL, NULL, &tv);",
            "+        select_rc = select(s->fd + 1, &read_set, NULL, NULL, &tv);",
            "         if(select_rc == 1) {",
            "             if(FD_ISSET(s->fd, &read_set)) {",
            "                 pdebug(DEBUG_DETAIL, \"Socket can read data.\");",
            "             } else {",
            "                 pdebug(DEBUG_WARN, \"select() returned but socket is not ready to read data!\");",
            "                 return PLCTAG_ERR_BAD_REPLY;",
            "             }",
            "@@ -1839,15 +1717,17 @@",
            " ",
            "                 case EINTR: /* signal was caught, this should not happen! */",
            "                     pdebug(DEBUG_WARN, \"A signal was caught in select() and this should not happen!\");",
            "                     return PLCTAG_ERR_BAD_CONFIG;",
            "                     break;",
            " ",
            "                 case EINVAL: /* number of FDs was negative or exceeded the max allowed. */",
            "-                    pdebug(DEBUG_WARN, \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "+                    pdebug(",
            "+                        DEBUG_WARN,",
            "+                        \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "                     return PLCTAG_ERR_BAD_PARAM;",
            "                     break;",
            " ",
            "                 case ENOMEM: /* No mem for internal tables. */",
            "                     pdebug(DEBUG_WARN, \"Insufficient memory for select() to run!\");",
            "                     return PLCTAG_ERR_NO_MEM;",
            "                     break;",
            "@@ -1856,35 +1736,33 @@",
            "                     pdebug(DEBUG_WARN, \"Unexpected socket err %d!\", errno);",
            "                     return PLCTAG_ERR_BAD_STATUS;",
            "                     break;",
            "             }",
            "         }",
            " ",
            "         /* try to read again. */",
            "-        rc = (int)read(s->fd,buf,(size_t)size);",
            "+        rc = (int)read(s->fd, buf, (size_t)size);",
            "         if(rc < 0) {",
            "             if(errno == EAGAIN || errno == EWOULDBLOCK) {",
            "                 pdebug(DEBUG_DETAIL, \"No data read.\");",
            "                 rc = 0;",
            "             } else {",
            "-                pdebug(DEBUG_WARN,\"Socket read error: rc=%d, errno=%d\", rc, errno);",
            "+                pdebug(DEBUG_WARN, \"Socket read error: rc=%d, errno=%d\", rc, errno);",
            "                 return PLCTAG_ERR_READ;",
            "             }",
            "         }",
            "     }",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done: result %d.\", rc);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_write(sock_p s, uint8_t *buf, int size, int timeout_ms)",
            "-{",
            "+int socket_write(sock_p s, uint8_t *buf, int size, int timeout_ms) {",
            "     int rc;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer is null!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -1939,15 +1817,15 @@",
            "         tv.tv_sec = (time_t)(timeout_ms / 1000);",
            "         tv.tv_usec = (suseconds_t)(timeout_ms % 1000) * (suseconds_t)(1000);",
            " ",
            "         FD_ZERO(&write_set);",
            " ",
            "         FD_SET(s->fd, &write_set);",
            " ",
            "-        select_rc = select(s->fd+1, NULL, &write_set, NULL, &tv);",
            "+        select_rc = select(s->fd + 1, NULL, &write_set, NULL, &tv);",
            "         if(select_rc == 1) {",
            "             if(FD_ISSET(s->fd, &write_set)) {",
            "                 pdebug(DEBUG_DETAIL, \"Socket can write data.\");",
            "             } else {",
            "                 pdebug(DEBUG_WARN, \"select() returned but socket is not ready to write data!\");",
            "                 return PLCTAG_ERR_BAD_REPLY;",
            "             }",
            "@@ -1965,15 +1843,17 @@",
            " ",
            "                 case EINTR: /* signal was caught, this should not happen! */",
            "                     pdebug(DEBUG_WARN, \"A signal was caught in select() and this should not happen!\");",
            "                     return PLCTAG_ERR_BAD_CONFIG;",
            "                     break;",
            " ",
            "                 case EINVAL: /* number of FDs was negative or exceeded the max allowed. */",
            "-                    pdebug(DEBUG_WARN, \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "+                    pdebug(",
            "+                        DEBUG_WARN,",
            "+                        \"The number of fds passed to select() was negative or exceeded the allowed limit or the timeout is invalid!\");",
            "                     return PLCTAG_ERR_BAD_PARAM;",
            "                     break;",
            " ",
            "                 case ENOMEM: /* No mem for internal tables. */",
            "                     pdebug(DEBUG_WARN, \"Insufficient memory for select() to run!\");",
            "                     return PLCTAG_ERR_NO_MEM;",
            "                     break;",
            "@@ -1982,21 +1862,21 @@",
            "                     pdebug(DEBUG_WARN, \"Unexpected socket err %d!\", errno);",
            "                     return PLCTAG_ERR_BAD_STATUS;",
            "                     break;",
            "             }",
            "         }",
            " ",
            "         /* select() passed and said we can write, so try. */",
            "-    #ifdef BSD_OS_TYPE",
            "+#ifdef BSD_OS_TYPE",
            "         /* On *BSD and macOS, the socket option is set to prevent SIGPIPE. */",
            "         rc = (int)write(s->fd, buf, (size_t)size);",
            "-    #else",
            "+#else",
            "         /* on Linux, we use MSG_NOSIGNAL */",
            "         rc = (int)send(s->fd, buf, (size_t)size, MSG_NOSIGNAL);",
            "-    #endif",
            "+#endif",
            " ",
            "         if(rc < 0) {",
            "             if(errno == EAGAIN || errno == EWOULDBLOCK) {",
            "                 pdebug(DEBUG_DETAIL, \"No data written.\");",
            "                 rc = 0;",
            "             } else {",
            "                 pdebug(DEBUG_WARN, \"Socket write error: rc=%d, errno=%d\", rc, errno);",
            "@@ -2007,17 +1887,15 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done: result = %d.\", rc);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_close(sock_p s)",
            "-{",
            "+int socket_close(sock_p s) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_INFO, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer or pointer to socket pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -2036,42 +1914,31 @@",
            " ",
            "     pdebug(DEBUG_INFO, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int socket_destroy(sock_p *s)",
            "-{",
            "-    int rc = PLCTAG_STATUS_OK;",
            "-",
            "+int socket_destroy(sock_p *s) {",
            "     pdebug(DEBUG_INFO, \"Starting.\");",
            " ",
            "     if(!s || !*s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer or pointer to socket pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     /* close the wake sockets */",
            "     if((*s)->wake_read_fd != INVALID_SOCKET) {",
            "-        if(close((*s)->wake_read_fd)) {",
            "-            pdebug(DEBUG_WARN, \"Error closing read wake socket!\");",
            "-            rc = PLCTAG_ERR_CLOSE;",
            "-        }",
            "+        if(close((*s)->wake_read_fd)) { pdebug(DEBUG_WARN, \"Error closing read wake socket!\"); }",
            " ",
            "         (*s)->wake_read_fd = INVALID_SOCKET;",
            "     }",
            " ",
            "     if((*s)->wake_write_fd != INVALID_SOCKET) {",
            "-        if(close((*s)->wake_write_fd)) {",
            "-            pdebug(DEBUG_WARN, \"Error closing write wake socket!\");",
            "-            rc = PLCTAG_ERR_CLOSE;",
            "-        }",
            "+        if(close((*s)->wake_write_fd)) { pdebug(DEBUG_WARN, \"Error closing write wake socket!\"); }",
            " ",
            "         (*s)->wake_write_fd = INVALID_SOCKET;",
            "     }",
            " ",
            "     socket_close(*s);",
            " ",
            "     mem_free(*s);",
            "@@ -2080,88 +1947,68 @@",
            " ",
            "     pdebug(DEBUG_INFO, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int sock_create_event_wakeup_channel(sock_p sock)",
            "-{",
            "+int sock_create_event_wakeup_channel(sock_p sock) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int flags = 0;",
            "-    int wake_fds[2] = { 0 };",
            "+    int wake_fds[2] = {0};",
            " #ifdef BSD_OS_TYPE",
            "-    int sock_opt=1;",
            "+    int sock_opt = 1;",
            " #endif",
            " ",
            "     pdebug(DEBUG_INFO, \"Starting.\");",
            " ",
            "     do {",
            "         /* open the pipe for waking the select wait. */",
            "         // if(pipe(wake_fds)) {",
            "         if((rc = socketpair(PF_LOCAL, SOCK_STREAM, 0, wake_fds))) {",
            "             pdebug(DEBUG_WARN, \"Unable to open waker pipe!\");",
            "             switch(errno) {",
            "-                case EAFNOSUPPORT:",
            "-                    pdebug(DEBUG_WARN, \"The specified addresss family is not supported on this machine!\");",
            "-                    break;",
            "+                case EAFNOSUPPORT: pdebug(DEBUG_WARN, \"The specified addresss family is not supported on this machine!\"); break;",
            " ",
            "                 case EFAULT:",
            "                     pdebug(DEBUG_WARN, \"The address socket_vector does not specify a valid part of the process address space.\");",
            "                     break;",
            " ",
            "-                case EMFILE:",
            "-                    pdebug(DEBUG_WARN, \"No more file descriptors are available for this process.\");",
            "-                    break;",
            "+                case EMFILE: pdebug(DEBUG_WARN, \"No more file descriptors are available for this process.\"); break;",
            " ",
            "-                case ENFILE:",
            "-                    pdebug(DEBUG_WARN, \"No more file descriptors are available for the system.\");",
            "-                    break;",
            "+                case ENFILE: pdebug(DEBUG_WARN, \"No more file descriptors are available for the system.\"); break;",
            " ",
            "                 case ENOBUFS:",
            "                     pdebug(DEBUG_WARN, \"Insufficient resources were available in the system to perform the operation.\");",
            "                     break;",
            " ",
            "-                case ENOMEM:",
            "-                    pdebug(DEBUG_WARN, \"Insufficient memory was available to fulfill the request.\");",
            "-                    break;",
            "+                case ENOMEM: pdebug(DEBUG_WARN, \"Insufficient memory was available to fulfill the request.\"); break;",
            " ",
            "-                case EOPNOTSUPP:",
            "-                    pdebug(DEBUG_WARN, \"The specified protocol does not support creation of socket pairs.\");",
            "-                    break;",
            "+                case EOPNOTSUPP: pdebug(DEBUG_WARN, \"The specified protocol does not support creation of socket pairs.\"); break;",
            " ",
            "-                case EPROTONOSUPPORT:",
            "-                    pdebug(DEBUG_WARN, \"The specified protocol is not supported on this machine.\");",
            "-                    break;",
            "+                case EPROTONOSUPPORT: pdebug(DEBUG_WARN, \"The specified protocol is not supported on this machine.\"); break;",
            " ",
            "-                case EPROTOTYPE:",
            "-                    pdebug(DEBUG_WARN, \"The socket type is not supported by the protocol.\");",
            "-                    break;",
            "+                case EPROTOTYPE: pdebug(DEBUG_WARN, \"The socket type is not supported by the protocol.\"); break;",
            " ",
            "-                default:",
            "-                    pdebug(DEBUG_WARN, \"Unexpected error %d!\", errno);",
            "-                    break;",
            "+                default: pdebug(DEBUG_WARN, \"Unexpected error %d!\", errno); break;",
            "             }",
            " ",
            "             rc = PLCTAG_ERR_BAD_REPLY;",
            "             break;",
            "         }",
            " ",
            " #ifdef BSD_OS_TYPE",
            "         /* The *BSD family has a different way to suppress SIGPIPE on sockets. */",
            "-        if(setsockopt(wake_fds[0], SOL_SOCKET, SO_NOSIGPIPE, (char*)&sock_opt, sizeof(sock_opt))) {",
            "+        if(setsockopt(wake_fds[0], SOL_SOCKET, SO_NOSIGPIPE, (char *)&sock_opt, sizeof(sock_opt))) {",
            "             pdebug(DEBUG_ERROR, \"Error setting wake fd read socket SIGPIPE suppression option, errno: %d\", errno);",
            "             rc = PLCTAG_ERR_OPEN;",
            "             break;",
            "         }",
            " ",
            "-        if(setsockopt(wake_fds[1], SOL_SOCKET, SO_NOSIGPIPE, (char*)&sock_opt, sizeof(sock_opt))) {",
            "+        if(setsockopt(wake_fds[1], SOL_SOCKET, SO_NOSIGPIPE, (char *)&sock_opt, sizeof(sock_opt))) {",
            "             pdebug(DEBUG_ERROR, \"Error setting wake fd write socket SIGPIPE suppression option, errno: %d\", errno);",
            "             rc = PLCTAG_ERR_OPEN;",
            "             break;",
            "         }",
            " #endif",
            " ",
            "         /* make the read pipe fd non-blocking. */",
            "@@ -2216,50 +2063,43 @@",
            "         pdebug(DEBUG_INFO, \"Done.\");",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ***************************** Miscellaneous *******************************",
            "  **************************************************************************/",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * sleep_ms",
            "  *",
            "  * Sleep the passed number of milliseconds.  This handles the case of being",
            "  * interrupted by a signal.",
            "  *",
            "  * TODO - should the signal interrupt handling be done here or in app code?",
            "  */",
            "-int sleep_ms(int ms)",
            "-{",
            "+int sleep_ms(int ms) {",
            "     struct timespec wait_time;",
            "     struct timespec remainder;",
            "     int done = 1;",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     if(ms < 0) {",
            "         pdebug(DEBUG_WARN, \"called with negative time %d!\", ms);",
            "         return PLCTAG_ERR_BAD_PARAM;",
            "     }",
            " ",
            "-    wait_time.tv_sec = ms/1000;",
            "-    wait_time.tv_nsec = ((long)ms % 1000)*1000000; /* convert to nanoseconds */",
            "+    wait_time.tv_sec = ms / 1000;",
            "+    wait_time.tv_nsec = ((long)ms % 1000) * 1000000; /* convert to nanoseconds */",
            " ",
            "     do {",
            "-        int rc = nanosleep(&wait_time, &remainder);",
            "+        rc = nanosleep(&wait_time, &remainder);",
            "         if(rc < 0 && errno == EINTR) {",
            "             /* we were interrupted, keep going. */",
            "             wait_time = remainder;",
            "             done = 0;",
            "         } else {",
            "             done = 1;",
            " ",
            "@@ -2289,15 +2129,14 @@",
            " ",
            " ",
            " /*",
            "  * time_ms",
            "  *",
            "  * Return the current epoch time in milliseconds.",
            "  */",
            "-int64_t time_ms(void)",
            "-{",
            "+int64_t time_ms(void) {",
            "     struct timeval tv;",
            " ",
            "-    gettimeofday(&tv,NULL);",
            "+    gettimeofday(&tv, NULL);",
            " ",
            "-    return  ((int64_t)tv.tv_sec*1000)+ ((int64_t)tv.tv_usec/1000);",
            "+    return ((int64_t)tv.tv_sec * 1000) + ((int64_t)tv.tv_usec / 1000);",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/platform/posix/platform.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/platform/posix/platform.h",
            "+++ /home/libplctag-2.6.7/src/platform/posix/platform.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -102,17 +102,14 @@",
            " extern char **str_split(const char *str, const char *sep);",
            " #define str_concat(s1, ...) str_concat_impl(COUNT_NARG(__VA_ARGS__)+1, s1, __VA_ARGS__)",
            " extern char *str_concat_impl(int num_args, ...);",
            " ",
            " /* mutex functions/defs */",
            " typedef struct mutex_t *mutex_p;",
            " extern int mutex_create(mutex_p *m);",
            "-// extern int mutex_lock(mutex_p m);",
            "-// extern int mutex_try_lock(mutex_p m);",
            "-// extern int mutex_unlock(mutex_p m);",
            " extern int mutex_destroy(mutex_p *m);",
            " ",
            " extern int mutex_lock_impl(const char *func, int line_num, mutex_p m);",
            " extern int mutex_try_lock_impl(const char *func, int line_num, mutex_p m);",
            " extern int mutex_unlock_impl(const char *func, int line_num, mutex_p m);",
            " ",
            " #if defined(_WIN32) && defined(_MSC_VER)",
            "@@ -149,15 +146,15 @@",
            " /* thread functions/defs */",
            " typedef struct thread_t *thread_p;",
            " typedef void *(*thread_func_t)(void *arg);",
            " extern int thread_create(thread_p *t, thread_func_t func, int stacksize, void *arg);",
            " extern void thread_stop(void) __attribute__((noreturn));",
            " extern void thread_kill(thread_p t);",
            " extern int thread_join(thread_p t);",
            "-extern int thread_detach();",
            "+extern int thread_detach(void);",
            " extern int thread_destroy(thread_p *t);",
            " ",
            " #define THREAD_FUNC(func) void *func(void *arg)",
            " #define THREAD_RETURN(val) return (void *)val;",
            " ",
            " #define THREAD_LOCAL __thread"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/platform/windows/platform.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/platform/windows/platform.c",
            "+++ /home/libplctag-2.6.7/src/platform/windows/platform.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -33,33 +33,35 @@",
            " ",
            " /***************************************************************************",
            "  ******************************* WINDOWS ***********************************",
            "  **************************************************************************/",
            " ",
            " #include <platform.h>",
            " ",
            "-#define _WINSOCKAPI_",
            "-#include <windows.h>",
            "-#include <tchar.h>",
            "-#include <strsafe.h>",
            "-#include <io.h>",
            "+/* KEEP THE SPACES BETWEEN THE INCLUDES.  The order is required! */",
            " #include <Winsock2.h>",
            "+",
            "+#include <Windows.h>",
            "+",
            " #include <Ws2tcpip.h>",
            "-#include <timeapi.h>",
            "-#include <string.h>",
            "-#include <stdlib.h>",
            "-#include <winnt.h>",
            "+",
            " #include <errno.h>",
            "+#include <io.h>",
            " #include <math.h>",
            " #include <process.h>",
            "-#include <time.h>",
            " #include <stdio.h>",
            "+#include <stdlib.h>",
            "+#include <string.h>",
            "+#include <strsafe.h>",
            "+#include <tchar.h>",
            "+#include <time.h>",
            "+#include <timeapi.h>",
            " ",
            "-#include <lib/libplctag.h>",
            "-#include <util/debug.h>",
            "+#include <libplctag/lib/libplctag.h>",
            "+#include <utils/debug.h>",
            " ",
            " ",
            " /*#ifdef __cplusplus",
            " extern \"C\"",
            " {",
            " #endif",
            " */",
            "@@ -67,114 +69,96 @@",
            " /*#include <stdint.h>",
            " #include <string.h>",
            " #include <errno.h>",
            " #include <fcntl.h>",
            " #include <stdlib.h>*/",
            " ",
            " ",
            "-",
            "-",
            " #define WINDOWS_REQUESTED_TIMER_PERIOD_MS ((unsigned int)4)",
            " ",
            "-",
            "+/* not defined under Windows */",
            "+typedef ptrdiff_t ssize_t;",
            " ",
            " /***************************************************************************",
            "  ******************************* Memory ************************************",
            "  **************************************************************************/",
            " ",
            " ",
            "-",
            " /*",
            "  * mem_alloc",
            "  *",
            "  * This is a wrapper around the platform's memory allocation routine.",
            "  * It will zero out memory before returning it.",
            "  *",
            "  * It will return NULL on failure.",
            "  */",
            "-extern void *mem_alloc(int size)",
            "-{",
            "+extern void *mem_alloc(int size) {",
            "     if(size <= 0) {",
            "         pdebug(DEBUG_WARN, \"Allocation size must be greater than zero bytes!\");",
            "         return NULL;",
            "     }",
            " ",
            "-    return calloc(size, 1);",
            "+    return calloc((size_t)(unsigned int)size, 1);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * mem_realloc",
            "  *",
            "  * This is a wrapper around the platform's memory re-allocation routine.",
            "  *",
            "  * It will return NULL on failure.",
            "  */",
            "-extern void *mem_realloc(void *orig, int size)",
            "-{",
            "+extern void *mem_realloc(void *orig, int size) {",
            "     if(size <= 0) {",
            "         pdebug(DEBUG_WARN, \"New allocation size must be greater than zero bytes!\");",
            "         return NULL;",
            "     }",
            " ",
            "     return realloc(orig, (size_t)(ssize_t)size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /*",
            "  * mem_free",
            "  *",
            "  * Free the allocated memory passed in.  If the passed pointer is",
            "  * null, do nothing.",
            "  */",
            "-extern void mem_free(const void *mem)",
            "-{",
            "-    if(mem) {",
            "-        free((void *)mem);",
            "-    }",
            "+extern void mem_free(const void *mem) {",
            "+    if(mem) { free((void *)mem); }",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * mem_set",
            "  *",
            "  * set memory to the passed argument.",
            "  */",
            "-extern void mem_set(void *dest, int c, int size)",
            "-{",
            "+extern void mem_set(void *dest, int c, int size) {",
            "     if(!dest) {",
            "         pdebug(DEBUG_WARN, \"Destination pointer is NULL!\");",
            "         return;",
            "     }",
            " ",
            "     if(size <= 0) {",
            "         pdebug(DEBUG_WARN, \"Size to set must be a positive number!\");",
            "         return;",
            "     }",
            " ",
            "     memset(dest, c, (size_t)(ssize_t)size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /*",
            "  * mem_copy",
            "  *",
            "  * copy memory from one pointer to another for the passed number of bytes.",
            "  */",
            "-extern void mem_copy(void *dest, void *src, int size)",
            "-{",
            "+extern void mem_copy(void *dest, void *src, int size) {",
            "     if(!dest) {",
            "         pdebug(DEBUG_WARN, \"Destination pointer is NULL!\");",
            "         return;",
            "     }",
            " ",
            "     if(!src) {",
            "         pdebug(DEBUG_WARN, \"Source pointer is NULL!\");",
            "@@ -191,24 +175,20 @@",
            "         return;",
            "     }",
            " ",
            "     memcpy(dest, src, (size_t)(ssize_t)size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /*",
            "  * mem_move",
            "  *",
            "  * move memory from one pointer to another for the passed number of bytes.",
            "  */",
            "-extern void mem_move(void *dest, void *src, int size)",
            "-{",
            "+extern void mem_move(void *dest, void *src, int size) {",
            "     if(!dest) {",
            "         pdebug(DEBUG_WARN, \"Destination pointer is NULL!\");",
            "         return;",
            "     }",
            " ",
            "     if(!src) {",
            "         pdebug(DEBUG_WARN, \"Source pointer is NULL!\");",
            "@@ -225,19 +205,15 @@",
            "         return;",
            "     }",
            " ",
            "     memmove(dest, src, (size_t)(ssize_t)size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int mem_cmp(void *src1, int src1_size, void *src2, int src2_size)",
            "-{",
            "+int mem_cmp(void *src1, int src1_size, void *src2, int src2_size) {",
            "     if(!src1 || src1_size <= 0) {",
            "         if(!src2 || src2_size <= 0) {",
            "             /* both are NULL or zero length, but that is \"equal\" for our purposes. */",
            "             return 0;",
            "         } else {",
            "             /* first one is \"less\" than second. */",
            "             return -1;",
            "@@ -246,27 +222,22 @@",
            "         if(!src2 || src2_size <= 0) {",
            "             /* first is \"greater\" than second */",
            "             return 1;",
            "         } else {",
            "             /* both pointers are non-NULL and the lengths are positive. */",
            " ",
            "             /* short circuit the comparison if the blocks are different lengths */",
            "-            if(src1_size != src2_size) {",
            "-                return (src1_size - src2_size);",
            "-            }",
            "+            if(src1_size != src2_size) { return (src1_size - src2_size); }",
            " ",
            "-            return memcmp(src1, src2, src1_size);",
            "+            return memcmp(src1, src2, (size_t)(unsigned int)src1_size);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Strings ***********************************",
            "  **************************************************************************/",
            " ",
            " ",
            " /*",
            "  * str_cmp",
            "@@ -274,16 +245,15 @@",
            "  * Return -1, 0, or 1 depending on whether the first string is \"less\" than the",
            "  * second, the same as the second, or \"greater\" than the second.  This routine",
            "  * just passes through to POSIX strcmp.",
            "  *",
            "  * We must handle some edge cases here due to wrappers.   We could get a NULL",
            "  * pointer or a zero-length string for either argument.",
            "  */",
            "-extern int str_cmp(const char *first, const char *second)",
            "-{",
            "+extern int str_cmp(const char *first, const char *second) {",
            "     int first_zero = !str_length(first);",
            "     int second_zero = !str_length(second);",
            " ",
            "     if(first_zero) {",
            "         if(second_zero) {",
            "             pdebug(DEBUG_DETAIL, \"NULL or zero length strings passed.\");",
            "             return 0;",
            "@@ -299,27 +269,24 @@",
            "             /* both are non-zero length. */",
            "             return strcmp(first, second);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * str_cmp_i",
            "  *",
            "  * Returns -1, 0, or 1 depending on whether the first string is \"less\" than the",
            "  * second, the same as the second, or \"greater\" than the second.  The comparison",
            "  * is done case insensitive.",
            "  *",
            "  * Handle the usual edge cases because Microsoft appears not to.",
            "  */",
            "-extern int str_cmp_i(const char *first, const char *second)",
            "-{",
            "+extern int str_cmp_i(const char *first, const char *second) {",
            "     int first_zero = !str_length(first);",
            "     int second_zero = !str_length(second);",
            " ",
            "     if(first_zero) {",
            "         if(second_zero) {",
            "             pdebug(DEBUG_DETAIL, \"NULL or zero length strings passed.\");",
            "             return 0;",
            "@@ -329,31 +296,30 @@",
            "         }",
            "     } else {",
            "         if(second_zero) {",
            "             /* first is \"more\" than second. */",
            "             return 1;",
            "         } else {",
            "             /* both are non-zero length. */",
            "-            return _stricmp(first,second);",
            "+            return _stricmp(first, second);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            " /*",
            "  * str_cmp_i_n",
            "  *",
            "  * Returns -1, 0, or 1 depending on whether the first string is \"less\" than the",
            "  * second, the same as the second, or \"greater\" than the second.  The comparison",
            "  * is done case insensitive.   Compares only the first count characters.",
            "  *",
            "  * It just passes this through to Windows stricmp.",
            "  */",
            "-extern int str_cmp_i_n(const char *first, const char *second, int count)",
            "-{",
            "+extern int str_cmp_i_n(const char *first, const char *second, int count) {",
            "     int first_zero = !str_length(first);",
            "     int second_zero = !str_length(second);",
            " ",
            "     if(count < 0) {",
            "         pdebug(DEBUG_WARN, \"Illegal negative count!\");",
            "         return -1;",
            "     }",
            "@@ -379,16 +345,14 @@",
            "             /* both are non-zero length. */",
            "             return _strnicmp(first, second, (size_t)(unsigned int)count);",
            "         }",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * str_str_cmp_i",
            "  *",
            "  * Returns a pointer to the location of the needle string in the haystack string",
            "  * or NULL if there is no match.  The comparison is done case-insensitive.",
            "  *",
            "  * Handle the usual edge cases.",
            "@@ -420,330 +384,291 @@",
            " **",
            " ** Hereby donated to public domain.",
            " **",
            " ** Modified for use with libcyrus by Ken Murchison 06/01/00.",
            " */",
            " ",
            " ",
            "-char* str_str_cmp_i(const char* haystack, const char* needle)",
            "-{",
            "-    char* nptr, * hptr, * start;",
            "+char *str_str_cmp_i(const char *haystack, const char *needle) {",
            "+    char *nptr, *hptr, *start;",
            "     int haystack_len = str_length(haystack);",
            "     int needle_len = str_length(needle);",
            " ",
            "-    if (!haystack_len) {",
            "+    if(!haystack_len) {",
            "         pdebug(DEBUG_DETAIL, \"Haystack string is NULL or zero length.\");",
            "         return NULL;",
            "     }",
            " ",
            "-    if (!needle_len) {",
            "+    if(!needle_len) {",
            "         pdebug(DEBUG_DETAIL, \"Needle string is NULL or zero length.\");",
            "         return NULL;",
            "     }",
            " ",
            "-    if (haystack_len < needle_len) {",
            "+    if(haystack_len < needle_len) {",
            "         pdebug(DEBUG_DETAIL, \"Needle string is longer than haystack string.\");",
            "         return NULL;",
            "     }",
            " ",
            "     /* while haystack length not shorter than needle length */",
            "-    for (start = (char*)haystack, nptr = (char*)needle; haystack_len >= needle_len; start++, haystack_len--) {",
            "+    for(start = (char *)haystack, nptr = (char *)needle; haystack_len >= needle_len; start++, haystack_len--) {",
            "         /* find start of needle in haystack */",
            "-        while (toupper(*start) != toupper(*needle)) {",
            "+        while(toupper(*start) != toupper(*needle)) {",
            "             start++;",
            "             haystack_len--;",
            " ",
            "             /* if needle longer than haystack */",
            " ",
            "-            if (haystack_len < needle_len) {",
            "-                return(NULL);",
            "-            }",
            "+            if(haystack_len < needle_len) { return (NULL); }",
            "         }",
            " ",
            "         hptr = start;",
            "-        nptr = (char*)needle;",
            "+        nptr = (char *)needle;",
            " ",
            "-        while (toupper(*hptr) == toupper(*nptr)) {",
            "+        while(toupper(*hptr) == toupper(*nptr)) {",
            "             hptr++;",
            "             nptr++;",
            " ",
            "             /* if end of needle then needle was found */",
            "-            if ('\\0' == *nptr) {",
            "-                return (start);",
            "-            }",
            "+            if('\\0' == *nptr) { return (start); }",
            "         }",
            "     }",
            " ",
            "-    return(NULL);",
            "+    return (NULL);",
            " }",
            " ",
            " ",
            " /*",
            "  * str_copy",
            "  *",
            "  * Returns",
            "  */",
            "-extern int str_copy(char *dst, int dst_size, const char *src)",
            "-{",
            "-    if (!dst) {",
            "+extern int str_copy(char *dst, int dst_size, const char *src) {",
            "+    if(!dst) {",
            "         pdebug(DEBUG_WARN, \"Destination string pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if (!src) {",
            "+    if(!src) {",
            "         pdebug(DEBUG_WARN, \"Source string pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     if(dst_size <= 0) {",
            "         pdebug(DEBUG_WARN, \"Destination size is negative or zero!\");",
            "         return PLCTAG_ERR_TOO_SMALL;",
            "     }",
            " ",
            " ",
            "     /* FIXME - if there is not enough room, truncate the string. */",
            "-    strncpy_s(dst, dst_size, src, _TRUNCATE);",
            "+    strncpy_s(dst, (rsize_t)(unsigned int)dst_size, src, _TRUNCATE);",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            " /*",
            "  * str_length",
            "  *",
            "  * Return the length of the string.  If a null pointer is passed, return",
            "  * null.",
            "  */",
            "-extern int str_length(const char *str)",
            "-{",
            "-    if(!str) {",
            "-        return 0;",
            "-    }",
            "+extern int str_length(const char *str) {",
            "+    if(!str) { return 0; }",
            " ",
            "     return (int)strlen(str);",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * str_dup",
            "  *",
            "  * Copy the passed string and return a pointer to the copy.",
            "  * The caller is responsible for freeing the memory.",
            "  */",
            "-extern char *str_dup(const char *str)",
            "-{",
            "-    if(!str) {",
            "-        return NULL;",
            "-    }",
            "+extern char *str_dup(const char *str) {",
            "+    if(!str) { return NULL; }",
            " ",
            "     return _strdup(str);",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * str_to_int",
            "  *",
            "  * Convert the characters in the passed string into",
            "  * an int.  Return an int in integer in the passed",
            "  * pointer and a status from the function.",
            "  */",
            "-extern int str_to_int(const char *str, int *val)",
            "-{",
            "+extern int str_to_int(const char *str, int *val) {",
            "     char *endptr;",
            "     long int tmp_val;",
            " ",
            "-    tmp_val = strtol(str,&endptr,0);",
            "+    tmp_val = strtol(str, &endptr, 0);",
            " ",
            "-    if (errno == ERANGE && (tmp_val == LONG_MAX || tmp_val == LONG_MIN)) {",
            "+    if(errno == ERANGE && (tmp_val == LONG_MAX || tmp_val == LONG_MIN)) {",
            "         /*pdebug(\"strtol returned %ld with errno %d\",tmp_val, errno);*/",
            "         return -1;",
            "     }",
            " ",
            "-    if (endptr == str) {",
            "-        return -1;",
            "-    }",
            "+    if(endptr == str) { return -1; }",
            " ",
            "     /* FIXME - this will truncate long values. */",
            "     *val = (int)tmp_val;",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-extern int str_to_float(const char *str, float *val)",
            "-{",
            "+extern int str_to_float(const char *str, float *val) {",
            "     char *endptr;",
            "     double tmp_val_d;",
            "     float tmp_val;",
            " ",
            "     /* Windows does not have strtof() */",
            "-    tmp_val_d = strtod(str,&endptr);",
            "+    tmp_val_d = strtod(str, &endptr);",
            " ",
            "-    if (errno == ERANGE && (tmp_val_d == HUGE_VAL || tmp_val_d == -HUGE_VAL || tmp_val_d == (double)0.0)) {",
            "-        return -1;",
            "-    }",
            "+    if(errno == ERANGE && (tmp_val_d == HUGE_VAL || tmp_val_d == -HUGE_VAL || tmp_val_d == (double)0.0)) { return -1; }",
            " ",
            "-    if (endptr == str) {",
            "-        return -1;",
            "-    }",
            "+    if(endptr == str) { return -1; }",
            " ",
            "     /* FIXME - this will truncate long values. */",
            "     tmp_val = (float)tmp_val_d;",
            "     *val = tmp_val;",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-extern char **str_split(const char *str, const char *sep)",
            "-{",
            "-    int sub_str_count=0;",
            "-    int size = 0;",
            "+extern char **str_split(const char *str, const char *sep) {",
            "+    size_t sub_str_count = 0;",
            "+    size_t size = 0;",
            "     const char *sub;",
            "     const char *tmp;",
            "     char **res;",
            " ",
            "     /* first, count the sub strings */",
            "     tmp = str;",
            "-    sub = strstr(tmp,sep);",
            "+    sub = strstr(tmp, sep);",
            " ",
            "     while(sub && *sub) {",
            "         /* separator could be at the front, ignore that. */",
            "-        if(sub != tmp) {",
            "-            sub_str_count++;",
            "-        }",
            "+        if(sub != tmp) { sub_str_count++; }",
            " ",
            "         tmp = sub + str_length(sep);",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "-    if(tmp && *tmp && (!sub || !*sub))",
            "-        sub_str_count++;",
            "+    if(tmp && *tmp && (!sub || !*sub)) { sub_str_count++; }",
            " ",
            "     /* calculate total size for string plus pointers */",
            "-    size = sizeof(char *)*(sub_str_count+1)+str_length(str)+1;",
            "+    size = (sizeof(char *) * (sub_str_count + 1)) + (size_t)(unsigned int)str_length(str) + 1;",
            " ",
            "     /* allocate enough memory */",
            "-    res = (char**)mem_alloc(size);",
            "-    if(!res)",
            "-        return NULL;",
            "+    res = (char **)mem_alloc((int)(unsigned int)size);",
            "+    if(!res) { return NULL; }",
            " ",
            "     /* calculate the beginning of the string */",
            "-    tmp = (char *)res + sizeof(char *)*(sub_str_count+1);",
            "+    tmp = (char *)res + sizeof(char *) * (sub_str_count + 1);",
            " ",
            "     /* copy the string into the new buffer past the first part with the array of char pointers. */",
            "-    str_copy((char *)tmp, (int)(size - ((char*)tmp - (char*)res)), str);",
            "+    str_copy((char *)tmp, (int)(ptrdiff_t)(size - ((char *)tmp - (char *)res)), str);",
            " ",
            "     /* set up the pointers */",
            "-    sub_str_count=0;",
            "-    sub = strstr(tmp,sep);",
            "+    sub_str_count = 0;",
            "+    sub = strstr(tmp, sep);",
            "     while(sub && *sub) {",
            "         /* separator could be at the front, ignore that. */",
            "         if(sub != tmp) {",
            "             /* store the pointer */",
            "             res[sub_str_count] = (char *)tmp;",
            " ",
            "             sub_str_count++;",
            "         }",
            " ",
            "         /* zero out the separator chars */",
            "-        mem_set((char*)sub,0,str_length(sep));",
            "+        mem_set((char *)sub, 0, str_length(sep));",
            " ",
            "         /* point past the separator (now zero) */",
            "         tmp = sub + str_length(sep);",
            " ",
            "         /* find the next separator */",
            "-        sub = strstr(tmp,sep);",
            "+        sub = strstr(tmp, sep);",
            "     }",
            " ",
            "     /* if there is a chunk at the end, store it. */",
            "-    if(tmp && *tmp && (!sub || !*sub)) {",
            "-        res[sub_str_count] = (char*)tmp;",
            "-    }",
            "+    if(tmp && *tmp && (!sub || !*sub)) { res[sub_str_count] = (char *)tmp; }",
            " ",
            "     return res;",
            " }",
            " ",
            " ",
            "-char *str_concat_impl(int num_args, ...)",
            "-{",
            "+char *str_concat_impl(int num_args, ...) {",
            "     va_list arg_list;",
            "     int total_length = 0;",
            "     char *result = NULL;",
            "     char *tmp = NULL;",
            " ",
            "     /* first loop to find the length */",
            "     va_start(arg_list, num_args);",
            "-    for(int i=0; i < num_args; i++) {",
            "+    for(int i = 0; i < num_args; i++) {",
            "         tmp = va_arg(arg_list, char *);",
            "-        if(tmp) {",
            "-            total_length += str_length(tmp);",
            "-        }",
            "+        if(tmp) { total_length += str_length(tmp); }",
            "     }",
            "     va_end(arg_list);",
            " ",
            "     /* make a buffer big enough */",
            "     total_length += 1;",
            " ",
            "     result = mem_alloc(total_length);",
            "     if(!result) {",
            "-        pdebug(DEBUG_ERROR,\"Unable to allocate new string buffer!\");",
            "+        pdebug(DEBUG_ERROR, \"Unable to allocate new string buffer!\");",
            "         return NULL;",
            "     }",
            " ",
            "     /* loop to copy the strings */",
            "     result[0] = 0;",
            "     va_start(arg_list, num_args);",
            "-    for(int i=0; i < num_args; i++) {",
            "+    for(int i = 0; i < num_args; i++) {",
            "         tmp = va_arg(arg_list, char *);",
            "         if(tmp) {",
            "             int len = str_length(result);",
            "             str_copy(&result[len], total_length - len, tmp);",
            "         }",
            "     }",
            "     va_end(arg_list);",
            " ",
            "     return result;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Mutexes ***********************************",
            "  **************************************************************************/",
            " ",
            " struct mutex_t {",
            "     HANDLE h_mutex;",
            "     int initialized;",
            " };",
            " ",
            " ",
            "-int mutex_create(mutex_p *m)",
            "-{",
            "+int mutex_create(mutex_p *m) {",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "-    if(*m) {",
            "-        pdebug(DEBUG_WARN, \"Called with non-NULL pointer!\");",
            "-    }",
            "+    if(*m) { pdebug(DEBUG_WARN, \"Called with non-NULL pointer!\"); }",
            " ",
            "     *m = (struct mutex_t *)mem_alloc(sizeof(struct mutex_t));",
            "-    if(! *m) {",
            "+    if(!*m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     /* set up the mutex */",
            "-    (*m)->h_mutex = CreateMutex(",
            "-                        NULL,                   /* default security attributes  */",
            "-                        FALSE,                  /* initially not owned          */",
            "-                        NULL);                  /* unnamed mutex                */",
            "+    (*m)->h_mutex = CreateMutex(NULL,  /* default security attributes  */",
            "+                                FALSE, /* initially not owned          */",
            "+                                NULL); /* unnamed mutex                */",
            " ",
            "     if(!(*m)->h_mutex) {",
            "         mem_free(*m);",
            "         *m = NULL;",
            "         pdebug(DEBUG_WARN, \"Error initializing mutex!\");",
            "         return PLCTAG_ERR_MUTEX_INIT;",
            "     }",
            "@@ -752,97 +677,80 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int mutex_lock_impl(const char *func, int line, mutex_p m)",
            "-{",
            "+int mutex_lock_impl(const char *func, int line, mutex_p m) {",
            "     DWORD dwWaitResult = 0;",
            " ",
            "-    pdebug(DEBUG_SPEW,\"locking mutex %p, called from %s:%d.\", m, func, line);",
            "+    pdebug(DEBUG_SPEW, \"locking mutex %p, called from %s:%d.\", m, func, line);",
            " ",
            "     if(!m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(!m->initialized) {",
            "-        return PLCTAG_ERR_MUTEX_INIT;",
            "-    }",
            "+    if(!m->initialized) { return PLCTAG_ERR_MUTEX_INIT; }",
            " ",
            "     dwWaitResult = ~WAIT_OBJECT_0;",
            " ",
            "     /* FIXME - This will potentially hang forever! */",
            "-    while(dwWaitResult != WAIT_OBJECT_0) {",
            "-        dwWaitResult = WaitForSingleObject(m->h_mutex,INFINITE);",
            "-    }",
            "+    while(dwWaitResult != WAIT_OBJECT_0) { dwWaitResult = WaitForSingleObject(m->h_mutex, INFINITE); }",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int mutex_try_lock_impl(const char *func, int line, mutex_p m)",
            "-{",
            "+int mutex_try_lock_impl(const char *func, int line, mutex_p m) {",
            "     DWORD dwWaitResult = 0;",
            " ",
            "-    pdebug(DEBUG_SPEW,\"trying to lock mutex %p, called from %s:%d.\", m, func, line);",
            "+    pdebug(DEBUG_SPEW, \"trying to lock mutex %p, called from %s:%d.\", m, func, line);",
            " ",
            "     if(!m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(!m->initialized) {",
            "-        return PLCTAG_ERR_MUTEX_INIT;",
            "-    }",
            "+    if(!m->initialized) { return PLCTAG_ERR_MUTEX_INIT; }",
            " ",
            "     dwWaitResult = WaitForSingleObject(m->h_mutex, 0);",
            "     if(dwWaitResult == WAIT_OBJECT_0) {",
            "         /* we got the lock */",
            "         return PLCTAG_STATUS_OK;",
            "     } else {",
            "         return PLCTAG_ERR_MUTEX_LOCK;",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-int mutex_unlock_impl(const char *func, int line, mutex_p m)",
            "-{",
            "-    pdebug(DEBUG_SPEW,\"unlocking mutex %p, called from %s:%d.\", m, func, line);",
            "+int mutex_unlock_impl(const char *func, int line, mutex_p m) {",
            "+    pdebug(DEBUG_SPEW, \"unlocking mutex %p, called from %s:%d.\", m, func, line);",
            " ",
            "     if(!m) {",
            "-        pdebug(DEBUG_WARN,\"null mutex pointer.\");",
            "+        pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(!m->initialized) {",
            "-        return PLCTAG_ERR_MUTEX_INIT;",
            "-    }",
            "+    if(!m->initialized) { return PLCTAG_ERR_MUTEX_INIT; }",
            " ",
            "     if(!ReleaseMutex(m->h_mutex)) {",
            "         /*pdebug(\"error unlocking mutex.\");*/",
            "         return PLCTAG_ERR_MUTEX_UNLOCK;",
            "     }",
            " ",
            "-    //pdebug(\"Done.\");",
            "+    // pdebug(\"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int mutex_destroy(mutex_p *m)",
            "-{",
            "-    pdebug(DEBUG_DETAIL,\"destroying mutex %p\", m);",
            "+int mutex_destroy(mutex_p *m) {",
            "+    pdebug(DEBUG_DETAIL, \"destroying mutex %p\", m);",
            " ",
            "     if(!m || !*m) {",
            "         pdebug(DEBUG_WARN, \"null mutex pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     CloseHandle((*m)->h_mutex);",
            "@@ -853,17 +761,14 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Threads ***********************************",
            "  **************************************************************************/",
            " ",
            " struct thread_t {",
            "     HANDLE h_thread;",
            "     int initialized;",
            "@@ -875,91 +780,82 @@",
            "  *",
            "  * Start up a new thread.  This allocates the thread_t structure and starts",
            "  * the passed function.  The arg argument is passed to the function.",
            "  *",
            "  * TODO - use the stacksize!",
            "  */",
            " ",
            "-extern int thread_create(thread_p *t, LPTHREAD_START_ROUTINE func, int stacksize, void *arg)",
            "-{",
            "+extern int thread_create(thread_p *t, LPTHREAD_START_ROUTINE func, int stacksize, void *arg) {",
            "+    (void)stacksize;",
            "+",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!t) {",
            "         pdebug(DEBUG_WARN, \"null pointer to thread pointer!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     *t = (thread_p)mem_alloc(sizeof(struct thread_t));",
            "-    if(! *t) {",
            "+    if(!*t) {",
            "         pdebug(DEBUG_WARN, \"Unable to create new thread struct!\");",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "     /* create a thread. */",
            "-    (*t)->h_thread = CreateThread(",
            "-                         NULL,                   /* default security attributes */",
            "-                         0,                      /* use default stack size      */",
            "-                         func,                   /* thread function             */",
            "-                         arg,                    /* argument to thread function */",
            "-                         0,                      /* use default creation flags  */",
            "-                         NULL);                  /* do not need thread ID       */",
            "+    (*t)->h_thread = CreateThread(NULL,  /* default security attributes */",
            "+                                  0,     /* use default stack size      */",
            "+                                  func,  /* thread function             */",
            "+                                  arg,   /* argument to thread function */",
            "+                                  0,     /* use default creation flags  */",
            "+                                  NULL); /* do not need thread ID       */",
            " ",
            "     if(!(*t)->h_thread) {",
            "         pdebug(DEBUG_WARN, \"error creating thread.\");",
            "         mem_free(*t);",
            "-        *t=NULL;",
            "+        *t = NULL;",
            " ",
            "         return PLCTAG_ERR_THREAD_CREATE;",
            "     }",
            " ",
            "     /* mark as initialized */",
            "     (*t)->initialized = 1;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * thread_stop()",
            "  *",
            "  * Stop the current thread.  Does not take arguments.  Note: the thread",
            "  * ends completely and this function does not return!",
            "  */",
            "-void thread_stop(void)",
            "-{",
            "-    ExitThread((DWORD)0);",
            "-}",
            "+void thread_stop(void) { ExitThread((DWORD)0); }",
            " ",
            " ",
            " /*",
            "  * thread_kill()",
            "  *",
            "  * Stop the indicated thread completely.",
            "  */",
            " ",
            "-void thread_kill(thread_p t)",
            "-{",
            "-    if(t) {",
            "-        TerminateThread(t->h_thread, (DWORD)0);",
            "-    }",
            "+void thread_kill(thread_p t) {",
            "+    if(t) { TerminateThread(t->h_thread, (DWORD)0); }",
            " }",
            " ",
            " ",
            " /*",
            "  * thread_join()",
            "  *",
            "  * Wait for the argument thread to stop and then continue.",
            "  */",
            " ",
            "-int thread_join(thread_p t)",
            "-{",
            "+int thread_join(thread_p t) {",
            "     /*pdebug(\"Starting.\");*/",
            " ",
            "     if(!t) {",
            "         /*pdebug(\"null thread pointer.\");*/",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "@@ -972,61 +868,51 @@",
            " ",
            "     /*pdebug(\"Done.\");*/",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * thread_detach",
            "  *",
            "  * Detach the thread.  You cannot call thread_join on a detached thread!",
            "  */",
            " ",
            "-extern int thread_detach()",
            "-{",
            "+extern int thread_detach() {",
            "     /* FIXME - it does not look like you can do this on Windows??? */",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /*",
            "  * thread_destroy",
            "  *",
            "  * This gets rid of the resources of a thread struct.  The thread in",
            "  * question must be dead first!",
            "  */",
            "-extern int thread_destroy(thread_p *t)",
            "-{",
            "+extern int thread_destroy(thread_p *t) {",
            "     /*pdebug(\"Starting.\");*/",
            " ",
            "-    if(!t || ! *t) {",
            "+    if(!t || !*t) {",
            "         /*pdebug(\"null thread pointer.\");*/",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     CloseHandle((*t)->h_thread);",
            " ",
            "     mem_free(*t);",
            " ",
            "     *t = NULL;",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************* Atomic Ops ********************************",
            "  **************************************************************************/",
            " ",
            " /*",
            "  * lock_acquire",
            "  *",
            "@@ -1036,68 +922,59 @@",
            "  *",
            "  * Warning: do not pass null pointers!",
            "  */",
            " ",
            " #define ATOMIC_UNLOCK_VAL ((LONG)(0))",
            " #define ATOMIC_LOCK_VAL ((LONG)(1))",
            " ",
            "-extern int lock_acquire_try(lock_t *lock)",
            "-{",
            "+extern int lock_acquire_try(lock_t *lock) {",
            "     LONG rc = InterlockedExchange(lock, ATOMIC_LOCK_VAL);",
            " ",
            "     if(rc != ATOMIC_LOCK_VAL) {",
            "         return 1;",
            "     } else {",
            "         return 0;",
            "     }",
            " }",
            " ",
            " ",
            "-extern int lock_acquire(lock_t *lock)",
            "-{",
            "-    while(!lock_acquire_try(lock)) ;",
            "+extern int lock_acquire(lock_t *lock) {",
            "+    while(!lock_acquire_try(lock));",
            " ",
            "     return 1;",
            " }",
            " ",
            "-extern void lock_release(lock_t *lock)",
            "-{",
            "+extern void lock_release(lock_t *lock) {",
            "     InterlockedExchange(lock, ATOMIC_UNLOCK_VAL);",
            "     /*pdebug(\"released lock\");*/",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ************************* Condition Variables *****************************",
            "  ***************************************************************************/",
            " ",
            " struct cond_t {",
            "     CRITICAL_SECTION cs;",
            "     CONDITION_VARIABLE cond;",
            "     int flag;",
            " };",
            " ",
            "-int cond_create(cond_p *c)",
            "-{",
            "+int cond_create(cond_p *c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     cond_p tmp_cond = NULL;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!c) {",
            "         pdebug(DEBUG_WARN, \"Null pointer to condition var pointer!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if(*c) {",
            "-        pdebug(DEBUG_WARN, \"Condition var pointer is not null, was it not deleted first?\");",
            "-    }",
            "+    if(*c) { pdebug(DEBUG_WARN, \"Condition var pointer is not null, was it not deleted first?\"); }",
            " ",
            "     /* clear the output first. */",
            "     *c = NULL;",
            " ",
            "     tmp_cond = mem_alloc((int)(unsigned int)sizeof(*tmp_cond));",
            "     if(!tmp_cond) {",
            "         pdebug(DEBUG_WARN, \"Unable to allocate new condition var!\");",
            "@@ -1113,39 +990,38 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_wait_impl(const char* func, int line_num, cond_p c, int timeout_ms)",
            "-{",
            "+int cond_wait_impl(const char *func, int line_num, cond_p c, int timeout_ms) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     int64_t start_time = time_ms();",
            " ",
            "     pdebug(DEBUG_SPEW, \"Starting. Called from %s:%d.\", func, line_num);",
            " ",
            "-    if (!c) {",
            "+    if(!c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null in call from %s:%d!\", func, line_num);",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "-    if (timeout_ms <= 0) {",
            "+    if(timeout_ms <= 0) {",
            "         pdebug(DEBUG_WARN, \"Timeout must be a positive value but was %d in call from %s:%d!\", timeout_ms, func, line_num);",
            "         return PLCTAG_ERR_BAD_PARAM;",
            "     }",
            " ",
            " ",
            "     EnterCriticalSection(&(c->cs));",
            " ",
            "     while(!c->flag) {",
            "         int64_t time_left = (int64_t)timeout_ms - (time_ms() - start_time);",
            " ",
            "         if(time_left > 0) {",
            "-            int wait_rc = 0;",
            "+            DWORD wait_rc = 0;",
            " ",
            "             if(SleepConditionVariableCS(&(c->cond), &(c->cs), (DWORD)time_left)) {",
            "                 /* we might need to wait again. could be a spurious wake up. */",
            "                 pdebug(DEBUG_SPEW, \"Condition var wait returned.\");",
            "                 rc = PLCTAG_STATUS_OK;",
            "             } else {",
            "                 /* error or timeout. */",
            "@@ -1163,39 +1039,37 @@",
            "         } else {",
            "             pdebug(DEBUG_SPEW, \"Timed out.\");",
            "             rc = PLCTAG_ERR_TIMEOUT;",
            "             break;",
            "         }",
            "     }",
            " ",
            "-    if (c->flag) {",
            "+    if(c->flag) {",
            "         pdebug(DEBUG_SPEW, \"Condition var signaled for call at %s:%d.\", func, line_num);",
            " ",
            "         /* clear the flag now that we've responded. */",
            "         c->flag = 0;",
            "-    }",
            "-    else {",
            "+    } else {",
            "         pdebug(DEBUG_SPEW, \"Condition wait terminated due to error or timeout for call at %s:%d.\", func, line_num);",
            "     }",
            " ",
            "-    LeaveCriticalSection (&(c->cs));",
            "+    LeaveCriticalSection(&(c->cs));",
            " ",
            "     pdebug(DEBUG_SPEW, \"Done for call at %s:%d.\", func, line_num);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_signal_impl(const char* func, int line_num, cond_p c)",
            "-{",
            "+int cond_signal_impl(const char *func, int line_num, cond_p c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_SPEW, \"Starting.  Called from %s:%d.\", func, line_num);",
            " ",
            "-    if (!c) {",
            "+    if(!c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null in call at %s:%d!\", func, line_num);",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     EnterCriticalSection(&(c->cs));",
            " ",
            "     c->flag = 1;",
            "@@ -1207,22 +1081,20 @@",
            " ",
            "     pdebug(DEBUG_SPEW, \"Done for call at %s:%d.\", func, line_num);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int cond_clear_impl(const char* func, int line_num, cond_p c)",
            "-{",
            "+int cond_clear_impl(const char *func, int line_num, cond_p c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_SPEW, \"Starting.  Called from %s:%d.\", func, line_num);",
            " ",
            "-    if (!c) {",
            "+    if(!c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null in call at %s:%d!\", func, line_num);",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     EnterCriticalSection(&(c->cs));",
            " ",
            "     c->flag = 0;",
            "@@ -1231,40 +1103,34 @@",
            " ",
            "     pdebug(DEBUG_SPEW, \"Done for call at %s:%d.\", func, line_num);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int cond_destroy(cond_p *c)",
            "-{",
            "+int cond_destroy(cond_p *c) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "-    if(!c || ! *c) {",
            "+    if(!c || !*c) {",
            "         pdebug(DEBUG_WARN, \"Condition var pointer is null!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     mem_free(*c);",
            " ",
            "     *c = NULL;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ******************************** Sockets **********************************",
            "  **************************************************************************/",
            " ",
            " ",
            " struct sock_t {",
            "     SOCKET fd;",
            "@@ -1284,51 +1150,48 @@",
            "  * Windows needs to have the Winsock library initialized",
            "  * before use. Does it need to be static?",
            "  *",
            "  * Also set the timer period to handle the newer Windows 10 case",
            "  * where it gets set fairly large (>15ms).",
            "  */",
            " ",
            "-static WSADATA wsaData = { 0 };",
            "+static WSADATA wsaData = {0};",
            " ",
            "-static int socket_lib_init(void)",
            "-{",
            "-    MMRESULT rc = 0;",
            "+static int socket_lib_init(void) {",
            "+    // MMRESULT rc = 0;",
            " ",
            "     /*",
            "     rc = timeBeginPeriod(WINDOWS_REQUESTED_TIMER_PERIOD_MS);",
            "     if(rc != TIMERR_NOERROR) {",
            "         pdebug(DEBUG_WARN, \"Unable to set timer period to %ums!\", WINDOWS_REQUESTED_TIMER_PERIOD_MS);",
            "     }",
            "     */",
            " ",
            "-    return WSAStartup(MAKEWORD(2,2), &wsaData) == NO_ERROR;",
            "+    return WSAStartup(MAKEWORD(2, 2), &wsaData) == NO_ERROR;",
            " }",
            " ",
            " ",
            "-",
            "-extern int socket_create(sock_p *s)",
            "-{",
            "+extern int socket_create(sock_p *s) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!socket_lib_init()) {",
            "-        pdebug(DEBUG_WARN,\"error initializing Windows Sockets.\");",
            "+        pdebug(DEBUG_WARN, \"error initializing Windows Sockets.\");",
            "         return PLCTAG_ERR_WINSOCK;",
            "     }",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"null socket pointer.\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     *s = (sock_p)mem_alloc(sizeof(struct sock_t));",
            " ",
            "-    if(! *s) {",
            "+    if(!*s) {",
            "         pdebug(DEBUG_ERROR, \"Unable to allocate memory for socket!\");",
            "         return PLCTAG_ERR_NO_MEM;",
            "     }",
            " ",
            "     (*s)->fd = INVALID_SOCKET;",
            "     (*s)->wake_read_fd = INVALID_SOCKET;",
            "     (*s)->wake_write_fd = INVALID_SOCKET;",
            "@@ -1342,159 +1205,156 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return PLCTAG_STATUS_OK;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_connect_tcp_start(sock_p s, const char *host, int port)",
            "-{",
            "+int socket_connect_tcp_start(sock_p s, const char *host, int port) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     IN_ADDR ips[MAX_IPS];",
            "     int num_ips = 0;",
            "     struct sockaddr_in gw_addr;",
            "     int sock_opt = 1;",
            "-    u_long non_blocking=1;",
            "+    u_long non_blocking = 1;",
            "     int i = 0;",
            "     int done = 0;",
            "     SOCKET fd;",
            "     struct timeval timeout; /* used for timing out connections etc. */",
            "     struct linger so_linger;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     /* Open a socket for communication with the gateway. */",
            "-    fd = socket(AF_INET, SOCK_STREAM, 0/*IPPROTO_TCP*/);",
            "+    fd = socket(AF_INET, SOCK_STREAM, 0 /*IPPROTO_TCP*/);",
            " ",
            "     /* check for errors */",
            "-    if(fd < 0) {",
            "+    if(fd == INVALID_SOCKET) {",
            "         /*pdebug(\"Socket creation failed, errno: %d\",errno);*/",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* set up our socket to allow reuse if we crash suddenly. */",
            "     sock_opt = 1;",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,(char*)&sock_opt, (int)sizeof(sock_opt))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&sock_opt, (int)sizeof(sock_opt))) {",
            "         closesocket(fd);",
            "-        pdebug(DEBUG_WARN,\"Error setting socket reuse option, errno: %d\",errno);",
            "+        pdebug(DEBUG_WARN, \"Error setting socket reuse option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     timeout.tv_sec = 10;",
            "     timeout.tv_usec = 0;",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, (int)sizeof(timeout))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, (int)sizeof(timeout))) {",
            "         closesocket(fd);",
            "-        pdebug(DEBUG_WARN,\"Error setting socket receive timeout option, errno: %d\",errno);",
            "+        pdebug(DEBUG_WARN, \"Error setting socket receive timeout option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, (int)sizeof(timeout))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, (int)sizeof(timeout))) {",
            "         closesocket(fd);",
            "-        pdebug(DEBUG_WARN,\"Error setting socket send timeout option, errno: %d\",errno);",
            "+        pdebug(DEBUG_WARN, \"Error setting socket send timeout option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* abort the connection on close. */",
            "     so_linger.l_onoff = 1;",
            "     so_linger.l_linger = 0;",
            " ",
            "-    if(setsockopt(fd, SOL_SOCKET, SO_LINGER,(char*)&so_linger, (int)sizeof(so_linger))) {",
            "+    if(setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&so_linger, (int)sizeof(so_linger))) {",
            "         closesocket(fd);",
            "-        pdebug(DEBUG_ERROR,\"Error setting socket close linger option, errno: %d\",errno);",
            "+        pdebug(DEBUG_ERROR, \"Error setting socket close linger option, errno: %d\", errno);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* figure out what address we are connecting to. */",
            " ",
            "     /* try a numeric IP address conversion first. */",
            "-    if(inet_pton(AF_INET,host,(struct in_addr *)ips) > 0) {",
            "+    if(inet_pton(AF_INET, host, (struct in_addr *)ips) > 0) {",
            "         pdebug(DEBUG_DETAIL, \"Found numeric IP address: %s\", host);",
            "         num_ips = 1;",
            "     } else {",
            "         struct addrinfo hints;",
            "-        struct addrinfo* res_head = NULL;",
            "+        struct addrinfo *res_head = NULL;",
            "         struct addrinfo *res = NULL;",
            " ",
            "         mem_set(&ips, 0, sizeof(ips));",
            "         mem_set(&hints, 0, sizeof(hints));",
            " ",
            "         hints.ai_socktype = SOCK_STREAM; /* TCP */",
            "-        hints.ai_family = AF_INET; /* IP V4 only */",
            "+        hints.ai_family = AF_INET;       /* IP V4 only */",
            " ",
            "-        if ((rc = getaddrinfo(host, NULL, &hints, &res_head)) != 0) {",
            "+        if((rc = getaddrinfo(host, NULL, &hints, &res_head)) != 0) {",
            "             pdebug(DEBUG_WARN, \"Error looking up PLC IP address %s, error = %d\\n\", host, rc);",
            " ",
            "-            if (res_head) {",
            "-                freeaddrinfo(res_head);",
            "-            }",
            "+            if(res_head) { freeaddrinfo(res_head); }",
            " ",
            "             closesocket(fd);",
            "             return PLCTAG_ERR_BAD_GATEWAY;",
            "         }",
            " ",
            "         res = res_head;",
            "-        for (num_ips = 0; res && num_ips < MAX_IPS; num_ips++) {",
            "+        for(num_ips = 0; res && num_ips < MAX_IPS; num_ips++) {",
            "             ips[num_ips].s_addr = ((struct sockaddr_in *)(res->ai_addr))->sin_addr.s_addr;",
            "             res = res->ai_next;",
            "         }",
            " ",
            "         freeaddrinfo(res_head);",
            "     }",
            " ",
            "     /* set the socket to non-blocking. */",
            "-    if (ioctlsocket(fd, FIONBIO, &non_blocking)) {",
            "+    if(ioctlsocket(fd, (long)FIONBIO, &non_blocking)) {",
            "         /*pdebug(\"Error getting socket options, errno: %d\", errno);*/",
            "         closesocket(fd);",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /*",
            "      * now try to connect to the remote gateway.  We may need to",
            "      * try several of the IPs we have.",
            "      */",
            " ",
            "     i = 0;",
            "     done = 0;",
            " ",
            "-    memset((void *)&gw_addr,0, sizeof(gw_addr));",
            "-    gw_addr.sin_family = AF_INET ;",
            "-    gw_addr.sin_port = htons(port);",
            "+    memset((void *)&gw_addr, 0, sizeof(gw_addr));",
            "+    gw_addr.sin_family = AF_INET;",
            "+    gw_addr.sin_port = htons((uint16_t)(int16_t)port);",
            " ",
            "     do {",
            "         /* try each IP until we run out or get a connection. */",
            "         gw_addr.sin_addr.s_addr = ips[i].s_addr;",
            " ",
            "         /*pdebug(DEBUG_DETAIL,\"Attempting to connect to %s\",inet_ntoa(*((struct in_addr *)&ips[i])));*/",
            " ",
            "-        rc = connect(fd,(struct sockaddr *)&gw_addr,sizeof(gw_addr));",
            "+        rc = connect(fd, (struct sockaddr *)&gw_addr, sizeof(gw_addr));",
            " ",
            "         /* connect returns SOCKET_ERROR and a code of WSAEWOULDBLOCK on non-blocking sockets. */",
            "         if(rc == SOCKET_ERROR) {",
            "             int sock_err = WSAGetLastError();",
            "-            if (sock_err == WSAEWOULDBLOCK) {",
            "+            if(sock_err == WSAEWOULDBLOCK) {",
            "                 pdebug(DEBUG_DETAIL, \"Socket connection attempt %d started successfully.\", i);",
            "                 rc = PLCTAG_STATUS_PENDING;",
            "                 done = 1;",
            "             } else {",
            "-                pdebug(DEBUG_WARN, \"Error %d trying to start connection attempt %d process!  Trying next IP address.\", sock_err, i);",
            "+                pdebug(DEBUG_WARN, \"Error %d trying to start connection attempt %d process!  Trying next IP address.\", sock_err,",
            "+                       i);",
            "                 i++;",
            "             }",
            "         } else {",
            "             pdebug(DEBUG_DETAIL, \"Socket connection attempt %d succeeded immediately.\", i);",
            "             rc = PLCTAG_STATUS_OK;",
            "             done = 1;",
            "         }",
            "     } while(!done && i < num_ips);",
            " ",
            "     if(!done) {",
            "         closesocket(fd);",
            "-        pdebug(DEBUG_WARN,\"Unable to connect to any gateway host IP address!\");",
            "+        pdebug(DEBUG_WARN, \"Unable to connect to any gateway host IP address!\");",
            "         return PLCTAG_ERR_OPEN;",
            "     }",
            " ",
            "     /* save the values */",
            "     s->fd = fd;",
            "     s->port = port;",
            " ",
            "@@ -1502,28 +1362,24 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-int socket_connect_tcp_check(sock_p sock, int timeout_ms)",
            "-{",
            "+int socket_connect_tcp_check(sock_p sock, int timeout_ms) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     fd_set write_set;",
            "     fd_set err_set;",
            "     struct timeval tv;",
            "     int select_rc = 0;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "-    if (!sock) {",
            "+    if(!sock) {",
            "         pdebug(DEBUG_WARN, \"Null socket pointer passed!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "     }",
            " ",
            "     /* wait for the socket to be ready. */",
            "     tv.tv_sec = (long)(timeout_ms / 1000);",
            "     tv.tv_usec = (long)(timeout_ms % 1000) * (long)(1000);",
            "@@ -1550,65 +1406,64 @@",
            "         pdebug(DEBUG_DETAIL, \"Socket connection not done yet.\");",
            "         rc = PLCTAG_ERR_TIMEOUT;",
            "     } else {",
            "         int err = WSAGetLastError();",
            " ",
            "         pdebug(DEBUG_WARN, \"select() has error %d!\", err);",
            " ",
            "-        switch (err) {",
            "-        case WSAENETDOWN: /* The network subsystem is down */",
            "-            pdebug(DEBUG_WARN, \"The network subsystem is down!\");",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+        switch(err) {",
            "+            case WSAENETDOWN: /* The network subsystem is down */",
            "+                pdebug(DEBUG_WARN, \"The network subsystem is down!\");",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            " ",
            "-        case WSANOTINITIALISED: /*Winsock was not initialized. */",
            "-            pdebug(DEBUG_WARN, \"WSAStartup() was not called to initialize the Winsock subsystem.!\");",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+            case WSANOTINITIALISED: /*Winsock was not initialized. */",
            "+                pdebug(DEBUG_WARN, \"WSAStartup() was not called to initialize the Winsock subsystem.!\");",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            " ",
            "-        case WSAEINVAL: /* The arguments to select() were bad. */",
            "-            pdebug(DEBUG_WARN, \"One or more of the arguments to select() were invalid!\");",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+            case WSAEINVAL: /* The arguments to select() were bad. */",
            "+                pdebug(DEBUG_WARN, \"One or more of the arguments to select() were invalid!\");",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            " ",
            "-        case WSAEFAULT: /* No mem/resources for select. */",
            "-            pdebug(DEBUG_WARN, \"Insufficient memory or resources for select() to run!\");",
            "-            return PLCTAG_ERR_NO_MEM;",
            "-            break;",
            "+            case WSAEFAULT: /* No mem/resources for select. */",
            "+                pdebug(DEBUG_WARN, \"Insufficient memory or resources for select() to run!\");",
            "+                return PLCTAG_ERR_NO_MEM;",
            "+                break;",
            " ",
            "-        case WSAEINTR: /* A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.  */",
            "-            pdebug(DEBUG_WARN, \"A blocking Winsock call was canceled!\");",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+            case WSAEINTR: /* A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.  */",
            "+                pdebug(DEBUG_WARN, \"A blocking Winsock call was canceled!\");",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            " ",
            "-        case WSAEINPROGRESS: /* A blocking Windows Socket 1.1 call is in progress.  */",
            "-            pdebug(DEBUG_WARN, \"A blocking Winsock call is in progress!\");",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+            case WSAEINPROGRESS: /* A blocking Windows Socket 1.1 call is in progress.  */",
            "+                pdebug(DEBUG_WARN, \"A blocking Winsock call is in progress!\");",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            " ",
            "-        case WSAENOTSOCK: /* One or more of the FDs in the set is not a socket. */",
            "-            pdebug(DEBUG_WARN, \"The fd in the FD set is not a socket!\");",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+            case WSAENOTSOCK: /* One or more of the FDs in the set is not a socket. */",
            "+                pdebug(DEBUG_WARN, \"The fd in the FD set is not a socket!\");",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            " ",
            "-        default:",
            "-            pdebug(DEBUG_WARN, \"Unexpected err %d from select()!\", err);",
            "-            return PLCTAG_ERR_OPEN;",
            "-            break;",
            "+            default:",
            "+                pdebug(DEBUG_WARN, \"Unexpected err %d from select()!\", err);",
            "+                return PLCTAG_ERR_OPEN;",
            "+                break;",
            "         }",
            "     }",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-int socket_wait_event(sock_p sock, int events, int timeout_ms)",
            "-{",
            "+int socket_wait_event(sock_p sock, int events, int timeout_ms) {",
            "     int result = SOCK_EVENT_NONE;",
            "     fd_set read_set;",
            "     fd_set write_set;",
            "     fd_set err_set;",
            "     int num_sockets = 0;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            "@@ -1642,21 +1497,17 @@",
            "     /* add the wake fd */",
            "     FD_SET(sock->wake_read_fd, &read_set);",
            " ",
            "     /* we always want to know about errors. */",
            "     FD_SET(sock->fd, &err_set);",
            " ",
            "     /* add more depending on the mask. */",
            "-    if(events & SOCK_EVENT_CAN_READ) {",
            "-        FD_SET(sock->fd, &read_set);",
            "-    }",
            "+    if(events & SOCK_EVENT_CAN_READ) { FD_SET(sock->fd, &read_set); }",
            " ",
            "-    if((events & SOCK_EVENT_CONNECT) || (events & SOCK_EVENT_CAN_WRITE)) {",
            "-        FD_SET(sock->fd, &write_set);",
            "-    }",
            "+    if((events & SOCK_EVENT_CONNECT) || (events & SOCK_EVENT_CAN_WRITE)) { FD_SET(sock->fd, &write_set); }",
            " ",
            "     /* calculate the timeout. */",
            "     if(timeout_ms > 0) {",
            "         struct timeval tv;",
            " ",
            "         tv.tv_sec = (long)(timeout_ms / 1000);",
            "         tv.tv_usec = (long)(timeout_ms % 1000) * (long)(1000);",
            "@@ -1671,15 +1522,15 @@",
            "     } else if(num_sockets > 0) {",
            "         /* was there a wake up? */",
            "         if(FD_ISSET(sock->wake_read_fd, &read_set)) {",
            "             int bytes_read = 0;",
            "             char buf[32];",
            " ",
            "             /* empty the socket. */",
            "-            while((bytes_read = (int)recv(sock->wake_read_fd, (char*)&buf[0], sizeof(buf), 0)) > 0) { }",
            "+            while((bytes_read = (int)recv(sock->wake_read_fd, (char *)&buf[0], sizeof(buf), 0)) > 0) {}",
            " ",
            "             pdebug(DEBUG_DETAIL, \"Socket woken up.\");",
            " ",
            "             result |= (events & SOCK_EVENT_WAKE_UP);",
            "         }",
            " ",
            "         /* is read ready for the main fd? */",
            "@@ -1759,17 +1610,15 @@",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return result;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_wake(sock_p sock)",
            "-{",
            "+int socket_wake(sock_p sock) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     const char dummy_data[] = \"Dummy data.\";",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!sock) {",
            "         pdebug(DEBUG_WARN, \"Null socket pointer passed!\");",
            "@@ -1777,37 +1626,35 @@",
            "     }",
            " ",
            "     if(!sock->is_open) {",
            "         pdebug(DEBUG_WARN, \"Socket is not open!\");",
            "         return PLCTAG_ERR_READ;",
            "     }",
            " ",
            "-    rc = send(sock->wake_write_fd, (const char *)dummy_data, sizeof(dummy_data), (int)MSG_NOSIGNAL);",
            "+    rc = send(sock->wake_write_fd, (const char *)dummy_data, sizeof(dummy_data), 0);",
            "     if(rc < 0) {",
            "         int err = WSAGetLastError();",
            " ",
            "         if(err == WSAEWOULDBLOCK) {",
            "             pdebug(DEBUG_DETAIL, \"Write wrote no data.\");",
            " ",
            "             rc = PLCTAG_STATUS_OK;",
            "         } else {",
            "-            pdebug(DEBUG_WARN,\"socket write error rc=%d, errno=%d\", rc, err);",
            "+            pdebug(DEBUG_WARN, \"socket write error rc=%d, errno=%d\", rc, err);",
            "             return PLCTAG_ERR_WRITE;",
            "         }",
            "     }",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_read(sock_p s, uint8_t *buf, int size, int timeout_ms)",
            "-{",
            "+int socket_read(sock_p s, uint8_t *buf, int size, int timeout_ms) {",
            "     int rc;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer is null!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -1838,15 +1685,15 @@",
            "                 pdebug(DEBUG_DETAIL, \"Immediate read attempt did not succeed, now wait for select().\");",
            "             } else {",
            "                 pdebug(DEBUG_DETAIL, \"Read resulted in no data.\");",
            "             }",
            " ",
            "             rc = 0;",
            "         } else {",
            "-            pdebug(DEBUG_WARN,\"socket read error rc=%d, errno=%d\", rc, err);",
            "+            pdebug(DEBUG_WARN, \"socket read error rc=%d, errno=%d\", rc, err);",
            "             return PLCTAG_ERR_READ;",
            "         }",
            "     }",
            " ",
            "     /* only wait if we have a timeout and no data and no error. */",
            "     if(rc == 0 && timeout_ms > 0) {",
            "         fd_set read_set;",
            "@@ -1923,29 +1770,27 @@",
            "         rc = recv(s->fd, (char *)buf, size, 0);",
            "         if(rc < 0) {",
            "             int err = WSAGetLastError();",
            " ",
            "             if(err == WSAEWOULDBLOCK) {",
            "                 rc = 0;",
            "             } else {",
            "-                pdebug(DEBUG_WARN,\"socket read error rc=%d, errno=%d\", rc, err);",
            "+                pdebug(DEBUG_WARN, \"socket read error rc=%d, errno=%d\", rc, err);",
            "                 return PLCTAG_ERR_READ;",
            "             }",
            "         }",
            "     }",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done: result = %d.\", rc);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_write(sock_p s, uint8_t *buf, int size, int timeout_ms)",
            "-{",
            "+int socket_write(sock_p s, uint8_t *buf, int size, int timeout_ms) {",
            "     int rc;",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer is null!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -1962,28 +1807,28 @@",
            "     }",
            " ",
            "     if(timeout_ms < 0) {",
            "         pdebug(DEBUG_WARN, \"Timeout must be zero or positive!\");",
            "         return PLCTAG_ERR_BAD_PARAM;",
            "     }",
            " ",
            "-    rc = send(s->fd, (const char *)buf, size, (int)MSG_NOSIGNAL);",
            "+    rc = send(s->fd, (const char *)buf, size, 0);",
            "     if(rc < 0) {",
            "         int err = WSAGetLastError();",
            " ",
            "         if(err == WSAEWOULDBLOCK) {",
            "             if(timeout_ms > 0) {",
            "                 pdebug(DEBUG_DETAIL, \"Immediate write attempt did not succeed, now wait for select().\");",
            "             } else {",
            "                 pdebug(DEBUG_DETAIL, \"Write wrote no data.\");",
            "             }",
            " ",
            "             rc = 0;",
            "         } else {",
            "-            pdebug(DEBUG_WARN,\"socket write error rc=%d, errno=%d\", rc, err);",
            "+            pdebug(DEBUG_WARN, \"socket write error rc=%d, errno=%d\", rc, err);",
            "             return PLCTAG_ERR_WRITE;",
            "         }",
            "     }",
            " ",
            "     /* only wait if we have a timeout and no data. */",
            "     if(rc == 0 && timeout_ms > 0) {",
            "         fd_set write_set;",
            "@@ -2053,37 +1898,35 @@",
            "                     pdebug(DEBUG_WARN, \"Unexpected socket err %d!\", err);",
            "                     return PLCTAG_ERR_BAD_STATUS;",
            "                     break;",
            "             }",
            "         }",
            " ",
            "         /* try to write since select() said we could. */",
            "-        rc = send(s->fd, (const char *)buf, size, (int)MSG_NOSIGNAL);",
            "+        rc = send(s->fd, (const char *)buf, size, 0);",
            "         if(rc < 0) {",
            "             int err = WSAGetLastError();",
            " ",
            "             if(err == WSAEWOULDBLOCK) {",
            "                 pdebug(DEBUG_DETAIL, \"No data written.\");",
            "                 rc = 0;",
            "             } else {",
            "-                pdebug(DEBUG_WARN,\"socket write error rc=%d, errno=%d\", rc, err);",
            "+                pdebug(DEBUG_WARN, \"socket write error rc=%d, errno=%d\", rc, err);",
            "                 return PLCTAG_ERR_WRITE;",
            "             }",
            "         }",
            "     }",
            " ",
            "     pdebug(DEBUG_DETAIL, \"Done: result = %d.\", rc);",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_close(sock_p s)",
            "-{",
            "+int socket_close(sock_p s) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_INFO, \"Starting.\");",
            " ",
            "     if(!s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer or pointer to socket pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -2102,17 +1945,15 @@",
            " ",
            "     pdebug(DEBUG_INFO, \"Done.\");",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int socket_destroy(sock_p *s)",
            "-{",
            "+int socket_destroy(sock_p *s) {",
            "     int rc = PLCTAG_STATUS_OK;",
            " ",
            "     pdebug(DEBUG_INFO, \"Starting.\");",
            " ",
            "     if(!s || !*s) {",
            "         pdebug(DEBUG_WARN, \"Socket pointer or pointer to socket pointer is NULL!\");",
            "         return PLCTAG_ERR_NULL_PTR;",
            "@@ -2138,32 +1979,28 @@",
            " ",
            "     socket_close(*s);",
            " ",
            "     mem_free(*s);",
            " ",
            "     *s = 0;",
            " ",
            "-    if(WSACleanup() != NO_ERROR) {",
            "-        return PLCTAG_ERR_WINSOCK;",
            "-    }",
            "+    if(WSACleanup() != NO_ERROR) { return PLCTAG_ERR_WINSOCK; }",
            " ",
            "     pdebug(DEBUG_INFO, \"Done.\");",
            " ",
            "-    return PLCTAG_STATUS_OK;",
            "+    return rc;",
            " }",
            " ",
            " ",
            "-",
            "-int sock_create_event_wakeup_channel(sock_p sock)",
            "-{",
            "+int sock_create_event_wakeup_channel(sock_p sock) {",
            "     int rc = PLCTAG_STATUS_OK;",
            "     SOCKET listener = INVALID_SOCKET;",
            "     struct sockaddr_in listener_addr_info;",
            "     socklen_t addr_info_size = sizeof(struct sockaddr_in);",
            "-    int non_blocking = 1;",
            "+    u_long non_blocking = 1;",
            "     SOCKET wake_fds[2];",
            " ",
            "     pdebug(DEBUG_INFO, \"Starting.\");",
            " ",
            "     wake_fds[0] = INVALID_SOCKET;",
            "     wake_fds[1] = INVALID_SOCKET;",
            " ",
            "@@ -2192,15 +2029,15 @@",
            " ",
            "     do {",
            "         /*",
            "          * Set up our listening socket.",
            "          */",
            " ",
            "         listener = (SOCKET)socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);",
            "-        if(listener < 0) {",
            "+        if(listener == INVALID_SOCKET) {",
            "             pdebug(DEBUG_WARN, \"Error %d creating the listener socket!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            " ",
            "         /* clear the listener address info */",
            "         mem_set(&listener_addr_info, 0, addr_info_size);",
            "@@ -2213,15 +2050,15 @@",
            " ",
            "         /* we want to connect on the loopback address. */",
            "         listener_addr_info.sin_addr.s_addr = htonl(INADDR_LOOPBACK);",
            " ",
            "         /* now comes the part where we could fail. */",
            " ",
            "         /* first we bind the listener to the loopback and let the OS choose the port. */",
            "-        if(bind(listener, (struct sockaddr *)&listener_addr_info, addr_info_size)){",
            "+        if(bind(listener, (struct sockaddr *)&listener_addr_info, addr_info_size)) {",
            "             pdebug(DEBUG_WARN, \"Error %d binding the listener socket!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            " ",
            "         /*",
            "          * we need to get the address and port of the listener for later steps.",
            "@@ -2241,15 +2078,15 @@",
            "         }",
            " ",
            "         /*",
            "          * Set up our wake read side socket.",
            "          */",
            " ",
            "         wake_fds[0] = (SOCKET)socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);",
            "-        if (wake_fds[0] < 0) {",
            "+        if(wake_fds[0] <= 0) {",
            "             pdebug(DEBUG_WARN, \"Error %d creating the wake channel read side socket!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            " ",
            "         /*",
            "          * now we start the next phase.   We need to connect to our own listener.",
            "@@ -2260,41 +2097,39 @@",
            "             pdebug(DEBUG_WARN, \"Error %d connecting to the listener socket!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            " ",
            "         /* now we accept our own connection. This becomes the writer side. */",
            "         wake_fds[1] = accept(listener, 0, 0);",
            "-        if (wake_fds[1] == INVALID_SOCKET) {",
            "+        if(wake_fds[1] == INVALID_SOCKET) {",
            "             pdebug(DEBUG_WARN, \"Error %d connecting to the listener socket!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            " ",
            "         /* now we need to set these to non-blocking. */",
            " ",
            "         /* reader */",
            "-        if(ioctlsocket(wake_fds[0], FIONBIO, &non_blocking)) {",
            "+        if(ioctlsocket(wake_fds[0], (long)FIONBIO, &non_blocking)) {",
            "             pdebug(DEBUG_WARN, \"Error %d setting reader socket to non-blocking!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            " ",
            "         /* writer */",
            "-        if(ioctlsocket(wake_fds[1], FIONBIO, &non_blocking)) {",
            "+        if(ioctlsocket(wake_fds[1], (long)FIONBIO, &non_blocking)) {",
            "             pdebug(DEBUG_WARN, \"Error %d setting reader socket to non-blocking!\", WSAGetLastError());",
            "             rc = PLCTAG_ERR_WINSOCK;",
            "             break;",
            "         }",
            "     } while(0);",
            " ",
            "     /* do some clean up */",
            "-    if(listener != INVALID_SOCKET) {",
            "-        closesocket(listener);",
            "-    }",
            "+    if(listener != INVALID_SOCKET) { closesocket(listener); }",
            " ",
            "     /* check the result */",
            "     if(rc != PLCTAG_STATUS_OK) {",
            "         pdebug(DEBUG_WARN, \"Unable to set up wakeup socket!\");",
            " ",
            "         if(wake_fds[0] != INVALID_SOCKET) {",
            "             closesocket(wake_fds[0]);",
            "@@ -2312,195 +2147,152 @@",
            "         pdebug(DEBUG_INFO, \"Done.\");",
            "     }",
            " ",
            "     return rc;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /***************************************************************************",
            "  ****************************** Serial Port ********************************",
            "  **************************************************************************/",
            " ",
            " ",
            " struct serial_port_t {",
            "     HANDLE hSerialPort;",
            "     COMMCONFIG oldDCBSerialParams;",
            "     COMMTIMEOUTS oldTimeouts;",
            " };",
            " ",
            " ",
            "-serial_port_p plc_lib_open_serial_port(/*plc_lib lib,*/ const char *path, int baud_rate, int data_bits, int stop_bits, int parity_type)",
            "-{",
            "+serial_port_p plc_lib_open_serial_port(/*plc_lib lib,*/ const char *path, int baud_rate, int data_bits, int stop_bits,",
            "+                                       int parity_type) {",
            "     serial_port_p serial_port;",
            "     COMMCONFIG dcbSerialParams;",
            "     COMMTIMEOUTS timeouts;",
            "     HANDLE hSerialPort;",
            "     int BAUD, PARITY, DATABITS, STOPBITS;",
            " ",
            "-    //plc_err(lib, PLC_LOG_DEBUG, PLC_ERR_NONE, \"Starting.\");",
            "+    // plc_err(lib, PLC_LOG_DEBUG, PLC_ERR_NONE, \"Starting.\");",
            " ",
            " ",
            "     /* create the configuration for the serial port. */",
            " ",
            "     /* code largely from Programmer's Heaven.",
            "      */",
            " ",
            "-    switch (baud_rate) {",
            "-    case 38400:",
            "-        BAUD = CBR_38400;",
            "-        break;",
            "-    case 19200:",
            "-        BAUD  = CBR_19200;",
            "-        break;",
            "-    case 9600:",
            "-        BAUD  = CBR_9600;",
            "-        break;",
            "-    case 4800:",
            "-        BAUD  = CBR_4800;",
            "-        break;",
            "-    case 2400:",
            "-        BAUD  = CBR_2400;",
            "-        break;",
            "-    case 1200:",
            "-        BAUD  = CBR_1200;",
            "-        break;",
            "-    case 600:",
            "-        BAUD  = CBR_600;",
            "-        break;",
            "-    case 300:",
            "-        BAUD  = CBR_300;",
            "-        break;",
            "-    case 110:",
            "-        BAUD  = CBR_110;",
            "-        break;",
            "-    default:",
            "-        /* unsupported baud rate */",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported baud rate: %d. Use standard baud rates (300,600,1200,2400...).\",baud_rate);",
            "-        return NULL;",
            "+    switch(baud_rate) {",
            "+        case 38400: BAUD = CBR_38400; break;",
            "+        case 19200: BAUD = CBR_19200; break;",
            "+        case 9600: BAUD = CBR_9600; break;",
            "+        case 4800: BAUD = CBR_4800; break;",
            "+        case 2400: BAUD = CBR_2400; break;",
            "+        case 1200: BAUD = CBR_1200; break;",
            "+        case 600: BAUD = CBR_600; break;",
            "+        case 300: BAUD = CBR_300; break;",
            "+        case 110: BAUD = CBR_110; break;",
            "+        default:",
            "+            /* unsupported baud rate */",
            "+            // plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported baud rate: %d. Use standard baud rates",
            "+            // (300,600,1200,2400...).\",baud_rate);",
            "+            return NULL;",
            "     }",
            " ",
            " ",
            "     /* data bits */",
            "     switch(data_bits) {",
            "-    case 5:",
            "-        DATABITS = 5;",
            "-        break;",
            "-",
            "-    case 6:",
            "-        DATABITS = 6;",
            "-        break;",
            "-",
            "-    case 7:",
            "-        DATABITS = 7;",
            "-        break;",
            "-",
            "-    case 8:",
            "-        DATABITS = 8;",
            "-        break;",
            "-",
            "-    default:",
            "-        /* unsupported number of data bits. */",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported number of data bits: %d. Use 5-8.\",data_bits);",
            "-        return NULL;",
            "+        case 5: DATABITS = 5; break;",
            "+",
            "+        case 6: DATABITS = 6; break;",
            "+",
            "+        case 7: DATABITS = 7; break;",
            "+",
            "+        case 8: DATABITS = 8; break;",
            "+",
            "+        default:",
            "+            /* unsupported number of data bits. */",
            "+            // plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported number of data bits: %d. Use 5-8.\",data_bits);",
            "+            return NULL;",
            "     }",
            " ",
            " ",
            "     switch(stop_bits) {",
            "-    case 1:",
            "-        STOPBITS = ONESTOPBIT;",
            "-        break;",
            "-    case 2:",
            "-        STOPBITS = TWOSTOPBITS;",
            "-        break;",
            "-    default:",
            "-        /* unsupported number of stop bits. */",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported number of stop bits, %d, must be 1 or 2.\",stop_bits);",
            "-        return NULL;",
            "+        case 1: STOPBITS = ONESTOPBIT; break;",
            "+        case 2: STOPBITS = TWOSTOPBITS; break;",
            "+        default:",
            "+            /* unsupported number of stop bits. */",
            "+            // plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported number of stop bits, %d, must be 1 or 2.\",stop_bits);",
            "+            return NULL;",
            "     }",
            " ",
            "     switch(parity_type) {",
            "-    case 0:",
            "-        PARITY = NOPARITY;",
            "-        break;",
            "-    case 1: /* Odd parity */",
            "-        PARITY = ODDPARITY;",
            "-        break;",
            "-    case 2: /* Even parity */",
            "-        PARITY = EVENPARITY;",
            "-        break;",
            "-    default:",
            "-        /* unsupported number of stop bits. */",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported parity type, must be none (0), odd (1) or even (2).\");",
            "-        return NULL;",
            "+        case 0: PARITY = NOPARITY; break;",
            "+        case 1: /* Odd parity */ PARITY = ODDPARITY; break;",
            "+        case 2: /* Even parity */ PARITY = EVENPARITY; break;",
            "+        default:",
            "+            /* unsupported number of stop bits. */",
            "+            // plc_err(lib, PLC_LOG_ERR, PLC_ERR_BAD_PARAM,\"Unsupported parity type, must be none (0), odd (1) or even (2).\");",
            "+            return NULL;",
            "     }",
            " ",
            "     /* allocate the structure */",
            "-    serial_port = (serial_port_p)calloc(1,sizeof(struct serial_port_t));",
            "+    serial_port = (serial_port_p)calloc(1, sizeof(struct serial_port_t));",
            " ",
            "     if(!serial_port) {",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_NO_MEM, \"Unable to allocate serial port struct.\");",
            "+        // plc_err(lib, PLC_LOG_ERR, PLC_ERR_NO_MEM, \"Unable to allocate serial port struct.\");",
            "         return NULL;",
            "     }",
            " ",
            "     /* open the serial port device */",
            "-    hSerialPort = CreateFile(path,",
            "-                             GENERIC_READ | GENERIC_WRITE,",
            "-                             0,",
            "-                             NULL,",
            "-                             OPEN_EXISTING,",
            "-                             FILE_ATTRIBUTE_NORMAL,",
            "-                             NULL);",
            "+    hSerialPort = CreateFile(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);",
            " ",
            "     /* did the open succeed? */",
            "     if(hSerialPort == INVALID_HANDLE_VALUE) {",
            "         free(serial_port);",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error opening serial device %s\",path);",
            "+        // plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error opening serial device %s\",path);",
            "         return NULL;",
            "     }",
            " ",
            "     /* get existing serial port configuration and save it. */",
            "     if(!GetCommState(hSerialPort, &(serial_port->oldDCBSerialParams.dcb))) {",
            "         free(serial_port);",
            "         CloseHandle(hSerialPort);",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error getting backup serial port configuration.\",path);",
            "+        // plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error getting backup serial port configuration.\",path);",
            "         return NULL;",
            "     }",
            " ",
            "     /* copy the params. */",
            "     dcbSerialParams = serial_port->oldDCBSerialParams;",
            " ",
            "     dcbSerialParams.dcb.BaudRate = BAUD;",
            "     dcbSerialParams.dcb.ByteSize = DATABITS;",
            "     dcbSerialParams.dcb.StopBits = STOPBITS;",
            "     dcbSerialParams.dcb.Parity = PARITY;",
            " ",
            "-    dcbSerialParams.dcb.fBinary         = TRUE;",
            "-    dcbSerialParams.dcb.fDtrControl     = DTR_CONTROL_DISABLE;",
            "-    dcbSerialParams.dcb.fRtsControl     = RTS_CONTROL_DISABLE;",
            "-    dcbSerialParams.dcb.fOutxCtsFlow    = FALSE;",
            "-    dcbSerialParams.dcb.fOutxDsrFlow    = FALSE;",
            "+    dcbSerialParams.dcb.fBinary = TRUE;",
            "+    dcbSerialParams.dcb.fDtrControl = DTR_CONTROL_DISABLE;",
            "+    dcbSerialParams.dcb.fRtsControl = RTS_CONTROL_DISABLE;",
            "+    dcbSerialParams.dcb.fOutxCtsFlow = FALSE;",
            "+    dcbSerialParams.dcb.fOutxDsrFlow = FALSE;",
            "     dcbSerialParams.dcb.fDsrSensitivity = FALSE;",
            "-    dcbSerialParams.dcb.fAbortOnError   = TRUE; /* TODO - should this be false? */",
            "+    dcbSerialParams.dcb.fAbortOnError = TRUE; /* TODO - should this be false? */",
            " ",
            "     /* attempt to set the serial params */",
            "     if(!SetCommState(hSerialPort, &dcbSerialParams.dcb)) {",
            "         free(serial_port);",
            "         CloseHandle(hSerialPort);",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error setting serial port configuration.\",path);",
            "+        // plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error setting serial port configuration.\",path);",
            "         return NULL;",
            "     }",
            " ",
            "     /* attempt to get the current serial port timeout set up */",
            "     if(!GetCommTimeouts(hSerialPort, &(serial_port->oldTimeouts))) {",
            "         SetCommState(hSerialPort, &(serial_port->oldDCBSerialParams.dcb));",
            "         free(serial_port);",
            "         CloseHandle(hSerialPort);",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error getting backup serial port timeouts.\",path);",
            "+        // plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error getting backup serial port timeouts.\",path);",
            "         return NULL;",
            "     }",
            " ",
            "     timeouts = serial_port->oldTimeouts;",
            " ",
            "     /* set the timeouts for asynch operation */",
            "     timeouts.ReadIntervalTimeout = MAXDWORD;",
            "@@ -2510,33 +2302,25 @@",
            "     timeouts.WriteTotalTimeoutConstant = 0;",
            " ",
            "     /* attempt to set the current serial port timeout set up */",
            "     if(!SetCommTimeouts(hSerialPort, &timeouts)) {",
            "         SetCommState(hSerialPort, &(serial_port->oldDCBSerialParams.dcb));",
            "         free(serial_port);",
            "         CloseHandle(hSerialPort);",
            "-        //plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error getting backup serial port timeouts.\",path);",
            "+        // plc_err(lib, PLC_LOG_ERR, PLC_ERR_OPEN, \"Error getting backup serial port timeouts.\",path);",
            "         return NULL;",
            "     }",
            " ",
            "     return serial_port;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            "-",
            "-int plc_lib_close_serial_port(serial_port_p serial_port)",
            "-{",
            "+int plc_lib_close_serial_port(serial_port_p serial_port) {",
            "     /* try to prevent this from being called twice */",
            "-    if(!serial_port || !serial_port->hSerialPort) {",
            "-        return 1;",
            "-    }",
            "+    if(!serial_port || !serial_port->hSerialPort) { return 1; }",
            " ",
            "     /* reset the old options */",
            "     SetCommTimeouts(serial_port->hSerialPort, &(serial_port->oldTimeouts));",
            "     SetCommState(serial_port->hSerialPort, &(serial_port->oldDCBSerialParams.dcb));",
            "     CloseHandle(serial_port->hSerialPort);",
            " ",
            "     /* make sure that we do not call this twice. */",
            "@@ -2545,100 +2329,75 @@",
            "     /* free the serial port */",
            "     free(serial_port);",
            " ",
            "     return 1;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-int plc_lib_serial_port_read(serial_port_p serial_port, uint8_t *data, int size)",
            "-{",
            "+int plc_lib_serial_port_read(serial_port_p serial_port, uint8_t *data, int size) {",
            "     DWORD numBytesRead = 0;",
            "     BOOL rc;",
            " ",
            "-    rc = ReadFile(serial_port->hSerialPort,(LPVOID)data,(DWORD)size,&numBytesRead,NULL);",
            "+    rc = ReadFile(serial_port->hSerialPort, (LPVOID)data, (DWORD)size, &numBytesRead, NULL);",
            " ",
            "-    if(rc != TRUE)",
            "-        return -1;",
            "+    if(rc != TRUE) { return -1; }",
            " ",
            "     return (int)numBytesRead;",
            " }",
            " ",
            " ",
            "-int plc_lib_serial_port_write(serial_port_p serial_port, uint8_t *data, int size)",
            "-{",
            "+int plc_lib_serial_port_write(serial_port_p serial_port, uint8_t *data, int size) {",
            "     DWORD numBytesWritten = 0;",
            "-    BOOL rc;",
            " ",
            "-    rc = WriteFile(serial_port->hSerialPort,(LPVOID)data,(DWORD)size,&numBytesWritten,NULL);",
            "+    WriteFile(serial_port->hSerialPort, (LPVOID)data, (DWORD)size, &numBytesWritten, NULL);",
            " ",
            "     return (int)numBytesWritten;",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            " /***************************************************************************",
            "  ***************************** Miscellaneous *******************************",
            "  **************************************************************************/",
            " ",
            " ",
            "-",
            "-",
            "-",
            "-",
            "-int sleep_ms(int ms)",
            "-{",
            "-    Sleep(ms);",
            "+int sleep_ms(int ms) {",
            "+    Sleep((DWORD)ms);",
            "     return 1;",
            " }",
            " ",
            " ",
            "-",
            " /*",
            "  * time_ms",
            "  *",
            "  * Return current system time in millisecond units.  This is NOT an",
            "  * Unix epoch time.  Windows uses a different epoch starting 1/1/1601.",
            "  */",
            " ",
            "-int64_t time_ms(void)",
            "-{",
            "+int64_t time_ms(void) {",
            "     FILETIME ft;",
            "     int64_t res;",
            " ",
            "     GetSystemTimeAsFileTime(&ft);",
            " ",
            "     /* calculate time as 100ns increments since Jan 1, 1601. */",
            "     res = (int64_t)(ft.dwLowDateTime) + ((int64_t)(ft.dwHighDateTime) << 32);",
            " ",
            "     /* get time in ms.   Magic offset is for Jan 1, 1970 Unix epoch baseline. */",
            "     res = (res - 116444736000000000) / 10000;",
            " ",
            "-    return  res;",
            "+    return res;",
            " }",
            " ",
            " ",
            "-struct tm *localtime_r(const time_t *timep, struct tm *result)",
            "-{",
            "+struct tm *localtime_r(const time_t *timep, struct tm *result) {",
            "     time_t t = *timep;",
            " ",
            "     localtime_s(result, &t);",
            " ",
            "     return result;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*#ifdef __cplusplus",
            " }",
            " #endif",
            " */"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/platform/windows/platform.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/platform/windows/platform.h",
            "+++ /home/libplctag-2.6.7/src/platform/windows/platform.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -42,41 +42,36 @@",
            " ",
            " /*#ifdef __cplusplus",
            " extern \"C\"",
            " {",
            " #endif",
            " */",
            " ",
            "-#define _WINSOCKAPI_",
            "+/* KEEP THE SPACES BETWEEN LINES!  The order is required! */",
            "+#include <Winsock2.h>",
            "+",
            " #include <windows.h>",
            "+",
            "+#include <Ws2tcpip.h>",
            "+",
            "+",
            " #include <tchar.h>",
            " #include <strsafe.h>",
            " #include <io.h>",
            "-#include <Winsock2.h>",
            "-#include <Ws2tcpip.h>",
            " #include <string.h>",
            " #include <stdlib.h>",
            "-#include <winnt.h>",
            " #include <errno.h>",
            " #include <math.h>",
            " #include <process.h>",
            " #include <time.h>",
            " #include <stdio.h>",
            " ",
            "-/*#include <WinSock2.h>*/",
            "-/*#include <Ws2tcpip.h>*/",
            "-/*#include <sys/types.h>*/",
            " #include <stdint.h>",
            "-/*#include <io.h>*/",
            "-/*#include <stdlib.h>*/",
            " #include <malloc.h>",
            " ",
            "-//#include \"libplctag_lib.h\"",
            "-",
            "-",
            " ",
            " /* WinSock does not define this or support signals */",
            " #define MSG_NOSIGNAL 0",
            " ",
            " #ifdef _MSC_VER",
            "     /* MS Visual Studio C compiler. */",
            "     #define START_PACK __pragma( pack(push, 1) )",
            "@@ -159,17 +154,14 @@",
            " extern char **str_split(const char *str, const char *sep);",
            " #define str_concat(s1, ...) str_concat_impl(COUNT_NARG(__VA_ARGS__)+1, s1, __VA_ARGS__)",
            " extern char *str_concat_impl(int num_args, ...);",
            " ",
            " /* mutex functions/defs */",
            " typedef struct mutex_t *mutex_p;",
            " extern int mutex_create(mutex_p *m);",
            "-// extern int mutex_lock(mutex_p m);",
            "-// extern int mutex_try_lock(mutex_p m);",
            "-// extern int mutex_unlock(mutex_p m);",
            " extern int mutex_destroy(mutex_p *m);",
            " ",
            " extern int mutex_lock_impl(const char *func, int line_num, mutex_p m);",
            " extern int mutex_try_lock_impl(const char *func, int line_num, mutex_p m);",
            " extern int mutex_unlock_impl(const char *func, int line_num, mutex_p m);",
            " ",
            " #if defined(_WIN32) && defined(_MSC_VER)",
            "@@ -218,15 +210,29 @@",
            " extern int thread_join(thread_p t);",
            " extern int thread_detach();",
            " extern int thread_destroy(thread_p *t);",
            " ",
            " #define THREAD_FUNC(func) DWORD __stdcall func(LPVOID arg)",
            " #define THREAD_RETURN(val) return (DWORD)val;",
            " ",
            "-#define THREAD_LOCAL __declspec(thread)",
            "+",
            "+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && (defined(__MINGW32__) || defined(__MINGW64__))",
            "+    #define THREAD_LOCAL _Thread_local",
            "+#else /* use Windows __declspec attribute */",
            "+    #define WIN32_LEAN_AND_MEAN",
            "+    #include <windows.h>",
            "+    #include <processthreadsapi.h>",
            "+    #define THREAD_LOCAL __declspec(thread)",
            "+    #define thread_func_t LPTHREAD_START_ROUTINE",
            "+    #define NO_RETURN __declspec(noreturn)",
            "+    #define THREAD_FUNC(func) DWORD __stdcall func(LPVOID arg)",
            "+    #define THREAD_RETURN(val) return (DWORD)val;",
            "+",
            "+#endif",
            "+",
            " ",
            " /* atomic operations */",
            " #define spin_block(lock) \\",
            " for(int LINE_ID(__sync_flag_nargle_lock) = 1; LINE_ID(__sync_flag_nargle_lock); LINE_ID(__sync_flag_nargle_lock) = 0, lock_release(lock))  for(int LINE_ID(__sync_rc_nargle_lock) = lock_acquire(lock); LINE_ID(__sync_rc_nargle_lock) && LINE_ID(__sync_flag_nargle_lock) ; LINE_ID(__sync_flag_nargle_lock) = 0)",
            " ",
            " typedef volatile long int lock_t;"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/cip.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/cip.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/cip.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,765 +27,1019 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include <inttypes.h>",
            "-#include <stdint.h>",
            "-#include <stdlib.h>",
            " #include \"cip.h\"",
            " #include \"eip.h\"",
            " #include \"pccc.h\"",
            " #include \"plc.h\"",
            " #include \"slice.h\"",
            " #include \"utils.h\"",
            "+#include <inttypes.h>",
            "+#include <stdint.h>",
            "+#include <stdlib.h>",
            "+#include <utils/random_utils.h>",
            " ",
            " ",
            " /* tag commands */",
            "-const uint8_t CIP_MULTI[] = { 0x0A, 0x02, 0x20, 0x02, 0x24, 0x01 };",
            "-const uint8_t CIP_READ[] = { 0x4C };",
            "-const uint8_t CIP_WRITE[] = { 0x4D };",
            "-const uint8_t CIP_RMW[] = { 0x4E, 0x02, 0x20, 0x02, 0x24, 0x01 };",
            "-const uint8_t CIP_READ_FRAG[] = { 0x52 };",
            "-const uint8_t CIP_WRITE_FRAG[] = { 0x53 };",
            "+#define CIP_SRV_MULTI ((uint8_t)0x0a)",
            "+#define CIP_SRV_PCCC_EXECUTE ((uint8_t)0x4b)",
            "+#define CIP_SRV_READ_NAMED_TAG ((uint8_t)0x4c)",
            "+#define CIP_SRV_WRITE_NAMED_TAG ((uint8_t)0x4d)",
            "+#define CIP_SRV_FORWARD_CLOSE ((uint8_t)0x4e)",
            "+#define CIP_SRV_READ_NAMED_TAG_FRAG ((uint8_t)0x52)",
            "+#define CIP_SRV_WRITE_NAMED_TAG_FRAG ((uint8_t)0x53)",
            "+#define CIP_SRV_FORWARD_OPEN ((uint8_t)0x54)",
            "+#define CIP_SRV_INSTANCES_ATTRIBS ((uint8_t)0x55)",
            "+#define CIP_SRV_FORWARD_OPEN_EX ((uint8_t)0x5b)",
            " ",
            " ",
            " /* non-tag commands */",
            "-//4b 02 20 67 24 01 07 3d f3 45 43 50 21",
            "-const uint8_t CIP_PCCC_EXECUTE[] = { 0x4B, 0x02, 0x20, 0x67, 0x24, 0x01, 0x07, 0x3d, 0xf3, 0x45, 0x43, 0x50, 0x21 };",
            "-const uint8_t CIP_FORWARD_CLOSE[] = { 0x4E, 0x02, 0x20, 0x06, 0x24, 0x01 };",
            "-const uint8_t CIP_FORWARD_OPEN[] = { 0x54, 0x02, 0x20, 0x06, 0x24, 0x01 };",
            "-const uint8_t CIP_LIST_TAGS[] = { 0x55, 0x02, 0x20, 0x02, 0x24, 0x01 };",
            "-const uint8_t CIP_FORWARD_OPEN_EX[] = { 0x5B, 0x02, 0x20, 0x06, 0x24, 0x01 };",
            "+// 4b 02 20 67 24 01 07 3d f3 45 43 50 21",
            "+//  const uint8_t CIP_PCCC_EXECUTE_OBJ[] = { 0x02, 0x20, 0x67, 0x24, 0x01 };",
            "+//  const uint8_t CIP_PCCC_PREFIX[] = { 0x07, 0x3d, 0xf3, 0x45, 0x43, 0x50, 0x21 };",
            "+//  const uint8_t CIP_FORWARD_CLOSE[] = { 0x4E, 0x02, 0x20, 0x06, 0x24, 0x01 };",
            "+const uint8_t CIP_OBJ_CONNECTION_MANAGER[] = {0x20, 0x06, 0x24, 0x01};",
            "+// const uint8_t CIP_LIST_TAGS[] = { 0x55, 0x02, 0x20, 0x02, 0x24, 0x01 };",
            "+// const uint8_t CIP_FORWARD_OPEN_EX[] = { 0x5B, 0x02, 0x20, 0x06, 0x24, 0x01 };",
            " ",
            " /* path to match. */",
            " // uint8_t LOGIX_CONN_PATH[] = { 0x03, 0x00, 0x00, 0x20, 0x02, 0x24, 0x01 };",
            " // uint8_t MICRO800_CONN_PATH[] = { 0x02, 0x20, 0x02, 0x24, 0x01 };",
            " ",
            "-#define CIP_DONE               ((uint8_t)0x80)",
            "+#define CIP_DONE ((uint8_t)0x80)",
            " ",
            " #define CIP_SYMBOLIC_SEGMENT_MARKER ((uint8_t)0x91)",
            " ",
            " /* CIP Errors */",
            " ",
            "-#define CIP_OK                  ((uint8_t)0x00)",
            "-#define CIP_ERR_0x01            ((uint8_t)0x01)",
            "-#define CIP_ERR_FRAG            ((uint8_t)0x06)",
            "-#define CIP_ERR_UNSUPPORTED     ((uint8_t)0x08)",
            "-#define CIP_ERR_EXTENDED        ((uint8_t)0xff)",
            "+#define CIP_OK ((uint8_t)0x00)",
            "+#define CIP_ERR_EXT_ERR ((uint8_t)0x01)",
            "+#define CIP_ERR_INVALID_PARAM ((uint8_t)0x03)",
            "+#define CIP_ERR_PATH_SEGMENT ((uint8_t)0x04)",
            "+#define CIP_ERR_PATH_DEST_UNKNOWN ((uint8_t)0x05)",
            "+#define CIP_ERR_FRAG ((uint8_t)0x06)",
            "+#define CIP_ERR_UNSUPPORTED ((uint8_t)0x08)",
            "+#define CIP_ERR_INSUFFICIENT_DATA ((uint8_t)0x13)",
            "+#define CIP_ERR_TOO_MUCH_DATA ((uint8_t)0x15)",
            "+#define CIP_ERR_EXTENDED ((uint8_t)0xff)",
            "+",
            "+#define CIP_ERR_EX_DUPLICATE_CONN ((uint16_t)0x0100)",
            "+#define CIP_ERR_EX_INVALID_CONN_SIZE ((uint16_t)0x0109)",
            "+#define CIP_ERR_EX_TOO_LONG ((uint16_t)0x2105)",
            "+",
            "+/* tag and object constants */",
            "+#define CIP_TAG_PATH_MIN ((size_t)(4)) /* 1 byte segment type, 1 byte length count, 1 byte tag name, 1 byte padding */",
            "+#define CIP_OBJ_PATH_MIN ((size_t)(4)) /* 1 byte class type, 1 byte class ID, 1 byte instance type, 1 byte instance ID */",
            "+",
            "+#define CIP_RESPONSE_HEADER_SIZE ((size_t)4)",
            "+#define CIP_RESPONSE_HEADER_EXT_ERR_SIZE ((size_t)6)",
            "+#define CIP_RESPONSE_TYPE_INFO_SIZE ((size_t)2) /* FIXME - this should come from the tag */",
            "+#define CIP_MIN_ATOMIC_ELEMENT_SIZE \\",
            "+    ((size_t)8) /* size to use if element size of tag is big.  Prevents splitting of atomic values. */",
            "+",
            "+#define CIP_READ_PAYLOAD_MIN_SIZE ((size_t)2)      /* two bytes for the element count */",
            "+#define CIP_READ_FRAG_PAYLOAD_MIN_SIZE ((size_t)6) /* two bytes for element count, four for byte offset */",
            "+",
            "+#define CIP_WRITE_PAYLOAD_MIN_SIZE ((size_t)5) /* two bytes for the element count, two bytes for type, 1 byte for data */",
            "+#define CIP_WRITE_FRAG_PAYLOAD_MIN_SIZE \\",
            "+    ((size_t)9) /* two bytes for element count, four for byte offset, two bytes for type, 1 bytes for data */",
            "+",
            "+#define CIP_TAG_MAX_INDEXES ((uint32_t)3) /* should double check for OMRON */",
            "+",
            "+",
            "+// typedef struct {",
            "+//     uint8_t service_code;   /* why is the operation code _before_ the path? */",
            "+//     uint8_t path_size;      /* size in 16-bit words of the path */",
            "+//     slice_s path;           /* store this in a slice to avoid copying */",
            "+// } cip_header_s;",
            " ",
            "-#define CIP_ERR_EX_TOO_LONG     ((uint16_t)0x2105)",
            " ",
            "-typedef struct {",
            "-    uint8_t service_code;   /* why is the operation code _before_ the path? */",
            "-    uint8_t path_size;      /* size in 16-bit words of the path */",
            "-    slice_s path;           /* store this in a slice to avoid copying */",
            "-} cip_header_s;",
            "-",
            "-static slice_s handle_forward_open(slice_s input, slice_s output, plc_s *plc);",
            "-static slice_s handle_forward_close(slice_s input, slice_s output, plc_s *plc);",
            "-static slice_s handle_read_request(slice_s input, slice_s output, plc_s *plc);",
            "-static slice_s handle_write_request(slice_s input, slice_s output, plc_s *plc);",
            "-",
            "-static bool process_tag_segment(plc_s *plc, slice_s input, tag_def_s **tag, size_t *start_read_offset);",
            " static slice_s make_cip_error(slice_s output, uint8_t cip_cmd, uint8_t cip_err, bool extend, uint16_t extended_error);",
            "-static bool match_path(slice_s input, bool need_pad, uint8_t *path, uint8_t path_len);",
            " ",
            "-slice_s cip_dispatch_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+static slice_s handle_forward_open(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                                   plc_s *plc);",
            "+static slice_s handle_forward_close(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                                    plc_s *plc);",
            "+static slice_s handle_read_request(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                                   plc_s *plc);",
            "+static slice_s handle_write_request(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                                    plc_s *plc);",
            "+",
            "+static bool parse_cip_request(slice_s input, uint8_t *cip_service, slice_s *cip_service_path, slice_s *cip_service_payload);",
            "+static bool extract_cip_path(slice_s input, size_t *offset, bool padded, slice_s *output);",
            "+static bool parse_tag_path(slice_s tag_path, plc_s *plc, tag_def_s **tag, uint32_t *num_indexes, uint32_t *indexes);",
            "+static bool calculate_request_start_and_end_offsets(tag_def_s *tag, uint32_t num_indexes, uint32_t *indexes,",
            "+                                                    uint16_t request_element_count, size_t *request_start_byte_offset,",
            "+                                                    size_t *request_end_byte_offset);",
            "+",
            "+",
            "+slice_s cip_dispatch_request(slice_s input, slice_s output, plc_s *plc) {",
            "+    uint8_t cip_service = 0;",
            "+    slice_s cip_service_path = {0};",
            "+    slice_s cip_service_payload = {0};",
            "+",
            "     info(\"Got packet:\");",
            "     slice_dump(input);",
            " ",
            "-    /* match the prefix and dispatch. */",
            "-    if(slice_match_bytes(input, CIP_READ, sizeof(CIP_READ))) {",
            "-        info(\"Case CIP_READ\");",
            "-        return handle_read_request(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_READ_FRAG, sizeof(CIP_READ_FRAG))) {",
            "-        info(\"Case CIP_READ_FRAG\");",
            "-        return handle_read_request(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_WRITE, sizeof(CIP_WRITE))) {",
            "-        info(\"Case CIP_WRITE\");",
            "-        return handle_write_request(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_WRITE_FRAG, sizeof(CIP_WRITE_FRAG))) {",
            "-        info(\"Case CIP_WRITE_FRAG\");",
            "-        return handle_write_request(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_FORWARD_OPEN, sizeof(CIP_FORWARD_OPEN))) {",
            "-        info(\"Case CIP_FORWARD_OPEN\");",
            "-        return handle_forward_open(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_FORWARD_OPEN_EX, sizeof(CIP_FORWARD_OPEN_EX))) {",
            "-        info(\"Case CIP_FORWARD_OPEN_EX\");",
            "-        return handle_forward_open(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_FORWARD_CLOSE, sizeof(CIP_FORWARD_CLOSE))) {",
            "-        info(\"Case CIP_FORWARD_CLOSE\");",
            "-        return handle_forward_close(input, output, plc);",
            "-    } else if(slice_match_bytes(input, CIP_PCCC_EXECUTE, sizeof(CIP_PCCC_EXECUTE))) {",
            "-        info(\"Case CIP_PCCC_EXECUTE\");",
            "-        return dispatch_pccc_request(input, output, plc);",
            "-    } else {",
            "-        info(\"Case NOT EXPECTED!\");",
            "-            return make_cip_error(output, (uint8_t)(slice_get_uint8(input, 0) | (uint8_t)CIP_DONE), (uint8_t)CIP_ERR_UNSUPPORTED, false, (uint16_t)0);",
            "+    if(!parse_cip_request(input, &cip_service, &cip_service_path, &cip_service_payload)) {",
            "+        info(\"Unable to parse CIP request!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "+    }",
            "+",
            "+    info(\"CIP Service: %02x\", cip_service);",
            "+    info(\"CIP Path:\");",
            "+    slice_dump(cip_service_path);",
            "+    info(\"CIP Payload:\");",
            "+    slice_dump(cip_service_payload);",
            "+",
            "+    switch(cip_service) {",
            "+        case CIP_SRV_FORWARD_OPEN:",
            "+        case CIP_SRV_FORWARD_OPEN_EX:",
            "+            return handle_forward_open(cip_service, cip_service_path, cip_service_payload, output, plc);",
            "+            break;",
            "+",
            "+        case CIP_SRV_FORWARD_CLOSE:",
            "+            return handle_forward_close(cip_service, cip_service_path, cip_service_payload, output, plc);",
            "+            break;",
            "+",
            "+        case CIP_SRV_READ_NAMED_TAG:",
            "+        case CIP_SRV_READ_NAMED_TAG_FRAG:",
            "+            return handle_read_request(cip_service, cip_service_path, cip_service_payload, output, plc);",
            "+            break;",
            "+",
            "+        case CIP_SRV_WRITE_NAMED_TAG:",
            "+        case CIP_SRV_WRITE_NAMED_TAG_FRAG:",
            "+            return handle_write_request(cip_service, cip_service_path, cip_service_payload, output, plc);",
            "+            break;",
            "+",
            "+        case CIP_SRV_PCCC_EXECUTE: return dispatch_pccc_request(input, output, plc); break;",
            "+",
            "+        default: return make_cip_error(output, cip_service, CIP_ERR_UNSUPPORTED, false, 0); break;",
            "     }",
            " }",
            " ",
            " ",
            " /* a handy structure to hold all the parameters we need to receive in a Forward Open request. */",
            " typedef struct {",
            "-    uint8_t secs_per_tick;                  /* seconds per tick */",
            "-    uint8_t timeout_ticks;                  /* timeout = srd_secs_per_tick * src_timeout_ticks */",
            "-    uint32_t server_conn_id;                /* 0, returned by server in reply. */",
            "-    uint32_t client_conn_id;                /* sent by client. */",
            "-    uint16_t conn_serial_number;            /* client connection ID/serial number */",
            "-    uint16_t orig_vendor_id;                /* client unique vendor ID */",
            "-    uint32_t orig_serial_number;            /* client unique serial number */",
            "-    uint8_t conn_timeout_multiplier;        /* timeout = mult * RPI */",
            "-    uint8_t reserved[3];                    /* reserved, set to 0 */",
            "-    uint32_t client_to_server_rpi;          /* us to target RPI - Request Packet Interval in microseconds */",
            "-    uint32_t client_to_server_conn_params;  /* some sort of identifier of what kind of PLC we are??? */",
            "-    uint32_t server_to_client_rpi;          /* target to us RPI, in microseconds */",
            "-    uint32_t server_to_client_conn_params;       /* some sort of identifier of what kind of PLC the target is ??? */",
            "-    uint8_t transport_class;                /* ALWAYS 0xA3, server transport, class 3, application trigger */",
            "-    slice_s path;                           /* connection path. */",
            "+    uint8_t secs_per_tick;                 /* seconds per tick */",
            "+    uint8_t timeout_ticks;                 /* timeout = srd_secs_per_tick * src_timeout_ticks */",
            "+    uint32_t server_conn_id;               /* 0, returned by server in reply. */",
            "+    uint32_t client_conn_id;               /* sent by client. */",
            "+    uint16_t conn_serial_number;           /* client connection ID/serial number */",
            "+    uint16_t orig_vendor_id;               /* client unique vendor ID */",
            "+    uint32_t orig_serial_number;           /* client unique serial number */",
            "+    uint8_t conn_timeout_multiplier;       /* timeout = mult * RPI */",
            "+    uint8_t reserved[3];                   /* reserved, set to 0 */",
            "+    uint32_t client_to_server_rpi;         /* us to target RPI - Request Packet Interval in microseconds */",
            "+    uint32_t client_to_server_conn_params; /* some sort of identifier of what kind of PLC we are??? */",
            "+    uint32_t server_to_client_rpi;         /* target to us RPI, in microseconds */",
            "+    uint32_t server_to_client_conn_params; /* some sort of identifier of what kind of PLC the target is ??? */",
            "+    uint8_t transport_class;               /* ALWAYS 0xA3, server transport, class 3, application trigger */",
            "+    slice_s path;                          /* connection path. */",
            " } forward_open_s;",
            " ",
            " /* the minimal Forward Open with no path */",
            "-#define CIP_FORWARD_OPEN_MIN_SIZE   (42)",
            "-#define CIP_FORWARD_OPEN_EX_MIN_SIZE   (46)",
            "+#define CIP_FORWARD_OPEN_MIN_SIZE (42)",
            "+#define CIP_FORWARD_OPEN_EX_MIN_SIZE (46)",
            " ",
            " ",
            "-slice_s handle_forward_open(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "-    slice_s conn_path;",
            "+slice_s handle_forward_open(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                            plc_s *plc) {",
            "+    slice_s path_payload = {0};",
            "+    slice_s conn_path_slice = {0};",
            "     size_t offset = 0;",
            "-    uint8_t fo_cmd = slice_get_uint8(input, 0);",
            "     forward_open_s fo_req = {0};",
            " ",
            "-    info(\"Checking Forward Open request:\");",
            "-    slice_dump(input);",
            "+    if(cip_service == CIP_SRV_FORWARD_OPEN) {",
            "+        info(\"Processing Forward Open request.\");",
            "+    } else {",
            "+        info(\"Processing Forward Open Extended request.\");",
            "+    }",
            " ",
            "-    /* minimum length check */",
            "-    if(slice_len(input) < ((fo_cmd == 0x54) ? CIP_FORWARD_OPEN_MIN_SIZE : CIP_FORWARD_OPEN_EX_MIN_SIZE)) {",
            "-        /* FIXME - send back the right error. */",
            "-        info(\"Forward open request size, %d, too small.   Should be greater than %d.  Skipped processing!\", slice_len(input), CIP_FORWARD_OPEN_MIN_SIZE);",
            "-        return make_cip_error(output, (uint8_t)(slice_get_uint8(input, 0) | (uint8_t)CIP_DONE), (uint8_t)CIP_ERR_UNSUPPORTED, false, (uint16_t)0);",
            "+    if(!slice_match_data_exact(cip_service_path, CIP_OBJ_CONNECTION_MANAGER, sizeof(CIP_OBJ_CONNECTION_MANAGER))) {",
            "+        info(\"Forward Open service requested from wrong object!\");",
            "+        slice_dump(cip_service_path);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    } else {",
            "+        info(\"Forward Open service requested of Connection Manager Object instance 1.\");",
            "     }",
            " ",
            "+    /* start parsing */",
            "+    offset = 0;",
            "+",
            "     /* get the data. */",
            "-    offset = sizeof(CIP_FORWARD_OPEN); /* step past the path to the CM */",
            "-    fo_req.secs_per_tick = slice_get_uint8(input, offset); offset++;",
            "-    fo_req.timeout_ticks = slice_get_uint8(input, offset); offset++;",
            "-    fo_req.server_conn_id = slice_get_uint32_le(input, offset); offset += 4;",
            "-    fo_req.client_conn_id = slice_get_uint32_le(input, offset); offset += 4;",
            "-    fo_req.conn_serial_number = slice_get_uint16_le(input, offset); offset += 2;",
            "-    fo_req.orig_vendor_id = slice_get_uint16_le(input, offset); offset += 2;",
            "-    fo_req.orig_serial_number = slice_get_uint32_le(input, offset); offset += 4;",
            "-    fo_req.conn_timeout_multiplier = slice_get_uint8(input, offset); offset += 4; /* byte plus 3-bytes of padding. */",
            "-    fo_req.client_to_server_rpi = slice_get_uint32_le(input, offset); offset += 4;",
            "-    if(fo_cmd == CIP_FORWARD_OPEN[0]) {",
            "+    fo_req.secs_per_tick = slice_get_uint8(cip_service_payload, offset);",
            "+    offset++;",
            "+    fo_req.timeout_ticks = slice_get_uint8(cip_service_payload, offset);",
            "+    offset++;",
            "+    fo_req.server_conn_id = slice_get_uint32_le(cip_service_payload, offset);",
            "+    offset += 4;",
            "+    fo_req.client_conn_id = slice_get_uint32_le(cip_service_payload, offset);",
            "+    offset += 4;",
            "+    fo_req.conn_serial_number = slice_get_uint16_le(cip_service_payload, offset);",
            "+    offset += 2;",
            "+    fo_req.orig_vendor_id = slice_get_uint16_le(cip_service_payload, offset);",
            "+    offset += 2;",
            "+    fo_req.orig_serial_number = slice_get_uint32_le(cip_service_payload, offset);",
            "+    offset += 4;",
            "+    fo_req.conn_timeout_multiplier = slice_get_uint8(cip_service_payload, offset);",
            "+    offset += 4; /* byte plus 3-bytes of padding. */",
            "+    fo_req.client_to_server_rpi = slice_get_uint32_le(cip_service_payload, offset);",
            "+    offset += 4;",
            "+",
            "+    if(cip_service == CIP_SRV_FORWARD_OPEN) {",
            "         /* old command uses 16-bit value. */",
            "-        fo_req.client_to_server_conn_params = slice_get_uint16_le(input, offset); offset += 2;",
            "+        fo_req.client_to_server_conn_params = slice_get_uint16_le(cip_service_payload, offset);",
            "+        offset += 2;",
            "     } else {",
            "         /* new command has 32-bit field here. */",
            "-        fo_req.client_to_server_conn_params = slice_get_uint32_le(input, offset); offset += 4;",
            "+        fo_req.client_to_server_conn_params = slice_get_uint32_le(cip_service_payload, offset);",
            "+        offset += 4;",
            "     }",
            "-    fo_req.server_to_client_rpi = slice_get_uint32_le(input, offset); offset += 4;",
            "-    if(fo_cmd == CIP_FORWARD_OPEN[0]) {",
            "+",
            "+    fo_req.server_to_client_rpi = slice_get_uint32_le(cip_service_payload, offset);",
            "+    offset += 4;",
            "+    if(cip_service == CIP_SRV_FORWARD_OPEN) {",
            "         /* old command uses 16-bit value. */",
            "-        fo_req.server_to_client_conn_params = slice_get_uint16_le(input, offset); offset += 2;",
            "+        fo_req.server_to_client_conn_params = slice_get_uint16_le(cip_service_payload, offset);",
            "+        offset += 2;",
            "     } else {",
            "         /* new command has 32-bit field here. */",
            "-        fo_req.server_to_client_conn_params = slice_get_uint32_le(input, offset); offset += 4;",
            "+        fo_req.server_to_client_conn_params = slice_get_uint32_le(cip_service_payload, offset);",
            "+        offset += 4;",
            "     }",
            "-    fo_req.transport_class = slice_get_uint8(input, offset); offset++;",
            " ",
            "-    /* check the remaining length */",
            "-    if(offset >= slice_len(input)) {",
            "-        /* FIXME - send back the right error. */",
            "-        info(\"Forward open request size, %d, too small.   Should be greater than %d.  Ran out of space processing the packet!\", slice_len(input), offset);",
            "-        return make_cip_error(output, (uint8_t)(slice_get_uint8(input, 0) | CIP_DONE), (uint8_t)CIP_ERR_UNSUPPORTED, false, (uint16_t)0);",
            "+    fo_req.transport_class = slice_get_uint8(cip_service_payload, offset);",
            "+    offset++;",
            "+",
            "+    /* did we run out of bounds? */",
            "+    if(offset > slice_len(cip_service_payload)) {",
            "+        info(\"Not enough Forward Open service data!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INSUFFICIENT_DATA, false, 0);",
            "     }",
            " ",
            "-    /* build the path to match. */",
            "-    conn_path = slice_from_slice(input, offset, slice_len(input));",
            "+    /* Get the connection path */",
            "+    path_payload = slice_from_slice(cip_service_payload, offset, slice_len(cip_service_payload));",
            " ",
            "-    info(\"path slice:\");",
            "-    slice_dump(conn_path);",
            "+    info(\"Forward Open path payload:\");",
            "+    slice_dump(path_payload);",
            "+",
            "+    offset = 0;",
            "+    if(!extract_cip_path(path_payload, &offset, false, &conn_path_slice)) {",
            "+        info(\"Unable to extract the connection path from the Forward Open request!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_PATH_SEGMENT, false, 0);",
            "+    }",
            "+",
            "+    info(\"Connection path slice:\");",
            "+    slice_dump(conn_path_slice);",
            "+",
            "+    if(!slice_match_data_exact(conn_path_slice, &(plc->path[0]), plc->path_len)) {",
            "+        slice_s plc_path = slice_make(&(plc->path[0]), (ssize_t)(size_t)(plc->path_len));",
            " ",
            "-    if(!match_path(conn_path, ((offset & 0x01) ? false : true), &plc->path[0], plc->path_len)) {",
            "-        /* FIXME - send back the right error. */",
            "         info(\"Forward open request path did not match the path for this PLC!\");",
            "-        return make_cip_error(output, (uint8_t)(slice_get_uint8(input, 0) | CIP_DONE), (uint8_t)CIP_ERR_UNSUPPORTED, false, (uint16_t)0);",
            "+        info(\"FO path:\");",
            "+        slice_dump(conn_path_slice);",
            "+        info(\"PLC path:\");",
            "+        slice_dump(plc_path);",
            "+",
            "+        return make_cip_error(output, cip_service, CIP_ERR_PATH_DEST_UNKNOWN, false, 0);",
            "     }",
            " ",
            "     /* check to see how many refusals we should do. */",
            "     if(plc->reject_fo_count > 0) {",
            "         plc->reject_fo_count--;",
            "         info(\"Forward open request being bounced for debugging. %d to go.\", plc->reject_fo_count);",
            "-        return make_cip_error(output,",
            "-                             (uint8_t)(slice_get_uint8(input, 0) | CIP_DONE),",
            "-                             (uint8_t)CIP_ERR_0x01,",
            "-                             true,",
            "-                             (uint16_t)0x100);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_EXT_ERR, true, CIP_ERR_EX_DUPLICATE_CONN);",
            "     }",
            " ",
            "     /* all good if we got here. */",
            "     plc->client_connection_id = fo_req.client_conn_id;",
            "     plc->client_connection_serial_number = fo_req.conn_serial_number;",
            "     plc->client_vendor_id = fo_req.orig_vendor_id;",
            "     plc->client_serial_number = fo_req.orig_serial_number;",
            "     plc->client_to_server_rpi = fo_req.client_to_server_rpi;",
            "     plc->server_to_client_rpi = fo_req.server_to_client_rpi;",
            "-    plc->server_connection_id = (uint32_t)rand();",
            "-    plc->server_connection_seq = (uint16_t)rand();",
            "+    plc->server_connection_id = (uint32_t)(random_u64(UINT32_MAX) + 1);",
            "+    plc->server_connection_seq = (uint16_t)(random_u64(UINT16_MAX) + 1);",
            " ",
            "     /* store the allowed packet sizes. */",
            "-    plc->client_to_server_max_packet = fo_req.client_to_server_conn_params &",
            "-                               ((fo_cmd == CIP_FORWARD_OPEN[0]) ? 0x1FF : 0x0FFF);",
            "-    plc->server_to_client_max_packet = fo_req.server_to_client_conn_params &",
            "-                               ((fo_cmd == CIP_FORWARD_OPEN[0]) ? 0x1FF : 0x0FFF);",
            "+    plc->client_to_server_max_packet =",
            "+        fo_req.client_to_server_conn_params & ((cip_service == CIP_SRV_FORWARD_OPEN) ? 0x1FF : 0x0FFF);",
            "+    plc->server_to_client_max_packet =",
            "+        fo_req.server_to_client_conn_params & ((cip_service == CIP_SRV_FORWARD_OPEN) ? 0x1FF : 0x0FFF);",
            " ",
            "     /* FIXME - check that the packet sizes are valid 508 or 4002 */",
            " ",
            "     /* now process the FO and respond. */",
            "     offset = 0;",
            "-    slice_set_uint8(output, offset, (uint8_t)(slice_get_uint8(input, 0) | CIP_DONE)); offset++;",
            "-    slice_set_uint8(output, offset, 0); offset++; /* padding/reserved. */",
            "-    slice_set_uint8(output, offset, 0); offset++; /* no error. */",
            "-    slice_set_uint8(output, offset, 0); offset++; /* no extra error fields. */",
            "-",
            "-    slice_set_uint32_le(output, offset, plc->server_connection_id); offset += 4;",
            "-    slice_set_uint32_le(output, offset, plc->client_connection_id); offset += 4;",
            "-    slice_set_uint16_le(output, offset, plc->client_connection_serial_number); offset += 2;",
            "-    slice_set_uint16_le(output, offset, plc->client_vendor_id); offset += 2;",
            "-    slice_set_uint32_le(output, offset, plc->client_serial_number); offset += 4;",
            "-    slice_set_uint32_le(output, offset, plc->client_to_server_rpi); offset += 4;",
            "-    slice_set_uint32_le(output, offset, plc->server_to_client_rpi); offset += 4;",
            "+    slice_set_uint8(output, offset, cip_service | CIP_DONE);",
            "+    offset++;",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++; /* padding/reserved. */",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++; /* no error. */",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++; /* no extra error fields. */",
            "+",
            "+    slice_set_uint32_le(output, offset, plc->server_connection_id);",
            "+    offset += 4;",
            "+    slice_set_uint32_le(output, offset, plc->client_connection_id);",
            "+    offset += 4;",
            "+    slice_set_uint16_le(output, offset, plc->client_connection_serial_number);",
            "+    offset += 2;",
            "+    slice_set_uint16_le(output, offset, plc->client_vendor_id);",
            "+    offset += 2;",
            "+    slice_set_uint32_le(output, offset, plc->client_serial_number);",
            "+    offset += 4;",
            "+    slice_set_uint32_le(output, offset, plc->client_to_server_rpi);",
            "+    offset += 4;",
            "+    slice_set_uint32_le(output, offset, plc->server_to_client_rpi);",
            "+    offset += 4;",
            " ",
            "     /* not sure what these do... */",
            "-    slice_set_uint8(output, offset, 0); offset++;",
            "-    slice_set_uint8(output, offset, 0); offset++;",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++;",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++;",
            " ",
            "     return slice_from_slice(output, 0, offset);",
            " }",
            " ",
            " ",
            " /* Forward Close request. */",
            " typedef struct {",
            "-    uint8_t secs_per_tick;          /* seconds per tick */",
            "-    uint8_t timeout_ticks;          /* timeout = srd_secs_per_tick * src_timeout_ticks */",
            "+    uint8_t secs_per_tick;                    /* seconds per tick */",
            "+    uint8_t timeout_ticks;                    /* timeout = srd_secs_per_tick * src_timeout_ticks */",
            "     uint16_t client_connection_serial_number; /* our connection ID/serial number */",
            "-    uint16_t client_vendor_id;      /* our unique vendor ID */",
            "-    uint32_t client_serial_number;  /* our unique serial number */",
            "-    slice_s path;                   /* path to PLC */",
            "+    uint16_t client_vendor_id;                /* our unique vendor ID */",
            "+    uint32_t client_serial_number;            /* our unique serial number */",
            "+    slice_s path;                             /* path to PLC */",
            " } forward_close_s;",
            " ",
            " /* the minimal Forward Open with no path */",
            "-#define CIP_FORWARD_CLOSE_MIN_SIZE   (16)",
            "+#define CIP_FORWARD_CLOSE_MIN_SIZE (16)",
            " ",
            " ",
            "-slice_s handle_forward_close(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "-    slice_s conn_path;",
            "+slice_s handle_forward_close(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                             plc_s *plc) {",
            "+    slice_s conn_path_slice;",
            "     size_t offset = 0;",
            "     forward_close_s fc_req = {0};",
            " ",
            "-    info(\"Checking Forward Close request:\");",
            "-    slice_dump(input);",
            "+    if(!slice_match_data_exact(cip_service_path, CIP_OBJ_CONNECTION_MANAGER, sizeof(CIP_OBJ_CONNECTION_MANAGER))) {",
            "+        info(\"Forward Open service requested from wrong object!\");",
            "+        slice_dump(cip_service_path);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    } else {",
            "+        info(\"Forward Close service requested of Connection Manager Object instance 1.\");",
            "+    }",
            " ",
            "     /* minimum length check */",
            "-    if(slice_len(input) < CIP_FORWARD_CLOSE_MIN_SIZE) {",
            "+    if(slice_len(cip_service_payload) < CIP_FORWARD_CLOSE_MIN_SIZE) {",
            "         /* FIXME - send back the right error. */",
            "-        return make_cip_error(output, (uint8_t)(slice_get_uint8(input, 0) | CIP_DONE), (uint8_t)CIP_ERR_UNSUPPORTED, false, (uint16_t)0);",
            "+        return make_cip_error(output, cip_service, (uint8_t)CIP_ERR_UNSUPPORTED, false, (uint16_t)0);",
            "     }",
            " ",
            "     /* get the data. */",
            "-    offset = sizeof(CIP_FORWARD_CLOSE); /* step past the path to the CM */",
            "-    fc_req.secs_per_tick = slice_get_uint8(input, offset); offset++;",
            "-    fc_req.timeout_ticks = slice_get_uint8(input, offset); offset++;",
            "-    fc_req.client_connection_serial_number = slice_get_uint16_le(input, offset); offset += 2;",
            "-    fc_req.client_vendor_id = slice_get_uint16_le(input, offset); offset += 2;",
            "-    fc_req.client_serial_number = slice_get_uint32_le(input, offset); offset += 4;",
            "+    offset = 0;",
            "+",
            "+    fc_req.secs_per_tick = slice_get_uint8(cip_service_payload, offset);",
            "+    offset++;",
            "+    fc_req.timeout_ticks = slice_get_uint8(cip_service_payload, offset);",
            "+    offset++;",
            "+    fc_req.client_connection_serial_number = slice_get_uint16_le(cip_service_payload, offset);",
            "+    offset += 2;",
            "+    fc_req.client_vendor_id = slice_get_uint16_le(cip_service_payload, offset);",
            "+    offset += 2;",
            "+    fc_req.client_serial_number = slice_get_uint32_le(cip_service_payload, offset);",
            "+    offset += 4;",
            " ",
            "     /* check the remaining length */",
            "-    if(offset >= slice_len(input)) {",
            "+    if(offset >= slice_len(cip_service_payload)) {",
            "         /* FIXME - send back the right error. */",
            "-        info(\"Forward close request size, %d, too small.   Should be greater than %d!\", slice_len(input), offset);",
            "-        return make_cip_error(output, slice_get_uint8(input, 0) | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+        info(\"Forward close request size, %d, too small.   Should be greater than %d!\", slice_len(cip_service_payload), offset);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INSUFFICIENT_DATA, false, 0);",
            "     }",
            " ",
            "     /*",
            "      * why does Rockwell do this?   The path here is _NOT_ a byte-for-byte copy of the path",
            "      * that was used to open the connection.  This one is padded with a zero byte after the path",
            "      * length.",
            "      */",
            " ",
            "-    /* build the path to match. */",
            "-    conn_path = slice_from_slice(input, offset, slice_len(input));",
            "+    if(!extract_cip_path(cip_service_payload, &offset, true, &conn_path_slice)) {",
            "+        info(\"Unable to extract the connection path from the Forward Close request!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_PATH_SEGMENT, false, 0);",
            "+    }",
            " ",
            "-    if(!match_path(conn_path, ((offset & 0x01) ? false : true), plc->path, plc->path_len)) {",
            "-        info(\"path does not match stored path!\");",
            "-        return make_cip_error(output, slice_get_uint8(input, 0) | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    info(\"Connection path slice:\");",
            "+    slice_dump(conn_path_slice);",
            "+",
            "+    if(!slice_match_data_exact(conn_path_slice, &(plc->path[0]), plc->path_len)) {",
            "+        slice_s plc_path = slice_make(&(plc->path[0]), (ssize_t)(size_t)(plc->path_len));",
            "+",
            "+        info(\"Forward Cpen request path did not match the path for this PLC!\");",
            "+        info(\"FC path:\");",
            "+        slice_dump(conn_path_slice);",
            "+        info(\"PLC path:\");",
            "+        slice_dump(plc_path);",
            "+",
            "+        return make_cip_error(output, cip_service, CIP_ERR_PATH_DEST_UNKNOWN, false, 0);",
            "     }",
            " ",
            "     /* Check the values we got. */",
            "     if(plc->client_connection_serial_number != fc_req.client_connection_serial_number) {",
            "         /* FIXME - send back the right error. */",
            "-        info(\"Forward close connection serial number, %x, did not match the connection serial number originally passed, %x!\", fc_req.client_connection_serial_number, plc->client_connection_serial_number);",
            "-        return make_cip_error(output, slice_get_uint8(input, 0) | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+        info(\"Forward close connection serial number, %x, did not match the connection serial number originally passed, %x!\",",
            "+             fc_req.client_connection_serial_number, plc->client_connection_serial_number);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            "     if(plc->client_vendor_id != fc_req.client_vendor_id) {",
            "         /* FIXME - send back the right error. */",
            "-        info(\"Forward close client vendor ID, %x, did not match the client vendor ID originally passed, %x!\", fc_req.client_vendor_id, plc->client_vendor_id);",
            "-        return make_cip_error(output, slice_get_uint8(input, 0) | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+        info(\"Forward Close client vendor ID, %x, did not match the client vendor ID originally passed, %x!\",",
            "+             fc_req.client_vendor_id, plc->client_vendor_id);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            "     if(plc->client_serial_number != fc_req.client_serial_number) {",
            "         /* FIXME - send back the right error. */",
            "-        info(\"Forward close client serial number, %x, did not match the client serial number originally passed, %x!\", fc_req.client_serial_number, plc->client_serial_number);",
            "-        return make_cip_error(output, slice_get_uint8(input, 0) | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+        info(\"Forward close client serial number, %x, did not match the client serial number originally passed, %x!\",",
            "+             fc_req.client_serial_number, plc->client_serial_number);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            " ",
            "     /* now process the FClose and respond. */",
            "     offset = 0;",
            "-    slice_set_uint8(output, offset, slice_get_uint8(input, 0) | CIP_DONE); offset++;",
            "-    slice_set_uint8(output, offset, 0); offset++; /* padding/reserved. */",
            "-    slice_set_uint8(output, offset, 0); offset++; /* no error. */",
            "-    slice_set_uint8(output, offset, 0); offset++; /* no extra error fields. */",
            "-",
            "-    slice_set_uint16_le(output, offset, plc->client_connection_serial_number); offset += 2;",
            "-    slice_set_uint16_le(output, offset, plc->client_vendor_id); offset += 2;",
            "-    slice_set_uint32_le(output, offset, plc->client_serial_number); offset += 4;",
            "+    slice_set_uint8(output, offset, cip_service | CIP_DONE);",
            "+    offset++;",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++; /* padding/reserved. */",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++; /* no error. */",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++; /* no extra error fields. */",
            "+",
            "+    slice_set_uint16_le(output, offset, plc->client_connection_serial_number);",
            "+    offset += 2;",
            "+    slice_set_uint16_le(output, offset, plc->client_vendor_id);",
            "+    offset += 2;",
            "+    slice_set_uint32_le(output, offset, plc->client_serial_number);",
            "+    offset += 4;",
            " ",
            "     /* not sure what these do... */",
            "-    slice_set_uint8(output, offset, 0); offset++;",
            "-    slice_set_uint8(output, offset, 0); offset++;",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++;",
            "+    slice_set_uint8(output, offset, 0);",
            "+    offset++;",
            " ",
            "     return slice_from_slice(output, 0, offset);",
            " }",
            " ",
            " ",
            "-/*",
            "- * A read request comes in with a symbolic segment first, then zero to three numeric segments.",
            "- */",
            "-",
            "-#define CIP_READ_MIN_SIZE (6)",
            "-#define CIP_READ_FRAG_MIN_SIZE (10)",
            "-",
            "-slice_s handle_read_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "-    uint8_t read_cmd = slice_get_uint8(input, 0);  /*get the type. */",
            "-    uint8_t tag_segment_size = 0;",
            "-    uint16_t element_count = 0;",
            "-    uint32_t byte_offset = 0;",
            "-    size_t read_start_offset = 0;",
            "-    size_t offset = 0;",
            "+slice_s handle_read_request(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                            plc_s *plc) {",
            "+    size_t required_request_payload_size = 0;",
            "     tag_def_s *tag = NULL;",
            "-    size_t tag_data_length = 0;",
            "-    size_t total_request_size = 0;",
            "-    size_t remaining_size = 0;",
            "-    size_t packet_capacity = 0;",
            "-    bool need_frag = false;",
            "-    size_t amount_to_copy = 0;",
            "-",
            "-    /* Omron does not support fragmented read. */",
            "-    if(plc->plc_type == PLC_OMRON && read_cmd == CIP_READ_FRAG[0]) {",
            "-        info(\"Omron PLCs do not support fragmented read!\");",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    uint32_t num_indexes = CIP_TAG_MAX_INDEXES;",
            "+    uint32_t indexes[CIP_TAG_MAX_INDEXES] = {0};",
            "+    size_t parse_offset = 0;",
            "+    uint16_t request_element_count = 0;",
            "+    size_t request_fragment_start_byte_offset = 0;",
            "+    size_t request_start_byte_offset = 0;",
            "+    size_t request_end_byte_offset = 0;",
            "+    size_t min_data_element_size = 0;",
            "+    slice_s cip_response_header_slice = {0};",
            "+    slice_s cip_response_type_info_slice = {0};",
            "+    slice_s cip_response_payload_slice = {0};",
            "+    size_t copy_size = 0;",
            "+    uint8_t cip_err = CIP_OK;",
            "+    bool needs_fragmentation = false;",
            "+",
            "+    /* what service are we handling? */",
            "+    if(cip_service == CIP_SRV_READ_NAMED_TAG) {",
            "+        info(\"Processing Read Named Tag request.\");",
            "+        required_request_payload_size = CIP_READ_PAYLOAD_MIN_SIZE;",
            "+    } else {",
            "+        info(\"Processing Read Named Tag Fragmented request.\");",
            "+        required_request_payload_size = CIP_READ_FRAG_PAYLOAD_MIN_SIZE;",
            "     }",
            " ",
            "-    if(slice_len(input) < (read_cmd == CIP_READ[0] ? CIP_READ_MIN_SIZE : CIP_READ_FRAG_MIN_SIZE)) {",
            "-        info(\"Insufficient data in the CIP read request!\");",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* OMRON only supports un-fragmented reads. */",
            "+    if(plc->plc_type == PLC_OMRON && cip_service != CIP_SRV_READ_NAMED_TAG) {",
            "+        info(\"Omron PLCs do not support fragmented read CIP service!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_UNSUPPORTED, false, 0);",
            "     }",
            " ",
            "-    offset = 1;",
            "-    tag_segment_size = slice_get_uint8(input, offset); offset++;",
            "-",
            "-    /* check that we have enough space. */",
            "-    if((slice_len(input) + (read_cmd == CIP_READ[0] ? 2 : 6) - 2) < (tag_segment_size * 2)) {",
            "-        info(\"Request does not have enough space for element count and byte offset!\");",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* check the payload size */",
            "+    if(slice_len(cip_service_payload) < required_request_payload_size) {",
            "+        info(\"Insufficient data in the CIP read request payload!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INSUFFICIENT_DATA, false, 0);",
            "     }",
            " ",
            "-    if(!process_tag_segment(plc, slice_from_slice(input, offset, (size_t)(tag_segment_size * 2)), &tag, &read_start_offset)) {",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* try to get the tag and indexes from the tag path. */",
            "+    if(!parse_tag_path(cip_service_path, plc, &tag, &num_indexes, &(indexes[0]))) {",
            "+        info(\"Unable to parse tag path:\");",
            "+        slice_dump(cip_service_path);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            " ",
            "-    /* step past the tag segment. */",
            "-    offset += (size_t)(tag_segment_size * 2);",
            "-",
            "-    element_count = slice_get_uint16_le(input, offset); offset += 2;",
            "+    /* get the element count and the optional request byte offset. */",
            "+    parse_offset = 0;",
            "+    request_element_count = slice_get_uint16_le(cip_service_payload, parse_offset);",
            "+    parse_offset += 2;",
            " ",
            "-    if(plc->plc_type == PLC_OMRON) {",
            "-        if(element_count != 1) {",
            "-            info(\"Omron PLC requires element count to be 1, found %d!\", element_count);",
            "-            return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "-        } else {",
            "-            /* all good, now fake it with an element count that is the full tag. */",
            "-            element_count = (uint16_t)tag->elem_count;",
            "-        }",
            "+    /* optionally get the request byte offset */",
            "+    if(cip_service == CIP_SRV_READ_NAMED_TAG_FRAG) {",
            "+        request_fragment_start_byte_offset = slice_get_uint32_le(cip_service_payload, parse_offset);",
            "+        parse_offset += 4;",
            "     }",
            " ",
            "-    if(read_cmd == CIP_READ_FRAG[0]) {",
            "-        byte_offset = slice_get_uint32_le(input, offset); offset += 4;",
            "+    if(parse_offset != slice_len(cip_service_payload)) {",
            "+        info(\"Extra data in the CIP read request payload!\");",
            "+        slice_dump(cip_service_payload);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_TOO_MUCH_DATA, false, 0);",
            "     }",
            " ",
            "-    /* double check the size of the request. */",
            "-    if(offset != slice_len(input)) {",
            "-        info(\"Request size does not match CIP request size!\");",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* get the starting offset of the request, checks against tag size. */",
            "+    if(!calculate_request_start_and_end_offsets(tag, num_indexes, indexes, request_element_count, &request_start_byte_offset,",
            "+                                                &request_end_byte_offset)) {",
            "+        info(\"Unable to calculate the starting offset of the read request!\");",
            "+        // FIXME - need other error.",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            " ",
            "-    /* check the offset bounds. */",
            "-    tag_data_length = (size_t)(tag->elem_count * tag->elem_size);",
            "-",
            "-    info(\"tag_data_length = %d\", tag_data_length);",
            "+    /* bump the start offset by the amount we may have already read. */",
            "+    request_start_byte_offset += request_fragment_start_byte_offset;",
            " ",
            "-    /* get the amount requested. */",
            "-    total_request_size = (size_t)(element_count * tag->elem_size);",
            "-",
            "-    info(\"total_request_size = %d\", total_request_size);",
            "-",
            "-    /* check the amount */",
            "-    if(read_start_offset + total_request_size > tag_data_length) {",
            "-        info(\"request asks for too much data!\");",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_EXTENDED, true, CIP_ERR_EX_TOO_LONG);",
            "+    /* check the byte offsets */",
            "+    if(request_start_byte_offset > request_end_byte_offset) {",
            "+        info(\"Invalid byte offsets in the read request!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            " ",
            "-    /* check to make sure that the offset passed is within the bounds. */",
            "-    if(read_start_offset + byte_offset > tag_data_length) {",
            "-        info(\"request offset is past the end of the tag!\");",
            "-        return make_cip_error(output, read_cmd | CIP_DONE, CIP_ERR_EXTENDED, true, CIP_ERR_EX_TOO_LONG);",
            "+    /* what is the minimum amount of data we can send back without breaking an atomic base type? */",
            "+    // FIXME - does this actually work?",
            "+    if(tag->elem_size > CIP_MIN_ATOMIC_ELEMENT_SIZE) {",
            "+        min_data_element_size = CIP_MIN_ATOMIC_ELEMENT_SIZE;",
            "+    } else {",
            "+        min_data_element_size = tag->elem_size;",
            "     }",
            " ",
            "-    /* do we need to fragment the result? */",
            "-    remaining_size = total_request_size - byte_offset;",
            "-    packet_capacity = slice_len(output) - 6; /* MAGIC - CIP header plus data type bytes is 6 bytes. */",
            "+    /* check the payload space.  */",
            "+    if(slice_len(output) < (CIP_RESPONSE_HEADER_SIZE + CIP_RESPONSE_TYPE_INFO_SIZE + min_data_element_size)) {",
            "+        info(\"Insufficient space in the output buffer for the response!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_FRAG, false, 0);",
            "+    }",
            " ",
            "-    info(\"packet_capacity = %d\", packet_capacity);",
            "+    /* peel off space for the header and type info and payload. */",
            "+    cip_response_header_slice = slice_from_slice(output, 0, CIP_RESPONSE_HEADER_SIZE);",
            "+    cip_response_type_info_slice = slice_from_slice(output, CIP_RESPONSE_HEADER_SIZE, CIP_RESPONSE_TYPE_INFO_SIZE);",
            "+    cip_response_payload_slice = slice_from_slice(output, CIP_RESPONSE_HEADER_SIZE + CIP_RESPONSE_TYPE_INFO_SIZE,",
            "+                                                  slice_len(output) - (CIP_RESPONSE_HEADER_SIZE + CIP_RESPONSE_TYPE_INFO_SIZE));",
            " ",
            "-    if(remaining_size > packet_capacity) {",
            "-        need_frag = true;",
            "-    } else {",
            "-        need_frag = false;",
            "+    /* make sure we have enough space for at least one element. */",
            "+    if(slice_len(cip_response_payload_slice) < min_data_element_size) {",
            "+        info(\"Insufficient space in the output buffer for the response payload!\");",
            "+        // FIXME - need other error.",
            "+        return make_cip_error(output, cip_service, CIP_ERR_EXTENDED, true, CIP_ERR_EX_TOO_LONG);",
            "     }",
            " ",
            "-    info(\"need_frag = %s\", need_frag ? \"true\" : \"false\");",
            "+    /* we have payload space so how much can we copy? */",
            "+    copy_size = slice_len(cip_response_payload_slice);",
            " ",
            "-    /* start making the response. */",
            "-    offset = 0;",
            "-    slice_set_uint8(output, offset, read_cmd | CIP_DONE); offset++;",
            "-    slice_set_uint8(output, offset, 0); offset++; /* padding/reserved. */",
            "-    slice_set_uint8(output, offset, (need_frag ? CIP_ERR_FRAG : CIP_OK)); offset++; /* no error. */",
            "-    slice_set_uint8(output, offset, 0); offset++; /* no extra error fields. */",
            "-",
            "-    /* copy the data type. */",
            "-    slice_set_uint16_le(output, offset, tag->tag_type); offset += 2;",
            "+    /* find the largest multiple of the min_data_element_size count that fits. */",
            "+    copy_size = (copy_size / min_data_element_size) * min_data_element_size;",
            " ",
            "-    /* how much data to copy? */",
            "-    amount_to_copy = (remaining_size < packet_capacity ? remaining_size : packet_capacity);",
            "-    if(amount_to_copy > 8) {",
            "-        /* align to 8-byte chunks */",
            "-        amount_to_copy &= 0xFFFFC;",
            "+    /* make sure we don't copy too much. */",
            "+    if(copy_size > request_end_byte_offset - request_start_byte_offset) {",
            "+        copy_size = request_end_byte_offset - request_start_byte_offset;",
            "     }",
            " ",
            "-    info(\"amount_to_copy = %d\", amount_to_copy);",
            "-    info(\"copy start location = %d\", offset);",
            "-    info(\"output space = %d\", slice_len(output) - offset);",
            "-",
            "-    /* FIXME - use memcpy */",
            "-    for(size_t i=0; i < amount_to_copy; i++) {",
            "-        slice_set_uint8(output, offset + i, tag->data[byte_offset + i]);",
            "+    /* copy the data into the response payload. */",
            "+    critical_block(tag->data_mutex) {",
            "+        if(!slice_copy_data_in(cip_response_payload_slice, tag->data + request_start_byte_offset, copy_size)) {",
            "+            info(\"Unable to copy the data into the response payload!\");",
            "+            // FIXME - need other error.",
            "+            cip_err = CIP_ERR_INVALID_PARAM;",
            "+            break;",
            "+        }",
            "     }",
            " ",
            "-    offset += amount_to_copy;",
            "+    if(cip_err != CIP_OK) { return make_cip_error(output, cip_service, cip_err, false, 0); }",
            " ",
            "-    return slice_from_slice(output, 0, offset);",
            "+    /* did we fragment? */",
            "+    if(request_start_byte_offset + copy_size < request_end_byte_offset) {",
            "+        info(\"Need to fragment read request.\");",
            "+        needs_fragmentation = true;",
            "+    }",
            "+",
            "+    /* fill in the CIP response header. */",
            "+    slice_set_uint8(cip_response_header_slice, 0, cip_service | CIP_DONE);",
            "+    slice_set_uint8(cip_response_header_slice, 1, 0);                                             /* reserved */",
            "+    slice_set_uint8(cip_response_header_slice, 2, (needs_fragmentation ? CIP_ERR_FRAG : CIP_OK)); /* status */",
            "+    slice_set_uint8(cip_response_header_slice, 3, 0);                                             /* no extended error */",
            "+",
            "+    /* fill in the tag data type */",
            "+    slice_set_uint16_le(cip_response_type_info_slice, 0, tag->tag_type);",
            "+",
            "+    /* return the slice used */",
            "+    return slice_from_slice(output, 0,",
            "+                            slice_len(cip_response_header_slice) + slice_len(cip_response_type_info_slice) + copy_size);",
            " }",
            " ",
            " ",
            "-",
            "-",
            " #define CIP_WRITE_MIN_SIZE (6)",
            " #define CIP_WRITE_FRAG_MIN_SIZE (10)",
            " ",
            "-slice_s handle_write_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "-    uint8_t write_cmd = slice_get_uint8(input, 0);  /*get the type. */",
            "-    uint8_t tag_segment_size = 0;",
            "-    uint32_t byte_offset = 0;",
            "-    size_t write_start_offset = 0;",
            "-    size_t offset = 0;",
            "-    tag_def_s *tag = NULL;",
            "-    size_t tag_data_length = 0;",
            "-    size_t total_request_size = 0;",
            "-    bool need_frag = false;",
            "-    uint16_t write_data_type = 0;",
            "-    uint16_t write_element_count = 0;",
            " ",
            "-    if(slice_len(input) < (write_cmd == CIP_WRITE[0] ? CIP_WRITE_MIN_SIZE : CIP_WRITE_FRAG_MIN_SIZE)) {",
            "-        info(\"Insufficient data in the CIP write request!\");",
            "-        return make_cip_error(output, write_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+slice_s handle_write_request(uint8_t cip_service, slice_s cip_service_path, slice_s cip_service_payload, slice_s output,",
            "+                             plc_s *plc) {",
            "+    size_t required_request_payload_size = 0;",
            "+    tag_def_s *tag = NULL;",
            "+    uint32_t num_indexes = CIP_TAG_MAX_INDEXES;",
            "+    uint32_t indexes[CIP_TAG_MAX_INDEXES] = {0};",
            "+    size_t parse_offset = 0;",
            "+    uint16_t request_element_type = 0;",
            "+    uint16_t request_element_count = 0;",
            "+    size_t request_fragment_start_byte_offset = 0;",
            "+    size_t request_start_byte_offset = 0;",
            "+    size_t request_end_byte_offset = 0;",
            "+    uint8_t cip_err = CIP_OK;",
            "+    slice_s write_request_payload_slice = {0};",
            "+    slice_s cip_response_header_slice = {0};",
            "+",
            "+    /* what service are we handling? */",
            "+    if(cip_service == CIP_SRV_WRITE_NAMED_TAG) {",
            "+        info(\"Processing Write Named Tag request.\");",
            "+        required_request_payload_size = CIP_WRITE_PAYLOAD_MIN_SIZE;",
            "+    } else {",
            "+        info(\"Processing Write Named Tag Fragmented request.\");",
            "+        required_request_payload_size = CIP_WRITE_FRAG_PAYLOAD_MIN_SIZE;",
            "     }",
            " ",
            "-    offset = 1;",
            "-    tag_segment_size = slice_get_uint8(input, offset); offset++;",
            "-",
            "-    /* check that we have enough space. */",
            "-    if((slice_len(input) + (write_cmd == CIP_WRITE[0] ? 2 : 6) - 2) < (tag_segment_size * 2)) {",
            "-        info(\"Request does not have enough space for element count and byte offset!\");",
            "-        return make_cip_error(output, write_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* OMRON only supports un-fragmented reads. */",
            "+    if(plc->plc_type == PLC_OMRON && cip_service != CIP_SRV_WRITE_NAMED_TAG) {",
            "+        info(\"Omron PLCs do not support fragmented write CIP service!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_UNSUPPORTED, false, 0);",
            "     }",
            " ",
            "-    if(!process_tag_segment(plc, slice_from_slice(input, offset, (size_t)(tag_segment_size * 2)), &tag, &write_start_offset)) {",
            "-        return make_cip_error(output, write_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* we need the tag to do more calculations and checks */",
            "+    if(!parse_tag_path(cip_service_path, plc, &tag, &num_indexes, &(indexes[0]))) {",
            "+        info(\"Unable to parse tag path:\");",
            "+        slice_dump(cip_service_path);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            " ",
            "-    /* step past the tag segment. */",
            "-    offset += (size_t)(tag_segment_size * 2);",
            "-",
            "-    /* get the tag data type and compare. */",
            "-    write_data_type = slice_get_uint16_le(input, offset); offset += 2;",
            "+    /* are the number of indexes correct? */",
            "+    if(num_indexes > 0 && num_indexes != tag->num_dimensions) {",
            "+        info(\"Wrong number of indexes passed.   Must be zero or %zu indexes.\", tag->num_dimensions);",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "+    }",
            " ",
            "-    /* check that the data types match. */",
            "-    if(tag->tag_type != write_data_type) {",
            "-        info(\"tag data type %02x does not match the data type in the write request %02x\", tag->tag_type, write_data_type);",
            "-        return make_cip_error(output, write_cmd | CIP_DONE, CIP_ERR_UNSUPPORTED, false, 0);",
            "+    /* check the payload size */",
            "+    if(slice_len(cip_service_payload) < required_request_payload_size) {",
            "+        info(\"Insufficient data in the CIP read request payload!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INSUFFICIENT_DATA, false, 0);",
            "     }",
            " ",
            "-    /* get the number of elements to write. */",
            "-    write_element_count = slice_get_uint16_le(input, offset); offset += 2;",
            "+    request_element_type = slice_get_uint16_le(cip_service_payload, parse_offset);",
            "+    parse_offset += 2;",
            " ",
            "-    /* check the number of elements */",
            "-    if(write_element_count > tag->elem_count) {",
            "-        info(\"request tries to write too many elements!\");",
            "-        return make_cip_error(output, write_cmd | CIP_DONE, CIP_ERR_EXTENDED, true, CIP_ERR_EX_TOO_LONG);",
            "+    if(request_element_type != tag->tag_type) {",
            "+        info(\"Request element type does not match tag type!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "     }",
            " ",
            "-    if(write_cmd == CIP_WRITE_FRAG[0]) {",
            "-        byte_offset = slice_get_uint32_le(input, offset); offset += 4;",
            "+    /* get the element count and the optional request byte offset. */",
            "+    request_element_count = slice_get_uint16_le(cip_service_payload, parse_offset);",
            "+    parse_offset += 2;",
            "+",
            "+    /* optionally get the request byte offset for this fragment */",
            "+    if(cip_service == CIP_SRV_WRITE_NAMED_TAG_FRAG) {",
            "+        request_fragment_start_byte_offset = (size_t)slice_get_uint32_le(cip_service_payload, parse_offset);",
            "+        parse_offset += 4;",
            "     }",
            " ",
            "-    info(\"byte_offset = %d\", byte_offset);",
            "+    /* get a slice for our payload data to write */",
            "+    write_request_payload_slice =",
            "+        slice_from_slice(cip_service_payload, parse_offset, slice_len(cip_service_payload) - parse_offset);",
            " ",
            "-    /* check the offset bounds. */",
            "-    tag_data_length = (size_t)(tag->elem_count * tag->elem_size);",
            "+    /* TODO - check the amount of data to write and make sure it does not partially write a primitive/atomic value. */",
            " ",
            "-    info(\"tag_data_length = %d\", tag_data_length);",
            "+    /* get the starting offset of the request, and checks tag size. */",
            "+    if(!calculate_request_start_and_end_offsets(tag, num_indexes, indexes, request_element_count, &request_start_byte_offset,",
            "+                                                &request_end_byte_offset)) {",
            "+        info(\"Unable to calculate the starting or ending offset of the write request!\");",
            "+        // FIXME - need other error.",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "+    }",
            " ",
            "-    /* get the write amount requested. */",
            "-    total_request_size = slice_len(input) - offset;",
            "+    /* what is the actual starting byte offset for this specific request which might be a fragment. */",
            "+    request_start_byte_offset += request_fragment_start_byte_offset;",
            " ",
            "-    info(\"total_request_size = %d\", total_request_size);",
            "+    /* Make sure we are not trying to write too much. */",
            "+    if((slice_len(write_request_payload_slice) + request_start_byte_offset) > request_end_byte_offset) {",
            "+        info(\"Too much data in the write request!\");",
            "+        return make_cip_error(output, cip_service, CIP_ERR_INVALID_PARAM, false, 0);",
            "+    }",
            " ",
            "-    /* check the amount */",
            "-    if(byte_offset + total_request_size > tag_data_length) {",
            "-        info(\"request tries to write too much data!\");",
            "-        return make_cip_error(output, write_cmd | CIP_DONE, CIP_ERR_EXTENDED, true, CIP_ERR_EX_TOO_LONG);",
            "+    critical_block(tag->data_mutex) {",
            "+        if(!slice_copy_data_out(tag->data + request_start_byte_offset, request_end_byte_offset - request_start_byte_offset,",
            "+                                write_request_payload_slice)) {",
            "+            info(\"Unable to copy the data into the tag!\");",
            "+            cip_err = CIP_ERR_INVALID_PARAM;",
            "+            break;",
            "+        }",
            "     }",
            " ",
            "-    /* copy the data. */",
            "-    info(\"byte_offset = %d\", byte_offset);",
            "-    info(\"offset = %d\", offset);",
            "-    info(\"total_request_size = %d\", total_request_size);",
            "-    memcpy(&tag->data[byte_offset], slice_get_bytes(input, offset), total_request_size);",
            "+    if(cip_err != CIP_OK) { return make_cip_error(output, cip_service, cip_err, false, 0); }",
            " ",
            "-    /* start making the response. */",
            "-    offset = 0;",
            "-    slice_set_uint8(output, offset, write_cmd | CIP_DONE); offset++;",
            "-    slice_set_uint8(output, offset, 0); offset++; /* padding/reserved. */",
            "-    slice_set_uint8(output, offset, (need_frag ? CIP_ERR_FRAG : CIP_OK)); offset++; /* no error. */",
            "-    slice_set_uint8(output, offset, 0); offset++; /* no extra error fields. */",
            "+    /* peel off space for the header */",
            "+    cip_response_header_slice = slice_from_slice(output, 0, CIP_RESPONSE_HEADER_SIZE);",
            " ",
            "-    return slice_from_slice(output, 0, offset);",
            "+    /* fill in the CIP response header. */",
            "+    slice_set_uint8(cip_response_header_slice, 0, cip_service | CIP_DONE);",
            "+    slice_set_uint8(cip_response_header_slice, 1, 0);      /* reserved */",
            "+    slice_set_uint8(cip_response_header_slice, 2, CIP_OK); /* status */",
            "+    slice_set_uint8(cip_response_header_slice, 3, 0);      /* no extended error */",
            "+",
            "+    /* peel off space for the header */",
            "+    cip_response_header_slice = slice_from_slice(output, 0, CIP_RESPONSE_HEADER_SIZE);",
            "+",
            "+    /* fill in the CIP response header. */",
            "+    slice_set_uint8(cip_response_header_slice, 0, cip_service | CIP_DONE);",
            "+    slice_set_uint8(cip_response_header_slice, 1, 0); /* reserved */",
            "+    slice_set_uint8(cip_response_header_slice, 2, CIP_OK); /* status */",
            "+    slice_set_uint8(cip_response_header_slice, 3, 0); /* no extended error */",
            "+",
            "+    /* return the remaining output space */",
            "+    return cip_response_header_slice;",
            " }",
            " ",
            " ",
            "+slice_s make_cip_error(slice_s output, uint8_t cip_cmd, uint8_t cip_err, bool extend, uint16_t extended_error) {",
            "+    size_t result_size = 0;",
            " ",
            "+    slice_set_uint8(output, 0, cip_cmd | CIP_DONE);",
            "+    slice_set_uint8(output, 1, 0); /* reserved, must be zero. */",
            "+    slice_set_uint8(output, 2, cip_err);",
            "+",
            "+    if(extend) {",
            "+        slice_set_uint8(output, 3, 2); /* two bytes of extended status. */",
            "+        slice_set_uint16_le(output, 4, extended_error);",
            "+        result_size = 6;",
            "+    } else {",
            "+        slice_set_uint8(output, 3, 0); /* no additional bytes of sub-error. */",
            "+        result_size = 4;",
            "+    }",
            "+",
            "+    return slice_from_slice(output, 0, result_size);",
            "+}",
            " ",
            " ",
            "-/*",
            "- * we should see:",
            "- *  0x91 <name len> <name bytes> (<numeric segment>){0-3}",
            "- *",
            "- * find the tag name, then check the numeric segments, if any, against the",
            "- * tag dimensions.",
            "- */",
            "+#define CIP_MIN_TAG_PATH_SIZE 2",
            " ",
            "-bool process_tag_segment(plc_s *plc, slice_s input, tag_def_s **tag, size_t *start_read_offset)",
            "-{",
            "+bool parse_tag_path(slice_s tag_path, plc_s *plc, tag_def_s **tag, uint32_t *num_indexes, uint32_t *indexes) {",
            "     size_t offset = 0;",
            "-    uint8_t symbolic_marker = slice_get_uint8(input, offset); offset++;",
            "     uint8_t name_len = 0;",
            "-    slice_s tag_name;",
            "-    size_t dimensions[3] = { 0, 0, 0};",
            "-    size_t dimension_index = 0;",
            "+    uint8_t segment_marker = 0;",
            "+    slice_s tag_name_slice = {0};",
            "+    uint32_t max_indexes = *num_indexes; /* contains the max possible */",
            "+",
            "+    /* Check if the tag path is long enough to contain the segment marker and name length */",
            "+    if(slice_len(tag_path) < CIP_MIN_TAG_PATH_SIZE) {",
            "+        info(\"Tag path is too short to contain segment marker and name length!\");",
            "+        return false;",
            "+    }",
            " ",
            "-    if(symbolic_marker != CIP_SYMBOLIC_SEGMENT_MARKER)  {",
            "-        info(\"Expected symbolic segment but found %x!\", symbolic_marker);",
            "+    /* Get the segment marker */",
            "+    segment_marker = slice_get_uint8(tag_path, offset);",
            "+    offset++;",
            "+    if(segment_marker != CIP_SYMBOLIC_SEGMENT_MARKER) {",
            "+        info(\"Expected symbolic segment marker but found %x!\", segment_marker);",
            "         return false;",
            "     }",
            " ",
            "-    /* get and check the length of the symbolic name part. */",
            "-    name_len = slice_get_uint8(input, offset); offset++;",
            "-    if(name_len >= slice_len(input)) {",
            "-        info(\"Insufficient space in symbolic segment for name.   Needed %d bytes but only had %d bytes!\", name_len, slice_len(input)-1);",
            "+    /* Get the name length */",
            "+    name_len = slice_get_uint8(tag_path, offset);",
            "+    offset++;",
            "+    if(name_len + offset > slice_len(tag_path)) {",
            "+        info(\"Name length %d exceeds remaining tag path length %d!\", name_len, slice_len(tag_path) - offset);",
            "         return false;",
            "     }",
            " ",
            "-    /* bump the offset.   Must be 16-bit aligned, so pad if needed. */",
            "-    offset += (size_t)(name_len + ((name_len & 0x01) ? 1 : 0));",
            "+    /* Extract the tag name slice */",
            "+    tag_name_slice = slice_from_slice(tag_path, offset, name_len);",
            "+    offset += name_len;",
            " ",
            "-    /* try to find the tag. */",
            "-    tag_name = slice_from_slice(input, 2, name_len);",
            "+    /* Align to 16-bit boundary if necessary */",
            "+    if(offset % 2 != 0) { offset++; }",
            "+",
            "+    /* find the tag */",
            "     *tag = plc->tags;",
            " ",
            "     while(*tag) {",
            "-        if(slice_match_string(tag_name, (*tag)->name)) {",
            "+        if(slice_match_string_exact(tag_name_slice, (*tag)->name)) {",
            "             info(\"Found tag %s\", (*tag)->name);",
            "             break;",
            "         }",
            " ",
            "         (*tag) = (*tag)->next_tag;",
            "     }",
            " ",
            "-    if(*tag) {",
            "-        slice_s numeric_segments = slice_from_slice(input, offset, slice_len(input));",
            "-",
            "-        dimension_index = 0;",
            "+    if(!*tag) {",
            "+        info(\"Tag %.*s not found!\", slice_len(tag_name_slice), (const char *)(tag_name_slice.data));",
            "+        return false;",
            "+    }",
            " ",
            "-        info(\"Numeric segment(s):\");",
            "-        slice_dump(numeric_segments);",
            "+    /* Initialize the number of indexes to zero */",
            "+    *num_indexes = 0;",
            " ",
            "-        while(slice_len(numeric_segments) > 0) {",
            "-            uint8_t segment_type = slice_get_uint8(numeric_segments, 0);",
            "+    /* Parse the numeric segments (indexes) */",
            "+    while(offset < slice_len(tag_path)) {",
            "+        uint8_t segment_type = slice_get_uint8(tag_path, offset);",
            "+",
            "+        switch(segment_type) {",
            "+            case 0x28:        // Single byte value",
            "+                offset += 1;  // skip segment type",
            "+                indexes[*num_indexes] = (uint32_t)slice_get_uint8(tag_path, offset);",
            "+                info(\"Numeric segment: %u\", indexes[*num_indexes]);",
            "+                offset += 1;",
            "+                break;",
            "+",
            "+            case 0x29:        // Two byte value",
            "+                offset += 2;  // skip segment type and padding",
            "+                indexes[*num_indexes] = (uint32_t)slice_get_uint16_le(tag_path, offset);",
            "+                info(\"Numeric segment: %u\", indexes[*num_indexes]);",
            "+                offset += 2;",
            "+                break;",
            "+",
            "+            case 0x2A:        // Four byte value",
            "+                offset += 2;  // skip segment type and padding",
            "+                indexes[*num_indexes] = (uint32_t)slice_get_uint32_le(tag_path, offset);",
            "+                info(\"Numeric segment: %u\", indexes[*num_indexes]);",
            "+                offset += 4;",
            "+                break;",
            " ",
            "-            if(dimension_index >= 3) {",
            "-                info(\"More numeric segments than expected!   Remaining request:\");",
            "-                slice_dump(numeric_segments);",
            "+            default:",
            "+                info(\"Unexpected numeric segment marker %x at position %zu!\", segment_type, offset);",
            "                 return false;",
            "-            }",
            "+                break;",
            "+        }",
            " ",
            "-            switch(segment_type) {",
            "-                case 0x28: /* single byte value. */",
            "-                    dimensions[dimension_index] = (size_t)slice_get_uint8(numeric_segments, 1);",
            "-                    dimension_index++;",
            "-                    numeric_segments = slice_from_slice(numeric_segments, 2, slice_len(numeric_segments));",
            "-                    break;",
            "-",
            "-                case 0x29: /* two byte value */",
            "-                    dimensions[dimension_index] = (size_t)slice_get_uint16_le(numeric_segments, 2);",
            "-                    dimension_index++;",
            "-                    numeric_segments = slice_from_slice(numeric_segments, 4, slice_len(numeric_segments));",
            "-                    break;",
            "-",
            "-                case 0x2A: /* four byte value */",
            "-                    dimensions[dimension_index] = (size_t)slice_get_uint32_le(numeric_segments, 2);",
            "-                    dimension_index++;",
            "-                    numeric_segments = slice_from_slice(numeric_segments, 6, slice_len(numeric_segments));",
            "-                    break;",
            "-",
            "-                default:",
            "-                    info(\"Unexpected numeric segment marker %x!\", segment_type);",
            "-                    return false;",
            "-                    break;",
            "-            }",
            "+        (*num_indexes)++;",
            "+",
            "+        if(*num_indexes > max_indexes) {",
            "+            info(\"More numeric segments, %zu, than expected, %zu!\", *num_indexes, max_indexes);",
            "+            return false;",
            "         }",
            "+    }",
            " ",
            "-        /* calculate the element offset. */",
            "-        if(dimension_index > 0) {",
            "-            size_t element_offset = 0;",
            "+    /* the only valid number of indexes is zero or the number of dimensions in the tag. */",
            "+    if(*num_indexes != 0 && *num_indexes != (*tag)->num_dimensions) {",
            "+        info(\"Required zero or %zu numeric segments, but only found %zu!\", (*tag)->num_dimensions, (size_t)*num_indexes);",
            "+        return false;",
            "+    }",
            " ",
            "-            if(dimension_index != (*tag)->num_dimensions) {",
            "-                info(\"Required %d numeric segments, but only found %d!\", (*tag)->num_dimensions, dimension_index);",
            "-                return false;",
            "-            }",
            "+    return true;",
            "+}",
            " ",
            "-            /* check in bounds. */",
            "-            for(size_t i=0; i < dimension_index; i++) {",
            "-                if(dimensions[i] >= (*tag)->dimensions[i]) {",
            "-                    info(\"Dimension %d is out of bounds, must be 0 <= %d < %d\", (int)i, dimensions[i], (*tag)->dimensions[i]);",
            "-                    return false;",
            "-                }",
            "-            }",
            "-",
            "-            /* calculate the offset. */",
            "-            element_offset = (size_t)(dimensions[0] * ((*tag)->dimensions[1] * (*tag)->dimensions[2]) +",
            "-                                      dimensions[1] *  (*tag)->dimensions[2] +",
            "-                                      dimensions[2]);",
            "-",
            "-            *start_read_offset = (size_t)((*tag)->elem_size * element_offset);",
            "-        } else {",
            "-            *start_read_offset = 0;",
            "-        }",
            "-    } else {",
            "-        info(\"Tag %.*s not found!\", slice_len(tag_name), (const char *)(tag_name.data));",
            "+",
            "+bool extract_cip_path(slice_s input, size_t *offset, bool padded, slice_s *output) {",
            "+    uint8_t path_len = 0;",
            "+",
            "+    /* Check if the input slice is long enough to contain the path length and path */",
            "+    if(slice_len(input) < ((*offset) + (padded ? 2 : 1))) {",
            "+        info(\"CIP path is too short to contain path length and path!\");",
            "+        return false;",
            "+    }",
            "+",
            "+    /* Get the path length */",
            "+    path_len = slice_get_uint8(input, (*offset));",
            "+    (*offset)++;",
            "+    if(path_len == 0) {",
            "+        info(\"CIP path length is zero!\");",
            "+        return false;",
            "+    }",
            "+",
            "+    if(padded) { *offset += 1; /* skip the padding byte */ }",
            "+",
            "+    /* Check if the input slice is long enough to contain the path */",
            "+    if(slice_len(input) < ((*offset) + (path_len * 2))) {",
            "+        info(\"CIP path is too short to contain the specified path length %u!\", path_len * 2);",
            "         return false;",
            "     }",
            " ",
            "+    /* return the slice with the path data. */",
            "+    *output = slice_from_slice(input, *offset, path_len * 2);",
            " ",
            "+    /* update the offset to past the path. */",
            "+    *offset += path_len * 2;",
            " ",
            "     return true;",
            " }",
            " ",
            "-/* match a path.   This is tricky, thanks, Rockwell. */",
            "-bool match_path(slice_s input, bool need_pad, uint8_t *path, uint8_t path_len)",
            "-{",
            "-    size_t input_len = slice_len(input);",
            "-    size_t input_path_len = 0;",
            "-    size_t path_start = 0;",
            " ",
            "-    info(\"Starting with request path:\");",
            "-    slice_dump(input);",
            "-    info(\"and stored path:\");",
            "-    slice_dump(slice_make(path, (ssize_t)path_len));",
            "+/* we assume that the number of indexes matches that of the tag or is zero */",
            " ",
            "-    if(input_len < path_len) {",
            "-        info(\"path does not match lengths.   Input length %zu, path length %zu.\", input_len, path_len);",
            "-        return false;",
            "+bool calculate_request_start_and_end_offsets(tag_def_s *tag, uint32_t num_indexes, uint32_t *indexes,",
            "+                                             uint16_t request_element_count, size_t *request_start_byte_offset,",
            "+                                             size_t *request_end_byte_offset) {",
            "+    size_t total_elements = 1;",
            "+    size_t tag_size = 0;",
            "+    size_t element_offset = 0;",
            "+",
            "+    /* Calculate the total number of elements in the tag */",
            "+    total_elements = 1;",
            "+    for(uint32_t i = 0; i < tag->num_dimensions; i++) { total_elements *= tag->dimensions[i]; }",
            "+",
            "+    tag_size = total_elements * tag->elem_size;",
            "+",
            "+    /* check index bounds */",
            "+    for(size_t index = 0; index < num_indexes; index++) {",
            "+        if(indexes[index] >= tag->dimensions[index]) {",
            "+            info(\"Index %zu out of bounds for dimension %zu.\", (size_t)indexes[index], index);",
            "+            return false;",
            "+        }",
            "     }",
            " ",
            "-    /* the first byte of the path input is the length byte in 16-bit words */",
            "-    input_path_len = (size_t)slice_get_uint8(input, 0);",
            "+    /* calculate the linear element offset */",
            "+    switch(num_indexes) {",
            "+        case 0: element_offset = 0; break;",
            " ",
            "-    /* check it against the passed path length */",
            "-    if((input_path_len * 2) != path_len) {",
            "-        info(\"path is wrong length.   Got %zu but expected %zu!\", input_path_len*2, path_len);",
            "+        case 1: element_offset = indexes[0]; break;",
            "+",
            "+        case 2: element_offset = (indexes[0] * tag->dimensions[1]) + indexes[1]; break;",
            "+",
            "+        case 3:",
            "+            element_offset =",
            "+                (indexes[0] * tag->dimensions[1] * tag->dimensions[2]) + (indexes[1] * tag->dimensions[2]) + indexes[2];",
            "+            break;",
            "+",
            "+        default:",
            "+            info(\"Too many indexes!\");",
            "+            return false;",
            "+            break;",
            "+    }",
            "+",
            "+    /* probably not needed, but just in case */",
            "+    if(element_offset >= total_elements) {",
            "+        info(\"Element offset %d exceeds total elements %d!\", element_offset, total_elements);",
            "         return false;",
            "     }",
            " ",
            "-    /* where does the path start? */",
            "-    if(need_pad) {",
            "-        path_start = 2;",
            "-    } else {",
            "-        path_start = 1;",
            "+    /*",
            "+     * Calculate the start and end byte offsets.",
            "+     * Note that these are absolute for the whole request.",
            "+     * Not for the fragment if there is one.",
            "+     */",
            "+    *request_start_byte_offset = element_offset * tag->elem_size;",
            "+    *request_end_byte_offset = *request_start_byte_offset + (request_element_count * tag->elem_size);",
            "+",
            "+    info(\"Request start byte offset: %d\", *request_start_byte_offset);",
            "+    info(\"Request end byte offset: %d\", *request_end_byte_offset);",
            "+",
            "+    /* Check if the start offset exceeds the total size of the tag */",
            "+    if(*request_start_byte_offset > tag_size) {",
            "+        info(\"Request start byte offset %d exceeds total tag size %zu\", (size_t)*request_start_byte_offset, tag_size);",
            "+        return false;",
            "     }",
            " ",
            "-    info(\"Comparing slice:\");",
            "-    slice_dump(slice_from_slice(input, path_start, slice_len(input)));",
            "-    info(\"with slice:\");",
            "-    slice_dump(slice_make(path, (ssize_t)path_len));",
            "+    /* Check if the end offset exceeds the total size of the tag */",
            "+    if(*request_end_byte_offset > tag_size) {",
            "+        info(\"Request end byte offset %d exceeds total tag size %zu\", (size_t)*request_end_byte_offset, tag_size);",
            "+        return false;",
            "+    }",
            " ",
            "-    return slice_match_bytes(slice_from_slice(input, path_start, slice_len(input)), path, path_len);",
            "+    return true;",
            " }",
            " ",
            "+#define CIP_MIN_REQUEST_SIZE \\",
            "+    4 /*  1 byte for service, 1 byte for service path length in word, 2 bytes for minimal service path. */",
            " ",
            "+bool parse_cip_request(slice_s input, uint8_t *cip_service, slice_s *cip_service_path, slice_s *cip_service_payload) {",
            "+    size_t offset = 0;",
            " ",
            "-slice_s make_cip_error(slice_s output, uint8_t cip_cmd, uint8_t cip_err, bool extend, uint16_t extended_error)",
            "-{",
            "-    size_t result_size = 0;",
            "-",
            "-    slice_set_uint8(output, 0, cip_cmd | CIP_DONE);",
            "-    slice_set_uint8(output, 1, 0); /* reserved, must be zero. */",
            "-    slice_set_uint8(output, 2, cip_err);",
            "+    /* Check if the input slice is long enough to contain the service code and path size */",
            "+    if(slice_len(input) < CIP_MIN_REQUEST_SIZE) {",
            "+        info(\"CIP request is too short to contain service code and path size!\");",
            "+        return false;",
            "+    }",
            " ",
            "-    if(extend) {",
            "-        slice_set_uint8(output, 3, 2); /* two bytes of extended status. */",
            "-        slice_set_uint16_le(output, 4, extended_error);",
            "-        result_size = 6;",
            "-    } else {",
            "-        slice_set_uint8(output, 3, 0); /* no additional bytes of sub-error. */",
            "-        result_size = 4;",
            "+    /* Get the service code */",
            "+    *cip_service = slice_get_uint8(input, offset);",
            "+    offset++;",
            "+",
            "+    /* extract the service path slice */",
            "+    if(!extract_cip_path(input, &offset, false, cip_service_path)) {",
            "+        info(\"Unable to extract CIP service path!\");",
            "+        return false;",
            "     }",
            " ",
            "-    return slice_from_slice(output, 0, result_size);",
            "+    /* Extract the service payload slice */",
            "+    *cip_service_payload = slice_from_slice(input, offset, slice_len(input) - offset);",
            "+",
            "+    return true;",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/cip.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/cip.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/cip.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/compat.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/compat.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/compat.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -33,25 +33,36 @@",
            " ",
            " #pragma once",
            " ",
            " /*",
            "  * This file contains various compatibility includes and definitions",
            "  * to allow compilation across POSIX and Windows systems.",
            "  */",
            "-",
            "-#if defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64)",
            "+#if defined(APPLE) || defined (__APPLE__) || defined(DARWIN) || defined(__DARWIN__)",
            "+    #define IS_MACOS (1)",
            "+    #define IS_POSIX (1)",
            "+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)",
            "+    #define IS_BSD (1)",
            "+    #define IS_POSIX (1)",
            "+#elif defined(__linux__)",
            "+    #define IS_LINUX (1)",
            "+    #define IS_POSIX (1)",
            "+#elif defined(__unix__)",
            "+    #define IS_POSIX (1) ",
            "+#elif defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64) || defined(__MINGW32__) || defined(__MINGW64__)",
            "     #define IS_WINDOWS (1)",
            "-#endif",
            " ",
            "-#if defined(_MSC_VER)",
            "-    #define IS_MSVC (1)",
            "+    #if defined(_MSC_VER)",
            "+        #define IS_MSVC (1)",
            "+    #endif",
            "+",
            " #endif",
            " ",
            " ",
            "-#ifdef IS_MSVC",
            "+#ifdef IS_WINDOWS",
            "     #define str_cmp_i(first, second) _stricmp(first, second)",
            "     #define strdup _strdup",
            "     #define str_scanf sscanf_s",
            " #else",
            "     #define str_cmp_i(first, second) strcasecmp(first, second)",
            "     #define str_scanf sscanf",
            " #endif",
            "@@ -59,8 +70,7 @@",
            " /* Define ssize_t */",
            " #ifdef IS_MSVC",
            "     #include <BaseTsd.h>",
            "     typedef SSIZE_T ssize_t;",
            " #else",
            "     #include <sys/types.h>",
            " #endif",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/cpf.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/cpf.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/cpf.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,56 +27,54 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include <stdint.h>",
            "-#include \"cip.h\"",
            " #include \"cpf.h\"",
            "+#include \"cip.h\"",
            " #include \"eip.h\"",
            " #include \"utils.h\"",
            "+#include <stdint.h>",
            " ",
            " #define CPF_ITEM_NAI ((uint16_t)0x0000) /* NULL Address Item */",
            " #define CPF_ITEM_CAI ((uint16_t)0x00A1) /* connected address item */",
            " #define CPF_ITEM_CDI ((uint16_t)0x00B1) /* connected data item */",
            " #define CPF_ITEM_UDI ((uint16_t)0x00B2) /* Unconnected data item */",
            " ",
            " ",
            " typedef struct {",
            "     uint32_t interface_handle;",
            "     uint16_t router_timeout;",
            "-    uint16_t item_count;        /* should be 2 for now. */",
            "+    uint16_t item_count; /* should be 2 for now. */",
            "     uint16_t item_addr_type;",
            "     uint16_t item_addr_length;",
            "     uint16_t item_data_type;",
            "     uint16_t item_data_length;",
            " } cpf_uc_header_s;",
            " ",
            " #define CPF_UCONN_HEADER_SIZE (16)",
            " ",
            " typedef struct {",
            "     uint32_t interface_handle;",
            "     uint16_t router_timeout;",
            "-    uint16_t item_count;        /* should be 2 for now. */",
            "+    uint16_t item_count; /* should be 2 for now. */",
            "     uint16_t item_addr_type;",
            "     uint16_t item_addr_length;",
            "     uint32_t conn_id;",
            "     uint16_t item_data_type;",
            "     uint16_t item_data_length;",
            "     uint16_t conn_seq;",
            " } cpf_co_header_s;",
            " ",
            " #define CPF_CONN_HEADER_SIZE (22)",
            " ",
            " ",
            "-",
            "-slice_s handle_cpf_unconnected(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s handle_cpf_unconnected(slice_s input, slice_s output, plc_s *plc) {",
            "     slice_s result;",
            "     cpf_uc_header_s header;",
            " ",
            "     info(\"handle_cpf_unconnected(): got packet:\");",
            "     slice_dump(input);",
            " ",
            "     /* we must have some sort of payload. */",
            "@@ -114,47 +112,46 @@",
            " ",
            "     if(header.item_data_type != CPF_ITEM_UDI) {",
            "         info(\"Expected unconnected data item but found %x!\", header.item_data_type);",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     if(header.item_data_length != (slice_len(input) - CPF_UCONN_HEADER_SIZE)) {",
            "-        info(\"CPF unconnected payload length, %d, does not match passed length, %d!\", (slice_len(input) - CPF_UCONN_HEADER_SIZE - 2), header.item_data_length);",
            "+        info(\"CPF unconnected payload length, %d, does not match passed length, %d!\",",
            "+             (slice_len(input) - CPF_UCONN_HEADER_SIZE - 2), header.item_data_length);",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     /* dispatch and handle the result. */",
            "-    result = cip_dispatch_request(slice_from_slice(input, (size_t)CPF_UCONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(input) - CPF_UCONN_HEADER_SIZE)),",
            "-                                slice_from_slice(output, (size_t)CPF_UCONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(output) - CPF_UCONN_HEADER_SIZE)),",
            "-                                plc);",
            "+    result = cip_dispatch_request(",
            "+        slice_from_slice(input, (size_t)CPF_UCONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(input) - CPF_UCONN_HEADER_SIZE)),",
            "+        slice_from_slice(output, (size_t)CPF_UCONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(output) - CPF_UCONN_HEADER_SIZE)),",
            "+        plc);",
            " ",
            "     if(!slice_has_err(result)) {",
            "         /* build outbound header. */",
            "         slice_set_uint32_le(output, 0, header.interface_handle);",
            "         slice_set_uint16_le(output, 4, header.router_timeout);",
            "-        slice_set_uint16_le(output, 6, 2); /* two items. */",
            "-        slice_set_uint16_le(output, 8, CPF_ITEM_NAI); /* connected address type. */",
            "-        slice_set_uint16_le(output, 10, 0); /* No connection ID. */",
            "-        slice_set_uint16_le(output, 12, CPF_ITEM_UDI); /* connected data type */",
            "+        slice_set_uint16_le(output, 6, 2);                            /* two items. */",
            "+        slice_set_uint16_le(output, 8, CPF_ITEM_NAI);                 /* connected address type. */",
            "+        slice_set_uint16_le(output, 10, 0);                           /* No connection ID. */",
            "+        slice_set_uint16_le(output, 12, CPF_ITEM_UDI);                /* connected data type */",
            "         slice_set_uint16_le(output, 14, (uint16_t)slice_len(result)); /* result from CIP processing downstream. */",
            " ",
            "         /* create a new slice with the CPF header and the response packet in it. */",
            "         result = slice_from_slice(output, (size_t)0, (size_t)(slice_len(result) + (ssize_t)CPF_UCONN_HEADER_SIZE));",
            "     }",
            " ",
            "     /* errors are pass through. */",
            " ",
            "     return result;",
            "-",
            " }",
            " ",
            " ",
            "-",
            "-slice_s handle_cpf_connected(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s handle_cpf_connected(slice_s input, slice_s output, plc_s *plc) {",
            "     slice_s result;",
            "     cpf_co_header_s header;",
            " ",
            "     /* we must have some sort of payload. */",
            "     if(slice_len(input) <= CPF_UCONN_HEADER_SIZE) {",
            "         info(\"Unusable size of connected CPF packet!\");",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "@@ -196,38 +193,41 @@",
            " ",
            "     if(header.item_data_type != CPF_ITEM_CDI) {",
            "         info(\"Expected connected data item but found %x!\", header.item_data_type);",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     if(header.item_data_length != (slice_len(input) - (CPF_CONN_HEADER_SIZE - 2))) {",
            "-        info(\"CPF payload length, %d, does not match passed length, %d!\", (slice_len(input) - (CPF_CONN_HEADER_SIZE - 2)), header.item_data_length);",
            "+        info(\"CPF payload length, %d, does not match passed length, %d!\", (slice_len(input) - (CPF_CONN_HEADER_SIZE - 2)),",
            "+             header.item_data_length);",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     /* do we care about the sequence ID?   Should check. */",
            "     plc->server_connection_seq = header.conn_seq;",
            " ",
            "     /* dispatch and handle the result. */",
            "-    result = cip_dispatch_request(slice_from_slice(input,  (size_t)CPF_CONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(input) - CPF_CONN_HEADER_SIZE)),",
            "-                                  slice_from_slice(output, (size_t)CPF_CONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(output) - CPF_CONN_HEADER_SIZE)),",
            "-                                  plc);",
            "+    result = cip_dispatch_request(",
            "+        slice_from_slice(input, (size_t)CPF_CONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(input) - CPF_CONN_HEADER_SIZE)),",
            "+        slice_from_slice(output, (size_t)CPF_CONN_HEADER_SIZE, (size_t)((uint16_t)slice_len(output) - CPF_CONN_HEADER_SIZE)),",
            "+        plc);",
            " ",
            "     if(!slice_has_err(result)) {",
            "         /* build outbound header. */",
            "-        slice_set_uint16_le(output, 0, 2); /* two items. */",
            "+        slice_set_uint16_le(output, 0, 2);            /* two items. */",
            "         slice_set_uint16_le(output, 2, CPF_ITEM_CAI); /* connected address type. */",
            "-        slice_set_uint16_le(output, 4, 4); /* connection ID is 4 bytes. */",
            "+        slice_set_uint16_le(output, 4, 4);            /* connection ID is 4 bytes. */",
            "         slice_set_uint32_le(output, 6, plc->client_connection_id);",
            "         slice_set_uint16_le(output, 10, CPF_ITEM_CDI); /* connected data type */",
            "-        slice_set_uint16_le(output, 12, (uint16_t)(slice_len(result) + 2)); /* result from CIP processing downstream.  Plus 2 bytes for sequence number. */",
            "+        slice_set_uint16_le(",
            "+            output, 12,",
            "+            (uint16_t)(slice_len(result) + 2)); /* result from CIP processing downstream.  Plus 2 bytes for sequence number. */",
            "         slice_set_uint16_le(output, 14, plc->client_connection_seq);",
            " ",
            "         /* create a new slice with the CPF header and the response packet in it. */",
            "         result = slice_from_slice(output, (size_t)0, (size_t)(slice_len(result) + CPF_CONN_HEADER_SIZE));",
            "     }",
            " ",
            "     /* errors are pass through. */",
            " ",
            "     return result;",
            " }",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/cpf.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/cpf.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/cpf.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/eip.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/eip.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/eip.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,31 +27,30 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include <stdlib.h>",
            "-#include \"cpf.h\"",
            " #include \"eip.h\"",
            "+#include \"cpf.h\"",
            " #include \"slice.h\"",
            " #include \"tcp_server.h\"",
            " #include \"utils.h\"",
            "+#include <stdlib.h>",
            " ",
            "-#define EIP_REGISTER_SESSION     ((uint16_t)0x0065)",
            "-   #define EIP_REGISTER_SESSION_SIZE (4) /* 4 bytes, 2 16-bit words */",
            "+#define EIP_REGISTER_SESSION ((uint16_t)0x0065)",
            "+#define EIP_REGISTER_SESSION_SIZE (4) /* 4 bytes, 2 16-bit words */",
            " ",
            "-#define EIP_UNREGISTER_SESSION   ((uint16_t)0x0066)",
            "-#define EIP_UNCONNECTED_SEND     ((uint16_t)0x006F)",
            "-#define EIP_CONNECTED_SEND       ((uint16_t)0x0070)",
            "+#define EIP_UNREGISTER_SESSION ((uint16_t)0x0066)",
            "+#define EIP_UNCONNECTED_SEND ((uint16_t)0x006F)",
            "+#define EIP_CONNECTED_SEND ((uint16_t)0x0070)",
            " ",
            " /* supported EIP version */",
            "-#define EIP_VERSION     ((uint16_t)1)",
            "-",
            "+#define EIP_VERSION ((uint16_t)1)",
            " ",
            " ",
            " typedef struct {",
            "     uint16_t command;",
            "     uint16_t length;",
            "     uint32_t session_handle;",
            "     uint32_t status;",
            "@@ -60,16 +59,15 @@",
            " } eip_header_s;",
            " ",
            " ",
            " static slice_s register_session(slice_s input, slice_s output, plc_s *plc, eip_header_s *header);",
            " static slice_s unregister_session(slice_s input, slice_s output, plc_s *plc, eip_header_s *header);",
            " ",
            " ",
            "-slice_s eip_dispatch_request(slice_s input, slice_s raw_output, plc_s *plc)",
            "-{",
            "+slice_s eip_dispatch_request(slice_s input, slice_s raw_output, plc_s *plc) {",
            "     slice_s output = slice_from_slice(raw_output, 0, plc->server_to_client_max_packet);",
            "     slice_s response = slice_from_slice(output, EIP_HEADER_SIZE, slice_len(output) - EIP_HEADER_SIZE);",
            " ",
            "     eip_header_s header;",
            " ",
            "     info(\"eip_dispatch_request(): got packet:\");",
            "     slice_dump(input);",
            "@@ -87,36 +85,35 @@",
            "         info(\"Illegal EIP packet.   Length should be %d but is %d!\", header.length + EIP_HEADER_SIZE, slice_len(input));",
            "         return slice_make_err(TCP_SERVER_BAD_REQUEST);",
            "     }",
            " ",
            "     /* dispatch the request */",
            "     switch(header.command) {",
            "         case EIP_REGISTER_SESSION:",
            "-            response = register_session(slice_from_slice(input, EIP_HEADER_SIZE, EIP_REGISTER_SESSION_SIZE), response, plc, &header);",
            "+            response =",
            "+                register_session(slice_from_slice(input, EIP_HEADER_SIZE, EIP_REGISTER_SESSION_SIZE), response, plc, &header);",
            "             break;",
            " ",
            "         case EIP_UNREGISTER_SESSION:",
            "-            response = unregister_session(slice_from_slice(input, EIP_HEADER_SIZE, EIP_REGISTER_SESSION_SIZE), response, plc, &header);",
            "+            response =",
            "+                unregister_session(slice_from_slice(input, EIP_HEADER_SIZE, EIP_REGISTER_SESSION_SIZE), response, plc, &header);",
            "             break;",
            " ",
            "         case EIP_UNCONNECTED_SEND:",
            "-            response = handle_cpf_unconnected(slice_from_slice(input, EIP_HEADER_SIZE, slice_len(input) - EIP_HEADER_SIZE),",
            "-                                              slice_from_slice(output, EIP_HEADER_SIZE, slice_len(output) - EIP_HEADER_SIZE),",
            "-                                              plc);",
            "+            response =",
            "+                handle_cpf_unconnected(slice_from_slice(input, EIP_HEADER_SIZE, slice_len(input) - EIP_HEADER_SIZE),",
            "+                                       slice_from_slice(output, EIP_HEADER_SIZE, slice_len(output) - EIP_HEADER_SIZE), plc);",
            "             break;",
            " ",
            "         case EIP_CONNECTED_SEND:",
            "             response = handle_cpf_connected(slice_from_slice(input, EIP_HEADER_SIZE, slice_len(input) - EIP_HEADER_SIZE),",
            "-                                            slice_from_slice(output, EIP_HEADER_SIZE, slice_len(output) - EIP_HEADER_SIZE),",
            "-                                            plc);",
            "+                                            slice_from_slice(output, EIP_HEADER_SIZE, slice_len(output) - EIP_HEADER_SIZE), plc);",
            "             break;",
            " ",
            "-        default:",
            "-            response = slice_make_err(TCP_SERVER_UNSUPPORTED);",
            "-            break;",
            "+        default: response = slice_make_err(TCP_SERVER_UNSUPPORTED); break;",
            "     }",
            " ",
            "     if(!slice_has_err(response)) {",
            "         /* build response */",
            "         slice_set_uint16_le(output, 0, header.command);",
            "         slice_set_uint16_le(output, 2, (uint16_t)slice_len(response));",
            "         slice_set_uint32_le(output, 4, plc->session_handle);",
            "@@ -130,27 +127,26 @@",
            "         /* just pass this through, normally not an error. */",
            "         info(\"Done with connection.\");",
            " ",
            "         return response;",
            "     } else {",
            "         /* error condition. */",
            "         slice_set_uint16_le(output, 0, header.command);",
            "-        slice_set_uint16_le(output, 2, (uint16_t)0);  /* no payload. */",
            "+        slice_set_uint16_le(output, 2, (uint16_t)0); /* no payload. */",
            "         slice_set_uint32_le(output, 4, plc->session_handle);",
            "         slice_set_uint32_le(output, 8, (uint32_t)(int32_t)slice_get_err(response)); /* status */",
            "         slice_set_uin64_le(output, 12, plc->sender_context);",
            "         slice_set_uint32_le(output, 20, header.options);",
            " ",
            "         return slice_from_slice(output, 0, EIP_HEADER_SIZE);",
            "     }",
            " }",
            " ",
            " ",
            "-slice_s register_session(slice_s input, slice_s output, plc_s *plc, eip_header_s *header)",
            "-{",
            "+slice_s register_session(slice_s input, slice_s output, plc_s *plc, eip_header_s *header) {",
            "     struct {",
            "         uint16_t eip_version;",
            "         uint16_t option_flags;",
            "     } register_request;",
            " ",
            "     register_request.eip_version = slice_get_uint16_le(input, 0);",
            "     register_request.option_flags = slice_get_uint16_le(input, 2);",
            "@@ -183,44 +179,42 @@",
            "         info(\"Request failed sanity check: request options is %u but should be zero.\", header->options);",
            " ",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     /* EIP version must be 1. */",
            "     if(register_request.eip_version != EIP_VERSION) {",
            "-        info(\"Request failed sanity check: request EIP version is %u but should be %u.\", register_request.eip_version, EIP_VERSION);",
            "+        info(\"Request failed sanity check: request EIP version is %u but should be %u.\", register_request.eip_version,",
            "+             EIP_VERSION);",
            " ",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     /* Session request option flags must be zero. */",
            "     if(register_request.option_flags != (uint16_t)0) {",
            "-        info(\"Request failed sanity check: request option flags field is %u but should be zero.\",register_request.option_flags);",
            "+        info(\"Request failed sanity check: request option flags field is %u but should be zero.\", register_request.option_flags);",
            " ",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " ",
            "     /* all good, generate a session handle. */",
            "-    plc->session_handle = header->session_handle = (uint32_t)rand();",
            "+    plc->session_handle = header->session_handle = (uint32_t)(random_u64(UINT32_MAX) + 1);",
            " ",
            "     /* build the response. */",
            "     slice_set_uint16_le(output, 0, register_request.eip_version);",
            "     slice_set_uint16_le(output, 2, register_request.option_flags);",
            " ",
            "     return slice_from_slice(output, 0, EIP_REGISTER_SESSION_SIZE);",
            " }",
            " ",
            " ",
            "-slice_s unregister_session(slice_s input, slice_s output, plc_s *plc, eip_header_s *header)",
            "-{",
            "+slice_s unregister_session(slice_s input, slice_s output, plc_s *plc, eip_header_s *header) {",
            "     (void)input;",
            "     (void)output;",
            "     (void)header;",
            " ",
            "     if(header->session_handle == plc->session_handle) {",
            "         return slice_make_err(TCP_SERVER_DONE);",
            "     } else {",
            "         return slice_make_err(EIP_ERR_BAD_REQUEST);",
            "     }",
            " }",
            "-",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/eip.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/eip.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/eip.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/main.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/main.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/main.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -30,33 +30,35 @@",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " #include \"compat.h\"",
            " ",
            " #include <stdbool.h>",
            "-#include <stdio.h>",
            " #include <stdint.h>",
            "+#include <stdio.h>",
            " #include <stdlib.h>",
            " #include <string.h>",
            " #include <time.h>",
            " ",
            " #if defined(IS_WINDOWS)",
            "-#include <Windows.h>",
            "+#    include <Windows.h>",
            " #else",
            "- /* assume it is POSIX of some sort... */",
            "-#include <signal.h>",
            "-#include <strings.h>",
            "+/* assume it is POSIX of some sort... */",
            "+#    include <signal.h>",
            "+#    include <strings.h>",
            " #endif",
            " ",
            " #include \"eip.h\"",
            "+#include \"mutex.h\"",
            " #include \"plc.h\"",
            " #include \"slice.h\"",
            " #include \"tcp_server.h\"",
            " #include \"utils.h\"",
            "+#include \"mutex.h\"",
            " ",
            " static void usage(void);",
            " static void process_args(int argc, const char **argv, plc_s *plc);",
            " static void parse_path(const char *path, plc_s *plc);",
            " static void parse_pccc_tag(const char *tag, plc_s *plc);",
            " static void parse_cip_tag(const char *tag, plc_s *plc);",
            " static slice_s request_handler(slice_s input, slice_s output, void *plc);",
            "@@ -65,121 +67,112 @@",
            " #ifdef IS_WINDOWS",
            " ",
            " typedef volatile int sig_flag_t;",
            " ",
            " sig_flag_t done = 0;",
            " ",
            " /* straight from MS' web site :-) */",
            "-int WINAPI CtrlHandler(DWORD fdwCtrlType)",
            "-{",
            "-    switch (fdwCtrlType)",
            "-    {",
            "-        // Handle the CTRL-C signal.",
            "-    case CTRL_C_EVENT:",
            "-        info(\"^C event\");",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-        // CTRL-CLOSE: confirm that the user wants to exit.",
            "-    case CTRL_CLOSE_EVENT:",
            "-        info(\"Close event\");",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-        // Pass other signals to the next handler.",
            "-    case CTRL_BREAK_EVENT:",
            "-        info(\"^Break event\");",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-    case CTRL_LOGOFF_EVENT:",
            "-        info(\"Logoff event\");",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-    case CTRL_SHUTDOWN_EVENT:",
            "-        info(\"Shutdown event\");",
            "-        done = 1;",
            "-        return TRUE;",
            "-",
            "-    default:",
            "-        info(\"Default Event: %d\", fdwCtrlType);",
            "-        return FALSE;",
            "+int WINAPI CtrlHandler(DWORD fdwCtrlType) {",
            "+    switch(fdwCtrlType) {",
            "+            // Handle the CTRL-C signal.",
            "+        case CTRL_C_EVENT:",
            "+            info(\"^C event\");",
            "+            done = 1;",
            "+            return TRUE;",
            "+",
            "+            // CTRL-CLOSE: confirm that the user wants to exit.",
            "+        case CTRL_CLOSE_EVENT:",
            "+            info(\"Close event\");",
            "+            done = 1;",
            "+            return TRUE;",
            "+",
            "+            // Pass other signals to the next handler.",
            "+        case CTRL_BREAK_EVENT:",
            "+            info(\"^Break event\");",
            "+            done = 1;",
            "+            return TRUE;",
            "+",
            "+        case CTRL_LOGOFF_EVENT:",
            "+            info(\"Logoff event\");",
            "+            done = 1;",
            "+            return TRUE;",
            "+",
            "+        case CTRL_SHUTDOWN_EVENT:",
            "+            info(\"Shutdown event\");",
            "+            done = 1;",
            "+            return TRUE;",
            "+",
            "+        default: info(\"Default Event: %d\", fdwCtrlType); return FALSE;",
            "     }",
            " }",
            " ",
            " ",
            "-void setup_break_handler(void)",
            "-{",
            "-    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))",
            "-    {",
            "+void setup_break_handler(void) {",
            "+    if(!SetConsoleCtrlHandler(CtrlHandler, TRUE)) {",
            "         printf(\"\\nERROR: Could not set control handler!\\n\");",
            "         usage();",
            "     }",
            " }",
            " ",
            " #else",
            " ",
            " typedef volatile sig_atomic_t sig_flag_t;",
            " ",
            " sig_flag_t done = 0;",
            " ",
            "-void SIGINT_handler(int not_used)",
            "-{",
            "+void SIGINT_handler(int not_used) {",
            "     (void)not_used;",
            " ",
            "     done = 1;",
            " }",
            " ",
            "-void setup_break_handler(void)",
            "-{",
            "+void setup_break_handler(void) {",
            "     struct sigaction act;",
            " ",
            "     /* set up signal handler. */",
            "+    // NOLINTNEXTLINE",
            "     memset(&act, 0, sizeof(act));",
            "     act.sa_handler = SIGINT_handler;",
            "     sigaction(SIGINT, &act, NULL);",
            " }",
            " ",
            " #endif",
            " ",
            " ",
            "-int main(int argc, const char **argv)",
            "-{",
            "+int main(int argc, const char **argv) {",
            "     tcp_server_p server = NULL;",
            "-    uint8_t buf[4200];  /* CIP only allows 4002 for the CIP request, but there is overhead. */",
            "-    slice_s server_buf = slice_make(buf, sizeof(buf));",
            "     plc_s plc;",
            " ",
            "     /* set up handler for ^C etc. */",
            "     setup_break_handler();",
            " ",
            "     debug_off();",
            " ",
            "     /* clear out context to make sure we do not get gremlins */",
            "+    // NOLINTNEXTLINE",
            "     memset(&plc, 0, sizeof(plc));",
            " ",
            "     /* set the random seed. */",
            "     srand((unsigned int)time(NULL));",
            " ",
            "     process_args(argc, argv, &plc);",
            " ",
            "     /* open a server connection and listen on the right port. */",
            "-    server = tcp_server_create(\"0.0.0.0\", (plc.port_str ? plc.port_str : \"44818\"), server_buf, request_handler, &plc);",
            "+    server = tcp_server_create(\"0.0.0.0\", (plc.port_str ? plc.port_str : \"44818\"), request_handler, &plc, sizeof(plc));",
            " ",
            "     tcp_server_start(server, &done);",
            " ",
            "     tcp_server_destroy(server);",
            " ",
            "     return 0;",
            " }",
            " ",
            " ",
            "-void usage(void)",
            "-{",
            "+void usage(void) {",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"Usage: ab_server --plc=<plc_type> [--path=<path>] [--port=<port>] --tag=<tag>\\n\"",
            "                     \"   <plc type> = one of the CIP PLCs: \\\"ControlLogix\\\", \\\"Micro800\\\" or \\\"Omron\\\",\\n\"",
            "                     \"                or one of the PCCC PLCs: \\\"PLC/5\\\", \\\"SLC500\\\" or \\\"Micrologix\\\".\\n\"",
            "                     \"\\n\"",
            "                     \"   <path> = (required for ControlLogix) internal path to CPU in PLC.  E.g. \\\"1,0\\\".\\n\"",
            "                     \"\\n\"",
            "                     \"   <port> = (required for ControlLogix) internal path to CPU in PLC.  E.g. \\\"1,0\\\".\\n\"",
            "@@ -210,58 +203,62 @@",
            "                     \"\\n\"",
            "                     \"Example: ab_server --plc=ControlLogix --path=1,0 --tag=MyTag:DINT[10,10]\\n\");",
            " ",
            "     exit(1);",
            " }",
            " ",
            " ",
            "-void process_args(int argc, const char **argv, plc_s *plc)",
            "-{",
            "+void process_args(int argc, const char **argv, plc_s *plc) {",
            "     bool has_path = false;",
            "     bool needs_path = false;",
            "     bool has_plc = false;",
            "     bool has_tag = false;",
            " ",
            "     /* make sure that the reject FO count is zero. */",
            "     plc->reject_fo_count = 0;",
            " ",
            "-    for(int i=0; i < argc; i++) {",
            "-        if(strncmp(argv[i],\"--plc=\",6) == 0) {",
            "+    for(int i = 0; i < argc; i++) {",
            "+        if(strncmp(argv[i], \"--plc=\", 6) == 0) {",
            "             if(has_plc) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"PLC type can only be specified once!\\n\");",
            "                 usage();",
            "+                return;",
            "             }",
            " ",
            "             if(str_cmp_i(&(argv[i][6]), \"ControlLogix\") == 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Selecting ControlLogix simulator.\\n\");",
            "                 plc->plc_type = PLC_CONTROL_LOGIX;",
            "                 plc->path[0] = (uint8_t)0x00; /* filled in later. */",
            "                 plc->path[1] = (uint8_t)0x00; /* filled in later. */",
            "                 plc->path[2] = (uint8_t)0x20;",
            "                 plc->path[3] = (uint8_t)0x02;",
            "                 plc->path[4] = (uint8_t)0x24;",
            "                 plc->path[5] = (uint8_t)0x01;",
            "                 plc->path_len = 6;",
            "                 plc->client_to_server_max_packet = 504;",
            "                 plc->server_to_client_max_packet = 504;",
            "                 needs_path = true;",
            "                 has_plc = true;",
            "             } else if(str_cmp_i(&(argv[i][6]), \"Micro800\") == 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Selecting Micro8xx simulator.\\n\");",
            "                 plc->plc_type = PLC_MICRO800;",
            "                 plc->path[0] = (uint8_t)0x20;",
            "                 plc->path[1] = (uint8_t)0x02;",
            "                 plc->path[2] = (uint8_t)0x24;",
            "                 plc->path[3] = (uint8_t)0x01;",
            "                 plc->path_len = 4;",
            "                 plc->client_to_server_max_packet = 504;",
            "                 plc->server_to_client_max_packet = 504;",
            "                 needs_path = false;",
            "                 has_plc = true;",
            "             } else if(str_cmp_i(&(argv[i][6]), \"Omron\") == 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Selecting Omron NJ/NX simulator.\\n\");",
            "                 plc->plc_type = PLC_OMRON;",
            "                 plc->path[0] = (uint8_t)0x12;  /* Extended segment, port A */",
            "                 plc->path[1] = (uint8_t)0x09;  /* 9 bytes length. */",
            "                 plc->path[2] = (uint8_t)0x31;  /* '1' */",
            "                 plc->path[3] = (uint8_t)0x32;  /* '2' */",
            "                 plc->path[4] = (uint8_t)0x37;  /* '7' */",
            "@@ -278,170 +275,174 @@",
            "                 plc->path[15] = (uint8_t)0x01;",
            "                 plc->path_len = 16;",
            "                 plc->client_to_server_max_packet = 504;",
            "                 plc->server_to_client_max_packet = 504;",
            "                 needs_path = false;",
            "                 has_plc = true;",
            "             } else if(str_cmp_i(&(argv[i][6]), \"PLC/5\") == 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Selecting PLC/5 simulator.\\n\");",
            "                 plc->plc_type = PLC_PLC5;",
            "                 plc->path[0] = (uint8_t)0x20;",
            "                 plc->path[1] = (uint8_t)0x02;",
            "                 plc->path[2] = (uint8_t)0x24;",
            "                 plc->path[3] = (uint8_t)0x01;",
            "                 plc->path_len = 4;",
            "                 plc->client_to_server_max_packet = 244;",
            "                 plc->server_to_client_max_packet = 244;",
            "                 needs_path = false;",
            "                 has_plc = true;",
            "             } else if(str_cmp_i(&(argv[i][6]), \"SLC500\") == 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Selecting SLC 500 simulator.\\n\");",
            "                 plc->plc_type = PLC_SLC;",
            "                 plc->path[0] = (uint8_t)0x20;",
            "                 plc->path[1] = (uint8_t)0x02;",
            "                 plc->path[2] = (uint8_t)0x24;",
            "                 plc->path[3] = (uint8_t)0x01;",
            "                 plc->path_len = 4;",
            "                 plc->client_to_server_max_packet = 244;",
            "                 plc->server_to_client_max_packet = 244;",
            "                 needs_path = false;",
            "                 has_plc = true;",
            "             } else if(str_cmp_i(&(argv[i][6]), \"Micrologix\") == 0) {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Selecting Micrologix simulator.\\n\");",
            "                 plc->plc_type = PLC_MICROLOGIX;",
            "                 plc->path[0] = (uint8_t)0x20;",
            "                 plc->path[1] = (uint8_t)0x02;",
            "                 plc->path[2] = (uint8_t)0x24;",
            "                 plc->path[3] = (uint8_t)0x01;",
            "                 plc->path_len = 4;",
            "                 plc->client_to_server_max_packet = 244;",
            "                 plc->server_to_client_max_packet = 244;",
            "                 needs_path = false;",
            "                 has_plc = true;",
            "             } else {",
            "+                // NOLINTNEXTLINE",
            "                 fprintf(stderr, \"Unsupported PLC type %s!\\n\", &(argv[i][6]));",
            "                 usage();",
            "             }",
            "         }",
            " ",
            "-        if(strncmp(argv[i],\"--path=\",7) == 0) {",
            "+        if(strncmp(argv[i], \"--path=\", 7) == 0) {",
            "             parse_path(&(argv[i][7]), plc);",
            "             has_path = true;",
            "         }",
            " ",
            "-        if(strncmp(argv[i],\"--port=\",7) == 0) {",
            "-            plc->port_str = &(argv[i][7]);",
            "-        }",
            "+        if(strncmp(argv[i], \"--port=\", 7) == 0) { plc->port_str = &(argv[i][7]); }",
            " ",
            "-        if(strncmp(argv[i],\"--tag=\",6) == 0) {",
            "+        if(strncmp(argv[i], \"--tag=\", 6) == 0) {",
            "             if(plc && (plc->plc_type == PLC_PLC5 || plc->plc_type == PLC_SLC || plc->plc_type == PLC_MICROLOGIX)) {",
            "                 parse_pccc_tag(&(argv[i][6]), plc);",
            "             } else {",
            "                 parse_cip_tag(&(argv[i][6]), plc);",
            "             }",
            "             has_tag = true;",
            "         }",
            " ",
            "-        if(strcmp(argv[i],\"--debug\") == 0) {",
            "-            debug_on();",
            "-        }",
            "+        if(strcmp(argv[i], \"--debug\") == 0) { debug_on(); }",
            " ",
            "-        if(strncmp(argv[i],\"--reject_fo=\", 12) == 0) {",
            "+        if(strncmp(argv[i], \"--reject_fo=\", 12) == 0) {",
            "             if(plc) {",
            "                 info(\"Setting reject ForwardOpen count to %d.\", atoi(&argv[i][12]));",
            "                 plc->reject_fo_count = atoi(&argv[i][12]);",
            "             }",
            "         }",
            " ",
            "-        if(strncmp(argv[i],\"--delay=\", 8) == 0) {",
            "+        if(strncmp(argv[i], \"--delay=\", 8) == 0) {",
            "             if(plc) {",
            "                 info(\"Setting response delay to %dms.\", atoi(&argv[i][8]));",
            "                 plc->response_delay = atoi(&argv[i][8]);",
            "             }",
            "         }",
            "     }",
            " ",
            "     if(needs_path && !has_path) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"This PLC type requires a path argument.\\n\");",
            "         usage();",
            "     }",
            " ",
            "     if(!has_plc) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"You must pass a --plc= argument!\\n\");",
            "         usage();",
            "     }",
            " ",
            "     if(!has_tag) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"You must define at least one tag.\\n\");",
            "         usage();",
            "     }",
            " }",
            " ",
            " ",
            "-void parse_path(const char *path_str, plc_s *plc)",
            "-{",
            "+void parse_path(const char *path_str, plc_s *plc) {",
            "     int tmp_path[2];",
            " ",
            "-    if (str_scanf(path_str, \"%d,%d\", &tmp_path[0], &tmp_path[1]) == 2) {",
            "+    // NOLINTNEXTLINE",
            "+    if(str_scanf(path_str, \"%d,%d\", &tmp_path[0], &tmp_path[1]) == 2) {",
            "         plc->path[0] = (uint8_t)tmp_path[0];",
            "         plc->path[1] = (uint8_t)tmp_path[1];",
            " ",
            "         info(\"Processed path %d,%d.\", plc->path[0], plc->path[1]);",
            "     } else {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Error processing path \\\"%s\\\"!  Path must be two numbers separated by a comma.\\n\", path_str);",
            "         usage();",
            "     }",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * PCCC tags are in the format:",
            "  *    <data file>[<size>]",
            "  *",
            "  * Where data file is one of the following:",
            "  *     N7 - 2 byte signed integer.  Requires size.",
            "  *     F8 - 4-byte floating point number.   Requires size.",
            "  *     ST18 - 82-byte string with 2-byte count word.",
            "  *     L19 - 4 byte signed integer.   Requires size.",
            "  *",
            "  * The size field is a single positive integer.",
            "  */",
            " ",
            "-void parse_pccc_tag(const char *tag_str, plc_s *plc)",
            "-{",
            "+void parse_pccc_tag(const char *tag_str, plc_s *plc) {",
            "     tag_def_s *tag = calloc(1, sizeof(*tag));",
            "-    char data_file_name[200] = { 0 };",
            "-    char size_str[200] = { 0 };",
            "+    char data_file_name[200] = {0};",
            "+    char size_str[200] = {0};",
            "     int num_dims = 0;",
            "     size_t start = 0;",
            "     size_t len = 0;",
            " ",
            "     info(\"Starting.\");",
            " ",
            "     if(!tag) {",
            "         error(\"Unable to allocate memory for new tag!\");",
            "+        return;",
            "     }",
            " ",
            "+    /* create the tag data mutex */",
            "+    if(mutex_create(&(tag->data_mutex)) != MUTEX_STATUS_OK) { error(\"Unable to create tag data mutex!\"); }",
            "+",
            "     /* try to match the two parts of a tag definition string. */",
            " ",
            "     info(\"Match data file.\");",
            " ",
            "     /* first match the data file. */",
            "     start = 0;",
            "     len = strspn(tag_str + start, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\");",
            "-    if (!len) {",
            "+    if(!len) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag definition string, cannot find tag name in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     } else {",
            "         /* copy the string. */",
            "-        for (size_t i = 0; i < len && i < (size_t)200; i++) {",
            "-            data_file_name[i] = tag_str[start + i];",
            "-        }",
            "+        for(size_t i = 0; i < len && i < (size_t)200; i++) { data_file_name[i] = tag_str[start + i]; }",
            " ",
            "         /* check data file for a match. */",
            "         if(str_cmp_i(data_file_name, \"N7\") == 0) {",
            "             info(\"Found N7 data file.\");",
            "             tag->tag_type = TAG_PCCC_TYPE_INT;",
            "             tag->elem_size = 2;",
            "             tag->data_file_num = 7;",
            "@@ -457,94 +458,103 @@",
            "             tag->data_file_num = 18;",
            "         } else if(str_cmp_i(data_file_name, \"L19\") == 0) {",
            "             info(\"Found L19 data file.\");",
            "             tag->tag_type = TAG_PCCC_TYPE_DINT;",
            "             tag->elem_size = 4;",
            "             tag->data_file_num = 19;",
            "         } else {",
            "+            // NOLINTNEXTLINE",
            "             fprintf(stderr, \"Unknown data file %s, unable to create tag!\", data_file_name);",
            "             usage();",
            "         }",
            " ",
            "         start += len;",
            "     }",
            " ",
            "     /* get the array size delimiter. */",
            "-    if (tag_str[start] != '[') {",
            "-        fprintf(stderr, \"Unable to parse tag definition string, cannot find starting square bracket after data file in \\\"%s\\\"!\\n\", tag_str);",
            "+    if(tag_str[start] != '[') {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to parse tag definition string, cannot find starting square bracket after data file in \\\"%s\\\"!\\n\",",
            "+                tag_str);",
            "         usage();",
            "     } else {",
            "         start++;",
            "     }",
            " ",
            "     /* get the size field */",
            "     len = strspn(tag_str + start, \"0123456789\");",
            "-    if (!len) {",
            "+    if(!len) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag definition string, cannot match array size in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     } else {",
            "         /* copy the string. */",
            "-        for (size_t i = 0; i < len && i < (size_t)200; i++) {",
            "-            size_str[i] = tag_str[start + i];",
            "-        }",
            "+        for(size_t i = 0; i < len && i < (size_t)200; i++) { size_str[i] = tag_str[start + i]; }",
            " ",
            "         start += len;",
            "     }",
            " ",
            "-    if (tag_str[start] != ']') {",
            "-        fprintf(stderr, \"Unable to parse tag definition string, cannot find ending square bracket after size in \\\"%s\\\"!\\n\", tag_str);",
            "+    if(tag_str[start] != ']') {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to parse tag definition string, cannot find ending square bracket after size in \\\"%s\\\"!\\n\",",
            "+                tag_str);",
            "         usage();",
            "     }",
            " ",
            "     /* make sure all the dimensions are defaulted to something sane. */",
            "     tag->dimensions[0] = 1;",
            "     tag->dimensions[1] = 1;",
            "     tag->dimensions[2] = 1;",
            " ",
            "     /* match the size. */",
            "+    // NOLINTNEXTLINE",
            "     num_dims = str_scanf(size_str, \"%zu\", &tag->dimensions[0]);",
            "     if(num_dims != 1) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag size in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     }",
            " ",
            "     /* check the size. */",
            "     if(tag->dimensions[0] <= 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"The array size must least 1 and may not be negative!\\n\");",
            "         usage();",
            "     } else {",
            "         tag->elem_count = tag->dimensions[0];",
            "         tag->num_dimensions = 1;",
            "     }",
            " ",
            "     /* copy the tag name */",
            "     tag->name = strdup(data_file_name);",
            "-    if (!tag->name) {",
            "+    if(!tag->name) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate a copy of the data file \\\"%s\\\"!\\n\", data_file_name);",
            "-        usage();",
            "+        exit(1);",
            "     }",
            " ",
            "     /* allocate the tag data array. */",
            "     info(\"allocating %d elements of %d bytes each.\", tag->elem_count, tag->elem_size);",
            "     tag->data = calloc(tag->elem_count, (size_t)tag->elem_size);",
            "     if(!tag->data) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate tag data buffer!\\n\");",
            "         free(tag->name);",
            "+        exit(1);",
            "     }",
            " ",
            "-    info(\"Processed \\\"%s\\\" into tag %s of type %x with dimensions (%d, %d, %d).\", tag_str, tag->name, tag->tag_type, tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]);",
            "+    info(\"Processed \\\"%s\\\" into tag %s of type %x with dimensions (%d, %d, %d).\", tag_str, tag->name, tag->tag_type,",
            "+         tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]);",
            " ",
            "     /* add the tag to the list. */",
            "     tag->next_tag = plc->tags;",
            "     plc->tags = tag;",
            " }",
            " ",
            " ",
            "-",
            "-",
            " /*",
            "  * CIP tags are in the format:",
            "  *    <name>:<type>[<sizes>]",
            "  *",
            "  * Where name is alphanumeric, starting with an alpha character.",
            "  *",
            "  * Type is one of:",
            "@@ -554,89 +564,99 @@",
            "  *     REAL - 4-byte floating point number.  Requires array size(s).",
            "  *     LREAL - 8-byte floating point number.  Requires array size(s).",
            "  *     STRING - 82-byte string with 4-byte count word and 2 bytes of padding.",
            "  *",
            "  * Array size field is one or more (up to 3) numbers separated by commas.",
            "  */",
            " ",
            "-void parse_cip_tag(const char *tag_str, plc_s *plc)",
            "-{",
            "+void parse_cip_tag(const char *tag_str, plc_s *plc) {",
            "     tag_def_s *tag = calloc(1, sizeof(*tag));",
            "-    char tag_name[200] = { 0 };",
            "-    char type_str[200] = { 0 };",
            "-    char dim_str[200] = { 0 };",
            "+    char tag_name[200] = {0};",
            "+    char type_str[200] = {0};",
            "+    char dim_str[200] = {0};",
            "     int num_dims = 0;",
            "     size_t start = 0;",
            "     size_t len = 0;",
            " ",
            "     if(!tag) {",
            "         error(\"Unable to allocate memory for new tag!\");",
            "+        return;",
            "     }",
            " ",
            "+    /* create the tag data mutex */",
            "+    if(mutex_create(&(tag->data_mutex)) != MUTEX_STATUS_OK) { error(\"Unable to create tag data mutex!\"); }",
            "+",
            "+",
            "+    /* create the tag data mutex */",
            "+    if(mutex_create(&(tag->data_mutex)) != MUTEX_STATUS_OK) { error(\"Unable to create tag data mutex!\"); }",
            "+",
            "+",
            "     /* try to match the three parts of a tag definition string. */",
            " ",
            "     /* first match the name. */",
            "     start = 0;",
            "     len = strspn(tag_str + start, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\");",
            "-    if (!len) {",
            "+    if(!len) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag definition string, cannot find tag name in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     } else {",
            "         /* copy the string. */",
            "-        for (size_t i = 0; i < len && i < (size_t)200; i++) {",
            "-            tag_name[i] = tag_str[start + i];",
            "-        }",
            "+        for(size_t i = 0; i < len && i < (size_t)200; i++) { tag_name[i] = tag_str[start + i]; }",
            " ",
            "         start += len;",
            "     }",
            " ",
            "     if(tag_str[start] != ':') {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag definition string, cannot find colon after tag name in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     } else {",
            "         start++;",
            "     }",
            " ",
            "     /* get the type field */",
            "     len = strspn(tag_str + start, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");",
            "-    if (!len) {",
            "+    if(!len) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag definition string, cannot match tag type in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     } else {",
            "         /* copy the string. */",
            "-        for (size_t i = 0; i < len && i < (size_t)200; i++) {",
            "-            type_str[i] = tag_str[start + i];",
            "-        }",
            "+        for(size_t i = 0; i < len && i < (size_t)200; i++) { type_str[i] = tag_str[start + i]; }",
            " ",
            "         start += len;",
            "     }",
            " ",
            "-    if (tag_str[start] != '[') {",
            "-        fprintf(stderr, \"Unable to parse tag definition string, cannot find starting square bracket after tag type in \\\"%s\\\"!\\n\", tag_str);",
            "+    if(tag_str[start] != '[') {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to parse tag definition string, cannot find starting square bracket after tag type in \\\"%s\\\"!\\n\",",
            "+                tag_str);",
            "         usage();",
            "     } else {",
            "         start++;",
            "     }",
            " ",
            "     /* get the dimension field */",
            "     len = strspn(tag_str + start, \"0123456789,\");",
            "-    if (!len) {",
            "+    if(!len) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to parse tag definition string, cannot match dimension in \\\"%s\\\"!\\n\", tag_str);",
            "         usage();",
            "     } else {",
            "         /* copy the string. */",
            "-        for (size_t i = 0; i < len && i < (size_t)200; i++) {",
            "-            dim_str[i] = tag_str[start + i];",
            "-        }",
            "+        for(size_t i = 0; i < len && i < (size_t)200; i++) { dim_str[i] = tag_str[start + i]; }",
            " ",
            "         start += len;",
            "     }",
            " ",
            "-    if (tag_str[start] != ']') {",
            "-        fprintf(stderr, \"Unable to parse tag definition string, cannot find ending square bracket after tag type in \\\"%s\\\"!\\n\", tag_str);",
            "+    if(tag_str[start] != ']') {",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"Unable to parse tag definition string, cannot find ending square bracket after tag type in \\\"%s\\\"!\\n\",",
            "+                tag_str);",
            "         usage();",
            "     }",
            " ",
            "     /* match the type. */",
            "     if(str_cmp_i(type_str, \"SINT\") == 0) {",
            "         tag->tag_type = TAG_CIP_TYPE_SINT;",
            "         tag->elem_size = 1;",
            "@@ -654,35 +674,39 @@",
            "         tag->elem_size = 4;",
            "     } else if(str_cmp_i(type_str, \"LREAL\") == 0) {",
            "         tag->tag_type = TAG_CIP_TYPE_LREAL;",
            "         tag->elem_size = 8;",
            "     } else if(str_cmp_i(type_str, \"STRING\") == 0) {",
            "         tag->tag_type = TAG_CIP_TYPE_STRING;",
            "         tag->elem_size = 88;",
            "-    } else if(str_cmp_i(type_str, \"BOOL\") == 0){",
            "+    } else if(str_cmp_i(type_str, \"BOOL\") == 0) {",
            "         tag->tag_type = TAG_CIP_TYPE_BOOL;",
            "         tag->elem_size = 1;",
            "     } else {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unsupported tag type \\\"%s\\\"!\", type_str);",
            "         usage();",
            "     }",
            " ",
            "     /* match the dimensions. */",
            "     tag->dimensions[0] = 0;",
            "     tag->dimensions[1] = 0;",
            "     tag->dimensions[2] = 0;",
            " ",
            "+    // NOLINTNEXTLINE",
            "     num_dims = str_scanf(dim_str, \"%zu,%zu,%zu,%*u\", &tag->dimensions[0], &tag->dimensions[1], &tag->dimensions[2]);",
            "     if(num_dims < 1 || num_dims > 3) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Tag dimensions must have at least one dimension non-zero and no more than three dimensions.\");",
            "         usage();",
            "     }",
            " ",
            "     /* check the dimensions. */",
            "     if(tag->dimensions[0] <= 0) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"The first tag dimension must be at least 1 and may not be negative!\\n\");",
            "         usage();",
            "     } else {",
            "         tag->elem_count = tag->dimensions[0];",
            "         tag->num_dimensions = 1;",
            "     }",
            " ",
            "@@ -698,55 +722,58 @@",
            "         tag->num_dimensions = 3;",
            "     } else {",
            "         tag->dimensions[2] = 1;",
            "     }",
            " ",
            "     /* copy the tag name */",
            "     tag->name = strdup(tag_name);",
            "-    if (!tag->name) {",
            "+    if(!tag->name) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate a copy of the tag name \\\"%s\\\"!\\n\", tag_name);",
            "-        usage();",
            "+        exit(1);",
            "     }",
            " ",
            "     /* allocate the tag data array. */",
            "     info(\"allocating %d elements of %d bytes each.\", tag->elem_count, tag->elem_size);",
            "     tag->data = calloc(tag->elem_count, (size_t)tag->elem_size);",
            "     if(!tag->data) {",
            "+        // NOLINTNEXTLINE",
            "         fprintf(stderr, \"Unable to allocate tag data buffer!\\n\");",
            "         free(tag->name);",
            "+        exit(1);",
            "     }",
            " ",
            "-    info(\"Processed \\\"%s\\\" into tag %s of type %x with dimensions (%d, %d, %d).\", tag_str, tag->name, tag->tag_type, tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]);",
            "+    info(\"Processed \\\"%s\\\" into tag %s of type %x with dimensions (%d, %d, %d).\", tag_str, tag->name, tag->tag_type,",
            "+         tag->dimensions[0], tag->dimensions[1], tag->dimensions[2]);",
            " ",
            "     /* add the tag to the list. */",
            "     tag->next_tag = plc->tags;",
            "     plc->tags = tag;",
            " }",
            " ",
            " ",
            " /*",
            "  * Process each request.  Dispatch to the correct",
            "  * request type handler.",
            "  */",
            " ",
            "-slice_s request_handler(slice_s input, slice_s output, void *plc_arg)",
            "-{",
            "-    plc_s *plc = (plc_s*)plc_arg;",
            "+slice_s request_handler(slice_s input, slice_s output, void *plc_arg) {",
            "+    // Remember that we get a copy of the plc_arg/context contents. So values are frozen",
            "+    // in time, but references are to a shared resource and must be mutex'ed.",
            "+    plc_s *plc = (plc_s *)plc_arg;",
            " ",
            "     /* check to see if we have a full packet. */",
            "     if(slice_len(input) >= EIP_HEADER_SIZE) {",
            "         uint16_t eip_len = slice_get_uint16_le(input, 2);",
            " ",
            "         if(slice_len(input) >= (size_t)(EIP_HEADER_SIZE + eip_len)) {",
            "             slice_s resp = eip_dispatch_request(input, output, plc);",
            " ",
            "             /* if there is a response delay requested, then wait a bit. */",
            "-            if(plc->response_delay > 0) {",
            "-                util_sleep_ms(plc->response_delay);",
            "-            }",
            "+            if(plc->response_delay > 0) { util_sleep_ms(plc->response_delay); }",
            " ",
            "             return resp;",
            "         }",
            "     }",
            " ",
            "     /* we do not have a complete packet, get more data. */",
            "     return slice_make_err(TCP_SERVER_INCOMPLETE);"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/pccc.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/pccc.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/pccc.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,31 +27,31 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include <inttypes.h>",
            "-#include <stdint.h>",
            "-#include <stdlib.h>",
            "+#include \"pccc.h\"",
            " #include \"cip.h\"",
            " #include \"eip.h\"",
            "-#include \"pccc.h\"",
            " #include \"plc.h\"",
            " #include \"slice.h\"",
            " #include \"utils.h\"",
            "+#include <inttypes.h>",
            "+#include <stdint.h>",
            "+#include <stdlib.h>",
            " ",
            "-const uint8_t PCCC_PREFIX[] = { 0x0f, 0x00 };",
            "-const uint8_t PLC5_READ[] = { 0x01 };",
            "-const uint8_t PLC5_WRITE[] = { 0x00 };",
            "-const uint8_t SLC_READ[] = { 0xa2 };",
            "-const uint8_t SLC_WRITE[] = { 0xaa };",
            "+const uint8_t PCCC_PREFIX[] = {0x0f, 0x00};",
            "+const uint8_t PLC5_READ[] = {0x01};",
            "+const uint8_t PLC5_WRITE[] = {0x00};",
            "+const uint8_t SLC_READ[] = {0xa2};",
            "+const uint8_t SLC_WRITE[] = {0xaa};",
            " ",
            "-const uint8_t PCCC_RESP_PREFIX[] = { 0xcb, 0x00, 0x00, 0x00, 0x07, 0x3d, 0xf3, 0x45, 0x43, 0x50, 0x21 };",
            "+const uint8_t PCCC_RESP_PREFIX[] = {0xcb, 0x00, 0x00, 0x00, 0x07, 0x3d, 0xf3, 0x45, 0x43, 0x50, 0x21};",
            " ",
            " const uint8_t PCCC_ERR_ADDR_NOT_USABLE = (int8_t)0x06;",
            " const uint8_t PCCC_ERR_FILE_IS_WRONG_SIZE = (int8_t)0x07;",
            " const uint8_t PCCC_ERR_UNSUPPORTED_COMMAND = (uint8_t)0x0e;",
            " ",
            " // 4f f0 3c 96 06 - address does not point to something usable.",
            " // 4f f0 fa da 07 - file is wrong size.",
            "@@ -60,68 +60,74 @@",
            " static slice_s handle_plc5_read_request(slice_s input, slice_s output, plc_s *plc);",
            " static slice_s handle_plc5_write_request(slice_s input, slice_s output, plc_s *plc);",
            " static slice_s handle_slc_read_request(slice_s input, slice_s output, plc_s *plc);",
            " static slice_s handle_slc_write_request(slice_s input, slice_s output, plc_s *plc);",
            " static slice_s make_pccc_error(slice_s output, uint8_t err_code, plc_s *plc);",
            " ",
            " ",
            "-slice_s dispatch_pccc_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s dispatch_pccc_request(slice_s input, slice_s output, plc_s *plc) {",
            "     slice_s pccc_input;",
            "     slice_s pccc_output;",
            "     info(\"Got packet:\");",
            "     slice_dump(input);",
            " ",
            "     if(slice_len(input) < 20) { /* FIXME - 13 + 7 */",
            "         info(\"Packet too short!\");",
            "         return make_pccc_error(output, PCCC_ERR_FILE_IS_WRONG_SIZE, plc);",
            "     }",
            " ",
            "     /* split off the PCCC packet. */",
            "-    pccc_input = slice_from_slice(input, 13, slice_len(input)-13);",
            "-    pccc_output = slice_from_slice(output, sizeof(PCCC_RESP_PREFIX), slice_len(output)-sizeof(PCCC_RESP_PREFIX));",
            "+    pccc_input = slice_from_slice(input, 13, slice_len(input) - 13);",
            "+    pccc_output = slice_from_slice(output, sizeof(PCCC_RESP_PREFIX), slice_len(output) - sizeof(PCCC_RESP_PREFIX));",
            " ",
            "     /* copy the response prefix. */",
            "-    for(size_t i=0; i < sizeof(PCCC_RESP_PREFIX); i++) {",
            "-        slice_set_uint8(output, i, PCCC_RESP_PREFIX[i]);",
            "-    }",
            "+    for(size_t i = 0; i < sizeof(PCCC_RESP_PREFIX); i++) { slice_set_uint8(output, i, PCCC_RESP_PREFIX[i]); }",
            " ",
            "     info(\"PCCC packet:\");",
            "     slice_dump(pccc_input);",
            " ",
            "-    if(slice_match_bytes(pccc_input, PCCC_PREFIX, sizeof(PCCC_PREFIX))) {",
            "+    if(slice_match_data_prefix(pccc_input, PCCC_PREFIX, sizeof(PCCC_PREFIX))) {",
            "         slice_s pccc_command;",
            " ",
            "         info(\"Matched valid PCCC prefix.\");",
            " ",
            "         plc->pccc_seq_id = slice_get_uint16_le(pccc_input, 2);",
            " ",
            "         pccc_command = slice_from_slice(pccc_input, 4, slice_len(pccc_input) - 4);",
            " ",
            "         /* match the command. */",
            "-        if(plc->plc_type == PLC_PLC5 && slice_match_bytes(pccc_command, PLC5_READ, sizeof(PLC5_READ))) {",
            "+        if(plc->plc_type == PLC_PLC5 && slice_match_data_prefix(pccc_command, PLC5_READ, sizeof(PLC5_READ))) {",
            "             pccc_output = handle_plc5_read_request(pccc_command, pccc_output, plc);",
            "-        } else if(plc->plc_type == PLC_PLC5 && slice_match_bytes(pccc_command, PLC5_WRITE, sizeof(PLC5_WRITE))) {",
            "+        } else if(plc->plc_type == PLC_PLC5 && slice_match_data_prefix(pccc_command, PLC5_WRITE, sizeof(PLC5_WRITE))) {",
            "             pccc_output = handle_plc5_write_request(pccc_command, pccc_output, plc);",
            "-        } else if((plc->plc_type == PLC_SLC || plc->plc_type == PLC_MICROLOGIX) && slice_match_bytes(pccc_command, SLC_READ, sizeof(SLC_READ))) {",
            "+        } else if((plc->plc_type == PLC_SLC || plc->plc_type == PLC_MICROLOGIX)",
            "+                  && slice_match_data_prefix(pccc_command, SLC_READ, sizeof(SLC_READ))) {",
            "             pccc_output = handle_slc_read_request(pccc_command, pccc_output, plc);",
            "-        } else if((plc->plc_type == PLC_SLC || plc->plc_type == PLC_MICROLOGIX) && slice_match_bytes(pccc_command, SLC_WRITE, sizeof(SLC_WRITE))) {",
            "+        } else if((plc->plc_type == PLC_SLC || plc->plc_type == PLC_MICROLOGIX)",
            "+                  && slice_match_data_prefix(pccc_command, SLC_WRITE, sizeof(SLC_WRITE))) {",
            "             pccc_output = handle_slc_write_request(pccc_command, pccc_output, plc);",
            "         } else {",
            "             info(\"Unsupported PCCC command!\");",
            "             pccc_output = make_pccc_error(pccc_output, PCCC_ERR_UNSUPPORTED_COMMAND, plc);",
            "         }",
            "+    } else {",
            "+        slice_s prefix = slice_make(&(PCCC_PREFIX[0]), sizeof(PCCC_PREFIX));",
            "+        info(\"Invalid PCCC prefix!\");",
            "+        info(\"Expected:\");",
            "+        slice_dump(prefix);",
            "+        info(\"Got:\");",
            "+        slice_dump(pccc_input);",
            "+        pccc_output = make_pccc_error(pccc_output, PCCC_ERR_UNSUPPORTED_COMMAND, plc);",
            "     }",
            " ",
            "     return slice_from_slice(output, 0, 11 + slice_len(pccc_output));",
            " }",
            " ",
            " ",
            "-slice_s handle_plc5_read_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s handle_plc5_read_request(slice_s input, slice_s output, plc_s *plc) {",
            "     uint16_t offset = 0;",
            "     size_t start_byte_offset = 0;",
            "     uint16_t transfer_size = 0;",
            "     size_t end_byte_offset = 0;",
            "     size_t tag_size = 0;",
            "     size_t data_file_num = 0;",
            "     size_t data_file_element = 0;",
            "@@ -146,17 +152,15 @@",
            "     /* get data file number. */",
            "     data_file_num = slice_get_uint8(input, 6);",
            " ",
            "     /* get the data element number. */",
            "     data_file_element = slice_get_uint8(input, 7);",
            " ",
            "     /* find the tag. */",
            "-    while(tag && tag->data_file_num != data_file_num) {",
            "-        tag = tag->next_tag;",
            "-    }",
            "+    while(tag && tag->data_file_num != data_file_num) { tag = tag->next_tag; }",
            " ",
            "     if(!tag) {",
            "         info(\"Unable to find tag with data file %u!\", data_file_num);",
            "         return make_pccc_error(output, PCCC_ERR_ADDR_NOT_USABLE, plc);",
            "     }",
            " ",
            "     /* now we can check the start and end offsets. */",
            "@@ -172,19 +176,21 @@",
            "     if(end_byte_offset > tag_size) {",
            "         info(\"Ending offset, %u, is greater than tag size, %d!\", (unsigned int)end_byte_offset, (unsigned int)tag_size);",
            "         return make_pccc_error(output, PCCC_ERR_FILE_IS_WRONG_SIZE, plc);",
            "     }",
            " ",
            "     /* check the amount of data requested. */",
            "     if((end_byte_offset - start_byte_offset) > 240) {",
            "-        info(\"Request asks for too much data, %u bytes, for response packet!\", (unsigned int)(end_byte_offset - start_byte_offset));",
            "+        info(\"Request asks for too much data, %u bytes, for response packet!\",",
            "+             (unsigned int)(end_byte_offset - start_byte_offset));",
            "         return make_pccc_error(output, PCCC_ERR_FILE_IS_WRONG_SIZE, plc);",
            "     }",
            " ",
            "-    info(\"Transfer size %u, tag elem size %u, bytes to transfer %d.\", transfer_size, tag->elem_size, transfer_size * tag->elem_size);",
            "+    info(\"Transfer size %u, tag elem size %u, bytes to transfer %d.\", transfer_size, tag->elem_size,",
            "+         transfer_size * tag->elem_size);",
            " ",
            "     /* build the response. */",
            "     slice_set_uint8(output, 0, 0x4f);",
            "     slice_set_uint8(output, 1, 0); /* no error */",
            "     slice_set_uint16_le(output, 2, plc->pccc_seq_id);",
            " ",
            "     for(size_t i = 0; i < (transfer_size * tag->elem_size); i++) {",
            "@@ -194,16 +200,15 @@",
            " ",
            "     info(\"Output slice length %d.\", slice_len(slice_from_slice(output, 0, 4 + (transfer_size * tag->elem_size))));",
            " ",
            "     return slice_from_slice(output, 0, 4 + (transfer_size * tag->elem_size));",
            " }",
            " ",
            " ",
            "-slice_s handle_plc5_write_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s handle_plc5_write_request(slice_s input, slice_s output, plc_s *plc) {",
            "     uint16_t offset = 0;",
            "     size_t start_byte_offset = 0;",
            "     uint16_t transfer_size = 0;",
            "     size_t end_byte_offset = 0;",
            "     size_t tag_size = 0;",
            "     size_t data_start_byte_offset = 0;",
            "     size_t data_len = 0;",
            "@@ -230,17 +235,15 @@",
            "     /* get data file number. */",
            "     data_file_num = slice_get_uint8(input, 6);",
            " ",
            "     /* get the data element number. */",
            "     data_file_element = slice_get_uint8(input, 7);",
            " ",
            "     /* find the tag. */",
            "-    while(tag && tag->data_file_num != data_file_num) {",
            "-        tag = tag->next_tag;",
            "-    }",
            "+    while(tag && tag->data_file_num != data_file_num) { tag = tag->next_tag; }",
            " ",
            "     if(!tag) {",
            "         info(\"Unable to find tag with data file %u!\", data_file_num);",
            "         return make_pccc_error(output, PCCC_ERR_ADDR_NOT_USABLE, plc);",
            "     }",
            " ",
            "     /*",
            "@@ -262,37 +265,38 @@",
            "         return make_pccc_error(output, PCCC_ERR_FILE_IS_WRONG_SIZE, plc);",
            "     }",
            " ",
            "     data_start_byte_offset = 8;",
            "     data_len = slice_len(input) - 8;",
            " ",
            "     if(data_len != (transfer_size * tag->elem_size)) {",
            "-        info(\"Data in packet is not the same length, %u, as the requested transfer, %d!\", data_len, (transfer_size * tag->elem_size));",
            "+        info(\"Data in packet is not the same length, %u, as the requested transfer, %d!\", data_len,",
            "+             (transfer_size * tag->elem_size));",
            "         return make_pccc_error(output, PCCC_ERR_FILE_IS_WRONG_SIZE, plc);",
            "     }",
            " ",
            "     /* copy the data into the tag. */",
            "     for(size_t i = 0; i < (transfer_size * tag->elem_size); i++) {",
            "         info(\"setting byte %d to value %d.\", start_byte_offset + i, slice_get_uint8(input, data_start_byte_offset + i));",
            "         tag->data[start_byte_offset + i] = slice_get_uint8(input, data_start_byte_offset + i);",
            "     }",
            " ",
            "-    info(\"Transfer size %u, tag elem size %u, bytes to transfer %d.\", transfer_size, tag->elem_size, transfer_size * tag->elem_size);",
            "+    info(\"Transfer size %u, tag elem size %u, bytes to transfer %d.\", transfer_size, tag->elem_size,",
            "+         transfer_size * tag->elem_size);",
            " ",
            "     /* build the response. */",
            "     slice_set_uint8(output, 0, 0x4f);",
            "     slice_set_uint8(output, 1, 0); /* no error */",
            "     slice_set_uint16_le(output, 2, plc->pccc_seq_id);",
            " ",
            "     return slice_from_slice(output, 0, 4);",
            " }",
            " ",
            " ",
            "-slice_s handle_slc_read_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s handle_slc_read_request(slice_s input, slice_s output, plc_s *plc) {",
            "     size_t start_byte_offset = 0;",
            "     uint8_t transfer_size = 0;",
            "     size_t end_byte_offset = 0;",
            "     size_t tag_size = 0;",
            "     size_t data_file_num = 0;",
            "     size_t data_file_type = 0;",
            "     size_t data_file_element = 0;",
            "@@ -319,17 +323,15 @@",
            " ",
            "     if(data_file_subelement != 0) {",
            "         info(\"Data file subelement is unsupported!\");",
            "         return make_pccc_error(output, PCCC_ERR_ADDR_NOT_USABLE, plc);",
            "     }",
            " ",
            "     /* find the tag. */",
            "-    while(tag && tag->data_file_num != data_file_num) {",
            "-        tag = tag->next_tag;",
            "-    }",
            "+    while(tag && tag->data_file_num != data_file_num) { tag = tag->next_tag; }",
            " ",
            "     if(!tag) {",
            "         info(\"Unable to find tag with data file %u!\", data_file_num);",
            "         return make_pccc_error(output, PCCC_ERR_ADDR_NOT_USABLE, plc);",
            "     }",
            " ",
            "     if(tag->tag_type != data_file_type) {",
            "@@ -374,17 +376,15 @@",
            " ",
            "     info(\"Output slice length %d.\", slice_len(slice_from_slice(output, 0, (size_t)4 + (size_t)transfer_size)));",
            " ",
            "     return slice_from_slice(output, 0, (size_t)4 + (size_t)transfer_size);",
            " }",
            " ",
            " ",
            "-",
            "-slice_s handle_slc_write_request(slice_s input, slice_s output, plc_s *plc)",
            "-{",
            "+slice_s handle_slc_write_request(slice_s input, slice_s output, plc_s *plc) {",
            "     size_t start_byte_offset = 0;",
            "     uint8_t transfer_size = 0;",
            "     size_t end_byte_offset = 0;",
            "     size_t tag_size = 0;",
            "     size_t data_file_num = 0;",
            "     size_t data_file_type = 0;",
            "     size_t data_file_element = 0;",
            "@@ -414,17 +414,15 @@",
            " ",
            "     if(data_file_subelement != 0) {",
            "         info(\"Data file subelement is unsupported!\");",
            "         return make_pccc_error(output, PCCC_ERR_ADDR_NOT_USABLE, plc);",
            "     }",
            " ",
            "     /* find the tag. */",
            "-    while(tag && tag->data_file_num != data_file_num) {",
            "-        tag = tag->next_tag;",
            "-    }",
            "+    while(tag && tag->data_file_num != data_file_num) { tag = tag->next_tag; }",
            " ",
            "     if(!tag) {",
            "         info(\"Unable to find tag with data file %u!\", data_file_num);",
            "         return make_pccc_error(output, PCCC_ERR_ADDR_NOT_USABLE, plc);",
            "     }",
            " ",
            "     if(tag->tag_type != data_file_type) {",
            "@@ -478,24 +476,20 @@",
            "     slice_set_uint8(output, 1, 0); /* no error */",
            "     slice_set_uint16_le(output, 2, plc->pccc_seq_id);",
            " ",
            "     return slice_from_slice(output, 0, 4);",
            " }",
            " ",
            " ",
            "-",
            "-",
            "-slice_s make_pccc_error(slice_s output, uint8_t err_code, plc_s *plc)",
            "-{",
            "+slice_s make_pccc_error(slice_s output, uint8_t err_code, plc_s *plc) {",
            "     // 4f f0 3c 96 06",
            "     slice_s err_resp = slice_from_slice(output, 0, 5);",
            " ",
            "     if(!slice_has_err(err_resp)) {",
            "         slice_set_uint8(err_resp, 0, (uint8_t)0x4f);",
            "         slice_set_uint8(err_resp, 1, (uint8_t)0xf0);",
            "         slice_set_uint16_le(err_resp, 2, plc->pccc_seq_id);",
            "         slice_set_uint8(err_resp, 4, err_code);",
            "     }",
            " ",
            "     return err_resp;",
            " }",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/pccc.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/pccc.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/pccc.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/plc.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/plc.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/plc.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -32,14 +32,15 @@",
            "  ***************************************************************************/",
            " ",
            " #pragma once",
            " ",
            " #include <stddef.h>",
            " #include <stdint.h>",
            " ",
            "+#include \"mutex.h\"",
            " ",
            " typedef uint16_t tag_type_t;",
            " ",
            " /* CIP data types. */",
            " #define TAG_CIP_TYPE_BOOL        ((tag_type_t)0x00C1) /* 8-bit boolean value */",
            " #define TAG_CIP_TYPE_SINT        ((tag_type_t)0x00C2) /* Signed 8bit integer value */",
            " #define TAG_CIP_TYPE_INT         ((tag_type_t)0x00C3) /* Signed 16bit integer value */",
            "@@ -65,14 +66,19 @@",
            "     tag_type_t tag_type;",
            "     size_t elem_size;",
            "     size_t elem_count;",
            "     size_t data_file_num;",
            "     size_t num_dimensions;",
            "     size_t dimensions[3];",
            "     uint8_t *data;",
            "+    /* Note we make a big simplifying assumption that the only access to the tag requiring thread",
            "+       protection, is to the data. The rest of the fields (the list itself, and the tags' names",
            "+       and types) are expected to be created once, in a single thread. From then on those fields",
            "+       are expected to be read-only (even if by multiple threads). */",
            "+    mutex_p data_mutex;",
            " };",
            " ",
            " typedef struct tag_def_s tag_def_s;",
            " ",
            " typedef enum {",
            "     PLC_CONTROL_LOGIX,",
            "     PLC_MICRO800,",
            "@@ -113,8 +119,7 @@",
            " ",
            "     /* response delay */",
            "     int response_delay;",
            " ",
            "     /* list of tags served by this \"PLC\" */",
            "     struct tag_def_s *tags;",
            " } plc_s;",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/slice.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/slice.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/slice.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -42,38 +42,49 @@",
            " #include \"compat.h\"",
            " ",
            " typedef struct {",
            "     ssize_t len;",
            "     uint8_t *data;",
            " } slice_s;",
            " ",
            "-inline static slice_s slice_make(uint8_t *data, ssize_t len) { return (slice_s){ .len = len, .data = data }; }",
            "+inline static slice_s slice_make(const uint8_t *data, ssize_t len) { return (slice_s){ .len = len, .data = (uint8_t *)data }; }",
            " inline static slice_s slice_make_err(ssize_t err) { return slice_make(NULL, err); }",
            " inline static size_t slice_len(slice_s s) { return (size_t)s.len; }",
            " inline static bool slice_in_bounds(slice_s s, size_t index) { if(index < (size_t)s.len) { return true; } else { return false; } }",
            " inline static uint8_t slice_get_uint8(slice_s s, size_t index) { if(slice_in_bounds(s, index)) { return s.data[index]; } else { return UINT8_MAX; } }",
            " inline static bool slice_set_uint8(slice_s s, size_t index, uint8_t val) { if(slice_in_bounds(s, index)) { s.data[index] = val; return true; } else { return false; } }",
            " inline static uint8_t *slice_get_bytes(slice_s s, size_t index) {  if(slice_in_bounds(s, index)) { return &s.data[index];} else { return NULL;} }",
            " inline static bool slice_has_err(slice_s s) { if(s.data == NULL) { return true; } else { return false; } }",
            " inline static int slice_get_err(slice_s s) { return (int)(ssize_t)slice_len(s); }",
            "-inline static bool slice_match_bytes(slice_s s, const uint8_t *data, size_t data_len) {",
            "+inline static bool slice_match_data_prefix(slice_s s, const uint8_t *data, size_t data_len) {",
            "+    /* Must be no more data prefix than data in the slice. */",
            "     if(data_len > slice_len(s)) {",
            "-        /* fprintf(stderr, \"lengths do not match! Slice has length %d and bytes have length %d!\\n\", (int)slice_len(s), (int)data_len); */",
            "+        //fprintf(stderr, \"Slice has too little data to match prefix bytes. Slice has length %d and bytes have length %d!\\n\", (int)slice_len(s), (int)data_len);",
            "         return false;",
            "     }",
            "+",
            "     for(size_t i=0; i < data_len; i++) {",
            "-        /* fprintf(stderr,\"Comparing element %d, %x and %x\\n\", (int)i, (int)slice_get_uint8(s, (ssize_t)i), data[i]); */",
            "+        //fprintf(stderr,\"Comparing element %d, %x and %x\\n\", (int)i, (int)slice_get_uint8(s, (ssize_t)i), data[i]);",
            "         if(slice_get_uint8(s, i) != data[i]) {",
            "             return false;",
            "         }",
            "     }",
            "     return true;",
            " }",
            "-inline static bool slice_match_string(slice_s s, const char *data) { return slice_match_bytes(s, (const uint8_t*)data, strlen(data)); }",
            "+inline static bool slice_match_string_prefix(slice_s s, const char *data) { return slice_match_data_prefix(s, (const uint8_t*)data, strlen(data)); }",
            "+inline static bool slice_match_data_exact(slice_s s, const uint8_t *data, size_t data_len) {",
            "+    /* must be an exact match */",
            "+    if(data_len != slice_len(s)) {",
            "+        //fprintf(stderr, \"lengths do not match! Slice has length %d and bytes have length %d!\\n\", (int)slice_len(s), (int)data_len);",
            "+        return false;",
            "+    }",
            " ",
            "+    return slice_match_data_prefix(s, data, data_len);",
            "+}",
            "+inline static bool slice_match_string_exact(slice_s s, const char *data) { return slice_match_data_exact(s, (const uint8_t*)data, strlen(data)); }",
            " inline static slice_s slice_from_slice(slice_s src, size_t start, size_t len) {",
            "     ssize_t actual_start;",
            "     ssize_t actual_len;",
            " ",
            "     if(slice_has_err(src)) {",
            "         return src;",
            "     }",
            "@@ -95,14 +106,61 @@",
            " ",
            "     return (slice_s){ .len = actual_len, .data = &(src.data[actual_start]) };",
            " }",
            " ",
            " ",
            " /* helper functions to get and set data in a slice. */",
            " ",
            "+inline static bool slice_copy_data_in(slice_s dest, uint8_t *src_data, size_t src_len) {",
            "+    if(slice_has_err(dest)) {",
            "+        return false;",
            "+    }",
            "+",
            "+    if(slice_len(dest) < src_len) {",
            "+        return false;",
            "+    }",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    memcpy(dest.data, src_data, src_len);",
            "+",
            "+    return true;",
            "+}",
            "+",
            "+inline static bool slice_copy_data_out(uint8_t *dest_data, size_t dest_len, slice_s src) {",
            "+    if(slice_has_err(src)) {",
            "+        return false;",
            "+    }",
            "+",
            "+    if(slice_len(src) > dest_len) {",
            "+        return false;",
            "+    }",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    memcpy(dest_data, src.data, slice_len(src));",
            "+",
            "+    return true;",
            "+}",
            "+",
            "+inline static bool slice_copy_slice(slice_s dest, slice_s src) {",
            "+    if(slice_has_err(dest) || slice_has_err(src)) {",
            "+        return false;",
            "+    }",
            "+",
            "+    if(slice_len(dest) < slice_len(src)) {",
            "+        return false;",
            "+    }",
            "+",
            "+    // NOLINTNEXTLINE",
            "+    memcpy(dest.data, src.data, slice_len(src));",
            "+",
            "+    return true;",
            "+}",
            "+",
            "+",
            "+",
            " inline static uint16_t slice_get_uint16_le(slice_s input_buf, size_t offset) {",
            "     uint16_t res = 0;",
            " ",
            "     if(slice_in_bounds(input_buf, offset + 1)) {",
            "         res = (uint16_t)(slice_get_uint8(input_buf, offset) + (slice_get_uint8(input_buf, offset + 1) << 8));",
            "     }",
            " ",
            "@@ -170,8 +228,7 @@",
            "         slice_set_uint8(output_buf, offset + 3, (uint8_t)((val >> 24) & 0xFF));",
            "         slice_set_uint8(output_buf, offset + 4, (uint8_t)((val >> 32) & 0xFF));",
            "         slice_set_uint8(output_buf, offset + 5, (uint8_t)((val >> 40) & 0xFF));",
            "         slice_set_uint8(output_buf, offset + 6, (uint8_t)((val >> 48) & 0xFF));",
            "         slice_set_uint8(output_buf, offset + 7, (uint8_t)((val >> 56) & 0xFF));",
            "     }",
            " }",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/socket.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/socket.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/socket.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -30,296 +30,356 @@",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " #include \"compat.h\"",
            " ",
            " #if IS_WINDOWS",
            "-    #include <winsock2.h>",
            "-    #include <ws2tcpip.h>",
            "+#    define WIN32_LEAN_AND_MEAN",
            "+",
            "+#    include <winsock2.h>",
            "+",
            "+#    include <windows.h>",
            "+",
            "+#    include <ws2tcpip.h>",
            "+",
            "+#    define suseconds_t long",
            "+",
            " #else",
            "-    #include <arpa/inet.h>",
            "-    #include <errno.h>",
            "-    #include <netdb.h>",
            "-    #include <netinet/in.h>",
            "-    #include <sys/socket.h>",
            "-    #include <sys/time.h>",
            "-    #include <sys/types.h>",
            "-    #include <unistd.h>",
            "+#    include <arpa/inet.h>",
            "+#    include <errno.h>",
            "+#    include <netdb.h>",
            "+#    include <netinet/in.h>",
            "+#    include <sys/socket.h>",
            "+#    include <sys/time.h>",
            "+#    include <sys/types.h>",
            "+#    include <unistd.h>",
            " #endif",
            "-#include <stdio.h>",
            "-#include <stdlib.h>",
            "-#include <string.h>",
            "+",
            "+",
            " #include \"slice.h\"",
            " #include \"socket.h\"",
            " #include \"utils.h\"",
            "+#include <stdio.h>",
            "+#include <stdlib.h>",
            "+#include <string.h>",
            " ",
            " ",
            " /* lengths for socket read and write. */",
            "-#ifdef IS_MSVC",
            "-    typedef int sock_io_len_t;",
            "+#ifdef IS_WINDOWS",
            "+typedef SOCKET sock_io_len_t;",
            " #else",
            "-    typedef size_t sock_io_len_t;",
            "-    typedef struct timeval TIMEVAL;",
            "+typedef int SOCKET;",
            "+typedef size_t sock_io_len_t;",
            "+typedef struct timeval TIMEVAL;",
            " #endif",
            " ",
            " ",
            " #define LISTEN_QUEUE (10)",
            " ",
            "-int socket_open(const char *host, const char *port)",
            "-{",
            "-\t//int status;",
            "-\tstruct addrinfo addr_hints;",
            "-    struct addrinfo *addr_info = NULL;",
            "-\tint sock;",
            "-    int sock_opt = 0;",
            "-    int rc;",
            "+",
            "+socket_fd_result socket_open_tcp_client(const char *remote_host, const char *remote_port) {",
            "+    SOCKET sock = INVALID_SOCKET;",
            "+    int rc = 0;",
            "+    struct sockaddr_in serv_addr = {0};",
            "+    struct timeval timeout = {0};",
            "+    struct linger so_linger = {0};",
            " ",
            " #ifdef IS_WINDOWS",
            "-\t/* Windows needs special initialization. */",
            "-\tstatic WSADATA winsock_data;",
            "-\trc = WSAStartup(MAKEWORD(2, 2), &winsock_data);",
            "-",
            "-\tif (rc != NO_ERROR) {",
            "-\t\tinfo(\"WSAStartup failed with error: %d\\n\", rc);",
            "-\t\treturn SOCKET_ERR_STARTUP;",
            "-\t}",
            "+    /* Windows needs special initialization. */",
            "+    static WSADATA winsock_data;",
            "+    rc = WSAStartup(MAKEWORD(2, 2), &winsock_data);",
            "+",
            "+    if(rc != NO_ERROR) {",
            "+        info(\"WSAStartup failed with error: %d\\n\", rc);",
            "+        return socket_fd_result_err(SOCKET_ERR_STARTUP);",
            "+    }",
            " #endif",
            " ",
            "-    /*",
            "-     * Set up the hints for the type of socket that we want.",
            "-     */",
            "-",
            "-    /* make sure the whole struct is set to 0 bytes */",
            "-\tmemset(&addr_hints, 0, sizeof addr_hints);",
            "-",
            "-    /*",
            "-     * From the man page (node == host name here):",
            "-     *",
            "-     * \"If the AI_PASSIVE flag is specified in hints.ai_flags, and node is NULL, then",
            "-     * the returned socket addresses will be suitable for bind(2)ing a socket that",
            "-     * will  accept(2) connections.   The returned  socket  address  will  contain",
            "-     * the  \"wildcard  address\" (INADDR_ANY for IPv4 addresses, IN6ADDR_ANY_INIT for",
            "-     * IPv6 address).  The wildcard address is used by applications (typically servers)",
            "-     * that intend to accept connections on any of the host's network addresses.  If",
            "-     * node is not NULL, then the AI_PASSIVE flag is ignored.",
            "-     *",
            "-     * If the AI_PASSIVE flag is not set in hints.ai_flags, then the returned socket",
            "-     * addresses will be suitable for use with connect(2), sendto(2), or sendmsg(2).",
            "-     * If node is NULL, then the  network address  will  be  set  to the loopback",
            "-     * interface address (INADDR_LOOPBACK for IPv4 addresses, IN6ADDR_LOOPBACK_INIT for",
            "-     * IPv6 address); this is used by applications that intend to communicate with",
            "-     * peers running on the same host.\"",
            "-     *",
            "-     * So we can get away with just setting AI_PASSIVE.",
            "-     */",
            "-    addr_hints.ai_flags = AI_PASSIVE;",
            "-",
            "-    /* this allows for both IPv4 and IPv6 */",
            "-    addr_hints.ai_family = AF_UNSPEC;",
            "-",
            "-    /* we want a TCP socket.  And we want it now! */",
            "-    addr_hints.ai_socktype = SOCK_STREAM;",
            "-",
            "-    /* Get the address info about the local system, to be used later. */",
            "-    rc = getaddrinfo(host, port, &addr_hints, &addr_info);",
            "-    if (rc != 0) {",
            "-        info(\"ERROR: getaddrinfo() failed: %s\\n\", gai_strerror(rc));",
            "-        return SOCKET_ERR_OPEN;",
            "+    /* create the socket */",
            "+    sock = socket(AF_INET, SOCK_STREAM, 0 /* IP protocol */);",
            "+    if(sock == INVALID_SOCKET) {",
            "+        info(\"ERROR: socket() failed: %s\\n\", gai_strerror(sock));",
            "+        return socket_fd_result_err(SOCKET_ERR_CREATE);",
            "     }",
            " ",
            "-    /* finally, finally, finally, we get to open a socket! */",
            "-    sock = (int)socket(addr_info->ai_family, addr_info->ai_socktype, addr_info->ai_protocol);",
            "+#ifdef SO_NOSIGPIPE",
            "+    int sock_opt = 1;",
            " ",
            "-    if (sock < 0) {",
            "-        info(\"ERROR: socket() failed: %s\\n\", gai_strerror(sock));",
            "-        return SOCKET_ERR_CREATE;",
            "+    /* On *BSD and macOS, set the socket option to prevent SIGPIPE. */",
            "+    rc = setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, (char *)&sock_opt, sizeof(sock_opt));",
            "+    if(rc) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Setting SO_NOSIGPIPE on socket failed: %s\\n\", gai_strerror(rc));",
            "+        return socket_fd_result_err(SOCKET_ERR_SETOPT);",
            "     }",
            "+#endif",
            " ",
            "-    /* if this is going to be a server socket, bind it. */",
            "-    if(strcmp(host,\"0.0.0.0\") == 0) {",
            "-        info(\"socket_open() setting up server socket.   Binding to address 0.0.0.0.\");",
            "+    timeout.tv_sec = 10;",
            "+    timeout.tv_usec = 0;",
            " ",
            "-        rc = bind(sock, addr_info->ai_addr, (socklen_t)(unsigned int)addr_info->ai_addrlen);",
            "-        if (rc < 0)\t{",
            "-            printf(\"ERROR: Unable to bind() socket: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_BIND;",
            "-        }",
            "+    rc = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));",
            "+    if(rc) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Setting SO_RCVTIMEO on socket failed: %s\\n\", gai_strerror(rc));",
            "+        return socket_fd_result_err(SOCKET_ERR_SETOPT);",
            "+    }",
            " ",
            "-        rc = listen(sock, LISTEN_QUEUE);",
            "-        if(rc < 0) {",
            "-            info(\"ERROR: Unable to call listen() on socket: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_LISTEN;",
            "-        }",
            "+    rc = setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout));",
            "+    if(rc) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Setting SO_SNDTIMEO on socket failed: %s\\n\", gai_strerror(rc));",
            "+        return socket_fd_result_err(SOCKET_ERR_SETOPT);",
            "+    }",
            " ",
            "-        /* set up our socket to allow reuse if we crash suddenly. */",
            "-        sock_opt = 1;",
            "-        rc = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*)&sock_opt, sizeof(sock_opt));",
            "-        if(rc) {",
            "-            socket_close(sock);",
            "-            info(\"ERROR: Setting SO_REUSEADDR on socket failed: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_SETOPT;",
            "-        }",
            "-    } else {",
            "-        struct timeval timeout; /* used for timing out connections etc. */",
            "-        struct linger so_linger; /* used to set up short/no lingering after connections are close()ed. */",
            "+    /* abort the connection on close. */",
            "+    so_linger.l_onoff = 1;",
            "+    so_linger.l_linger = 0;",
            "+",
            "+    rc = setsockopt(sock, SOL_SOCKET, SO_LINGER, (char *)&so_linger, sizeof(so_linger));",
            "+    if(rc) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Setting SO_LINGER on socket failed: %s\\n\", gai_strerror(rc));",
            "+        return socket_fd_result_err(SOCKET_ERR_SETOPT);",
            "+    }",
            " ",
            "-#ifdef SO_NOSIGPIPE",
            "-        /* On *BSD and macOS, set the socket option to prevent SIGPIPE. */",
            "-        rc = setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, (char*)&sock_opt, sizeof(sock_opt));",
            "-        if(rc) {",
            "-            socket_close(sock);",
            "-            info (\"ERROR: Setting SO_REUSEADDR on socket failed: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_SETOPT;",
            "-        }",
            "+    serv_addr.sin_family = AF_INET;",
            "+    serv_addr.sin_port = htons((uint16_t)atoi(remote_port));",
            "+",
            "+    if((rc = inet_pton(AF_INET, remote_host, &serv_addr.sin_addr)) <= 0) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Getting IP address for remote server, %s, failed: %d\\n\", remote_host, rc);",
            "+        return socket_fd_result_err(SOCKET_ERR_BAD_PARAM);",
            "+    }",
            "+",
            "+    /* now connect to the remote server */",
            "+    if(connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr))) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Connecting to remote server, %s, failed: %d\\n\", remote_host, rc);",
            "+        return socket_fd_result_err(SOCKET_ERR_CONNECT);",
            "+    }",
            "+",
            "+    return socket_fd_result_val(sock);",
            "+}",
            "+",
            "+",
            "+socket_fd_result socket_open_tcp_server(const char *listening_port) {",
            "+    struct sockaddr_in address = {0};",
            "+    SOCKET sock = INVALID_SOCKET;",
            "+    SOCKET sock_opt = 0;",
            "+    int rc = 0;",
            "+",
            "+#ifdef IS_WINDOWS",
            "+    /* Windows needs special initialization. */",
            "+    static WSADATA winsock_data;",
            "+    rc = WSAStartup(MAKEWORD(2, 2), &winsock_data);",
            "+",
            "+    if(rc != NO_ERROR) {",
            "+        info(\"WSAStartup failed with error: %d\\n\", rc);",
            "+        return socket_fd_result_err(SOCKET_ERR_CREATE);",
            "+    }",
            " #endif",
            " ",
            "-        timeout.tv_sec = 10;",
            "-        timeout.tv_usec = 0;",
            "+    /* create the socket */",
            "+    sock = socket(AF_INET, SOCK_STREAM, 0 /* IP protocol */);",
            "+    if(sock == INVALID_SOCKET) {",
            "+        info(\"ERROR: socket() failed: %s\\n\", gai_strerror(sock));",
            "+        return socket_fd_result_err(SOCKET_ERR_BAD_PARAM);",
            "+    }",
            " ",
            "-        rc = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));",
            "-        if(rc) {",
            "-            socket_close(sock);",
            "-            info(\"ERROR: Setting SO_RCVTIMEO on socket failed: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_SETOPT;",
            "-        }",
            "+    address.sin_family = AF_INET;",
            "+    address.sin_addr.s_addr = INADDR_ANY;",
            "+    address.sin_port = htons((uint16_t)atoi(listening_port));",
            " ",
            "-        rc = setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout));",
            "-        if(rc) {",
            "-            socket_close(sock);",
            "-            info(\"ERROR: Setting SO_SNDTIMEO on socket failed: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_SETOPT;",
            "-        }",
            "+    info(\"socket_open() setting up server socket. Binding to address 0.0.0.0.\");",
            " ",
            "-        /* abort the connection on close. */",
            "-        so_linger.l_onoff = 1;",
            "-        so_linger.l_linger = 0;",
            "-",
            "-        rc = setsockopt(sock, SOL_SOCKET, SO_LINGER,(char*)&so_linger,sizeof(so_linger));",
            "-        if(rc) {",
            "-            socket_close(sock);",
            "-            info(\"ERROR: Setting SO_LINGER on socket failed: %s\\n\", gai_strerror(rc));",
            "-            return SOCKET_ERR_SETOPT;",
            "-        }",
            "+    rc = bind(sock, (struct sockaddr *)&address, (socklen_t)sizeof(address));",
            "+    if(rc < 0) {",
            "+        perror(\"Error from bind(): \");",
            "+        printf(\"ERROR: Unable to bind() socket: %d\\n\", rc);",
            "+        return socket_fd_result_err(SOCKET_ERR_BIND);",
            "     }",
            " ",
            "-    /* free the memory for the address info struct. */",
            "-    freeaddrinfo(addr_info);",
            "+    rc = listen(sock, LISTEN_QUEUE);",
            "+    if(rc < 0) {",
            "+        info(\"ERROR: Unable to call listen() on socket: %d\\n\", rc);",
            "+        return socket_fd_result_err(SOCKET_ERR_LISTEN);",
            "+    }",
            " ",
            "-    return sock;",
            "-}",
            "+    /* set up our socket to allow reuse if we crash suddenly. */",
            "+    sock_opt = 1;",
            "+    rc = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&sock_opt, sizeof(sock_opt));",
            "+    if(rc) {",
            "+        socket_close(sock);",
            "+        info(\"ERROR: Setting SO_REUSEADDR on socket failed: %s\\n\", gai_strerror(rc));",
            "+        return socket_fd_result_err(SOCKET_ERR_SETOPT);",
            "+    }",
            "+",
            "+    socket_fd_result result = socket_fd_result_val(sock);",
            " ",
            "+    return result;",
            "+}",
            " ",
            " ",
            "-void socket_close(int sock)",
            "-{",
            "-    if(sock >= 0) {",
            "+void socket_close(SOCKET sock) {",
            "+    if(sock > 0) {",
            " #ifdef IS_WINDOWS",
            "         closesocket(sock);",
            " #else",
            "         close(sock);",
            " #endif",
            "     }",
            " }",
            " ",
            " ",
            "-int socket_accept(int sock)",
            "-{",
            "+socket_fd_result socket_accept(SOCKET sock, uint32_t timeout_ms) {",
            "     fd_set accept_fd_set;",
            "-    TIMEVAL timeout; ",
            "+    TIMEVAL timeout;",
            "     int num_accept_ready = 0;",
            " ",
            "     /* set the timeout to zero */",
            "-    timeout.tv_sec = 0;",
            "-    timeout.tv_usec = 0;",
            "+    timeout.tv_sec = (time_t)(timeout_ms / 1000);",
            "+    timeout.tv_usec = (suseconds_t)((timeout_ms % 1000) * 1000);",
            " ",
            "     /* zero out the file descriptor set. */",
            "     FD_ZERO(&accept_fd_set);",
            " ",
            "     /* set our socket's bit in the set. */",
            "     FD_SET(sock, &accept_fd_set);",
            " ",
            "     /* do a select to see if anything is ready to accept. */",
            "-    num_accept_ready = select(sock+1, &accept_fd_set, NULL, NULL, &timeout);",
            "-    if (num_accept_ready > 0) {",
            "+    num_accept_ready = select((int)(unsigned int)sock + 1, &accept_fd_set, NULL, NULL, &timeout);",
            "+    if(num_accept_ready > 0) {",
            "+        SOCKET client_fd = INVALID_SOCKET;",
            "+",
            "         info(\"Ready to accept on %d sockets.\", num_accept_ready);",
            "-        if (FD_ISSET(sock, &accept_fd_set)) {",
            "-            return (int)accept(sock, NULL, NULL);",
            "+",
            "+        client_fd = accept(sock, NULL, NULL);",
            "+        if(client_fd == INVALID_SOCKET) {",
            "+            return socket_fd_result_err(SOCKET_ERR_ACCEPT);",
            "+        } else {",
            "+            return socket_fd_result_val(client_fd);",
            "         }",
            "-    } else if (num_accept_ready < 0) {",
            "+    } else if(num_accept_ready < 0) {",
            "         info(\"Error selecting the listen socket!\");",
            "-        return SOCKET_ERR_SELECT;",
            "-    } ",
            "-",
            "-    return SOCKET_STATUS_OK;",
            "+        return socket_fd_result_err(SOCKET_ERR_SELECT);",
            "+    } else {",
            "+        /* no client connection, timeout */",
            "+        return socket_fd_result_err(SOCKET_ERR_TIMEOUT);",
            "+    }",
            " }",
            " ",
            " ",
            "-slice_s socket_read(int sock, slice_s in_buf)",
            "-{",
            "-#ifdef IS_WINDOWS",
            "-    int rc = (int)recv(sock, (char *)in_buf.data, (int)in_buf.len, 0);",
            "-#else",
            "-    int rc = (int)recv(sock, (char *)in_buf.data, (size_t)in_buf.len, 0);",
            "-#endif ",
            "+socket_slice_result socket_read(SOCKET sock, slice_s in_buf, uint32_t timeout_ms) {",
            "+    fd_set read_fd_set;",
            "+    TIMEVAL timeout;",
            "+    int num_read_ready = 0;",
            " ",
            "-    if(rc < 0) {",
            "+    /* set the timeout to zero */",
            "+    timeout.tv_sec = (time_t)(timeout_ms / 1000);",
            "+    timeout.tv_usec = (suseconds_t)((timeout_ms % 1000) * 1000);",
            "+",
            "+    /* zero out the file descriptor set. */",
            "+    FD_ZERO(&read_fd_set);",
            "+",
            "+    /* set our socket's bit in the set. */",
            "+    FD_SET(sock, &read_fd_set);",
            "+",
            "+    /* do a select to see if anything is ready to read. */",
            "+    num_read_ready = select((int)(unsigned int)sock + 1, &read_fd_set, NULL, NULL, &timeout);",
            "+    if(num_read_ready > 0) {",
            "+        int rc = 0;",
            " #ifdef IS_WINDOWS",
            "-        rc = WSAGetLastError();",
            "-        if(rc == WSAEWOULDBLOCK) {",
            "+        rc = (int)recv(sock, (char *)slice_get_bytes(in_buf, 0), (int)slice_len(in_buf), 0);",
            " #else",
            "-        rc = errno;",
            "-        if(rc == EAGAIN || rc == EWOULDBLOCK) {",
            "+        rc = (int)recv(sock, (char *)slice_get_bytes(in_buf, 0), (size_t)slice_len(in_buf), 0);",
            " #endif",
            "-            rc = 0;",
            "+        if(rc > 0) {",
            "+            return socket_slice_result_val(slice_from_slice(in_buf, 0, (size_t)(unsigned int)rc));",
            "+        } else if(rc == 0) {",
            "+            /* socket is closed. */",
            "+            info(\"Unable to read.  The socket is closed.\");",
            "+            return socket_slice_result_err(SOCKET_ERR_EOF);",
            "         } else {",
            "-            info(\"Socket read error rc=%d.\\n\", rc);",
            "-            rc = SOCKET_ERR_READ;",
            "+#ifdef IS_WINDOWS",
            "+            rc = WSAGetLastError();",
            "+            if(rc == WSAEWOULDBLOCK) {",
            "+#else",
            "+            rc = errno;",
            "+            if(rc == EAGAIN || rc == EWOULDBLOCK) {",
            "+#endif",
            "+                /* the read was interrupted.  We will return as if it was a timeout. */",
            "+                info(\"Read interrupted.\");",
            "+                return socket_slice_result_err(SOCKET_ERR_TIMEOUT);",
            "+            } else {",
            "+                info(\"Socket read error rc=%d.\\n\", rc);",
            "+                return socket_slice_result_err(SOCKET_ERR_READ);",
            "+            }",
            "         }",
            "+    } else if(num_read_ready == 0) {",
            "+        /* num_read_ready sockets is zero, so we timed out. */",
            "+        info(\"Timeout waiting for data to read.\");",
            "+        return socket_slice_result_err(SOCKET_ERR_TIMEOUT);",
            "+    } else {",
            "+        info(\"Socket select error trying to read!\\n\");",
            "+        return socket_slice_result_err(SOCKET_ERR_SELECT);",
            "     }",
            "-",
            "-    return ((rc>=0) ? slice_from_slice(in_buf, 0, (size_t)(unsigned int)rc) : slice_make_err(rc));",
            " }",
            " ",
            " ",
            " /* this blocks until all the data is written or there is an error. */",
            "-int socket_write(int sock, slice_s out_buf)",
            "-{",
            "-    size_t total_bytes_written = 0;",
            "-    int rc = 0;",
            "-    slice_s tmp_out_buf = out_buf;",
            "+socket_slice_result socket_write(SOCKET sock, slice_s out_buf, uint32_t timeout_ms) {",
            "+    fd_set write_fd_set;",
            "+    TIMEVAL timeout;",
            "+    int num_write_ready = 0;",
            " ",
            "-    info(\"socket_write(): writing packet:\");",
            "-    slice_dump(out_buf);",
            "+    /* set the timeout to zero */",
            "+    timeout.tv_sec = (time_t)(timeout_ms / 1000);",
            "+    timeout.tv_usec = (suseconds_t)((timeout_ms % 1000) * 1000);",
            " ",
            "-    do {",
            "+    /* zero out the file descriptor set. */",
            "+    FD_ZERO(&write_fd_set);",
            "+",
            "+    /* set our socket's bit in the set. */",
            "+    FD_SET(sock, &write_fd_set);",
            "+",
            "+    /* do a select to see if anything is ready to write. */",
            "+    num_write_ready = select((int)(unsigned int)sock + 1, NULL, &write_fd_set, NULL, &timeout);",
            "+    if(num_write_ready > 0) {",
            "+        int rc = 0;",
            " #ifdef IS_WINDOWS",
            "-        rc = (int)send(sock, (char *)tmp_out_buf.data, (int)tmp_out_buf.len, 0);",
            "+        rc = (int)send(sock, (char *)slice_get_bytes(out_buf, 0), (int)slice_len(out_buf), 0);",
            " #else",
            "-        rc = (int)send(sock, (char *)tmp_out_buf.data, (size_t)tmp_out_buf.len, 0);",
            "+        rc = (int)send(sock, (char *)slice_get_bytes(out_buf, 0), (size_t)slice_len(out_buf), MSG_NOSIGNAL);",
            " #endif",
            "-",
            "-        /* was there an error? */",
            "-        if(rc < 0) {",
            "-            /*",
            "-             * check the return value.  If it is an interrupted system call",
            "-             * or would block, just keep looping.",
            "-             */",
            "+        if(rc >= 0) {",
            "+            return socket_slice_result_val(",
            "+                slice_from_slice(out_buf, (size_t)(unsigned int)rc, (size_t)(slice_len(out_buf) - (size_t)(unsigned int)rc)));",
            "+        } else if(rc == 0) {",
            "+            /* socket is closed. */",
            "+            info(\"Unable to write.  The socket is closed.\");",
            "+            return socket_slice_result_err(SOCKET_ERR_EOF);",
            "+        } else {",
            " #ifdef IS_WINDOWS",
            "             rc = WSAGetLastError();",
            "-            if(rc != WSAEWOULDBLOCK) {",
            "+            if(rc == WSAEWOULDBLOCK) {",
            " #else",
            "             rc = errno;",
            "-            if(rc != EAGAIN && rc != EWOULDBLOCK) {",
            "+            if(rc == EAGAIN || rc == EWOULDBLOCK) {",
            " #endif",
            "+                /* the write was interrupted.  We will return as if it was a timeout. */",
            "+                info(\"write interrupted.\");",
            "+                return socket_slice_result_err(SOCKET_ERR_TIMEOUT);",
            "+            } else {",
            "                 info(\"Socket write error rc=%d.\\n\", rc);",
            "-                return SOCKET_ERR_WRITE;",
            "+                return socket_slice_result_err(SOCKET_ERR_WRITE);",
            "             }",
            "-        } else {",
            "-            total_bytes_written += (size_t)rc;",
            "-            tmp_out_buf = slice_from_slice(out_buf, total_bytes_written, slice_len(out_buf) - total_bytes_written);",
            "         }",
            "-    } while(total_bytes_written < slice_len(out_buf));",
            "-",
            "-    return (int)(unsigned int)total_bytes_written;",
            "+    } else if(num_write_ready == 0) {",
            "+        /* num_write_ready sockets is zero, so we timed out. */",
            "+        info(\"Timeout waiting for data to write.\");",
            "+        return socket_slice_result_err(SOCKET_ERR_TIMEOUT);",
            "+    } else {",
            "+        info(\"Socket select error trying to write!\\n\");",
            "+        return socket_slice_result_err(SOCKET_ERR_SELECT);",
            "+    }",
            " }",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/socket.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/socket.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/socket.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -29,29 +29,50 @@",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            " #pragma once",
            " ",
            "+#include \"compat.h\"",
            "+",
            "+#include \"result.h\"",
            " #include \"slice.h\"",
            " ",
            "+#include <stdint.h>",
            "+",
            " typedef enum {",
            "-    SOCKET_STATUS_OK    = -1,",
            "-    SOCKET_ERR_STARTUP  = -2,",
            "-    SOCKET_ERR_OPEN     = -3,",
            "-    SOCKET_ERR_CREATE   = -4,",
            "-    SOCKET_ERR_BIND     = -5,",
            "-    SOCKET_ERR_LISTEN   = -6,",
            "-    SOCKET_ERR_SETOPT   = -7,",
            "-    SOCKET_ERR_READ     = -8,",
            "-    SOCKET_ERR_WRITE    = -9,",
            "-    SOCKET_ERR_SELECT   = -10,",
            "-    SOCKET_ERR_ACCEPT   = -11",
            "+    SOCKET_STATUS_OK = 0,",
            "+    SOCKET_ERR_ACCEPT,",
            "+    SOCKET_ERR_BAD_PARAM,",
            "+    SOCKET_ERR_BIND,",
            "+    SOCKET_ERR_CONNECT,",
            "+    SOCKET_ERR_CREATE,",
            "+    SOCKET_ERR_EOF,",
            "+    SOCKET_ERR_LISTEN,",
            "+    SOCKET_ERR_OPEN,",
            "+    SOCKET_ERR_READ,",
            "+    SOCKET_ERR_SELECT,",
            "+    SOCKET_ERR_SETOPT,",
            "+    SOCKET_ERR_STARTUP,",
            "+    SOCKET_ERR_TIMEOUT,",
            "+    SOCKET_ERR_WRITE",
            " } socket_err_t;",
            " ",
            "-extern int socket_open(const char *host, const char *port);",
            "-extern void socket_close(int sock);",
            "-extern int socket_accept(int sock);",
            "-extern slice_s socket_read(int sock, slice_s in_buf);",
            "-extern int socket_write(int sock, slice_s out_buf);",
            "+#ifndef IS_WINDOWS",
            "+typedef int SOCKET;",
            "+#    define INVALID_SOCKET (-1)",
            "+#else",
            "+#    include <winsock2.h>",
            "+#endif",
            "+",
            "+RESULT_DEF(socket_fd_result, SOCKET)",
            "+",
            "+RESULT_DEF(socket_slice_result, slice_s)",
            "+",
            " ",
            "+extern socket_fd_result socket_open_tcp_client(const char *remote_host, const char *remote_port);",
            "+extern socket_fd_result socket_open_tcp_server(const char *listening_port);",
            "+extern void socket_close(SOCKET sock);",
            "+extern socket_fd_result socket_accept(SOCKET sock, uint32_t timeout_ms);",
            "+extern socket_slice_result socket_read(SOCKET sock, slice_s in_buf, uint32_t timeout_ms);",
            "+extern socket_slice_result socket_write(SOCKET sock, slice_s out_buf, uint32_t timeout_ms);"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/tcp_server.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/tcp_server.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/tcp_server.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,140 +27,218 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include <stdbool.h>",
            "-#include <stdint.h>",
            "-#include <limits.h>",
            "-#include <stdlib.h>",
            "+#include \"tcp_server.h\"",
            " #include \"slice.h\"",
            " #include \"socket.h\"",
            "-#include \"tcp_server.h\"",
            "+#include \"thread.h\"",
            " #include \"utils.h\"",
            "+#include <limits.h>",
            "+#include <stdbool.h>",
            "+#include <stdint.h>",
            "+#include <stdlib.h>",
            "+",
            "+",
            "+static THREAD_FUNC(conn_handler);",
            "+",
            " ",
            " struct tcp_server {",
            "-    int sock_fd;",
            "-    slice_s buffer;",
            "+    SOCKET sock_fd;",
            "     slice_s (*handler)(slice_s input, slice_s output, void *context);",
            "     void *context;",
            "+    size_t context_size;",
            "+};",
            "+",
            "+struct client_session {",
            "+    SOCKET client_fd;",
            "+    tcp_server_p server;",
            "+    void *server_context;",
            "+    bool *server_done;",
            "+    slice_s buffer;",
            "+    thread_p thread;",
            " };",
            "+typedef struct client_session *client_session_p;",
            " ",
            " ",
            "-tcp_server_p tcp_server_create(const char *host, const char *port, slice_s buffer, slice_s (*handler)(slice_s input, slice_s output, void *context), void *context)",
            "-{",
            "+tcp_server_p tcp_server_create(const char *host, const char *port,",
            "+                               slice_s (*handler)(slice_s input, slice_s output, void *context), void *context,",
            "+                               size_t context_size) {",
            "     tcp_server_p server = calloc(1, sizeof(*server));",
            " ",
            "+    (void)host;",
            "+",
            "     if(server) {",
            "-        server->sock_fd = socket_open(host, port);",
            "+        socket_fd_result sock_res = socket_open_tcp_server(port);",
            " ",
            "-        if(server->sock_fd < 0) {",
            "-            error(\"ERROR: Unable to open TCP socket, error code %d!\", server->sock_fd);",
            "+        if(socket_fd_result_is_val(sock_res)) {",
            "+            server->sock_fd = socket_fd_result_get_val(sock_res);",
            "+        } else {",
            "+            error(\"ERROR: Unable to open TCP socket, error code %d!\", socket_fd_result_get_err(sock_res));",
            "         }",
            " ",
            "-        server->buffer = buffer;",
            "         server->handler = handler;",
            "         server->context = context;",
            "+        server->context_size = context_size;",
            "     }",
            " ",
            "     return server;",
            " }",
            " ",
            "-void tcp_server_start(tcp_server_p server, volatile sig_atomic_t *terminate)",
            "-{",
            "-    int client_fd;",
            "-    bool done = false;",
            "+void tcp_server_start(tcp_server_p server, volatile sig_atomic_t *terminate) {",
            "+    static bool done; /* static so it doesn't go out of scope, since it's passed to sub-threads. */",
            "+    done = false;     /* initialised every invocation for logic sake, even though that's once. */",
            " ",
            "     info(\"Waiting for new client connection.\");",
            " ",
            "     do {",
            "-        client_fd = socket_accept(server->sock_fd);",
            "+        socket_fd_result sock_res = socket_accept(server->sock_fd, 1000); /* MAGIC */",
            " ",
            "-        if(client_fd >= 0) {",
            "-            slice_s tmp_input = server->buffer;",
            "-            slice_s tmp_output;",
            "-            int rc;",
            "+        if(socket_fd_result_is_val(sock_res)) {",
            "+            SOCKET client_fd = socket_fd_result_get_val(sock_res);",
            "+            struct client_session *session = NULL;",
            "+",
            "+            /* The client thread is responsible for freeing these */",
            "+            /* TODO: A malloc'ed blob inside a malloc'ed blob is too much. Simplify. */",
            "+            // FIXME - combine the allocations and use calloc or memset to get zeroed memory",
            "+            session = malloc(sizeof(struct client_session));",
            "+",
            "+            if(!session) { error(\"Unable to allocate memory for the session!\"); }",
            "+",
            "+            // NOLINTNEXTLINE",
            "+            memset(session, 0, sizeof(*session));",
            "+",
            "+            session->server_context = malloc(server->context_size);",
            "+",
            "+            if(!session->server_context) { error(\"Unable to allocate memory for the server context!\"); }",
            "+",
            "+            /* Make a copy of the server context so the thread can use it without threading concerns. */",
            "+            // NOLINTNEXTLINE",
            "+            memcpy(session->server_context, server->context, server->context_size);",
            "+            session->client_fd = client_fd; /* copy of a temporary value - no thread safety concerns */",
            "+            session->server = server;       /* reference to a long-lived struct, which has values and the original context */",
            "+            session->server_done = &done;   /* reference to a flag that any thread can raise (and all must monitor) */",
            "+",
            "+            if(thread_create(&(session->thread), conn_handler, 10 * 1024, session) != THREAD_STATUS_OK) {",
            "+                error(\"ERROR: Unable to create connection handler thread!\");",
            "+            }",
            "+        } else if(socket_fd_result_get_err(sock_res) == SOCKET_ERR_TIMEOUT) {",
            "+            info(\"Timed out waiting for new client connection.\");",
            "+            continue;",
            "+        } else {",
            "+            error(\"ERROR: Received error, %d, accepting new client connection!\", socket_fd_result_get_err(sock_res));",
            "+            done = true;",
            "+        }",
            " ",
            "-            info(\"Got new client connection, going into processing loop.\");",
            "+        /* give back the CPU. */",
            "+        system_yield();",
            "+    } while(!done && !*terminate);",
            " ",
            "-            do {",
            "-                rc = TCP_SERVER_PROCESSED;",
            "+    /* in case we were terminated by signal, raise the done flag for all the threads to exit */",
            "+    done = true;",
            "+}",
            " ",
            "-                /* get an incoming packet or a partial packet. */",
            "-                tmp_input = socket_read(client_fd, tmp_input);",
            " ",
            "-                if((rc = slice_has_err(tmp_input))) {",
            "-                    info(\"WARN: error response reading socket! error %d\", rc);",
            "-                    rc = TCP_SERVER_DONE;",
            "-                    break;",
            "-                }",
            "+void tcp_server_destroy(tcp_server_p server) {",
            "+    if(server) {",
            "+        if(server->sock_fd != INVALID_SOCKET) {",
            "+            socket_close(server->sock_fd);",
            "+            server->sock_fd = INVALID_SOCKET;",
            "+        }",
            "+        free(server);",
            "+    }",
            "+}",
            "+",
            "+",
            "+THREAD_FUNC(conn_handler) {",
            "+    client_session_p session = arg;",
            "+    uint8_t buf[65536 + 128];                            /* Rockwell supports up to 64k (Micro800) */",
            "+    tcp_server_p server = (tcp_server_p)session->server; /* need to cast for C++ */",
            "+    slice_s tmp_input = {0};",
            "+    slice_s tmp_output = {0};",
            "+    int rc = TCP_SERVER_DONE;",
            "+",
            "+    info(\"Got new client connection, going into processing loop.\");",
            "+",
            "+    /* no one will join this thread, so clean ourselves up. */",
            "+    thread_detach();",
            " ",
            "-                /* try to process the packet. */",
            "-                tmp_output = server->handler(tmp_input, server->buffer, server->context);",
            "+    session->buffer = slice_make(buf, sizeof(buf));",
            "+    tmp_input = session->buffer;",
            " ",
            "-                /* check the response. */",
            "-                if(!slice_has_err(tmp_output)) {",
            "-                    /* FIXME - this should be in a loop to make sure all data is pushed. */",
            "-                    rc = socket_write(client_fd, tmp_output);",
            "-",
            "-                    /* error writing? */",
            "-                    if(rc < 0) {",
            "-                        info(\"ERROR: error writing output packet! Error: %d\", rc);",
            "-                        rc = TCP_SERVER_DONE;",
            "-                        break;",
            "-                    } else {",
            "-                        /* all good. Reset the buffers etc. */",
            "-                        tmp_input = server->buffer;",
            "-                        rc = TCP_SERVER_PROCESSED;",
            "-                    }",
            "-                } else {",
            "-                    /* there was some sort of error or exceptional condition. */",
            "-                    switch((rc = slice_get_err(tmp_input))) {",
            "-                        case TCP_SERVER_DONE:",
            "-                            done = true;",
            "-                            break;",
            "-",
            "-                        case TCP_SERVER_INCOMPLETE:",
            "-                            tmp_input = slice_from_slice(server->buffer, slice_len(tmp_input), slice_len(server->buffer) - slice_len(tmp_input));",
            "-                            break;",
            "-",
            "-                        case TCP_SERVER_PROCESSED:",
            "-                            break;",
            "-",
            "-                        case TCP_SERVER_UNSUPPORTED:",
            "-                            info(\"WARN: Unsupported packet!\");",
            "-                            slice_dump(tmp_input);",
            "-                            break;",
            "-",
            "-                        default:",
            "-                            info(\"WARN: Unsupported return code %d!\", rc);",
            "-                            break;",
            "-                    }",
            "-                }",
            "-            } while(rc == TCP_SERVER_INCOMPLETE || rc == TCP_SERVER_PROCESSED);",
            "-",
            "-            /* done with the socket */",
            "-            socket_close(client_fd);",
            "-        } else if (client_fd != SOCKET_STATUS_OK) {",
            "-            /* There was an error either opening or accepting! */",
            "-            info(\"WARN: error while trying to open/accept the client socket.\");",
            "+    do {",
            "+        socket_slice_result slice_res = socket_read(session->client_fd, tmp_input, 1000); /* MAGIC */",
            "+",
            "+        if(socket_slice_result_is_err(slice_res)) {",
            "+            if(socket_slice_result_get_err(slice_res) == SOCKET_ERR_TIMEOUT) {",
            "+                info(\"Timed out waiting for client to send us a request.\");",
            "+                continue;",
            "+            } else {",
            "+                info(\"Error, %d, reading data from the client!\", socket_slice_result_get_err(slice_res));",
            "+                break;",
            "+            }",
            "         }",
            " ",
            "-        /* wait a bit to give back the CPU. */",
            "-        util_sleep_ms(1);",
            "-    } while(!done && !*terminate);",
            "-}",
            "+        /* get an incoming packet or a partial packet. */",
            "+        tmp_input = socket_slice_result_get_val(slice_res);",
            " ",
            "+        if(slice_has_err(tmp_input)) {",
            "+            info(\"WARN: error response reading socket! error %d\", slice_get_err(tmp_input));",
            "+            break;",
            "+        }",
            " ",
            "+        /* try to process the packet. */",
            "+        /* FIXME - convert to RESULT types */",
            "+        tmp_output = server->handler(tmp_input, session->buffer, session->server_context);",
            "+",
            "+        /* check the response. */",
            "+        if(!slice_has_err(tmp_output)) {",
            "+            socket_slice_result write_res = socket_write(session->client_fd, tmp_output, 1000); /* MAGIC*/",
            "+",
            "+            if(socket_slice_result_is_err(write_res)) {",
            "+                info(\"Error, %d, writing packet!\", socket_slice_result_get_err(write_res));",
            "+                break;",
            "+            }",
            "+",
            "+            /* all good. Reset the buffers etc. */",
            "+            tmp_input = session->buffer;",
            "+            rc = TCP_SERVER_PROCESSED;",
            "+        } else {",
            "+            /* there was some sort of error or exceptional condition. */",
            "+            switch((rc = slice_get_err(tmp_output))) {",
            "+                case TCP_SERVER_DONE:",
            "+                    /* Note this is assumed atomic, which is not guaranteed. To be really sure it",
            "+                       should be mutex protected or changed to a stdatomic. The former is messy",
            "+                       and the latter requires C11. Since I think it might be actually a bug (why",
            "+                       would deregistering a session kill the server?) I've not bothered for now. */",
            "+                    *(session->server_done) = true;",
            "+                    break;",
            " ",
            "-void tcp_server_destroy(tcp_server_p server)",
            "-{",
            "-    if(server) {",
            "-        if(server->sock_fd >= 0) {",
            "-            socket_close(server->sock_fd);",
            "-            server->sock_fd = INT_MIN;",
            "+                case TCP_SERVER_INCOMPLETE:",
            "+                    tmp_input = slice_from_slice(session->buffer, slice_len(tmp_input),",
            "+                                                 slice_len(session->buffer) - slice_len(tmp_input));",
            "+                    break;",
            "+",
            "+                case TCP_SERVER_PROCESSED: break;",
            "+",
            "+                case TCP_SERVER_UNSUPPORTED:",
            "+                    info(\"WARN: Unsupported packet!\");",
            "+                    slice_dump(tmp_input);",
            "+                    break;",
            "+",
            "+                default: info(\"WARN: Unsupported return code %d!\", rc); break;",
            "+            }",
            "         }",
            "-        free(server);",
            "-    }",
            "+    } while((rc == TCP_SERVER_INCOMPLETE || rc == TCP_SERVER_PROCESSED)",
            "+            && (*(session->server_done) != true)); /* make sure another thread hasn't killed the server */",
            "+",
            "+    socket_close(session->client_fd);",
            "+",
            "+    /* see tcp_server_start() where these are malloc'ed for us */",
            "+    free(session->server_context);",
            "+    free(session);",
            "+",
            "+    THREAD_RETURN(0);",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/tcp_server.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/tcp_server.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/tcp_server.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -43,11 +43,10 @@",
            "     TCP_SERVER_DONE = 100003,",
            "     TCP_SERVER_BAD_REQUEST = 100004,",
            "     TCP_SERVER_UNSUPPORTED = 100005",
            " } tcp_server_status_t;",
            " ",
            " typedef struct tcp_server *tcp_server_p;",
            " ",
            "-extern tcp_server_p tcp_server_create(const char *host, const char *port, slice_s buffer, slice_s (*handler)(slice_s input, slice_s output, void *context), void *context);",
            "+extern tcp_server_p tcp_server_create(const char *host, const char *port, slice_s (*handler)(slice_s input, slice_s output, void *context), void *context, size_t context_size);",
            " extern void tcp_server_start(tcp_server_p server, volatile sig_atomic_t *terminate);",
            " extern void tcp_server_destroy(tcp_server_p server);",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/utils.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/utils.c",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/utils.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,205 +27,264 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "+#include \"utils.h\"",
            "+#include \"compat.h\"",
            "+#include <errno.h>",
            "+#include <stdarg.h>",
            " #include <stdio.h>",
            " #include <stdlib.h>",
            "-#include <time.h>",
            "-#include <stdarg.h>",
            " #include <string.h>",
            "-#include <errno.h>",
            "+#include <time.h>",
            "+",
            "+",
            "+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || (__linux__)",
            "+#    define USE_ARC4RANDOM",
            "+#    define PLATFORM_POSIX",
            "+",
            "+#    include <arpa/inet.h>",
            "+#    include <netdb.h>",
            "+#    include <netinet/in.h>",
            "+#    include <stdlib.h>",
            "+#    include <sys/socket.h>",
            "+#    include <sys/time.h>",
            "+#    include <sys/types.h>",
            "+#    include <unistd.h>",
            "+",
            "+#elif defined(_WIN32) || defined(_WIN64)",
            "+#    define USE_BCRYPTGENRANDOM",
            "+#    define PLATFORM_WINDOWS",
            "+",
            "+/* Windows include file order is important! */",
            "+#    include <Winsock2.h>",
            "+#    include <Windows.h>",
            "+#    include <Ws2tcpip.h>",
            "+#    include <io.h>",
            "+#    include <tchar.h>",
            "+#    include <strsafe.h>",
            "+#    include <wincrypt.h>",
            " ",
            "-#if defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64)",
            "-    #define _WINSOCKAPI_",
            "-    #include <windows.h>",
            "-    #include <tchar.h>",
            "-    #include <strsafe.h>",
            "-    #include <io.h>",
            "-    #include <Winsock2.h>",
            "-    #include <Ws2tcpip.h>",
            " #else",
            "-    /* assume it is POSIX of some sort... */",
            "-    #include <sys/time.h>",
            "-    #include <sys/types.h>",
            "-    #include <sys/socket.h>",
            "-    #include <netinet/in.h>",
            "-    #include <arpa/inet.h>",
            "-    #include <unistd.h>",
            "-    #include <netdb.h>",
            "+#    error \"Platform does not support good random function!\"",
            " #endif",
            " ",
            "-#include \"utils.h\"",
            "-",
            " ",
            " /*",
            "  * This contains the utilities used by the test harness.",
            "  */",
            " ",
            " ",
            "-#ifdef IS_WINDOWS",
            "+#ifdef PLATFORM_WINDOWS",
            " ",
            "-int util_sleep_ms(int ms)",
            "-{",
            "-    Sleep(ms);",
            "+int util_sleep_ms(int ms) {",
            "+    if(ms <= 0) { return 1; }",
            "+",
            "+    Sleep((DWORD)(unsigned int)ms);",
            "     return 1;",
            " }",
            " ",
            " #else",
            " ",
            "-int util_sleep_ms(int ms)",
            "-{",
            "+int util_sleep_ms(int ms) {",
            "     struct timeval tv;",
            " ",
            "-    tv.tv_sec = ms/1000;",
            "-    tv.tv_usec = (ms % 1000)*1000;",
            "+    tv.tv_sec = ms / 1000;",
            "+    tv.tv_usec = (ms % 1000) * 1000;",
            " ",
            "-    return select(0,NULL,NULL,NULL, &tv);",
            "+    return select(0, NULL, NULL, NULL, &tv);",
            " }",
            " ",
            " #endif",
            " ",
            " ",
            " /*",
            "  * time_ms",
            "  *",
            "  * Return the current epoch time in milliseconds.",
            "  */",
            " ",
            "-#ifdef IS_WINDOWS",
            "-int64_t util_time_ms(void)",
            "-{",
            "+#ifdef PLATFORM_WINDOWS",
            "+int64_t util_time_ms(void) {",
            "     FILETIME ft;",
            "     int64_t res;",
            " ",
            "     GetSystemTimeAsFileTime(&ft);",
            " ",
            "     /* calculate time as 100ns increments since Jan 1, 1601. */",
            "     res = (int64_t)(ft.dwLowDateTime) + ((int64_t)(ft.dwHighDateTime) << 32);",
            " ",
            "     /* get time in ms */",
            " ",
            "     res = res / 10000;",
            " ",
            "-    return  res;",
            "+    return res;",
            " }",
            " ",
            " #else",
            " ",
            " ",
            "-int64_t util_time_ms(void)",
            "-{",
            "+int64_t util_time_ms(void) {",
            "     struct timeval tv;",
            " ",
            "-    gettimeofday(&tv,NULL);",
            "+    gettimeofday(&tv, NULL);",
            " ",
            "-    return  ((int64_t)tv.tv_sec*1000)+ ((int64_t)tv.tv_usec/1000);",
            "+    return ((int64_t)tv.tv_sec * 1000) + ((int64_t)tv.tv_usec / 1000);",
            " }",
            " ",
            "-#endif ",
            "+#endif",
            " ",
            "+#ifdef PLATFORM_WINDOWS",
            "+void system_yield(void) { SwitchToThread(); }",
            "+#else",
            "+#    include <sched.h>",
            "+void system_yield(void) { sched_yield(); }",
            "+#endif",
            " ",
            " /*",
            "  * string helpers",
            "  */",
            " ",
            "-int match_chars(const char* source, int start_index, const char* chars)",
            "-{",
            "+int match_chars(const char *source, int start_index, const char *chars) {",
            "     return (int)(unsigned int)strspn(source + start_index, chars);",
            " }",
            " ",
            " ",
            " /*",
            "  * Logging routines.",
            "  */",
            " ",
            " static bool debug_is_on = false;",
            " ",
            " ",
            "-void debug_on(void)",
            "-{",
            "-    debug_is_on = true;",
            "-}",
            "-",
            "-void debug_off(void)",
            "-{",
            "-    debug_is_on = false;",
            "-}",
            "+void debug_on(void) { debug_is_on = true; }",
            " ",
            "+void debug_off(void) { debug_is_on = false; }",
            " ",
            " ",
            "-void error_impl(const char *func, int line, const char *templ, ...)",
            "-{",
            "+void error_impl(const char *func, int line, const char *templ, ...) {",
            "     va_list va;",
            " ",
            "     /* print it out. */",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"ERROR %s:%d \", func, line);",
            "-    va_start(va,templ);",
            "-    vfprintf(stderr,templ,va);",
            "+    va_start(va, templ);",
            "+    vfprintf(stderr, templ, va);",
            "     va_end(va);",
            "-    fprintf(stderr,\"\\n\");",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"\\n\");",
            " ",
            "     exit(1);",
            " }",
            " ",
            " ",
            "-",
            "-void info_impl(const char *func, int line, const char *templ, ...)",
            "-{",
            "+void info_impl(const char *func, int line, const char *templ, ...) {",
            "     va_list va;",
            " ",
            "-    if(!debug_is_on) {",
            "-        return;",
            "-    }",
            "+    if(!debug_is_on) { return; }",
            " ",
            "     /* print it out. */",
            "+    // NOLINTNEXTLINE",
            "     fprintf(stderr, \"INFO %s:%d \", func, line);",
            "-    va_start(va,templ);",
            "-    vfprintf(stderr,templ,va);",
            "+    va_start(va, templ);",
            "+    vfprintf(stderr, templ, va);",
            "     va_end(va);",
            "-    fprintf(stderr,\"\\n\");",
            "+    // NOLINTNEXTLINE",
            "+    fprintf(stderr, \"\\n\");",
            " }",
            " ",
            " ",
            " #define COLUMNS (size_t)(10)",
            " ",
            "-void slice_dump(slice_s s)",
            "-{",
            "+void slice_dump(slice_s s) {",
            "     size_t max_row, row, column;",
            "     char row_buf[300]; /* MAGIC */",
            " ",
            "-    if(!debug_is_on) {",
            "-        return;",
            "-    }",
            "+    if(!debug_is_on) { return; }",
            " ",
            "     /* determine the number of rows we will need to print. */",
            "-    max_row = (slice_len(s)  + (COLUMNS - 1))/COLUMNS;",
            "+    max_row = (slice_len(s) + (COLUMNS - 1)) / COLUMNS;",
            " ",
            "     for(row = 0; row < max_row; row++) {",
            "         size_t offset = (row * COLUMNS);",
            "         size_t row_offset;",
            " ",
            "         /* print the prefix and address */",
            "-        row_offset = (size_t)snprintf(&row_buf[0], sizeof(row_buf),\"%03zu\", offset);",
            "+        // NOLINTNEXTLINE",
            "+        row_offset = (size_t)snprintf(&row_buf[0], sizeof(row_buf), \"%03zu\", offset);",
            " ",
            "-        for(column = 0; column < COLUMNS && ((row * COLUMNS) + column) < slice_len(s) && row_offset < (int)sizeof(row_buf); column++) {",
            "+        for(column = 0; column < COLUMNS && ((row * COLUMNS) + column) < slice_len(s) && row_offset < (int)sizeof(row_buf);",
            "+            column++) {",
            "             offset = (row * COLUMNS) + column;",
            "-            row_offset += (size_t)snprintf(&row_buf[row_offset], sizeof(row_buf) - row_offset, \" %02x\", slice_get_uint8(s, offset));",
            "+            row_offset +=",
            "+                // NOLINTNEXTLINE",
            "+                (size_t)snprintf(&row_buf[row_offset], sizeof(row_buf) - row_offset, \" %02x\", slice_get_uint8(s, offset));",
            "         }",
            " ",
            "         /* zero terminate */",
            "         if(row_offset < sizeof(row_buf)) {",
            "             row_buf[row_offset] = (char)0;",
            "         } else {",
            "             /* this might truncate the string, but it is safe. */",
            "-            row_buf[sizeof(row_buf)-1] = (char)0;",
            "+            row_buf[sizeof(row_buf) - 1] = (char)0;",
            "         }",
            " ",
            "         /* output it, finally */",
            "-        fprintf(stderr,\"%s\\n\", row_buf);",
            "+        // NOLINTNEXTLINE",
            "+        fprintf(stderr, \"%s\\n\", row_buf);",
            "     }",
            " }",
            " ",
            "+/* FIXME - move this all over into a compatibility/platform check header */",
            "+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)",
            "+#    include <stdlib.h>",
            " ",
            "+uint64_t random_u64(uint64_t upper_bound) {",
            "+    uint64_t random_number = 0;",
            "+",
            "+    arc4random_buf(&random_number, sizeof(random_number));",
            "+    random_number %= upper_bound;",
            "+",
            "+    return random_number;",
            "+}",
            "+",
            "+#elif defined(__linux__)",
            "+#    include <stdlib.h>",
            "+#    include <sys/random.h>",
            "+",
            "+",
            "+uint64_t random_u64(uint64_t upper_bound) {",
            "+    uint64_t random_number = 0;",
            "+",
            "+    if(upper_bound == 0) { return 0; }",
            "+",
            "+    if(getrandom(&random_number, sizeof(random_number), GRND_NONBLOCK) < (ssize_t)sizeof(random_number)) {",
            "+        /* not enough entropy, do it the hard way. */",
            "+        srand((unsigned int)((uint64_t)time(NULL) ^ random_number));",
            "+        for(size_t i = 0; i < sizeof(random_number); ++i) { ((uint8_t *)&random_number)[i] ^= (uint8_t)(rand() % 256); }",
            "+    }",
            "+",
            "+    random_number %= upper_bound;",
            "+",
            "+    return random_number;",
            "+}",
            "+",
            "+#elif defined(USE_BCRYPTGENRANDOM)",
            "+",
            "+uint64_t random_u64(uint64_t upper_bound) {",
            "+    uint64_t random_number = 0;",
            "+",
            "+    if(BCryptGenRandom(NULL, (PUCHAR)&random_number, sizeof(random_number), BCRYPT_USE_SYSTEM_PREFERRED_RNG) != 0) {",
            "+        return RANDOM_U64_ERROR;",
            "+    }",
            "+    if(upper_bound == 0) { return 0; }",
            "+    random_number %= upper_bound;",
            "+",
            "+    return random_number;",
            "+}",
            "+",
            "+#else",
            "+#    error \"Platform not supported!\"",
            "+#endif"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/ab_server/src/utils.h",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/ab_server/src/utils.h",
            "+++ /home/libplctag-2.6.7/src/tests/ab_server/src/utils.h",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -36,18 +36,23 @@",
            " #include <stdint.h>",
            " #include \"compat.h\"",
            " #include \"slice.h\"",
            " ",
            " extern int util_sleep_ms(int ms);",
            " extern int64_t util_time_ms(void);",
            " ",
            "+extern void system_yield(void);",
            "+",
            " /* string helpers */",
            "-extern int match_chars(const char* source, int start_index, const char *chars);",
            "+extern int match_chars(const char *source, int start_index, const char *chars);",
            " ",
            " /* debug helpers */",
            " void debug_on(void);",
            " void debug_off(void);",
            " #define error(...) error_impl(__func__, __LINE__, __VA_ARGS__)",
            " extern void error_impl(const char *func, int line, const char *templ, ...);",
            " #define info(...) info_impl(__func__, __LINE__, __VA_ARGS__)",
            " extern void info_impl(const char *func, int line, const char *templ, ...);",
            " extern void slice_dump(slice_s s);",
            "+",
            "+#define RANDOM_U64_ERROR (UINT64_MAX)",
            "+extern uint64_t random_u64(uint64_t upper_bound);"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/tests/hashtable/test_hashtable.c",
          "change": [
            "--- /home/libplctag-2.6.2/src/tests/hashtable/test_hashtable.c",
            "+++ /home/libplctag-2.6.7/src/tests/hashtable/test_hashtable.c",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -27,102 +27,97 @@",
            "  *                                                                         *",
            "  *   You should have received a copy of the GNU Library General Public     *",
            "  *   License along with this program; if not, write to the                 *",
            "  *   Free Software Foundation, Inc.,                                       *",
            "  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *",
            "  ***************************************************************************/",
            " ",
            "-#include <assert.h>",
            "-#include <stdio.h>",
            " #include \"../../lib/libplctag.h\"",
            "-#include \"../../util/hashtable.h\"",
            " #include \"../../util/debug.h\"",
            "+#include \"../../util/hashtable.h\"",
            "+#include <assert.h>",
            "+#include <stdio.h>",
            " ",
            " #define START_CAPACITY (10)",
            " #define INSERT_ENTRIES (50)",
            " ",
            "-int main(int argc, const char **argv)",
            "-{",
            "+int main(int argc, const char **argv) {",
            "     hashtable_p table = NULL;",
            "     int size = START_CAPACITY;",
            "     float best_utilization = 0.0;",
            "     float tmp_utilization = 0.0;",
            " ",
            "     (void)argc;",
            "     (void)argv;",
            " ",
            "-    pdebug(DEBUG_INFO,\"Starting hashtable tests.\");",
            "+    pdebug(DEBUG_INFO, \"Starting hashtable tests.\");",
            " ",
            "     plc_tag_set_debug_level(PLCTAG_DEBUG_SPEW);",
            " ",
            "     /* create a hashtable */",
            "-    pdebug(DEBUG_INFO,\"Creating hashtable with at least capacity %d.\", START_CAPACITY);",
            "+    pdebug(DEBUG_INFO, \"Creating hashtable with at least capacity %d.\", START_CAPACITY);",
            "     table = hashtable_create(START_CAPACITY);",
            "     assert(table != NULL);",
            "     assert(hashtable_capacity(table) >= START_CAPACITY);",
            "     assert(hashtable_entries(table) == 0);",
            " ",
            "     size = hashtable_capacity(table);",
            " ",
            "     /* insert tests. */",
            "-    for(int i=1; i <= INSERT_ENTRIES; i++) {",
            "-        int rc = hashtable_put(table, i, (void*)(intptr_t)i);",
            "+    for(int i = 1; i <= INSERT_ENTRIES; i++) {",
            "+        int rc = hashtable_put(table, i, (void *)(intptr_t)i);",
            "         assert(rc == PLCTAG_STATUS_OK);",
            " ",
            "         if(hashtable_capacity(table) != size) {",
            "-            pdebug(DEBUG_INFO, \"Hashtable expanded from %d entries to %d entries after inserting %d entries.\", size, hashtable_capacity(table), hashtable_entries(table));",
            "+            pdebug(DEBUG_INFO, \"Hashtable expanded from %d entries to %d entries after inserting %d entries.\", size,",
            "+                   hashtable_capacity(table), hashtable_entries(table));",
            "             size = hashtable_capacity(table);",
            "         }",
            "     }",
            " ",
            "-    tmp_utilization = (float)(hashtable_entries(table))/(float)(hashtable_capacity(table));",
            "+    tmp_utilization = (float)(hashtable_entries(table)) / (float)(hashtable_capacity(table));",
            " ",
            "-    pdebug(DEBUG_INFO, \"Current table utilization %f%%\", tmp_utilization*100.0);",
            "+    pdebug(DEBUG_INFO, \"Current table utilization %f%%\", tmp_utilization * 100.0);",
            " ",
            "-    if(tmp_utilization > best_utilization) {",
            "-        best_utilization = tmp_utilization;",
            "-    }",
            "+    if(tmp_utilization > best_utilization) { best_utilization = tmp_utilization; }",
            " ",
            "     assert(hashtable_entries(table) == INSERT_ENTRIES);",
            "     pdebug(DEBUG_INFO, \"Hash table has correct number of used entries, %d.\", hashtable_entries(table));",
            " ",
            "     pdebug(DEBUG_INFO, \"Hashtable using %d entries of %d entries capacity.\", hashtable_entries(table), hashtable_capacity(table));",
            " ",
            "     /* retrieval tests. */",
            "     pdebug(DEBUG_INFO, \"Running retrieval tests.\");",
            "-    for(int i=INSERT_ENTRIES; i > 0; i--) {",
            "+    for(int i = INSERT_ENTRIES; i > 0; i--) {",
            "         void *res = hashtable_get(table, i);",
            "         assert(res != NULL);",
            " ",
            "         assert(i == (int)(intptr_t)res);",
            "     }",
            " ",
            "     /* insert + delete tests. */",
            "     pdebug(DEBUG_INFO, \"Running combined insert and delete tests.\");",
            "-    for(int i=INSERT_ENTRIES+1; i < (INSERT_ENTRIES*2); i++) {",
            "-        int rc = hashtable_put(table, i, (void*)(intptr_t)i);",
            "+    for(int i = INSERT_ENTRIES + 1; i < (INSERT_ENTRIES * 2); i++) {",
            "+        int rc = hashtable_put(table, i, (void *)(intptr_t)i);",
            "         void *res = NULL;",
            " ",
            "         assert(rc == PLCTAG_STATUS_OK);",
            " ",
            "         res = hashtable_remove(table, (i - INSERT_ENTRIES));",
            "         assert((i - INSERT_ENTRIES) == (int)(intptr_t)res);",
            "     }",
            " ",
            "     assert(hashtable_entries(table) == INSERT_ENTRIES);",
            "     pdebug(DEBUG_INFO, \"Hash table has correct number of used entries, %d.\", hashtable_entries(table));",
            " ",
            "-    tmp_utilization = (float)(hashtable_entries(table))/(float)(hashtable_capacity(table));",
            "+    tmp_utilization = (float)(hashtable_entries(table)) / (float)(hashtable_capacity(table));",
            " ",
            "-    pdebug(DEBUG_INFO, \"Current table utilization %f%%\", tmp_utilization*100.0);",
            "+    pdebug(DEBUG_INFO, \"Current table utilization %f%%\", tmp_utilization * 100.0);",
            " ",
            "-    if(tmp_utilization > best_utilization) {",
            "-        best_utilization = tmp_utilization;",
            "-    }",
            "+    if(tmp_utilization > best_utilization) { best_utilization = tmp_utilization; }",
            " ",
            "-    pdebug(DEBUG_INFO, \"Best table utilization %f%%\", best_utilization*100.0);",
            "+    pdebug(DEBUG_INFO, \"Best table utilization %f%%\", best_utilization * 100.0);",
            " ",
            "     hashtable_destroy(table);",
            " ",
            "     pdebug(DEBUG_INFO, \"Done.\");",
            " }",
            "-"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/wrappers/go/examples/toogle_bool.go",
          "change": [
            "--- /home/libplctag-2.6.2/src/wrappers/go/examples/toogle_bool.go",
            "+++ /home/libplctag-2.6.7/src/wrappers/go/examples/toogle_bool.go",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2019 Anbal Limn <limon.anibal@gmail.com>                                        *",
            "+ *   Copyright (C) 2025 Anbal Limn <limon.anibal@gmail.com>                                        *",
            "  *                                                                         *",
            "  *   This program is free software; you can redistribute it and/or modify  *",
            "  *   it under the terms of the GNU Library General Public License as       *",
            "  *   published by the Free Software Foundation; either version 2 of the    *",
            "  *   License, or (at your option) any later version.                       *",
            "  *                                                                         *",
            "  *   This program is distributed in the hope that it will be useful,       *"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/wrappers/go/src/plctag/plctag.go",
          "change": [
            "--- /home/libplctag-2.6.2/src/wrappers/go/src/plctag/plctag.go",
            "+++ /home/libplctag-2.6.7/src/wrappers/go/src/plctag/plctag.go",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2019 Anbal Limn <limon.anibal@gmail.com>              *",
            "+ *   Copyright (C) 2025 Anbal Limn <limon.anibal@gmail.com>              *",
            "  *                                                                         *",
            "  *   This program is free software; you can redistribute it and/or modify  *",
            "  *   it under the terms of the GNU Library General Public License as       *",
            "  *   published by the Free Software Foundation; either version 2 of the    *",
            "  *   License, or (at your option) any later version.                       *",
            "  *                                                                         *",
            "  *   This program is distributed in the hope that it will be useful,       *"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/wrappers/java/TagRW.java",
          "change": [
            "--- /home/libplctag-2.6.2/src/wrappers/java/TagRW.java",
            "+++ /home/libplctag-2.6.7/src/wrappers/java/TagRW.java",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *",
            "@@ -32,266 +32,266 @@",
            "  ***************************************************************************/",
            " ",
            " import libplctag.Tag;",
            " ",
            " public class TagRW {",
            " \tenum DataType { UNKNOWN, SINT8, UINT8, SINT16, UINT16, SINT32, UINT32, SINT64, REAL32, REAL64 };",
            " ",
            "-\t",
            "+",
            " \tprivate static final int CREATE_TIMEOUT = 2000; // two seconds",
            " \tprivate static final int OP_TIMEOUT = 2000; // two seconds",
            "-\t",
            "+",
            " \tprivate static DataType dType = DataType.UNKNOWN;",
            " \tprivate static int dSize = 0;",
            " \tprivate static String attribs;",
            " \tprivate static boolean hasWrite = false;",
            " \tprivate static String writeStr;",
            "-\t",
            "+",
            "     public static void main (String[] args) {",
            "     \tint rc = Tag.PLCTAG_STATUS_OK;",
            "-    \t",
            "+",
            "         parseArgs(args);",
            "-        ",
            "+",
            "         Tag tag = new Tag(attribs, CREATE_TIMEOUT);",
            "-        ",
            "+",
            "         if(tag.status() != Tag.PLCTAG_STATUS_OK) {",
            "         \tSystem.err.println(\"Tag creation failed with error: \" + tag.decodeError(tag.status()));",
            "         \ttag.close();",
            "         \tSystem.exit(1);",
            "         }",
            "-        ",
            "+",
            "         if(hasWrite) {",
            "         \tdoWrite(tag);",
            "         \tSystem.out.println(\"Wrote tag value successfully.\");",
            "         }",
            "-        ",
            "+",
            "         doRead(tag);",
            "         System.out.println(\"Read tag value successfully.\");",
            "     }",
            "-    ",
            "-    ",
            "+",
            "+",
            "     private static void doWrite(Tag tag) {",
            "     \tint rc = Tag.PLCTAG_STATUS_OK;",
            "     \tint iVal = 0;",
            "     \tlong lVal = 0;",
            "     \tdouble fVal = 0.0;",
            "-    \t",
            "+",
            "     \tswitch(dType) {",
            "     \tcase SINT8:",
            "     \t\tiVal = Integer.parseInt(writeStr);",
            "     \t\trc  = tag.setInt8(0, iVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            "     \t\tbreak;",
            " \t\tcase UINT8:",
            "     \t\tiVal = Integer.parseInt(writeStr);",
            "     \t\trc  = tag.setUInt8(0, iVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            " \t\t\tbreak;",
            " ",
            "     \tcase SINT16:",
            "     \t\tiVal = Integer.parseInt(writeStr);",
            "     \t\trc  = tag.setInt16(0, iVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            "     \t\tbreak;",
            " \t\tcase UINT16:",
            "     \t\tiVal = Integer.parseInt(writeStr);",
            "     \t\trc  = tag.setUInt16(0, iVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            " \t\t\tbreak;",
            " ",
            "     \tcase SINT32:",
            "     \t\tiVal = Integer.parseInt(writeStr);",
            "     \t\trc  = tag.setInt32(0, iVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            "     \t\tbreak;",
            " \t\tcase UINT32:",
            "     \t\tiVal = Integer.parseInt(writeStr);",
            "     \t\trc  = tag.setUInt32(0, iVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            " \t\t\tbreak;",
            " ",
            "     \tcase SINT64:",
            "     \t\tlVal = Long.parseLong(writeStr);",
            "     \t\trc  = tag.setInt64(0, lVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            "     \t\tbreak;",
            " ",
            "     \tcase REAL32:",
            "     \t\tfVal = Double.parseDouble(writeStr);",
            "     \t\trc  = tag.setFloat32(0, (float) fVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            " \t\t\tbreak;",
            " ",
            " \t\tcase REAL64:",
            "     \t\tfVal = Double.parseDouble(writeStr);",
            "     \t\trc  = tag.setFloat64(0, fVal);",
            "     \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "             \tSystem.err.println(\"Setting tag value failed with error: \" + tag.decodeError(rc));",
            "             \ttag.close();",
            "-            \tSystem.exit(1);    \t\t\t",
            "+            \tSystem.exit(1);",
            "     \t\t}",
            " \t\t\tbreak;",
            " ",
            " \t\tdefault:",
            " \t\t\tSystem.err.println(\"Unsupported data type!\");",
            " \t\t\tSystem.exit(1);",
            " \t\t\tbreak;",
            "     \t}",
            "-    \t",
            "+",
            "     \trc = tag.write(OP_TIMEOUT);",
            " \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "         \tSystem.err.println(\"Writing tag failed with error: \" + tag.decodeError(rc));",
            "         \ttag.close();",
            "-        \tSystem.exit(1);    \t\t\t",
            "+        \tSystem.exit(1);",
            " \t\t}",
            "     }",
            "-    ",
            "-    ",
            "+",
            "+",
            "     private static void doRead(Tag tag) {",
            "     \tint rc = Tag.PLCTAG_STATUS_OK;",
            "     \tint iVal = 0;",
            "     \tlong lVal = 0;",
            "     \tdouble fVal = 0.0;",
            "     \tint index = 0;",
            "     \tint numElems = 0;",
            "-    \t",
            "+",
            "     \trc = tag.read(OP_TIMEOUT);",
            " \t\tif(rc != Tag.PLCTAG_STATUS_OK) {",
            "         \tSystem.err.println(\"Reading tag failed with error: \" + tag.decodeError(rc));",
            "         \ttag.close();",
            "-        \tSystem.exit(1);    \t\t\t",
            "+        \tSystem.exit(1);",
            " \t\t}",
            " ",
            " \t\tnumElems = tag.size() / dSize;",
            "-\t\t",
            "+",
            " \t\tfor(index = 0; index < numElems; index++) {",
            " \t\t\tswitch(dType) {",
            " \t\t\tcase UINT8:",
            "-\t\t\t\tiVal = tag.getUInt8(index * dSize);\t\t\t\t",
            "+\t\t\t\tiVal = tag.getUInt8(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + iVal);",
            " \t\t\t\tbreak;",
            " ",
            " \t\t\tcase SINT8:",
            "-\t\t\t\tiVal = tag.getInt8(index * dSize);\t\t\t\t",
            "+\t\t\t\tiVal = tag.getInt8(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + iVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase UINT16:",
            "-\t\t\t\tiVal = tag.getUInt16(index * dSize);\t\t\t\t",
            "+\t\t\t\tiVal = tag.getUInt16(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + iVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase SINT16:",
            "-\t\t\t\tiVal = tag.getInt16(index * dSize);\t\t\t\t",
            "+\t\t\t\tiVal = tag.getInt16(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + iVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase UINT32:",
            "-\t\t\t\tlVal = tag.getUInt32(index * dSize);\t\t\t\t",
            "+\t\t\t\tlVal = tag.getUInt32(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + lVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase SINT32:",
            "-\t\t\t\tiVal = tag.getInt32(index * dSize);\t\t\t\t",
            "+\t\t\t\tiVal = tag.getInt32(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + iVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase SINT64:",
            "-\t\t\t\tlVal = tag.getInt64(index * dSize);\t\t\t\t",
            "+\t\t\t\tlVal = tag.getInt64(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + lVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase REAL32:",
            "-\t\t\t\tfVal = tag.getFloat32(index * dSize);\t\t\t\t",
            "+\t\t\t\tfVal = tag.getFloat32(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + fVal);",
            " \t\t\t\tbreak;",
            "-\t\t\t\t",
            "+",
            " \t\t\tcase REAL64:",
            " \t\t\t\tfVal = tag.getFloat64(index * dSize);",
            " \t\t\t\tSystem.out.println(\"data[\"  + index + \"] = \" + fVal);",
            " \t\t\t\tbreak;",
            " ",
            "-\t\t\t\t",
            "+",
            " \t\t\tdefault:",
            " \t\t\t\tSystem.err.println(\"Unsupported data type!\");",
            " \t\t\t\tSystem.exit(1);",
            " \t\t\t\tbreak;",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            "-    ",
            "+",
            "     private static void parseArgs(String[] args) {",
            "     \tint i = 0;",
            "-    \t",
            "+",
            "     \tfor(i=0; i<args.length; i++) {",
            "     \t\tif(args[i].equalsIgnoreCase(\"-t\")) {",
            "     \t\t\tif((i+1) >= args.length) {",
            "     \t\t\t\tSystem.err.println(\"-t param requires a type!\");",
            "     \t\t\t\tSystem.exit(1);",
            "     \t\t\t}",
            "-    \t\t\t",
            "+",
            "     \t\t\tparseTypeArg(args[i+1]);",
            "     \t\t\ti++;",
            "     \t\t} else if(\"-p\".equalsIgnoreCase(args[i])) {",
            "     \t\t\tif((i+1) >= args.length) {",
            "     \t\t\t\tSystem.err.println(\"-p param requires a value!\");",
            "     \t\t\t\tSystem.exit(1);",
            "     \t\t\t}",
            "-    \t\t\t",
            "+",
            "     \t\t\tparseAttribArg(args[i+1]);",
            "     \t\t\ti++;",
            "     \t\t} else if(\"-w\".equalsIgnoreCase(args[i])) {",
            "     \t\t\tif((i+1) >= args.length) {",
            "     \t\t\t\tSystem.err.println(\"-w param requires a value!\");",
            "     \t\t\t\tSystem.exit(1);",
            "     \t\t\t}",
            "-    \t\t\t",
            "+",
            "     \t\t\thasWrite = true;",
            "     \t\t\tparseWriteArg(args[i+1]);",
            "     \t\t\ti++;",
            "     \t\t} else {",
            " \t\t\t\tSystem.err.println(\"Unknown argument: \" + args[i]);",
            "-\t\t\t\tSystem.exit(1);    \t\t\t",
            "+\t\t\t\tSystem.exit(1);",
            "     \t\t}",
            "     \t}",
            "     }",
            "-    ",
            "-    ",
            "+",
            "+",
            "     private static void parseTypeArg(String typeArg) {",
            "     \tif(\"uint8\".equalsIgnoreCase(typeArg)) {",
            "     \t\tdType = DataType.UINT8;",
            "     \t\tdSize = 1;",
            "     \t} else if(\"sint8\".equalsIgnoreCase(typeArg)) {",
            "     \t\tdType = DataType.SINT8;",
            "     \t\tdSize = 1;",
            "@@ -317,23 +317,23 @@",
            "     \t\tdType = DataType.REAL64;",
            "     \t\tdSize = 8;",
            "     \t} else {",
            " \t\t\tSystem.err.println(\"Unknown type: \" + typeArg);",
            " \t\t\tSystem.exit(1);",
            "     \t}",
            "     }",
            "-    ",
            "-    ",
            "+",
            "+",
            "     private static void parseAttribArg(String attribArg) {",
            "     \tif(attribArg.isEmpty()) {",
            " \t\t\tSystem.err.println(\"Attribute string must not be empty or missing!\");",
            " \t\t\tSystem.exit(1);",
            "     \t}",
            "-    \t",
            "+",
            "     \tattribs = attribArg;",
            "     }",
            " ",
            "-    ",
            "+",
            "     private static void parseWriteArg(String writeArg) {",
            "     \twriteStr = writeArg;",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/libplctag-2.6.7/src/wrappers/java/libplctag/Tag.java",
          "change": [
            "--- /home/libplctag-2.6.2/src/wrappers/java/libplctag/Tag.java",
            "+++ /home/libplctag-2.6.7/src/wrappers/java/libplctag/Tag.java",
            "@@ -1,9 +1,9 @@",
            " /***************************************************************************",
            "- *   Copyright (C) 2020 by Kyle Hayes                                      *",
            "+ *   Copyright (C) 2025 by Kyle Hayes                                      *",
            "  *   Author Kyle Hayes  kyle.hayes@gmail.com                               *",
            "  *                                                                         *",
            "  * This software is available under either the Mozilla Public License      *",
            "  * version 2.0 or the GNU LGPL version 2 (or later) license, whichever     *",
            "  * you choose.                                                             *",
            "  *                                                                         *",
            "  * MPL 2.0:                                                                *"
          ]
        }
      ]
    }
  }
}