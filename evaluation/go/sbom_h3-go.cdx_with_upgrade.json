{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:38700f05-eaf1-446c-bbf1-e9e1e259b236",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T13:48:43-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "695115798cddeff6",
      "type": "file",
      "name": "h3-go-0.5.0/"
    }
  },
  "components": [
    {
      "bom-ref": "pkg:github/actions/checkout@v3?package-id=e01ecc9a5f425206",
      "type": "library",
      "name": "actions/checkout",
      "version": "v3",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v3:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/go_tests.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/setup-go@v4?package-id=8921f17bee8f9621",
      "type": "library",
      "name": "actions/setup-go",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/setup-go:actions\\/setup-go:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/setup-go@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup-go:actions\\/setup_go:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup_go:actions\\/setup-go:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup_go:actions\\/setup_go:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup:actions\\/setup-go:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup:actions\\/setup_go:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/go_tests.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/davecgh/go-spew@v1.1.1?package-id=4fff1eaa0bc0be66",
      "type": "library",
      "name": "github.com/davecgh/go-spew",
      "version": "v1.1.1",
      "cpe": "cpe:2.3:a:davecgh:go-spew:v1.1.1:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/davecgh/go-spew@v1.1.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:davecgh:go_spew:v1.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pmezard/go-difflib@v1.0.0?package-id=2e9153c8c5a4f906",
      "type": "library",
      "name": "github.com/pmezard/go-difflib",
      "version": "v1.0.0",
      "cpe": "cpe:2.3:a:pmezard:go-difflib:v1.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pmezard/go-difflib@v1.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pmezard:go_difflib:v1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/stretchr/testify@v1.10.0?package-id=d4d0576c4c3746f0",
      "type": "library",
      "name": "github.com/stretchr/testify",
      "version": "v1.10.0",
      "cpe": "cpe:2.3:a:stretchr:testify:v1.10.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/stretchr/testify@v1.10.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/gopkg.in/yaml.v3@v3.0.1?package-id=716c668b92999095",
      "type": "library",
      "name": "gopkg.in/yaml.v3",
      "version": "v3.0.1",
      "cpe": "cpe:2.3:a:yaml_project:yaml:v3.0.1:*:*:*:*:go:*:*",
      "purl": "pkg:golang/gopkg.in/yaml.v3@v3.0.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA="
        }
      ]
    },
    {
      "bom-ref": "3744f4e26c2bf8e9",
      "type": "file",
      "name": "/home/h3-go-0.5.0/.github/workflows/go_tests.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "f0e676c198d3a9d5ed82edeb883802e425f77d39"
        },
        {
          "alg": "SHA-256",
          "content": "b2962046a92499e99af1359b57b010fb65599ac21aa111faec2837584af498b4"
        }
      ]
    },
    {
      "bom-ref": "3fc5a8d3d86e9790",
      "type": "file",
      "name": "/home/h3-go-0.5.0/go.mod",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "c9683445eaf69910e18ffb10402a7e81a4d2baeb"
        },
        {
          "alg": "SHA-256",
          "content": "9b620510bcbcbd95d77588e6c5af79fb3d43b1dffcc858467a057d8768a8c83e"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/h3-go-0.1.0",
      "New file": [
        "/home/h3-go-0.5.0/pkg/h3/localij.go",
        "/home/h3-go-0.5.0/pkg/h3/localij_test.go"
      ],
      "Deleted file": [],
      "Modified file": [
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/base_cell.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/base_cell.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/base_cell.go",
            "@@ -813,14 +813,31 @@",
            " ",
            " // isPolarPentagon returns whether the indicated base cell is a pentagon where",
            " // all neighbors are oriented towards it.",
            " func (c baseCell) isPolarPentagon() bool {",
            " \treturn c == 4 || c == 117",
            " }",
            " ",
            "+// baseCellDirection returns the direction from the origin base cell to the",
            "+// neighbor base cell. Returns INVALID_DIGIT if the cells are not neighbors.",
            "+func (c baseCell) baseCellDirection(neighbor baseCell) Direction {",
            "+\tfor dir := CENTER_DIGIT; dir < NUM_DIGITS; dir++ {",
            "+\t\ttestBaseCell := c.getBaseCellNeighbor(dir)",
            "+\t\tif testBaseCell == neighbor {",
            "+\t\t\treturn dir",
            "+\t\t}",
            "+\t}",
            "+\treturn INVALID_DIGIT",
            "+}",
            "+",
            "+// getBaseCellNeighbor returns the neighboring base cell in the given direction.",
            "+func (c baseCell) getBaseCellNeighbor(dir Direction) baseCell {",
            "+\treturn baseCellNeighbors[c][dir]",
            "+}",
            "+",
            " // faceIjkToBaseCellCCWrot60 finds the base cell given FaceIJK.",
            " //",
            " // Given the face number and a resolution 0 ijk+ coordinate in that face's",
            " // face-centered ijk coordinate system, return the number of 60' ccw rotations",
            " // to rotate into the coordinate system of the base cell at that coordinates.",
            " //",
            " // Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2)."
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/cell.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/cell.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/cell.go",
            "@@ -491,18 +491,113 @@",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            " \treturn out",
            " }",
            " ",
            "+// GridDistance returns the number of grid cells between this cell and the other.",
            "+//",
            "+// This function may return an error if the cells are very far apart, if the",
            "+// cells are not at the same resolution, or if the cells are on opposite sides of",
            "+// a pentagon.",
            "+func (c Cell) GridDistance(other Cell) (int, error) {",
            "+\toriginIjk, err := c.toLocalIJK(c)",
            "+\tif err != nil {",
            "+\t\treturn 0, err",
            "+\t}",
            "+",
            "+\totherIjk, err := c.toLocalIJK(other)",
            "+\tif err != nil {",
            "+\t\treturn 0, err",
            "+\t}",
            "+",
            "+\treturn originIjk.Distance(otherIjk), nil",
            "+}",
            "+",
            " func (c Cell) isResolutionClassIII() bool {",
            " \treturn c.Resolution()%2 > 0",
            " }",
            " ",
            "+// rotatePentagon60ccw rotates the Cell 60 degrees clockwise about a pentagonal center and returns the new index.",
            "+func (c Cell) rotatePentagon60cw() Cell {",
            "+\tfoundFirstNonZeroDigit := false",
            "+\tout := c",
            "+\tres := out.Resolution()",
            "+",
            "+\tfor r := 1; r <= res; r++ {",
            "+\t\t// rotate this digit",
            "+\t\tout = out.setIndexDigit(r, rotate60cw(out.getIndexDigit(r)))",
            "+",
            "+\t\t// look for the first non-zero digit so we can adjust for deleted k-axes sequence",
            "+\t\t// if necessary",
            "+\t\tif !foundFirstNonZeroDigit && out.getIndexDigit(r) != 0 {",
            "+\t\t\tfoundFirstNonZeroDigit = true",
            "+",
            "+\t\t\t// adjust for deleted k-axes sequence",
            "+\t\t\tif out.leadingNonZeroDigit() == K_AXES_DIGIT {",
            "+\t\t\t\tout = out.rotate60cw()",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn out",
            "+}",
            "+",
            "+// toFaceIjkWithInitializedFijk converts a Cell to the FaceIJK address on a specified icosahedral face.",
            "+func (c Cell) toFaceIjkWithInitializedFijk(fijk faceIJK) (faceIJK, bool) {",
            "+\tijk := fijk.coord",
            "+\tres := c.Resolution()",
            "+",
            "+\t// center base cell hierarchy is entirely on this face",
            "+\tpossibleOverage := true",
            "+\tif (!c.BaseCell().isPentagon()) &&",
            "+\t\t(res == 0 ||",
            "+\t\t\t(fijk.coord.i == 0 && fijk.coord.j == 0 && fijk.coord.k == 0)) {",
            "+\t\tpossibleOverage = false",
            "+\t}",
            "+",
            "+\tfor r := 1; r <= res; r++ {",
            "+\t\tif isResolutionClassIII(r) {",
            "+\t\t\t// Class III == rotate ccw",
            "+\t\t\tijk = ijk.downAp7()",
            "+\t\t} else {",
            "+\t\t\t// Class II == rotate cw",
            "+\t\t\tijk = ijk.downAp7r()",
            "+\t\t}",
            "+",
            "+\t\tijk = ijk.neighbor(c.getIndexDigit(r))",
            "+\t}",
            "+",
            "+\tfijk.coord = ijk",
            "+",
            "+\treturn fijk, possibleOverage",
            "+}",
            "+",
            "+// Parent produces the parent cell for a given H3 cell. res is the resolution to",
            "+// switch to.",
            "+func (c Cell) Parent(res int) (Cell, error) {",
            "+\tchildRes := c.Resolution()",
            "+",
            "+\tif res < 0 || res > MAX_H3_RES {",
            "+\t\treturn 0, ErrInvalidArgument",
            "+\t} else if res > childRes {",
            "+\t\treturn 0, ErrInvalidArgument",
            "+\t} else if res == childRes {",
            "+\t\treturn c, nil",
            "+\t}",
            "+",
            "+\tparent := c.setResolution(res)",
            "+\tfor r := res + 1; r <= childRes; r++ {",
            "+\t\tparent = parent.setIndexDigit(r, H3_DIGIT_MASK)",
            "+\t}",
            "+",
            "+\treturn parent, nil",
            "+}",
            "+",
            " // rotate60ccw rotates the given digit 60 degrees counter-clockwise and returns the new digit.",
            " func rotate60ccw(digit Direction) Direction {",
            " \tswitch digit {",
            " \tcase K_AXES_DIGIT:",
            " \t\treturn IK_AXES_DIGIT",
            " \tcase IK_AXES_DIGIT:",
            " \t\treturn I_AXES_DIGIT"
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/cell_set.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/cell_set.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/cell_set.go",
            "@@ -1,10 +1,12 @@",
            " package h3",
            " ",
            "-import \"fmt\"",
            "+import (",
            "+\t\"fmt\"",
            "+)",
            " ",
            " // CellSet represents a set of H3 cells.",
            " type CellSet map[Cell]struct{}",
            " ",
            " // NewCellSetFromStrings creates a new cell set from a list of hex-encoded strings.",
            " func NewCellSetFromStrings(ss []string) (CellSet, error) {",
            " \tcs := make(CellSet, len(ss))",
            "@@ -32,14 +34,18 @@",
            " \tcells := make([]Cell, 0, len(cs))",
            " \tfor c := range cs {",
            " \t\tcells = append(cells, c)",
            " \t}",
            " \treturn cells",
            " }",
            " ",
            "+func (cs CellSet) String() string {",
            "+\treturn fmt.Sprintf(\"%v\", cs.Cells())",
            "+}",
            "+",
            " // Strings returns the cells in the set as a list of hex-encoded strings.",
            " func (cs CellSet) Strings() []string {",
            " \tss := make([]string, 0, len(cs))",
            " \tfor c := range cs {",
            " \t\tss = append(ss, c.String())",
            " \t}",
            " \treturn ss",
            "@@ -51,7 +57,311 @@",
            " \treturn ok",
            " }",
            " ",
            " // Add adds a cell to the set.",
            " func (cs CellSet) Add(c Cell) {",
            " \tcs[c] = struct{}{}",
            " }",
            "+",
            "+// Union returns the union of two cell sets.",
            "+func (cs CellSet) Union(other CellSet) CellSet {",
            "+\tnewSet := make(CellSet, len(cs)+len(other))",
            "+\tfor c := range cs {",
            "+\t\tnewSet[c] = struct{}{}",
            "+\t}",
            "+\tfor c := range other {",
            "+\t\tnewSet[c] = struct{}{}",
            "+\t}",
            "+\treturn newSet",
            "+}",
            "+",
            "+// GridDisk returns the cells in the set's grid disk of radius k. The grid disk",
            "+// is the set of cells within k grid steps of the cells in the set. k=0 returns",
            "+// the set itself.",
            "+func (cs CellSet) GridDisk(k int) (CellSet, error) {",
            "+\t// k<0 returns an error",
            "+\tif k < 0 {",
            "+\t\treturn nil, fmt.Errorf(\"k must be >= 0\")",
            "+\t}",
            "+",
            "+\t// k=0 returns the set itself",
            "+\tif k == 0 {",
            "+\t\treturn cs, nil",
            "+\t}",
            "+",
            "+\t// If the set is empty, return an error",
            "+\tif len(cs) == 0 {",
            "+\t\treturn nil, fmt.Errorf(\"empty cell set\")",
            "+\t}",
            "+",
            "+\t// Start with the original set",
            "+\tresult := make(CellSet, len(cs))",
            "+\tfor c := range cs {",
            "+\t\tresult.Add(c)",
            "+\t}",
            "+",
            "+\t// For each k, expand only the cells added in the previous step",
            "+\tcurrentShell := cs",
            "+\tfor i := 0; i < k; i++ {",
            "+\t\t// Find boundary cells of the current shell",
            "+\t\tnextShell := make(CellSet, len(currentShell))",
            "+",
            "+\t\tfor c := range currentShell {",
            "+\t\t\t// Get immediate neighbors of the current shell",
            "+\t\t\tneighbors, err := c.GridDisk(1)",
            "+\t\t\tif err != nil {",
            "+\t\t\t\treturn nil, fmt.Errorf(\"error getting neighbors for cell %s: %w\", c, err)",
            "+\t\t\t}",
            "+",
            "+\t\t\t// Add new neighbors to the next shell",
            "+\t\t\tfor _, n := range neighbors {",
            "+\t\t\t\tif !result.Contains(n) {",
            "+\t\t\t\t\tnextShell.Add(n)",
            "+\t\t\t\t\tresult.Add(n)",
            "+\t\t\t\t}",
            "+\t\t\t}",
            "+\t\t}",
            "+",
            "+\t\tif len(nextShell) == 0 {",
            "+\t\t\tbreak // No new cells added, exit the loop",
            "+\t\t}",
            "+",
            "+\t\t// Move to the next shell",
            "+\t\tcurrentShell = nextShell",
            "+\t}",
            "+",
            "+\treturn result, nil",
            "+}",
            "+",
            "+// GridDistance returns the minimum grid distance between cells in the two sets.",
            "+// All cells in the sets must have the same resolution. Distance is zero if any",
            "+// of the cells overlap. The function will return an error if either set is",
            "+// empty.",
            "+func (cs CellSet) GridDistance(other CellSet) (int, error) {",
            "+\t// If either set is empty, return an error",
            "+\tif len(cs) == 0 || len(other) == 0 {",
            "+\t\treturn 0, fmt.Errorf(\"cannot compute grid distance between empty cell sets\")",
            "+\t}",
            "+",
            "+\t// Both sets must contain cells with the same resolution.",
            "+\tthisResolution, err := cs.Resolution()",
            "+\tif err != nil {",
            "+\t\treturn 0, fmt.Errorf(\"this cell set is not consistent resolution: %w\", err)",
            "+\t}",
            "+",
            "+\totherResolution, err := other.Resolution()",
            "+\tif err != nil {",
            "+\t\treturn 0, fmt.Errorf(\"other cell set is not consistent resolution: %w\", err)",
            "+\t}",
            "+",
            "+\tif thisResolution != otherResolution {",
            "+\t\treturn 0, fmt.Errorf(\"cell sets have different resolutions: %d and %d\", thisResolution, otherResolution)",
            "+\t}",
            "+",
            "+\t// If any cells overlap, the distance is zero.",
            "+\tif cs.Intersects(other) {",
            "+\t\treturn 0, nil",
            "+\t}",
            "+",
            "+\t// Group cells by their lower-resolution parent to reduce search space.",
            "+\tparentReduction := 1",
            "+\tselfGroups := make(map[Cell][]Cell)",
            "+\totherGroups := make(map[Cell][]Cell)",
            "+",
            "+\t// Group cells by their parent",
            "+\tfor c := range cs {",
            "+\t\tparent, err := c.Parent(thisResolution - parentReduction)",
            "+\t\tif err != nil {",
            "+\t\t\treturn 0, fmt.Errorf(\"error getting parent for cell %s: %w\", c, err)",
            "+\t\t}",
            "+\t\tselfGroups[parent] = append(selfGroups[parent], c)",
            "+\t}",
            "+",
            "+\tfor c := range other {",
            "+\t\tparent, err := c.Parent(thisResolution - parentReduction)",
            "+\t\tif err != nil {",
            "+\t\t\treturn 0, fmt.Errorf(\"error getting parent for cell %s: %w\", c, err)",
            "+\t\t}",
            "+\t\totherGroups[parent] = append(otherGroups[parent], c)",
            "+\t}",
            "+",
            "+\t// First find minimum distance between parent cells",
            "+\tminParentDistance := -1",
            "+\trelevantPairs := make([][2]Cell, 0, len(selfGroups)*len(otherGroups))",
            "+\tfor parent1 := range selfGroups {",
            "+\t\tfor parent2 := range otherGroups {",
            "+\t\t\td, err := parent1.GridDistance(parent2)",
            "+\t\t\tif err != nil {",
            "+\t\t\t\treturn 0, fmt.Errorf(\"error computing grid distance between parent cells %s and %s: %w\", parent1, parent2, err)",
            "+\t\t\t}",
            "+",
            "+\t\t\tif minParentDistance == -1 || d < minParentDistance {",
            "+\t\t\t\tminParentDistance = d",
            "+\t\t\t\trelevantPairs = relevantPairs[:0]",
            "+\t\t\t}",
            "+",
            "+\t\t\t// This pair is among the closest, so we'll check its children later",
            "+\t\t\tif d <= minParentDistance+parentReduction {",
            "+\t\t\t\trelevantPairs = append(relevantPairs, [2]Cell{parent1, parent2})",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+",
            "+\t// Now calculate the actual minimum distance between the children of the relevant pairs",
            "+\tminDistance := -1",
            "+",
            "+\tfor _, pair := range relevantPairs {",
            "+\t\tparent1, parent2 := pair[0], pair[1]",
            "+\t\tchildrenPairs1 := selfGroups[parent1]",
            "+\t\tchildrenPairs2 := otherGroups[parent2]",
            "+",
            "+\t\tfor _, c1 := range childrenPairs1 {",
            "+\t\t\tfor _, c2 := range childrenPairs2 {",
            "+\t\t\t\td, err := c1.GridDistance(c2)",
            "+\t\t\t\tif err != nil {",
            "+\t\t\t\t\treturn 0, fmt.Errorf(\"error computing grid distance between cells %s and %s: %w\", c1, c2, err)",
            "+\t\t\t\t}",
            "+",
            "+\t\t\t\tif minDistance == -1 || d < minDistance {",
            "+\t\t\t\t\tminDistance = d",
            "+\t\t\t\t}",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+",
            "+\t// If no distance was found, return an error",
            "+\tif minDistance == -1 {",
            "+\t\treturn 0, fmt.Errorf(\"no distance found between cell sets\")",
            "+\t}",
            "+",
            "+\treturn minDistance, nil",
            "+}",
            "+",
            "+// BoundaryCells returns the cells on the outer boundary of the set. A boundary",
            "+// cell is one that has at least one neighboring cell that's not in the set.",
            "+func (cs CellSet) BoundaryCells() (CellSet, error) {",
            "+\t// If the set has < 7 cells, return the set itself because there aren't enough",
            "+\t// cells to enclose one cell.",
            "+\tif len(cs) < 7 {",
            "+\t\treturn cs, nil",
            "+\t}",
            "+",
            "+\tboundaryCells := make(CellSet, len(cs))",
            "+\tfor c := range cs {",
            "+\t\tneighbors, err := c.GridDisk(1)",
            "+\t\tif err != nil {",
            "+\t\t\treturn nil, fmt.Errorf(\"error getting neighbors for cell %s: %w\", c, err)",
            "+\t\t}",
            "+",
            "+\t\tfor _, n := range neighbors {",
            "+\t\t\tif !cs.Contains(n) {",
            "+\t\t\t\tboundaryCells.Add(c)",
            "+\t\t\t\tbreak",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn boundaryCells, nil",
            "+}",
            "+",
            "+// Resolution returns the resolution of the cells in the set. The function will",
            "+// return an error if the set is empty or contains cells of different",
            "+// resolutions.",
            "+func (cs CellSet) Resolution() (int, error) {",
            "+\t// If the set is empty, return an error",
            "+\tif len(cs) == 0 {",
            "+\t\treturn 0, fmt.Errorf(\"empty cell set\")",
            "+\t}",
            "+",
            "+\t// Check if all cells have the same resolution",
            "+\tresolution := -1",
            "+\tfor c := range cs {",
            "+\t\tif resolution == -1 {",
            "+\t\t\tresolution = c.Resolution()",
            "+\t\t} else if c.Resolution() != resolution {",
            "+\t\t\treturn 0, fmt.Errorf(\"cell set contains cells of different resolutions\")",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn resolution, nil",
            "+}",
            "+",
            "+// Intersects returns whether the set intersects with another set.",
            "+func (cs CellSet) Intersects(other CellSet) bool {",
            "+\tfor c := range cs {",
            "+\t\tif other.Contains(c) {",
            "+\t\t\treturn true",
            "+\t\t}",
            "+\t}",
            "+\treturn false",
            "+}",
            "+",
            "+// Subtract returns a new cell set that contains the cells in the first set that",
            "+// are not in the second set. Both sets must have the same resolution.",
            "+func (cs CellSet) Subtract(other CellSet) (CellSet, error) {",
            "+\t// If other is empty, return the set itself",
            "+\tif len(other) == 0 {",
            "+\t\treturn cs, nil",
            "+\t}",
            "+",
            "+\t// Both sets must contain cells with the same resolution.",
            "+\tthisResolution, err := cs.Resolution()",
            "+\tif err != nil {",
            "+\t\treturn nil, fmt.Errorf(\"this cell set is not consistent resolution: %w\", err)",
            "+\t}",
            "+",
            "+\totherResolution, err := other.Resolution()",
            "+\tif err != nil {",
            "+\t\treturn nil, fmt.Errorf(\"other cell set is not consistent resolution: %w\", err)",
            "+\t}",
            "+",
            "+\tif thisResolution != otherResolution {",
            "+\t\treturn nil, fmt.Errorf(\"cell sets have different resolutions: %d and %d\", thisResolution, otherResolution)",
            "+\t}",
            "+",
            "+\tresult := make(CellSet, len(cs))",
            "+\tfor c := range cs {",
            "+\t\tif !other.Contains(c) {",
            "+\t\t\tresult.Add(c)",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn result, nil",
            "+}",
            "+",
            "+// Parent returns a new cell set that contains the parent cells of the cells in",
            "+// the given set. The resolution of the new set is the given resolution. It is an",
            "+// error to call this function with a resolution greater than the set's",
            "+// resolution, if the set is empty, or if the resolution is not consistent within",
            "+// the set.",
            "+func (cs CellSet) Parent(resolution int) (CellSet, error) {",
            "+\t// If the set is empty, return an error",
            "+\tif len(cs) == 0 {",
            "+\t\treturn nil, fmt.Errorf(\"empty cell set\")",
            "+\t}",
            "+",
            "+\tsetResolution, err := cs.Resolution()",
            "+\tif err != nil {",
            "+\t\treturn nil, fmt.Errorf(\"cell set is not consistent resolution: %w\", err)",
            "+\t}",
            "+",
            "+\t// If the resolution is the same as the set's resolution, return the set itself",
            "+\tif resolution == setResolution {",
            "+\t\treturn cs, nil",
            "+\t}",
            "+",
            "+\t// Can't get children using the parent function",
            "+\tif resolution > setResolution {",
            "+\t\treturn nil, fmt.Errorf(\"resolution %d is greater than current resolution %d\", resolution, setResolution)",
            "+\t}",
            "+",
            "+\tresult := make(CellSet, len(cs))",
            "+\tfor c := range cs {",
            "+\t\tparent, err := c.Parent(resolution)",
            "+\t\tif err != nil {",
            "+\t\t\treturn nil, fmt.Errorf(\"error getting parent for cell %s: %w\", c, err)",
            "+\t\t}",
            "+\t\tresult.Add(parent)",
            "+\t}",
            "+",
            "+\treturn result, nil",
            "+}"
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/cell_set_test.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/cell_set_test.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/cell_set_test.go",
            "@@ -1,11 +1,14 @@",
            " package h3",
            " ",
            " import (",
            "+\t\"fmt\"",
            " \t\"testing\"",
            "+",
            "+\t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestNewCellSetFromStrings(t *testing.T) {",
            " \tstrs := []string{\"8f283473fffffff\", \"872830829fffffff\"}",
            " \tcs, err := NewCellSetFromStrings(strs)",
            " \tif err != nil {",
            " \t\tt.Fatalf(\"NewCellSetFromStrings() error = %v\", err)",
            "@@ -82,7 +85,578 @@",
            " \tfor _, s := range strs {",
            " \t\tc, _ := NewCellFromString(s)",
            " \t\tif !cs.Contains(c) {",
            " \t\t\tt.Errorf(\"Strings() missing cell %v\", c)",
            " \t\t}",
            " \t}",
            " }",
            "+",
            "+func TestCellSet_Union(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tother CellSet",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname string",
            "+\t\tcs   CellSet",
            "+\t\targs args",
            "+\t\twant CellSet",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\tCellSet{},",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty\",",
            "+\t\t\tCellSet{0x8f283473fffffff: {}},",
            "+\t\t\targs{CellSet{0x872830829fffffff: {}}},",
            "+\t\t\tCellSet{0x8f283473fffffff: {}, 0x872830829fffffff: {}},",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty with overlap\",",
            "+\t\t\tCellSet{0x8f283473fffffff: {}},",
            "+\t\t\targs{CellSet{0x8f283473fffffff: {}}},",
            "+\t\t\tCellSet{0x8f283473fffffff: {}},",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty with empty\",",
            "+\t\t\tCellSet{0x8f283473fffffff: {}},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\tCellSet{0x8f283473fffffff: {}},",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"empty with non-empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{CellSet{0x8f283473fffffff: {}}},",
            "+\t\t\tCellSet{0x8f283473fffffff: {}},",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tassert.Equalf(t, tt.want, tt.cs.Union(tt.args.other), \"Union(%v)\", tt.args.other)",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_GridDisk(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tk int",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tcs      CellSet",
            "+\t\targs    args",
            "+\t\twant    CellSet",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{0},",
            "+\t\t\tCellSet{},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{0},",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty k=1\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{1},",
            "+\t\t\tCellSet{",
            "+\t\t\t\t0x87283082affffff: {},",
            "+\t\t\t\t0x87283082bffffff: {},",
            "+\t\t\t\t0x87283080cffffff: {},",
            "+\t\t\t\t0x872830801ffffff: {},",
            "+\t\t\t\t0x872830805ffffff: {},",
            "+\t\t\t\t0x87283082effffff: {},",
            "+\t\t\t\t0x872830828ffffff: {},",
            "+\t\t\t},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"two nearby cells, k=1\",",
            "+\t\t\tCellSet{",
            "+\t\t\t\t0x87283082affffff: {},",
            "+\t\t\t\t0x872830823ffffff: {},",
            "+\t\t\t},",
            "+\t\t\targs{1},",
            "+\t\t\tCellSet{",
            "+\t\t\t\t0x872830801ffffff: {},",
            "+\t\t\t\t0x872830804ffffff: {},",
            "+\t\t\t\t0x872830805ffffff: {},",
            "+\t\t\t\t0x87283080cffffff: {},",
            "+\t\t\t\t0x872830820ffffff: {},",
            "+\t\t\t\t0x872830821ffffff: {},",
            "+\t\t\t\t0x872830822ffffff: {},",
            "+\t\t\t\t0x872830823ffffff: {},",
            "+\t\t\t\t0x872830828ffffff: {},",
            "+\t\t\t\t0x87283082affffff: {},",
            "+\t\t\t\t0x87283082bffffff: {},",
            "+\t\t\t\t0x87283082effffff: {},",
            "+\t\t\t},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"invalid k\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{-1},",
            "+\t\t\tnil,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.cs.GridDisk(tt.args.k)",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"GridDisk(%v)\", tt.args.k)) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"GridDisk(%v)\", tt.args.k)",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_Intersects(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tother CellSet",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname string",
            "+\t\tcs   CellSet",
            "+\t\targs args",
            "+\t\twant bool",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\tfalse,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty intersects\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x87283082affffff: {}}},",
            "+\t\t\ttrue,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-empty no intersection\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x87283082bffffff: {}}},",
            "+\t\t\tfalse,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"empty other\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\tfalse,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tassert.Equalf(t, tt.want, tt.cs.Intersects(tt.args.other), \"Intersects(%v)\", tt.args.other)",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_Resolution(t *testing.T) {",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tcs      CellSet",
            "+\t\twant    int",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\t0,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\t7,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}},",
            "+\t\t\t7,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells different resolutions\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x86283080fffffff: {}}, // 7, 7, 6",
            "+\t\t\t0,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.cs.Resolution()",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"Resolution()\")) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"Resolution()\")",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_GridDistance(t *testing.T) {",
            "+\t// L7 cells for San Francisco",
            "+\tsfCells := NewCellSetFromCells([]Cell{0x872830876ffffff, 0x87283082bffffff, 0x87283082affffff, 0x872830874ffffff, 0x872830829ffffff, 0x872830828ffffff, 0x87283082effffff, 0x87283095bffffff, 0x87283095affffff, 0x87283082dffffff, 0x87283082cffffff, 0x872830821ffffff, 0x872830820ffffff, 0x872830958ffffff, 0x87283095effffff, 0x872830953ffffff, 0x872830952ffffff, 0x872830825ffffff, 0x87283095cffffff, 0x872830951ffffff, 0x872830950ffffff, 0x872830942ffffff})",
            "+",
            "+\t// L7 cells for Vallejo",
            "+\tvallejoCells := NewCellSetFromCells([]Cell{0x87283002dffffff, 0x87283002cffffff, 0x87283002effffff, 0x872830023ffffff, 0x872830004ffffff, 0x872830153ffffff, 0x872830152ffffff, 0x872830021ffffff, 0x872830020ffffff, 0x872830022ffffff, 0x872830026ffffff, 0x872830024ffffff, 0x872830025ffffff, 0x872830156ffffff, 0x872830150ffffff, 0x872830154ffffff, 0x872830109ffffff, 0x87283010bffffff, 0x87283010affffff, 0x872830119ffffff, 0x87283011dffffff, 0x87283010effffff, 0x872830108ffffff})",
            "+",
            "+\ttype args struct {",
            "+\t\tother CellSet",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tcs      CellSet",
            "+\t\targs    args",
            "+\t\twant    int",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\t0,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single identical cell\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x87283082affffff: {}}},",
            "+\t\t\t0,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"different resolutions\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x86283080fffffff: {}}},",
            "+\t\t\t0,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell distance 1\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x87283082bffffff: {}}},",
            "+\t\t\t1,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"overlapping cell sets\",",
            "+\t\t\tCellSet{0x872830876ffffff: {}, 0x872830874ffffff: {}},",
            "+\t\t\targs{CellSet{0x872830876ffffff: {}, 0x872830808ffffff: {}}},",
            "+\t\t\t0,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"non-zero distance\",",
            "+\t\t\tCellSet{0x872830876ffffff: {}, 0x872830874ffffff: {}},",
            "+\t\t\targs{CellSet{0x872830808ffffff: {}}},",
            "+\t\t\t2,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"sf to vallejo\",",
            "+\t\t\tsfCells,",
            "+\t\t\targs{vallejoCells},",
            "+\t\t\t16,",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.cs.GridDistance(tt.args.other)",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"GridDistance(%v)\", tt.args.other)) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"GridDistance(%v)\", tt.args.other)",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func BenchmarkCellSet_GridDisk(b *testing.B) {",
            "+\t// L7 cells for San Francisco",
            "+\tcells := NewCellSetFromCells([]Cell{",
            "+\t\t0x872830876ffffff,",
            "+\t\t0x87283082bffffff,",
            "+\t\t0x87283082affffff,",
            "+\t\t0x872830874ffffff,",
            "+\t\t0x872830829ffffff,",
            "+\t\t0x872830828ffffff,",
            "+\t\t0x87283082effffff,",
            "+\t\t0x87283095bffffff,",
            "+\t\t0x87283095affffff,",
            "+\t\t0x87283082dffffff,",
            "+\t\t0x87283082cffffff,",
            "+\t\t0x872830821ffffff,",
            "+\t\t0x872830820ffffff,",
            "+\t\t0x872830958ffffff,",
            "+\t\t0x87283095effffff,",
            "+\t\t0x872830953ffffff,",
            "+\t\t0x872830952ffffff,",
            "+\t\t0x872830825ffffff,",
            "+\t\t0x87283095cffffff,",
            "+\t\t0x872830951ffffff,",
            "+\t\t0x872830950ffffff,",
            "+\t\t0x872830942ffffff,",
            "+\t})",
            "+",
            "+\tfor k := 0; k < 100; k++ {",
            "+\t\tb.Run(fmt.Sprintf(\"k=%d\", k), func(b *testing.B) {",
            "+\t\t\tfor i := 0; i < b.N; i++ {",
            "+\t\t\t\t_, err := cells.GridDisk(k)",
            "+\t\t\t\tif err != nil {",
            "+\t\t\t\t\tb.Fatalf(\"GridDisk() error = %v\", err)",
            "+\t\t\t\t}",
            "+\t\t\t}",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_BoundaryCells(t *testing.T) {",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tcs      CellSet",
            "+\t\twant    CellSet",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\tCellSet{},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"two cells\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}},",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"6 cells around a center cell should return the outer cells\",",
            "+\t\t\tCellSet{",
            "+\t\t\t\t0x872830876ffffff: {},",
            "+\t\t\t\t0x87283082bffffff: {},",
            "+\t\t\t\t0x872830874ffffff: {},",
            "+\t\t\t\t0x872830829ffffff: {},",
            "+\t\t\t\t0x872830828ffffff: {},",
            "+\t\t\t\t0x87283082dffffff: {},",
            "+\t\t\t\t0x87283095affffff: {},",
            "+\t\t\t},",
            "+\t\t\tCellSet{",
            "+\t\t\t\t0x872830876ffffff: {},",
            "+\t\t\t\t0x87283082bffffff: {},",
            "+\t\t\t\t0x872830828ffffff: {},",
            "+\t\t\t\t0x87283082dffffff: {},",
            "+\t\t\t\t0x87283095affffff: {},",
            "+\t\t\t\t0x872830874ffffff: {},",
            "+\t\t\t},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.cs.BoundaryCells()",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"BoundaryCells()\")) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"BoundaryCells()\")",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func BenchmarkCellSet_GridDistance(b *testing.B) {",
            "+\t// L7 cells for San Francisco",
            "+\tsfCells := NewCellSetFromCells([]Cell{0x872830876ffffff, 0x87283082bffffff, 0x87283082affffff, 0x872830874ffffff, 0x872830829ffffff, 0x872830828ffffff, 0x87283082effffff, 0x87283095bffffff, 0x87283095affffff, 0x87283082dffffff, 0x87283082cffffff, 0x872830821ffffff, 0x872830820ffffff, 0x872830958ffffff, 0x87283095effffff, 0x872830953ffffff, 0x872830952ffffff, 0x872830825ffffff, 0x87283095cffffff, 0x872830951ffffff, 0x872830950ffffff, 0x872830942ffffff})",
            "+",
            "+\t// L7 cells for Vallejo",
            "+\tvallejoCells := NewCellSetFromCells([]Cell{0x87283002dffffff, 0x87283002cffffff, 0x87283002effffff, 0x872830023ffffff, 0x872830004ffffff, 0x872830153ffffff, 0x872830152ffffff, 0x872830021ffffff, 0x872830020ffffff, 0x872830022ffffff, 0x872830026ffffff, 0x872830024ffffff, 0x872830025ffffff, 0x872830156ffffff, 0x872830150ffffff, 0x872830154ffffff, 0x872830109ffffff, 0x87283010bffffff, 0x87283010affffff, 0x872830119ffffff, 0x87283011dffffff, 0x87283010effffff, 0x872830108ffffff})",
            "+",
            "+\t// L7 cells for Chicago",
            "+\tchicagoCells := NewCellSetFromCells([]Cell{0x872664523ffffff, 0x872664c84ffffff, 0x87266452dffffff, 0x872664c89ffffff, 0x872664193ffffff, 0x872664ca2ffffff, 0x872664cacffffff, 0x872664cb1ffffff, 0x872664564ffffff, 0x872664cc0ffffff, 0x872664cc5ffffff, 0x872664ccaffffff, 0x872664cd4ffffff, 0x872664cd9ffffff, 0x872664cdeffffff, 0x872664cf2ffffff, 0x872664d88ffffff, 0x87275934cffffff, 0x872664c1effffff, 0x872664521ffffff, 0x872664c8cffffff, 0x872664191ffffff, 0x872664196ffffff, 0x872664ca0ffffff, 0x872664ca5ffffff, 0x872664caaffffff, 0x872664562ffffff, 0x87266456cffffff, 0x872664cc3ffffff, 0x872664cc8ffffff, 0x872664ccdffffff, 0x872664cd2ffffff, 0x872664cdcffffff, 0x872664cebffffff, 0x872664cf0ffffff, 0x872664cf5ffffff, 0x872664d8bffffff, 0x872664d9affffff, 0x872664c12ffffff, 0x872664c80ffffff, 0x872664c85ffffff, 0x872664194ffffff, 0x872664ca3ffffff, 0x872664ca8ffffff, 0x872664cadffffff, 0x872664cb2ffffff, 0x8726641b2ffffff, 0x872664560ffffff, 0x872664565ffffff, 0x872664cc1ffffff, 0x872664cc6ffffff, 0x872664ccbffffff, 0x872664cd0ffffff, 0x872664cd5ffffff, 0x872664cf3ffffff, 0x872664d89ffffff, 0x872664d8effffff, 0x872664d98ffffff, 0x872664d9dffffff, 0x872759343ffffff, 0x87275934dffffff, 0x87275936bffffff, 0x872664c10ffffff, 0x872664c1affffff, 0x872664c83ffffff, 0x87266452cffffff, 0x872664c88ffffff, 0x872664c8dffffff, 0x872664192ffffff, 0x872664ca1ffffff, 0x872664ca6ffffff, 0x872664cabffffff, 0x872664cb0ffffff, 0x872664cb5ffffff, 0x872664563ffffff, 0x872664cc4ffffff, 0x872664cc9ffffff, 0x872664cceffffff, 0x872664cd3ffffff, 0x872664cd8ffffff, 0x872664cddffffff, 0x872664ce2ffffff, 0x872664cf1ffffff, 0x872664cf6ffffff, 0x872664d8cffffff, 0x872664d9bffffff, 0x872759341ffffff, 0x872759369ffffff, 0x872664c13ffffff, 0x872664c18ffffff, 0x872664520ffffff, 0x872664525ffffff, 0x872664c81ffffff, 0x872664c86ffffff, 0x872664c8bffffff, 0x872664190ffffff, 0x872664ca4ffffff, 0x872664ca9ffffff, 0x872664caeffffff, 0x872664561ffffff, 0x872664566ffffff, 0x872664cc2ffffff, 0x872664570ffffff, 0x872664575ffffff, 0x872664cccffffff, 0x872664cd1ffffff, 0x872664cd6ffffff, 0x872664cdbffffff, 0x872664ceaffffff, 0x872664cf4ffffff, 0x872664d8affffff, 0x872664d99ffffff, 0x872664d9effffff, 0x87275934effffff, 0x87275935dffffff, 0x872664c16ffffff, 0x872664c1bffffff})",
            "+",
            "+\t// L7 cells for Milwaukee",
            "+\tmkeCells := NewCellSetFromCells([]Cell{0x87275d745ffffff, 0x87275d39affffff, 0x87275d0dcffffff, 0x87275d764ffffff, 0x87275d396ffffff, 0x87275d286ffffff, 0x87275d0d8ffffff, 0x87275d76dffffff, 0x87275d2b2ffffff, 0x87275d0cbffffff, 0x87275d760ffffff, 0x87275d392ffffff, 0x87275d282ffffff, 0x87275d769ffffff, 0x87275d39bffffff, 0x87275d0ddffffff, 0x87275d765ffffff, 0x87275d294ffffff, 0x87275d0c3ffffff, 0x87275d0d9ffffff, 0x87275d76effffff, 0x87275d2b3ffffff, 0x87275d761ffffff, 0x87275d2a6ffffff, 0x87275d393ffffff, 0x87275d283ffffff, 0x87275d39cffffff, 0x87275d2a2ffffff, 0x87275d766ffffff, 0x87275d398ffffff, 0x87275d2b4ffffff, 0x87275d74cffffff, 0x87275d762ffffff, 0x87275d284ffffff, 0x87275d76bffffff, 0x87275d2b0ffffff, 0x87275d390ffffff, 0x87275d280ffffff, 0x87275d296ffffff, 0x87275d0dbffffff, 0x87275d2b5ffffff, 0x87275d763ffffff, 0x87275d76cffffff, 0x87275d2b1ffffff, 0x87275d39effffff, 0x87275d0caffffff, 0x87275d775ffffff, 0x87275d391ffffff, 0x87275d281ffffff, 0x87275d768ffffff, 0x87275d0d1ffffff})",
            "+",
            "+\t// L7 cells for Evanston (adjacent to Chicago)",
            "+\tevanstonCells := NewCellSetFromCells([]Cell{0x872664d81ffffff, 0x872664d85ffffff, 0x872664d80ffffff, 0x872664d84ffffff})",
            "+",
            "+\tfor i := 0; i < b.N; i++ {",
            "+\t\t// Distance between smaller, closer sets",
            "+\t\t_, err := sfCells.GridDistance(vallejoCells)",
            "+\t\tif err != nil {",
            "+\t\t\tb.Fatalf(\"GridDistance() error = %v\", err)",
            "+\t\t}",
            "+",
            "+\t\t// Distance between larger, farther sets",
            "+\t\t_, err = chicagoCells.GridDistance(mkeCells)",
            "+\t\tif err != nil {",
            "+\t\t\tb.Fatalf(\"GridDistance() error = %v\", err)",
            "+\t\t}",
            "+",
            "+\t\t// Distance between two adjacent (but not overlapping) sets",
            "+\t\t_, err = chicagoCells.GridDistance(evanstonCells)",
            "+\t\tif err != nil {",
            "+\t\t\tb.Fatalf(\"GridDistance() error = %v\", err)",
            "+\t\t}",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_Subtract(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tother CellSet",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tcs      CellSet",
            "+\t\targs    args",
            "+\t\twant    CellSet",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\tCellSet{},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"different resolutions\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x86283080fffffff: {}}},",
            "+\t\t\tnil,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell removed\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x87283082affffff: {}}},",
            "+\t\t\tCellSet{},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell not removed\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{CellSet{0x87283082bffffff: {}}},",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells, some removed\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}},",
            "+\t\t\targs{CellSet{0x87283082affffff: {}, 0x87283082bffffff: {}}},",
            "+\t\t\tCellSet{0x87283082cffffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells, all removed\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}},",
            "+\t\t\targs{CellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}}},",
            "+\t\t\tCellSet{},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells, none removed\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}},",
            "+\t\t\targs{CellSet{0x87283082dffffff: {}}},",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells, empty removal set\",",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}},",
            "+\t\t\targs{CellSet{}},",
            "+\t\t\tCellSet{0x87283082affffff: {}, 0x87283082bffffff: {}, 0x87283082cffffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.cs.Subtract(tt.args.other)",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"Subtract(%v)\", tt.args.other)) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"Subtract(%v)\", tt.args.other)",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCellSet_Parent(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tresolution int",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tcs      CellSet",
            "+\t\targs    args",
            "+\t\twant    CellSet",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\t\"empty\",",
            "+\t\t\tCellSet{},",
            "+\t\t\targs{0},",
            "+\t\t\tnil,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell, same resolution\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{7},",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell, different resolution\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{5},",
            "+\t\t\tCellSet{0x85283083fffffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell, greater resolution\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{8},",
            "+\t\t\tnil,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"single cell, invalid resolution\",",
            "+\t\t\tCellSet{0x87283082affffff: {}},",
            "+\t\t\targs{-1},",
            "+\t\t\tnil,",
            "+\t\t\tassert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\t\"multiple cells, different resolution\",",
            "+\t\t\tCellSet{0x872830876ffffff: {}, 0x87283082bffffff: {}, 0x87283082affffff: {}},",
            "+\t\t\targs{5},",
            "+\t\t\tCellSet{0x85283083fffffff: {}, 0x85283087fffffff: {}},",
            "+\t\t\tassert.NoError,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.cs.Parent(tt.args.resolution)",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"Parent(%v)\", tt.args.resolution)) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"Parent(%v)\", tt.args.resolution)",
            "+\t\t})",
            "+\t}",
            "+}"
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/cell_test.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/cell_test.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/cell_test.go",
            "@@ -569,7 +569,137 @@",
            " \t}",
            " \tfor _, tt := range tests {",
            " \t\tt.Run(tt.name, func(t *testing.T) {",
            " \t\t\tassert.Equalf(t, tt.want, tt.c.isPentagon(), \"isPentagon()\")",
            " \t\t})",
            " \t}",
            " }",
            "+",
            "+func TestCell_GridDistance(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tother Cell",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tc       Cell",
            "+\t\targs    args",
            "+\t\twant    int",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\tname:    \"identity\",",
            "+\t\t\tc:       0x81283ffffffffff,",
            "+\t\t\targs:    args{other: 0x81283ffffffffff},",
            "+\t\t\twant:    0,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"next to each other\",",
            "+\t\t\tc:       0x872830874ffffff,",
            "+\t\t\targs:    args{other: 0x872830876ffffff},",
            "+\t\t\twant:    1,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"one further away\",",
            "+\t\t\tc:       0x872830874ffffff,",
            "+\t\t\targs:    args{other: 0x87283080dffffff},",
            "+\t\t\twant:    2,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"three away\",",
            "+\t\t\tc:       0x872830874ffffff,",
            "+\t\t\targs:    args{other: 0x872830808ffffff},",
            "+\t\t\twant:    3,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"from examples/distance.c\",",
            "+\t\t\tc:       0x8f2830828052d25,              // 1455 Market St @ resolution 15",
            "+\t\t\targs:    args{other: 0x8f283082a30e623}, // 555 Market St @ resolution 15",
            "+\t\t\twant:    2340,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"resolution mismatch\",",
            "+\t\t\tc:       0x832830fffffffff,",
            "+\t\t\targs:    args{other: 0x822837fffffffff},",
            "+\t\t\twant:    0,",
            "+\t\t\twantErr: assert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"distance from invalid cell\",",
            "+\t\t\tc:       0xffffffffffffffff,",
            "+\t\t\targs:    args{other: 0xffffffffffffffff},",
            "+\t\t\twant:    0,",
            "+\t\t\twantErr: assert.Error,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.c.GridDistance(tt.args.other)",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"GridDistance(%v)\", tt.args.other)) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"GridDistance(%v)\", tt.args.other)",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestCell_Parent(t *testing.T) {",
            "+\ttype args struct {",
            "+\t\tres int",
            "+\t}",
            "+\ttests := []struct {",
            "+\t\tname    string",
            "+\t\tc       Cell",
            "+\t\targs    args",
            "+\t\twant    Cell",
            "+\t\twantErr assert.ErrorAssertionFunc",
            "+\t}{",
            "+\t\t{",
            "+\t\t\tname:    \"valid parent\",",
            "+\t\t\tc:       0x872830829ffffff,",
            "+\t\t\targs:    args{res: 2},",
            "+\t\t\twant:    0x822837fffffffff,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"res is too low\",",
            "+\t\t\tc:       0x872830829ffffff,",
            "+\t\t\targs:    args{res: -1},",
            "+\t\t\twant:    0,",
            "+\t\t\twantErr: assert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"res is too high\",",
            "+\t\t\tc:       0x872830829ffffff,",
            "+\t\t\targs:    args{res: MAX_H3_RES + 1},",
            "+\t\t\twant:    0,",
            "+\t\t\twantErr: assert.Error,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"res is same\",",
            "+\t\t\tc:       0x872830829ffffff,",
            "+\t\t\targs:    args{res: 7},",
            "+\t\t\twant:    0x872830829ffffff,",
            "+\t\t\twantErr: assert.NoError,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:    \"res is higher\",",
            "+\t\t\tc:       0x872830829ffffff,",
            "+\t\t\targs:    args{res: 16},",
            "+\t\t\twant:    0,",
            "+\t\t\twantErr: assert.Error,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tgot, err := tt.c.Parent(tt.args.res)",
            "+\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"Parent(%v)\", tt.args.res)) {",
            "+\t\t\t\treturn",
            "+\t\t\t}",
            "+\t\t\tassert.Equalf(t, tt.want, got, \"Parent(%v)\", tt.args.res)",
            "+\t\t})",
            "+\t}",
            "+}"
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/coordijk.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/coordijk.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/coordijk.go",
            "@@ -781,7 +781,55 @@",
            " ",
            " \tif o.normalizeCouldOverflow() {",
            " \t\treturn coordIJK{}, ErrInvalidArgument",
            " \t}",
            " ",
            " \treturn o.normalize(), nil",
            " }",
            "+",
            "+// rotate60cw rotates the ijk coordinates 60 degrees clockwise and returns the result.",
            "+func (c coordIJK) rotate60cw() coordIJK {",
            "+\t// unit vector rotations",
            "+\tiVec := coordIJK{1, 0, 1}",
            "+\tjVec := coordIJK{1, 1, 0}",
            "+\tkVec := coordIJK{0, 1, 1}",
            "+",
            "+\tiVec = iVec.scale(c.i)",
            "+\tjVec = jVec.scale(c.j)",
            "+\tkVec = kVec.scale(c.k)",
            "+",
            "+\tout := iVec.add(jVec)",
            "+\tout = out.add(kVec)",
            "+",
            "+\tout = out.normalize()",
            "+\treturn out",
            "+}",
            "+",
            "+// rotate60ccw rotates the ijk coordinates 60 degrees counter-clockwise and returns the result.",
            "+func (c coordIJK) rotate60ccw() coordIJK {",
            "+\t// unit vector rotations",
            "+\tiVec := coordIJK{1, 1, 0}",
            "+\tjVec := coordIJK{0, 1, 1}",
            "+\tkVec := coordIJK{1, 0, 1}",
            "+",
            "+\tiVec = iVec.scale(c.i)",
            "+\tjVec = jVec.scale(c.j)",
            "+\tkVec = kVec.scale(c.k)",
            "+",
            "+\tout := iVec.add(jVec)",
            "+\tout = out.add(kVec)",
            "+",
            "+\tout = out.normalize()",
            "+\treturn out",
            "+}",
            "+",
            "+// Distance returns the distance between two ijk coordinates.",
            "+func (c coordIJK) Distance(other coordIJK) int {",
            "+\tdiff := c.subtract(other)",
            "+\tdiff = diff.normalize()",
            "+\tabsDiff := coordIJK{",
            "+\t\ti: int(math.Abs(float64(diff.i))),",
            "+\t\tj: int(math.Abs(float64(diff.j))),",
            "+\t\tk: int(math.Abs(float64(diff.k))),",
            "+\t}",
            "+\treturn max(max(absDiff.i, absDiff.j), absDiff.k)",
            "+}"
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/grid_disk.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/grid_disk.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/grid_disk.go",
            "@@ -6,37 +6,37 @@",
            " ",
            " const (",
            " \t// K_ALL_CELLS_AT_RES_15 is the k value that encompass all cells at resolution",
            " \t// 15. This is the largest possible k in the H3 grid system.",
            " \tK_ALL_CELLS_AT_RES_15 = 13780510",
            " )",
            " ",
            "-// Maximum number of cells that result from the gridDisk algorithm with the",
            "+// Maximum number of cells that result from the GridDisk algorithm with the",
            " // given k. Formula source and proof: https://oeis.org/A003215",
            " func maxGridDiskSize(k int) (int, error) {",
            " \tif k < 0 {",
            " \t\treturn 0, ErrInvalidArgument",
            " \t}",
            " ",
            " \tif k >= K_ALL_CELLS_AT_RES_15 {",
            " \t\t// If a k value of this value or above is provided, this function will estimate",
            " \t\t// more cells than exist in the H3 grid at the finest resolution. This is a",
            " \t\t// problem since the function does signed integer arithmetic on `k`, which could",
            " \t\t// overflow. To prevent that, instead substitute the maximum number of cells in",
            "-\t\t// the grid, as it should not be possible for the gridDisk functions to exceed",
            "+\t\t// the grid, as it should not be possible for the GridDisk functions to exceed",
            " \t\t// that. Note this is not resolution specific. So, when resolution < 15, this",
            " \t\t// function may still estimate a size larger than the number of cells in the",
            " \t\t// grid.",
            " \t\treturn getNumCellsAtResolution(MAX_H3_RES), nil",
            " \t}",
            " ",
            " \treturn 3*k*(k+1) + 1, nil",
            " }",
            " ",
            "-// gridDiskDistancesSafe is the safe but slow version of gridDiskDistances (also",
            "+// gridDiskDistancesSafe is the safe but slow version of GridDiskDistances (also",
            " // called by it when needed).",
            " //",
            " // Includes the origin cell in the output list (treating it as a hash set) and",
            " // recurses to its neighbors, if needed.",
            " func (c Cell) gridDiskDistancesSafe(k int) ([]Cell, []int, error) {",
            " \tmaxIdx, err := maxGridDiskSize(k)",
            " \tif err != nil {",
            "@@ -135,29 +135,29 @@",
            " // Output behavior is undefined when one of the indexes returned by this",
            " // function is a pentagon or is in the pentagon distortion area.",
            " func (c Cell) gridDiskUnsafe(k int) ([]Cell, error) {",
            " \tcells, _, err := c.gridDiskDistancesUnsafe(k)",
            " \treturn cells, err",
            " }",
            " ",
            "-// gridDisk produces cells within k distance of the origin cell.",
            "+// GridDisk produces cells within k distance of the origin cell.",
            " //",
            " // k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and",
            " // all neighboring cells, and so on.",
            "-func (c Cell) gridDisk(k int) ([]Cell, error) {",
            "-\tcells, _, err := c.gridDiskDistances(k)",
            "+func (c Cell) GridDisk(k int) ([]Cell, error) {",
            "+\tcells, _, err := c.GridDiskDistances(k)",
            " \treturn cells, err",
            " }",
            " ",
            "-// gridDiskDistances produces cells and their distances from the given origin",
            "+// GridDiskDistances produces cells and their distances from the given origin",
            " // cell, up to distance k.",
            " //",
            " // k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and",
            " // all neighboring cells, and so on.",
            "-func (c Cell) gridDiskDistances(k int) ([]Cell, []int, error) {",
            "+func (c Cell) GridDiskDistances(k int) ([]Cell, []int, error) {",
            " \t// Try the faster, unsafe version first",
            " \tcells, distances, err := c.gridDiskDistancesUnsafe(k)",
            " \tif err == nil {",
            " \t\treturn cells, distances, nil",
            " \t}",
            " ",
            " \t// If the unsafe version failed, fall back to the safe version"
          ]
        },
        {
          "file": "/home/h3-go-0.5.0/pkg/h3/grid_disk_test.go",
          "change": [
            "--- /home/h3-go-0.1.0/pkg/h3/grid_disk_test.go",
            "+++ /home/h3-go-0.5.0/pkg/h3/grid_disk_test.go",
            "@@ -75,25 +75,25 @@",
            " \t\tcells, distances, err = sf.gridDiskDistancesSafe(-1)",
            " \t\tassert.Error(t, err)",
            " \t\tassert.Nil(t, cells)",
            " \t\tassert.Nil(t, distances)",
            " \t})",
            " ",
            " \tt.Run(\"invalid cell\", func(t *testing.T) {",
            "-\t\t_, err := Cell(0x7fffffffffffffff).gridDisk(1000)",
            "-\t\tassert.Error(t, err, \"should not be able to create a cell from an invalid index\")",
            "+\t\t_, err := Cell(0x7fffffffffffffff).GridDisk(1000)",
            "+\t\tassert.Error(t, err, \"should not be able to create a grid disk from an invalid index\")",
            " \t})",
            " ",
            " \tt.Run(\"san francisco k=0\", func(t *testing.T) {",
            " \t\t// This should run into a pentagon and go into the slower, recursive \"safe\" path.",
            " \t\tsfLL := NewLatLng(37.813318, -122.40929)",
            " \t\tsf, err := NewCellFromLatLng(sfLL, 0)",
            " \t\tassert.NoError(t, err)",
            " ",
            "-\t\tcells, distances, err := sf.gridDiskDistances(0)",
            "+\t\tcells, distances, err := sf.GridDiskDistances(0)",
            " \t\tassert.NoError(t, err)",
            " \t\tassert.Len(t, cells, 1)",
            " \t\tassert.Len(t, distances, 1)",
            " ",
            " \t\texpectedDistances := []int{0}",
            " \t\tassert.Equal(t, expectedDistances, distances)",
            " \t\texpectedCells := []Cell{sf}",
            "@@ -102,15 +102,15 @@",
            " ",
            " \tt.Run(\"san francisco res=1 k=1\", func(t *testing.T) {",
            " \t\t// This should not run into a pentagon and should be able to use the faster, \"unsafe\" path.",
            " \t\tsfLL := NewLatLng(37.813318, -122.40929)",
            " \t\tsf, err := NewCellFromLatLng(sfLL, 1)",
            " \t\tassert.NoError(t, err)",
            " ",
            "-\t\tcells, distances, err := sf.gridDiskDistances(1)",
            "+\t\tcells, distances, err := sf.GridDiskDistances(1)",
            " \t\tassert.NoError(t, err)",
            " \t\tassert.Len(t, cells, 7)",
            " \t\tassert.Len(t, distances, 7)",
            " ",
            " \t\t// First cell is the origin, so it should have a distance of 0. The rest should be 1.",
            " \t\texpectedDistances := []int{0, 1, 1, 1, 1, 1, 1}",
            " \t\tassert.Equal(t, expectedDistances, distances)",
            "@@ -128,15 +128,15 @@",
            " \t})",
            " ",
            " \tt.Run(\"san francisco res=0 k=1\", func(t *testing.T) {",
            " \t\tsfLL := NewLatLng(37.813318, -122.40929)",
            " \t\tsf, err := NewCellFromLatLng(sfLL, 0)",
            " \t\tassert.NoError(t, err)",
            " ",
            "-\t\tcells, distances, err := sf.gridDiskDistances(1)",
            "+\t\tcells, distances, err := sf.GridDiskDistances(1)",
            " \t\tassert.NoError(t, err)",
            " \t\tassert.Len(t, cells, 7)",
            " \t\tassert.Len(t, distances, 7)",
            " ",
            " \t\t// First cell is the origin, so it should have a distance of 0. The rest should be 1.",
            " \t\texpectedDistances := []int{1, 1, 1, 0, 1, 1, 1}",
            " \t\tassert.Equal(t, expectedDistances, distances)"
          ]
        }
      ]
    }
  }
}