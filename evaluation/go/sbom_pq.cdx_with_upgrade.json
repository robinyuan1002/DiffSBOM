{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:95bab06c-e275-427c-8c3c-534c769ad684",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T13:44:12-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "adb3b81819cc6afb",
      "type": "file",
      "name": "pq-1.10.9/"
    }
  },
  "components": [
    {
      "bom-ref": "pkg:github/actions/checkout@v2?package-id=c09d14cd3aa450f1",
      "type": "library",
      "name": "actions/checkout",
      "version": "v2",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/codeql-analysis.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v2?package-id=01a34e8a081a4b84",
      "type": "library",
      "name": "actions/checkout",
      "version": "v2",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/test.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/setup-go@v2?package-id=fab9a986d0385e18",
      "type": "library",
      "name": "actions/setup-go",
      "version": "v2",
      "cpe": "cpe:2.3:a:actions\\/setup-go:actions\\/setup-go:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/setup-go@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup-go:actions\\/setup_go:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup_go:actions\\/setup-go:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup_go:actions\\/setup_go:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup:actions\\/setup-go:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup:actions\\/setup_go:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/test.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/alexbrainman/sspi@v0.0.0-20180613141037-e580b900e9f5?package-id=e77eba4dafc07f7f",
      "type": "library",
      "name": "github.com/alexbrainman/sspi",
      "version": "v0.0.0-20180613141037-e580b900e9f5",
      "cpe": "cpe:2.3:a:alexbrainman:sspi:v0.0.0-20180613141037-e580b900e9f5:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/alexbrainman/sspi@v0.0.0-20180613141037-e580b900e9f5",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/auth/kerberos/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:P5U+E4x5OkVEKQDklVPmzs71WM56RTTRqV4OrDC//Y4="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/jcmturner/gokrb5@v8.2.0?package-id=50a752222f3b6013#v8",
      "type": "library",
      "name": "github.com/jcmturner/gokrb5/v8",
      "version": "v8.2.0",
      "cpe": "cpe:2.3:a:jcmturner:gokrb5\\/v8:v8.2.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/jcmturner/gokrb5@v8.2.0#v8",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/auth/kerberos/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:lzPl/30ZLkTveYsYZPKMcgXc8MbnE6RsTd4F9KgiLtk="
        }
      ]
    },
    {
      "bom-ref": "pkg:github/github/codeql-action@v1?package-id=18af62aa75b723ff#analyze",
      "type": "library",
      "name": "github/codeql-action/analyze",
      "version": "v1",
      "cpe": "cpe:2.3:a:github\\/codeql-action\\/analyze:github\\/codeql-action\\/analyze:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/github/codeql-action@v1#analyze",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql-action\\/analyze:github\\/codeql_action\\/analyze:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/analyze:github\\/codeql-action\\/analyze:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/analyze:github\\/codeql_action\\/analyze:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql-action\\/analyze:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql_action\\/analyze:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/codeql-analysis.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/github/codeql-action@v1?package-id=af1304530876e6d4#init",
      "type": "library",
      "name": "github/codeql-action/init",
      "version": "v1",
      "cpe": "cpe:2.3:a:github\\/codeql-action\\/init:github\\/codeql-action\\/init:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/github/codeql-action@v1#init",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql-action\\/init:github\\/codeql_action\\/init:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/init:github\\/codeql-action\\/init:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql_action\\/init:github\\/codeql_action\\/init:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql-action\\/init:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:github\\/codeql:github\\/codeql_action\\/init:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/codeql-analysis.yml"
        }
      ]
    },
    {
      "bom-ref": "5e19ea2e1f9dfee4",
      "type": "file",
      "name": "/home/pq-1.10.9/.github/workflows/codeql-analysis.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "f523b0d9b0169dd7cfdd2269cc5f683b68d5233d"
        },
        {
          "alg": "SHA-256",
          "content": "de3a4c7f0058d227f8f48f9eaabaddeb6e0c794c7b74b52dec09fcffe695f00f"
        }
      ]
    },
    {
      "bom-ref": "cab532682e2c03a4",
      "type": "file",
      "name": "/home/pq-1.10.9/.github/workflows/test.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "14c56e208f86a7f456ea53a67b85528470474048"
        },
        {
          "alg": "SHA-256",
          "content": "849c48ec837761f59c44c326c0ccc64c61198d93ee80004690ef067e1a17acd6"
        }
      ]
    },
    {
      "bom-ref": "8bbc04c4d5853769",
      "type": "file",
      "name": "/home/pq-1.10.9/auth/kerberos/go.mod",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "64b071a107bb1e63fe32825615891fe92dc114da"
        },
        {
          "alg": "SHA-256",
          "content": "894af40abe3b9c4f8a9f7c6aa4297b81812bd04ea91bd970c62f608fcafbe68e"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/pq-1.10.1",
      "New file": [
        "/home/pq-1.10.9/conn_go115.go",
        "/home/pq-1.10.9/ssl_permissions_test.go",
        "/home/pq-1.10.9/user_other.go"
      ],
      "Deleted file": [],
      "Modified file": [
        {
          "file": "/home/pq-1.10.9/array.go",
          "change": [
            "--- /home/pq-1.10.1/array.go",
            "+++ /home/pq-1.10.9/array.go",
            "@@ -583,16 +583,16 @@",
            " \t\treturn err",
            " \t}",
            " \tif *a != nil && len(elems) == 0 {",
            " \t\t*a = (*a)[:0]",
            " \t} else {",
            " \t\tb := make(Int32Array, len(elems))",
            " \t\tfor i, v := range elems {",
            "-\t\t\tvar x int",
            "-\t\t\tif x, err = strconv.Atoi(string(v)); err != nil {",
            "+\t\t\tx, err := strconv.ParseInt(string(v), 10, 32)",
            "+\t\t\tif err != nil {",
            " \t\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: %v\", i, err)",
            " \t\t\t}",
            " \t\t\tb[i] = int32(x)",
            " \t\t}",
            " \t\t*a = b",
            " \t}",
            " \treturn nil"
          ]
        },
        {
          "file": "/home/pq-1.10.9/auth/kerberos/krb_unix.go",
          "change": [
            "--- /home/pq-1.10.1/auth/kerberos/krb_unix.go",
            "+++ /home/pq-1.10.9/auth/kerberos/krb_unix.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build !windows",
            " // +build !windows",
            " ",
            " package kerberos",
            " ",
            " import (",
            " \t\"fmt\"",
            " \t\"os\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/auth/kerberos/krb_windows.go",
          "change": [
            "--- /home/pq-1.10.1/auth/kerberos/krb_windows.go",
            "+++ /home/pq-1.10.9/auth/kerberos/krb_windows.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build windows",
            " // +build windows",
            " ",
            " package kerberos",
            " ",
            " import (",
            " \t\"github.com/alexbrainman/sspi\"",
            " \t\"github.com/alexbrainman/sspi/negotiate\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/conn.go",
          "change": [
            "--- /home/pq-1.10.1/conn.go",
            "+++ /home/pq-1.10.9/conn.go",
            "@@ -1,11 +1,12 @@",
            " package pq",
            " ",
            " import (",
            " \t\"bufio\"",
            "+\t\"bytes\"",
            " \t\"context\"",
            " \t\"crypto/md5\"",
            " \t\"crypto/sha256\"",
            " \t\"database/sql\"",
            " \t\"database/sql/driver\"",
            " \t\"encoding/binary\"",
            " \t\"errors\"",
            "@@ -14,29 +15,31 @@",
            " \t\"net\"",
            " \t\"os\"",
            " \t\"os/user\"",
            " \t\"path\"",
            " \t\"path/filepath\"",
            " \t\"strconv\"",
            " \t\"strings\"",
            "-\t\"sync/atomic\"",
            "+\t\"sync\"",
            " \t\"time\"",
            " \t\"unicode\"",
            " ",
            " \t\"github.com/lib/pq/oid\"",
            " \t\"github.com/lib/pq/scram\"",
            " )",
            " ",
            " // Common error types",
            " var (",
            " \tErrNotSupported              = errors.New(\"pq: Unsupported command\")",
            " \tErrInFailedTransaction       = errors.New(\"pq: Could not complete operation in a failed transaction\")",
            " \tErrSSLNotSupported           = errors.New(\"pq: SSL is not enabled on the server\")",
            "-\tErrSSLKeyHasWorldPermissions = errors.New(\"pq: Private key file has group or world access. Permissions should be u=rw (0600) or less\")",
            "-\tErrCouldNotDetectUsername    = errors.New(\"pq: Could not detect default username. Please provide one explicitly\")",
            "+\tErrSSLKeyUnknownOwnership    = errors.New(\"pq: Could not get owner information for private key, may not be properly protected\")",
            "+\tErrSSLKeyHasWorldPermissions = errors.New(\"pq: Private key has world access. Permissions should be u=rw,g=r (0640) if owned by root, or u=rw (0600), or less\")",
            "+",
            "+\tErrCouldNotDetectUsername = errors.New(\"pq: Could not detect default username. Please provide one explicitly\")",
            " ",
            " \terrUnexpectedReady = errors.New(\"unexpected ReadyForQuery\")",
            " \terrNoRowsAffected  = errors.New(\"no RowsAffected available after the empty statement\")",
            " \terrNoLastInsertID  = errors.New(\"no LastInsertId available after the empty statement\")",
            " )",
            " ",
            " // Compile time validation that our types implement the expected interfaces",
            "@@ -106,15 +109,17 @@",
            " type defaultDialer struct {",
            " \td net.Dialer",
            " }",
            " ",
            " func (d defaultDialer) Dial(network, address string) (net.Conn, error) {",
            " \treturn d.d.Dial(network, address)",
            " }",
            "-func (d defaultDialer) DialTimeout(network, address string, timeout time.Duration) (net.Conn, error) {",
            "+func (d defaultDialer) DialTimeout(",
            "+\tnetwork, address string, timeout time.Duration,",
            "+) (net.Conn, error) {",
            " \tctx, cancel := context.WithTimeout(context.Background(), timeout)",
            " \tdefer cancel()",
            " \treturn d.DialContext(ctx, network, address)",
            " }",
            " func (d defaultDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {",
            " \treturn d.d.DialContext(ctx, network, address)",
            " }",
            "@@ -136,17 +141,18 @@",
            " \tsecretKey int",
            " ",
            " \tparameterStatus parameterStatus",
            " ",
            " \tsaveMessageType   byte",
            " \tsaveMessageBuffer []byte",
            " ",
            "-\t// If true, this connection is bad and all public-facing functions should",
            "-\t// return ErrBadConn.",
            "-\tbad *atomic.Value",
            "+\t// If an error is set, this connection is bad and all public-facing",
            "+\t// functions should return the appropriate error by calling get()",
            "+\t// (ErrBadConn) or getForNext().",
            "+\terr syncErr",
            " ",
            " \t// If set, this connection should never use the binary format when",
            " \t// receiving query results from prepared statements.  Only provided for",
            " \t// debugging.",
            " \tdisablePreparedBinaryResult bool",
            " ",
            " \t// Whether to always send []byte parameters over as binary.  Enables single",
            "@@ -162,14 +168,48 @@",
            " \t// If not nil, notifications will be synchronously sent here",
            " \tnotificationHandler func(*Notification)",
            " ",
            " \t// GSSAPI context",
            " \tgss GSS",
            " }",
            " ",
            "+type syncErr struct {",
            "+\terr error",
            "+\tsync.Mutex",
            "+}",
            "+",
            "+// Return ErrBadConn if connection is bad.",
            "+func (e *syncErr) get() error {",
            "+\te.Lock()",
            "+\tdefer e.Unlock()",
            "+\tif e.err != nil {",
            "+\t\treturn driver.ErrBadConn",
            "+\t}",
            "+\treturn nil",
            "+}",
            "+",
            "+// Return the error set on the connection. Currently only used by rows.Next.",
            "+func (e *syncErr) getForNext() error {",
            "+\te.Lock()",
            "+\tdefer e.Unlock()",
            "+\treturn e.err",
            "+}",
            "+",
            "+// Set error, only if it isn't set yet.",
            "+func (e *syncErr) set(err error) {",
            "+\tif err == nil {",
            "+\t\tpanic(\"attempt to set nil err\")",
            "+\t}",
            "+\te.Lock()",
            "+\tdefer e.Unlock()",
            "+\tif e.err == nil {",
            "+\t\te.err = err",
            "+\t}",
            "+}",
            "+",
            " // Handle driver-side settings in parsed connection string.",
            " func (cn *conn) handleDriverSettings(o values) (err error) {",
            " \tboolSetting := func(key string, val *bool) error {",
            " \t\tif value, ok := o[key]; ok {",
            " \t\t\tif value == \"yes\" {",
            " \t\t\t\t*val = true",
            " \t\t\t} else if value == \"no\" {",
            "@@ -219,55 +259,64 @@",
            " \t}",
            " \tfile, err := os.Open(filename)",
            " \tif err != nil {",
            " \t\treturn",
            " \t}",
            " \tdefer file.Close()",
            " \tscanner := bufio.NewScanner(io.Reader(file))",
            "+\t// From: https://github.com/tg/pgpass/blob/master/reader.go",
            "+\tfor scanner.Scan() {",
            "+\t\tif scanText(scanner.Text(), o) {",
            "+\t\t\tbreak",
            "+\t\t}",
            "+\t}",
            "+}",
            "+",
            "+// GetFields is a helper function for scanText.",
            "+func getFields(s string) []string {",
            "+\tfs := make([]string, 0, 5)",
            "+\tf := make([]rune, 0, len(s))",
            "+",
            "+\tvar esc bool",
            "+\tfor _, c := range s {",
            "+\t\tswitch {",
            "+\t\tcase esc:",
            "+\t\t\tf = append(f, c)",
            "+\t\t\tesc = false",
            "+\t\tcase c == '\\\\':",
            "+\t\t\tesc = true",
            "+\t\tcase c == ':':",
            "+\t\t\tfs = append(fs, string(f))",
            "+\t\t\tf = f[:0]",
            "+\t\tdefault:",
            "+\t\t\tf = append(f, c)",
            "+\t\t}",
            "+\t}",
            "+\treturn append(fs, string(f))",
            "+}",
            "+",
            "+// ScanText assists HandlePgpass in it's objective.",
            "+func scanText(line string, o values) bool {",
            " \thostname := o[\"host\"]",
            " \tntw, _ := network(o)",
            " \tport := o[\"port\"]",
            " \tdb := o[\"dbname\"]",
            " \tusername := o[\"user\"]",
            "-\t// From: https://github.com/tg/pgpass/blob/master/reader.go",
            "-\tgetFields := func(s string) []string {",
            "-\t\tfs := make([]string, 0, 5)",
            "-\t\tf := make([]rune, 0, len(s))",
            "-",
            "-\t\tvar esc bool",
            "-\t\tfor _, c := range s {",
            "-\t\t\tswitch {",
            "-\t\t\tcase esc:",
            "-\t\t\t\tf = append(f, c)",
            "-\t\t\t\tesc = false",
            "-\t\t\tcase c == '\\\\':",
            "-\t\t\t\tesc = true",
            "-\t\t\tcase c == ':':",
            "-\t\t\t\tfs = append(fs, string(f))",
            "-\t\t\t\tf = f[:0]",
            "-\t\t\tdefault:",
            "-\t\t\t\tf = append(f, c)",
            "-\t\t\t}",
            "-\t\t}",
            "-\t\treturn append(fs, string(f))",
            "+\tif len(line) == 0 || line[0] == '#' {",
            "+\t\treturn false",
            " \t}",
            "-\tfor scanner.Scan() {",
            "-\t\tline := scanner.Text()",
            "-\t\tif len(line) == 0 || line[0] == '#' {",
            "-\t\t\tcontinue",
            "-\t\t}",
            "-\t\tsplit := getFields(line)",
            "-\t\tif len(split) != 5 {",
            "-\t\t\tcontinue",
            "-\t\t}",
            "-\t\tif (split[0] == \"*\" || split[0] == hostname || (split[0] == \"localhost\" && (hostname == \"\" || ntw == \"unix\"))) && (split[1] == \"*\" || split[1] == port) && (split[2] == \"*\" || split[2] == db) && (split[3] == \"*\" || split[3] == username) {",
            "-\t\t\to[\"password\"] = split[4]",
            "-\t\t\treturn",
            "-\t\t}",
            "+\tsplit := getFields(line)",
            "+\tif len(split) != 5 {",
            "+\t\treturn false",
            " \t}",
            "+\tif (split[0] == \"*\" || split[0] == hostname || (split[0] == \"localhost\" && (hostname == \"\" || ntw == \"unix\"))) && (split[1] == \"*\" || split[1] == port) && (split[2] == \"*\" || split[2] == db) && (split[3] == \"*\" || split[3] == username) {",
            "+\t\to[\"password\"] = split[4]",
            "+\t\treturn true",
            "+\t}",
            "+\treturn false",
            " }",
            " ",
            " func (cn *conn) writeBuf(b byte) *writeBuf {",
            " \tcn.scratch[0] = b",
            " \treturn &writeBuf{",
            " \t\tbuf: cn.scratch[:5],",
            " \t\tpos: 1,",
            "@@ -283,15 +332,15 @@",
            " ",
            " // DialOpen opens a new connection to the database using a dialer.",
            " func DialOpen(d Dialer, dsn string) (_ driver.Conn, err error) {",
            " \tc, err := NewConnector(dsn)",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            "-\tc.dialer = d",
            "+\tc.Dialer(d)",
            " \treturn c.open(context.Background())",
            " }",
            " ",
            " func (c *Connector) open(ctx context.Context) (cn *conn, err error) {",
            " \t// Handle any panics during connection initialization.  Note that we",
            " \t// specifically do *not* want to use errRecover(), as that would turn any",
            " \t// connection errors into ErrBadConns, hiding the real error message from",
            "@@ -302,20 +351,17 @@",
            " \t// connections do not reference the same underlying data structure, so it",
            " \t// is safe for multiple connections to concurrently write to their opts.",
            " \to := make(values)",
            " \tfor k, v := range c.opts {",
            " \t\to[k] = v",
            " \t}",
            " ",
            "-\tbad := &atomic.Value{}",
            "-\tbad.Store(false)",
            " \tcn = &conn{",
            " \t\topts:   o,",
            " \t\tdialer: c.dialer,",
            "-\t\tbad:    bad,",
            " \t}",
            " \terr = cn.handleDriverSettings(o)",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " \tcn.handlePgpass(o)",
            " ",
            "@@ -512,70 +558,57 @@",
            " }",
            " ",
            " func (cn *conn) isInTransaction() bool {",
            " \treturn cn.txnStatus == txnStatusIdleInTransaction ||",
            " \t\tcn.txnStatus == txnStatusInFailedTransaction",
            " }",
            " ",
            "-func (cn *conn) setBad() {",
            "-\tif cn.bad != nil {",
            "-\t\tcn.bad.Store(true)",
            "-\t}",
            "-}",
            "-",
            "-func (cn *conn) getBad() bool {",
            "-\tif cn.bad != nil {",
            "-\t\treturn cn.bad.Load().(bool)",
            "-\t}",
            "-\treturn false",
            "-}",
            "-",
            " func (cn *conn) checkIsInTransaction(intxn bool) {",
            " \tif cn.isInTransaction() != intxn {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected transaction status %v\", cn.txnStatus)",
            " \t}",
            " }",
            " ",
            " func (cn *conn) Begin() (_ driver.Tx, err error) {",
            " \treturn cn.begin(\"\")",
            " }",
            " ",
            " func (cn *conn) begin(mode string) (_ driver.Tx, err error) {",
            "-\tif cn.getBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\tif err := cn.err.get(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tdefer cn.errRecover(&err)",
            " ",
            " \tcn.checkIsInTransaction(false)",
            " \t_, commandTag, err := cn.simpleExec(\"BEGIN\" + mode)",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " \tif commandTag != \"BEGIN\" {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\treturn nil, fmt.Errorf(\"unexpected command tag %s\", commandTag)",
            " \t}",
            " \tif cn.txnStatus != txnStatusIdleInTransaction {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\treturn nil, fmt.Errorf(\"unexpected transaction status %v\", cn.txnStatus)",
            " \t}",
            " \treturn cn, nil",
            " }",
            " ",
            " func (cn *conn) closeTxn() {",
            " \tif finish := cn.txnFinish; finish != nil {",
            " \t\tfinish()",
            " \t}",
            " }",
            " ",
            " func (cn *conn) Commit() (err error) {",
            " \tdefer cn.closeTxn()",
            "-\tif cn.getBad() {",
            "-\t\treturn driver.ErrBadConn",
            "+\tif err := cn.err.get(); err != nil {",
            "+\t\treturn err",
            " \t}",
            " \tdefer cn.errRecover(&err)",
            " ",
            " \tcn.checkIsInTransaction(true)",
            " \t// We don't want the client to think that everything is okay if it tries",
            " \t// to commit a failed transaction.  However, no matter what we return,",
            " \t// database/sql will release this connection back into the free connection",
            "@@ -588,41 +621,41 @@",
            " \t\t}",
            " \t\treturn ErrInFailedTransaction",
            " \t}",
            " ",
            " \t_, commandTag, err := cn.simpleExec(\"COMMIT\")",
            " \tif err != nil {",
            " \t\tif cn.isInTransaction() {",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t}",
            " \t\treturn err",
            " \t}",
            " \tif commandTag != \"COMMIT\" {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\treturn fmt.Errorf(\"unexpected command tag %s\", commandTag)",
            " \t}",
            " \tcn.checkIsInTransaction(false)",
            " \treturn nil",
            " }",
            " ",
            " func (cn *conn) Rollback() (err error) {",
            " \tdefer cn.closeTxn()",
            "-\tif cn.getBad() {",
            "-\t\treturn driver.ErrBadConn",
            "+\tif err := cn.err.get(); err != nil {",
            "+\t\treturn err",
            " \t}",
            " \tdefer cn.errRecover(&err)",
            " \treturn cn.rollback()",
            " }",
            " ",
            " func (cn *conn) rollback() (err error) {",
            " \tcn.checkIsInTransaction(true)",
            " \t_, commandTag, err := cn.simpleExec(\"ROLLBACK\")",
            " \tif err != nil {",
            " \t\tif cn.isInTransaction() {",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t}",
            " \t\treturn err",
            " \t}",
            " \tif commandTag != \"ROLLBACK\" {",
            " \t\treturn fmt.Errorf(\"unexpected command tag %s\", commandTag)",
            " \t}",
            " \tcn.checkIsInTransaction(false)",
            "@@ -654,15 +687,15 @@",
            " \t\tcase 'E':",
            " \t\t\terr = parseError(r)",
            " \t\tcase 'I':",
            " \t\t\tres = emptyRows",
            " \t\tcase 'T', 'D':",
            " \t\t\t// ignore any results",
            " \t\tdefault:",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\terrorf(\"unknown response for simple query: %q\", t)",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " func (cn *conn) simpleQuery(q string) (res *rows, err error) {",
            " \tdefer cn.errRecover(&err)",
            "@@ -676,15 +709,15 @@",
            " \t\tswitch t {",
            " \t\tcase 'C', 'I':",
            " \t\t\t// We allow queries which don't return any results through Query as",
            " \t\t\t// well as Exec.  We still have to give database/sql a rows object",
            " \t\t\t// the user can close, though, to avoid connections from being",
            " \t\t\t// leaked.  A \"rows\" with done=true works fine for that purpose.",
            " \t\t\tif err != nil {",
            "-\t\t\t\tcn.setBad()",
            "+\t\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\t\terrorf(\"unexpected message %q in simple query execution\", t)",
            " \t\t\t}",
            " \t\t\tif res == nil {",
            " \t\t\t\tres = &rows{",
            " \t\t\t\t\tcn: cn,",
            " \t\t\t\t}",
            " \t\t\t}",
            "@@ -703,30 +736,30 @@",
            " \t\t\t// done",
            " \t\t\treturn",
            " \t\tcase 'E':",
            " \t\t\tres = nil",
            " \t\t\terr = parseError(r)",
            " \t\tcase 'D':",
            " \t\t\tif res == nil {",
            "-\t\t\t\tcn.setBad()",
            "+\t\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\t\terrorf(\"unexpected DataRow in simple query execution\")",
            " \t\t\t}",
            " \t\t\t// the query didn't fail; kick off to Next",
            " \t\t\tcn.saveMessage(t, r)",
            " \t\t\treturn",
            " \t\tcase 'T':",
            " \t\t\t// res might be non-nil here if we received a previous",
            " \t\t\t// CommandComplete, but that's fine; just overwrite it",
            " \t\t\tres = &rows{cn: cn}",
            " \t\t\tres.rowsHeader = parsePortalRowDescribe(r)",
            " ",
            " \t\t\t// To work around a bug in QueryRow in Go 1.2 and earlier, wait",
            " \t\t\t// until the first DataRow has been received.",
            " \t\tdefault:",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\terrorf(\"unknown response for simple query: %q\", t)",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " type noRows struct{}",
            " ",
            "@@ -740,15 +773,17 @@",
            " ",
            " func (noRows) RowsAffected() (int64, error) {",
            " \treturn 0, errNoRowsAffected",
            " }",
            " ",
            " // Decides which column formats to use for a prepared statement.  The input is",
            " // an array of type oids, one element per result column.",
            "-func decideColumnFormats(colTyps []fieldDesc, forceText bool) (colFmts []format, colFmtData []byte) {",
            "+func decideColumnFormats(",
            "+\tcolTyps []fieldDesc, forceText bool,",
            "+) (colFmts []format, colFmtData []byte) {",
            " \tif len(colTyps) == 0 {",
            " \t\treturn nil, colFmtDataAllText",
            " \t}",
            " ",
            " \tcolFmts = make([]format, len(colTyps))",
            " \tif forceText {",
            " \t\treturn colFmts, colFmtDataAllText",
            "@@ -811,16 +846,16 @@",
            " \tst.paramTyps, st.colNames, st.colTyps = cn.readStatementDescribeResponse()",
            " \tst.colFmts, st.colFmtData = decideColumnFormats(st.colTyps, cn.disablePreparedBinaryResult)",
            " \tcn.readReadyForQuery()",
            " \treturn st",
            " }",
            " ",
            " func (cn *conn) Prepare(q string) (_ driver.Stmt, err error) {",
            "-\tif cn.getBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\tif err := cn.err.get(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tdefer cn.errRecover(&err)",
            " ",
            " \tif len(q) >= 4 && strings.EqualFold(q[:4], \"COPY\") {",
            " \t\ts, err := cn.prepareCopyIn(q)",
            " \t\tif err == nil {",
            " \t\t\tcn.inCopy = true",
            "@@ -850,16 +885,16 @@",
            " ",
            " // Implement the \"Queryer\" interface",
            " func (cn *conn) Query(query string, args []driver.Value) (driver.Rows, error) {",
            " \treturn cn.query(query, args)",
            " }",
            " ",
            " func (cn *conn) query(query string, args []driver.Value) (_ *rows, err error) {",
            "-\tif cn.getBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\tif err := cn.err.get(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tif cn.inCopy {",
            " \t\treturn nil, errCopyInProgress",
            " \t}",
            " \tdefer cn.errRecover(&err)",
            " ",
            " \t// Check to see if we can use the \"simpleQuery\" interface, which is",
            "@@ -884,16 +919,16 @@",
            " \t\tcn:         cn,",
            " \t\trowsHeader: st.rowsHeader,",
            " \t}, nil",
            " }",
            " ",
            " // Implement the optional \"Execer\" interface for one-shot queries",
            " func (cn *conn) Exec(query string, args []driver.Value) (res driver.Result, err error) {",
            "-\tif cn.getBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\tif err := cn.err.get(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tdefer cn.errRecover(&err)",
            " ",
            " \t// Check to see if we can use the \"simpleExec\" interface, which is",
            " \t// *much* faster than going through prepare/exec",
            " \tif len(args) == 0 {",
            " \t\t// ignore commandTag, our caller doesn't care",
            "@@ -956,15 +991,15 @@",
            " // saveMessage memorizes a message and its buffer in the conn struct.",
            " // recvMessage will then return these values on the next call to it.  This",
            " // method is useful in cases where you have to see what the next message is",
            " // going to be (e.g. to see whether it's an error or not) but you can't handle",
            " // the message yourself.",
            " func (cn *conn) saveMessage(typ byte, buf *readBuf) {",
            " \tif cn.saveMessageType != 0 {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected saveMessageType %d\", cn.saveMessageType)",
            " \t}",
            " \tcn.saveMessageType = typ",
            " \tcn.saveMessageBuffer = *buf",
            " }",
            " ",
            " // recvMessage receives any message from the backend, or returns an error if",
            "@@ -1102,15 +1137,15 @@",
            " // startup packet.",
            " func isDriverSetting(key string) bool {",
            " \tswitch key {",
            " \tcase \"host\", \"port\":",
            " \t\treturn true",
            " \tcase \"password\":",
            " \t\treturn true",
            "-\tcase \"sslmode\", \"sslcert\", \"sslkey\", \"sslrootcert\", \"sslinline\":",
            "+\tcase \"sslmode\", \"sslcert\", \"sslkey\", \"sslrootcert\", \"sslinline\", \"sslsni\":",
            " \t\treturn true",
            " \tcase \"fallback_application_name\":",
            " \t\treturn true",
            " \tcase \"connect_timeout\":",
            " \t\treturn true",
            " \tcase \"disable_prepared_binary_result\":",
            " \t\treturn true",
            "@@ -1326,59 +1361,63 @@",
            " \tclosed     bool",
            " }",
            " ",
            " func (st *stmt) Close() (err error) {",
            " \tif st.closed {",
            " \t\treturn nil",
            " \t}",
            "-\tif st.cn.getBad() {",
            "-\t\treturn driver.ErrBadConn",
            "+\tif err := st.cn.err.get(); err != nil {",
            "+\t\treturn err",
            " \t}",
            " \tdefer st.cn.errRecover(&err)",
            " ",
            " \tw := st.cn.writeBuf('C')",
            " \tw.byte('S')",
            " \tw.string(st.name)",
            " \tst.cn.send(w)",
            " ",
            " \tst.cn.send(st.cn.writeBuf('S'))",
            " ",
            " \tt, _ := st.cn.recv1()",
            " \tif t != '3' {",
            "-\t\tst.cn.setBad()",
            "+\t\tst.cn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected close response: %q\", t)",
            " \t}",
            " \tst.closed = true",
            " ",
            " \tt, r := st.cn.recv1()",
            " \tif t != 'Z' {",
            "-\t\tst.cn.setBad()",
            "+\t\tst.cn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"expected ready for query, but got: %q\", t)",
            " \t}",
            " \tst.cn.processReadyForQuery(r)",
            " ",
            " \treturn nil",
            " }",
            " ",
            " func (st *stmt) Query(v []driver.Value) (r driver.Rows, err error) {",
            "-\tif st.cn.getBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\treturn st.query(v)",
            "+}",
            "+",
            "+func (st *stmt) query(v []driver.Value) (r *rows, err error) {",
            "+\tif err := st.cn.err.get(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tdefer st.cn.errRecover(&err)",
            " ",
            " \tst.exec(v)",
            " \treturn &rows{",
            " \t\tcn:         st.cn,",
            " \t\trowsHeader: st.rowsHeader,",
            " \t}, nil",
            " }",
            " ",
            " func (st *stmt) Exec(v []driver.Value) (res driver.Result, err error) {",
            "-\tif st.cn.getBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\tif err := st.cn.err.get(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tdefer st.cn.errRecover(&err)",
            " ",
            " \tst.exec(v)",
            " \tres, _, err = st.cn.readExecuteResponse(\"simple query\")",
            " \treturn res, err",
            " }",
            "@@ -1456,27 +1495,27 @@",
            " \t// INSERT also includes the oid of the inserted row in its command tag.",
            " \t// Oids in user tables are deprecated, and the oid is only returned when",
            " \t// exactly one row is inserted, so it's unlikely to be of value to any",
            " \t// real-world application and we can ignore it.",
            " \tif affectedRows == nil && strings.HasPrefix(commandTag, \"INSERT \") {",
            " \t\tparts := strings.Split(commandTag, \" \")",
            " \t\tif len(parts) != 3 {",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\terrorf(\"unexpected INSERT command tag %s\", commandTag)",
            " \t\t}",
            " \t\taffectedRows = &parts[len(parts)-1]",
            " \t\tcommandTag = \"INSERT\"",
            " \t}",
            " \t// There should be no affected rows attached to the tag, just return it",
            " \tif affectedRows == nil {",
            " \t\treturn driver.RowsAffected(0), commandTag",
            " \t}",
            " \tn, err := strconv.ParseInt(*affectedRows, 10, 64)",
            " \tif err != nil {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"could not parse commandTag: %s\", err)",
            " \t}",
            " \treturn driver.RowsAffected(n), commandTag",
            " }",
            " ",
            " type rowsHeader struct {",
            " \tcolNames []string",
            "@@ -1535,16 +1574,16 @@",
            " ",
            " func (rs *rows) Next(dest []driver.Value) (err error) {",
            " \tif rs.done {",
            " \t\treturn io.EOF",
            " \t}",
            " ",
            " \tconn := rs.cn",
            "-\tif conn.getBad() {",
            "-\t\treturn driver.ErrBadConn",
            "+\tif err := conn.err.getForNext(); err != nil {",
            "+\t\treturn err",
            " \t}",
            " \tdefer conn.errRecover(&err)",
            " ",
            " \tfor {",
            " \t\tt := conn.recv1Buf(&rs.rb)",
            " \t\tswitch t {",
            " \t\tcase 'E':",
            "@@ -1560,15 +1599,15 @@",
            " \t\t\tif err != nil {",
            " \t\t\t\treturn err",
            " \t\t\t}",
            " \t\t\treturn io.EOF",
            " \t\tcase 'D':",
            " \t\t\tn := rs.rb.int16()",
            " \t\t\tif err != nil {",
            "-\t\t\t\tconn.setBad()",
            "+\t\t\t\tconn.err.set(driver.ErrBadConn)",
            " \t\t\t\terrorf(\"unexpected DataRow after error %s\", err)",
            " \t\t\t}",
            " \t\t\tif n < len(dest) {",
            " \t\t\t\tdest = dest[:n]",
            " \t\t\t}",
            " \t\t\tfor i := range dest {",
            " \t\t\t\tl := rs.rb.int32()",
            "@@ -1602,36 +1641,48 @@",
            " \trs.next = nil",
            " \treturn nil",
            " }",
            " ",
            " // QuoteIdentifier quotes an \"identifier\" (e.g. a table or a column name) to be",
            " // used as part of an SQL statement.  For example:",
            " //",
            "-//    tblname := \"my_table\"",
            "-//    data := \"my_data\"",
            "-//    quoted := pq.QuoteIdentifier(tblname)",
            "-//    err := db.Exec(fmt.Sprintf(\"INSERT INTO %s VALUES ($1)\", quoted), data)",
            "+//\ttblname := \"my_table\"",
            "+//\tdata := \"my_data\"",
            "+//\tquoted := pq.QuoteIdentifier(tblname)",
            "+//\terr := db.Exec(fmt.Sprintf(\"INSERT INTO %s VALUES ($1)\", quoted), data)",
            " //",
            " // Any double quotes in name will be escaped.  The quoted identifier will be",
            " // case sensitive when used in a query.  If the input string contains a zero",
            " // byte, the result will be truncated immediately before it.",
            " func QuoteIdentifier(name string) string {",
            " \tend := strings.IndexRune(name, 0)",
            " \tif end > -1 {",
            " \t\tname = name[:end]",
            " \t}",
            " \treturn `\"` + strings.Replace(name, `\"`, `\"\"`, -1) + `\"`",
            " }",
            " ",
            "+// BufferQuoteIdentifier satisfies the same purpose as QuoteIdentifier, but backed by a",
            "+// byte buffer.",
            "+func BufferQuoteIdentifier(name string, buffer *bytes.Buffer) {",
            "+\tend := strings.IndexRune(name, 0)",
            "+\tif end > -1 {",
            "+\t\tname = name[:end]",
            "+\t}",
            "+\tbuffer.WriteRune('\"')",
            "+\tbuffer.WriteString(strings.Replace(name, `\"`, `\"\"`, -1))",
            "+\tbuffer.WriteRune('\"')",
            "+}",
            "+",
            " // QuoteLiteral quotes a 'literal' (e.g. a parameter, often used to pass literal",
            " // to DDL and other statements that do not accept parameters) to be used as part",
            " // of an SQL statement.  For example:",
            " //",
            "-//    exp_date := pq.QuoteLiteral(\"2023-01-05 15:00:00Z\")",
            "-//    err := db.Exec(fmt.Sprintf(\"CREATE ROLE my_user VALID UNTIL %s\", exp_date))",
            "+//\texp_date := pq.QuoteLiteral(\"2023-01-05 15:00:00Z\")",
            "+//\terr := db.Exec(fmt.Sprintf(\"CREATE ROLE my_user VALID UNTIL %s\", exp_date))",
            " //",
            " // Any single quotes in name will be escaped. Any backslashes (i.e. \"\\\") will be",
            " // replaced by two backslashes (i.e. \"\\\\\") and the C-style escape identifier",
            " // that PostgreSQL provides ('E') will be prepended to the string.",
            " func QuoteLiteral(literal string) string {",
            " \t// This follows the PostgreSQL internal algorithm for handling quoted literals",
            " \t// from libpq, which can be found in the \"PQEscapeStringInternal\" function,",
            "@@ -1754,15 +1805,15 @@",
            " func (cn *conn) readReadyForQuery() {",
            " \tt, r := cn.recv1()",
            " \tswitch t {",
            " \tcase 'Z':",
            " \t\tcn.processReadyForQuery(r)",
            " \t\treturn",
            " \tdefault:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected message %q; expected ReadyForQuery\", t)",
            " \t}",
            " }",
            " ",
            " func (cn *conn) processBackendKeyData(r *readBuf) {",
            " \tcn.processID = r.int32()",
            " \tcn.secretKey = r.int32()",
            "@@ -1774,20 +1825,24 @@",
            " \tcase '1':",
            " \t\treturn",
            " \tcase 'E':",
            " \t\terr := parseError(r)",
            " \t\tcn.readReadyForQuery()",
            " \t\tpanic(err)",
            " \tdefault:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected Parse response %q\", t)",
            " \t}",
            " }",
            " ",
            "-func (cn *conn) readStatementDescribeResponse() (paramTyps []oid.Oid, colNames []string, colTyps []fieldDesc) {",
            "+func (cn *conn) readStatementDescribeResponse() (",
            "+\tparamTyps []oid.Oid,",
            "+\tcolNames []string,",
            "+\tcolTyps []fieldDesc,",
            "+) {",
            " \tfor {",
            " \t\tt, r := cn.recv1()",
            " \t\tswitch t {",
            " \t\tcase 't':",
            " \t\t\tnparams := r.int16()",
            " \t\t\tparamTyps = make([]oid.Oid, nparams)",
            " \t\t\tfor i := range paramTyps {",
            "@@ -1799,15 +1854,15 @@",
            " \t\t\tcolNames, colTyps = parseStatementRowDescribe(r)",
            " \t\t\treturn paramTyps, colNames, colTyps",
            " \t\tcase 'E':",
            " \t\t\terr := parseError(r)",
            " \t\t\tcn.readReadyForQuery()",
            " \t\t\tpanic(err)",
            " \t\tdefault:",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\terrorf(\"unexpected Describe statement response %q\", t)",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " func (cn *conn) readPortalDescribeResponse() rowsHeader {",
            " \tt, r := cn.recv1()",
            "@@ -1817,15 +1872,15 @@",
            " \tcase 'n':",
            " \t\treturn rowsHeader{}",
            " \tcase 'E':",
            " \t\terr := parseError(r)",
            " \t\tcn.readReadyForQuery()",
            " \t\tpanic(err)",
            " \tdefault:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected Describe response %q\", t)",
            " \t}",
            " \tpanic(\"not reached\")",
            " }",
            " ",
            " func (cn *conn) readBindResponse() {",
            " \tt, r := cn.recv1()",
            "@@ -1833,15 +1888,15 @@",
            " \tcase '2':",
            " \t\treturn",
            " \tcase 'E':",
            " \t\terr := parseError(r)",
            " \t\tcn.readReadyForQuery()",
            " \t\tpanic(err)",
            " \tdefault:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\terrorf(\"unexpected Bind response %q\", t)",
            " \t}",
            " }",
            " ",
            " func (cn *conn) postExecuteWorkaround() {",
            " \t// Work around a bug in sql.DB.QueryRow: in Go 1.2 and earlier it ignores",
            " \t// any errors from rows.Next, which masks errors that happened during the",
            "@@ -1860,50 +1915,52 @@",
            " \t\t\tcn.readReadyForQuery()",
            " \t\t\tpanic(err)",
            " \t\tcase 'C', 'D', 'I':",
            " \t\t\t// the query didn't fail, but we can't process this message",
            " \t\t\tcn.saveMessage(t, r)",
            " \t\t\treturn",
            " \t\tdefault:",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\terrorf(\"unexpected message during extended query execution: %q\", t)",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " // Only for Exec(), since we ignore the returned data",
            "-func (cn *conn) readExecuteResponse(protocolState string) (res driver.Result, commandTag string, err error) {",
            "+func (cn *conn) readExecuteResponse(",
            "+\tprotocolState string,",
            "+) (res driver.Result, commandTag string, err error) {",
            " \tfor {",
            " \t\tt, r := cn.recv1()",
            " \t\tswitch t {",
            " \t\tcase 'C':",
            " \t\t\tif err != nil {",
            "-\t\t\t\tcn.setBad()",
            "+\t\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\t\terrorf(\"unexpected CommandComplete after error %s\", err)",
            " \t\t\t}",
            " \t\t\tres, commandTag = cn.parseComplete(r.string())",
            " \t\tcase 'Z':",
            " \t\t\tcn.processReadyForQuery(r)",
            " \t\t\tif res == nil && err == nil {",
            " \t\t\t\terr = errUnexpectedReady",
            " \t\t\t}",
            " \t\t\treturn res, commandTag, err",
            " \t\tcase 'E':",
            " \t\t\terr = parseError(r)",
            " \t\tcase 'T', 'D', 'I':",
            " \t\t\tif err != nil {",
            "-\t\t\t\tcn.setBad()",
            "+\t\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\t\terrorf(\"unexpected %q after error %s\", t, err)",
            " \t\t\t}",
            " \t\t\tif t == 'I' {",
            " \t\t\t\tres = emptyRows",
            " \t\t\t}",
            " \t\t\t// ignore any results",
            " \t\tdefault:",
            "-\t\t\tcn.setBad()",
            "+\t\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t\terrorf(\"unknown %s response: %q\", protocolState, t)",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " func parseStatementRowDescribe(r *readBuf) (colNames []string, colTyps []fieldDesc) {",
            " \tn := r.int16()",
            "@@ -1991,14 +2048,16 @@",
            " \t\t\taccrue(\"sslmode\")",
            " \t\tcase \"PGSSLCERT\":",
            " \t\t\taccrue(\"sslcert\")",
            " \t\tcase \"PGSSLKEY\":",
            " \t\t\taccrue(\"sslkey\")",
            " \t\tcase \"PGSSLROOTCERT\":",
            " \t\t\taccrue(\"sslrootcert\")",
            "+\t\tcase \"PGSSLSNI\":",
            "+\t\t\taccrue(\"sslsni\")",
            " \t\tcase \"PGREQUIRESSL\", \"PGSSLCRL\":",
            " \t\t\tunsupported()",
            " \t\tcase \"PGREQUIREPEER\":",
            " \t\t\tunsupported()",
            " \t\tcase \"PGKRBSRVNAME\", \"PGGSSLIB\":",
            " \t\t\tunsupported()",
            " \t\tcase \"PGCONNECT_TIMEOUT\":",
            "@@ -2031,7 +2090,23 @@",
            " \t\treturn ch + ('a' - 'A')",
            " \t}",
            " \tif 'a' <= ch && ch <= 'z' || '0' <= ch && ch <= '9' {",
            " \t\treturn ch",
            " \t}",
            " \treturn -1 // discard",
            " }",
            "+",
            "+// The database/sql/driver package says:",
            "+// All Conn implementations should implement the following interfaces: Pinger, SessionResetter, and Validator.",
            "+var _ driver.Pinger = &conn{}",
            "+var _ driver.SessionResetter = &conn{}",
            "+",
            "+func (cn *conn) ResetSession(ctx context.Context) error {",
            "+\t// Ensure bad connections are reported: From database/sql/driver:",
            "+\t// If a connection is never returned to the connection pool but immediately reused, then",
            "+\t// ResetSession is called prior to reuse but IsValid is not called.",
            "+\treturn cn.err.get()",
            "+}",
            "+",
            "+func (cn *conn) IsValid() bool {",
            "+\treturn cn.err.get() == nil",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/conn_go18.go",
          "change": [
            "--- /home/pq-1.10.1/conn_go18.go",
            "+++ /home/pq-1.10.9/conn_go18.go",
            "@@ -3,18 +3,21 @@",
            " import (",
            " \t\"context\"",
            " \t\"database/sql\"",
            " \t\"database/sql/driver\"",
            " \t\"fmt\"",
            " \t\"io\"",
            " \t\"io/ioutil\"",
            "-\t\"sync/atomic\"",
            " \t\"time\"",
            " )",
            " ",
            "+const (",
            "+\twatchCancelDialContextTimeout = time.Second * 10",
            "+)",
            "+",
            " // Implement the \"QueryerContext\" interface",
            " func (cn *conn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {",
            " \tlist := make([]driver.Value, len(args))",
            " \tfor i, nv := range args {",
            " \t\tlist[i] = nv.Value",
            " \t}",
            " \tfinish := cn.watchCancel(ctx)",
            "@@ -39,14 +42,22 @@",
            " \tif finish := cn.watchCancel(ctx); finish != nil {",
            " \t\tdefer finish()",
            " \t}",
            " ",
            " \treturn cn.Exec(query, list)",
            " }",
            " ",
            "+// Implement the \"ConnPrepareContext\" interface",
            "+func (cn *conn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {",
            "+\tif finish := cn.watchCancel(ctx); finish != nil {",
            "+\t\tdefer finish()",
            "+\t}",
            "+\treturn cn.Prepare(query)",
            "+}",
            "+",
            " // Implement the \"ConnBeginTx\" interface",
            " func (cn *conn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) {",
            " \tvar mode string",
            " ",
            " \tswitch sql.IsolationLevel(opts.Isolation) {",
            " \tcase sql.LevelDefault:",
            " \t\t// Don't touch mode: use the server's default",
            "@@ -99,31 +110,31 @@",
            " \t\t\t\tdefault:",
            " \t\t\t\t\t// We raced with the finish func, let the next query handle this with the",
            " \t\t\t\t\t// context.",
            " \t\t\t\t\treturn",
            " \t\t\t\t}",
            " ",
            " \t\t\t\t// Set the connection state to bad so it does not get reused.",
            "-\t\t\t\tcn.setBad()",
            "+\t\t\t\tcn.err.set(ctx.Err())",
            " ",
            " \t\t\t\t// At this point the function level context is canceled,",
            " \t\t\t\t// so it must not be used for the additional network",
            " \t\t\t\t// request to cancel the query.",
            " \t\t\t\t// Create a new context to pass into the dial.",
            "-\t\t\t\tctxCancel, cancel := context.WithTimeout(context.Background(), time.Second*10)",
            "+\t\t\t\tctxCancel, cancel := context.WithTimeout(context.Background(), watchCancelDialContextTimeout)",
            " \t\t\t\tdefer cancel()",
            " ",
            " \t\t\t\t_ = cn.cancel(ctxCancel)",
            " \t\t\tcase <-finished:",
            " \t\t\t}",
            " \t\t}()",
            " \t\treturn func() {",
            " \t\t\tselect {",
            " \t\t\tcase <-finished:",
            "-\t\t\t\tcn.setBad()",
            "+\t\t\t\tcn.err.set(ctx.Err())",
            " \t\t\t\tcn.Close()",
            " \t\t\tcase finished <- struct{}{}:",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " \treturn nil",
            " }",
            "@@ -141,19 +152,16 @@",
            " \tc, err := dial(ctx, cn.dialer, o)",
            " \tif err != nil {",
            " \t\treturn err",
            " \t}",
            " \tdefer c.Close()",
            " ",
            " \t{",
            "-\t\tbad := &atomic.Value{}",
            "-\t\tbad.Store(false)",
            " \t\tcan := conn{",
            "-\t\t\tc:   c,",
            "-\t\t\tbad: bad,",
            "+\t\t\tc: c,",
            " \t\t}",
            " \t\terr = can.ssl(o)",
            " \t\tif err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " ",
            " \t\tw := can.writeBuf(0)",
            "@@ -168,7 +176,72 @@",
            " ",
            " \t// Read until EOF to ensure that the server received the cancel.",
            " \t{",
            " \t\t_, err := io.Copy(ioutil.Discard, c)",
            " \t\treturn err",
            " \t}",
            " }",
            "+",
            "+// Implement the \"StmtQueryContext\" interface",
            "+func (st *stmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {",
            "+\tlist := make([]driver.Value, len(args))",
            "+\tfor i, nv := range args {",
            "+\t\tlist[i] = nv.Value",
            "+\t}",
            "+\tfinish := st.watchCancel(ctx)",
            "+\tr, err := st.query(list)",
            "+\tif err != nil {",
            "+\t\tif finish != nil {",
            "+\t\t\tfinish()",
            "+\t\t}",
            "+\t\treturn nil, err",
            "+\t}",
            "+\tr.finish = finish",
            "+\treturn r, nil",
            "+}",
            "+",
            "+// Implement the \"StmtExecContext\" interface",
            "+func (st *stmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {",
            "+\tlist := make([]driver.Value, len(args))",
            "+\tfor i, nv := range args {",
            "+\t\tlist[i] = nv.Value",
            "+\t}",
            "+",
            "+\tif finish := st.watchCancel(ctx); finish != nil {",
            "+\t\tdefer finish()",
            "+\t}",
            "+",
            "+\treturn st.Exec(list)",
            "+}",
            "+",
            "+// watchCancel is implemented on stmt in order to not mark the parent conn as bad",
            "+func (st *stmt) watchCancel(ctx context.Context) func() {",
            "+\tif done := ctx.Done(); done != nil {",
            "+\t\tfinished := make(chan struct{})",
            "+\t\tgo func() {",
            "+\t\t\tselect {",
            "+\t\t\tcase <-done:",
            "+\t\t\t\t// At this point the function level context is canceled,",
            "+\t\t\t\t// so it must not be used for the additional network",
            "+\t\t\t\t// request to cancel the query.",
            "+\t\t\t\t// Create a new context to pass into the dial.",
            "+\t\t\t\tctxCancel, cancel := context.WithTimeout(context.Background(), watchCancelDialContextTimeout)",
            "+\t\t\t\tdefer cancel()",
            "+",
            "+\t\t\t\t_ = st.cancel(ctxCancel)",
            "+\t\t\t\tfinished <- struct{}{}",
            "+\t\t\tcase <-finished:",
            "+\t\t\t}",
            "+\t\t}()",
            "+\t\treturn func() {",
            "+\t\t\tselect {",
            "+\t\t\tcase <-finished:",
            "+\t\t\tcase finished <- struct{}{}:",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+\treturn nil",
            "+}",
            "+",
            "+func (st *stmt) cancel(ctx context.Context) error {",
            "+\treturn st.cn.cancel(ctx)",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/conn_test.go",
          "change": [
            "--- /home/pq-1.10.1/conn_test.go",
            "+++ /home/pq-1.10.9/conn_test.go",
            "@@ -1,20 +1,20 @@",
            " package pq",
            " ",
            " import (",
            " \t\"context\"",
            " \t\"database/sql\"",
            " \t\"database/sql/driver\"",
            "+\t\"errors\"",
            " \t\"fmt\"",
            " \t\"io\"",
            " \t\"net\"",
            " \t\"os\"",
            " \t\"reflect\"",
            " \t\"strings\"",
            "-\t\"sync/atomic\"",
            " \t\"testing\"",
            " \t\"time\"",
            " )",
            " ",
            " type Fatalistic interface {",
            " \tFatal(args ...interface{})",
            " }",
            "@@ -140,18 +140,14 @@",
            " \ttestURL(\"postgres://\")",
            " \ttestURL(\"postgresql://\")",
            " }",
            " ",
            " const pgpassFile = \"/tmp/pqgotest_pgpass\"",
            " ",
            " func TestPgpass(t *testing.T) {",
            "-\tif os.Getenv(\"TRAVIS\") != \"true\" {",
            "-\t\tt.Skip(\"not running under Travis, skipping pgpass tests\")",
            "-\t}",
            "-",
            " \ttestAssert := func(conninfo string, expected string, reason string) {",
            " \t\tconn, err := openTestConnConninfo(conninfo)",
            " \t\tif err != nil {",
            " \t\t\tt.Fatal(err)",
            " \t\t}",
            " \t\tdefer conn.Close()",
            " ",
            "@@ -692,41 +688,37 @@",
            " \t\tt.Error(\"connection leaked\")",
            " \t}",
            " }",
            " ",
            " func TestBadConn(t *testing.T) {",
            " \tvar err error",
            " ",
            "-\tbad := &atomic.Value{}",
            "-\tbad.Store(false)",
            "-\tcn := conn{bad: bad}",
            "+\tcn := conn{}",
            " \tfunc() {",
            " \t\tdefer cn.errRecover(&err)",
            " \t\tpanic(io.EOF)",
            " \t}()",
            " \tif err != driver.ErrBadConn {",
            " \t\tt.Fatalf(\"expected driver.ErrBadConn, got: %#v\", err)",
            " \t}",
            "-\tif !cn.getBad() {",
            "-\t\tt.Fatalf(\"expected cn.bad\")",
            "+\tif err := cn.err.get(); err != driver.ErrBadConn {",
            "+\t\tt.Fatalf(\"expected driver.ErrBadConn, got %#v\", err)",
            " \t}",
            " ",
            "-\tbadd := &atomic.Value{}",
            "-\tbadd.Store(false)",
            "-\tcn = conn{bad: badd}",
            "+\tcn = conn{}",
            " \tfunc() {",
            " \t\tdefer cn.errRecover(&err)",
            " \t\te := &Error{Severity: Efatal}",
            " \t\tpanic(e)",
            " \t}()",
            " \tif err != driver.ErrBadConn {",
            " \t\tt.Fatalf(\"expected driver.ErrBadConn, got: %#v\", err)",
            " \t}",
            "-\tif !cn.getBad() {",
            "-\t\tt.Fatalf(\"expected cn.bad\")",
            "+\tif err := cn.err.get(); err != driver.ErrBadConn {",
            "+\t\tt.Fatalf(\"expected driver.ErrBadConn, got %#v\", err)",
            " \t}",
            " }",
            " ",
            " // TestCloseBadConn tests that the underlying connection can be closed with",
            " // Close after an error.",
            " func TestCloseBadConn(t *testing.T) {",
            " \thost := os.Getenv(\"PGHOST\")",
            "@@ -1802,7 +1794,173 @@",
            " \tif err != nil {",
            " \t\tt.Fatal(err)",
            " \t}",
            " ",
            " \tres.RowsAffected()",
            " \tres.LastInsertId()",
            " }",
            "+",
            "+func TestConnPrepareContext(t *testing.T) {",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\ttests := []struct {",
            "+\t\tname string",
            "+\t\tctx  func() (context.Context, context.CancelFunc)",
            "+\t\tsql  string",
            "+\t\terr  error",
            "+\t}{",
            "+\t\t{",
            "+\t\t\tname: \"context.Background\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.Background(), nil",
            "+\t\t\t},",
            "+\t\t\tsql: \"SELECT 1\",",
            "+\t\t\terr: nil,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname: \"context.WithTimeout exceeded\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.WithTimeout(context.Background(), -time.Minute)",
            "+\t\t\t},",
            "+\t\t\tsql: \"SELECT 1\",",
            "+\t\t\terr: context.DeadlineExceeded,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname: \"context.WithTimeout\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.WithTimeout(context.Background(), time.Minute)",
            "+\t\t\t},",
            "+\t\t\tsql: \"SELECT 1\",",
            "+\t\t\terr: nil,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tctx, cancel := tt.ctx()",
            "+\t\t\tif cancel != nil {",
            "+\t\t\t\tdefer cancel()",
            "+\t\t\t}",
            "+\t\t\t_, err := db.PrepareContext(ctx, tt.sql)",
            "+\t\t\tswitch {",
            "+\t\t\tcase (err != nil) != (tt.err != nil):",
            "+\t\t\t\tt.Fatalf(\"conn.PrepareContext() unexpected nil err got = %v, expected = %v\", err, tt.err)",
            "+\t\t\tcase (err != nil && tt.err != nil) && (err.Error() != tt.err.Error()):",
            "+\t\t\t\tt.Errorf(\"conn.PrepareContext() got = %v, expected = %v\", err.Error(), tt.err.Error())",
            "+\t\t\t}",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestStmtQueryContext(t *testing.T) {",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\ttests := []struct {",
            "+\t\tname           string",
            "+\t\tctx            func() (context.Context, context.CancelFunc)",
            "+\t\tsql            string",
            "+\t\tcancelExpected bool",
            "+\t}{",
            "+\t\t{",
            "+\t\t\tname: \"context.Background\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.Background(), nil",
            "+\t\t\t},",
            "+\t\t\tsql:            \"SELECT pg_sleep(1);\",",
            "+\t\t\tcancelExpected: false,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname: \"context.WithTimeout exceeded\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.WithTimeout(context.Background(), 1*time.Second)",
            "+\t\t\t},",
            "+\t\t\tsql:            \"SELECT pg_sleep(10);\",",
            "+\t\t\tcancelExpected: true,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname: \"context.WithTimeout\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.WithTimeout(context.Background(), time.Minute)",
            "+\t\t\t},",
            "+\t\t\tsql:            \"SELECT pg_sleep(1);\",",
            "+\t\t\tcancelExpected: false,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tctx, cancel := tt.ctx()",
            "+\t\t\tif cancel != nil {",
            "+\t\t\t\tdefer cancel()",
            "+\t\t\t}",
            "+\t\t\tstmt, err := db.PrepareContext(ctx, tt.sql)",
            "+\t\t\tif err != nil {",
            "+\t\t\t\tt.Fatal(err)",
            "+\t\t\t}",
            "+\t\t\t_, err = stmt.QueryContext(ctx)",
            "+\t\t\tpgErr := (*Error)(nil)",
            "+\t\t\tswitch {",
            "+\t\t\tcase (err != nil) != tt.cancelExpected:",
            "+\t\t\t\tt.Fatalf(\"stmt.QueryContext() unexpected nil err got = %v, cancelExpected = %v\", err, tt.cancelExpected)",
            "+\t\t\tcase (err != nil && tt.cancelExpected) && !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode):",
            "+\t\t\t\tt.Errorf(\"stmt.QueryContext() got = %v, cancelExpected = %v\", err.Error(), tt.cancelExpected)",
            "+\t\t\t}",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+func TestStmtExecContext(t *testing.T) {",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\ttests := []struct {",
            "+\t\tname           string",
            "+\t\tctx            func() (context.Context, context.CancelFunc)",
            "+\t\tsql            string",
            "+\t\tcancelExpected bool",
            "+\t}{",
            "+\t\t{",
            "+\t\t\tname: \"context.Background\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.Background(), nil",
            "+\t\t\t},",
            "+\t\t\tsql:            \"SELECT pg_sleep(1);\",",
            "+\t\t\tcancelExpected: false,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname: \"context.WithTimeout exceeded\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.WithTimeout(context.Background(), 1*time.Second)",
            "+\t\t\t},",
            "+\t\t\tsql:            \"SELECT pg_sleep(10);\",",
            "+\t\t\tcancelExpected: true,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname: \"context.WithTimeout\",",
            "+\t\t\tctx: func() (context.Context, context.CancelFunc) {",
            "+\t\t\t\treturn context.WithTimeout(context.Background(), time.Minute)",
            "+\t\t\t},",
            "+\t\t\tsql:            \"SELECT pg_sleep(1);\",",
            "+\t\t\tcancelExpected: false,",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tctx, cancel := tt.ctx()",
            "+\t\t\tif cancel != nil {",
            "+\t\t\t\tdefer cancel()",
            "+\t\t\t}",
            "+\t\t\tstmt, err := db.PrepareContext(ctx, tt.sql)",
            "+\t\t\tif err != nil {",
            "+\t\t\t\tt.Fatal(err)",
            "+\t\t\t}",
            "+\t\t\t_, err = stmt.ExecContext(ctx)",
            "+\t\t\tpgErr := (*Error)(nil)",
            "+\t\t\tswitch {",
            "+\t\t\tcase (err != nil) != tt.cancelExpected:",
            "+\t\t\t\tt.Fatalf(\"stmt.QueryContext() unexpected nil err got = %v, cancelExpected = %v\", err, tt.cancelExpected)",
            "+\t\t\tcase (err != nil && tt.cancelExpected) && !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode):",
            "+\t\t\t\tt.Errorf(\"stmt.QueryContext() got = %v, cancelExpected = %v\", err.Error(), tt.cancelExpected)",
            "+\t\t\t}",
            "+\t\t})",
            "+\t}",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/connector.go",
          "change": [
            "--- /home/pq-1.10.1/connector.go",
            "+++ /home/pq-1.10.9/connector.go",
            "@@ -23,14 +23,19 @@",
            " ",
            " // Connect returns a connection to the database using the fixed configuration",
            " // of this Connector. Context is not used.",
            " func (c *Connector) Connect(ctx context.Context) (driver.Conn, error) {",
            " \treturn c.open(ctx)",
            " }",
            " ",
            "+// Dialer allows change the dialer used to open connections.",
            "+func (c *Connector) Dialer(dialer Dialer) {",
            "+\tc.dialer = dialer",
            "+}",
            "+",
            " // Driver returns the underlying driver of this Connector.",
            " func (c *Connector) Driver() driver.Driver {",
            " \treturn &Driver{}",
            " }",
            " ",
            " // NewConnector returns a connector for the pq driver in a fixed configuration",
            " // with the given dsn. The returned connector can be used to create any number"
          ]
        },
        {
          "file": "/home/pq-1.10.9/connector_example_test.go",
          "change": [
            "--- /home/pq-1.10.1/connector_example_test.go",
            "+++ /home/pq-1.10.9/connector_example_test.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build go1.10",
            " // +build go1.10",
            " ",
            " package pq_test",
            " ",
            " import (",
            " \t\"database/sql\"",
            " \t\"fmt\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/connector_test.go",
          "change": [
            "--- /home/pq-1.10.1/connector_test.go",
            "+++ /home/pq-1.10.9/connector_test.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build go1.10",
            " // +build go1.10",
            " ",
            " package pq",
            " ",
            " import (",
            " \t\"context\"",
            " \t\"database/sql\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/copy.go",
          "change": [
            "--- /home/pq-1.10.1/copy.go",
            "+++ /home/pq-1.10.9/copy.go",
            "@@ -1,10 +1,12 @@",
            " package pq",
            " ",
            " import (",
            "+\t\"bytes\"",
            "+\t\"context\"",
            " \t\"database/sql/driver\"",
            " \t\"encoding/binary\"",
            " \t\"errors\"",
            " \t\"fmt\"",
            " \t\"sync\"",
            " )",
            " ",
            "@@ -15,50 +17,58 @@",
            " \terrCopyNotSupportedOutsideTxn = errors.New(\"pq: COPY is only allowed inside a transaction\")",
            " \terrCopyInProgress             = errors.New(\"pq: COPY in progress\")",
            " )",
            " ",
            " // CopyIn creates a COPY FROM statement which can be prepared with",
            " // Tx.Prepare().  The target table should be visible in search_path.",
            " func CopyIn(table string, columns ...string) string {",
            "-\tstmt := \"COPY \" + QuoteIdentifier(table) + \" (\"",
            "+\tbuffer := bytes.NewBufferString(\"COPY \")",
            "+\tBufferQuoteIdentifier(table, buffer)",
            "+\tbuffer.WriteString(\" (\")",
            "+\tmakeStmt(buffer, columns...)",
            "+\treturn buffer.String()",
            "+}",
            "+",
            "+// MakeStmt makes the stmt string for CopyIn and CopyInSchema.",
            "+func makeStmt(buffer *bytes.Buffer, columns ...string) {",
            "+\t//s := bytes.NewBufferString()",
            " \tfor i, col := range columns {",
            " \t\tif i != 0 {",
            "-\t\t\tstmt += \", \"",
            "+\t\t\tbuffer.WriteString(\", \")",
            " \t\t}",
            "-\t\tstmt += QuoteIdentifier(col)",
            "+\t\tBufferQuoteIdentifier(col, buffer)",
            " \t}",
            "-\tstmt += \") FROM STDIN\"",
            "-\treturn stmt",
            "+\tbuffer.WriteString(\") FROM STDIN\")",
            " }",
            " ",
            " // CopyInSchema creates a COPY FROM statement which can be prepared with",
            " // Tx.Prepare().",
            " func CopyInSchema(schema, table string, columns ...string) string {",
            "-\tstmt := \"COPY \" + QuoteIdentifier(schema) + \".\" + QuoteIdentifier(table) + \" (\"",
            "-\tfor i, col := range columns {",
            "-\t\tif i != 0 {",
            "-\t\t\tstmt += \", \"",
            "-\t\t}",
            "-\t\tstmt += QuoteIdentifier(col)",
            "-\t}",
            "-\tstmt += \") FROM STDIN\"",
            "-\treturn stmt",
            "+\tbuffer := bytes.NewBufferString(\"COPY \")",
            "+\tBufferQuoteIdentifier(schema, buffer)",
            "+\tbuffer.WriteRune('.')",
            "+\tBufferQuoteIdentifier(table, buffer)",
            "+\tbuffer.WriteString(\" (\")",
            "+\tmakeStmt(buffer, columns...)",
            "+\treturn buffer.String()",
            " }",
            " ",
            " type copyin struct {",
            " \tcn      *conn",
            " \tbuffer  []byte",
            " \trowData chan []byte",
            " \tdone    chan bool",
            "-\tdriver.Result",
            " ",
            " \tclosed bool",
            " ",
            "-\tsync.Mutex // guards err",
            "-\terr        error",
            "+\tmu struct {",
            "+\t\tsync.Mutex",
            "+\t\terr error",
            "+\t\tdriver.Result",
            "+\t}",
            " }",
            " ",
            " const ciBufferSize = 64 * 1024",
            " ",
            " // flush buffer before the buffer is filled up and needs reallocation",
            " const ciBufferFlushSize = 63 * 1024",
            " ",
            "@@ -94,21 +104,21 @@",
            " \t\tcase 'H':",
            " \t\t\terr = errCopyToNotSupported",
            " \t\t\tbreak awaitCopyInResponse",
            " \t\tcase 'E':",
            " \t\t\terr = parseError(r)",
            " \t\tcase 'Z':",
            " \t\t\tif err == nil {",
            "-\t\t\t\tci.setBad()",
            "+\t\t\t\tci.setBad(driver.ErrBadConn)",
            " \t\t\t\terrorf(\"unexpected ReadyForQuery in response to COPY\")",
            " \t\t\t}",
            " \t\t\tcn.processReadyForQuery(r)",
            " \t\t\treturn nil, err",
            " \t\tdefault:",
            "-\t\t\tci.setBad()",
            "+\t\t\tci.setBad(driver.ErrBadConn)",
            " \t\t\terrorf(\"unknown response for copy query: %q\", t)",
            " \t\t}",
            " \t}",
            " ",
            " \t// something went wrong, abort COPY before we return",
            " \tb = cn.writeBuf('f')",
            " \tb.string(err.Error())",
            "@@ -119,15 +129,15 @@",
            " \t\tswitch t {",
            " \t\tcase 'c', 'C', 'E':",
            " \t\tcase 'Z':",
            " \t\t\t// correctly aborted, we're done",
            " \t\t\tcn.processReadyForQuery(r)",
            " \t\t\treturn nil, err",
            " \t\tdefault:",
            "-\t\t\tci.setBad()",
            "+\t\t\tci.setBad(driver.ErrBadConn)",
            " \t\t\terrorf(\"unknown response for CopyFail: %q\", t)",
            " \t\t}",
            " \t}",
            " }",
            " ",
            " func (ci *copyin) flush(buf []byte) {",
            " \t// set message length (without message identifier)",
            "@@ -140,15 +150,15 @@",
            " }",
            " ",
            " func (ci *copyin) resploop() {",
            " \tfor {",
            " \t\tvar r readBuf",
            " \t\tt, err := ci.cn.recvMessage(&r)",
            " \t\tif err != nil {",
            "-\t\t\tci.setBad()",
            "+\t\t\tci.setBad(driver.ErrBadConn)",
            " \t\t\tci.setError(err)",
            " \t\t\tci.done <- true",
            " \t\t\treturn",
            " \t\t}",
            " \t\tswitch t {",
            " \t\tcase 'C':",
            " \t\t\t// complete",
            "@@ -162,62 +172,57 @@",
            " \t\t\tci.cn.processReadyForQuery(&r)",
            " \t\t\tci.done <- true",
            " \t\t\treturn",
            " \t\tcase 'E':",
            " \t\t\terr := parseError(&r)",
            " \t\t\tci.setError(err)",
            " \t\tdefault:",
            "-\t\t\tci.setBad()",
            "+\t\t\tci.setBad(driver.ErrBadConn)",
            " \t\t\tci.setError(fmt.Errorf(\"unknown response during CopyIn: %q\", t))",
            " \t\t\tci.done <- true",
            " \t\t\treturn",
            " \t\t}",
            " \t}",
            " }",
            " ",
            "-func (ci *copyin) setBad() {",
            "-\tci.Lock()",
            "-\tci.cn.setBad()",
            "-\tci.Unlock()",
            "-}",
            "-",
            "-func (ci *copyin) isBad() bool {",
            "-\tci.Lock()",
            "-\tb := ci.cn.getBad()",
            "-\tci.Unlock()",
            "-\treturn b",
            "-}",
            "-",
            "-func (ci *copyin) isErrorSet() bool {",
            "-\tci.Lock()",
            "-\tisSet := (ci.err != nil)",
            "-\tci.Unlock()",
            "-\treturn isSet",
            "+func (ci *copyin) setBad(err error) {",
            "+\tci.cn.err.set(err)",
            "+}",
            "+",
            "+func (ci *copyin) getBad() error {",
            "+\treturn ci.cn.err.get()",
            "+}",
            "+",
            "+func (ci *copyin) err() error {",
            "+\tci.mu.Lock()",
            "+\terr := ci.mu.err",
            "+\tci.mu.Unlock()",
            "+\treturn err",
            " }",
            " ",
            " // setError() sets ci.err if one has not been set already.  Caller must not be",
            " // holding ci.Mutex.",
            " func (ci *copyin) setError(err error) {",
            "-\tci.Lock()",
            "-\tif ci.err == nil {",
            "-\t\tci.err = err",
            "+\tci.mu.Lock()",
            "+\tif ci.mu.err == nil {",
            "+\t\tci.mu.err = err",
            " \t}",
            "-\tci.Unlock()",
            "+\tci.mu.Unlock()",
            " }",
            " ",
            " func (ci *copyin) setResult(result driver.Result) {",
            "-\tci.Lock()",
            "-\tci.Result = result",
            "-\tci.Unlock()",
            "+\tci.mu.Lock()",
            "+\tci.mu.Result = result",
            "+\tci.mu.Unlock()",
            " }",
            " ",
            " func (ci *copyin) getResult() driver.Result {",
            "-\tci.Lock()",
            "-\tresult := ci.Result",
            "-\tci.Unlock()",
            "+\tci.mu.Lock()",
            "+\tresult := ci.mu.Result",
            "+\tci.mu.Unlock()",
            " \tif result == nil {",
            " \t\treturn driver.RowsAffected(0)",
            " \t}",
            " \treturn result",
            " }",
            " ",
            " func (ci *copyin) NumInput() int {",
            "@@ -236,21 +241,21 @@",
            " // errors from pending data, since Stmt.Close() doesn't return errors",
            " // to the user.",
            " func (ci *copyin) Exec(v []driver.Value) (r driver.Result, err error) {",
            " \tif ci.closed {",
            " \t\treturn nil, errCopyInClosed",
            " \t}",
            " ",
            "-\tif ci.isBad() {",
            "-\t\treturn nil, driver.ErrBadConn",
            "+\tif err := ci.getBad(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " \tdefer ci.cn.errRecover(&err)",
            " ",
            "-\tif ci.isErrorSet() {",
            "-\t\treturn nil, ci.err",
            "+\tif err := ci.err(); err != nil {",
            "+\t\treturn nil, err",
            " \t}",
            " ",
            " \tif len(v) == 0 {",
            " \t\tif err := ci.Close(); err != nil {",
            " \t\t\treturn driver.RowsAffected(0), err",
            " \t\t}",
            " ",
            "@@ -272,22 +277,59 @@",
            " \t\t// reset buffer, keep bytes for message identifier and length",
            " \t\tci.buffer = ci.buffer[:5]",
            " \t}",
            " ",
            " \treturn driver.RowsAffected(0), nil",
            " }",
            " ",
            "+// CopyData inserts a raw string into the COPY stream. The insert is",
            "+// asynchronous and CopyData can return errors from previous CopyData calls to",
            "+// the same COPY stmt.",
            "+//",
            "+// You need to call Exec(nil) to sync the COPY stream and to get any",
            "+// errors from pending data, since Stmt.Close() doesn't return errors",
            "+// to the user.",
            "+func (ci *copyin) CopyData(ctx context.Context, line string) (r driver.Result, err error) {",
            "+\tif ci.closed {",
            "+\t\treturn nil, errCopyInClosed",
            "+\t}",
            "+",
            "+\tif finish := ci.cn.watchCancel(ctx); finish != nil {",
            "+\t\tdefer finish()",
            "+\t}",
            "+",
            "+\tif err := ci.getBad(); err != nil {",
            "+\t\treturn nil, err",
            "+\t}",
            "+\tdefer ci.cn.errRecover(&err)",
            "+",
            "+\tif err := ci.err(); err != nil {",
            "+\t\treturn nil, err",
            "+\t}",
            "+",
            "+\tci.buffer = append(ci.buffer, []byte(line)...)",
            "+\tci.buffer = append(ci.buffer, '\\n')",
            "+",
            "+\tif len(ci.buffer) > ciBufferFlushSize {",
            "+\t\tci.flush(ci.buffer)",
            "+\t\t// reset buffer, keep bytes for message identifier and length",
            "+\t\tci.buffer = ci.buffer[:5]",
            "+\t}",
            "+",
            "+\treturn driver.RowsAffected(0), nil",
            "+}",
            "+",
            " func (ci *copyin) Close() (err error) {",
            " \tif ci.closed { // Don't do anything, we're already closed",
            " \t\treturn nil",
            " \t}",
            " \tci.closed = true",
            " ",
            "-\tif ci.isBad() {",
            "-\t\treturn driver.ErrBadConn",
            "+\tif err := ci.getBad(); err != nil {",
            "+\t\treturn err",
            " \t}",
            " \tdefer ci.cn.errRecover(&err)",
            " ",
            " \tif len(ci.buffer) > 0 {",
            " \t\tci.flush(ci.buffer)",
            " \t}",
            " \t// Avoid touching the scratch buffer as resploop could be using it.",
            "@@ -295,13 +337,12 @@",
            " \tif err != nil {",
            " \t\treturn err",
            " \t}",
            " ",
            " \t<-ci.done",
            " \tci.cn.inCopy = false",
            " ",
            "-\tif ci.isErrorSet() {",
            "-\t\terr = ci.err",
            "+\tif err := ci.err(); err != nil {",
            " \t\treturn err",
            " \t}",
            " \treturn nil",
            " }"
          ]
        },
        {
          "file": "/home/pq-1.10.9/copy_test.go",
          "change": [
            "--- /home/pq-1.10.1/copy_test.go",
            "+++ /home/pq-1.10.9/copy_test.go",
            "@@ -496,7 +496,15 @@",
            " \t\tb.Fatal(err)",
            " \t}",
            " ",
            " \tif num != b.N {",
            " \t\tb.Fatalf(\"expected %d items, not %d\", b.N, num)",
            " \t}",
            " }",
            "+",
            "+var bigTableColumns = []string{\"ABIOGENETICALLY\", \"ABORIGINALITIES\", \"ABSORBABILITIES\", \"ABSORBEFACIENTS\", \"ABSORPTIOMETERS\", \"ABSTRACTIONISMS\", \"ABSTRACTIONISTS\", \"ACANTHOCEPHALAN\", \"ACCEPTABILITIES\", \"ACCEPTINGNESSES\", \"ACCESSARINESSES\", \"ACCESSIBILITIES\", \"ACCESSORINESSES\", \"ACCIDENTALITIES\", \"ACCIDENTOLOGIES\", \"ACCLIMATISATION\", \"ACCLIMATIZATION\", \"ACCOMMODATINGLY\", \"ACCOMMODATIONAL\", \"ACCOMPLISHMENTS\", \"ACCOUNTABLENESS\", \"ACCOUNTANTSHIPS\", \"ACCULTURATIONAL\", \"ACETOPHENETIDIN\", \"ACETYLSALICYLIC\", \"ACHONDROPLASIAS\", \"ACHONDROPLASTIC\", \"ACHROMATICITIES\", \"ACHROMATISATION\", \"ACHROMATIZATION\", \"ACIDIMETRICALLY\", \"ACKNOWLEDGEABLE\", \"ACKNOWLEDGEABLY\", \"ACKNOWLEDGEMENT\", \"ACKNOWLEDGMENTS\", \"ACQUIRABILITIES\", \"ACQUISITIVENESS\", \"ACRIMONIOUSNESS\", \"ACROPARESTHESIA\", \"ACTINOBIOLOGIES\", \"ACTINOCHEMISTRY\", \"ACTINOTHERAPIES\", \"ADAPTABLENESSES\", \"ADDITIONALITIES\", \"ADENOCARCINOMAS\", \"ADENOHYPOPHYSES\", \"ADENOHYPOPHYSIS\", \"ADENOIDECTOMIES\", \"ADIATHERMANCIES\", \"ADJUSTABILITIES\", \"ADMINISTRATIONS\", \"ADMIRABLENESSES\", \"ADMISSIBILITIES\", \"ADRENALECTOMIES\", \"ADSORBABILITIES\", \"ADVENTUROUSNESS\", \"ADVERSARINESSES\", \"ADVISABLENESSES\", \"AERODYNAMICALLY\", \"AERODYNAMICISTS\", \"AEROELASTICIANS\", \"AEROHYDROPLANES\", \"AEROLITHOLOGIES\", \"AEROSOLISATIONS\", \"AEROSOLIZATIONS\", \"AFFECTABILITIES\", \"AFFECTIVENESSES\", \"AFFORDABILITIES\", \"AFFRANCHISEMENT\", \"AFTERSENSATIONS\", \"AGGLUTINABILITY\", \"AGGRANDISEMENTS\", \"AGGRANDIZEMENTS\", \"AGGREGATENESSES\", \"AGRANULOCYTOSES\", \"AGRANULOCYTOSIS\", \"AGREEABLENESSES\", \"AGRIBUSINESSMAN\", \"AGRIBUSINESSMEN\", \"AGRICULTURALIST\", \"AIRWORTHINESSES\", \"ALCOHOLISATIONS\", \"ALCOHOLIZATIONS\", \"ALCOHOLOMETRIES\", \"ALEXIPHARMAKONS\", \"ALGORITHMICALLY\", \"ALKALINISATIONS\", \"ALKALINIZATIONS\", \"ALLEGORICALNESS\", \"ALLEGORISATIONS\", \"ALLEGORIZATIONS\", \"ALLELOMORPHISMS\", \"ALLERGENICITIES\", \"ALLOTETRAPLOIDS\", \"ALLOTETRAPLOIDY\", \"ALLOTRIOMORPHIC\", \"ALLOWABLENESSES\", \"ALPHABETISATION\", \"ALPHABETIZATION\", \"ALTERNATIVENESS\", \"ALTITUDINARIANS\", \"ALUMINOSILICATE\", \"ALUMINOTHERMIES\", \"AMARYLLIDACEOUS\", \"AMBASSADORSHIPS\", \"AMBIDEXTERITIES\", \"AMBIGUOUSNESSES\", \"AMBISEXUALITIES\", \"AMBITIOUSNESSES\", \"AMINOPEPTIDASES\", \"AMINOPHENAZONES\", \"AMMONIFICATIONS\", \"AMORPHOUSNESSES\", \"AMPHIDIPLOIDIES\", \"AMPHITHEATRICAL\", \"ANACOLUTHICALLY\", \"ANACREONTICALLY\", \"ANAESTHESIOLOGY\", \"ANAESTHETICALLY\", \"ANAGRAMMATISING\", \"ANAGRAMMATIZING\", \"ANALOGOUSNESSES\", \"ANALYZABILITIES\", \"ANAMORPHOSCOPES\", \"ANCYLOSTOMIASES\", \"ANCYLOSTOMIASIS\", \"ANDROGYNOPHORES\", \"ANDROMEDOTOXINS\", \"ANDROMONOECIOUS\", \"ANDROMONOECISMS\", \"ANESTHETIZATION\", \"ANFRACTUOSITIES\", \"ANGUSTIROSTRATE\", \"ANIMATRONICALLY\", \"ANISOTROPICALLY\", \"ANKYLOSTOMIASES\", \"ANKYLOSTOMIASIS\", \"ANNIHILATIONISM\", \"ANOMALISTICALLY\", \"ANOMALOUSNESSES\", \"ANONYMOUSNESSES\", \"ANSWERABILITIES\", \"ANTAGONISATIONS\", \"ANTAGONIZATIONS\", \"ANTAPHRODISIACS\", \"ANTEPENULTIMATE\", \"ANTHROPOBIOLOGY\", \"ANTHROPOCENTRIC\", \"ANTHROPOGENESES\", \"ANTHROPOGENESIS\", \"ANTHROPOGENETIC\", \"ANTHROPOLATRIES\", \"ANTHROPOLOGICAL\", \"ANTHROPOLOGISTS\", \"ANTHROPOMETRIES\", \"ANTHROPOMETRIST\", \"ANTHROPOMORPHIC\", \"ANTHROPOPATHIES\", \"ANTHROPOPATHISM\", \"ANTHROPOPHAGIES\", \"ANTHROPOPHAGITE\", \"ANTHROPOPHAGOUS\", \"ANTHROPOPHOBIAS\", \"ANTHROPOPHOBICS\", \"ANTHROPOPHUISMS\", \"ANTHROPOPSYCHIC\", \"ANTHROPOSOPHIES\", \"ANTHROPOSOPHIST\", \"ANTIABORTIONIST\", \"ANTIALCOHOLISMS\", \"ANTIAPHRODISIAC\", \"ANTIARRHYTHMICS\", \"ANTICAPITALISMS\", \"ANTICAPITALISTS\", \"ANTICARCINOGENS\", \"ANTICHOLESTEROL\", \"ANTICHOLINERGIC\", \"ANTICHRISTIANLY\", \"ANTICLERICALISM\", \"ANTICLIMACTICAL\", \"ANTICOINCIDENCE\", \"ANTICOLONIALISM\", \"ANTICOLONIALIST\", \"ANTICOMPETITIVE\", \"ANTICONVULSANTS\", \"ANTICONVULSIVES\", \"ANTIDEPRESSANTS\", \"ANTIDERIVATIVES\", \"ANTIDEVELOPMENT\", \"ANTIEDUCATIONAL\", \"ANTIEGALITARIAN\", \"ANTIFASHIONABLE\", \"ANTIFEDERALISTS\", \"ANTIFERROMAGNET\", \"ANTIFORECLOSURE\", \"ANTIHELMINTHICS\", \"ANTIHISTAMINICS\", \"ANTILIBERALISMS\", \"ANTILIBERTARIAN\", \"ANTILOGARITHMIC\", \"ANTIMATERIALISM\", \"ANTIMATERIALIST\", \"ANTIMETABOLITES\", \"ANTIMILITARISMS\", \"ANTIMILITARISTS\", \"ANTIMONARCHICAL\", \"ANTIMONARCHISTS\", \"ANTIMONOPOLISTS\", \"ANTINATIONALIST\", \"ANTINUCLEARISTS\", \"ANTIODONTALGICS\", \"ANTIPERISTALSES\", \"ANTIPERISTALSIS\", \"ANTIPERISTALTIC\", \"ANTIPERSPIRANTS\", \"ANTIPHLOGISTICS\", \"ANTIPORNOGRAPHY\", \"ANTIPROGRESSIVE\", \"ANTIQUARIANISMS\", \"ANTIRADICALISMS\", \"ANTIRATIONALISM\", \"ANTIRATIONALIST\", \"ANTIRATIONALITY\", \"ANTIREPUBLICANS\", \"ANTIROMANTICISM\", \"ANTISEGREGATION\", \"ANTISENTIMENTAL\", \"ANTISEPARATISTS\", \"ANTISEPTICISING\", \"ANTISEPTICIZING\", \"ANTISEXUALITIES\", \"ANTISHOPLIFTING\", \"ANTISOCIALITIES\", \"ANTISPECULATION\", \"ANTISPECULATIVE\", \"ANTISYPHILITICS\", \"ANTITHEORETICAL\", \"ANTITHROMBOTICS\", \"ANTITRADITIONAL\", \"ANTITRANSPIRANT\", \"ANTITRINITARIAN\", \"ANTITUBERCULOUS\", \"ANTIVIVISECTION\", \"APHELIOTROPISMS\", \"APOCALYPTICALLY\", \"APOCALYPTICISMS\", \"APOLIPOPROTEINS\", \"APOLITICALITIES\", \"APOPHTHEGMATISE\", \"APOPHTHEGMATIST\", \"APOPHTHEGMATIZE\", \"APOTHEGMATISING\", \"APOTHEGMATIZING\", \"APPEALABILITIES\", \"APPEALINGNESSES\", \"APPENDICULARIAN\", \"APPLICABILITIES\", \"APPRENTICEHOODS\", \"APPRENTICEMENTS\", \"APPRENTICESHIPS\", \"APPROACHABILITY\", \"APPROPINQUATING\", \"APPROPINQUATION\", \"APPROPINQUITIES\", \"APPROPRIATENESS\", \"ARACHNOIDITISES\", \"ARBITRARINESSES\", \"ARBORICULTURIST\", \"ARCHAEBACTERIUM\", \"ARCHAEOBOTANIES\", \"ARCHAEOBOTANIST\", \"ARCHAEOMETRISTS\", \"ARCHAEOPTERYXES\", \"ARCHAEZOOLOGIES\", \"ARCHEOASTRONOMY\", \"ARCHEOBOTANISTS\", \"ARCHEOLOGICALLY\", \"ARCHEOMAGNETISM\", \"ARCHEOZOOLOGIES\", \"ARCHEOZOOLOGIST\", \"ARCHGENETHLIACS\", \"ARCHIDIACONATES\", \"ARCHIEPISCOPACY\", \"ARCHIEPISCOPATE\", \"ARCHITECTURALLY\", \"ARCHPRIESTHOODS\", \"ARCHPRIESTSHIPS\", \"ARGUMENTATIVELY\", \"ARIBOFLAVINOSES\", \"ARIBOFLAVINOSIS\", \"AROMATHERAPISTS\", \"ARRONDISSEMENTS\", \"ARTERIALISATION\", \"ARTERIALIZATION\", \"ARTERIOGRAPHIES\", \"ARTIFICIALISING\", \"ARTIFICIALITIES\", \"ARTIFICIALIZING\", \"ASCLEPIADACEOUS\", \"ASSENTIVENESSES\"}",
            "+",
            "+func BenchmarkCopy(b *testing.B) {",
            "+\tfor i := 0; i < b.N; i++ {",
            "+\t\tCopyIn(\"temp\", bigTableColumns...)",
            "+\t}",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/encode.go",
          "change": [
            "--- /home/pq-1.10.1/encode.go",
            "+++ /home/pq-1.10.9/encode.go",
            "@@ -196,19 +196,25 @@",
            " \t}",
            " \treturn result",
            " }",
            " ",
            " func mustParse(f string, typ oid.Oid, s []byte) time.Time {",
            " \tstr := string(s)",
            " ",
            "-\t// check for a 30-minute-offset timezone",
            "-\tif (typ == oid.T_timestamptz || typ == oid.T_timetz) &&",
            "-\t\tstr[len(str)-3] == ':' {",
            "-\t\tf += \":00\"",
            "+\t// Check for a minute and second offset in the timezone.",
            "+\tif typ == oid.T_timestamptz || typ == oid.T_timetz {",
            "+\t\tfor i := 3; i <= 6; i += 3 {",
            "+\t\t\tif str[len(str)-i] == ':' {",
            "+\t\t\t\tf += \":00\"",
            "+\t\t\t\tcontinue",
            "+\t\t\t}",
            "+\t\t\tbreak",
            "+\t\t}",
            " \t}",
            "+",
            " \t// Special case for 24:00 time.",
            " \t// Unfortunately, golang does not parse 24:00 as a proper time.",
            " \t// In this case, we want to try \"round to the next day\", to differentiate.",
            " \t// As such, we find if the 24:00 time matches at the beginning; if so,",
            " \t// we default it back to 00:00 but add a day later.",
            " \tvar is2400Time bool",
            " \tswitch typ {",
            "@@ -412,25 +418,25 @@",
            " \t// offsets if the preceding sections exist.",
            " ",
            " \tnanoSec := 0",
            " \ttzOff := 0",
            " ",
            " \tif remainderIdx < len(str) && str[remainderIdx] == '.' {",
            " \t\tfracStart := remainderIdx + 1",
            "-\t\tfracOff := strings.IndexAny(str[fracStart:], \"-+ \")",
            "+\t\tfracOff := strings.IndexAny(str[fracStart:], \"-+Z \")",
            " \t\tif fracOff < 0 {",
            " \t\t\tfracOff = len(str) - fracStart",
            " \t\t}",
            " \t\tfracSec := p.mustAtoi(str, fracStart, fracStart+fracOff)",
            " \t\tnanoSec = fracSec * (1000000000 / int(math.Pow(10, float64(fracOff))))",
            " ",
            " \t\tremainderIdx += fracOff + 1",
            " \t}",
            " \tif tzStart := remainderIdx; tzStart < len(str) && (str[tzStart] == '-' || str[tzStart] == '+') {",
            "-\t\t// time zone separator is always '-' or '+' (UTC is +00)",
            "+\t\t// time zone separator is always '-' or '+' or 'Z' (UTC is +00)",
            " \t\tvar tzSign int",
            " \t\tswitch c := str[tzStart]; c {",
            " \t\tcase '-':",
            " \t\t\ttzSign = -1",
            " \t\tcase '+':",
            " \t\t\ttzSign = +1",
            " \t\tdefault:",
            "@@ -444,15 +450,19 @@",
            " \t\t\tremainderIdx += 3",
            " \t\t}",
            " \t\tif remainderIdx < len(str) && str[remainderIdx] == ':' {",
            " \t\t\ttzSec = p.mustAtoi(str, remainderIdx+1, remainderIdx+3)",
            " \t\t\tremainderIdx += 3",
            " \t\t}",
            " \t\ttzOff = tzSign * ((tzHours * 60 * 60) + (tzMin * 60) + tzSec)",
            "+\t} else if tzStart < len(str) && str[tzStart] == 'Z' {",
            "+\t\t// time zone Z separator indicates UTC is +00",
            "+\t\tremainderIdx += 1",
            " \t}",
            "+",
            " \tvar isoYear int",
            " ",
            " \tif isBC {",
            " \t\tisoYear = 1 - year",
            " \t\tremainderIdx += 3",
            " \t} else {",
            " \t\tisoYear = year",
            "@@ -549,15 +559,15 @@",
            " \t\t\t\t\tcontinue",
            " \t\t\t\t}",
            " ",
            " \t\t\t\t// '\\\\' followed by an octal number",
            " \t\t\t\tif len(s) < 4 {",
            " \t\t\t\t\treturn nil, fmt.Errorf(\"invalid bytea sequence %v\", s)",
            " \t\t\t\t}",
            "-\t\t\t\tr, err := strconv.ParseInt(string(s[1:4]), 8, 9)",
            "+\t\t\t\tr, err := strconv.ParseUint(string(s[1:4]), 8, 8)",
            " \t\t\t\tif err != nil {",
            " \t\t\t\t\treturn nil, fmt.Errorf(\"could not parse bytea value: %s\", err.Error())",
            " \t\t\t\t}",
            " \t\t\t\tresult = append(result, byte(r))",
            " \t\t\t\ts = s[4:]",
            " \t\t\t} else {",
            " \t\t\t\t// We hit an unescaped, raw byte.  Try to read in as many as"
          ]
        },
        {
          "file": "/home/pq-1.10.9/encode_test.go",
          "change": [
            "--- /home/pq-1.10.1/encode_test.go",
            "+++ /home/pq-1.10.9/encode_test.go",
            "@@ -55,14 +55,16 @@",
            " \t\ttime.FixedZone(\"\", -7*60*60))},",
            " \t{\"2001-02-03 04:05:06-07\", time.Date(2001, time.February, 3, 4, 5, 6, 0,",
            " \t\ttime.FixedZone(\"\", -7*60*60))},",
            " \t{\"2001-02-03 04:05:06-07:42\", time.Date(2001, time.February, 3, 4, 5, 6, 0,",
            " \t\ttime.FixedZone(\"\", -(7*60*60+42*60)))},",
            " \t{\"2001-02-03 04:05:06-07:30:09\", time.Date(2001, time.February, 3, 4, 5, 6, 0,",
            " \t\ttime.FixedZone(\"\", -(7*60*60+30*60+9)))},",
            "+\t{\"2001-02-03 04:05:06+07:30:09\", time.Date(2001, time.February, 3, 4, 5, 6, 0,",
            "+\t\ttime.FixedZone(\"\", +(7*60*60+30*60+9)))},",
            " \t{\"2001-02-03 04:05:06+07\", time.Date(2001, time.February, 3, 4, 5, 6, 0,",
            " \t\ttime.FixedZone(\"\", 7*60*60))},",
            " \t{\"0011-02-03 04:05:06 BC\", time.Date(-10, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", 0))},",
            " \t{\"0011-02-03 04:05:06.123 BC\", time.Date(-10, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},",
            " \t{\"0011-02-03 04:05:06.123-07 BC\", time.Date(-10, time.February, 3, 4, 5, 6, 123000000,",
            " \t\ttime.FixedZone(\"\", -7*60*60))},",
            " \t{\"0001-02-03 04:05:06.123\", time.Date(1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},",
            "@@ -247,14 +249,16 @@",
            " ",
            " \tfor _, tc := range []struct {",
            " \t\trefTime      string",
            " \t\texpectedTime time.Time",
            " \t}{",
            " \t\t{\"11:59:59+00:00\", time.Date(0, 1, 1, 11, 59, 59, 0, time.UTC)},",
            " \t\t{\"11:59:59+04:00\", time.Date(0, 1, 1, 11, 59, 59, 0, time.FixedZone(\"+04\", 4*60*60))},",
            "+\t\t{\"11:59:59+04:01:02\", time.Date(0, 1, 1, 11, 59, 59, 0, time.FixedZone(\"+04:01:02\", 4*60*60+1*60+2))},",
            "+\t\t{\"11:59:59-04:01:02\", time.Date(0, 1, 1, 11, 59, 59, 0, time.FixedZone(\"-04:01:02\", -(4*60*60+1*60+2)))},",
            " \t\t{\"24:00+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},",
            " \t\t{\"24:00Z\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},",
            " \t\t{\"24:00-04:00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.FixedZone(\"-04\", -4*60*60))},",
            " \t\t{\"24:00:00+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},",
            " \t\t{\"24:00:00.0+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},",
            " \t\t{\"24:00:00.000000+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},",
            " \t} {",
            "@@ -820,14 +824,51 @@",
            " \t}",
            " \tbuf = []byte(\"123\\t\")",
            " \tif esc := appendEscapedText(buf, \"\\n\\r\\t\\f\"); string(esc) != \"123\\t\\\\n\\\\r\\\\t\\f\" {",
            " \t\tt.Fatal(string(esc))",
            " \t}",
            " }",
            " ",
            "+var formatAndParseTimestamp = []struct {",
            "+\ttime     time.Time",
            "+\texpected string",
            "+}{",
            "+\t{time.Time{}, \"0001-01-01 00:00:00Z\"},",
            "+\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"2001-02-03 04:05:06.123456789Z\"},",
            "+\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"2001-02-03 04:05:06.123456789+02:00\"},",
            "+\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"2001-02-03 04:05:06.123456789-06:00\"},",
            "+\t{time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"2001-02-03 04:05:06-07:30:09\"},",
            "+",
            "+\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"0001-02-03 04:05:06.123456789Z\"},",
            "+\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"0001-02-03 04:05:06.123456789+02:00\"},",
            "+\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"0001-02-03 04:05:06.123456789-06:00\"},",
            "+",
            "+\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"0001-02-03 04:05:06.123456789Z BC\"},",
            "+\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"0001-02-03 04:05:06.123456789+02:00 BC\"},",
            "+\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"0001-02-03 04:05:06.123456789-06:00 BC\"},",
            "+",
            "+\t{time.Date(1, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"0001-02-03 04:05:06-07:30:09\"},",
            "+\t{time.Date(0, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"0001-02-03 04:05:06-07:30:09 BC\"},",
            "+}",
            "+",
            "+func TestFormatAndParseTimestamp(t *testing.T) {",
            "+\tfor _, val := range formatAndParseTimestamp {",
            "+\t\tformattedTime := FormatTimestamp(val.time)",
            "+\t\tparsedTime, err := ParseTimestamp(nil, string(formattedTime))",
            "+",
            "+\t\tif err != nil {",
            "+\t\t\tt.Errorf(\"invalid parsing, err: %v\", err.Error())",
            "+\t\t}",
            "+",
            "+\t\tif val.time.UTC() != parsedTime.UTC() {",
            "+\t\t\tt.Errorf(\"invalid parsing from formatted timestamp, got %v; expected %v\", parsedTime.String(), val.time.String())",
            "+\t\t}",
            "+\t}",
            "+}",
            "+",
            " func BenchmarkAppendEscapedText(b *testing.B) {",
            " \tlongString := \"\"",
            " \tfor i := 0; i < 100; i++ {",
            " \t\tlongString += \"123456789\\n\"",
            " \t}",
            " \tfor i := 0; i < b.N; i++ {",
            " \t\tappendEscapedText(nil, longString)"
          ]
        },
        {
          "file": "/home/pq-1.10.9/error.go",
          "change": [
            "--- /home/pq-1.10.1/error.go",
            "+++ /home/pq-1.10.9/error.go",
            "@@ -398,14 +398,19 @@",
            " }",
            " ",
            " // Fatal returns true if the Error Severity is fatal.",
            " func (err *Error) Fatal() bool {",
            " \treturn err.Severity == Efatal",
            " }",
            " ",
            "+// SQLState returns the SQLState of the error.",
            "+func (err *Error) SQLState() string {",
            "+\treturn string(err.Code)",
            "+}",
            "+",
            " // Get implements the legacy PGError interface. New code should use the fields",
            " // of the Error struct directly.",
            " func (err *Error) Get(k byte) (v string) {",
            " \tswitch k {",
            " \tcase 'S':",
            " \t\treturn err.Severity",
            " \tcase 'C':",
            "@@ -440,15 +445,15 @@",
            " \t\treturn err.Line",
            " \tcase 'R':",
            " \t\treturn err.Routine",
            " \t}",
            " \treturn \"\"",
            " }",
            " ",
            "-func (err Error) Error() string {",
            "+func (err *Error) Error() string {",
            " \treturn \"pq: \" + err.Message",
            " }",
            " ",
            " // PGError is an interface used by previous versions of pq. It is provided",
            " // only to support legacy code. New code should use the Error type.",
            " type PGError interface {",
            " \tError() string",
            "@@ -480,39 +485,39 @@",
            " ",
            " func (cn *conn) errRecover(err *error) {",
            " \te := recover()",
            " \tswitch v := e.(type) {",
            " \tcase nil:",
            " \t\t// Do nothing",
            " \tcase runtime.Error:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\tpanic(v)",
            " \tcase *Error:",
            " \t\tif v.Fatal() {",
            " \t\t\t*err = driver.ErrBadConn",
            " \t\t} else {",
            " \t\t\t*err = v",
            " \t\t}",
            " \tcase *net.OpError:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t*err = v",
            " \tcase *safeRetryError:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\t*err = driver.ErrBadConn",
            " \tcase error:",
            "-\t\tif v == io.EOF || v.(error).Error() == \"remote error: handshake failure\" {",
            "+\t\tif v == io.EOF || v.Error() == \"remote error: handshake failure\" {",
            " \t\t\t*err = driver.ErrBadConn",
            " \t\t} else {",
            " \t\t\t*err = v",
            " \t\t}",
            " ",
            " \tdefault:",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t\tpanic(fmt.Sprintf(\"unknown error: %#v\", e))",
            " \t}",
            " ",
            " \t// Any time we return ErrBadConn, we need to remember it since *Tx doesn't",
            " \t// mark the connection bad in database/sql.",
            " \tif *err == driver.ErrBadConn {",
            "-\t\tcn.setBad()",
            "+\t\tcn.err.set(driver.ErrBadConn)",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/pq-1.10.9/go18_test.go",
          "change": [
            "--- /home/pq-1.10.1/go18_test.go",
            "+++ /home/pq-1.10.9/go18_test.go",
            "@@ -1,13 +1,14 @@",
            " package pq",
            " ",
            " import (",
            " \t\"context\"",
            " \t\"database/sql\"",
            " \t\"database/sql/driver\"",
            "+\t\"errors\"",
            " \t\"runtime\"",
            " \t\"strings\"",
            " \t\"testing\"",
            " \t\"time\"",
            " )",
            " ",
            " func TestMultipleSimpleQuery(t *testing.T) {",
            "@@ -71,27 +72,29 @@",
            " \tif rows.NextResultSet() {",
            " \t\tt.Fatal(\"unexpected result set\")",
            " \t}",
            " }",
            " ",
            " const contextRaceIterations = 100",
            " ",
            "+const cancelErrorCode ErrorCode = \"57014\"",
            "+",
            " func TestContextCancelExec(t *testing.T) {",
            " \tdb := openTestConn(t)",
            " \tdefer db.Close()",
            " ",
            " \tctx, cancel := context.WithCancel(context.Background())",
            " ",
            " \t// Delay execution for just a bit until db.ExecContext has begun.",
            " \tdefer time.AfterFunc(time.Millisecond*10, cancel).Stop()",
            " ",
            " \t// Not canceled until after the exec has started.",
            " \tif _, err := db.ExecContext(ctx, \"select pg_sleep(1)\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            "-\t} else if err.Error() != \"pq: canceling statement due to user request\" {",
            "+\t} else if pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {",
            " \t\tt.Fatalf(\"unexpected error: %s\", err)",
            " \t}",
            " ",
            " \t// Context is already canceled, so error should come before execution.",
            " \tif _, err := db.ExecContext(ctx, \"select pg_sleep(1)\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            " \t} else if err.Error() != \"context canceled\" {",
            "@@ -121,15 +124,15 @@",
            " ",
            " \t// Delay execution for just a bit until db.QueryContext has begun.",
            " \tdefer time.AfterFunc(time.Millisecond*10, cancel).Stop()",
            " ",
            " \t// Not canceled until after the exec has started.",
            " \tif _, err := db.QueryContext(ctx, \"select pg_sleep(1)\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            "-\t} else if err.Error() != \"pq: canceling statement due to user request\" {",
            "+\t} else if pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {",
            " \t\tt.Fatalf(\"unexpected error: %s\", err)",
            " \t}",
            " ",
            " \t// Context is already canceled, so error should come before execution.",
            " \tif _, err := db.QueryContext(ctx, \"select pg_sleep(1)\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            " \t} else if err.Error() != \"context canceled\" {",
            "@@ -139,15 +142,15 @@",
            " \tfor i := 0; i < contextRaceIterations; i++ {",
            " \t\tfunc() {",
            " \t\t\tctx, cancel := context.WithCancel(context.Background())",
            " \t\t\trows, err := db.QueryContext(ctx, \"select 1\")",
            " \t\t\tcancel()",
            " \t\t\tif err != nil {",
            " \t\t\t\tt.Fatal(err)",
            "-\t\t\t} else if err := rows.Close(); err != nil && err != driver.ErrBadConn {",
            "+\t\t\t} else if err := rows.Close(); err != nil && err != driver.ErrBadConn && err != context.Canceled {",
            " \t\t\t\tt.Fatal(err)",
            " \t\t\t}",
            " \t\t}()",
            " ",
            " \t\tif rows, err := db.Query(\"select 1\"); err != nil {",
            " \t\t\tt.Fatal(err)",
            " \t\t} else if err := rows.Close(); err != nil {",
            "@@ -211,15 +214,15 @@",
            " ",
            " \t// Delay execution for just a bit until tx.Exec has begun.",
            " \tdefer time.AfterFunc(time.Millisecond*10, cancel).Stop()",
            " ",
            " \t// Not canceled until after the exec has started.",
            " \tif _, err := tx.Exec(\"select pg_sleep(1)\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            "-\t} else if err.Error() != \"pq: canceling statement due to user request\" {",
            "+\t} else if pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {",
            " \t\tt.Fatalf(\"unexpected error: %s\", err)",
            " \t}",
            " ",
            " \t// Transaction is canceled, so expect an error.",
            " \tif _, err := tx.Query(\"select pg_sleep(1)\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            " \t} else if err != sql.ErrTxDone {",
            "@@ -236,17 +239,17 @@",
            " \tfor i := 0; i < contextRaceIterations; i++ {",
            " \t\tfunc() {",
            " \t\t\tctx, cancel := context.WithCancel(context.Background())",
            " \t\t\ttx, err := db.BeginTx(ctx, nil)",
            " \t\t\tcancel()",
            " \t\t\tif err != nil {",
            " \t\t\t\tt.Fatal(err)",
            "-\t\t\t} else if err := tx.Rollback(); err != nil &&",
            "-\t\t\t\terr.Error() != \"pq: canceling statement due to user request\" &&",
            "-\t\t\t\terr != sql.ErrTxDone && err != driver.ErrBadConn {",
            "+\t\t\t} else if err, pgErr := tx.Rollback(), (*Error)(nil); err != nil &&",
            "+\t\t\t\t!(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) &&",
            "+\t\t\t\terr != sql.ErrTxDone && err != driver.ErrBadConn && err != context.Canceled {",
            " \t\t\t\tt.Fatal(err)",
            " \t\t\t}",
            " \t\t}()",
            " ",
            " \t\tif tx, err := db.Begin(); err != nil {",
            " \t\t\tt.Fatal(err)",
            " \t\t} else if err := tx.Rollback(); err != nil {",
            "@@ -327,7 +330,23 @@",
            " \tif err == nil {",
            " \t\tt.Fatal(\"expected LevelLinearizable to fail\")",
            " \t}",
            " \tif !strings.Contains(err.Error(), \"isolation level not supported\") {",
            " \t\tt.Errorf(\"Expected error to mention isolation level, got %q\", err)",
            " \t}",
            " }",
            "+",
            "+func TestErrorSQLState(t *testing.T) {",
            "+\tr := readBuf([]byte{67, 52, 48, 48, 48, 49, 0, 0}) // 40001",
            "+\terr := parseError(&r)",
            "+\tvar sqlErr errWithSQLState",
            "+\tif !errors.As(err, &sqlErr) {",
            "+\t\tt.Fatal(\"SQLState interface not satisfied\")",
            "+\t}",
            "+\tif state := err.SQLState(); state != \"40001\" {",
            "+\t\tt.Fatalf(\"unexpected SQL state %v\", state)",
            "+\t}",
            "+}",
            "+",
            "+type errWithSQLState interface {",
            "+\tSQLState() string",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/go19_test.go",
          "change": [
            "--- /home/pq-1.10.1/go19_test.go",
            "+++ /home/pq-1.10.9/go19_test.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build go1.9",
            " // +build go1.9",
            " ",
            " package pq",
            " ",
            " import (",
            " \t\"context\"",
            " \t\"database/sql\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/issues_test.go",
          "change": [
            "--- /home/pq-1.10.1/issues_test.go",
            "+++ /home/pq-1.10.9/issues_test.go",
            "@@ -1,10 +1,16 @@",
            " package pq",
            " ",
            "-import \"testing\"",
            "+import (",
            "+\t\"context\"",
            "+\t\"database/sql\"",
            "+\t\"errors\"",
            "+\t\"testing\"",
            "+\t\"time\"",
            "+)",
            " ",
            " func TestIssue494(t *testing.T) {",
            " \tdb := openTestConn(t)",
            " \tdefer db.Close()",
            " ",
            " \tquery := `CREATE TEMP TABLE t (i INT PRIMARY KEY)`",
            " \tif _, err := db.Exec(query); err != nil {",
            "@@ -20,7 +26,133 @@",
            " \t\tt.Fatal(err)",
            " \t}",
            " ",
            " \tif _, err := txn.Query(\"SELECT 1\"); err == nil {",
            " \t\tt.Fatal(\"expected error\")",
            " \t}",
            " }",
            "+",
            "+func TestIssue1046(t *testing.T) {",
            "+\tctxTimeout := time.Second * 2",
            "+",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\tctx, cancel := context.WithTimeout(context.Background(), ctxTimeout)",
            "+\tdefer cancel()",
            "+",
            "+\tstmt, err := db.PrepareContext(ctx, `SELECT pg_sleep(10) AS id`)",
            "+\tif err != nil {",
            "+\t\tt.Fatal(err)",
            "+\t}",
            "+",
            "+\tvar d []uint8",
            "+\terr = stmt.QueryRowContext(ctx).Scan(&d)",
            "+\tdl, _ := ctx.Deadline()",
            "+\tsince := time.Since(dl)",
            "+\tif since > ctxTimeout {",
            "+\t\tt.Logf(\"FAIL %s: query returned after context deadline: %v\\n\", t.Name(), since)",
            "+\t\tt.Fail()",
            "+\t}",
            "+\tif pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {",
            "+\t\tt.Logf(\"ctx.Err(): [%T]%+v\\n\", ctx.Err(), ctx.Err())",
            "+\t\tt.Logf(\"got err: [%T] %+v expected errCode: %v\", err, err, cancelErrorCode)",
            "+\t\tt.Fail()",
            "+\t}",
            "+}",
            "+",
            "+func TestIssue1062(t *testing.T) {",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\t// Ensure that cancelling a QueryRowContext does not result in an ErrBadConn.",
            "+",
            "+\tfor i := 0; i < 100; i++ {",
            "+\t\tctx, cancel := context.WithCancel(context.Background())",
            "+\t\tgo cancel()",
            "+\t\trow := db.QueryRowContext(ctx, \"select 1\")",
            "+",
            "+\t\tvar v int",
            "+\t\terr := row.Scan(&v)",
            "+\t\tif pgErr := (*Error)(nil); err != nil &&",
            "+\t\t\terr != context.Canceled &&",
            "+\t\t\t!(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {",
            "+\t\t\tt.Fatalf(\"Scan resulted in unexpected error %v for canceled QueryRowContext at attempt %d\", err, i+1)",
            "+\t\t}",
            "+\t}",
            "+}",
            "+",
            "+func connIsValid(t *testing.T, db *sql.DB) {",
            "+\tt.Helper()",
            "+",
            "+\tctx := context.Background()",
            "+\tconn, err := db.Conn(ctx)",
            "+\tif err != nil {",
            "+\t\tt.Fatal(err)",
            "+\t}",
            "+\tdefer conn.Close()",
            "+",
            "+\t// the connection must be valid",
            "+\terr = conn.PingContext(ctx)",
            "+\tif err != nil {",
            "+\t\tt.Errorf(\"PingContext err=%#v\", err)",
            "+\t}",
            "+\t// close must not return an error",
            "+\terr = conn.Close()",
            "+\tif err != nil {",
            "+\t\tt.Errorf(\"Close err=%#v\", err)",
            "+\t}",
            "+}",
            "+",
            "+func TestQueryCancelRace(t *testing.T) {",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\t// cancel a query while executing on Postgres: must return the cancelled error code",
            "+\tctx, cancel := context.WithCancel(context.Background())",
            "+\tgo func() {",
            "+\t\ttime.Sleep(10 * time.Millisecond)",
            "+\t\tcancel()",
            "+\t}()",
            "+\trow := db.QueryRowContext(ctx, \"select pg_sleep(0.5)\")",
            "+\tvar pgSleepVoid string",
            "+\terr := row.Scan(&pgSleepVoid)",
            "+\tif pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {",
            "+\t\tt.Fatalf(\"expected cancelled error; err=%#v\", err)",
            "+\t}",
            "+",
            "+\t// get a connection: it must be a valid",
            "+\tconnIsValid(t, db)",
            "+}",
            "+",
            "+// Test cancelling a scan after it is started. This broke with 1.10.4.",
            "+func TestQueryCancelledReused(t *testing.T) {",
            "+\tdb := openTestConn(t)",
            "+\tdefer db.Close()",
            "+",
            "+\tctx, cancel := context.WithCancel(context.Background())",
            "+\t// run a query that returns a lot of data",
            "+\trows, err := db.QueryContext(ctx, \"select generate_series(1, 10000)\")",
            "+\tif err != nil {",
            "+\t\tt.Fatal(err)",
            "+\t}",
            "+",
            "+\t// scan the first value",
            "+\tif !rows.Next() {",
            "+\t\tt.Error(\"expected rows.Next() to return true\")",
            "+\t}",
            "+\tvar i int",
            "+\terr = rows.Scan(&i)",
            "+\tif err != nil {",
            "+\t\tt.Fatal(err)",
            "+\t}",
            "+\tif i != 1 {",
            "+\t\tt.Error(i)",
            "+\t}",
            "+",
            "+\t// cancel the context and close rows, ignoring errors",
            "+\tcancel()",
            "+\trows.Close()",
            "+",
            "+\t// get a connection: it must be valid",
            "+\tconnIsValid(t, db)",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/notice.go",
          "change": [
            "--- /home/pq-1.10.1/notice.go",
            "+++ /home/pq-1.10.9/notice.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build go1.10",
            " // +build go1.10",
            " ",
            " package pq",
            " ",
            " import (",
            " \t\"context\"",
            " \t\"database/sql/driver\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/notice_example_test.go",
          "change": [
            "--- /home/pq-1.10.1/notice_example_test.go",
            "+++ /home/pq-1.10.9/notice_example_test.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build go1.10",
            " // +build go1.10",
            " ",
            " package pq_test",
            " ",
            " import (",
            " \t\"database/sql\"",
            " \t\"fmt\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/notice_test.go",
          "change": [
            "--- /home/pq-1.10.1/notice_test.go",
            "+++ /home/pq-1.10.9/notice_test.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build go1.10",
            " // +build go1.10",
            " ",
            " package pq",
            " ",
            " import (",
            " \t\"database/sql\"",
            " \t\"database/sql/driver\""
          ]
        },
        {
          "file": "/home/pq-1.10.9/oid/gen.go",
          "change": [
            "--- /home/pq-1.10.1/oid/gen.go",
            "+++ /home/pq-1.10.9/oid/gen.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build ignore",
            " // +build ignore",
            " ",
            " // Generate the table of OID values",
            " // Run with 'go run gen.go'.",
            " package main",
            " ",
            " import ("
          ]
        },
        {
          "file": "/home/pq-1.10.9/ssl.go",
          "change": [
            "--- /home/pq-1.10.1/ssl.go",
            "+++ /home/pq-1.10.9/ssl.go",
            "@@ -4,14 +4,15 @@",
            " \t\"crypto/tls\"",
            " \t\"crypto/x509\"",
            " \t\"io/ioutil\"",
            " \t\"net\"",
            " \t\"os\"",
            " \t\"os/user\"",
            " \t\"path/filepath\"",
            "+\t\"strings\"",
            " )",
            " ",
            " // ssl generates a function to upgrade a net.Conn based on the \"sslmode\" and",
            " // related settings. The function is nil when no upgrade should take place.",
            " func ssl(o values) (func(net.Conn) (net.Conn, error), error) {",
            " \tverifyCaOnly := false",
            " \ttlsConf := tls.Config{}",
            "@@ -46,14 +47,24 @@",
            " \t\ttlsConf.ServerName = o[\"host\"]",
            " \tcase \"disable\":",
            " \t\treturn nil, nil",
            " \tdefault:",
            " \t\treturn nil, fmterrorf(`unsupported sslmode %q; only \"require\" (default), \"verify-full\", \"verify-ca\", and \"disable\" supported`, mode)",
            " \t}",
            " ",
            "+\t// Set Server Name Indication (SNI), if enabled by connection parameters.",
            "+\t// By default SNI is on, any value which is not starting with \"1\" disables",
            "+\t// SNI -- that is the same check vanilla libpq uses.",
            "+\tif sslsni := o[\"sslsni\"]; sslsni == \"\" || strings.HasPrefix(sslsni, \"1\") {",
            "+\t\t// RFC 6066 asks to not set SNI if the host is a literal IP address (IPv4",
            "+\t\t// or IPv6). This check is coded already crypto.tls.hostnameInSNI, so",
            "+\t\t// just always set ServerName here and let crypto/tls do the filtering.",
            "+\t\ttlsConf.ServerName = o[\"host\"]",
            "+\t}",
            "+",
            " \terr := sslClientCertificates(&tlsConf, o)",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " \terr = sslCertificateAuthority(&tlsConf, o)",
            " \tif err != nil {",
            " \t\treturn nil, err"
          ]
        },
        {
          "file": "/home/pq-1.10.9/ssl_permissions.go",
          "change": [
            "--- /home/pq-1.10.1/ssl_permissions.go",
            "+++ /home/pq-1.10.9/ssl_permissions.go",
            "@@ -1,20 +1,93 @@",
            "+//go:build !windows",
            " // +build !windows",
            " ",
            " package pq",
            " ",
            "-import \"os\"",
            "+import (",
            "+\t\"errors\"",
            "+\t\"os\"",
            "+\t\"syscall\"",
            "+)",
            "+",
            "+const (",
            "+\trootUserID = uint32(0)",
            "+",
            "+\t// The maximum permissions that a private key file owned by a regular user",
            "+\t// is allowed to have. This translates to u=rw.",
            "+\tmaxUserOwnedKeyPermissions os.FileMode = 0600",
            "+",
            "+\t// The maximum permissions that a private key file owned by root is allowed",
            "+\t// to have. This translates to u=rw,g=r.",
            "+\tmaxRootOwnedKeyPermissions os.FileMode = 0640",
            "+)",
            "+",
            "+var (",
            "+\terrSSLKeyHasUnacceptableUserPermissions = errors.New(\"permissions for files not owned by root should be u=rw (0600) or less\")",
            "+\terrSSLKeyHasUnacceptableRootPermissions = errors.New(\"permissions for root owned files should be u=rw,g=r (0640) or less\")",
            "+)",
            " ",
            " // sslKeyPermissions checks the permissions on user-supplied ssl key files.",
            " // The key file should have very little access.",
            " //",
            " // libpq does not check key file permissions on Windows.",
            " func sslKeyPermissions(sslkey string) error {",
            " \tinfo, err := os.Stat(sslkey)",
            " \tif err != nil {",
            " \t\treturn err",
            " \t}",
            "-\tif info.Mode().Perm()&0077 != 0 {",
            "-\t\treturn ErrSSLKeyHasWorldPermissions",
            "+",
            "+\terr = hasCorrectPermissions(info)",
            "+",
            "+\t// return ErrSSLKeyHasWorldPermissions for backwards compatability with",
            "+\t// existing code.",
            "+\tif err == errSSLKeyHasUnacceptableUserPermissions || err == errSSLKeyHasUnacceptableRootPermissions {",
            "+\t\terr = ErrSSLKeyHasWorldPermissions",
            " \t}",
            "-\treturn nil",
            "+\treturn err",
            "+}",
            "+",
            "+// hasCorrectPermissions checks the file info (and the unix-specific stat_t",
            "+// output) to verify that the permissions on the file are correct.",
            "+//",
            "+// If the file is owned by the same user the process is running as,",
            "+// the file should only have 0600 (u=rw). If the file is owned by root,",
            "+// and the group matches the group that the process is running in, the",
            "+// permissions cannot be more than 0640 (u=rw,g=r). The file should",
            "+// never have world permissions.",
            "+//",
            "+// Returns an error when the permission check fails.",
            "+func hasCorrectPermissions(info os.FileInfo) error {",
            "+\t// if file's permission matches 0600, allow access.",
            "+\tuserPermissionMask := (os.FileMode(0777) ^ maxUserOwnedKeyPermissions)",
            "+",
            "+\t// regardless of if we're running as root or not, 0600 is acceptable,",
            "+\t// so we return if we match the regular user permission mask.",
            "+\tif info.Mode().Perm()&userPermissionMask == 0 {",
            "+\t\treturn nil",
            "+\t}",
            "+",
            "+\t// We need to pull the Unix file information to get the file's owner.",
            "+\t// If we can't access it, there's some sort of operating system level error",
            "+\t// and we should fail rather than attempting to use faulty information.",
            "+\tsysInfo := info.Sys()",
            "+\tif sysInfo == nil {",
            "+\t\treturn ErrSSLKeyUnknownOwnership",
            "+\t}",
            "+",
            "+\tunixStat, ok := sysInfo.(*syscall.Stat_t)",
            "+\tif !ok {",
            "+\t\treturn ErrSSLKeyUnknownOwnership",
            "+\t}",
            "+",
            "+\t// if the file is owned by root, we allow 0640 (u=rw,g=r) to match what",
            "+\t// Postgres does.",
            "+\tif unixStat.Uid == rootUserID {",
            "+\t\trootPermissionMask := (os.FileMode(0777) ^ maxRootOwnedKeyPermissions)",
            "+\t\tif info.Mode().Perm()&rootPermissionMask != 0 {",
            "+\t\t\treturn errSSLKeyHasUnacceptableRootPermissions",
            "+\t\t}",
            "+\t\treturn nil",
            "+\t}",
            "+",
            "+\treturn errSSLKeyHasUnacceptableUserPermissions",
            " }"
          ]
        },
        {
          "file": "/home/pq-1.10.9/ssl_test.go",
          "change": [
            "--- /home/pq-1.10.1/ssl_test.go",
            "+++ /home/pq-1.10.9/ssl_test.go",
            "@@ -1,18 +1,25 @@",
            " package pq",
            " ",
            " // This file contains SSL tests",
            " ",
            " import (",
            "+\t\"bytes\"",
            " \t_ \"crypto/sha256\"",
            "+\t\"crypto/tls\"",
            " \t\"crypto/x509\"",
            " \t\"database/sql\"",
            "+\t\"fmt\"",
            "+\t\"io\"",
            "+\t\"net\"",
            " \t\"os\"",
            " \t\"path/filepath\"",
            "+\t\"strings\"",
            " \t\"testing\"",
            "+\t\"time\"",
            " )",
            " ",
            " func maybeSkipSSLTests(t *testing.T) {",
            " \t// Require some special variables for testing certificates",
            " \tif os.Getenv(\"PQSSLCERTTEST_PATH\") == \"\" {",
            " \t\tt.Skip(\"PQSSLCERTTEST_PATH not set, skipping SSL tests\")",
            " \t}",
            "@@ -276,7 +283,139 @@",
            " \t\t\tt.Fatal(err)",
            " \t\t}",
            " \t\tif err := db.Close(); err != nil {",
            " \t\t\tt.Fatal(err)",
            " \t\t}",
            " \t}",
            " }",
            "+",
            "+// Check that clint sends SNI data when `sslsni` is not disabled",
            "+func TestSNISupport(t *testing.T) {",
            "+\tt.Parallel()",
            "+\ttests := []struct {",
            "+\t\tname         string",
            "+\t\tconn_param   string",
            "+\t\thostname     string",
            "+\t\texpected_sni string",
            "+\t}{",
            "+\t\t{",
            "+\t\t\tname:         \"SNI is set by default\",",
            "+\t\t\tconn_param:   \"\",",
            "+\t\t\thostname:     \"localhost\",",
            "+\t\t\texpected_sni: \"localhost\",",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:         \"SNI is passed when asked for\",",
            "+\t\t\tconn_param:   \"sslsni=1\",",
            "+\t\t\thostname:     \"localhost\",",
            "+\t\t\texpected_sni: \"localhost\",",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:         \"SNI is not passed when disabled\",",
            "+\t\t\tconn_param:   \"sslsni=0\",",
            "+\t\t\thostname:     \"localhost\",",
            "+\t\t\texpected_sni: \"\",",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tname:         \"SNI is not set for IPv4\",",
            "+\t\t\tconn_param:   \"\",",
            "+\t\t\thostname:     \"127.0.0.1\",",
            "+\t\t\texpected_sni: \"\",",
            "+\t\t},",
            "+\t}",
            "+\tfor _, tt := range tests {",
            "+\t\ttt := tt",
            "+\t\tt.Run(tt.name, func(t *testing.T) {",
            "+\t\t\tt.Parallel()",
            "+",
            "+\t\t\t// Start mock postgres server on OS-provided port",
            "+\t\t\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:\")",
            "+\t\t\tif err != nil {",
            "+\t\t\t\tt.Fatal(err)",
            "+\t\t\t}",
            "+\t\t\tserverErrChan := make(chan error, 1)",
            "+\t\t\tserverSNINameChan := make(chan string, 1)",
            "+\t\t\tgo mockPostgresSSL(listener, serverErrChan, serverSNINameChan)",
            "+",
            "+\t\t\tdefer listener.Close()",
            "+\t\t\tdefer close(serverErrChan)",
            "+\t\t\tdefer close(serverSNINameChan)",
            "+",
            "+\t\t\t// Try to establish a connection with the mock server. Connection will error out after TLS",
            "+\t\t\t// clientHello, but it is enough to catch SNI data on the server side",
            "+\t\t\tport := strings.Split(listener.Addr().String(), \":\")[1]",
            "+\t\t\tconnStr := fmt.Sprintf(\"sslmode=require host=%s port=%s %s\", tt.hostname, port, tt.conn_param)",
            "+",
            "+\t\t\t// We are okay to skip this error as we are polling serverErrChan and we'll get an error",
            "+\t\t\t// or timeout from the server side in case of problems here.",
            "+\t\t\tdb, _ := sql.Open(\"postgres\", connStr)",
            "+\t\t\t_, _ = db.Exec(\"SELECT 1\")",
            "+",
            "+\t\t\t// Check SNI data",
            "+\t\t\tselect {",
            "+\t\t\tcase sniHost := <-serverSNINameChan:",
            "+\t\t\t\tif sniHost != tt.expected_sni {",
            "+\t\t\t\t\tt.Fatalf(\"Expected SNI to be 'localhost', got '%+v' instead\", sniHost)",
            "+\t\t\t\t}",
            "+\t\t\tcase err = <-serverErrChan:",
            "+\t\t\t\tt.Fatalf(\"mock server failed with error: %+v\", err)",
            "+\t\t\tcase <-time.After(time.Second):",
            "+\t\t\t\tt.Fatal(\"exceeded connection timeout without erroring out\")",
            "+\t\t\t}",
            "+\t\t})",
            "+\t}",
            "+}",
            "+",
            "+// Make a postgres mock server to test TLS SNI",
            "+//",
            "+// Accepts postgres StartupMessage and handles TLS clientHello, then closes a connection.",
            "+// While reading clientHello catch passed SNI data and report it to nameChan.",
            "+func mockPostgresSSL(listener net.Listener, errChan chan error, nameChan chan string) {",
            "+\tvar sniHost string",
            "+",
            "+\tconn, err := listener.Accept()",
            "+\tif err != nil {",
            "+\t\terrChan <- err",
            "+\t\treturn",
            "+\t}",
            "+\tdefer conn.Close()",
            "+",
            "+\terr = conn.SetDeadline(time.Now().Add(time.Second))",
            "+\tif err != nil {",
            "+\t\terrChan <- err",
            "+\t\treturn",
            "+\t}",
            "+",
            "+\t// Receive StartupMessage with SSL Request",
            "+\tstartupMessage := make([]byte, 8)",
            "+\tif _, err := io.ReadFull(conn, startupMessage); err != nil {",
            "+\t\terrChan <- err",
            "+\t\treturn",
            "+\t}",
            "+\t// StartupMessage: first four bytes -- total len = 8, last four bytes SslRequestNumber",
            "+\tif !bytes.Equal(startupMessage, []byte{0, 0, 0, 0x8, 0x4, 0xd2, 0x16, 0x2f}) {",
            "+\t\terrChan <- fmt.Errorf(\"unexpected startup message: %#v\", startupMessage)",
            "+\t\treturn",
            "+\t}",
            "+",
            "+\t// Respond with SSLOk",
            "+\t_, err = conn.Write([]byte(\"S\"))",
            "+\tif err != nil {",
            "+\t\terrChan <- err",
            "+\t\treturn",
            "+\t}",
            "+",
            "+\t// Set up TLS context to catch clientHello. It will always error out during handshake",
            "+\t// as no certificate is set.",
            "+\tsrv := tls.Server(conn, &tls.Config{",
            "+\t\tGetConfigForClient: func(argHello *tls.ClientHelloInfo) (*tls.Config, error) {",
            "+\t\t\tsniHost = argHello.ServerName",
            "+\t\t\treturn nil, nil",
            "+\t\t},",
            "+\t})",
            "+\tdefer srv.Close()",
            "+",
            "+\t// Do the TLS handshake ignoring errors",
            "+\t_ = srv.Handshake()",
            "+",
            "+\tnameChan <- sniHost",
            "+}"
          ]
        },
        {
          "file": "/home/pq-1.10.9/ssl_windows.go",
          "change": [
            "--- /home/pq-1.10.1/ssl_windows.go",
            "+++ /home/pq-1.10.9/ssl_windows.go",
            "@@ -1,7 +1,8 @@",
            "+//go:build windows",
            " // +build windows",
            " ",
            " package pq",
            " ",
            " // sslKeyPermissions checks the permissions on user-supplied ssl key files.",
            " // The key file should have very little access.",
            " //"
          ]
        },
        {
          "file": "/home/pq-1.10.9/user_posix.go",
          "change": [
            "--- /home/pq-1.10.1/user_posix.go",
            "+++ /home/pq-1.10.9/user_posix.go",
            "@@ -1,10 +1,11 @@",
            " // Package pq is a pure Go Postgres driver for the database/sql package.",
            " ",
            "-// +build aix darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris rumprun",
            "+//go:build aix || darwin || dragonfly || freebsd || (linux && !android) || nacl || netbsd || openbsd || plan9 || solaris || rumprun || illumos",
            "+// +build aix darwin dragonfly freebsd linux,!android nacl netbsd openbsd plan9 solaris rumprun illumos",
            " ",
            " package pq",
            " ",
            " import (",
            " \t\"os\"",
            " \t\"os/user\"",
            " )"
          ]
        }
      ]
    }
  }
}