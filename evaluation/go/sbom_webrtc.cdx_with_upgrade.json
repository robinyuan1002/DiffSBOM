{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:3603c379-9dd3-467b-a95f-f7aa39fd41f9",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T13:46:51-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "ced807856491fbd6",
      "type": "file",
      "name": "webrtc-4.1.3/"
    }
  },
  "components": [
    {
      "bom-ref": "pkg:npm/%40roamhq/wrtc@0.9.0?package-id=283421f21fd8c8cd",
      "type": "library",
      "name": "@roamhq/wrtc",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/%40roamhq/wrtc@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/%40roamhq/wrtc-darwin-arm64@0.9.0?package-id=8e69e6e77e6ae874",
      "type": "library",
      "name": "@roamhq/wrtc-darwin-arm64",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin-arm64:\\@roamhq\\/wrtc-darwin-arm64:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/%40roamhq/wrtc-darwin-arm64@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin-arm64:\\@roamhq\\/wrtc_darwin_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin_arm64:\\@roamhq\\/wrtc-darwin-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin_arm64:\\@roamhq\\/wrtc_darwin_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin:\\@roamhq\\/wrtc-darwin-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin:\\@roamhq\\/wrtc_darwin_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin:\\@roamhq\\/wrtc-darwin-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin:\\@roamhq\\/wrtc_darwin_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc-darwin-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc_darwin_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/%40roamhq/wrtc-darwin-x64@0.9.0?package-id=24f63d50fadac076",
      "type": "library",
      "name": "@roamhq/wrtc-darwin-x64",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin-x64:\\@roamhq\\/wrtc-darwin-x64:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/%40roamhq/wrtc-darwin-x64@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin-x64:\\@roamhq\\/wrtc_darwin_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin_x64:\\@roamhq\\/wrtc-darwin-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin_x64:\\@roamhq\\/wrtc_darwin_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin:\\@roamhq\\/wrtc-darwin-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-darwin:\\@roamhq\\/wrtc_darwin_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin:\\@roamhq\\/wrtc-darwin-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_darwin:\\@roamhq\\/wrtc_darwin_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc-darwin-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc_darwin_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/%40roamhq/wrtc-linux-arm64@0.9.0?package-id=20a3280697ca5a33",
      "type": "library",
      "name": "@roamhq/wrtc-linux-arm64",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:\\@roamhq\\/wrtc-linux-arm64:\\@roamhq\\/wrtc-linux-arm64:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/%40roamhq/wrtc-linux-arm64@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-linux-arm64:\\@roamhq\\/wrtc_linux_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux_arm64:\\@roamhq\\/wrtc-linux-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux_arm64:\\@roamhq\\/wrtc_linux_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-linux:\\@roamhq\\/wrtc-linux-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-linux:\\@roamhq\\/wrtc_linux_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux:\\@roamhq\\/wrtc-linux-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux:\\@roamhq\\/wrtc_linux_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc-linux-arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc_linux_arm64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/%40roamhq/wrtc-linux-x64@0.9.0?package-id=c79200481969212b",
      "type": "library",
      "name": "@roamhq/wrtc-linux-x64",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:\\@roamhq\\/wrtc-linux-x64:\\@roamhq\\/wrtc-linux-x64:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/%40roamhq/wrtc-linux-x64@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-linux-x64:\\@roamhq\\/wrtc_linux_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux_x64:\\@roamhq\\/wrtc-linux-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux_x64:\\@roamhq\\/wrtc_linux_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-linux:\\@roamhq\\/wrtc-linux-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-linux:\\@roamhq\\/wrtc_linux_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux:\\@roamhq\\/wrtc-linux-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_linux:\\@roamhq\\/wrtc_linux_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc-linux-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc_linux_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/%40roamhq/wrtc-win32-x64@0.9.0?package-id=41ae1a386aef47c4",
      "type": "library",
      "name": "@roamhq/wrtc-win32-x64",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:\\@roamhq\\/wrtc-win32-x64:\\@roamhq\\/wrtc-win32-x64:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/%40roamhq/wrtc-win32-x64@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-win32-x64:\\@roamhq\\/wrtc_win32_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_win32_x64:\\@roamhq\\/wrtc-win32-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_win32_x64:\\@roamhq\\/wrtc_win32_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-win32:\\@roamhq\\/wrtc-win32-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc-win32:\\@roamhq\\/wrtc_win32_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_win32:\\@roamhq\\/wrtc-win32-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc_win32:\\@roamhq\\/wrtc_win32_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc-win32-x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:\\@roamhq\\/wrtc:\\@roamhq\\/wrtc_win32_x64:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=3012958b4c7e477d",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/browser-e2e.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=81422f787f2100f9",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/examples-tests.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=6d55eea55306f6c7",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/standardjs.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/setup-node@v4?package-id=92639aa06a6d8a64",
      "type": "library",
      "name": "actions/setup-node",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/setup-node:actions\\/setup-node:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/setup-node@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup-node:actions\\/setup_node:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup_node:actions\\/setup-node:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup_node:actions\\/setup_node:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup:actions\\/setup-node:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/setup:actions\\/setup_node:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/standardjs.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/ajv@6.12.2?package-id=f0a33c10a1cf4cf6",
      "type": "library",
      "name": "ajv",
      "version": "6.12.2",
      "cpe": "cpe:2.3:a:ajv:ajv:6.12.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/ajv@6.12.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/asn1@0.2.4?package-id=cb47954fb1d471c4",
      "type": "library",
      "name": "asn1",
      "version": "0.2.4",
      "cpe": "cpe:2.3:a:asn1:asn1:0.2.4:*:*:*:*:*:*:*",
      "purl": "pkg:npm/asn1@0.2.4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/assert-plus@1.0.0?package-id=bbef4f15a02c98bb",
      "type": "library",
      "name": "assert-plus",
      "version": "1.0.0",
      "cpe": "cpe:2.3:a:assert-plus:assert-plus:1.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/assert-plus@1.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:assert-plus:assert_plus:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:assert_plus:assert-plus:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:assert_plus:assert_plus:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:assert:assert-plus:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:assert:assert_plus:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/asynckit@0.4.0?package-id=55e052873a8ebf82",
      "type": "library",
      "name": "asynckit",
      "version": "0.4.0",
      "cpe": "cpe:2.3:a:asynckit:asynckit:0.4.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/asynckit@0.4.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/aws-sign2@0.7.0?package-id=d7660bc8181f35aa",
      "type": "library",
      "name": "aws-sign2",
      "version": "0.7.0",
      "cpe": "cpe:2.3:a:aws-sign2:aws-sign2:0.7.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/aws-sign2@0.7.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:aws-sign2:aws_sign2:0.7.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:aws_sign2:aws-sign2:0.7.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:aws_sign2:aws_sign2:0.7.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:aws:aws-sign2:0.7.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:aws:aws_sign2:0.7.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/aws4@1.10.0?package-id=1d137c2253418dd5",
      "type": "library",
      "name": "aws4",
      "version": "1.10.0",
      "cpe": "cpe:2.3:a:aws4:aws4:1.10.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/aws4@1.10.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/bcrypt-pbkdf@1.0.2?package-id=449ecef0b504f725",
      "type": "library",
      "name": "bcrypt-pbkdf",
      "version": "1.0.2",
      "cpe": "cpe:2.3:a:bcrypt-pbkdf:bcrypt-pbkdf:1.0.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/bcrypt-pbkdf@1.0.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:bcrypt-pbkdf:bcrypt_pbkdf:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:bcrypt_pbkdf:bcrypt-pbkdf:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:bcrypt_pbkdf:bcrypt_pbkdf:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:bcrypt:bcrypt-pbkdf:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:bcrypt:bcrypt_pbkdf:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/caseless@0.12.0?package-id=8cc5cf640f5637a9",
      "type": "library",
      "name": "caseless",
      "version": "0.12.0",
      "cpe": "cpe:2.3:a:caseless:caseless:0.12.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/caseless@0.12.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/combined-stream@1.0.8?package-id=0c201626d8187386",
      "type": "library",
      "name": "combined-stream",
      "version": "1.0.8",
      "cpe": "cpe:2.3:a:combined-stream:combined-stream:1.0.8:*:*:*:*:*:*:*",
      "purl": "pkg:npm/combined-stream@1.0.8",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:combined-stream:combined_stream:1.0.8:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:combined_stream:combined-stream:1.0.8:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:combined_stream:combined_stream:1.0.8:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:combined:combined-stream:1.0.8:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:combined:combined_stream:1.0.8:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/core-util-is@1.0.2?package-id=0354f5a9f1a90f95",
      "type": "library",
      "name": "core-util-is",
      "version": "1.0.2",
      "cpe": "cpe:2.3:a:core-util-is:core-util-is:1.0.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/core-util-is@1.0.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core-util-is:core_util_is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core_util_is:core-util-is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core_util_is:core_util_is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core-util:core-util-is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core-util:core_util_is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core_util:core-util-is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core_util:core_util_is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core:core-util-is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:core:core_util_is:1.0.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/dashdash@1.14.1?package-id=805832404f71b697",
      "type": "library",
      "name": "dashdash",
      "version": "1.14.1",
      "cpe": "cpe:2.3:a:dashdash:dashdash:1.14.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/dashdash@1.14.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/delayed-stream@1.0.0?package-id=73053405202e42f1",
      "type": "library",
      "name": "delayed-stream",
      "version": "1.0.0",
      "cpe": "cpe:2.3:a:delayed-stream:delayed-stream:1.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/delayed-stream@1.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:delayed-stream:delayed_stream:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:delayed_stream:delayed-stream:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:delayed_stream:delayed_stream:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:delayed:delayed-stream:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:delayed:delayed_stream:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/domexception@4.0.0?package-id=b9d4e44461fc7ca2",
      "type": "library",
      "name": "domexception",
      "version": "4.0.0",
      "cpe": "cpe:2.3:a:domexception:domexception:4.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/domexception@4.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/ecc-jsbn@0.1.2?package-id=585da036ee1506d5",
      "type": "library",
      "name": "ecc-jsbn",
      "version": "0.1.2",
      "cpe": "cpe:2.3:a:ecc-jsbn:ecc-jsbn:0.1.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/ecc-jsbn@0.1.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ecc-jsbn:ecc_jsbn:0.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ecc_jsbn:ecc-jsbn:0.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ecc_jsbn:ecc_jsbn:0.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ecc:ecc-jsbn:0.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:ecc:ecc_jsbn:0.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/extend@3.0.2?package-id=8914d63ad34fdd31",
      "type": "library",
      "name": "extend",
      "version": "3.0.2",
      "cpe": "cpe:2.3:a:extend_project:extend:3.0.2:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/extend@3.0.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/extsprintf@1.3.0?package-id=7208bc6b2805e012",
      "type": "library",
      "name": "extsprintf",
      "version": "1.3.0",
      "cpe": "cpe:2.3:a:extsprintf:extsprintf:1.3.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/extsprintf@1.3.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/extsprintf@1.4.0?package-id=52ab17869f319634",
      "type": "library",
      "name": "extsprintf",
      "version": "1.4.0",
      "cpe": "cpe:2.3:a:extsprintf:extsprintf:1.4.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/extsprintf@1.4.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/fast-deep-equal@3.1.1?package-id=96b368874bde7a29",
      "type": "library",
      "name": "fast-deep-equal",
      "version": "3.1.1",
      "cpe": "cpe:2.3:a:fast-deep-equal:fast-deep-equal:3.1.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/fast-deep-equal@3.1.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-deep-equal:fast_deep_equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_deep_equal:fast-deep-equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_deep_equal:fast_deep_equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-deep:fast-deep-equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-deep:fast_deep_equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_deep:fast-deep-equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_deep:fast_deep_equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast:fast-deep-equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast:fast_deep_equal:3.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/fast-json-stable-stringify@2.1.0?package-id=00f2a13510ffb105",
      "type": "library",
      "name": "fast-json-stable-stringify",
      "version": "2.1.0",
      "cpe": "cpe:2.3:a:fast-json-stable-stringify:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/fast-json-stable-stringify@2.1.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-json-stable-stringify:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_json_stable_stringify:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_json_stable_stringify:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-json-stable:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-json-stable:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_json_stable:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_json_stable:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-json:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast-json:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_json:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast_json:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast:fast-json-stable-stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:fast:fast_json_stable_stringify:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/forever-agent@0.6.1?package-id=446d30cb59a3c1b2",
      "type": "library",
      "name": "forever-agent",
      "version": "0.6.1",
      "cpe": "cpe:2.3:a:forever-agent:forever-agent:0.6.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/forever-agent@0.6.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:forever-agent:forever_agent:0.6.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:forever_agent:forever-agent:0.6.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:forever_agent:forever_agent:0.6.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:forever:forever-agent:0.6.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:forever:forever_agent:0.6.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/form-data@2.3.3?package-id=f2c75abf02243b36",
      "type": "library",
      "name": "form-data",
      "version": "2.3.3",
      "cpe": "cpe:2.3:a:form-data:form-data:2.3.3:*:*:*:*:*:*:*",
      "purl": "pkg:npm/form-data@2.3.3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:form-data:form_data:2.3.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:form_data:form-data:2.3.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:form_data:form_data:2.3.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:form:form-data:2.3.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:form:form_data:2.3.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/getpass@0.1.7?package-id=266c2068f5195021",
      "type": "library",
      "name": "getpass",
      "version": "0.1.7",
      "cpe": "cpe:2.3:a:getpass:getpass:0.1.7:*:*:*:*:*:*:*",
      "purl": "pkg:npm/getpass@0.1.7",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/davecgh/go-spew@v1.1.1?package-id=4fff1eaa0bc0be66",
      "type": "library",
      "name": "github.com/davecgh/go-spew",
      "version": "v1.1.1",
      "cpe": "cpe:2.3:a:davecgh:go-spew:v1.1.1:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/davecgh/go-spew@v1.1.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:davecgh:go_spew:v1.1.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/google/uuid@v1.6.0?package-id=f6424607fde0264b",
      "type": "library",
      "name": "github.com/google/uuid",
      "version": "v1.6.0",
      "cpe": "cpe:2.3:a:google:uuid:v1.6.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/google/uuid@v1.6.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/onsi/ginkgo@v1.16.5?package-id=c5bda0be224a8bf8",
      "type": "library",
      "name": "github.com/onsi/ginkgo",
      "version": "v1.16.5",
      "cpe": "cpe:2.3:a:onsi:ginkgo:v1.16.5:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/onsi/ginkgo@v1.16.5",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/onsi/gomega@v1.17.0?package-id=59482f91f5234f75",
      "type": "library",
      "name": "github.com/onsi/gomega",
      "version": "v1.17.0",
      "cpe": "cpe:2.3:a:onsi:gomega:v1.17.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/onsi/gomega@v1.17.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:9Luw4uT5HTjHTN8+aNcSThgH1vdXnmdJ8xIfZ4wyTRE="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/datachannel@v1.5.10?package-id=fc34beb79c8dc018",
      "type": "library",
      "name": "github.com/pion/datachannel",
      "version": "v1.5.10",
      "cpe": "cpe:2.3:a:pion:datachannel:v1.5.10:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/datachannel@v1.5.10",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:ly0Q26K1i6ZkGf42W7D4hQYR90pZwzFOjTq5AuCKk4o="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/dtls@v3.0.6?package-id=854945215da77df3#v3",
      "type": "library",
      "name": "github.com/pion/dtls/v3",
      "version": "v3.0.6",
      "cpe": "cpe:2.3:a:pion:dtls\\/v3:v3.0.6:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/dtls@v3.0.6#v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:7Hkd8WhAJNbRgq9RgdNh1aaWlZlGpYTzdqjy9x9sK2E="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/ice@v4.0.10?package-id=634862ee9eb4a70d#v4",
      "type": "library",
      "name": "github.com/pion/ice/v4",
      "version": "v4.0.10",
      "cpe": "cpe:2.3:a:pion:ice\\/v4:v4.0.10:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/ice@v4.0.10#v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:P59w1iauC/wPk9PdY8Vjl4fOFL5B+USq1+xbDcN6gT4="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/interceptor@v0.1.40?package-id=34a015c4579860ed",
      "type": "library",
      "name": "github.com/pion/interceptor",
      "version": "v0.1.40",
      "cpe": "cpe:2.3:a:pion:interceptor:v0.1.40:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/interceptor@v0.1.40",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:e0BjnPcGpr2CFQgKhrQisBU7V3GXK6wrfYrGYaU6Jq4="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/logging@v0.2.4?package-id=8661f3eb73dd66c1",
      "type": "library",
      "name": "github.com/pion/logging",
      "version": "v0.2.4",
      "cpe": "cpe:2.3:a:pion:logging:v0.2.4:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/logging@v0.2.4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:tTew+7cmQ+Mc1pTBLKH2puKsOvhm32dROumOZ655zB8="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/mdns@v2.0.7?package-id=6dab1f6de99fa5ba#v2",
      "type": "library",
      "name": "github.com/pion/mdns/v2",
      "version": "v2.0.7",
      "cpe": "cpe:2.3:a:pion:mdns\\/v2:v2.0.7:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/mdns@v2.0.7#v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:c9kM8ewCgjslaAmicYMFQIde2H9/lrZpjBkN8VwoVtM="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/randutil@v0.1.0?package-id=92b473e239d52d6e",
      "type": "library",
      "name": "github.com/pion/randutil",
      "version": "v0.1.0",
      "cpe": "cpe:2.3:a:pion:randutil:v0.1.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/randutil@v0.1.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:CFG1UdESneORglEsnimhUjf33Rwjubwj6xfiOXBa3mA="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/rtcp@v1.2.15?package-id=3263f2776c1ebafd",
      "type": "library",
      "name": "github.com/pion/rtcp",
      "version": "v1.2.15",
      "cpe": "cpe:2.3:a:pion:rtcp:v1.2.15:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/rtcp@v1.2.15",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:LZQi2JbdipLOj4eBjK4wlVoQWfrZbh3Q6eHtWtJBZBo="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/rtp@v1.8.20?package-id=39ee1ae357e99972",
      "type": "library",
      "name": "github.com/pion/rtp",
      "version": "v1.8.20",
      "cpe": "cpe:2.3:a:pion:rtp:v1.8.20:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/rtp@v1.8.20",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:8zcyqohadZE8FCBeGdyEvHiclPIezcwRQH9zfapFyYI="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/sctp@v1.8.39?package-id=667aeace54fd5fef",
      "type": "library",
      "name": "github.com/pion/sctp",
      "version": "v1.8.39",
      "cpe": "cpe:2.3:a:pion:sctp:v1.8.39:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/sctp@v1.8.39",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:PJma40vRHa3UTO3C4MyeJDQ+KIobVYRZQZ0Nt7SjQnE="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/sdp@v3.0.14?package-id=796534a291e507d7#v3",
      "type": "library",
      "name": "github.com/pion/sdp/v3",
      "version": "v3.0.14",
      "cpe": "cpe:2.3:a:pion:sdp\\/v3:v3.0.14:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/sdp@v3.0.14#v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:1h7gBr9FhOWH5GjWWY5lcw/U85MtdcibTyt/o6RxRUI="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/srtp@v3.0.6?package-id=2093a27d4be26173#v3",
      "type": "library",
      "name": "github.com/pion/srtp/v3",
      "version": "v3.0.6",
      "cpe": "cpe:2.3:a:pion:srtp\\/v3:v3.0.6:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/srtp@v3.0.6#v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:E2gyj1f5X10sB/qILUGIkL4C2CqK269Xq167PbGCc/4="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/stun@v3.0.0?package-id=73cd4539c4c7de8d#v3",
      "type": "library",
      "name": "github.com/pion/stun/v3",
      "version": "v3.0.0",
      "cpe": "cpe:2.3:a:pion:stun\\/v3:v3.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/stun@v3.0.0#v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:4h1gwhWLWuZWOJIJR9s2ferRO+W3zA/b6ijOI6mKzUw="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/transport@v3.0.7?package-id=34d6362438e8cbf1#v3",
      "type": "library",
      "name": "github.com/pion/transport/v3",
      "version": "v3.0.7",
      "cpe": "cpe:2.3:a:pion:transport\\/v3:v3.0.7:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/transport@v3.0.7#v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:iRbMH05BzSNwhILHoBoAPxoB9xQgOaJk+591KC9P1o0="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pion/turn@v4.0.0?package-id=3b0eafe5628eecc7#v4",
      "type": "library",
      "name": "github.com/pion/turn/v4",
      "version": "v4.0.0",
      "cpe": "cpe:2.3:a:pion:turn\\/v4:v4.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pion/turn@v4.0.0#v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:qxplo3Rxa9Yg1xXDxxH8xaqcyGUtbHYw4QSCvmFWvhM="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/pmezard/go-difflib@v1.0.0?package-id=2e9153c8c5a4f906",
      "type": "library",
      "name": "github.com/pmezard/go-difflib",
      "version": "v1.0.0",
      "cpe": "cpe:2.3:a:pmezard:go-difflib:v1.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/pmezard/go-difflib@v1.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pmezard:go_difflib:v1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/sclevine/agouti@v3.0.0%2Bincompatible?package-id=811eb8984bbba1fa",
      "type": "library",
      "name": "github.com/sclevine/agouti",
      "version": "v3.0.0+incompatible",
      "cpe": "cpe:2.3:a:sclevine:agouti:v3.0.0\\+incompatible:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/sclevine/agouti@v3.0.0%2Bincompatible",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:8IBJS6PWz3uTlMP3YBIR5f+KAldcGuOeFkFbUWfBgK4="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/stretchr/testify@v1.10.0?package-id=d4d0576c4c3746f0",
      "type": "library",
      "name": "github.com/stretchr/testify",
      "version": "v1.10.0",
      "cpe": "cpe:2.3:a:stretchr:testify:v1.10.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/stretchr/testify@v1.10.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/github.com/wlynxg/anet@v0.0.5?package-id=7bb0a870c688ef52",
      "type": "library",
      "name": "github.com/wlynxg/anet",
      "version": "v0.0.5",
      "cpe": "cpe:2.3:a:wlynxg:anet:v0.0.5:*:*:*:*:*:*:*",
      "purl": "pkg:golang/github.com/wlynxg/anet@v0.0.5",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:J3VJGi1gvo0JwZ/P1/Yc/8p63SoW98B5dHkYDmpgvvU="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/golang.org/x/crypto@v0.33.0?package-id=d7be98416807ffb6",
      "type": "library",
      "name": "golang.org/x/crypto",
      "version": "v0.33.0",
      "cpe": "cpe:2.3:a:go:ssh:v0.33.0:*:*:*:*:go:*:*",
      "purl": "pkg:golang/golang.org/x/crypto@v0.33.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:IOBPskki6Lysi0lo9qQvbxiQ+FvsCC/YWOecCHAixus="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/golang.org/x/net@v0.35.0?package-id=fa92345ba6fabde6",
      "type": "library",
      "name": "golang.org/x/net",
      "version": "v0.35.0",
      "cpe": "cpe:2.3:a:golang:networking:v0.35.0:*:*:*:*:go:*:*",
      "purl": "pkg:golang/golang.org/x/net@v0.35.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:T5GQRQb2y08kTAByq9L4/bz8cipCdA8FbRTXewonqY8="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/golang.org/x/sys@v0.30.0?package-id=c93c59f02a64581b",
      "type": "library",
      "name": "golang.org/x/sys",
      "version": "v0.30.0",
      "cpe": "cpe:2.3:a:golang:x\\/sys:v0.30.0:*:*:*:*:*:*:*",
      "purl": "pkg:golang/golang.org/x/sys@v0.30.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc="
        }
      ]
    },
    {
      "bom-ref": "pkg:golang/gopkg.in/yaml.v3@v3.0.1?package-id=716c668b92999095",
      "type": "library",
      "name": "gopkg.in/yaml.v3",
      "version": "v3.0.1",
      "cpe": "cpe:2.3:a:yaml_project:yaml:v3.0.1:*:*:*:*:go:*:*",
      "purl": "pkg:golang/gopkg.in/yaml.v3@v3.0.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "go-module-file-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "go"
        },
        {
          "name": "syft:package:type",
          "value": "go-module"
        },
        {
          "name": "syft:package:metadataType",
          "value": "go-module-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/go.mod"
        },
        {
          "name": "syft:metadata:h1Digest",
          "value": "h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA="
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/har-schema@2.0.0?package-id=af65235478b473f7",
      "type": "library",
      "name": "har-schema",
      "version": "2.0.0",
      "cpe": "cpe:2.3:a:har-schema:har-schema:2.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/har-schema@2.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har-schema:har_schema:2.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har_schema:har-schema:2.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har_schema:har_schema:2.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har:har-schema:2.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har:har_schema:2.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/har-validator@5.1.3?package-id=b3c374937ea365bf",
      "type": "library",
      "name": "har-validator",
      "version": "5.1.3",
      "cpe": "cpe:2.3:a:har-validator:har-validator:5.1.3:*:*:*:*:*:*:*",
      "purl": "pkg:npm/har-validator@5.1.3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har-validator:har_validator:5.1.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har_validator:har-validator:5.1.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har_validator:har_validator:5.1.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har:har-validator:5.1.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:har:har_validator:5.1.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/http-signature@1.2.0?package-id=236de08aa9d3aa5a",
      "type": "library",
      "name": "http-signature",
      "version": "1.2.0",
      "cpe": "cpe:2.3:a:joyent:http-signature:1.2.0:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/http-signature@1.2.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/is-typedarray@1.0.0?package-id=259124d702e82344",
      "type": "library",
      "name": "is-typedarray",
      "version": "1.0.0",
      "cpe": "cpe:2.3:a:is-typedarray:is-typedarray:1.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/is-typedarray@1.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:is-typedarray:is_typedarray:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:is_typedarray:is-typedarray:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:is_typedarray:is_typedarray:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:is:is-typedarray:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:is:is_typedarray:1.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/isstream@0.1.2?package-id=978d5e075e6ec5d4",
      "type": "library",
      "name": "isstream",
      "version": "0.1.2",
      "cpe": "cpe:2.3:a:isstream:isstream:0.1.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/isstream@0.1.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/jsbn@0.1.1?package-id=8266231f2c315aed",
      "type": "library",
      "name": "jsbn",
      "version": "0.1.1",
      "cpe": "cpe:2.3:a:jsbn:jsbn:0.1.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/jsbn@0.1.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/json-schema@0.2.3?package-id=35035061b3dbc803",
      "type": "library",
      "name": "json-schema",
      "version": "0.2.3",
      "cpe": "cpe:2.3:a:json-schema:json-schema:0.2.3:*:*:*:*:*:*:*",
      "purl": "pkg:npm/json-schema@0.2.3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-schema:json_schema:0.2.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_schema:json-schema:0.2.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_schema:json_schema:0.2.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json:json-schema:0.2.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json:json_schema:0.2.3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/json-schema-traverse@0.4.1?package-id=21b00b2b81fe7b21",
      "type": "library",
      "name": "json-schema-traverse",
      "version": "0.4.1",
      "cpe": "cpe:2.3:a:json-schema-traverse:json-schema-traverse:0.4.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/json-schema-traverse@0.4.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-schema-traverse:json_schema_traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_schema_traverse:json-schema-traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_schema_traverse:json_schema_traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-schema:json-schema-traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-schema:json_schema_traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_schema:json-schema-traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_schema:json_schema_traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json:json-schema-traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json:json_schema_traverse:0.4.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/json-stringify-safe@5.0.1?package-id=ce608e703e2f42e1",
      "type": "library",
      "name": "json-stringify-safe",
      "version": "5.0.1",
      "cpe": "cpe:2.3:a:json-stringify-safe:json-stringify-safe:5.0.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/json-stringify-safe@5.0.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-stringify-safe:json_stringify_safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_stringify_safe:json-stringify-safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_stringify_safe:json_stringify_safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-stringify:json-stringify-safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json-stringify:json_stringify_safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_stringify:json-stringify-safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json_stringify:json_stringify_safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json:json-stringify-safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:json:json_stringify_safe:5.0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/jsprim@1.4.1?package-id=9120664132cce235",
      "type": "library",
      "name": "jsprim",
      "version": "1.4.1",
      "cpe": "cpe:2.3:a:jsprim:jsprim:1.4.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/jsprim@1.4.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/mime-db@1.44.0?package-id=ac686fb04bcfdd15",
      "type": "library",
      "name": "mime-db",
      "version": "1.44.0",
      "cpe": "cpe:2.3:a:mime-db:mime-db:1.44.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/mime-db@1.44.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime-db:mime_db:1.44.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime_db:mime-db:1.44.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime_db:mime_db:1.44.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime:mime-db:1.44.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime:mime_db:1.44.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/mime-types@2.1.27?package-id=34431ca7f2672077",
      "type": "library",
      "name": "mime-types",
      "version": "2.1.27",
      "cpe": "cpe:2.3:a:mime-types:mime-types:2.1.27:*:*:*:*:*:*:*",
      "purl": "pkg:npm/mime-types@2.1.27",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime-types:mime_types:2.1.27:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime_types:mime-types:2.1.27:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime_types:mime_types:2.1.27:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime:mime-types:2.1.27:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:mime:mime_types:2.1.27:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/oauth-sign@0.9.0?package-id=0265eb3480183f41",
      "type": "library",
      "name": "oauth-sign",
      "version": "0.9.0",
      "cpe": "cpe:2.3:a:oauth-sign:oauth-sign:0.9.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/oauth-sign@0.9.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:oauth-sign:oauth_sign:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:oauth_sign:oauth-sign:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:oauth_sign:oauth_sign:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:oauth:oauth-sign:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:oauth:oauth_sign:0.9.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/performance-now@2.1.0?package-id=0a57196bc18559f2",
      "type": "library",
      "name": "performance-now",
      "version": "2.1.0",
      "cpe": "cpe:2.3:a:performance-now:performance-now:2.1.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/performance-now@2.1.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:performance-now:performance_now:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:performance_now:performance-now:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:performance_now:performance_now:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:performance:performance-now:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:performance:performance_now:2.1.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=2828fa247e28fd29#.github/workflows/api.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/api.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/api.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/api.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/api.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/api.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=eabcb15da37ca126#.github/workflows/codeql-analysis.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/codeql-analysis.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/codeql-analysis.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/codeql-analysis.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/codeql-analysis.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/codeql-analysis.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/codeql_analysis.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/codeql_analysis.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/codeql-analysis.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/codeql_analysis.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/codeql_analysis.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/codeql:pion\\/.goassets\\/.github\\/workflows\\/codeql-analysis.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/codeql:pion\\/.goassets\\/.github\\/workflows\\/codeql_analysis.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/codeql-analysis.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=5cc07acb4dd24036#.github/workflows/lint.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/lint.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/lint.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/lint.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/lint.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/lint.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=5c40253a5bd137c9#.github/workflows/release.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/release.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/release.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/release.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/release.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=385e8f4970d25af0#.github/workflows/renovate-go-sum-fix.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/renovate-go-sum-fix.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/renovate-go-sum-fix.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate-go:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate-go:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate_go:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate_go:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate:pion\\/.goassets\\/.github\\/workflows\\/renovate-go-sum-fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/renovate:pion\\/.goassets\\/.github\\/workflows\\/renovate_go_sum_fix.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/renovate-go-sum-fix.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=236ed81380cd51aa#.github/workflows/reuse.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/reuse.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/reuse.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/reuse.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/reuse.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/reuse.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=12735d73e4084a24#.github/workflows/test-i386.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/test-i386.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test-i386.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test-i386.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/test-i386.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test-i386.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test_i386.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test_i386.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test-i386.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test_i386.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test_i386.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test:pion\\/.goassets\\/.github\\/workflows\\/test-i386.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test:pion\\/.goassets\\/.github\\/workflows\\/test_i386.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/test.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=4b291bfe4a63487c#.github/workflows/test-wasm.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/test-wasm.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test-wasm.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test-wasm.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/test-wasm.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test-wasm.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test_wasm.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test_wasm.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test-wasm.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test_wasm.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test_wasm.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test:pion\\/.goassets\\/.github\\/workflows\\/test-wasm.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test:pion\\/.goassets\\/.github\\/workflows\\/test_wasm.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/test.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=d8929bd475e2c436#.github/workflows/test.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/test.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/test.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/test.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/test.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/test.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/pion/.goassets@master?package-id=632212c4d866dd38#.github/workflows/tidy-check.reusable.yml",
      "type": "library",
      "name": "pion/.goassets/.github/workflows/tidy-check.reusable.yml",
      "version": "master",
      "cpe": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/tidy-check.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/tidy-check.reusable.yml:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/pion/.goassets@master#.github/workflows/tidy-check.reusable.yml",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-action-workflow-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action-workflow"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/tidy-check.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/tidy_check.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/tidy_check.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/tidy-check.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/tidy_check.reusable.yml:pion\\/.goassets\\/.github\\/workflows\\/tidy_check.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/tidy:pion\\/.goassets\\/.github\\/workflows\\/tidy-check.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:pion\\/.goassets\\/.github\\/workflows\\/tidy:pion\\/.goassets\\/.github\\/workflows\\/tidy_check.reusable.yml:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/tidy-check.yaml"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/psl@1.8.0?package-id=71f8215ab0e828c0",
      "type": "library",
      "name": "psl",
      "version": "1.8.0",
      "cpe": "cpe:2.3:a:psl:psl:1.8.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/psl@1.8.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/punycode@2.1.1?package-id=ab8da0002e2d4f31",
      "type": "library",
      "name": "punycode",
      "version": "2.1.1",
      "cpe": "cpe:2.3:a:punycode:punycode:2.1.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/punycode@2.1.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/qs@6.5.2?package-id=492ac7bb7bd30dd1",
      "type": "library",
      "name": "qs",
      "version": "6.5.2",
      "cpe": "cpe:2.3:a:qs_project:qs:6.5.2:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/qs@6.5.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/request@2.88.2?package-id=258aee370cfe349f",
      "type": "library",
      "name": "request",
      "version": "2.88.2",
      "cpe": "cpe:2.3:a:request_project:request:2.88.2:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/request@2.88.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/safe-buffer@5.1.2?package-id=9b71ed1a03e6fc17",
      "type": "library",
      "name": "safe-buffer",
      "version": "5.1.2",
      "cpe": "cpe:2.3:a:safe-buffer:safe-buffer:5.1.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/safe-buffer@5.1.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe-buffer:safe_buffer:5.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe_buffer:safe-buffer:5.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe_buffer:safe_buffer:5.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe:safe-buffer:5.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe:safe_buffer:5.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/safe-buffer@5.2.1?package-id=dd0421ba5bba23d7",
      "type": "library",
      "name": "safe-buffer",
      "version": "5.2.1",
      "cpe": "cpe:2.3:a:safe-buffer:safe-buffer:5.2.1:*:*:*:*:*:*:*",
      "purl": "pkg:npm/safe-buffer@5.2.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe-buffer:safe_buffer:5.2.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe_buffer:safe-buffer:5.2.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe_buffer:safe_buffer:5.2.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe:safe-buffer:5.2.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safe:safe_buffer:5.2.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/safer-buffer@2.1.2?package-id=0e16fe9b1e334ea9",
      "type": "library",
      "name": "safer-buffer",
      "version": "2.1.2",
      "cpe": "cpe:2.3:a:safer-buffer:safer-buffer:2.1.2:*:*:*:*:*:*:*",
      "purl": "pkg:npm/safer-buffer@2.1.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safer-buffer:safer_buffer:2.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safer_buffer:safer-buffer:2.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safer_buffer:safer_buffer:2.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safer:safer-buffer:2.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:safer:safer_buffer:2.1.2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/sshpk@1.16.1?package-id=09fac1a7f046a1ab",
      "type": "library",
      "name": "sshpk",
      "version": "1.16.1",
      "cpe": "cpe:2.3:a:joyent:sshpk:1.16.1:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/sshpk@1.16.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/tough-cookie@2.5.0?package-id=b0f4e20f7af9be88",
      "type": "library",
      "name": "tough-cookie",
      "version": "2.5.0",
      "cpe": "cpe:2.3:a:salesforce:tough-cookie:2.5.0:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/tough-cookie@2.5.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/tunnel-agent@0.6.0?package-id=99827e88335a6744",
      "type": "library",
      "name": "tunnel-agent",
      "version": "0.6.0",
      "cpe": "cpe:2.3:a:tunnel-agent:tunnel-agent:0.6.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/tunnel-agent@0.6.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:tunnel-agent:tunnel_agent:0.6.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:tunnel_agent:tunnel-agent:0.6.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:tunnel_agent:tunnel_agent:0.6.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:tunnel:tunnel-agent:0.6.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:tunnel:tunnel_agent:0.6.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/tweetnacl@0.14.5?package-id=ba362cb6c0cbc06d",
      "type": "library",
      "name": "tweetnacl",
      "version": "0.14.5",
      "cpe": "cpe:2.3:a:tweetnacl:tweetnacl:0.14.5:*:*:*:*:*:*:*",
      "purl": "pkg:npm/tweetnacl@0.14.5",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/uri-js@4.2.2?package-id=e616c05a4bfc5ac8",
      "type": "library",
      "name": "uri-js",
      "version": "4.2.2",
      "cpe": "cpe:2.3:a:garycourt:uri-js:4.2.2:*:*:*:*:node.js:*:*",
      "purl": "pkg:npm/uri-js@4.2.2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/uuid@3.4.0?package-id=d280ce6ff15b338e",
      "type": "library",
      "name": "uuid",
      "version": "3.4.0",
      "cpe": "cpe:2.3:a:uuid:uuid:3.4.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/uuid@3.4.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/verror@1.10.0?package-id=7869da9fa13bddaf",
      "type": "library",
      "name": "verror",
      "version": "1.10.0",
      "cpe": "cpe:2.3:a:verror:verror:1.10.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/verror@1.10.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "pkg:npm/webidl-conversions@7.0.0?package-id=2750e6a344cf8acf",
      "type": "library",
      "name": "webidl-conversions",
      "version": "7.0.0",
      "cpe": "cpe:2.3:a:webidl-conversions:webidl-conversions:7.0.0:*:*:*:*:*:*:*",
      "purl": "pkg:npm/webidl-conversions@7.0.0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "javascript-lock-cataloger"
        },
        {
          "name": "syft:package:language",
          "value": "javascript"
        },
        {
          "name": "syft:package:type",
          "value": "npm"
        },
        {
          "name": "syft:package:metadataType",
          "value": "javascript-yarn-lock-entry"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:webidl-conversions:webidl_conversions:7.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:webidl_conversions:webidl-conversions:7.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:webidl_conversions:webidl_conversions:7.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:webidl:webidl-conversions:7.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:webidl:webidl_conversions:7.0.0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/yarn.lock"
        }
      ]
    },
    {
      "bom-ref": "2a9a48dd2fd7871c",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/api.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "1bd9820f9fc787fb39ec3e178b748b8ef591a373"
        },
        {
          "alg": "SHA-256",
          "content": "200d208b9248a8f5136ef3efab5ee389c8b699f9fa893fd5504f03b4a3cacaa3"
        }
      ]
    },
    {
      "bom-ref": "ca32724a6c53e088",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/browser-e2e.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "a1bd2926db8d2801d863db58fad6e3ec12cbb836"
        },
        {
          "alg": "SHA-256",
          "content": "8b24e960a04d96ac68e0b666bec4541ff40dee6a28f031b347852107374c9909"
        }
      ]
    },
    {
      "bom-ref": "5e19ea2e1f9dfee4",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/codeql-analysis.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "1fcaf0b4cedc53cb0ad292cceb0a45b729638c92"
        },
        {
          "alg": "SHA-256",
          "content": "48269b7f1cf344c5438f5ec77a95ca5e9e0373838f575fd50ea6c6de2759605d"
        }
      ]
    },
    {
      "bom-ref": "ddbc30de66f68f60",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/examples-tests.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "54f6fbbce61a44e549dd94ea22261021848825e4"
        },
        {
          "alg": "SHA-256",
          "content": "ff955e7fef2b8b57ff27c0da18bbdc105891d8deb011fab62dda89e3aed37ac6"
        }
      ]
    },
    {
      "bom-ref": "0ec0c3c6d68a288f",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/lint.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "3a77ea38903c0993ab7e0dd77be07e52dabd422b"
        },
        {
          "alg": "SHA-256",
          "content": "5abc3fd577235c9e95a5c861470b40e5ddfeefe44d74714c14589d7d1d3be2f4"
        }
      ]
    },
    {
      "bom-ref": "cc210d8a1a5f5704",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/release.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "3b5f3a41a14aa9aeeef7d1afb54dc984e38013c5"
        },
        {
          "alg": "SHA-256",
          "content": "51a18f7f0fefeb60e2b808c7c70d50dc55e9ba1fc94b0c184f42fd88c4d8e6ff"
        }
      ]
    },
    {
      "bom-ref": "f63e1a90978f9d9f",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/renovate-go-sum-fix.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "38bacb77f14c4e1887c407afc5a462c44839d9f7"
        },
        {
          "alg": "SHA-256",
          "content": "202e5baa731807d0b2684ca4ed5c7129c3273aa7fa671064b3699bf82eaa9751"
        }
      ]
    },
    {
      "bom-ref": "8de10344cadb03de",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/reuse.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "1055c1b86d824b4943a16e3cdd8496273e17ffbc"
        },
        {
          "alg": "SHA-256",
          "content": "2436e2af6a2780f1eabdeed6e6b78585bbc865bb3c019d46898fe4fdee9cd77f"
        }
      ]
    },
    {
      "bom-ref": "16d0ec2920bb305f",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/standardjs.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "e32077c5f19fcaead5ccb5a1f742134564daa7b8"
        },
        {
          "alg": "SHA-256",
          "content": "0c94f478989b93893de184566cdfe02980202daa50e8b437428ecdf4b9f26560"
        }
      ]
    },
    {
      "bom-ref": "c36203b231c0805f",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/test.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "84873de9493b59891a7572ef748ef6848d6b8225"
        },
        {
          "alg": "SHA-256",
          "content": "d69b6ba0da02bba8aef168b3f286b53f1d6fd6ff676c3bf25d95393b5ad80a4b"
        }
      ]
    },
    {
      "bom-ref": "5e5ff4553d7c82b0",
      "type": "file",
      "name": "/home/webrtc-4.1.3/.github/workflows/tidy-check.yaml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "11216438bd8ee37311581b759f5c888e28ad3699"
        },
        {
          "alg": "SHA-256",
          "content": "a9fadc57171b8c8844956bda57d8ecf30071be86e180d7b76723538860d07ac2"
        }
      ]
    },
    {
      "bom-ref": "3fc5a8d3d86e9790",
      "type": "file",
      "name": "/home/webrtc-4.1.3/go.mod",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "050f20726bec2c5423640b4db36d92d9b7ebea74"
        },
        {
          "alg": "SHA-256",
          "content": "74dae47723a191ddaf755a5dda53e6424726f80048f2402d79d6916c3f1b5471"
        }
      ]
    },
    {
      "bom-ref": "dcee26e98fae7b36",
      "type": "file",
      "name": "/home/webrtc-4.1.3/yarn.lock",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "cbd7fbb8ec48003dfdb429b8b13f20f60ba59e44"
        },
        {
          "alg": "SHA-256",
          "content": "5ca49d5388a7ac1a543028cb7060ec068c4b3ce5fd1259173761dcdebb2e9b86"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/webrtc-4.0.11",
      "New file": [
        "/home/webrtc-4.1.3/certificate_js_test.go",
        "/home/webrtc-4.1.3/examples/play-from-disk-fec/main.go",
        "/home/webrtc-4.1.3/mimetype.go",
        "/home/webrtc-4.1.3/pkg/media/h265reader/h265reader.go",
        "/home/webrtc-4.1.3/pkg/media/h265reader/h265reader_test.go",
        "/home/webrtc-4.1.3/pkg/media/h265reader/nalunittype.go",
        "/home/webrtc-4.1.3/pkg/media/h265writer/h265writer.go",
        "/home/webrtc-4.1.3/pkg/media/h265writer/h265writer_test.go",
        "/home/webrtc-4.1.3/rtpcodec_test.go"
      ],
      "Deleted file": [
        "/home/webrtc-4.0.11/atomicbool.go"
      ],
      "Modified file": [
        {
          "file": "/home/webrtc-4.1.3/api_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/api_test.go",
            "+++ /home/webrtc-4.1.3/api_test.go",
            "@@ -10,43 +10,30 @@",
            " \t\"testing\"",
            " ",
            " \t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestNewAPI(t *testing.T) {",
            " \tapi := NewAPI()",
            "-",
            "-\tif api.settingEngine == nil {",
            "-\t\tt.Error(\"Failed to init settings engine\")",
            "-\t}",
            "-",
            "-\tif api.mediaEngine == nil {",
            "-\t\tt.Error(\"Failed to init media engine\")",
            "-\t}",
            "-",
            "-\tif api.interceptorRegistry == nil {",
            "-\t\tt.Error(\"Failed to init interceptor registry\")",
            "-\t}",
            "+\tassert.NotNil(t, api.settingEngine, \"failed to init settings engine\")",
            "+\tassert.NotNil(t, api.mediaEngine, \"failed to init media engine\")",
            "+\tassert.NotNil(t, api.interceptorRegistry, \"failed to init interceptor registry\")",
            " }",
            " ",
            " func TestNewAPI_Options(t *testing.T) {",
            " \ts := SettingEngine{}",
            " \ts.DetachDataChannels()",
            " ",
            " \tapi := NewAPI(",
            " \t\tWithSettingEngine(s),",
            " \t)",
            " ",
            "-\tif !api.settingEngine.detach.DataChannels {",
            "-\t\tt.Error(\"Failed to set settings engine\")",
            "-\t}",
            "-",
            "-\tif len(api.mediaEngine.audioCodecs) == 0 || len(api.mediaEngine.videoCodecs) == 0 {",
            "-\t\tt.Error(\"Failed to set media engine\")",
            "-\t}",
            "+\tassert.True(t, api.settingEngine.detach.DataChannels, \"failed to set settings engine\")",
            "+\tassert.NotEmpty(t, api.mediaEngine.audioCodecs, \"failed to set audio codecs\")",
            "+\tassert.NotEmpty(t, api.mediaEngine.videoCodecs, \"failed to set video codecs\")",
            " }",
            " ",
            " func TestNewAPI_OptionsDefaultize(t *testing.T) {",
            " \tapi := NewAPI(",
            " \t\tWithMediaEngine(nil),",
            " \t\tWithInterceptorRegistry(nil),",
            " \t)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/certificate.go",
          "change": [
            "--- /home/webrtc-4.0.11/certificate.go",
            "+++ /home/webrtc-4.1.3/certificate.go",
            "@@ -1,13 +1,10 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            "-//go:build !js",
            "-// +build !js",
            "-",
            " package webrtc",
            " ",
            " import (",
            " \t\"crypto\"",
            " \t\"crypto/ecdsa\"",
            " \t\"crypto/rand\"",
            " \t\"crypto/rsa\"",
            "@@ -187,41 +184,63 @@",
            " \treport.Collect(stats.ID, stats)",
            " ",
            " \treturn nil",
            " }",
            " ",
            " // CertificateFromPEM creates a fresh certificate based on a string containing",
            " // pem blocks fort the private key and x509 certificate.",
            "-func CertificateFromPEM(pems string) (*Certificate, error) {",
            "-\t// decode & parse the certificate",
            "-\tblock, more := pem.Decode([]byte(pems))",
            "-\tif block == nil || block.Type != \"CERTIFICATE\" {",
            "-\t\treturn nil, errCertificatePEMFormatError",
            "-\t}",
            "-\tcertBytes := make([]byte, base64.StdEncoding.DecodedLen(len(block.Bytes)))",
            "-\tn, err := base64.StdEncoding.Decode(certBytes, block.Bytes)",
            "-\tif err != nil {",
            "-\t\treturn nil, fmt.Errorf(\"failed to decode ceritifcate: %w\", err)",
            "-\t}",
            "-\tcert, err := x509.ParseCertificate(certBytes[:n])",
            "-\tif err != nil {",
            "-\t\treturn nil, fmt.Errorf(\"failed parsing ceritifcate: %w\", err)",
            "-\t}",
            "-\t// decode & parse the private key",
            "-\tblock, _ = pem.Decode(more)",
            "-\tif block == nil || block.Type != \"PRIVATE KEY\" {",
            "-\t\treturn nil, errCertificatePEMFormatError",
            "+func CertificateFromPEM(pems string) (*Certificate, error) { //nolint: cyclop",
            "+\tvar cert *x509.Certificate",
            "+\tvar privateKey crypto.PrivateKey",
            "+",
            "+\tvar block *pem.Block",
            "+\tmore := []byte(pems)",
            "+\tfor {",
            "+\t\tvar err error",
            "+\t\tblock, more = pem.Decode(more)",
            "+\t\tif block == nil {",
            "+\t\t\tbreak",
            "+\t\t}",
            "+",
            "+\t\t// decode & parse the certificate",
            "+\t\tswitch block.Type {",
            "+\t\tcase \"CERTIFICATE\":",
            "+\t\t\tif cert != nil {",
            "+\t\t\t\treturn nil, errCertificatePEMMultipleCert",
            "+\t\t\t}",
            "+\t\t\tcert, err = x509.ParseCertificate(block.Bytes)",
            "+\t\t\t// If parsing failed using block.Bytes, then parse the bytes as base64 and try again",
            "+\t\t\tif err != nil {",
            "+\t\t\t\tvar n int",
            "+\t\t\t\tcertBytes := make([]byte, base64.StdEncoding.DecodedLen(len(block.Bytes)))",
            "+\t\t\t\tn, err = base64.StdEncoding.Decode(certBytes, block.Bytes)",
            "+\t\t\t\tif err == nil {",
            "+\t\t\t\t\tcert, err = x509.ParseCertificate(certBytes[:n])",
            "+\t\t\t\t}",
            "+\t\t\t}",
            "+\t\tcase \"PRIVATE KEY\":",
            "+\t\t\tif privateKey != nil {",
            "+\t\t\t\treturn nil, errCertificatePEMMultiplePriv",
            "+\t\t\t}",
            "+\t\t\tprivateKey, err = x509.ParsePKCS8PrivateKey(block.Bytes)",
            "+\t\t}",
            "+",
            "+\t\t// Report errors from parsing either the private key or the certificate",
            "+\t\tif err != nil {",
            "+\t\t\treturn nil, fmt.Errorf(\"failed to decode %s: %w\", block.Type, err)",
            "+\t\t}",
            " \t}",
            "-\tprivateKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)",
            "-\tif err != nil {",
            "-\t\treturn nil, fmt.Errorf(\"unable to parse private key: %w\", err)",
            "+",
            "+\tif cert == nil || privateKey == nil {",
            "+\t\treturn nil, errCertificatePEMMissing",
            " \t}",
            "-\tx := CertificateFromX509(privateKey, cert)",
            " ",
            "-\treturn &x, nil",
            "+\tret := CertificateFromX509(privateKey, cert)",
            "+",
            "+\treturn &ret, nil",
            " }",
            " ",
            " // PEM returns the certificate encoded as two pem block: once for the X509",
            " // certificate and the other for the private key.",
            " func (c Certificate) PEM() (string, error) {",
            " \t// First write the X509 certificate",
            " \tvar builder strings.Builder"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/certificate_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/certificate_test.go",
            "+++ /home/webrtc-4.1.3/certificate_test.go",
            "@@ -100,39 +100,75 @@",
            " \tassert.False(t, cert.Expires().IsZero() || now.After(cert.Expires()))",
            " ",
            " \tx509Cert := CertificateFromX509(sk, &x509.Certificate{})",
            " \tassert.NotNil(t, x509Cert)",
            " \tassert.Contains(t, x509Cert.statsID, \"certificate\")",
            " }",
            " ",
            "-func TestBadCertificate(t *testing.T) {",
            "-\tvar nokey interface{}",
            "-\tbadcert, err := NewCertificate(nokey, x509.Certificate{})",
            "-\tassert.Nil(t, badcert)",
            "-\tassert.Error(t, err)",
            "-",
            "-\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)",
            "-\tassert.Nil(t, err)",
            "-",
            "-\tbadcert, err = NewCertificate(sk, x509.Certificate{})",
            "-\tassert.Nil(t, badcert)",
            "-\tassert.Error(t, err)",
            "-",
            "-\tc0 := Certificate{}",
            "-\tc1 := Certificate{}",
            "-\tassert.False(t, c0.Equals(c1))",
            "-}",
            "-",
            " func TestPEM(t *testing.T) {",
            " \tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)",
            " \tassert.Nil(t, err)",
            " \tcert, err := GenerateCertificate(sk)",
            " \tassert.Nil(t, err)",
            " ",
            " \tpem, err := cert.PEM()",
            " \tassert.Nil(t, err)",
            " \tcert2, err := CertificateFromPEM(pem)",
            " \tassert.Nil(t, err)",
            " \tpem2, err := cert2.PEM()",
            " \tassert.Nil(t, err)",
            " \tassert.Equal(t, pem, pem2)",
            " }",
            "+",
            "+const (",
            "+\tcertHeader = `!! This is a test certificate: Don't use it in production !!",
            "+You can create your own using openssl",
            "+` + \"```sh\" + `",
            "+openssl req -new -sha256 -newkey ec -pkeyopt ec_paramgen_curve:prime256v1 ` +",
            "+\t\t`-x509 -nodes -days 365 -out cert.pem -keyout cert.pem -subj \"/CN=WebRTC\"",
            "+openssl x509 -in cert.pem -noout -fingerprint -sha256",
            "+` + \"```\\n\"",
            "+",
            "+\tcertPriv = `-----BEGIN PRIVATE KEY-----",
            "+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg2XFaTNqFpTUqNtG9",
            "+A21MEe04JtsWVpUTDD8nI0KvchKhRANCAAS1nqME3jS5GFicwYfGDYaz7oSINwWm",
            "+X4BkfsSCxMrhr7mPtfxOi4Lxy/P3w6EvSSEU8t5E9ouKIWh5xPS9dYwu",
            "+-----END PRIVATE KEY-----",
            "+`",
            "+",
            "+\tcertCert = `-----BEGIN CERTIFICATE-----",
            "+MIIBljCCATugAwIBAgIUQa1sD+5HG43K+hCEVZLYxB68/hQwCgYIKoZIzj0EAwIw",
            "+IDEeMBwGA1UEAwwVc3dpdGNoLmV2YW4tYnJhc3MubmV0MB4XDTI0MDQyNDIwMjEy",
            "+MFoXDTI1MDQyNDIwMjEyMFowIDEeMBwGA1UEAwwVc3dpdGNoLmV2YW4tYnJhc3Mu",
            "+bmV0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEtZ6jBN40uRhYnMGHxg2Gs+6E",
            "+iDcFpl+AZH7EgsTK4a+5j7X8TouC8cvz98OhL0khFPLeRPaLiiFoecT0vXWMLqNT",
            "+MFEwHQYDVR0OBBYEFGecfGnYqZFVgUApHGgX2kSIhUusMB8GA1UdIwQYMBaAFGec",
            "+fGnYqZFVgUApHGgX2kSIhUusMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0EAwID",
            "+SQAwRgIhAJ3VWO8JZ7FEOJhxpUCeyOgl+G4vXSHtj9J9NRD3uGGZAiEAsTKGLOGE",
            "+9c6CtLDU9Ohf1c+Xj2Yi9H+srLZj1mrsnd4=",
            "+-----END CERTIFICATE-----",
            "+`",
            "+)",
            "+",
            "+func TestOpensslCert(t *testing.T) {",
            "+\t// Check that CertificateFromPEM can parse certificates with the PRIVATE KEY before the CERTIFICATE block",
            "+\t_, err := CertificateFromPEM(certHeader + certPriv + certCert)",
            "+\tassert.Nil(t, err)",
            "+}",
            "+",
            "+func TestEmpty(t *testing.T) {",
            "+\tcert, err := CertificateFromPEM(\"\")",
            "+\tassert.Nil(t, cert)",
            "+\tassert.Equal(t, errCertificatePEMMissing, err)",
            "+}",
            "+",
            "+func TestMultiCert(t *testing.T) {",
            "+\tcert, err := CertificateFromPEM(certHeader + certCert + certPriv + certCert)",
            "+\tassert.Nil(t, cert)",
            "+\tassert.Equal(t, errCertificatePEMMultipleCert, err)",
            "+}",
            "+",
            "+func TestMultiPriv(t *testing.T) {",
            "+\tcert, err := CertificateFromPEM(certPriv + certHeader + certCert + certPriv)",
            "+\tassert.Nil(t, cert)",
            "+\tassert.Equal(t, errCertificatePEMMultiplePriv, err)",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/configuration_js.go",
          "change": [
            "--- /home/webrtc-4.0.11/configuration_js.go",
            "+++ /home/webrtc-4.1.3/configuration_js.go",
            "@@ -32,8 +32,10 @@",
            " \tPeerIdentity string",
            " ",
            " \t// Certificates are not supported in the JavaScript/Wasm bindings.",
            " \t// Certificates []Certificate",
            " ",
            " \t// ICECandidatePoolSize describes the size of the prefetched ICE pool.",
            " \tICECandidatePoolSize uint8",
            "+",
            "+\tCertificates []Certificate `json:\"certificates,omitempty\"`",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/constants.go",
          "change": [
            "--- /home/webrtc-4.0.11/constants.go",
            "+++ /home/webrtc-4.1.3/constants.go",
            "@@ -1,13 +1,17 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package webrtc",
            " ",
            "-import \"github.com/pion/dtls/v3\"",
            "+import (",
            "+\t\"math\"",
            "+",
            "+\t\"github.com/pion/dtls/v3\"",
            "+)",
            " ",
            " const (",
            " \t// default as the standard ethernet MTU",
            " \t// can be overwritten with SettingEngine.SetReceiveMTU().",
            " \treceiveMTU = 1500",
            " ",
            " \t// simulcastProbeCount is the amount of RTP Packets",
            "@@ -15,21 +19,30 @@",
            " \t// mid and rid values.",
            " \tsimulcastProbeCount = 10",
            " ",
            " \t// simulcastMaxProbeRoutines is how many active routines can be used to probe",
            " \t// If the total amount of incoming SSRCes exceeds this new requests will be ignored.",
            " \tsimulcastMaxProbeRoutines = 25",
            " ",
            "+\t// Default Max SCTP Message Size is the largest single DataChannel",
            "+\t// message we can send or accept. This default was chosen to match FireFox.",
            "+\tdefaultMaxSCTPMessageSize = 1073741823",
            "+",
            "+\t// If a DataChannel Max Message Size isn't declared by the Remote(max-message-size)",
            "+\t// this is the value we default to. This value was chosen because it was the behavior",
            "+\t// of Pion before max-message-size was implemented.",
            "+\tsctpMaxMessageSizeUnsetValue = math.MaxUint16",
            "+",
            " \tmediaSectionApplication = \"application\"",
            " ",
            " \tsdpAttributeRid = \"rid\"",
            " ",
            " \tsdpAttributeSimulcast = \"simulcast\"",
            " ",
            "-\trtpOutboundMTU = 1200",
            "+\toutboundMTU = 1200",
            " ",
            " \trtpPayloadTypeBitmask = 0x7F",
            " ",
            " \tincomingUnhandledRTPSsrc = \"Incoming unhandled RTP ssrc(%d), OnTrack will not be fired. %v\"",
            " ",
            " \tgeneratedCertificateOrigin = \"WebRTC\""
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/datachannel.go",
          "change": [
            "--- /home/webrtc-4.0.11/datachannel.go",
            "+++ /home/webrtc-4.1.3/datachannel.go",
            "@@ -6,25 +6,23 @@",
            " ",
            " package webrtc",
            " ",
            " import (",
            " \t\"errors\"",
            " \t\"fmt\"",
            " \t\"io\"",
            "-\t\"math\"",
            " \t\"sync\"",
            " \t\"sync/atomic\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/datachannel\"",
            " \t\"github.com/pion/logging\"",
            " \t\"github.com/pion/webrtc/v4/pkg/rtcerr\"",
            " )",
            " ",
            "-const dataChannelBufferSize = math.MaxUint16 // message size limit for Chromium",
            " var errSCTPNotEstablished = errors.New(\"SCTP not established\")",
            " ",
            " // DataChannel represents a WebRTC DataChannel",
            " // The DataChannel interface represents a network channel",
            " // which can be used for bidirectional peer-to-peer transfers of arbitrary data.",
            " type DataChannel struct {",
            " \tmu sync.RWMutex",
            "@@ -400,32 +398,45 @@",
            " func (d *DataChannel) readLoop() {",
            " \tdefer func() {",
            " \t\td.mu.Lock()",
            " \t\treadLoopActive := d.readLoopActive",
            " \t\td.mu.Unlock()",
            " \t\tdefer close(readLoopActive)",
            " \t}()",
            "-\tbuffer := make([]byte, dataChannelBufferSize)",
            "+",
            "+\tbuffer := make([]byte, sctpMaxMessageSizeUnsetValue)",
            " \tfor {",
            " \t\tn, isString, err := d.dataChannel.ReadDataChannel(buffer)",
            " \t\tif err != nil {",
            "+\t\t\tif errors.Is(err, io.ErrShortBuffer) {",
            "+\t\t\t\tif int64(n) < int64(d.api.settingEngine.getSCTPMaxMessageSize()) {",
            "+\t\t\t\t\tbuffer = append(buffer, make([]byte, len(buffer))...) // nolint",
            "+",
            "+\t\t\t\t\tcontinue",
            "+\t\t\t\t}",
            "+",
            "+\t\t\t\td.log.Errorf(",
            "+\t\t\t\t\t\"Incoming DataChannel message larger then Max Message size %v\",",
            "+\t\t\t\t\td.api.settingEngine.getSCTPMaxMessageSize(),",
            "+\t\t\t\t)",
            "+\t\t\t}",
            "+",
            " \t\t\td.setReadyState(DataChannelStateClosed)",
            " \t\t\tif !errors.Is(err, io.EOF) {",
            " \t\t\t\td.onError(err)",
            " \t\t\t}",
            " \t\t\td.onClose()",
            " ",
            " \t\t\treturn",
            " \t\t}",
            " ",
            "-\t\tmsg := DataChannelMessage{Data: make([]byte, n), IsString: isString}",
            "-\t\tcopy(msg.Data, buffer[:n])",
            "-",
            "-\t\t// NB: Why was DataChannelMessage not passed as a pointer value?",
            "-\t\td.onMessage(msg) // nolint:staticcheck",
            "+\t\td.onMessage(DataChannelMessage{",
            "+\t\t\tData:     append([]byte{}, buffer[:n]...),",
            "+\t\t\tIsString: isString,",
            "+\t\t})",
            " \t}",
            " }",
            " ",
            " // Send sends the binary message to the DataChannel peer.",
            " func (d *DataChannel) Send(data []byte) error {",
            " \terr := d.ensureOpen()",
            " \tif err != nil {"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/datachannel_go_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/datachannel_go_test.go",
            "+++ /home/webrtc-4.1.3/datachannel_go_test.go",
            "@@ -3,20 +3,19 @@",
            " ",
            " //go:build !js",
            " // +build !js",
            " ",
            " package webrtc",
            " ",
            " import (",
            "-\t\"bytes\"",
            "+\t\"context\"",
            " \t\"crypto/rand\"",
            " \t\"encoding/binary\"",
            " \t\"io\"",
            " \t\"math/big\"",
            "-\t\"reflect\"",
            " \t\"regexp\"",
            " \t\"strings\"",
            " \t\"sync\"",
            " \t\"sync/atomic\"",
            " \t\"testing\"",
            " \t\"time\"",
            " ",
            "@@ -76,17 +75,15 @@",
            " \tmaxVal := 512",
            " \tout := make(chan int)",
            " \tinner := func(msg DataChannelMessage) {",
            " \t\t// randomly sleep",
            " \t\t// math/rand a weak RNG, but this does not need to be secure. Ignore with #nosec",
            " \t\t/* #nosec */",
            " \t\trandInt, err := rand.Int(rand.Reader, big.NewInt(int64(maxVal)))",
            "-\t\t/* #nosec */ if err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to get random sleep duration: %s\", err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"Failed to get random sleep duration\")",
            " \t\ttime.Sleep(time.Duration(randInt.Int64()) * time.Microsecond)",
            " \t\ts, _ := binary.Varint(msg.Data)",
            " \t\tout <- int(s)",
            " \t}",
            " \tdc.OnMessage(func(p DataChannelMessage) {",
            " \t\tinner(p)",
            " \t})",
            "@@ -189,17 +186,15 @@",
            " \t\tvar offerBufferedAmountLowThreshold uint64 = 1500",
            " \t\tvar nAnswerBufferedAmountLowCbs uint32",
            " \t\tvar answerBufferedAmountLowThreshold uint64 = 1400",
            " ",
            " \t\tbuf := make([]byte, 1000)",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tnPacketsToSend := int(10)",
            " \t\tvar nOfferReceived uint32",
            " \t\tvar nAnswerReceived uint32",
            " ",
            " \t\tdone := make(chan bool)",
            " ",
            "@@ -211,17 +206,15 @@",
            " \t\t\t}",
            " ",
            " \t\t\tanswerDC.OnOpen(func() {",
            " \t\t\t\tassert.Equal(t, answerBufferedAmountLowThreshold, answerDC.BufferedAmountLowThreshold(), \"value mismatch\")",
            " ",
            " \t\t\t\tfor i := 0; i < nPacketsToSend; i++ {",
            " \t\t\t\t\te := answerDC.Send(buf)",
            "-\t\t\t\t\tif e != nil {",
            "-\t\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t\t\t}",
            "+\t\t\t\t\tassert.NoError(t, e, \"Failed to send string on data channel\")",
            " \t\t\t\t}",
            " \t\t\t})",
            " ",
            " \t\t\tanswerDC.OnMessage(func(DataChannelMessage) {",
            " \t\t\t\tatomic.AddUint32(&nAnswerReceived, 1)",
            " \t\t\t})",
            " \t\t\tassert.True(t, answerDC.Ordered(), \"Ordered should be set to true\")",
            "@@ -236,28 +229,23 @@",
            " \t\t\t\tif atomic.LoadUint32(&nOfferBufferedAmountLowCbs) > 0 {",
            " \t\t\t\t\tdone <- true",
            " \t\t\t\t}",
            " \t\t\t})",
            " \t\t})",
            " ",
            " \t\tofferDC, err := offerPC.CreateDataChannel(expectedLabel, nil)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "-",
            "+\t\tassert.NoError(t, err, \"Failed to create a PC pair for testing\")",
            " \t\tassert.True(t, offerDC.Ordered(), \"Ordered should be set to true\")",
            " ",
            " \t\tofferDC.OnOpen(func() {",
            " \t\t\tassert.Equal(t, offerBufferedAmountLowThreshold, offerDC.BufferedAmountLowThreshold(), \"value mismatch\")",
            " ",
            " \t\t\tfor i := 0; i < nPacketsToSend; i++ {",
            " \t\t\t\te := offerDC.Send(buf)",
            "-\t\t\t\tif e != nil {",
            "-\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, e, \"Failed to send string on data channel\")",
            " \t\t\t\t// assert.Equal(t, (i+1)*len(buf), int(offerDC.BufferedAmount()), \"unexpected bufferedAmount\")",
            " \t\t\t}",
            " \t\t})",
            " ",
            " \t\tofferDC.OnMessage(func(DataChannelMessage) {",
            " \t\t\tatomic.AddUint32(&nOfferReceived, 1)",
            " \t\t})",
            "@@ -271,17 +259,15 @@",
            " \t\t\tatomic.AddUint32(&nOfferBufferedAmountLowCbs, 1)",
            " \t\t\tif atomic.LoadUint32(&nAnswerBufferedAmountLowCbs) > 0 {",
            " \t\t\t\tdone <- true",
            " \t\t\t}",
            " \t\t})",
            " ",
            " \t\terr = signalPair(offerPC, answerPC)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"Failed to signal our PC pair for testing\")",
            " ",
            " \t\tclosePair(t, offerPC, answerPC, done)",
            " ",
            " \t\tt.Logf(\"nOfferBufferedAmountLowCbs : %d\", nOfferBufferedAmountLowCbs)",
            " \t\tt.Logf(\"nAnswerBufferedAmountLowCbs: %d\", nAnswerBufferedAmountLowCbs)",
            " \t\tassert.True(t, nOfferBufferedAmountLowCbs > uint32(0), \"callback should be made at least once\")",
            " \t\tassert.True(t, nAnswerBufferedAmountLowCbs > uint32(0), \"callback should be made at least once\")",
            "@@ -291,17 +277,15 @@",
            " \t\treport := test.CheckRoutines(t)",
            " \t\tdefer report()",
            " ",
            " \t\tvar nCbs int",
            " \t\tbuf := make([]byte, 1000)",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdone := make(chan bool)",
            " ",
            " \t\tanswerPC.OnDataChannel(func(dataChannel *DataChannel) {",
            " \t\t\t// Make sure this is the data channel we were looking for. (Not the one",
            " \t\t\t// created in signalPair).",
            " \t\t\tif dataChannel.Label() != expectedLabel {",
            "@@ -318,45 +302,37 @@",
            " \t\t\t\t\t}()",
            " \t\t\t\t}",
            " \t\t\t})",
            " \t\t\tassert.True(t, dataChannel.Ordered(), \"Ordered should be set to true\")",
            " \t\t})",
            " ",
            " \t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")",
            " ",
            " \t\tdc.OnOpen(func() {",
            " \t\t\t// The value should directly be passed to sctp",
            " \t\t\tdc.SetBufferedAmountLowThreshold(1500)",
            " \t\t\t// The callback function should directly be passed to sctp",
            " \t\t\tdc.OnBufferedAmountLow(func() {",
            " \t\t\t\tnCbs++",
            " \t\t\t})",
            " ",
            " \t\t\tfor i := 0; i < 10; i++ {",
            "-\t\t\t\te := dc.Send(buf)",
            "-\t\t\t\tif e != nil {",
            "-\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, dc.Send(buf), \"Failed to send string on data channel\")",
            " \t\t\t\tassert.Equal(t, uint64(1500), dc.BufferedAmountLowThreshold(), \"value mismatch\")",
            " \t\t\t\t// assert.Equal(t, (i+1)*len(buf), int(dc.BufferedAmount()), \"unexpected bufferedAmount\")",
            " \t\t\t}",
            " \t\t})",
            " ",
            " \t\tdc.OnMessage(func(DataChannelMessage) {",
            " \t\t})",
            " ",
            "-\t\terr = signalPair(offerPC, answerPC)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, signalPair(offerPC, answerPC))",
            " ",
            " \t\tclosePair(t, offerPC, answerPC, done)",
            " ",
            " \t\tassert.True(t, nCbs > 0, \"callback should be made at least once\")",
            " \t})",
            " }",
            " ",
            "@@ -375,38 +351,31 @@",
            " \t\ts := SettingEngine{}",
            " \t\ts.DetachDataChannels()",
            " \t\tapi := NewAPI(WithSettingEngine(s))",
            " ",
            " \t\t// Set up two peer connections.",
            " \t\tconfig := Configuration{}",
            " \t\tpca, err := api.NewPeerConnection(config)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " \t\tpcb, err := api.NewPeerConnection(config)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdefer closePairNow(t, pca, pcb)",
            " ",
            " \t\tvar wg sync.WaitGroup",
            " ",
            " \t\tdcChan := make(chan datachannel.ReadWriteCloser)",
            " \t\tpcb.OnDataChannel(func(dc *DataChannel) {",
            " \t\t\tif dc.Label() != label {",
            " \t\t\t\treturn",
            " \t\t\t}",
            " \t\t\tlog.Debug(\"OnDataChannel was called\")",
            " \t\t\tdc.OnOpen(func() {",
            " \t\t\t\tdetached, err2 := dc.Detach()",
            "-\t\t\t\tif err2 != nil {",
            "-\t\t\t\t\tlog.Debugf(\"Detach failed: %s\", err2.Error())",
            "-\t\t\t\t\tt.Error(err2)",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, err2, \"Detach failed\")",
            " ",
            " \t\t\t\tdcChan <- detached",
            " \t\t\t})",
            " \t\t})",
            " ",
            " \t\twg.Add(1)",
            " \t\tgo func() {",
            "@@ -418,54 +387,41 @@",
            " \t\t\tdc := <-dcChan",
            " \t\t\tlog.Debug(\"data channel opened\")",
            " \t\t\tdefer func() { assert.NoError(t, dc.Close(), \"should succeed\") }()",
            " ",
            " \t\t\tlog.Debug(\"Waiting for ping...\")",
            " \t\t\tmsg, err2 := io.ReadAll(dc)",
            " \t\t\tlog.Debugf(\"Received ping! \\\"%s\\\"\", string(msg))",
            "-\t\t\tif err2 != nil {",
            "-\t\t\t\tt.Error(err2)",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, err2)",
            " ",
            "-\t\t\tif !bytes.Equal(msg, testData) {",
            "-\t\t\t\tt.Errorf(\"expected %q, got %q\", string(msg), string(testData))",
            "-\t\t\t} else {",
            "-\t\t\t\tlog.Debug(\"Received ping successfully!\")",
            "-\t\t\t}",
            "+\t\t\tassert.Equal(t, testData, msg)",
            " \t\t}()",
            " ",
            "-\t\tif err = signalPair(pca, pcb); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, signalPair(pca, pcb))",
            " ",
            " \t\tattached, err := pca.CreateDataChannel(label, nil)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " \t\tlog.Debug(\"Waiting for data channel to open\")",
            " \t\topen := make(chan struct{})",
            " \t\tattached.OnOpen(func() {",
            " \t\t\topen <- struct{}{}",
            " \t\t})",
            " \t\t<-open",
            " \t\tlog.Debug(\"data channel opened\")",
            " ",
            " \t\tvar dc io.ReadWriteCloser",
            " \t\tdc, err = attached.Detach()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\twg.Add(1)",
            " \t\tgo func() {",
            " \t\t\tdefer wg.Done()",
            " \t\t\tlog.Debug(\"Sending ping...\")",
            "-\t\t\tif _, err2 := dc.Write(testData); err2 != nil {",
            "-\t\t\t\tt.Error(err2)",
            "-\t\t\t}",
            "+\t\t\t_, err = dc.Write(testData)",
            "+\t\t\tassert.NoError(t, err)",
            " \t\t\tlog.Debug(\"Sent ping\")",
            " ",
            " \t\t\tassert.NoError(t, dc.Close(), \"should succeed\")",
            " ",
            " \t\t\tlog.Debug(\"Wating for EOF\")",
            " \t\t\tret, err2 := io.ReadAll(dc)",
            " \t\t\tassert.Nil(t, err2, \"should succeed\")",
            "@@ -478,21 +434,17 @@",
            " \tt.Run(\"No detach\", func(t *testing.T) {",
            " \t\tlim := test.TimeOut(time.Second * 5)",
            " \t\tdefer lim.Stop()",
            " ",
            " \t\t// Set up two peer connections.",
            " \t\tconfig := Configuration{}",
            " \t\tpca, err := NewPeerConnection(config)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " \t\tpcb, err := NewPeerConnection(config)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdefer closePairNow(t, pca, pcb)",
            " ",
            " \t\tvar dca, dcb *DataChannel",
            " \t\tdcaClosedCh := make(chan struct{})",
            " \t\tdcbClosedCh := make(chan struct{})",
            " ",
            "@@ -515,53 +467,43 @@",
            " \t\t\t\tclose(dcbClosedCh)",
            " \t\t\t})",
            " ",
            " \t\t\t// Register the OnMessage to handle incoming messages",
            " \t\t\tlog.Debug(\"pcb: registering onMessage callback\")",
            " \t\t\tdcb.OnMessage(func(dcMsg DataChannelMessage) {",
            " \t\t\t\tlog.Debugf(\"pcb: received ping: %s\", string(dcMsg.Data))",
            "-\t\t\t\tif !reflect.DeepEqual(dcMsg.Data, testData) {",
            "-\t\t\t\t\tt.Error(\"data mismatch\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.Equal(t, testData, dcMsg.Data)",
            " \t\t\t})",
            " \t\t})",
            " ",
            " \t\tdca, err = pca.CreateDataChannel(label, nil)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdca.OnOpen(func() {",
            " \t\t\tlog.Debug(\"pca: data channel opened\")",
            " \t\t\tlog.Debugf(\"pca: sending \\\"%s\\\"\", string(testData))",
            "-\t\t\tif err := dca.Send(testData); err != nil {",
            "-\t\t\t\tt.Fatal(err)",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, dca.Send(testData))",
            " \t\t\tlog.Debug(\"pca: sent ping\")",
            " \t\t\tassert.NoError(t, dca.Close(), \"should succeed\") // <-- dca closes",
            " \t\t})",
            " ",
            " \t\tdca.OnClose(func() {",
            " \t\t\t// (1)",
            " \t\t\tlog.Debug(\"pca: data channel closed\")",
            " \t\t\tclose(dcaClosedCh)",
            " \t\t})",
            " ",
            " \t\t// Register the OnMessage to handle incoming messages",
            " \t\tlog.Debug(\"pca: registering onMessage callback\")",
            " \t\tdca.OnMessage(func(dcMsg DataChannelMessage) {",
            " \t\t\tlog.Debugf(\"pca: received pong: %s\", string(dcMsg.Data))",
            "-\t\t\tif !reflect.DeepEqual(dcMsg.Data, testData) {",
            "-\t\t\t\tt.Error(\"data mismatch\")",
            "-\t\t\t}",
            "+\t\t\tassert.Equal(t, testData, dcMsg.Data)",
            " \t\t})",
            " ",
            "-\t\tif err := signalPair(pca, pcb); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, signalPair(pca, pcb))",
            " ",
            " \t\t// When dca closes the channel,",
            " \t\t// (1) dca.Onclose() will fire immediately, then",
            " \t\t// (2) dcb.OnClose will also fire",
            " \t\t<-dcaClosedCh // (1)",
            " \t\t<-dcbClosedCh // (2)",
            " \t})",
            "@@ -629,26 +571,24 @@",
            " \t\tdefer report()",
            " ",
            " \t\tdialCalls := make(chan bool, 2)",
            " \t\twg := new(sync.WaitGroup)",
            " \t\twg.Add(2)",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tanswerPC.OnDataChannel(func(d *DataChannel) {",
            " \t\t\tif d.Label() != expectedLabel {",
            " \t\t\t\treturn",
            " \t\t\t}",
            " ",
            " \t\t\td.OnDial(func() {",
            " \t\t\t\t// only dialing side should fire OnDial",
            "-\t\t\t\tt.Fatalf(\"answering side should not call on dial\")",
            "+\t\t\t\tassert.Fail(t, \"answering side should not call on dial\")",
            " \t\t\t})",
            " ",
            " \t\t\td.OnOpen(wg.Done)",
            " \t\t})",
            " ",
            " \t\td, err := offerPC.CreateDataChannel(expectedLabel, nil)",
            " \t\tassert.NoError(t, err)",
            "@@ -668,17 +608,15 @@",
            " \tt.Run(\"handler should be called immediately if already dialed\", func(t *testing.T) {",
            " \t\treport := test.CheckRoutines(t)",
            " \t\tdefer report()",
            " ",
            " \t\tdone := make(chan bool)",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\td, err := offerPC.CreateDataChannel(expectedLabel, nil)",
            " \t\tassert.NoError(t, err)",
            " \t\td.OnOpen(func() {",
            " \t\t\t// when the offer DC has been opened, its guaranteed to have dialed since it has",
            " \t\t\t// received a response to said dial. this test represents an unrealistic usage,",
            " \t\t\t// but its the best way to guarantee we \"missed\" the dial event and still invoke",
            "@@ -699,56 +637,45 @@",
            " \ts := SettingEngine{}",
            " \ts.DetachDataChannels()",
            " \tapi := NewAPI(WithSettingEngine(s))",
            " ",
            " \t// Set up two peer connections.",
            " \tconfig := Configuration{}",
            " \tpca, err := api.NewPeerConnection(config)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \tpcb, err := api.NewPeerConnection(config)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tdefer closePairNow(t, pca, pcb)",
            " ",
            " \tdcChan := make(chan *DataChannel, 1)",
            " \tpcb.OnDataChannel(func(d *DataChannel) {",
            " \t\td.OnOpen(func() {",
            "-\t\t\tif _, detachErr := d.Detach(); detachErr != nil {",
            "-\t\t\t\tt.Error(detachErr)",
            "-\t\t\t}",
            "+\t\t\t_, detachErr := d.Detach()",
            "+\t\t\tassert.NoError(t, detachErr)",
            " ",
            " \t\t\tdcChan <- d",
            " \t\t})",
            " \t})",
            " ",
            "-\tif err = signalPair(pca, pcb); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, signalPair(pca, pcb))",
            " ",
            " \tattached, err := pca.CreateDataChannel(\"\", nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \topen := make(chan struct{}, 1)",
            " \tattached.OnOpen(func() {",
            " \t\topen <- struct{}{}",
            " \t})",
            " \t<-open",
            " ",
            " \td := <-dcChan",
            " \td.sctpTransport.lock.RLock()",
            " \tdefer d.sctpTransport.lock.RUnlock()",
            " \tfor _, dc := range d.sctpTransport.dataChannels[:cap(d.sctpTransport.dataChannels)] {",
            "-\t\tif dc == d {",
            "-\t\t\tt.Errorf(\"expected sctpTransport to drop reference to datachannel\")",
            "-\t\t}",
            "+\t\tassert.NotEqual(t, dc, d, \"expected sctpTransport to drop reference to datachannel\")",
            " \t}",
            " }",
            " ",
            " func TestDataChannelClose(t *testing.T) {",
            " \t// Test if onClose is fired for self and remote after Close is called",
            " \tt.Run(\"close open channels\", func(t *testing.T) {",
            " \t\toptions := &DataChannelInit{}",
            "@@ -796,15 +723,15 @@",
            " \t\t\t// Make sure this is the data channel we were looking for. (Not the one",
            " \t\t\t// created in signalPair).",
            " \t\t\tif dataChannel.Label() != expectedLabel {",
            " \t\t\t\treturn",
            " \t\t\t}",
            " ",
            " \t\t\tdataChannel.OnOpen(func() {",
            "-\t\t\t\tt.Fatal(\"OnOpen must not be fired after we call Close\")",
            "+\t\t\t\tassert.Fail(t, \"OnOpen must not be fired after we call Close\")",
            " \t\t\t})",
            " ",
            " \t\t\tdataChannel.OnClose(func() {",
            " \t\t\t\tdone <- true",
            " \t\t\t})",
            " ",
            " \t\t\tassert.NoError(t, dataChannel.Close())",
            "@@ -847,7 +774,42 @@",
            " \t\tassert.NoError(t, err)",
            " \t\t_, err = dc.Detach()",
            " \t\tassert.ErrorIs(t, err, errDetachBeforeOpened)",
            " \t\tassert.NoError(t, offer.Close())",
            " \t\tassert.NoError(t, answer.Close())",
            " \t})",
            " }",
            "+",
            "+func TestDataChannelMessageSize(t *testing.T) {",
            "+\tofferPC, answerPC, err := newPair()",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tdc, err := offerPC.CreateDataChannel(\"\", nil)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tanswerDataChannelMessages := make(chan []byte)",
            "+\tanswerPC.OnDataChannel(func(d *DataChannel) {",
            "+\t\td.OnMessage(func(m DataChannelMessage) {",
            "+\t\t\tanswerDataChannelMessages <- m.Data",
            "+\t\t})",
            "+\t})",
            "+",
            "+\tassert.NoError(t, signalPair(offerPC, answerPC))",
            "+",
            "+\tmessagesSent, messagesSentCancel := context.WithCancel(context.Background())",
            "+\tdc.OnOpen(func() {",
            "+\t\tfor i := 0; i <= 10; i++ {",
            "+\t\t\toutboundMessage := make([]byte, sctpMaxMessageSizeUnsetValue*i)",
            "+\t\t\t_, err := rand.Read(outboundMessage)",
            "+\t\t\tassert.NoError(t, err)",
            "+",
            "+\t\t\tassert.NoError(t, dc.Send(outboundMessage))",
            "+\t\t\tinboundMessage := <-answerDataChannelMessages",
            "+",
            "+\t\t\tassert.Equal(t, outboundMessage, inboundMessage)",
            "+\t\t}",
            "+\t\tmessagesSentCancel()",
            "+\t})",
            "+",
            "+\t<-messagesSent.Done()",
            "+\tclosePairNow(t, offerPC, answerPC)",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/datachannel_js.go",
          "change": [
            "--- /home/webrtc-4.0.11/datachannel_js.go",
            "+++ /home/webrtc-4.1.3/datachannel_js.go",
            "@@ -44,58 +44,58 @@",
            " // OnOpen sets an event handler which is invoked when",
            " // the underlying data transport has been established (or re-established).",
            " func (d *DataChannel) OnOpen(f func()) {",
            " \tif d.onOpenHandler != nil {",
            " \t\toldHandler := d.onOpenHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonOpenHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonOpenHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo f()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \td.onOpenHandler = &onOpenHandler",
            " \td.underlying.Set(\"onopen\", onOpenHandler)",
            " }",
            " ",
            " // OnClose sets an event handler which is invoked when",
            " // the underlying data transport has been closed.",
            " func (d *DataChannel) OnClose(f func()) {",
            " \tif d.onCloseHandler != nil {",
            " \t\toldHandler := d.onCloseHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonCloseHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonCloseHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo f()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \td.onCloseHandler = &onCloseHandler",
            " \td.underlying.Set(\"onclose\", onCloseHandler)",
            " }",
            " ",
            " // FYI `OnClosing` is not implemented in the non-JS version of Pion.",
            " ",
            " func (d *DataChannel) OnClosing(f func()) {",
            " \tif d.onClosingHandler != nil {",
            " \t\toldHandler := d.onClosingHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonClosingHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonClosingHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo f()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \td.onClosingHandler = &onClosingHandler",
            " \td.underlying.Set(\"onclosing\", onClosingHandler)",
            " }",
            " ",
            " func (d *DataChannel) OnError(f func(err error)) {",
            " \tif d.onErrorHandler != nil {",
            " \t\toldHandler := d.onErrorHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonErrorHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonErrorHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tevent := args[0]",
            " \t\terrorObj := event.Get(\"error\")",
            " \t\t// FYI RTCError has some extra properties, e.g. `errorDetail`:",
            " \t\t// https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/error_event",
            " \t\terrorMessage := errorObj.Get(\"message\").String()",
            " \t\tgo f(errors.New(errorMessage))",
            " \t\treturn js.Undefined()",
            "@@ -107,15 +107,15 @@",
            " // OnMessage sets an event handler which is invoked on a binary message arrival",
            " // from a remote peer. Note that browsers may place limitations on message size.",
            " func (d *DataChannel) OnMessage(f func(msg DataChannelMessage)) {",
            " \tif d.onMessageHandler != nil {",
            " \t\toldHandler := d.onMessageHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonMessageHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonMessageHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\t// pion/webrtc/projects/15",
            " \t\tdata := args[0].Get(\"data\")",
            " \t\tgo func() {",
            " \t\t\t// valueToDataChannelMessage may block when handling 'Blob' data",
            " \t\t\t// so we need to call it from a new routine. See:",
            " \t\t\t// https://pkg.go.dev/syscall/js#FuncOf",
            " \t\t\tmsg := valueToDataChannelMessage(data)",
            "@@ -296,15 +296,15 @@",
            " // the number of bytes of outgoing data becomes lower than or equal to the",
            " // BufferedAmountLowThreshold.",
            " func (d *DataChannel) OnBufferedAmountLow(f func()) {",
            " \tif d.onBufferedAmountLow != nil {",
            " \t\toldHandler := d.onBufferedAmountLow",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonBufferedAmountLow := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonBufferedAmountLow := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo f()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \td.onBufferedAmountLow = &onBufferedAmountLow",
            " \td.underlying.Set(\"onbufferedamountlow\", onBufferedAmountLow)",
            " }",
            " ",
            "@@ -332,15 +332,15 @@",
            " \t\t// to a Uint8Array.",
            " \t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Blob",
            " ",
            " \t\t// The JavaScript API for reading from the Blob is asynchronous. We use a",
            " \t\t// channel to signal when reading is done.",
            " \t\treader := js.Global().Get(\"FileReader\").New()",
            " \t\tdoneChan := make(chan struct{})",
            "-\t\treader.Call(\"addEventListener\", \"loadend\", js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\t\treader.Call(\"addEventListener\", \"loadend\", js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\t\tgo func() {",
            " \t\t\t\t// Signal that the FileReader is done reading/loading by sending through",
            " \t\t\t\t// the doneChan.",
            " \t\t\t\tdoneChan <- struct{}{}",
            " \t\t\t}()",
            " \t\t\treturn js.Undefined()",
            " \t\t}))"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/datachannel_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/datachannel_test.go",
            "+++ /home/webrtc-4.1.3/datachannel_test.go",
            "@@ -3,14 +3,15 @@",
            " ",
            " package webrtc",
            " ",
            " import (",
            " \t\"fmt\"",
            " \t\"io\"",
            " \t\"sync\"",
            "+\t\"sync/atomic\"",
            " \t\"testing\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/transport/v3/test\"",
            " \t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            "@@ -37,47 +38,41 @@",
            " }",
            " ",
            " func closePair(t *testing.T, pc1, pc2 io.Closer, done <-chan bool) {",
            " \tt.Helper()",
            " ",
            " \tselect {",
            " \tcase <-time.After(10 * time.Second):",
            "-\t\tt.Fatalf(\"closePair timed out waiting for done signal\")",
            "+\t\tassert.Fail(t, \"closePair timed out waiting for done signal\")",
            " \tcase <-done:",
            " \t\tclosePairNow(t, pc1, pc2)",
            " \t}",
            " }",
            " ",
            " func setUpDataChannelParametersTest(",
            " \tt *testing.T,",
            " \toptions *DataChannelInit,",
            " ) (*PeerConnection, *PeerConnection, *DataChannel, chan bool) {",
            " \tt.Helper()",
            " ",
            " \tofferPC, answerPC, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \tdone := make(chan bool)",
            " ",
            " \tdc, err := offerPC.CreateDataChannel(expectedLabel, options)",
            "-\tif err != nil {",
            "-\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \treturn offerPC, answerPC, dc, done",
            " }",
            " ",
            " func closeReliabilityParamTest(t *testing.T, pc1, pc2 *PeerConnection, done chan bool) {",
            " \tt.Helper()",
            " ",
            " \terr := signalPair(pc1, pc2)",
            "-\tif err != nil {",
            "-\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tclosePair(t, pc1, pc2, done)",
            " }",
            " ",
            " func BenchmarkDataChannelSend2(b *testing.B)  { benchmarkDataChannelSend(b, 2) }",
            " func BenchmarkDataChannelSend4(b *testing.B)  { benchmarkDataChannelSend(b, 4) }",
            " func BenchmarkDataChannelSend8(b *testing.B)  { benchmarkDataChannelSend(b, 8) }",
            "@@ -130,17 +125,15 @@",
            " \tconst openOnceChannelCapacity = 2",
            " ",
            " \tt.Run(\"handler should be called once\", func(t *testing.T) {",
            " \t\treport := test.CheckRoutines(t)",
            " \t\tdefer report()",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdone := make(chan bool)",
            " \t\topenCalls := make(chan bool, openOnceChannelCapacity)",
            " ",
            " \t\tanswerPC.OnDataChannel(func(d *DataChannel) {",
            " \t\t\tif d.Label() != expectedLabel {",
            " \t\t\t\treturn",
            "@@ -157,35 +150,30 @@",
            " \t\t\t})",
            " \t\t})",
            " ",
            " \t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\tdc.OnOpen(func() {",
            "-\t\t\te := dc.SendText(\"Ping\")",
            "-\t\t\tif e != nil {",
            "-\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, dc.SendText(\"Ping\"), \"Failed to send string on data channel\")",
            " \t\t})",
            " ",
            " \t\tassert.NoError(t, signalPair(offerPC, answerPC))",
            " ",
            " \t\tclosePair(t, offerPC, answerPC, done)",
            " ",
            " \t\tassert.Len(t, openCalls, 1)",
            " \t})",
            " ",
            " \tt.Run(\"handler should be called once when already negotiated\", func(t *testing.T) {",
            " \t\treport := test.CheckRoutines(t)",
            " \t\tdefer report()",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdone := make(chan bool)",
            " \t\tanswerOpenCalls := make(chan bool, openOnceChannelCapacity)",
            " \t\tofferOpenCalls := make(chan bool, openOnceChannelCapacity)",
            " ",
            " \t\tnegotiated := true",
            " \t\tordered := true",
            "@@ -213,18 +201,15 @@",
            " \t\t})",
            " \t\tanswerDC.OnOpen(func() {",
            " \t\t\tanswerOpenCalls <- true",
            " \t\t})",
            " ",
            " \t\tofferDC.OnOpen(func() {",
            " \t\t\tofferOpenCalls <- true",
            "-\t\t\te := offerDC.SendText(\"Ping\")",
            "-\t\t\tif e != nil {",
            "-\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, offerDC.SendText(\"Ping\"), \"Failed to send string on data channel\")",
            " \t\t})",
            " ",
            " \t\tassert.NoError(t, signalPair(offerPC, answerPC))",
            " ",
            " \t\tclosePair(t, offerPC, answerPC, done)",
            " ",
            " \t\tassert.Len(t, answerOpenCalls, 1)",
            "@@ -234,119 +219,95 @@",
            " ",
            " func TestDataChannel_Send(t *testing.T) { //nolint:cyclop",
            " \tt.Run(\"before signaling\", func(t *testing.T) {",
            " \t\treport := test.CheckRoutines(t)",
            " \t\tdefer report()",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdone := make(chan bool)",
            " ",
            " \t\tanswerPC.OnDataChannel(func(d *DataChannel) {",
            " \t\t\t// Make sure this is the data channel we were looking for. (Not the one",
            " \t\t\t// created in signalPair).",
            " \t\t\tif d.Label() != expectedLabel {",
            " \t\t\t\treturn",
            " \t\t\t}",
            " \t\t\td.OnMessage(func(DataChannelMessage) {",
            "-\t\t\t\te := d.Send([]byte(\"Pong\"))",
            "-\t\t\t\tif e != nil {",
            "-\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, d.Send([]byte(\"Pong\")), \"Failed to send string on data channel\")",
            " \t\t\t})",
            " \t\t\tassert.True(t, d.Ordered(), \"Ordered should be set to true\")",
            " \t\t})",
            " ",
            " \t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")",
            " ",
            " \t\tdc.OnOpen(func() {",
            "-\t\t\te := dc.SendText(\"Ping\")",
            "-\t\t\tif e != nil {",
            "-\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, dc.SendText(\"Ping\"), \"Failed to send string on data channel\")",
            " \t\t})",
            " \t\tdc.OnMessage(func(DataChannelMessage) {",
            " \t\t\tdone <- true",
            " \t\t})",
            " ",
            " \t\terr = signalPair(offerPC, answerPC)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing: %+v\", err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tclosePair(t, offerPC, answerPC, done)",
            " \t})",
            " ",
            " \tt.Run(\"after connected\", func(t *testing.T) {",
            " \t\treport := test.CheckRoutines(t)",
            " \t\tdefer report()",
            " ",
            " \t\tofferPC, answerPC, err := newPair()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tdone := make(chan bool)",
            " ",
            " \t\tanswerPC.OnDataChannel(func(d *DataChannel) {",
            " \t\t\t// Make sure this is the data channel we were looking for. (Not the one",
            " \t\t\t// created in signalPair).",
            " \t\t\tif d.Label() != expectedLabel {",
            " \t\t\t\treturn",
            " \t\t\t}",
            " \t\t\td.OnMessage(func(DataChannelMessage) {",
            "-\t\t\t\te := d.Send([]byte(\"Pong\"))",
            "-\t\t\t\tif e != nil {",
            "-\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, d.Send([]byte(\"Pong\")), \"Failed to send string on data channel\")",
            " \t\t\t})",
            " \t\t\tassert.True(t, d.Ordered(), \"Ordered should be set to true\")",
            " \t\t})",
            " ",
            " \t\tonce := &sync.Once{}",
            " \t\tofferPC.OnICEConnectionStateChange(func(state ICEConnectionState) {",
            " \t\t\tif state == ICEConnectionStateConnected || state == ICEConnectionStateCompleted {",
            " \t\t\t\t// wasm fires completed state multiple times",
            " \t\t\t\tonce.Do(func() {",
            " \t\t\t\t\tdc, createErr := offerPC.CreateDataChannel(expectedLabel, nil)",
            "-\t\t\t\t\tif createErr != nil {",
            "-\t\t\t\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")",
            "-\t\t\t\t\t}",
            "+\t\t\t\t\tassert.NoError(t, createErr)",
            " ",
            " \t\t\t\t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")",
            " ",
            " \t\t\t\t\tdc.OnMessage(func(DataChannelMessage) {",
            " \t\t\t\t\t\tdone <- true",
            " \t\t\t\t\t})",
            " ",
            " \t\t\t\t\tif e := dc.SendText(\"Ping\"); e != nil {",
            " \t\t\t\t\t\t// wasm binding doesn't fire OnOpen (we probably already missed it)",
            " \t\t\t\t\t\tdc.OnOpen(func() {",
            "-\t\t\t\t\t\t\te = dc.SendText(\"Ping\")",
            "-\t\t\t\t\t\t\tif e != nil {",
            "-\t\t\t\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")",
            "-\t\t\t\t\t\t\t}",
            "+\t\t\t\t\t\t\tassert.NoError(t, dc.SendText(\"Ping\"), \"Failed to send string on data channel\")",
            " \t\t\t\t\t\t})",
            " \t\t\t\t\t}",
            " \t\t\t\t})",
            " \t\t\t}",
            " \t\t})",
            " ",
            " \t\terr = signalPair(offerPC, answerPC)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tclosePair(t, offerPC, answerPC, done)",
            " \t})",
            " }",
            " ",
            " func TestDataChannel_Close(t *testing.T) {",
            " \treport := test.CheckRoutines(t)",
            "@@ -480,45 +441,37 @@",
            " ",
            " \t\tofferPC, answerPC, offerDatachannel, done := setUpDataChannelParametersTest(t, options)",
            " \t\tanswerDatachannel, err := answerPC.CreateDataChannel(expectedLabel, options)",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\tanswerPC.OnDataChannel(func(d *DataChannel) {",
            " \t\t\t// Ignore our default channel, exists to force ICE candidates. See signalPair for more info",
            "-\t\t\tif d.Label() == \"initial_data_channel\" {",
            "-\t\t\t\treturn",
            "-\t\t\t}",
            "-",
            "-\t\t\tt.Fatal(\"OnDataChannel must not be fired when negotiated == true\")",
            "+\t\t\tassert.Equal(t, \"initial_data_channel\", d.Label(), \"OnDataChannel must not be fired when negotiated == true\")",
            " \t\t})",
            " \t\tofferPC.OnDataChannel(func(*DataChannel) {",
            "-\t\t\tt.Fatal(\"OnDataChannel must not be fired when negotiated == true\")",
            "+\t\t\tassert.Fail(t, \"OnDataChannel must not be fired when negotiated == true\")",
            " \t\t})",
            " ",
            "-\t\tseenAnswerMessage := &atomicBool{}",
            "-\t\tseenOfferMessage := &atomicBool{}",
            "+\t\tseenAnswerMessage := &atomic.Bool{}",
            "+\t\tseenOfferMessage := &atomic.Bool{}",
            " ",
            " \t\tanswerDatachannel.OnMessage(func(msg DataChannelMessage) {",
            " \t\t\tif msg.IsString && string(msg.Data) == expectedMessage {",
            "-\t\t\t\tseenAnswerMessage.set(true)",
            "+\t\t\t\tseenAnswerMessage.Store(true)",
            " \t\t\t}",
            " \t\t})",
            " ",
            " \t\tofferDatachannel.OnMessage(func(msg DataChannelMessage) {",
            " \t\t\tif msg.IsString && string(msg.Data) == expectedMessage {",
            "-\t\t\t\tseenOfferMessage.set(true)",
            "+\t\t\t\tseenOfferMessage.Store(true)",
            " \t\t\t}",
            " \t\t})",
            " ",
            " \t\tgo func() {",
            "-\t\t\tfor {",
            "-\t\t\t\tif seenAnswerMessage.get() && seenOfferMessage.get() {",
            "-\t\t\t\t\tbreak",
            "-\t\t\t\t}",
            "-",
            "+\t\t\tfor seenAnswerMessage.Load() && seenOfferMessage.Load() {",
            " \t\t\t\tif offerDatachannel.ReadyState() == DataChannelStateOpen {",
            " \t\t\t\t\tassert.NoError(t, offerDatachannel.SendText(expectedMessage))",
            " \t\t\t\t}",
            " \t\t\t\tif answerDatachannel.ReadyState() == DataChannelStateOpen {",
            " \t\t\t\t\tassert.NoError(t, answerDatachannel.SendText(expectedMessage))",
            " \t\t\t\t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/dtlsrole_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/dtlsrole_test.go",
            "+++ /home/webrtc-4.1.3/dtlsrole_test.go",
            "@@ -30,17 +30,15 @@",
            " \t\t)",
            " \t}",
            " }",
            " ",
            " func TestDTLSRoleFromRemoteSDP(t *testing.T) {",
            " \tparseSDP := func(raw string) *sdp.SessionDescription {",
            " \t\tparsed := &sdp.SessionDescription{}",
            "-\t\tif err := parsed.Unmarshal([]byte(raw)); err != nil {",
            "-\t\t\tpanic(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, parsed.Unmarshal([]byte(raw)))",
            " ",
            " \t\treturn parsed",
            " \t}",
            " ",
            " \tconst noMedia = `v=0",
            " o=- 4596489990601351948 2 IN IP4 127.0.0.1",
            " s=-"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/dtlstransport_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/dtlstransport_test.go",
            "+++ /home/webrtc-4.1.3/dtlstransport_test.go",
            "@@ -20,119 +20,94 @@",
            " \tlim := test.TimeOut(time.Second * 5)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tpcAnswer, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tpcAnswer.OnDataChannel(func(_ *DataChannel) {",
            "-\t\tt.Fatal(\"A DataChannel must not be created when Fingerprint verification fails\")",
            "+\t\tassert.Fail(t, \"A DataChannel must not be created when Fingerprint verification fails\")",
            " \t})",
            " ",
            " \tdefer closePairNow(t, pcOffer, pcAnswer)",
            " ",
            " \tofferChan := make(chan SessionDescription)",
            " \tpcOffer.OnICECandidate(func(candidate *ICECandidate) {",
            " \t\tif candidate == nil {",
            " \t\t\tofferChan <- *pcOffer.PendingLocalDescription()",
            " \t\t}",
            " \t})",
            " ",
            " \tofferConnectionHasClosed := untilConnectionState(PeerConnectionStateClosed, pcOffer)",
            " \tanswerConnectionHasClosed := untilConnectionState(PeerConnectionStateClosed, pcAnswer)",
            " ",
            "-\tif _, err = pcOffer.CreateDataChannel(\"unusedDataChannel\", nil); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\t_, err = pcOffer.CreateDataChannel(\"unusedDataChannel\", nil)",
            "+\tassert.NoError(t, err)",
            " ",
            " \toffer, err := pcOffer.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t} else if err := pcOffer.SetLocalDescription(offer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            " ",
            " \tselect {",
            " \tcase offer := <-offerChan:",
            " \t\t// Replace with invalid fingerprint",
            " \t\tre := regexp.MustCompile(`sha-256 (.*?)\\r`)",
            " \t\toffer.SDP = re.ReplaceAllString(",
            " \t\t\toffer.SDP,",
            " \t\t\t\"sha-256 AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA\\r\",",
            " \t\t)",
            " ",
            "-\t\tif err := pcAnswer.SetRemoteDescription(offer); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))",
            " ",
            " \t\tanswer, err := pcAnswer.CreateAnswer(nil)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "-",
            "-\t\tif err = pcAnswer.SetLocalDescription(answer); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            "+\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))",
            " ",
            " \t\tanswer.SDP = re.ReplaceAllString(",
            " \t\t\tanswer.SDP,",
            " \t\t\t\"sha-256 AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA\\r\",",
            " \t\t)",
            " ",
            "-\t\terr = pcOffer.SetRemoteDescription(answer)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, pcOffer.SetRemoteDescription(answer))",
            " \tcase <-time.After(5 * time.Second):",
            "-\t\tt.Fatal(\"timed out waiting to receive offer\")",
            "+\t\tassert.Fail(t, \"timed out waiting to receive offer\")",
            " \t}",
            " ",
            " \tofferConnectionHasClosed.Wait()",
            " \tanswerConnectionHasClosed.Wait()",
            " ",
            "-\tif pcOffer.SCTP().Transport().State() != DTLSTransportStateClosed &&",
            "-\t\tpcOffer.SCTP().Transport().State() != DTLSTransportStateFailed {",
            "-\t\tt.Fail()",
            "-\t}",
            "+\tassert.Contains(",
            "+\t\tt, []DTLSTransportState{DTLSTransportStateClosed, DTLSTransportStateFailed}, pcOffer.SCTP().Transport().State(),",
            "+\t\t\"DTLS Transport should be closed or failed\",",
            "+\t)",
            " \tassert.Nil(t, pcOffer.SCTP().Transport().conn)",
            " ",
            "-\tif pcAnswer.SCTP().Transport().State() != DTLSTransportStateClosed &&",
            "-\t\tpcAnswer.SCTP().Transport().State() != DTLSTransportStateFailed {",
            "-\t\tt.Fail()",
            "-\t}",
            "+\tassert.Contains(",
            "+\t\tt, []DTLSTransportState{DTLSTransportStateClosed, DTLSTransportStateFailed}, pcAnswer.SCTP().Transport().State(),",
            "+\t\t\"DTLS Transport should be closed or failed\",",
            "+\t)",
            " \tassert.Nil(t, pcAnswer.SCTP().Transport().conn)",
            " }",
            " ",
            " func TestPeerConnection_DTLSRoleSettingEngine(t *testing.T) {",
            " \trunTest := func(r DTLSRole) {",
            " \t\ts := SettingEngine{}",
            " \t\tassert.NoError(t, s.SetAnsweringDTLSRole(r))",
            " ",
            " \t\tofferPC, err := NewAPI(WithSettingEngine(s)).NewPeerConnection(Configuration{})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tanswerPC, err := NewAPI(WithSettingEngine(s)).NewPeerConnection(Configuration{})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "-",
            "-\t\tif err = signalPair(offerPC, answerPC); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            "+\t\tassert.NoError(t, signalPair(offerPC, answerPC))",
            " ",
            " \t\tconnectionComplete := untilConnectionState(PeerConnectionStateConnected, answerPC)",
            " \t\tconnectionComplete.Wait()",
            " \t\tclosePairNow(t, offerPC, answerPC)",
            " \t}",
            " ",
            " \treport := test.CheckRoutines(t)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/e2e/e2e_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/e2e/e2e_test.go",
            "+++ /home/webrtc-4.1.3/e2e/e2e_test.go",
            "@@ -91,15 +91,15 @@",
            " \t\t\tanswerBytes, errAnsSDP := json.Marshal(answer)",
            " \t\t\tif errAnsSDP != nil {",
            " \t\t\t\tt.Fatalf(\"Failed to marshal SDP: %v\", errAnsSDP)",
            " \t\t\t}",
            " \t\t\tvar result string",
            " \t\t\tif err := page.RunScript(",
            " \t\t\t\t\"pc.setRemoteDescription(JSON.parse(answer))\",",
            "-\t\t\t\tmap[string]interface{}{\"answer\": string(answerBytes)},",
            "+\t\t\t\tmap[string]any{\"answer\": string(answerBytes)},",
            " \t\t\t\t&result,",
            " \t\t\t); err != nil {",
            " \t\t\t\tt.Fatalf(\"Failed to run script to set SDP: %v\", err)",
            " \t\t\t}",
            " ",
            " \t\t\tgo func() {",
            " \t\t\t\tfor {",
            "@@ -231,15 +231,15 @@",
            " \t\t\tanswerBytes, errAnsSDP := json.Marshal(answer)",
            " \t\t\tif errAnsSDP != nil {",
            " \t\t\t\tt.Fatalf(\"Failed to marshal SDP: %v\", errAnsSDP)",
            " \t\t\t}",
            " \t\t\tvar result string",
            " \t\t\tif err := page.RunScript(",
            " \t\t\t\t\"pc.setRemoteDescription(JSON.parse(answer))\",",
            "-\t\t\t\tmap[string]interface{}{\"answer\": string(answerBytes)},",
            "+\t\t\t\tmap[string]any{\"answer\": string(answerBytes)},",
            " \t\t\t\t&result,",
            " \t\t\t); err != nil {",
            " \t\t\t\tt.Fatalf(\"Failed to run script to set SDP: %v\", err)",
            " \t\t\t}",
            " ",
            " \t\t\tselect {",
            " \t\t\tcase <-chStarted:"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/errors.go",
          "change": [
            "--- /home/webrtc-4.0.11/errors.go",
            "+++ /home/webrtc-4.1.3/errors.go",
            "@@ -145,14 +145,17 @@",
            " \t// ErrUnsupportedCodec indicates the remote peer doesn't support the requested codec.",
            " \tErrUnsupportedCodec = errors.New(\"unable to start track, codec is not supported by remote\")",
            " ",
            " \t// ErrSenderWithNoCodecs indicates that a RTPSender was created without any codecs. To send media the MediaEngine",
            " \t//  needs at least one configured codec.",
            " \tErrSenderWithNoCodecs = errors.New(\"unable to populate media section, RTPSender created with no codecs\")",
            " ",
            "+\t// ErrCodecAlreadyRegistered indicates that a codec has already been registered for the same payload type.",
            "+\tErrCodecAlreadyRegistered = errors.New(\"codec already registered for same payload type\")",
            "+",
            " \t// ErrRTPSenderNewTrackHasIncorrectKind indicates that the new track is of a different kind than the previous/original.",
            " \tErrRTPSenderNewTrackHasIncorrectKind = errors.New(\"new track must be of the same kind as previous\")",
            " ",
            " \t// ErrRTPSenderNewTrackHasIncorrectEnvelope indicates that the new track has a different envelope",
            " \t//  than the previous/original.",
            " \tErrRTPSenderNewTrackHasIncorrectEnvelope = errors.New(\"new track must have the same envelope as previous\")",
            " ",
            "@@ -204,15 +207,15 @@",
            " \terrPeerConnStateChangeInvalid                     = errors.New(\"invalid state change op\")",
            " \terrPeerConnStateChangeUnhandled                   = errors.New(\"unhandled state change op\")",
            " \terrPeerConnSDPTypeInvalidValueSetLocalDescription = errors.New(\"invalid SDP type supplied to SetLocalDescription()\")",
            " \terrPeerConnRemoteDescriptionWithoutMidValue       = errors.New(",
            " \t\t\"remoteDescription contained media section without mid value\",",
            " \t)",
            " \terrPeerConnRemoteDescriptionNil                  = errors.New(\"remoteDescription has not been set yet\")",
            "-\terrPeerConnSingleMediaSectionHasExplicitSSRC     = errors.New(\"single media section has an explicit SSRC\")",
            "+\terrMediaSectionHasExplictSSRCAttribute           = errors.New(\"media section has an explicit SSRC\")",
            " \terrPeerConnRemoteSSRCAddTransceiver              = errors.New(\"could not add transceiver for remote SSRC\")",
            " \terrPeerConnSimulcastMidRTPExtensionRequired      = errors.New(\"mid RTP Extensions required for Simulcast\")",
            " \terrPeerConnSimulcastStreamIDRTPExtensionRequired = errors.New(\"stream id RTP Extensions required for Simulcast\")",
            " \terrPeerConnSimulcastIncomingSSRCFailed           = errors.New(\"incoming SSRC failed Simulcast probing\")",
            " \terrPeerConnAddTransceiverFromKindOnlyAcceptsOne  = errors.New(",
            " \t\t\"AddTransceiverFromKind only accepts one RTPTransceiverInit\",",
            " \t)",
            "@@ -241,15 +244,15 @@",
            " \terrRTPSenderTrackRemoved         = errors.New(\"Sender Track has been removed or replaced to nil\")",
            " \terrRTPSenderRidNil               = errors.New(\"Sender cannot add encoding as rid is empty\")",
            " \terrRTPSenderNoBaseEncoding       = errors.New(\"Sender cannot add encoding as there is no base track\")",
            " \terrRTPSenderBaseEncodingMismatch = errors.New(\"Sender cannot add encoding as provided track does not match base track\")",
            " \terrRTPSenderRIDCollision         = errors.New(\"Sender cannot encoding due to RID collision\")",
            " \terrRTPSenderNoTrackForRID        = errors.New(\"Sender does not have track for RID\")",
            " ",
            "-\terrRTPTransceiverCannotChangeMid        = errors.New(\"errRTPSenderTrackNil\")",
            "+\terrRTPTransceiverCannotChangeMid        = errors.New(\"cannot change transceiver mid\")",
            " \terrRTPTransceiverSetSendingInvalidState = errors.New(\"invalid state change in RTPTransceiver.setSending\")",
            " \terrRTPTransceiverCodecUnsupported       = errors.New(\"unsupported codec type by this transceiver\")",
            " ",
            " \terrSCTPTransportDTLS = errors.New(\"DTLS not established\")",
            " ",
            " \terrSDPZeroTransceivers                 = errors.New(\"addTransceiverSDP() called with 0 transceivers\")",
            " \terrSDPMediaSectionMediaDataChanInvalid = errors.New(\"invalid Media Section. Media + DataChannel both enabled\")",
            "@@ -268,13 +271,15 @@",
            " ",
            " \terrInvalidICECredentialTypeString = errors.New(\"invalid ICECredentialType\")",
            " \terrInvalidICEServer               = errors.New(\"invalid ICEServer\")",
            " ",
            " \terrICETransportNotInNew = errors.New(\"ICETransport can only be called in ICETransportStateNew\")",
            " \terrICETransportClosed   = errors.New(\"ICETransport closed\")",
            " ",
            "-\terrCertificatePEMFormatError = errors.New(\"bad Certificate PEM format\")",
            "+\terrCertificatePEMMultipleCert = errors.New(\"failed parsing certificate, more than 1 CERTIFICATE block in pems\")",
            "+\terrCertificatePEMMultiplePriv = errors.New(\"failed parsing certificate, more than 1 PRIVATE KEY block in pems\")",
            "+\terrCertificatePEMMissing      = errors.New(\"failed parsing certificate, pems must contain both a CERTIFICATE block and a PRIVATE KEY block\") // nolint: lll",
            " ",
            " \terrRTPTooShort = errors.New(\"not long enough to be a RTP Packet\")",
            " ",
            " \terrExcessiveRetries = errors.New(\"excessive retries in CreateOffer\")",
            " )"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/examples/custom-logger/main.go",
          "change": [
            "--- /home/webrtc-4.0.11/examples/custom-logger/main.go",
            "+++ /home/webrtc-4.1.3/examples/custom-logger/main.go",
            "@@ -19,31 +19,31 @@",
            " ",
            " // customLogger satisfies the interface logging.LeveledLogger",
            " // a logger is created per subsystem in Pion, so you can have custom",
            " // behavior per subsystem (ICE, DTLS, SCTP...)",
            " type customLogger struct{}",
            " ",
            " // Print all messages except trace.",
            "-func (c customLogger) Trace(string)                  {}",
            "-func (c customLogger) Tracef(string, ...interface{}) {}",
            "+func (c customLogger) Trace(string)          {}",
            "+func (c customLogger) Tracef(string, ...any) {}",
            " ",
            " func (c customLogger) Debug(msg string) { fmt.Printf(\"customLogger Debug: %s\\n\", msg) }",
            "-func (c customLogger) Debugf(format string, args ...interface{}) {",
            "+func (c customLogger) Debugf(format string, args ...any) {",
            " \tc.Debug(fmt.Sprintf(format, args...))",
            " }",
            " func (c customLogger) Info(msg string) { fmt.Printf(\"customLogger Info: %s\\n\", msg) }",
            "-func (c customLogger) Infof(format string, args ...interface{}) {",
            "+func (c customLogger) Infof(format string, args ...any) {",
            " \tc.Trace(fmt.Sprintf(format, args...))",
            " }",
            " func (c customLogger) Warn(msg string) { fmt.Printf(\"customLogger Warn: %s\\n\", msg) }",
            "-func (c customLogger) Warnf(format string, args ...interface{}) {",
            "+func (c customLogger) Warnf(format string, args ...any) {",
            " \tc.Warn(fmt.Sprintf(format, args...))",
            " }",
            " func (c customLogger) Error(msg string) { fmt.Printf(\"customLogger Error: %s\\n\", msg) }",
            "-func (c customLogger) Errorf(format string, args ...interface{}) {",
            "+func (c customLogger) Errorf(format string, args ...any) {",
            " \tc.Error(fmt.Sprintf(format, args...))",
            " }",
            " ",
            " // customLoggerFactory satisfies the interface logging.LoggerFactory",
            " // This allows us to create different loggers per subsystem. So we can",
            " // add custom behavior.",
            " type customLoggerFactory struct{}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/examples/data-channels/jsfiddle/main.go",
          "change": [
            "--- /home/webrtc-4.0.11/examples/data-channels/jsfiddle/main.go",
            "+++ /home/webrtc-4.1.3/examples/data-channels/jsfiddle/main.go",
            "@@ -78,29 +78,29 @@",
            " \t\t\tencodedDescr := encode(pc.LocalDescription())",
            " \t\t\tel := getElementByID(\"localSessionDescription\")",
            " \t\t\tel.Set(\"value\", encodedDescr)",
            " \t\t}",
            " \t})",
            " ",
            " \t// Set up global callbacks which will be triggered on button clicks.",
            "-\tjs.Global().Set(\"sendMessage\", js.FuncOf(func(_ js.Value, _ []js.Value) interface{} {",
            "+\tjs.Global().Set(\"sendMessage\", js.FuncOf(func(_ js.Value, _ []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\tel := getElementByID(\"message\")",
            " \t\t\tmessage := el.Get(\"value\").String()",
            " \t\t\tif message == \"\" {",
            " \t\t\t\tjs.Global().Call(\"alert\", \"Message must not be empty\")",
            " \t\t\t\treturn",
            " \t\t\t}",
            " \t\t\tif err := sendChannel.SendText(message); err != nil {",
            " \t\t\t\thandleError(err)",
            " \t\t\t}",
            " \t\t}()",
            " \t\treturn js.Undefined()",
            " \t}))",
            "-\tjs.Global().Set(\"startSession\", js.FuncOf(func(_ js.Value, _ []js.Value) interface{} {",
            "+\tjs.Global().Set(\"startSession\", js.FuncOf(func(_ js.Value, _ []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\tel := getElementByID(\"remoteSessionDescription\")",
            " \t\t\tsd := el.Get(\"value\").String()",
            " \t\t\tif sd == \"\" {",
            " \t\t\t\tjs.Global().Call(\"alert\", \"Session Description must not be empty\")",
            " \t\t\t\treturn",
            " \t\t\t}",
            "@@ -109,15 +109,15 @@",
            " \t\t\tdecode(sd, &descr)",
            " \t\t\tif err := pc.SetRemoteDescription(descr); err != nil {",
            " \t\t\t\thandleError(err)",
            " \t\t\t}",
            " \t\t}()",
            " \t\treturn js.Undefined()",
            " \t}))",
            "-\tjs.Global().Set(\"copySDP\", js.FuncOf(func(_ js.Value, _ []js.Value) interface{} {",
            "+\tjs.Global().Set(\"copySDP\", js.FuncOf(func(_ js.Value, _ []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\tdefer func() {",
            " \t\t\t\tif e := recover(); e != nil {",
            " \t\t\t\t\tswitch e := e.(type) {",
            " \t\t\t\t\tcase error:",
            " \t\t\t\t\t\thandleError(e)",
            " \t\t\t\t\tdefault:"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/examples/data-channels-detach/jsfiddle/main.go",
          "change": [
            "--- /home/webrtc-4.0.11/examples/data-channels-detach/jsfiddle/main.go",
            "+++ /home/webrtc-4.1.3/examples/data-channels-detach/jsfiddle/main.go",
            "@@ -103,29 +103,29 @@",
            " \t\t\tencodedDescr := encode(peerConnection.LocalDescription())",
            " \t\t\tel := getElementByID(\"localSessionDescription\")",
            " \t\t\tel.Set(\"value\", encodedDescr)",
            " \t\t}",
            " \t})",
            " ",
            " \t// Set up global callbacks which will be triggered on button clicks.",
            "-\t/*js.Global().Set(\"sendMessage\", js.FuncOf(func(_ js.Value, _ []js.Value) interface{} {",
            "+\t/*js.Global().Set(\"sendMessage\", js.FuncOf(func(_ js.Value, _ []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\tel := getElementByID(\"message\")",
            " \t\t\tmessage := el.Get(\"value\").String()",
            " \t\t\tif message == \"\" {",
            " \t\t\t\tjs.Global().Call(\"alert\", \"Message must not be empty\")",
            " \t\t\t\treturn",
            " \t\t\t}",
            " \t\t\tif err := sendChannel.SendText(message); err != nil {",
            " \t\t\t\thandleError(err)",
            " \t\t\t}",
            " \t\t}()",
            " \t\treturn js.Undefined()",
            " \t}))*/",
            "-\tjs.Global().Set(\"startSession\", js.FuncOf(func(_ js.Value, _ []js.Value) interface{} {",
            "+\tjs.Global().Set(\"startSession\", js.FuncOf(func(_ js.Value, _ []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\tel := getElementByID(\"remoteSessionDescription\")",
            " \t\t\tsd := el.Get(\"value\").String()",
            " \t\t\tif sd == \"\" {",
            " \t\t\t\tjs.Global().Call(\"alert\", \"Session Description must not be empty\")",
            " \t\t\t\treturn",
            " \t\t\t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/examples/play-from-disk-renegotiation/main.go",
          "change": [
            "--- /home/webrtc-4.0.11/examples/play-from-disk-renegotiation/main.go",
            "+++ /home/webrtc-4.1.3/examples/play-from-disk-renegotiation/main.go",
            "@@ -67,17 +67,40 @@",
            " \t}",
            " ",
            " \tdoSignaling(res, req)",
            " \tfmt.Println(\"PeerConnection has been created\")",
            " }",
            " ",
            " // Add a single video track.",
            "-func addVideo(res http.ResponseWriter, req *http.Request) {",
            "+func addVideo(res http.ResponseWriter, req *http.Request) { //nolint:cyclop",
            "+\t// Open a IVF file and start reading using our IVFReader",
            "+\tfile, err := os.Open(\"output.ivf\")",
            "+\tif err != nil {",
            "+\t\tpanic(err)",
            "+\t}",
            "+",
            "+\tivf, header, err := ivfreader.NewWith(file)",
            "+\tif err != nil {",
            "+\t\tpanic(err)",
            "+\t}",
            "+",
            "+\tvar mimeType string",
            "+\tswitch header.FourCC {",
            "+\tcase \"VP80\":",
            "+\t\tmimeType = webrtc.MimeTypeVP8",
            "+\tcase \"VP90\":",
            "+\t\tmimeType = webrtc.MimeTypeVP9",
            "+\tcase \"AV01\":",
            "+\t\tmimeType = webrtc.MimeTypeAV1",
            "+\tdefault:",
            "+\t\tpanic(fmt.Sprintf(\"unsupported codec: %s\", header.FourCC))",
            "+\t}",
            "+",
            " \tvideoTrack, err := webrtc.NewTrackLocalStaticSample(",
            "-\t\twebrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeVP8},",
            "+\t\twebrtc.RTPCodecCapability{MimeType: mimeType},",
            " \t\tfmt.Sprintf(\"video-%d\", randutil.NewMathRandomGenerator().Uint32()),",
            " \t\tfmt.Sprintf(\"video-%d\", randutil.NewMathRandomGenerator().Uint32()),",
            " \t)",
            " \tif err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " \trtpSender, err := peerConnection.AddTrack(videoTrack)",
            "@@ -93,17 +116,17 @@",
            " \t\tfor {",
            " \t\t\tif _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {",
            " \t\t\t\treturn",
            " \t\t\t}",
            " \t\t}",
            " \t}()",
            " ",
            "-\tgo writeVideoToTrack(videoTrack)",
            " \tdoSignaling(res, req)",
            " \tfmt.Println(\"Video track has been added\")",
            "+\tgo writeVideoToTrack(ivf, header, videoTrack)",
            " }",
            " ",
            " // Remove a single sender.",
            " func removeVideo(res http.ResponseWriter, req *http.Request) {",
            " \tif senders := peerConnection.GetSenders(); len(senders) != 0 {",
            " \t\tif err := peerConnection.RemoveTrack(senders[0]); err != nil {",
            " \t\t\tpanic(err)",
            "@@ -159,26 +182,17 @@",
            " ",
            " \t// Block forever",
            " \tselect {}",
            " }",
            " ",
            " // Read a video file from disk and write it to a webrtc.Track",
            " // When the video has been completely read this exits without error.",
            "-func writeVideoToTrack(track *webrtc.TrackLocalStaticSample) {",
            "-\t// Open a IVF file and start reading using our IVFReader",
            "-\tfile, err := os.Open(\"output.ivf\")",
            "-\tif err != nil {",
            "-\t\tpanic(err)",
            "-\t}",
            "-",
            "-\tivf, header, err := ivfreader.NewWith(file)",
            "-\tif err != nil {",
            "-\t\tpanic(err)",
            "-\t}",
            "-",
            "+func writeVideoToTrack(",
            "+\tivf *ivfreader.IVFReader, header *ivfreader.IVFFileHeader, track *webrtc.TrackLocalStaticSample,",
            "+) {",
            " \t// Send our video file frame at a time. Pace our sending so we send it at the same speed it should be played back as.",
            " \t// This isn't required since the video is timestamped, but we will such much higher loss if we send all at once.",
            " \t//",
            " \t// It is important to use a time.Ticker instead of time.Sleep because",
            " \t// * avoids accumulating skew, just calling time.Sleep didn't compensate for the time spent parsing the data",
            " \t// * works around latency issues with Sleep (see https://github.com/golang/go/issues/44343)",
            " \tticker := time.NewTicker("
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/examples/save-to-disk-av1/main.go",
          "change": [
            "--- /home/webrtc-4.0.11/examples/save-to-disk-av1/main.go",
            "+++ /home/webrtc-4.1.3/examples/save-to-disk-av1/main.go",
            "@@ -49,16 +49,14 @@",
            " // nolint:cyclop",
            " func main() {",
            " \t// Everything below is the Pion WebRTC API! Thanks for using it ❤️.",
            " ",
            " \t// Create a MediaEngine object to configure the supported codec",
            " \tmediaEngine := &webrtc.MediaEngine{}",
            " ",
            "-\t// Setup the codecs you want to use.",
            "-\t// We'll use a VP8 and Opus but you can also define your own",
            " \tif err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{",
            " \t\tRTPCodecCapability: webrtc.RTPCodecCapability{",
            " \t\t\tMimeType:     webrtc.MimeTypeAV1,",
            " \t\t\tClockRate:    90000,",
            " \t\t\tChannels:     0,",
            " \t\t\tSDPFmtpLine:  \"\",",
            " \t\t\tRTCPFeedback: nil,"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/examples/whip-whep/main.go",
          "change": [
            "--- /home/webrtc-4.0.11/examples/whip-whep/main.go",
            "+++ /home/webrtc-4.1.3/examples/whip-whep/main.go",
            "@@ -11,14 +11,17 @@",
            " import (",
            " \t\"fmt\"",
            " \t\"io\"",
            " \t\"net/http\"",
            " ",
            " \t\"github.com/pion/interceptor\"",
            " \t\"github.com/pion/interceptor/pkg/intervalpli\"",
            "+\t\"github.com/pion/interceptor/pkg/packetdump\"",
            "+\t\"github.com/pion/interceptor/pkg/report\"",
            "+\t\"github.com/pion/rtp\"",
            " \t\"github.com/pion/webrtc/v4\"",
            " )",
            " ",
            " // nolint: gochecknoglobals",
            " var (",
            " \tvideoTrack *webrtc.TrackLocalStaticRTP",
            " ",
            "@@ -45,15 +48,15 @@",
            " \thttp.HandleFunc(\"/whep\", whepHandler)",
            " \thttp.HandleFunc(\"/whip\", whipHandler)",
            " ",
            " \tfmt.Println(\"Open http://localhost:8080 to access this demo\")",
            " \tpanic(http.ListenAndServe(\":8080\", nil)) // nolint: gosec",
            " }",
            " ",
            "-func whipHandler(res http.ResponseWriter, req *http.Request) {",
            "+func whipHandler(res http.ResponseWriter, req *http.Request) { // nolint: cyclop",
            " \t// Read the offer from HTTP Request",
            " \toffer, err := io.ReadAll(req.Body)",
            " \tif err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " ",
            " \t// Create a MediaEngine object to configure the supported codec",
            "@@ -90,56 +93,79 @@",
            " \tif err = webrtc.RegisterDefaultInterceptors(mediaEngine, interceptorRegistry); err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " ",
            " \t// Create the API object with the MediaEngine",
            " \tapi := webrtc.NewAPI(webrtc.WithMediaEngine(mediaEngine), webrtc.WithInterceptorRegistry(interceptorRegistry))",
            " ",
            "-\t// Prepare the configuration",
            "-",
            " \t// Create a new RTCPeerConnection",
            " \tpeerConnection, err := api.NewPeerConnection(peerConnectionConfiguration)",
            " \tif err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " ",
            " \t// Allow us to receive 1 video trac",
            " \tif _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo); err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " ",
            " \t// Set a handler for when a new remote track starts, this handler saves buffers to disk as",
            " \t// an ivf file, since we could have multiple video tracks we provide a counter.",
            " \t// In your application this is where you would handle/process video",
            "-\tpeerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) { //nolint: revive",
            "+\tpeerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {",
            "+\t\tgo func() {",
            "+\t\t\tfor {",
            "+\t\t\t\t_, _, rtcpErr := receiver.ReadRTCP()",
            "+\t\t\t\tif rtcpErr != nil {",
            "+\t\t\t\t\tpanic(rtcpErr)",
            "+\t\t\t\t}",
            "+\t\t\t}",
            "+\t\t}()",
            " \t\tfor {",
            " \t\t\tpkt, _, err := track.ReadRTP()",
            " \t\t\tif err != nil {",
            " \t\t\t\tpanic(err)",
            " \t\t\t}",
            "-",
            " \t\t\tif err = videoTrack.WriteRTP(pkt); err != nil {",
            " \t\t\t\tpanic(err)",
            " \t\t\t}",
            " \t\t}",
            " \t})",
            "-",
            " \t// Send answer via HTTP Response",
            " \twriteAnswer(res, peerConnection, offer, \"/whip\")",
            " }",
            " ",
            " func whepHandler(res http.ResponseWriter, req *http.Request) {",
            " \t// Read the offer from HTTP Request",
            " \toffer, err := io.ReadAll(req.Body)",
            " \tif err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " ",
            "+\tinterceptorRegistry := &interceptor.Registry{}",
            "+\tpacketDump, err := packetdump.NewSenderInterceptor(",
            "+\t\t// filter out all RTP packets, only RTCP packets will be logged",
            "+\t\tpacketdump.RTPFilter(func(_ *rtp.Packet) bool {",
            "+\t\t\treturn false",
            "+\t\t}),",
            "+\t)",
            "+\tif err != nil {",
            "+\t\tpanic(err)",
            "+\t}",
            "+\tinterceptorRegistry.Add(packetDump)",
            "+\tsenderInterceptor, err := report.NewSenderInterceptor()",
            "+\tif err != nil {",
            "+\t\tpanic(err)",
            "+\t}",
            "+\tinterceptorRegistry.Add(senderInterceptor)",
            "+",
            "+\tapi := webrtc.NewAPI(webrtc.WithInterceptorRegistry(interceptorRegistry))",
            "+",
            " \t// Create a new RTCPeerConnection",
            "-\tpeerConnection, err := webrtc.NewPeerConnection(peerConnectionConfiguration)",
            "+\tpeerConnection, err := api.NewPeerConnection(peerConnectionConfiguration)",
            " \tif err != nil {",
            " \t\tpanic(err)",
            " \t}",
            " ",
            " \t// Add Video Track that is being written to from WHIP Session",
            " \trtpSender, err := peerConnection.AddTrack(videoTrack)",
            " \tif err != nil {"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icecandidate.go",
          "change": [
            "--- /home/webrtc-4.0.11/icecandidate.go",
            "+++ /home/webrtc-4.1.3/icecandidate.go",
            "@@ -76,15 +76,16 @@",
            " \t\tnewCandidate.RelatedAddress = candidate.RelatedAddress().Address",
            " \t\tnewCandidate.RelatedPort = uint16(candidate.RelatedAddress().Port) //nolint:gosec // G115",
            " \t}",
            " ",
            " \treturn newCandidate, nil",
            " }",
            " ",
            "-func (c ICECandidate) toICE() (cand ice.Candidate, err error) {",
            "+// ToICE converts ICECandidate to ice.Candidate.",
            "+func (c ICECandidate) ToICE() (cand ice.Candidate, err error) {",
            " \tcandidateID := c.statsID",
            " \tswitch c.Typ {",
            " \tcase ICECandidateTypeHost:",
            " \t\tconfig := ice.CandidateHostConfig{",
            " \t\t\tCandidateID: candidateID,",
            " \t\t\tNetwork:     c.Protocol.String(),",
            " \t\t\tAddress:     c.Address,",
            "@@ -212,28 +213,28 @@",
            " \t\treturn ICECandidateTypeRelay, nil",
            " \tdefault:",
            " \t\treturn ICECandidateType(t), fmt.Errorf(\"%w: %s\", errICECandidateTypeUnknown, t)",
            " \t}",
            " }",
            " ",
            " func (c ICECandidate) String() string {",
            "-\tic, err := c.toICE()",
            "+\tic, err := c.ToICE()",
            " \tif err != nil {",
            " \t\treturn fmt.Sprintf(\"%#v failed to convert to ICE: %s\", c, err)",
            " \t}",
            " ",
            " \treturn ic.String()",
            " }",
            " ",
            " // ToJSON returns an ICECandidateInit",
            " // as indicated by the spec https://w3c.github.io/webrtc-pc/#dom-rtcicecandidate-tojson",
            " func (c ICECandidate) ToJSON() ICECandidateInit {",
            " \tcandidateStr := \"\"",
            " ",
            "-\tcandidate, err := c.toICE()",
            "+\tcandidate, err := c.ToICE()",
            " \tif err == nil {",
            " \t\tcandidateStr = candidate.Marshal()",
            " \t}",
            " ",
            " \treturn ICECandidateInit{",
            " \t\tCandidate:     fmt.Sprintf(\"candidate:%s\", candidateStr),",
            " \t\tSDPMid:        &c.SDPMid,"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icecandidate_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/icecandidate_test.go",
            "+++ /home/webrtc-4.1.3/icecandidate_test.go",
            "@@ -126,48 +126,36 @@",
            " \t\t\t}",
            " \t\t\texpectedICE, err = ice.NewCandidatePeerReflexive(&config)",
            " \t\t}",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\t// first copy the candidate ID so it matches the new one",
            " \t\ttestCase.native.statsID = expectedICE.ID()",
            "-\t\tactualICE, err := testCase.native.toICE()",
            "+\t\tactualICE, err := testCase.native.ToICE()",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\tassert.Equal(t, expectedICE, actualICE, \"testCase: %d ice not equal %v\", i, actualICE)",
            " \t}",
            " }",
            " ",
            " func TestConvertTypeFromICE(t *testing.T) {",
            " \tt.Run(\"host\", func(t *testing.T) {",
            " \t\tct, err := convertTypeFromICE(ice.CandidateTypeHost)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(\"failed coverting ice.CandidateTypeHost\")",
            "-\t\t}",
            "-\t\tif ct != ICECandidateTypeHost {",
            "-\t\t\tt.Fatal(\"should be converted to ICECandidateTypeHost\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"failed coverting ice.CandidateTypeHost\")",
            "+\t\tassert.Equal(t, ICECandidateTypeHost, ct, \"should be converted to ICECandidateTypeHost\")",
            " \t})",
            " \tt.Run(\"srflx\", func(t *testing.T) {",
            " \t\tct, err := convertTypeFromICE(ice.CandidateTypeServerReflexive)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(\"failed coverting ice.CandidateTypeServerReflexive\")",
            "-\t\t}",
            "-\t\tif ct != ICECandidateTypeSrflx {",
            "-\t\t\tt.Fatal(\"should be converted to ICECandidateTypeSrflx\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"failed coverting ice.CandidateTypeServerReflexive\")",
            "+\t\tassert.Equal(t, ICECandidateTypeSrflx, ct, \"should be converted to ICECandidateTypeSrflx\")",
            " \t})",
            " \tt.Run(\"prflx\", func(t *testing.T) {",
            " \t\tct, err := convertTypeFromICE(ice.CandidateTypePeerReflexive)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(\"failed coverting ice.CandidateTypePeerReflexive\")",
            "-\t\t}",
            "-\t\tif ct != ICECandidateTypePrflx {",
            "-\t\t\tt.Fatal(\"should be converted to ICECandidateTypePrflx\")",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"failed coverting ice.CandidateTypePeerReflexive\")",
            "+\t\tassert.Equal(t, ICECandidateTypePrflx, ct, \"should be converted to ICECandidateTypePrflx\")",
            " \t})",
            " }",
            " ",
            " func TestNewIdentifiedICECandidateFromICE(t *testing.T) {",
            " \tconfig := ice.CandidateHostConfig{",
            " \t\tNetwork:    \"udp\",",
            " \t\tAddress:    \"::1\",",
            "@@ -235,14 +223,38 @@",
            " func TestICECandidateZeroSDPid(t *testing.T) {",
            " \tcandidate := ICECandidate{}",
            " ",
            " \tassert.Equal(t, candidate.SDPMid, \"\")",
            " \tassert.Equal(t, candidate.SDPMLineIndex, uint16(0))",
            " }",
            " ",
            "+func TestICECandidateString(t *testing.T) {",
            "+\tcandidate := ICECandidate{",
            "+\t\tFoundation: \"foundation\",",
            "+\t\tPriority:   128,",
            "+\t\tAddress:    \"1.0.0.1\",",
            "+\t\tProtocol:   ICEProtocolUDP,",
            "+\t\tPort:       1234,",
            "+\t\tTyp:        ICECandidateTypeHost,",
            "+\t\tComponent:  1,",
            "+\t}",
            "+\ticeCandidateConfig := ice.CandidateHostConfig{",
            "+\t\tNetwork:    \"udp\",",
            "+\t\tAddress:    \"1.0.0.1\",",
            "+\t\tPort:       1234,",
            "+\t\tComponent:  1,",
            "+\t\tFoundation: \"foundation\",",
            "+\t\tPriority:   128,",
            "+\t}",
            "+\ticeCandidate, err := ice.NewCandidateHost(&iceCandidateConfig)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tassert.Equal(t, candidate.String(), iceCandidate.String())",
            "+}",
            "+",
            " func TestICECandidateSDPMid_ToJSON(t *testing.T) {",
            " \tcandidate := ICECandidate{}",
            " ",
            " \tcandidate.SDPMid = \"0\"",
            " \tcandidate.SDPMLineIndex = 1",
            " ",
            " \tassert.Equal(t, candidate.SDPMid, \"0\")",
            "@@ -344,13 +356,13 @@",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\tcandidateInit := iceCandidate.ToJSON()",
            " ",
            " \t\tassert.Equal(t, sdpMLineIndex, *candidateInit.SDPMLineIndex)",
            " \t\tassert.Equal(t, \"candidate:\"+cand.candidate, candidateInit.Candidate)",
            " ",
            "-\t\ticeBack, err := iceCandidate.toICE()",
            "+\t\ticeBack, err := iceCandidate.ToICE()",
            " ",
            " \t\tassert.NoError(t, err)",
            " \t\tassert.Equal(t, cand.extensions, iceBack.Extensions())",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icecandidateinit_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/icecandidateinit_test.go",
            "+++ /home/webrtc-4.1.3/icecandidateinit_test.go",
            "@@ -24,29 +24,22 @@",
            " \t\t{ICECandidateInit{",
            " \t\t\tCandidate: \"candidate:abc123\",",
            " \t\t}, `{\"candidate\":\"candidate:abc123\",\"sdpMid\":null,\"sdpMLineIndex\":null,\"usernameFragment\":null}`},",
            " \t}",
            " ",
            " \tfor i, tc := range tt {",
            " \t\tb, err := json.Marshal(tc.candidate)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"Failed to marshal %d: %v\", i, err)",
            "-\t\t}",
            "+\t\tassert.NoErrorf(t, err, \"test case %d\", i)",
            " \t\tactualSerialized := string(b)",
            "-\t\tif actualSerialized != tc.serialized {",
            "-\t\t\tt.Errorf(\"%d expected %s got %s\", i, tc.serialized, actualSerialized)",
            "-\t\t}",
            "+\t\tassert.Equalf(t, tc.serialized, actualSerialized, \"test case %d\", i)",
            " ",
            " \t\tvar actual ICECandidateInit",
            " \t\terr = json.Unmarshal(b, &actual)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"Failed to unmarshal %d: %v\", i, err)",
            "-\t\t}",
            "-",
            "-\t\tassert.Equal(t, tc.candidate, actual, \"should match\")",
            "+\t\tassert.NoErrorf(t, err, \"test case %d\", i)",
            "+\t\tassert.Equalf(t, tc.candidate, actual, \"test case %d\", i)",
            " \t}",
            " }",
            " ",
            " func refString(s string) *string {",
            " \treturn &s",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icecandidatetype_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/icecandidatetype_test.go",
            "+++ /home/webrtc-4.1.3/icecandidatetype_test.go",
            "@@ -20,16 +20,18 @@",
            " \t\t{\"srflx\", false, ICECandidateTypeSrflx},",
            " \t\t{\"prflx\", false, ICECandidateTypePrflx},",
            " \t\t{\"relay\", false, ICECandidateTypeRelay},",
            " \t}",
            " ",
            " \tfor i, testCase := range testCases {",
            " \t\tactual, err := NewICECandidateType(testCase.typeString)",
            "-\t\tif (err != nil) != testCase.shouldFail {",
            "-\t\t\tt.Error(err)",
            "+\t\tif testCase.shouldFail {",
            "+\t\t\tassert.Error(t, err, \"testCase: %d %v\", i, testCase)",
            "+\t\t} else {",
            "+\t\t\tassert.NoError(t, err, \"testCase: %d %v\", i, testCase)",
            " \t\t}",
            " \t\tassert.Equal(t,",
            " \t\t\ttestCase.expectedType,",
            " \t\t\tactual,",
            " \t\t\t\"testCase: %d %v\", i, testCase,",
            " \t\t)",
            " \t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icegatherer_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/icegatherer_test.go",
            "+++ /home/webrtc-4.1.3/icegatherer_test.go",
            "@@ -26,53 +26,37 @@",
            " \tdefer report()",
            " ",
            " \topts := ICEGatherOptions{",
            " \t\tICEServers: []ICEServer{{URLs: []string{\"stun:stun.l.google.com:19302\"}}},",
            " \t}",
            " ",
            " \tgatherer, err := NewAPI().NewICEGatherer(opts)",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "-",
            "-\tif gatherer.State() != ICEGathererStateNew {",
            "-\t\tt.Fatalf(\"Expected gathering state new\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.Equal(t, ICEGathererStateNew, gatherer.State())",
            " ",
            " \tgatherFinished := make(chan struct{})",
            " \tgatherer.OnLocalCandidate(func(i *ICECandidate) {",
            " \t\tif i == nil {",
            " \t\t\tclose(gatherFinished)",
            " \t\t}",
            " \t})",
            " ",
            "-\tif err = gatherer.Gather(); err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "+\tassert.NoError(t, gatherer.Gather())",
            " ",
            " \t<-gatherFinished",
            " ",
            " \tparams, err := gatherer.GetLocalParameters()",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif params.UsernameFragment == \"\" ||",
            "-\t\tparams.Password == \"\" {",
            "-\t\tt.Fatalf(\"Empty local username or password frag\")",
            "-\t}",
            "+\tassert.NotEmpty(t, params.UsernameFragment, \"Empty local username frag\")",
            "+\tassert.NotEmpty(t, params.Password, \"Empty local password\")",
            " ",
            " \tcandidates, err := gatherer.GetLocalCandidates()",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "-",
            "-\tif len(candidates) == 0 {",
            "-\t\tt.Fatalf(\"No candidates gathered\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NotEmpty(t, candidates, \"No candidates gathered\")",
            " ",
            " \tassert.NoError(t, gatherer.Close())",
            " }",
            " ",
            " func TestICEGather_mDNSCandidateGathering(t *testing.T) {",
            " \t// Limit runtime in case of deadlocks",
            " \tlim := test.TimeOut(time.Second * 20)",
            "@@ -81,17 +65,15 @@",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \ts := SettingEngine{}",
            " \ts.SetICEMulticastDNSMode(ice.MulticastDNSModeQueryAndGather)",
            " ",
            " \tgatherer, err := NewAPI(WithSettingEngine(s)).NewICEGatherer(ICEGatherOptions{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tgotMulticastDNSCandidate, resolveFunc := context.WithCancel(context.Background())",
            " \tgatherer.OnLocalCandidate(func(c *ICECandidate) {",
            " \t\tif c != nil && strings.HasSuffix(c.Address, \".local\") {",
            " \t\t\tresolveFunc()",
            " \t\t}",
            " \t})",
            "@@ -166,61 +148,45 @@",
            " \tdefer report()",
            " ",
            " \topts := ICEGatherOptions{",
            " \t\tICEServers: []ICEServer{{URLs: []string{\"stun:stun.l.google.com:19302\"}}},",
            " \t}",
            " ",
            " \tgatherer, err := NewAPI().NewICEGatherer(opts)",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \texpectedMid := \"5\"",
            " \texpectedMLineIndex := uint16(1)",
            " ",
            " \tgatherer.setMediaStreamIdentification(expectedMid, expectedMLineIndex)",
            " ",
            "-\tif gatherer.State() != ICEGathererStateNew {",
            "-\t\tt.Fatalf(\"Expected gathering state new\")",
            "-\t}",
            "+\tassert.Equal(t, ICEGathererStateNew, gatherer.State())",
            " ",
            " \tgatherFinished := make(chan struct{})",
            " \tgatherer.OnLocalCandidate(func(i *ICECandidate) {",
            " \t\tif i == nil {",
            " \t\t\tclose(gatherFinished)",
            " \t\t} else {",
            " \t\t\tassert.Equal(t, expectedMid, i.SDPMid)",
            " \t\t\tassert.Equal(t, expectedMLineIndex, i.SDPMLineIndex)",
            " \t\t}",
            " \t})",
            " ",
            "-\tif err = gatherer.Gather(); err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "-",
            "+\tassert.NoError(t, gatherer.Gather())",
            " \t<-gatherFinished",
            " ",
            " \tparams, err := gatherer.GetLocalParameters()",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif params.UsernameFragment == \"\" ||",
            "-\t\tparams.Password == \"\" {",
            "-\t\tt.Fatalf(\"Empty local username or password frag\")",
            "-\t}",
            "+\tassert.NotEmpty(t, params.UsernameFragment, \"Empty local username frag\")",
            "+\tassert.NotEmpty(t, params.Password, \"Empty local password\")",
            " ",
            " \tcandidates, err := gatherer.GetLocalCandidates()",
            "-\tif err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "-",
            "-\tif len(candidates) == 0 {",
            "-\t\tt.Fatalf(\"No candidates gathered\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NotEmpty(t, candidates, \"No candidates gathered\")",
            " ",
            " \tfor _, c := range candidates {",
            " \t\tassert.Equal(t, expectedMid, c.SDPMid)",
            " \t\tassert.Equal(t, expectedMLineIndex, c.SDPMLineIndex)",
            " \t}",
            " ",
            " \tassert.NoError(t, gatherer.Close())"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/iceprotocol_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/iceprotocol_test.go",
            "+++ /home/webrtc-4.1.3/iceprotocol_test.go",
            "@@ -20,16 +20,18 @@",
            " \t\t{\"tcp\", false, ICEProtocolTCP},",
            " \t\t{\"UDP\", false, ICEProtocolUDP},",
            " \t\t{\"TCP\", false, ICEProtocolTCP},",
            " \t}",
            " ",
            " \tfor i, testCase := range testCases {",
            " \t\tactual, err := NewICEProtocol(testCase.protoString)",
            "-\t\tif (err != nil) != testCase.shouldFail {",
            "-\t\t\tt.Error(err)",
            "+\t\tif testCase.shouldFail {",
            "+\t\t\tassert.Error(t, err, \"testCase: %d %v\", i, testCase)",
            "+\t\t} else {",
            "+\t\t\tassert.NoError(t, err, \"testCase: %d %v\", i, testCase)",
            " \t\t}",
            " \t\tassert.Equal(t,",
            " \t\t\ttestCase.expectedProto,",
            " \t\t\tactual,",
            " \t\t\t\"testCase: %d %v\", i, testCase,",
            " \t\t)",
            " \t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/iceserver.go",
          "change": [
            "--- /home/webrtc-4.0.11/iceserver.go",
            "+++ /home/webrtc-4.1.3/iceserver.go",
            "@@ -14,15 +14,15 @@",
            " )",
            " ",
            " // ICEServer describes a single STUN and TURN server that can be used by",
            " // the ICEAgent to establish a connection with a peer.",
            " type ICEServer struct {",
            " \tURLs           []string          `json:\"urls\"`",
            " \tUsername       string            `json:\"username,omitempty\"`",
            "-\tCredential     interface{}       `json:\"credential,omitempty\"`",
            "+\tCredential     any               `json:\"credential,omitempty\"`",
            " \tCredentialType ICECredentialType `json:\"credentialType,omitempty\"`",
            " }",
            " ",
            " func (s ICEServer) parseURL(i int) (*stun.URI, error) {",
            " \treturn stun.ParseURI(s.URLs[i])",
            " }",
            " ",
            "@@ -70,32 +70,32 @@",
            " ",
            " \t\turls = append(urls, url)",
            " \t}",
            " ",
            " \treturn urls, nil",
            " }",
            " ",
            "-func iceserverUnmarshalUrls(val interface{}) (*[]string, error) {",
            "-\ts, ok := val.([]interface{})",
            "+func iceserverUnmarshalUrls(val any) (*[]string, error) {",
            "+\ts, ok := val.([]any)",
            " \tif !ok {",
            " \t\treturn nil, errInvalidICEServer",
            " \t}",
            " \tout := make([]string, len(s))",
            " \tfor idx, url := range s {",
            " \t\tout[idx], ok = url.(string)",
            " \t\tif !ok {",
            " \t\t\treturn nil, errInvalidICEServer",
            " \t\t}",
            " \t}",
            " ",
            " \treturn &out, nil",
            " }",
            " ",
            "-func iceserverUnmarshalOauth(val interface{}) (*OAuthCredential, error) {",
            "-\tc, ok := val.(map[string]interface{})",
            "+func iceserverUnmarshalOauth(val any) (*OAuthCredential, error) {",
            "+\tc, ok := val.(map[string]any)",
            " \tif !ok {",
            " \t\treturn nil, errInvalidICEServer",
            " \t}",
            " \tMACKey, ok := c[\"MACKey\"].(string)",
            " \tif !ok {",
            " \t\treturn nil, errInvalidICEServer",
            " \t}",
            "@@ -106,15 +106,15 @@",
            " ",
            " \treturn &OAuthCredential{",
            " \t\tMACKey:      MACKey,",
            " \t\tAccessToken: AccessToken,",
            " \t}, nil",
            " }",
            " ",
            "-func (s *ICEServer) iceserverUnmarshalFields(fields map[string]interface{}) error { //nolint:cyclop",
            "+func (s *ICEServer) iceserverUnmarshalFields(fields map[string]any) error { //nolint:cyclop",
            " \tif val, ok := fields[\"urls\"]; ok {",
            " \t\tu, err := iceserverUnmarshalUrls(val)",
            " \t\tif err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " \t\ts.URLs = *u",
            " \t} else {",
            "@@ -156,29 +156,29 @@",
            " \t}",
            " ",
            " \treturn nil",
            " }",
            " ",
            " // UnmarshalJSON parses the JSON-encoded data and stores the result.",
            " func (s *ICEServer) UnmarshalJSON(b []byte) error {",
            "-\tvar tmp interface{}",
            "+\tvar tmp any",
            " \terr := json.Unmarshal(b, &tmp)",
            " \tif err != nil {",
            " \t\treturn err",
            " \t}",
            "-\tif m, ok := tmp.(map[string]interface{}); ok {",
            "+\tif m, ok := tmp.(map[string]any); ok {",
            " \t\treturn s.iceserverUnmarshalFields(m)",
            " \t}",
            " ",
            " \treturn errInvalidICEServer",
            " }",
            " ",
            " // MarshalJSON returns the JSON encoding.",
            " func (s ICEServer) MarshalJSON() ([]byte, error) {",
            "-\tm := make(map[string]interface{})",
            "+\tm := make(map[string]any)",
            " \tm[\"urls\"] = s.URLs",
            " \tif s.Username != \"\" {",
            " \t\tm[\"username\"] = s.Username",
            " \t}",
            " \tif s.Credential != nil {",
            " \t\tm[\"credential\"] = s.Credential",
            " \t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/iceserver_js.go",
          "change": [
            "--- /home/webrtc-4.0.11/iceserver_js.go",
            "+++ /home/webrtc-4.1.3/iceserver_js.go",
            "@@ -14,15 +14,15 @@",
            " ",
            " // ICEServer describes a single STUN and TURN server that can be used by",
            " // the ICEAgent to establish a connection with a peer.",
            " type ICEServer struct {",
            " \tURLs     []string",
            " \tUsername string",
            " \t// Note: TURN is not supported in the WASM bindings yet",
            "-\tCredential     interface{}",
            "+\tCredential     any",
            " \tCredentialType ICECredentialType",
            " }",
            " ",
            " func (s ICEServer) parseURL(i int) (*ice.URL, error) {",
            " \treturn ice.ParseURL(s.URLs[i])",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icetransport.go",
          "change": [
            "--- /home/webrtc-4.0.11/icetransport.go",
            "+++ /home/webrtc-4.1.3/icetransport.go",
            "@@ -294,15 +294,15 @@",
            " ",
            " \tagent := t.gatherer.getAgent()",
            " \tif agent == nil {",
            " \t\treturn fmt.Errorf(\"%w: unable to set remote candidates\", errICEAgentNotExist)",
            " \t}",
            " ",
            " \tfor _, c := range remoteCandidates {",
            "-\t\ti, err := c.toICE()",
            "+\t\ti, err := c.ToICE()",
            " \t\tif err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " ",
            " \t\tif err = agent.AddRemoteCandidate(i); err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            "@@ -322,15 +322,15 @@",
            " \t)",
            " ",
            " \tif err = t.ensureGatherer(); err != nil {",
            " \t\treturn err",
            " \t}",
            " ",
            " \tif remoteCandidate != nil {",
            "-\t\tif candidate, err = remoteCandidate.toICE(); err != nil {",
            "+\t\tif candidate, err = remoteCandidate.ToICE(); err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " \t}",
            " ",
            " \tagent := t.gatherer.getAgent()",
            " \tif agent == nil {",
            " \t\treturn fmt.Errorf(\"%w: unable to add remote candidates\", errICEAgentNotExist)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/icetransport_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/icetransport_test.go",
            "+++ /home/webrtc-4.1.3/icetransport_test.go",
            "@@ -78,17 +78,18 @@",
            " \tpcOffer.SCTP().Transport().ICETransport().OnSelectedCandidatePairChange(func(*ICECandidatePair) {",
            " \t\tatomic.StoreInt32(&senderCalledCandidateChange, 1)",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " \t<-iceComplete",
            " ",
            "-\tif atomic.LoadInt32(&senderCalledCandidateChange) == 0 {",
            "-\t\tt.Fatalf(\"Sender ICETransport OnSelectedCandidateChange was never called\")",
            "-\t}",
            "+\tassert.NotEmpty(",
            "+\t\tt, atomic.LoadInt32(&senderCalledCandidateChange),",
            "+\t\t\"Sender ICETransport OnSelectedCandidateChange was never called\",",
            "+\t)",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " func TestICETransport_GetSelectedCandidatePair(t *testing.T) {",
            " \tofferer, answerer, err := newPair()",
            " \tassert.NoError(t, err)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/interceptor.go",
          "change": [
            "--- /home/webrtc-4.0.11/interceptor.go",
            "+++ /home/webrtc-4.1.3/interceptor.go",
            "@@ -6,14 +6,15 @@",
            " ",
            " package webrtc",
            " ",
            " import (",
            " \t\"sync/atomic\"",
            " ",
            " \t\"github.com/pion/interceptor\"",
            "+\t\"github.com/pion/interceptor/pkg/flexfec\"",
            " \t\"github.com/pion/interceptor/pkg/nack\"",
            " \t\"github.com/pion/interceptor/pkg/report\"",
            " \t\"github.com/pion/interceptor/pkg/rfc8888\"",
            " \t\"github.com/pion/interceptor/pkg/twcc\"",
            " \t\"github.com/pion/rtp\"",
            " \t\"github.com/pion/sdp/v3\"",
            " )",
            "@@ -156,14 +157,49 @@",
            " \t}",
            " ",
            " \treturn mediaEngine.RegisterHeaderExtension(",
            " \t\tRTPHeaderExtensionCapability{URI: sdp.SDESRepairRTPStreamIDURI}, RTPCodecTypeVideo,",
            " \t)",
            " }",
            " ",
            "+// ConfigureFlexFEC03 registers flexfec-03 codec with provided payloadType in mediaEngine",
            "+// and adds corresponding interceptor to the registry.",
            "+// Note that this function should be called before any other interceptor that modifies RTP packets",
            "+// (i.e. TWCCHeaderExtensionSender) is added to the registry, so that packets generated by flexfec",
            "+// interceptor are not modified.",
            "+func ConfigureFlexFEC03(",
            "+\tpayloadType PayloadType,",
            "+\tmediaEngine *MediaEngine,",
            "+\tinterceptorRegistry *interceptor.Registry,",
            "+\toptions ...flexfec.FecOption,",
            "+) error {",
            "+\tcodecFEC := RTPCodecParameters{",
            "+\t\tRTPCodecCapability: RTPCodecCapability{",
            "+\t\t\tMimeType:     MimeTypeFlexFEC03,",
            "+\t\t\tClockRate:    90000,",
            "+\t\t\tSDPFmtpLine:  \"repair-window=10000000\",",
            "+\t\t\tRTCPFeedback: nil,",
            "+\t\t},",
            "+\t\tPayloadType: payloadType,",
            "+\t}",
            "+",
            "+\tif err := mediaEngine.RegisterCodec(codecFEC, RTPCodecTypeVideo); err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\tgenerator, err := flexfec.NewFecInterceptor(options...)",
            "+\tif err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\tinterceptorRegistry.Add(generator)",
            "+",
            "+\treturn nil",
            "+}",
            "+",
            " type interceptorToTrackLocalWriter struct{ interceptor atomic.Value } // interceptor.RTPWriter }",
            " ",
            " func (i *interceptorToTrackLocalWriter) WriteRTP(header *rtp.Header, payload []byte) (int, error) {",
            " \tif writer, ok := i.interceptor.Load().(interceptor.RTPWriter); ok && writer != nil {",
            " \t\treturn writer.Write(header, payload, interceptor.Attributes{})",
            " \t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/interceptor_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/interceptor_test.go",
            "+++ /home/webrtc-4.1.3/interceptor_test.go",
            "@@ -5,14 +5,15 @@",
            " // +build !js",
            " ",
            " package webrtc",
            " ",
            " //",
            " import (",
            " \t\"context\"",
            "+\t\"fmt\"",
            " \t\"io\"",
            " \t\"sync/atomic\"",
            " \t\"testing\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/interceptor\"",
            " \tmock_interceptor \"github.com/pion/interceptor/pkg/mock\"",
            "@@ -197,37 +198,29 @@",
            " \t\t}",
            " \t}()",
            " ",
            " \tassert.NoError(t, sender.GracefulClose())",
            " \tassert.NoError(t, receiver.GracefulClose())",
            " ",
            " \t// Bind/UnbindLocal/RemoteStream should be called from one side.",
            "-\tif cnt := atomic.LoadUint32(&cntBindLocalStream); cnt != 1 {",
            "-\t\tt.Errorf(\"BindLocalStreamFn is expected to be called once, but called %d times\", cnt)",
            "-\t}",
            "-\tif cnt := atomic.LoadUint32(&cntUnbindLocalStream); cnt != 1 {",
            "-\t\tt.Errorf(\"UnbindLocalStreamFn is expected to be called once, but called %d times\", cnt)",
            "-\t}",
            "-\tif cnt := atomic.LoadUint32(&cntBindRemoteStream); cnt != 2 {",
            "-\t\tt.Errorf(\"BindRemoteStreamFn is expected to be called once, but called %d times\", cnt)",
            "-\t}",
            "-\tif cnt := atomic.LoadUint32(&cntUnbindRemoteStream); cnt != 2 {",
            "-\t\tt.Errorf(\"UnbindRemoteStreamFn is expected to be called once, but called %d times\", cnt)",
            "-\t}",
            "+\tassert.Equal(t, uint32(1), atomic.LoadUint32(&cntBindLocalStream), \"BindLocalStreamFn is expected to be called once\")",
            "+\tassert.Equal(",
            "+\t\tt, uint32(1), atomic.LoadUint32(&cntUnbindLocalStream), \"UnbindLocalStreamFn is expected to be called once\",",
            "+\t)",
            "+\tassert.Equal(",
            "+\t\tt, uint32(2), atomic.LoadUint32(&cntBindRemoteStream), \"BindRemoteStreamFn is expected to be called twice\",",
            "+\t)",
            "+\tassert.Equal(",
            "+\t\tt, uint32(2), atomic.LoadUint32(&cntUnbindRemoteStream), \"UnbindRemoteStreamFn is expected to be called twice\",",
            "+\t)",
            " ",
            " \t// BindRTCPWriter/Reader and Close should be called from both side.",
            "-\tif cnt := atomic.LoadUint32(&cntBindRTCPWriter); cnt != 2 {",
            "-\t\tt.Errorf(\"BindRTCPWriterFn is expected to be called twice, but called %d times\", cnt)",
            "-\t}",
            "-\tif cnt := atomic.LoadUint32(&cntBindRTCPReader); cnt != 3 {",
            "-\t\tt.Errorf(\"BindRTCPReaderFn is expected to be called twice, but called %d times\", cnt)",
            "-\t}",
            "-\tif cnt := atomic.LoadUint32(&cntClose); cnt != 2 {",
            "-\t\tt.Errorf(\"CloseFn is expected to be called twice, but called %d times\", cnt)",
            "-\t}",
            "+\tassert.Equal(t, uint32(2), atomic.LoadUint32(&cntBindRTCPWriter), \"BindRTCPWriterFn is expected to be called twice\")",
            "+\tassert.Equal(t, uint32(3), atomic.LoadUint32(&cntBindRTCPReader), \"BindRTCPReaderFn is expected to be called thrice\")",
            "+\tassert.Equal(t, uint32(2), atomic.LoadUint32(&cntClose), \"CloseFn is expected to be called twice\")",
            " }",
            " ",
            " func Test_InterceptorRegistry_Build(t *testing.T) {",
            " \tregistryBuildCount := 0",
            " ",
            " \tir := &interceptor.Registry{}",
            " \tir.Add(&mock_interceptor.Factory{",
            "@@ -241,14 +234,76 @@",
            " \tpeerConnectionA, peerConnectionB, err := NewAPI(WithInterceptorRegistry(ir)).newPair(Configuration{})",
            " \tassert.NoError(t, err)",
            " ",
            " \tassert.Equal(t, 2, registryBuildCount)",
            " \tclosePairNow(t, peerConnectionA, peerConnectionB)",
            " }",
            " ",
            "+// TestConfigureFlexFEC03_FECParameters tests only that FEC parameters are correctly set and that SDP contains FEC info.",
            "+// FEC between 2 Pion clients is not currently supported and cannot be negotiated due to the blocking issue:",
            "+// https://github.com/pion/webrtc/issues/3109",
            "+func TestConfigureFlexFEC03_FECParameters(t *testing.T) {",
            "+\tto := test.TimeOut(time.Second * 20)",
            "+\tdefer to.Stop()",
            "+",
            "+\treport := test.CheckRoutines(t)",
            "+\tdefer report()",
            "+",
            "+\tmediaEngine := &MediaEngine{}",
            "+",
            "+\tassert.NoError(t, mediaEngine.RegisterCodec(RTPCodecParameters{",
            "+\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8, ClockRate: 90000},",
            "+\t\tPayloadType:        96,",
            "+\t}, RTPCodecTypeVideo))",
            "+",
            "+\tinterceptorRegistry := &interceptor.Registry{}",
            "+",
            "+\tfecPayloadType := PayloadType(120)",
            "+\tassert.NoError(t, ConfigureFlexFEC03(fecPayloadType, mediaEngine, interceptorRegistry))",
            "+",
            "+\tassert.NoError(t, RegisterDefaultInterceptors(mediaEngine, interceptorRegistry))",
            "+",
            "+\tapi := NewAPI(WithMediaEngine(mediaEngine), WithInterceptorRegistry(interceptorRegistry))",
            "+",
            "+\tpc, err := api.NewPeerConnection(Configuration{})",
            "+\tassert.NoError(t, err)",
            "+\tdefer func() { assert.NoError(t, pc.Close()) }()",
            "+",
            "+\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tsender, err := pc.AddTrack(track)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\toffer, err := pc.CreateOffer(nil)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tassert.Contains(t, offer.SDP, \"a=rtpmap:120 flexfec-03/90000\")",
            "+",
            "+\tassert.NoError(t, pc.SetLocalDescription(offer))",
            "+",
            "+\tparams := sender.GetParameters()",
            "+\tassert.NotZero(t, params.Encodings[0].FEC.SSRC, \"FEC SSRC should be non-zero\")",
            "+",
            "+\texpectedFECGroup := fmt.Sprintf(\"FEC-FR %d %d\", params.Encodings[0].SSRC, params.Encodings[0].FEC.SSRC)",
            "+\tassert.Contains(t, offer.SDP, expectedFECGroup, \"SDP should contain FEC-FR ssrc-group\")",
            "+",
            "+\tvar fecCodecFound bool",
            "+\tfor _, codec := range params.Codecs {",
            "+\t\tif codec.MimeType == MimeTypeFlexFEC03 && codec.PayloadType == fecPayloadType {",
            "+\t\t\tfecCodecFound = true",
            "+\t\t\tassert.Equal(t, uint32(90000), codec.ClockRate)",
            "+\t\t\tassert.Equal(t, \"repair-window=10000000\", codec.SDPFmtpLine)",
            "+",
            "+\t\t\tbreak",
            "+\t\t}",
            "+\t}",
            "+\tassert.True(t, fecCodecFound, \"FlexFEC-03 codec should be registered\")",
            "+}",
            "+",
            " func Test_Interceptor_ZeroSSRC(t *testing.T) {",
            " \tto := test.TimeOut(time.Second * 20)",
            " \tdefer to.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            "@@ -338,14 +393,21 @@",
            " \t\tWithMediaEngine(&mediaEngine),",
            " \t\tWithInterceptorRegistry(&ir),",
            " \t)",
            " ",
            " \tpc1, err := api.NewPeerConnection(Configuration{})",
            " \tassert.NoError(t, err)",
            " ",
            "+\tpc1Connected := make(chan struct{})",
            "+\tpc1.OnConnectionStateChange(func(state PeerConnectionState) {",
            "+\t\tif state == PeerConnectionStateConnected {",
            "+\t\t\tclose(pc1Connected)",
            "+\t\t}",
            "+\t})",
            "+",
            " \ttrack1, err := NewTrackLocalStaticRTP(",
            " \t\tRTPCodecCapability{MimeType: MimeTypeVP8},",
            " \t\t\"video\", \"pion\",",
            " \t)",
            " \tassert.NoError(t, err)",
            " \tsender, err := pc1.AddTrack(track1)",
            " \tassert.NoError(t, err)",
            "@@ -366,14 +428,16 @@",
            " \terr = pc2.SetLocalDescription(answer)",
            " \tassert.NoError(t, err)",
            " \t<-GatheringCompletePromise(pc2)",
            " ",
            " \terr = pc1.SetRemoteDescription(*pc2.LocalDescription())",
            " \tassert.NoError(t, err)",
            " ",
            "+\t<-pc1Connected",
            "+",
            " \tvar gotNack bool",
            " \trtcpDone := make(chan struct{})",
            " \tgo func() {",
            " \t\tdefer close(rtcpDone)",
            " \t\tbuf := make([]byte, 1500)",
            " \t\tfor {",
            " \t\t\tn, _, err2 := sender.Read(buf)",
            "@@ -420,30 +484,26 @@",
            " \t\t\t\tcontinue",
            " \t\t\t}",
            " \t\t\tvar p rtp.Packet",
            " \t\t\tp.Version = 2",
            " \t\t\tp.Marker = true",
            " \t\t\tp.PayloadType = 96",
            " \t\t\tp.SequenceNumber = uint16(i)         //nolint:gosec // G115",
            "-\t\t\tp.Timestamp = uint32(i * 90000 / 50) ///nolint:gosec // G115",
            "+\t\t\tp.Timestamp = uint32(i * 90000 / 50) //nolint:gosec // G115",
            " \t\t\tp.Payload = []byte{42}",
            " \t\t\terr2 := track1.WriteRTP(&p)",
            " \t\t\tassert.NoError(t, err2)",
            " \t\t}",
            " \t}()",
            " ",
            " \t<-done",
            " \terr = pc1.Close()",
            " \tassert.NoError(t, err)",
            " \terr = pc2.Close()",
            " \tassert.NoError(t, err)",
            " ",
            " \tif requestNack {",
            "-\t\tif !gotNack {",
            "-\t\t\tt.Errorf(\"Expected to get a NACK, got none\")",
            "-\t\t}",
            "+\t\tassert.True(t, gotNack, \"Expected to get a NACK, got none\")",
            " \t} else {",
            "-\t\tif gotNack {",
            "-\t\t\tt.Errorf(\"Expected to get no NACK, got one\")",
            "-\t\t}",
            "+\t\tassert.False(t, gotNack, \"Expected to get no NACK, got one\")",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/internal/fmtp/fmtp_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/internal/fmtp/fmtp_test.go",
            "+++ /home/webrtc-4.1.3/internal/fmtp/fmtp_test.go",
            "@@ -1,15 +1,16 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package fmtp",
            " ",
            " import (",
            "-\t\"reflect\"",
            " \t\"testing\"",
            "+",
            "+\t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestParseParameters(t *testing.T) {",
            " \tfor _, ca := range []struct {",
            " \t\tname       string",
            " \t\tline       string",
            " \t\tparameters map[string]string",
            "@@ -43,17 +44,15 @@",
            " \t\t\t\t\"key-name\": \"value\",",
            " \t\t\t\t\"key2\":     \"value2\",",
            " \t\t\t},",
            " \t\t},",
            " \t} {",
            " \t\tt.Run(ca.name, func(t *testing.T) {",
            " \t\t\tparameters := parseParameters(ca.line)",
            "-\t\t\tif !reflect.DeepEqual(parameters, ca.parameters) {",
            "-\t\t\t\tt.Errorf(\"expected '%v', got '%v'\", ca.parameters, parameters)",
            "-\t\t\t}",
            "+\t\t\tassert.Equal(t, ca.parameters, parameters)",
            " \t\t})",
            " \t}",
            " }",
            " ",
            " func TestParse(t *testing.T) {",
            " \tfor _, ca := range []struct {",
            " \t\tname      string",
            "@@ -128,21 +127,17 @@",
            " \t\t\t\t\t\"key-name\": \"value\",",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t},",
            " \t} {",
            " \t\tt.Run(ca.name, func(t *testing.T) {",
            " \t\t\tf := Parse(ca.mimeType, ca.clockRate, ca.channels, ca.line)",
            "-\t\t\tif !reflect.DeepEqual(ca.expected, f) {",
            "-\t\t\t\tt.Errorf(\"expected '%v', got '%v'\", ca.expected, f)",
            "-\t\t\t}",
            " ",
            "-\t\t\tif f.MimeType() != ca.mimeType {",
            "-\t\t\t\tt.Errorf(\"Expected '%v', got '%s'\", ca.mimeType, f.MimeType())",
            "-\t\t\t}",
            "+\t\t\tassert.Equal(t, ca.expected, f)",
            "+\t\t\tassert.Equal(t, ca.mimeType, f.MimeType())",
            " \t\t})",
            " \t}",
            " }",
            " ",
            " func TestMatch(t *testing.T) { //nolint:maintidx",
            " \tconsistString := map[bool]string{true: \"consist\", false: \"inconsist\"}",
            " ",
            "@@ -700,24 +695,23 @@",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t\ttrue,",
            " \t\t},",
            " \t} {",
            " \t\tt.Run(ca.name, func(t *testing.T) {",
            " \t\t\tc := ca.a.Match(ca.b)",
            "-\t\t\tif c != ca.consist {",
            "-\t\t\t\tt.Errorf(",
            "-\t\t\t\t\t\"'%s' and '%s' are expected to be %s, but treated as %s\",",
            "-\t\t\t\t\tca.a, ca.b, consistString[ca.consist], consistString[c],",
            "-\t\t\t\t)",
            "-\t\t\t}",
            "+\t\t\tassert.Equal(t, ca.consist, c)",
            "+\t\t\tassert.Equal(",
            "+\t\t\t\tt, ca.consist, c,",
            "+\t\t\t\t\"'%s' and '%s' are expected to be %s, but treated as %s\",",
            "+\t\t\t\tca.a, ca.b, consistString[ca.consist], consistString[c],",
            "+\t\t\t)",
            " ",
            " \t\t\tc = ca.b.Match(ca.a)",
            "-\t\t\tif c != ca.consist {",
            "-\t\t\t\tt.Errorf(",
            "-\t\t\t\t\t\"'%s' and '%s' are expected to be %s, but treated as %s\",",
            "-\t\t\t\t\tca.a, ca.b, consistString[ca.consist], consistString[c],",
            "-\t\t\t\t)",
            "-\t\t\t}",
            "+\t\t\tassert.Equalf(",
            "+\t\t\t\tt, ca.consist, c,",
            "+\t\t\t\t\"'%s' and '%s' are expected to be %s, but treated as %s\",",
            "+\t\t\t\tca.b, ca.a, consistString[ca.consist], consistString[c],",
            "+\t\t\t)",
            " \t\t})",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/internal/util/util_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/internal/util/util_test.go",
            "+++ /home/webrtc-4.1.3/internal/util/util_test.go",
            "@@ -1,27 +1,22 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package util",
            " ",
            " import (",
            " \t\"errors\"",
            "-\t\"regexp\"",
            " \t\"testing\"",
            "+",
            "+\t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestMathRandAlpha(t *testing.T) {",
            "-\tif len(MathRandAlpha(10)) != 10 {",
            "-\t\tt.Errorf(\"MathRandAlpha return invalid length\")",
            "-\t}",
            "-",
            "-\tisLetter := regexp.MustCompile(`^[a-zA-Z]+$`).MatchString",
            "-\tif !isLetter(MathRandAlpha(10)) {",
            "-\t\tt.Errorf(\"MathRandAlpha should be AlphaNumeric only\")",
            "-\t}",
            "+\tassert.Len(t, MathRandAlpha(10), 10, \"MathRandAlpha should return 10 characters\")",
            "+\tassert.Regexp(t, `^[a-zA-Z]+$`, MathRandAlpha(10), \"MathRandAlpha should be Alpha only\")",
            " }",
            " ",
            " func TestMultiError(t *testing.T) {",
            " \trawErrs := []error{",
            " \t\terrors.New(\"err1\"), //nolint",
            " \t\terrors.New(\"err2\"), //nolint",
            " \t\terrors.New(\"err3\"), //nolint",
            "@@ -33,24 +28,17 @@",
            " \t\trawErrs[1],",
            " \t\tFlattenErrs([]error{",
            " \t\t\trawErrs[2],",
            " \t\t}),",
            " \t})",
            " \tstr := \"err1\\nerr2\\nerr3\"",
            " ",
            "-\tif errs.Error() != str {",
            "-\t\tt.Errorf(\"String representation doesn't match, expected: %s, got: %s\", errs.Error(), str)",
            "-\t}",
            "+\tassert.Equal(t, str, errs.Error(), \"String representation doesn't match\")",
            " ",
            " \terrIs, ok := errs.(multiError) //nolint:errorlint",
            "-\tif !ok {",
            "-\t\tt.Fatal(\"FlattenErrs returns non-multiError\")",
            "-\t}",
            "+\tassert.True(t, ok, \"FlattenErrs returns non-multiError\")",
            " \tfor i := 0; i < 3; i++ {",
            "-\t\tif !errIs.Is(rawErrs[i]) {",
            "-\t\t\tt.Errorf(\"'%+v' should contains '%v'\", errs, rawErrs[i])",
            "-\t\t}",
            "-\t}",
            "-\tif errIs.Is(rawErrs[3]) {",
            "-\t\tt.Errorf(\"'%+v' should not contains '%v'\", errs, rawErrs[3])",
            "+\t\tassert.Truef(t, errIs.Is(rawErrs[i]), \"Should contains this error '%v'\", rawErrs[i])",
            " \t}",
            "+",
            "+\tassert.Falsef(t, errIs.Is(rawErrs[3]), \"Should not contains this error '%v'\", rawErrs[3])",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/js_utils.go",
          "change": [
            "--- /home/webrtc-4.0.11/js_utils.go",
            "+++ /home/webrtc-4.1.3/js_utils.go",
            "@@ -15,23 +15,23 @@",
            " // resolves, it returns (result, nil). If the promise rejects, it returns",
            " // (js.Undefined, error). awaitPromise has a synchronous-like API but does not",
            " // block the JavaScript event loop.",
            " func awaitPromise(promise js.Value) (js.Value, error) {",
            " \tresultsChan := make(chan js.Value)",
            " \terrChan := make(chan js.Error)",
            " ",
            "-\tthenFunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tthenFunc := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\tresultsChan <- args[0]",
            " \t\t}()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tdefer thenFunc.Release()",
            " ",
            "-\tcatchFunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tcatchFunc := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo func() {",
            " \t\t\terrChan <- js.Error{args[0]}",
            " \t\t}()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tdefer catchFunc.Release()",
            " ",
            "@@ -71,15 +71,15 @@",
            " func uint8ToValueOrUndefined(val uint8) js.Value {",
            " \tif val == 0 {",
            " \t\treturn js.Undefined()",
            " \t}",
            " \treturn js.ValueOf(val)",
            " }",
            " ",
            "-func interfaceToValueOrUndefined(val interface{}) js.Value {",
            "+func interfaceToValueOrUndefined(val any) js.Value {",
            " \tif val == nil {",
            " \t\treturn js.Undefined()",
            " \t}",
            " \treturn js.ValueOf(val)",
            " }",
            " ",
            " func valueToStringOrZero(val js.Value) string {",
            "@@ -136,30 +136,30 @@",
            " \tif val == nil {",
            " \t\treturn js.Undefined()",
            " \t}",
            " \treturn js.ValueOf(*val)",
            " }",
            " ",
            " func stringsToValue(strings []string) js.Value {",
            "-\tval := make([]interface{}, len(strings))",
            "+\tval := make([]any, len(strings))",
            " \tfor i, s := range strings {",
            " \t\tval[i] = s",
            " \t}",
            " \treturn js.ValueOf(val)",
            " }",
            " ",
            " func stringEnumToValueOrUndefined(s string) js.Value {",
            " \tif s == \"unknown\" {",
            " \t\treturn js.Undefined()",
            " \t}",
            " \treturn js.ValueOf(s)",
            " }",
            " ",
            " // Converts the return value of recover() to an error.",
            "-func recoveryToError(e interface{}) error {",
            "+func recoveryToError(e any) error {",
            " \tswitch e := e.(type) {",
            " \tcase error:",
            " \t\treturn e",
            " \tdefault:",
            " \t\treturn fmt.Errorf(\"recovered with non-error value: (%T) %s\", e, e)",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/mediaengine.go",
          "change": [
            "--- /home/webrtc-4.0.11/mediaengine.go",
            "+++ /home/webrtc-4.1.3/mediaengine.go",
            "@@ -3,85 +3,67 @@",
            " ",
            " //go:build !js",
            " // +build !js",
            " ",
            " package webrtc",
            " ",
            " import (",
            "+\t\"errors\"",
            " \t\"fmt\"",
            " \t\"strconv\"",
            " \t\"strings\"",
            " \t\"sync\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/rtp\"",
            " \t\"github.com/pion/rtp/codecs\"",
            " \t\"github.com/pion/sdp/v3\"",
            " \t\"github.com/pion/webrtc/v4/internal/fmtp\"",
            " )",
            " ",
            "-const (",
            "-\t// MimeTypeH264 H264 MIME type.",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeH264 = \"video/H264\"",
            "-\t// MimeTypeH265 H265 MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeH265 = \"video/H265\"",
            "-\t// MimeTypeOpus Opus MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeOpus = \"audio/opus\"",
            "-\t// MimeTypeVP8 VP8 MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeVP8 = \"video/VP8\"",
            "-\t// MimeTypeVP9 VP9 MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeVP9 = \"video/VP9\"",
            "-\t// MimeTypeAV1 AV1 MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeAV1 = \"video/AV1\"",
            "-\t// MimeTypeG722 G722 MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeG722 = \"audio/G722\"",
            "-\t// MimeTypePCMU PCMU MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypePCMU = \"audio/PCMU\"",
            "-\t// MimeTypePCMA PCMA MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypePCMA = \"audio/PCMA\"",
            "-\t// MimeTypeRTX RTX MIME type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeRTX = \"video/rtx\"",
            "-\t// MimeTypeFlexFEC FEC MIME Type",
            "-\t// Note: Matching should be case insensitive.",
            "-\tMimeTypeFlexFEC = \"video/flexfec\"",
            "-)",
            "-",
            " type mediaEngineHeaderExtension struct {",
            " \turi              string",
            " \tisAudio, isVideo bool",
            " ",
            " \t// If set only Transceivers of this direction are allowed",
            " \tallowedDirections []RTPTransceiverDirection",
            " }",
            " ",
            " // A MediaEngine defines the codecs supported by a PeerConnection, and the",
            " // configuration of those codecs.",
            " type MediaEngine struct {",
            " \t// If we have attempted to negotiate a codec type yet.",
            " \tnegotiatedVideo, negotiatedAudio bool",
            "+\tnegotiateMultiCodecs             bool",
            " ",
            " \tvideoCodecs, audioCodecs                     []RTPCodecParameters",
            " \tnegotiatedVideoCodecs, negotiatedAudioCodecs []RTPCodecParameters",
            " ",
            " \theaderExtensions           []mediaEngineHeaderExtension",
            " \tnegotiatedHeaderExtensions map[int]mediaEngineHeaderExtension",
            " ",
            " \tmu sync.RWMutex",
            " }",
            " ",
            "+// setMultiCodecNegotiation enables or disables the negotiation of multiple codecs.",
            "+func (m *MediaEngine) setMultiCodecNegotiation(negotiateMultiCodecs bool) {",
            "+\tm.mu.Lock()",
            "+\tdefer m.mu.Unlock()",
            "+",
            "+\tm.negotiateMultiCodecs = negotiateMultiCodecs",
            "+}",
            "+",
            "+// multiCodecNegotiation returns the current state of the negotiation of multiple codecs.",
            "+func (m *MediaEngine) multiCodecNegotiation() bool {",
            "+\tm.mu.RLock()",
            "+\tdefer m.mu.RUnlock()",
            "+",
            "+\treturn m.negotiateMultiCodecs",
            "+}",
            "+",
            " // RegisterDefaultCodecs registers the default codecs supported by Pion WebRTC.",
            " // RegisterDefaultCodecs is not safe for concurrent use.",
            " func (m *MediaEngine) RegisterDefaultCodecs() error {",
            " \t// Default Pion Audio Codecs",
            " \tfor _, codec := range []RTPCodecParameters{",
            " \t\t{",
            " \t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"minptime=10;useinbandfec=1\", nil},",
            "@@ -190,15 +172,26 @@",
            " \t\t\t},",
            " \t\t\tPayloadType: 39,",
            " \t\t},",
            " \t\t{",
            " \t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=39\", nil},",
            " \t\t\tPayloadType:        40,",
            " \t\t},",
            "-",
            "+\t\t{",
            "+\t\t\tRTPCodecCapability: RTPCodecCapability{",
            "+\t\t\t\tMimeType:     MimeTypeH265,",
            "+\t\t\t\tClockRate:    90000,",
            "+\t\t\t\tRTCPFeedback: videoRTCPFeedback,",
            "+\t\t\t},",
            "+\t\t\tPayloadType: 116,",
            "+\t\t},",
            "+\t\t{",
            "+\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=116\", nil},",
            "+\t\t\tPayloadType:        117,",
            "+\t\t},",
            " \t\t{",
            " \t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeAV1, 90000, 0, \"\", videoRTCPFeedback},",
            " \t\t\tPayloadType:        45,",
            " \t\t},",
            " \t\t{",
            " \t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=45\", nil},",
            " \t\t\tPayloadType:        46,",
            "@@ -240,44 +233,48 @@",
            " \t\t}",
            " \t}",
            " ",
            " \treturn nil",
            " }",
            " ",
            " // addCodec will append codec if it not exists.",
            "-func (m *MediaEngine) addCodec(codecs []RTPCodecParameters, codec RTPCodecParameters) []RTPCodecParameters {",
            "+func (m *MediaEngine) addCodec(codecs []RTPCodecParameters, codec RTPCodecParameters) ([]RTPCodecParameters, error) {",
            " \tfor _, c := range codecs {",
            "-\t\tif c.MimeType == codec.MimeType &&",
            "-\t\t\tfmtp.ClockRateEqual(c.MimeType, c.ClockRate, codec.ClockRate) &&",
            "-\t\t\tfmtp.ChannelsEqual(c.MimeType, c.Channels, codec.Channels) &&",
            "-\t\t\tc.PayloadType == codec.PayloadType {",
            "-\t\t\treturn codecs",
            "+\t\tif c.PayloadType == codec.PayloadType {",
            "+\t\t\tif strings.EqualFold(c.MimeType, codec.MimeType) &&",
            "+\t\t\t\tfmtp.ClockRateEqual(c.MimeType, c.ClockRate, codec.ClockRate) &&",
            "+\t\t\t\tfmtp.ChannelsEqual(c.MimeType, c.Channels, codec.Channels) {",
            "+\t\t\t\treturn codecs, nil",
            "+\t\t\t}",
            "+",
            "+\t\t\treturn codecs, ErrCodecAlreadyRegistered",
            " \t\t}",
            " \t}",
            " ",
            "-\treturn append(codecs, codec)",
            "+\treturn append(codecs, codec), nil",
            " }",
            " ",
            " // RegisterCodec adds codec to the MediaEngine",
            " // These are the list of codecs supported by this PeerConnection.",
            " func (m *MediaEngine) RegisterCodec(codec RTPCodecParameters, typ RTPCodecType) error {",
            " \tm.mu.Lock()",
            " \tdefer m.mu.Unlock()",
            " ",
            "+\tvar err error",
            " \tcodec.statsID = fmt.Sprintf(\"RTPCodec-%d\", time.Now().UnixNano())",
            " \tswitch typ {",
            " \tcase RTPCodecTypeAudio:",
            "-\t\tm.audioCodecs = m.addCodec(m.audioCodecs, codec)",
            "+\t\tm.audioCodecs, err = m.addCodec(m.audioCodecs, codec)",
            " \tcase RTPCodecTypeVideo:",
            "-\t\tm.videoCodecs = m.addCodec(m.videoCodecs, codec)",
            "+\t\tm.videoCodecs, err = m.addCodec(m.videoCodecs, codec)",
            " \tdefault:",
            " \t\treturn ErrUnknownType",
            " \t}",
            " ",
            "-\treturn nil",
            "+\treturn err",
            " }",
            " ",
            " // RegisterHeaderExtension adds a header extension to the MediaEngine",
            " // To determine the negotiated value use `GetHeaderExtensionID` after signaling is complete.",
            " //",
            " //nolint:cyclop",
            " func (m *MediaEngine) RegisterHeaderExtension(",
            "@@ -573,26 +570,33 @@",
            " \t\t\tm.negotiatedHeaderExtensions[id] = h",
            " \t\t}",
            " \t}",
            " ",
            " \treturn nil",
            " }",
            " ",
            "-func (m *MediaEngine) pushCodecs(codecs []RTPCodecParameters, typ RTPCodecType) {",
            "+func (m *MediaEngine) pushCodecs(codecs []RTPCodecParameters, typ RTPCodecType) error {",
            "+\tvar joinedErr error",
            " \tfor _, codec := range codecs {",
            "+\t\tvar err error",
            " \t\tif typ == RTPCodecTypeAudio {",
            "-\t\t\tm.negotiatedAudioCodecs = m.addCodec(m.negotiatedAudioCodecs, codec)",
            "+\t\t\tm.negotiatedAudioCodecs, err = m.addCodec(m.negotiatedAudioCodecs, codec)",
            " \t\t} else if typ == RTPCodecTypeVideo {",
            "-\t\t\tm.negotiatedVideoCodecs = m.addCodec(m.negotiatedVideoCodecs, codec)",
            "+\t\t\tm.negotiatedVideoCodecs, err = m.addCodec(m.negotiatedVideoCodecs, codec)",
            "+\t\t}",
            "+\t\tif err != nil {",
            "+\t\t\tjoinedErr = errors.Join(joinedErr, err)",
            " \t\t}",
            " \t}",
            "+",
            "+\treturn joinedErr",
            " }",
            " ",
            " // Update the MediaEngine from a remote description.",
            "-func (m *MediaEngine) updateFromRemoteDescription(desc sdp.SessionDescription) error { //nolint:cyclop",
            "+func (m *MediaEngine) updateFromRemoteDescription(desc sdp.SessionDescription) error { //nolint:cyclop,gocognit",
            " \tm.mu.Lock()",
            " \tdefer m.mu.Unlock()",
            " ",
            " \tfor _, media := range desc.MediaDescriptions {",
            " \t\tvar typ RTPCodecType",
            " ",
            " \t\tswitch {",
            "@@ -612,15 +616,17 @@",
            " \t\t\t// would send updated header extension in renegotiation.",
            " \t\t\t// e.g. publish first track without simucalst ->negotiated-> publish second track with simucalst",
            " \t\t\t// then the two media secontions have different rtp header extensions in offer",
            " \t\t\tif err := m.updateHeaderExtensionFromMediaSection(media); err != nil {",
            " \t\t\t\treturn err",
            " \t\t\t}",
            " ",
            "-\t\t\tcontinue",
            "+\t\t\tif !m.negotiateMultiCodecs || (typ != RTPCodecTypeAudio && typ != RTPCodecTypeVideo) {",
            "+\t\t\t\tcontinue",
            "+\t\t\t}",
            " \t\t}",
            " ",
            " \t\tcodecs, err := codecsFromMediaDescription(media)",
            " \t\tif err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " ",
            "@@ -641,21 +647,24 @@",
            " \t\t\t\tpartialMatches = append(partialMatches, remoteCodec)",
            " \t\t\t}",
            " \t\t}",
            " ",
            " \t\t// use exact matches when they exist, otherwise fall back to partial",
            " \t\tswitch {",
            " \t\tcase len(exactMatches) > 0:",
            "-\t\t\tm.pushCodecs(exactMatches, typ)",
            "+\t\t\terr = m.pushCodecs(exactMatches, typ)",
            " \t\tcase len(partialMatches) > 0:",
            "-\t\t\tm.pushCodecs(partialMatches, typ)",
            "+\t\t\terr = m.pushCodecs(partialMatches, typ)",
            " \t\tdefault:",
            " \t\t\t// no match, not negotiated",
            " \t\t\tcontinue",
            " \t\t}",
            "+\t\tif err != nil {",
            "+\t\t\treturn err",
            "+\t\t}",
            " ",
            " \t\tif err := m.updateHeaderExtensionFromMediaSection(media); err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " \t}",
            " ",
            " \treturn nil",
            "@@ -785,24 +794,24 @@",
            " \tdefault:",
            " \t\treturn nil, ErrNoPayloaderForCodec",
            " \t}",
            " }",
            " ",
            " func (m *MediaEngine) isRTXEnabled(typ RTPCodecType, directions []RTPTransceiverDirection) bool {",
            " \tfor _, p := range m.getRTPParametersByKind(typ, directions).Codecs {",
            "-\t\tif p.MimeType == MimeTypeRTX {",
            "+\t\tif strings.EqualFold(p.MimeType, MimeTypeRTX) {",
            " \t\t\treturn true",
            " \t\t}",
            " \t}",
            " ",
            " \treturn false",
            " }",
            " ",
            " func (m *MediaEngine) isFECEnabled(typ RTPCodecType, directions []RTPTransceiverDirection) bool {",
            " \tfor _, p := range m.getRTPParametersByKind(typ, directions).Codecs {",
            "-\t\tif strings.Contains(p.MimeType, MimeTypeFlexFEC) {",
            "+\t\tif strings.Contains(strings.ToLower(p.MimeType), MimeTypeFlexFEC) {",
            " \t\t\treturn true",
            " \t\t}",
            " \t}",
            " ",
            " \treturn false",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/mediaengine_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/mediaengine_test.go",
            "+++ /home/webrtc-4.1.3/mediaengine_test.go",
            "@@ -571,23 +571,93 @@",
            " \t\tassert.Equal(t, 1, len(video.HeaderExtensions))",
            " \t\tassert.NotEqual(t, audio.HeaderExtensions[0].ID, video.HeaderExtensions[0].ID)",
            " \t})",
            " }",
            " ",
            " // If a user attempts to register a codec twice we should just discard duplicate calls.",
            " func TestMediaEngineDoubleRegister(t *testing.T) {",
            "+\tt.Run(\"Same Codec\", func(t *testing.T) {",
            "+\t\tmediaEngine := MediaEngine{}",
            "+",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        111,",
            "+\t\t\t}, RTPCodecTypeAudio))",
            "+",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        111,",
            "+\t\t\t}, RTPCodecTypeAudio))",
            "+",
            "+\t\tassert.Equal(t, len(mediaEngine.audioCodecs), 1)",
            "+\t})",
            "+",
            "+\tt.Run(\"Case Insensitive Audio Codec\", func(t *testing.T) {",
            "+\t\tmediaEngine := MediaEngine{}",
            "+",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{\"audio/OPUS\", 48000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        111,",
            "+\t\t\t}, RTPCodecTypeAudio))",
            "+",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{\"audio/opus\", 48000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        111,",
            "+\t\t\t}, RTPCodecTypeAudio))",
            "+",
            "+\t\tassert.Equal(t, len(mediaEngine.audioCodecs), 1)",
            "+\t})",
            "+",
            "+\tt.Run(\"Case Insensitive Video Codec\", func(t *testing.T) {",
            "+\t\tmediaEngine := MediaEngine{}",
            "+",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{strings.ToUpper(MimeTypeRTX), 90000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        98,",
            "+\t\t\t}, RTPCodecTypeVideo))",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        98,",
            "+\t\t\t}, RTPCodecTypeVideo))",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{strings.ToUpper(MimeTypeFlexFEC), 90000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        100,",
            "+\t\t\t}, RTPCodecTypeVideo))",
            "+\t\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\t\t\tRTPCodecParameters{",
            "+\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeFlexFEC, 90000, 0, \"\", nil},",
            "+\t\t\t\tPayloadType:        100,",
            "+\t\t\t}, RTPCodecTypeVideo))",
            "+\t\tassert.Equal(t, len(mediaEngine.videoCodecs), 2)",
            "+\t\tisRTX := mediaEngine.isRTXEnabled(RTPCodecTypeVideo, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})",
            "+\t\tassert.True(t, isRTX)",
            "+\t\tisFEC := mediaEngine.isFECEnabled(RTPCodecTypeVideo, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})",
            "+\t\tassert.True(t, isFEC)",
            "+\t})",
            "+}",
            "+",
            "+// If a user attempts to register a codec with same payload but with different",
            "+// codec we should just discard duplicate calls.",
            "+func TestMediaEngineDoubleRegisterDifferentCodec(t *testing.T) {",
            " \tmediaEngine := MediaEngine{}",
            " ",
            " \tassert.NoError(t, mediaEngine.RegisterCodec(",
            " \t\tRTPCodecParameters{",
            "-\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},",
            "+\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeG722, 8000, 0, \"\", nil},",
            " \t\t\tPayloadType:        111,",
            " \t\t}, RTPCodecTypeAudio))",
            " ",
            "-\tassert.NoError(t, mediaEngine.RegisterCodec(",
            "+\tassert.Error(t, ErrCodecAlreadyRegistered, mediaEngine.RegisterCodec(",
            " \t\tRTPCodecParameters{",
            " \t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},",
            " \t\t\tPayloadType:        111,",
            " \t\t}, RTPCodecTypeAudio))",
            " ",
            " \tassert.Equal(t, len(mediaEngine.audioCodecs), 1)",
            " }",
            "@@ -872,7 +942,72 @@",
            " \t\trunTest(t, false)",
            " \t})",
            " ",
            " \tt.Run(\"sendrecv\", func(t *testing.T) {",
            " \t\trunTest(t, true)",
            " \t})",
            " }",
            "+",
            "+func TestMultiCodecNegotiation(t *testing.T) {",
            "+\tconst offerSdp = `v=0",
            "+o=- 781500112831855234 6 IN IP4 127.0.0.1",
            "+s=-",
            "+t=0 0",
            "+a=group:BUNDLE 0 1 2 3",
            "+a=extmap-allow-mixed",
            "+a=msid-semantic: WMS be0216be-f3d8-40ca-a624-379edf70f1c9",
            "+m=application 53555 UDP/DTLS/SCTP webrtc-datachannel",
            "+a=mid:0",
            "+a=sctp-port:5000",
            "+a=max-message-size:262144",
            "+m=video 9 UDP/TLS/RTP/SAVPF 98",
            "+a=mid:1",
            "+a=sendonly",
            "+a=msid:be0216be-f3d8-40ca-a624-379edf70f1c9 3d032b3b-ffe5-48ec-b783-21375668d1c3",
            "+a=rtcp-mux",
            "+a=rtcp-rsize",
            "+a=rtpmap:98 VP9/90000",
            "+a=rtcp-fb:98 goog-remb",
            "+a=rtcp-fb:98 transport-cc",
            "+a=rtcp-fb:98 ccm fir",
            "+a=rtcp-fb:98 nack",
            "+a=rtcp-fb:98 nack pli",
            "+a=fmtp:98 profile-id=0",
            "+a=rid:q send",
            "+a=rid:h send",
            "+a=simulcast:send q;h",
            "+m=video 9 UDP/TLS/RTP/SAVPF 96",
            "+a=mid:2",
            "+a=sendonly",
            "+a=msid:6ff05509-be96-4ef1-a74f-425e14720983 16d5d7fe-d076-4718-9ca9-ec62b4543727",
            "+a=rtcp-mux",
            "+a=rtcp-rsize",
            "+a=rtpmap:96 VP8/90000",
            "+a=rtcp-fb:96 goog-remb",
            "+a=rtcp-fb:96 transport-cc",
            "+a=rtcp-fb:96 ccm fir",
            "+a=rtcp-fb:96 nack",
            "+a=rtcp-fb:96 nack pli",
            "+a=ssrc:4281768245 cname:JDM9GNMEg+9To6K7",
            "+a=ssrc:4281768245 msid:6ff05509-be96-4ef1-a74f-425e14720983 16d5d7fe-d076-4718-9ca9-ec62b4543727",
            "+`",
            "+\tmustParse := func(raw string) sdp.SessionDescription {",
            "+\t\ts := sdp.SessionDescription{}",
            "+\t\tassert.NoError(t, s.Unmarshal([]byte(raw)))",
            "+",
            "+\t\treturn s",
            "+\t}",
            "+\tt.Run(\"Multi codec negotiation disabled\", func(t *testing.T) {",
            "+\t\tmediaEngine := MediaEngine{}",
            "+\t\tassert.NoError(t, mediaEngine.RegisterDefaultCodecs())",
            "+\t\tassert.NoError(t, mediaEngine.updateFromRemoteDescription(mustParse(offerSdp)))",
            "+\t\tassert.Len(t, mediaEngine.negotiatedVideoCodecs, 1)",
            "+\t})",
            "+\tt.Run(\"Multi codec negotiation enabled\", func(t *testing.T) {",
            "+\t\tmediaEngine := MediaEngine{}",
            "+\t\tmediaEngine.setMultiCodecNegotiation(true)",
            "+\t\tassert.True(t, mediaEngine.multiCodecNegotiation())",
            "+\t\tassert.NoError(t, mediaEngine.RegisterDefaultCodecs())",
            "+\t\tassert.NoError(t, mediaEngine.updateFromRemoteDescription(mustParse(offerSdp)))",
            "+\t\tassert.Len(t, mediaEngine.negotiatedVideoCodecs, 2)",
            "+\t})",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/networktype_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/networktype_test.go",
            "+++ /home/webrtc-4.1.3/networktype_test.go",
            "@@ -41,16 +41,18 @@",
            " \t\t{\"udp6\", false, NetworkTypeUDP6},",
            " \t\t{\"tcp4\", false, NetworkTypeTCP4},",
            " \t\t{\"tcp6\", false, NetworkTypeTCP6},",
            " \t}",
            " ",
            " \tfor i, testCase := range testCases {",
            " \t\tactual, err := NewNetworkType(testCase.typeString)",
            "-\t\tif (err != nil) != testCase.shouldFail {",
            "-\t\t\tt.Error(err)",
            "+\t\tif testCase.shouldFail {",
            "+\t\t\tassert.Error(t, err)",
            "+\t\t} else {",
            "+\t\t\tassert.NoError(t, err)",
            " \t\t}",
            " \t\tassert.Equal(t,",
            " \t\t\ttestCase.expectedType,",
            " \t\t\tactual,",
            " \t\t\t\"testCase: %d %v\", i, testCase,",
            " \t\t)",
            " \t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/operations.go",
          "change": [
            "--- /home/webrtc-4.0.11/operations.go",
            "+++ /home/webrtc-4.1.3/operations.go",
            "@@ -2,32 +2,33 @@",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package webrtc",
            " ",
            " import (",
            " \t\"container/list\"",
            " \t\"sync\"",
            "+\t\"sync/atomic\"",
            " )",
            " ",
            " // Operation is a function.",
            " type operation func()",
            " ",
            " // Operations is a task executor.",
            " type operations struct {",
            " \tmu     sync.Mutex",
            " \tbusyCh chan struct{}",
            " \tops    *list.List",
            " ",
            "-\tupdateNegotiationNeededFlagOnEmptyChain *atomicBool",
            "+\tupdateNegotiationNeededFlagOnEmptyChain *atomic.Bool",
            " \tonNegotiationNeeded                     func()",
            " \tisClosed                                bool",
            " }",
            " ",
            " func newOperations(",
            "-\tupdateNegotiationNeededFlagOnEmptyChain *atomicBool,",
            "+\tupdateNegotiationNeededFlagOnEmptyChain *atomic.Bool,",
            " \tonNegotiationNeeded func(),",
            " ) *operations {",
            " \treturn &operations{",
            " \t\tops:                                     list.New(),",
            " \t\tupdateNegotiationNeededFlagOnEmptyChain: updateNegotiationNeededFlagOnEmptyChain,",
            " \t\tonNegotiationNeeded:                     onNegotiationNeeded,",
            " \t}",
            "@@ -146,13 +147,13 @@",
            " \t}()",
            " ",
            " \tfn := o.pop()",
            " \tfor fn != nil {",
            " \t\tfn()",
            " \t\tfn = o.pop()",
            " \t}",
            "-\tif !o.updateNegotiationNeededFlagOnEmptyChain.get() {",
            "+\tif !o.updateNegotiationNeededFlagOnEmptyChain.Load() {",
            " \t\treturn",
            " \t}",
            "-\to.updateNegotiationNeededFlagOnEmptyChain.set(false)",
            "+\to.updateNegotiationNeededFlagOnEmptyChain.Store(false)",
            " \to.onNegotiationNeeded()",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/operations_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/operations_test.go",
            "+++ /home/webrtc-4.1.3/operations_test.go",
            "@@ -1,21 +1,22 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package webrtc",
            " ",
            " import (",
            " \t\"sync\"",
            "+\t\"sync/atomic\"",
            " \t\"testing\"",
            " ",
            " \t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestOperations_Enqueue(t *testing.T) {",
            "-\tupdateNegotiationNeededFlagOnEmptyChain := &atomicBool{}",
            "+\tupdateNegotiationNeededFlagOnEmptyChain := &atomic.Bool{}",
            " \tonNegotiationNeededCalledCount := 0",
            " \tvar onNegotiationNeededCalledCountMu sync.Mutex",
            " \tops := newOperations(updateNegotiationNeededFlagOnEmptyChain, func() {",
            " \t\tonNegotiationNeededCalledCountMu.Lock()",
            " \t\tonNegotiationNeededCalledCount++",
            " \t\tonNegotiationNeededCalledCountMu.Unlock()",
            " \t})",
            "@@ -25,15 +26,15 @@",
            " \t\tresults := make([]int, 16)",
            " \t\tresultSetCopy := resultSet",
            " \t\tfor i := range results {",
            " \t\t\tfunc(j int) {",
            " \t\t\t\tops.Enqueue(func() {",
            " \t\t\t\t\tresults[j] = j * j",
            " \t\t\t\t\tif resultSetCopy > 50 {",
            "-\t\t\t\t\t\tupdateNegotiationNeededFlagOnEmptyChain.set(true)",
            "+\t\t\t\t\t\tupdateNegotiationNeededFlagOnEmptyChain.Store(true)",
            " \t\t\t\t\t}",
            " \t\t\t\t})",
            " \t\t\t}(i)",
            " \t\t}",
            " ",
            " \t\tops.Done()",
            " \t\texpected := []int{0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225}",
            "@@ -42,22 +43,22 @@",
            " \t}",
            " \tonNegotiationNeededCalledCountMu.Lock()",
            " \tdefer onNegotiationNeededCalledCountMu.Unlock()",
            " \tassert.NotEqual(t, onNegotiationNeededCalledCount, 0)",
            " }",
            " ",
            " func TestOperations_Done(*testing.T) {",
            "-\tops := newOperations(&atomicBool{}, func() {",
            "+\tops := newOperations(&atomic.Bool{}, func() {",
            " \t})",
            " \tdefer ops.GracefulClose()",
            " \tops.Done()",
            " }",
            " ",
            " func TestOperations_GracefulClose(t *testing.T) {",
            "-\tops := newOperations(&atomicBool{}, func() {",
            "+\tops := newOperations(&atomic.Bool{}, func() {",
            " \t})",
            " ",
            " \tcounter := 0",
            " \tvar counterMu sync.Mutex",
            " \tincFunc := func() {",
            " \t\tcounterMu.Lock()",
            " \t\tcounter++"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection.go",
            "+++ /home/webrtc-4.1.3/peerconnection.go",
            "@@ -51,20 +51,20 @@",
            " \tpendingRemoteDescription *SessionDescription",
            " \tsignalingState           SignalingState",
            " \ticeConnectionState       atomic.Value // ICEConnectionState",
            " \tconnectionState          atomic.Value // PeerConnectionState",
            " ",
            " \tidpLoginURL *string",
            " ",
            "-\tisClosed                                *atomicBool",
            "+\tisClosed                                *atomic.Bool",
            " \tisGracefullyClosingOrClosed             bool",
            " \tisCloseDone                             chan struct{}",
            " \tisGracefulCloseDone                     chan struct{}",
            "-\tisNegotiationNeeded                     *atomicBool",
            "-\tupdateNegotiationNeededFlagOnEmptyChain *atomicBool",
            "+\tisNegotiationNeeded                     *atomic.Bool",
            "+\tupdateNegotiationNeededFlagOnEmptyChain *atomic.Bool",
            " ",
            " \tlastOffer  string",
            " \tlastAnswer string",
            " ",
            " \t// a value containing the last known greater mid value",
            " \t// we internally generate mids as numbers. Needed since JSEP",
            " \t// requires that when reusing a media section a new unique mid",
            "@@ -120,19 +120,19 @@",
            " \t\t\tICEServers:           []ICEServer{},",
            " \t\t\tICETransportPolicy:   ICETransportPolicyAll,",
            " \t\t\tBundlePolicy:         BundlePolicyBalanced,",
            " \t\t\tRTCPMuxPolicy:        RTCPMuxPolicyRequire,",
            " \t\t\tCertificates:         []Certificate{},",
            " \t\t\tICECandidatePoolSize: 0,",
            " \t\t},",
            "-\t\tisClosed:                                &atomicBool{},",
            "+\t\tisClosed:                                &atomic.Bool{},",
            " \t\tisCloseDone:                             make(chan struct{}),",
            " \t\tisGracefulCloseDone:                     make(chan struct{}),",
            "-\t\tisNegotiationNeeded:                     &atomicBool{},",
            "-\t\tupdateNegotiationNeededFlagOnEmptyChain: &atomicBool{},",
            "+\t\tisNegotiationNeeded:                     &atomic.Bool{},",
            "+\t\tupdateNegotiationNeededFlagOnEmptyChain: &atomic.Bool{},",
            " \t\tlastOffer:                               \"\",",
            " \t\tlastAnswer:                              \"\",",
            " \t\tgreaterMid:                              -1,",
            " \t\tsignalingState:                          SignalingStateStable,",
            " ",
            " \t\tapi: api,",
            " \t\tlog: api.settingEngine.LoggerFactory.NewLogger(\"pc\"),",
            "@@ -152,14 +152,15 @@",
            " \t\tinterceptor:   i,",
            " \t}",
            " ",
            " \tif api.settingEngine.disableMediaEngineCopy {",
            " \t\tpc.api.mediaEngine = api.mediaEngine",
            " \t} else {",
            " \t\tpc.api.mediaEngine = api.mediaEngine.copy()",
            "+\t\tpc.api.mediaEngine.setMultiCodecNegotiation(!api.settingEngine.disableMediaEngineMultipleCodecs)",
            " \t}",
            " ",
            " \tif err = pc.initConfiguration(configuration); err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " ",
            " \tpc.iceGatherer, err = pc.createICEGatherer()",
            "@@ -291,58 +292,58 @@",
            " // onNegotiationNeeded enqueues negotiationNeededOp if necessary",
            " // caller of this method should hold `pc.mu` lock",
            " // https://www.w3.org/TR/webrtc/#dfn-update-the-negotiation-needed-flag",
            " func (pc *PeerConnection) onNegotiationNeeded() {",
            " \t// 4.7.3.1 If the length of connection.[[Operations]] is not 0, then set",
            " \t// connection.[[UpdateNegotiationNeededFlagOnEmptyChain]] to true, and abort these steps.",
            " \tif !pc.ops.IsEmpty() {",
            "-\t\tpc.updateNegotiationNeededFlagOnEmptyChain.set(true)",
            "+\t\tpc.updateNegotiationNeededFlagOnEmptyChain.Store(true)",
            " ",
            " \t\treturn",
            " \t}",
            " \tpc.ops.Enqueue(pc.negotiationNeededOp)",
            " }",
            " ",
            " // https://www.w3.org/TR/webrtc/#dfn-update-the-negotiation-needed-flag",
            " func (pc *PeerConnection) negotiationNeededOp() {",
            " \t// 4.7.3.2.1 If connection.[[IsClosed]] is true, abort these steps.",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn",
            " \t}",
            " ",
            " \t// 4.7.3.2.2 If the length of connection.[[Operations]] is not 0,",
            " \t// then set connection.[[UpdateNegotiationNeededFlagOnEmptyChain]] to",
            " \t// true, and abort these steps.",
            " \tif !pc.ops.IsEmpty() {",
            "-\t\tpc.updateNegotiationNeededFlagOnEmptyChain.set(true)",
            "+\t\tpc.updateNegotiationNeededFlagOnEmptyChain.Store(true)",
            " ",
            " \t\treturn",
            " \t}",
            " ",
            " \t// 4.7.3.2.3 If connection's signaling state is not \"stable\", abort these steps.",
            " \tif pc.SignalingState() != SignalingStateStable {",
            " \t\treturn",
            " \t}",
            " ",
            " \t// 4.7.3.2.4 If the result of checking if negotiation is needed is false,",
            " \t// clear the negotiation-needed flag by setting connection.[[NegotiationNeeded]]",
            " \t// to false, and abort these steps.",
            " \tif !pc.checkNegotiationNeeded() {",
            "-\t\tpc.isNegotiationNeeded.set(false)",
            "+\t\tpc.isNegotiationNeeded.Store(false)",
            " ",
            " \t\treturn",
            " \t}",
            " ",
            " \t// 4.7.3.2.5 If connection.[[NegotiationNeeded]] is already true, abort these steps.",
            "-\tif pc.isNegotiationNeeded.get() {",
            "+\tif pc.isNegotiationNeeded.Load() {",
            " \t\treturn",
            " \t}",
            " ",
            " \t// 4.7.3.2.6 Set connection.[[NegotiationNeeded]] to true.",
            "-\tpc.isNegotiationNeeded.set(true)",
            "+\tpc.isNegotiationNeeded.Store(true)",
            " ",
            " \t// 4.7.3.2.7 Fire an event named negotiationneeded at connection.",
            " \tif handler, ok := pc.onNegotiationNeededHandler.Load().(func()); ok && handler != nil {",
            " \t\thandler()",
            " \t}",
            " }",
            " ",
            "@@ -508,15 +509,15 @@",
            " \t\tgo handler(cs)",
            " \t}",
            " }",
            " ",
            " // SetConfiguration updates the configuration of this PeerConnection object.",
            " func (pc *PeerConnection) SetConfiguration(configuration Configuration) error { //nolint:gocognit,cyclop",
            " \t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-setconfiguration (step #2)",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #3)",
            " \tif configuration.PeerIdentity != \"\" {",
            " \t\tif configuration.PeerIdentity != pc.configuration.PeerIdentity {",
            " \t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingPeerIdentity}",
            "@@ -618,15 +619,15 @@",
            " //",
            " //nolint:gocognit,cyclop",
            " func (pc *PeerConnection) CreateOffer(options *OfferOptions) (SessionDescription, error) {",
            " \tuseIdentity := pc.idpLoginURL != nil",
            " \tswitch {",
            " \tcase useIdentity:",
            " \t\treturn SessionDescription{}, errIdentityProviderNotImplemented",
            "-\tcase pc.isClosed.get():",
            "+\tcase pc.isClosed.Load():",
            " \t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tif options != nil && options.ICERestart {",
            " \t\tif err := pc.iceTransport.restart(); err != nil {",
            " \t\t\treturn SessionDescription{}, err",
            " \t\t}",
            "@@ -758,15 +759,15 @@",
            " func (pc *PeerConnection) updateConnectionState(",
            " \ticeConnectionState ICEConnectionState,",
            " \tdtlsTransportState DTLSTransportState,",
            " ) {",
            " \tconnectionState := PeerConnectionStateNew",
            " \tswitch {",
            " \t// The RTCPeerConnection object's [[IsClosed]] slot is true.",
            "-\tcase pc.isClosed.get():",
            "+\tcase pc.isClosed.Load():",
            " \t\tconnectionState = PeerConnectionStateClosed",
            " ",
            " \t// Any of the RTCIceTransports or RTCDtlsTransports are in a \"failed\" state.",
            " \tcase iceConnectionState == ICEConnectionStateFailed || dtlsTransportState == DTLSTransportStateFailed:",
            " \t\tconnectionState = PeerConnectionStateFailed",
            " ",
            " \t// Any of the RTCIceTransports or RTCDtlsTransports are in the \"disconnected\"",
            "@@ -839,15 +840,15 @@",
            " \tuseIdentity := pc.idpLoginURL != nil",
            " \tremoteDesc := pc.RemoteDescription()",
            " \tswitch {",
            " \tcase remoteDesc == nil:",
            " \t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}",
            " \tcase useIdentity:",
            " \t\treturn SessionDescription{}, errIdentityProviderNotImplemented",
            "-\tcase pc.isClosed.get():",
            "+\tcase pc.isClosed.Load():",
            " \t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \tcase pc.signalingState.Get() != SignalingStateHaveRemoteOffer &&",
            " \t\tpc.signalingState.Get() != SignalingStateHaveLocalPranswer:",
            " \t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrIncorrectSignalingState}",
            " \t}",
            " ",
            " \tconnectionRole := connectionRoleFromDtlsRole(pc.api.settingEngine.answeringDTLSRole)",
            "@@ -886,15 +887,15 @@",
            " }",
            " ",
            " // 4.4.1.6 Set the SessionDescription",
            " //",
            " //nolint:gocognit,cyclop",
            " func (pc *PeerConnection) setDescription(sd *SessionDescription, op stateChangeOp) error {",
            " \tswitch {",
            "-\tcase pc.isClosed.get():",
            "+\tcase pc.isClosed.Load():",
            " \t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \tcase NewSDPType(sd.Type.String()) == SDPTypeUnknown:",
            " \t\treturn &rtcerr.TypeError{",
            " \t\t\tErr: fmt.Errorf(\"%w: '%d' is not a valid enum value of type SDPType\", errPeerConnSDPTypeInvalidValue, sd.Type),",
            " \t\t}",
            " \t}",
            " ",
            "@@ -990,30 +991,30 @@",
            " ",
            " \t\treturn nextState, err",
            " \t}()",
            " ",
            " \tif err == nil {",
            " \t\tpc.signalingState.Set(nextState)",
            " \t\tif pc.signalingState.Get() == SignalingStateStable {",
            "-\t\t\tpc.isNegotiationNeeded.set(false)",
            "+\t\t\tpc.isNegotiationNeeded.Store(false)",
            " \t\t\tpc.mu.Lock()",
            " \t\t\tpc.onNegotiationNeeded()",
            " \t\t\tpc.mu.Unlock()",
            " \t\t}",
            " \t\tpc.onSignalingStateChange(nextState)",
            " \t}",
            " ",
            " \treturn err",
            " }",
            " ",
            " // SetLocalDescription sets the SessionDescription of the local peer",
            " //",
            " //nolint:cyclop",
            " func (pc *PeerConnection) SetLocalDescription(desc SessionDescription) error {",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \thaveLocalDescription := pc.currentLocalDescription != nil",
            " ",
            " \t// JSEP 5.4",
            " \tif desc.SDP == \"\" {",
            "@@ -1076,15 +1077,15 @@",
            " \treturn pc.CurrentLocalDescription()",
            " }",
            " ",
            " // SetRemoteDescription sets the SessionDescription of the remote peer",
            " //",
            " //nolint:gocognit,gocyclo,cyclop,maintidx",
            " func (pc *PeerConnection) SetRemoteDescription(desc SessionDescription) error {",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tisRenegotiation := pc.currentRemoteDescription != nil",
            " ",
            " \tif _, err := desc.Unmarshal(); err != nil {",
            " \t\treturn err",
            "@@ -1559,44 +1560,38 @@",
            " \t\t}",
            " \t}",
            " ",
            " \treturn nil",
            " }",
            " ",
            " // Start SCTP subsystem.",
            "-func (pc *PeerConnection) startSCTP() {",
            "+func (pc *PeerConnection) startSCTP(maxMessageSize uint32) {",
            " \t// Start sctp",
            " \tif err := pc.sctpTransport.Start(SCTPCapabilities{",
            "-\t\tMaxMessageSize: 0,",
            "+\t\tMaxMessageSize: maxMessageSize,",
            " \t}); err != nil {",
            " \t\tpc.log.Warnf(\"Failed to start SCTP: %s\", err)",
            " \t\tif err = pc.sctpTransport.Stop(); err != nil {",
            " \t\t\tpc.log.Warnf(\"Failed to stop SCTPTransport: %s\", err)",
            " \t\t}",
            " ",
            " \t\treturn",
            " \t}",
            " }",
            " ",
            "-//nolint:cyclop",
            " func (pc *PeerConnection) handleUndeclaredSSRC(",
            " \tssrc SSRC,",
            "-\tremoteDescription *SessionDescription,",
            "+\tmediaSection *sdp.MediaDescription,",
            " ) (handled bool, err error) {",
            "-\tif len(remoteDescription.parsed.MediaDescriptions) != 1 {",
            "-\t\treturn false, nil",
            "-\t}",
            "-",
            "-\tonlyMediaSection := remoteDescription.parsed.MediaDescriptions[0]",
            " \tstreamID := \"\"",
            " \tid := \"\"",
            " \thasRidAttribute := false",
            " \thasSSRCAttribute := false",
            " ",
            "-\tfor _, a := range onlyMediaSection.Attributes {",
            "+\tfor _, a := range mediaSection.Attributes {",
            " \t\tswitch a.Key {",
            " \t\tcase sdp.AttrKeyMsid:",
            " \t\t\tif split := strings.Split(a.Value, \" \"); len(split) == 2 {",
            " \t\t\t\tstreamID = split[0]",
            " \t\t\t\tid = split[1]",
            " \t\t\t}",
            " \t\tcase sdp.AttrKeySSRC:",
            "@@ -1605,24 +1600,24 @@",
            " \t\t\thasRidAttribute = true",
            " \t\t}",
            " \t}",
            " ",
            " \tif hasRidAttribute {",
            " \t\treturn false, nil",
            " \t} else if hasSSRCAttribute {",
            "-\t\treturn false, errPeerConnSingleMediaSectionHasExplicitSSRC",
            "+\t\treturn false, errMediaSectionHasExplictSSRCAttribute",
            " \t}",
            " ",
            " \tincoming := trackDetails{",
            " \t\tssrcs:    []SSRC{ssrc},",
            " \t\tkind:     RTPCodecTypeVideo,",
            " \t\tstreamID: streamID,",
            " \t\tid:       id,",
            " \t}",
            "-\tif onlyMediaSection.MediaName.Media == RTPCodecTypeAudio.String() {",
            "+\tif mediaSection.MediaName.Media == RTPCodecTypeAudio.String() {",
            " \t\tincoming.kind = RTPCodecTypeAudio",
            " \t}",
            " ",
            " \tt, err := pc.AddTransceiverFromKind(incoming.kind, RTPTransceiverInit{",
            " \t\tDirection: RTPTransceiverDirectionSendrecv,",
            " \t})",
            " \tif err != nil {",
            "@@ -1632,14 +1627,46 @@",
            " ",
            " \tpc.configureReceiver(incoming, t.Receiver())",
            " \tpc.startReceiver(incoming, t.Receiver())",
            " ",
            " \treturn true, nil",
            " }",
            " ",
            "+// For legacy clients that didn't support urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id",
            "+// or urn:ietf:params:rtp-hdrext:sdes:mid extension, and didn't declare a=ssrc lines.",
            "+// Assumes that the payload type is unique across the media section.",
            "+func (pc *PeerConnection) findMediaSectionByPayloadType(",
            "+\tpayloadType PayloadType,",
            "+\tremoteDescription *SessionDescription,",
            "+) (selectedMediaSection *sdp.MediaDescription, ok bool) {",
            "+\tfor i := range remoteDescription.parsed.MediaDescriptions {",
            "+\t\tdescr := remoteDescription.parsed.MediaDescriptions[i]",
            "+\t\tmedia := descr.MediaName.Media",
            "+\t\tif !strings.EqualFold(media, \"video\") && !strings.EqualFold(media, \"audio\") {",
            "+\t\t\tcontinue",
            "+\t\t}",
            "+",
            "+\t\tformats := descr.MediaName.Formats",
            "+\t\tfor _, payloadStr := range formats {",
            "+\t\t\tpayload, err := strconv.ParseUint(payloadStr, 10, 8)",
            "+\t\t\tif err != nil {",
            "+\t\t\t\tcontinue",
            "+\t\t\t}",
            "+",
            "+\t\t\t// Return the first media section that has the payload type.",
            "+\t\t\t// Assuming that the payload type is unique across the media section.",
            "+\t\t\tif PayloadType(payload) == payloadType {",
            "+\t\t\t\treturn remoteDescription.parsed.MediaDescriptions[i], true",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn nil, false",
            "+}",
            "+",
            " // Chrome sends probing traffic on SSRC 0. This reads the packets to ensure that we properly",
            " // generate TWCC reports for it. Since this isn't actually media we don't pass this to the user.",
            " func (pc *PeerConnection) handleNonMediaBandwidthProbe() {",
            " \tnonMediaBandwidthProbe, err := pc.api.NewRTPReceiver(RTPCodecTypeVideo, pc.dtlsTransport)",
            " \tif err != nil {",
            " \t\tpc.log.Errorf(\"handleNonMediaBandwidthProbe failed to create RTPReceiver: %v\", err)",
            " ",
            "@@ -1661,72 +1688,92 @@",
            " \t\t\tpc.log.Tracef(\"handleNonMediaBandwidthProbe read exiting: %v\", err)",
            " ",
            " \t\t\treturn",
            " \t\t}",
            " \t}",
            " }",
            " ",
            "-func (pc *PeerConnection) handleIncomingSSRC(rtpStream io.Reader, ssrc SSRC) error { //nolint:gocognit,cyclop",
            "+func (pc *PeerConnection) handleIncomingSSRC(rtpStream io.Reader, ssrc SSRC) error { //nolint:gocyclo,gocognit,cyclop",
            " \tremoteDescription := pc.RemoteDescription()",
            " \tif remoteDescription == nil {",
            " \t\treturn errPeerConnRemoteDescriptionNil",
            " \t}",
            " ",
            " \t// If a SSRC already exists in the RemoteDescription don't perform heuristics upon it",
            " \tfor _, track := range trackDetailsFromSDP(pc.log, remoteDescription.parsed) {",
            "-\t\tif track.repairSsrc != nil && ssrc == *track.repairSsrc {",
            "+\t\tif track.rtxSsrc != nil && ssrc == *track.rtxSsrc {",
            "+\t\t\treturn nil",
            "+\t\t}",
            "+\t\tif track.fecSsrc != nil && ssrc == *track.fecSsrc {",
            " \t\t\treturn nil",
            " \t\t}",
            " \t\tfor _, trackSsrc := range track.ssrcs {",
            " \t\t\tif ssrc == trackSsrc {",
            " \t\t\t\treturn nil",
            " \t\t\t}",
            " \t\t}",
            " \t}",
            " ",
            "-\t// If the remote SDP was only one media section the ssrc doesn't have to be explicitly declared",
            "-\tif handled, err := pc.handleUndeclaredSSRC(ssrc, remoteDescription); handled || err != nil {",
            "+\t// if the SSRC is not declared in the SDP and there is only one media section,",
            "+\t// we attempt to resolve it using this single section",
            "+\t// This applies even if the client supports RTP extensions:",
            "+\t// (urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id and urn:ietf:params:rtp-hdrext:sdes:mid)",
            "+\t// and even if the RTP stream contains an incorrect MID or RID.",
            "+\t// while this can be incorrect, this is done to maintain compatibility with older behavior.",
            "+\tif len(remoteDescription.parsed.MediaDescriptions) == 1 {",
            "+\t\tmediaSection := remoteDescription.parsed.MediaDescriptions[0]",
            "+\t\tif handled, err := pc.handleUndeclaredSSRC(ssrc, mediaSection); handled || err != nil {",
            "+\t\t\treturn err",
            "+\t\t}",
            "+\t}",
            "+",
            "+\t// We read the RTP packet to determine the payload type",
            "+\tb := make([]byte, pc.api.settingEngine.getReceiveMTU())",
            "+",
            "+\ti, err := rtpStream.Read(b)",
            "+\tif err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\tif i < 4 {",
            "+\t\treturn errRTPTooShort",
            "+\t}",
            "+",
            "+\tpayloadType := PayloadType(b[1] & 0x7f)",
            "+\tparams, err := pc.api.mediaEngine.getRTPParametersByPayloadType(payloadType)",
            "+\tif err != nil {",
            " \t\treturn err",
            " \t}",
            " ",
            " \tmidExtensionID, audioSupported, videoSupported := pc.api.mediaEngine.getHeaderExtensionID(",
            " \t\tRTPHeaderExtensionCapability{sdp.SDESMidURI},",
            " \t)",
            " \tif !audioSupported && !videoSupported {",
            "+\t\t// try to find media section by payload type as a last resort for legacy clients.",
            "+\t\tmediaSection, ok := pc.findMediaSectionByPayloadType(payloadType, remoteDescription)",
            "+\t\tif ok {",
            "+\t\t\tif ok, err = pc.handleUndeclaredSSRC(ssrc, mediaSection); ok || err != nil {",
            "+\t\t\t\treturn err",
            "+\t\t\t}",
            "+\t\t}",
            "+",
            " \t\treturn errPeerConnSimulcastMidRTPExtensionRequired",
            " \t}",
            " ",
            " \tstreamIDExtensionID, audioSupported, videoSupported := pc.api.mediaEngine.getHeaderExtensionID(",
            " \t\tRTPHeaderExtensionCapability{sdp.SDESRTPStreamIDURI},",
            " \t)",
            " \tif !audioSupported && !videoSupported {",
            " \t\treturn errPeerConnSimulcastStreamIDRTPExtensionRequired",
            " \t}",
            " ",
            " \trepairStreamIDExtensionID, _, _ := pc.api.mediaEngine.getHeaderExtensionID(",
            " \t\tRTPHeaderExtensionCapability{sdp.SDESRepairRTPStreamIDURI},",
            " \t)",
            " ",
            "-\tb := make([]byte, pc.api.settingEngine.getReceiveMTU())",
            "-",
            "-\ti, err := rtpStream.Read(b)",
            "-\tif err != nil {",
            "-\t\treturn err",
            "-\t}",
            "-",
            "-\tif i < 4 {",
            "-\t\treturn errRTPTooShort",
            "-\t}",
            "-",
            "-\tpayloadType := PayloadType(b[1] & 0x7f)",
            "-\tparams, err := pc.api.mediaEngine.getRTPParametersByPayloadType(payloadType)",
            "-\tif err != nil {",
            "-\t\treturn err",
            "-\t}",
            "-",
            " \tstreamInfo := createStreamInfo(",
            " \t\t\"\",",
            " \t\tssrc,",
            " \t\t0, 0,",
            " \t\tparams.Codecs[0].PayloadType,",
            " \t\t0, 0,",
            " \t\tparams.Codecs[0].RTPCodecCapability,",
            "@@ -1835,15 +1882,15 @@",
            " \t\tsrtcpReadStream, err := srtcpSession.OpenReadStream(ssrc)",
            " \t\tif err != nil {",
            " \t\t\tpc.log.Warnf(\"Failed to open RTCP stream for %d: %v\", ssrc, err)",
            " ",
            " \t\t\treturn",
            " \t\t}",
            " ",
            "-\t\tif pc.isClosed.get() {",
            "+\t\tif pc.isClosed.Load() {",
            " \t\t\tif err = srtpReadStream.Close(); err != nil {",
            " \t\t\t\tpc.log.Warnf(\"Failed to close RTP stream %v\", err)",
            " \t\t\t}",
            " \t\t\tif err = srtcpReadStream.Close(); err != nil {",
            " \t\t\t\tpc.log.Warnf(\"Failed to close RTCP stream %v\", err)",
            " \t\t\t}",
            " ",
            "@@ -1914,41 +1961,73 @@",
            " ",
            " \treturn pc.currentRemoteDescription",
            " }",
            " ",
            " // AddICECandidate accepts an ICE candidate string and adds it",
            " // to the existing set of candidates.",
            " func (pc *PeerConnection) AddICECandidate(candidate ICECandidateInit) error {",
            "-\tif pc.RemoteDescription() == nil {",
            "+\tremoteDesc := pc.RemoteDescription()",
            "+\tif remoteDesc == nil {",
            " \t\treturn &rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}",
            " \t}",
            " ",
            " \tcandidateValue := strings.TrimPrefix(candidate.Candidate, \"candidate:\")",
            " ",
            "-\tvar iceCandidate *ICECandidate",
            "-\tif candidateValue != \"\" {",
            "-\t\tcandidate, err := ice.UnmarshalCandidate(candidateValue)",
            "-\t\tif err != nil {",
            "-\t\t\tif errors.Is(err, ice.ErrUnknownCandidateTyp) || errors.Is(err, ice.ErrDetermineNetworkType) {",
            "-\t\t\t\tpc.log.Warnf(\"Discarding remote candidate: %s\", err)",
            "+\tif candidateValue == \"\" {",
            "+\t\treturn pc.iceTransport.AddRemoteCandidate(nil)",
            "+\t}",
            " ",
            "-\t\t\t\treturn nil",
            "-\t\t\t}",
            "+\tcand, err := ice.UnmarshalCandidate(candidateValue)",
            "+\tif err != nil {",
            "+\t\tif errors.Is(err, ice.ErrUnknownCandidateTyp) || errors.Is(err, ice.ErrDetermineNetworkType) {",
            "+\t\t\tpc.log.Warnf(\"Discarding remote candidate: %s\", err)",
            " ",
            "-\t\t\treturn err",
            "+\t\t\treturn nil",
            " \t\t}",
            " ",
            "-\t\tc, err := newICECandidateFromICE(candidate, \"\", 0)",
            "-\t\tif err != nil {",
            "-\t\t\treturn err",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\t// Reject candidates from old generations.",
            "+\t// If candidate.usernameFragment is not null,",
            "+\t// and is not equal to any username fragment present in the corresponding media",
            "+\t//  description of an applied remote description,",
            "+\t// return a promise rejected with a newly created OperationError.",
            "+\t// https://w3c.github.io/webrtc-pc/#dom-peerconnection-addicecandidate",
            "+\tif ufrag, ok := cand.GetExtension(\"ufrag\"); ok {",
            "+\t\tif !pc.descriptionContainsUfrag(remoteDesc.parsed, ufrag.Value) {",
            "+\t\t\tpc.log.Errorf(\"dropping candidate with ufrag %s because it doesn't match the current ufrags\", ufrag.Value)",
            "+",
            "+\t\t\treturn nil",
            " \t\t}",
            "-\t\ticeCandidate = &c",
            " \t}",
            " ",
            "-\treturn pc.iceTransport.AddRemoteCandidate(iceCandidate)",
            "+\tc, err := newICECandidateFromICE(cand, \"\", 0)",
            "+\tif err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\treturn pc.iceTransport.AddRemoteCandidate(&c)",
            "+}",
            "+",
            "+// Return true if the sdp contains a specific ufrag.",
            "+func (pc *PeerConnection) descriptionContainsUfrag(sdp *sdp.SessionDescription, matchUfrag string) bool {",
            "+\tufrag, ok := sdp.Attribute(\"ice-ufrag\")",
            "+\tif ok && ufrag == matchUfrag {",
            "+\t\treturn true",
            "+\t}",
            "+",
            "+\tfor _, media := range sdp.MediaDescriptions {",
            "+\t\tufrag, ok := media.Attribute(\"ice-ufrag\")",
            "+\t\tif ok && ufrag == matchUfrag {",
            "+\t\t\treturn true",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn false",
            " }",
            " ",
            " // ICEConnectionState returns the ICE connection state of the",
            " // PeerConnection instance.",
            " func (pc *PeerConnection) ICEConnectionState() ICEConnectionState {",
            " \tif state, ok := pc.iceConnectionState.Load().(ICEConnectionState); ok {",
            " \t\treturn state",
            "@@ -1993,15 +2072,15 @@",
            " \treturn pc.rtpTransceivers",
            " }",
            " ",
            " // AddTrack adds a Track to the PeerConnection.",
            " //",
            " //nolint:cyclop",
            " func (pc *PeerConnection) AddTrack(track TrackLocal) (*RTPSender, error) {",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tpc.mu.Lock()",
            " \tdefer pc.mu.Unlock()",
            " \tfor _, transceiver := range pc.rtpTransceivers {",
            " \t\tcurrentDirection := transceiver.getCurrentDirection()",
            "@@ -2035,15 +2114,15 @@",
            " \tpc.addRTPTransceiver(transceiver)",
            " ",
            " \treturn transceiver.Sender(), nil",
            " }",
            " ",
            " // RemoveTrack removes a Track from the PeerConnection.",
            " func (pc *PeerConnection) RemoveTrack(sender *RTPSender) (err error) {",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tvar transceiver *RTPTransceiver",
            " \tpc.mu.Lock()",
            " \tdefer pc.mu.Unlock()",
            " \tfor _, t := range pc.rtpTransceivers {",
            "@@ -2103,15 +2182,15 @@",
            " // AddTransceiverFromKind Create a new RtpTransceiver and adds it to the set of transceivers.",
            " //",
            " //nolint:cyclop",
            " func (pc *PeerConnection) AddTransceiverFromKind(",
            " \tkind RTPCodecType,",
            " \tinit ...RTPTransceiverInit,",
            " ) (t *RTPTransceiver, err error) {",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tdirection := RTPTransceiverDirectionSendrecv",
            " \tif len(init) > 1 {",
            " \t\treturn nil, errPeerConnAddTransceiverFromKindOnlyAcceptsOne",
            " \t} else if len(init) == 1 {",
            "@@ -2148,15 +2227,15 @@",
            " }",
            " ",
            " // AddTransceiverFromTrack Create a new RtpTransceiver(SendRecv or SendOnly) and add it to the set of transceivers.",
            " func (pc *PeerConnection) AddTransceiverFromTrack(",
            " \ttrack TrackLocal,",
            " \tinit ...RTPTransceiverInit,",
            " ) (t *RTPTransceiver, err error) {",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tdirection := RTPTransceiverDirectionSendrecv",
            " \tif len(init) > 1 {",
            " \t\treturn nil, errPeerConnAddTransceiverFromTrackOnlyAcceptsOne",
            " \t} else if len(init) == 1 {",
            "@@ -2176,15 +2255,15 @@",
            " // CreateDataChannel creates a new DataChannel object with the given label",
            " // and optional DataChannelInit used to configure properties of the",
            " // underlying channel such as data reliability.",
            " //",
            " //nolint:cyclop",
            " func (pc *PeerConnection) CreateDataChannel(label string, options *DataChannelInit) (*DataChannel, error) {",
            " \t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #2)",
            "-\tif pc.isClosed.get() {",
            "+\tif pc.isClosed.Load() {",
            " \t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}",
            " \t}",
            " ",
            " \tparams := &DataChannelParameters{",
            " \t\tLabel:   label,",
            " \t\tOrdered: true,",
            " \t}",
            "@@ -2297,15 +2376,15 @@",
            " \t// A lock in this critical section is needed because pc.isClosed and",
            " \t// pc.isGracefullyClosingOrClosed are related to each other in that we",
            " \t// want to make graceful and normal closure one time operations in order",
            " \t// to avoid any double closure errors from cropping up. However, there are",
            " \t// some overlapping close cases when both normal and graceful close are used",
            " \t// that should be idempotent, but be cautioned when writing new close behavior",
            " \t// to preserve this property.",
            "-\tisAlreadyClosingOrClosed := pc.isClosed.swap(true)",
            "+\tisAlreadyClosingOrClosed := pc.isClosed.Swap(true)",
            " \tisAlreadyGracefullyClosingOrClosed := pc.isGracefullyClosingOrClosed",
            " \tif shouldGracefullyClose && !isAlreadyGracefullyClosingOrClosed {",
            " \t\tpc.isGracefullyClosingOrClosed = true",
            " \t}",
            " \tpc.mu.Unlock()",
            " ",
            " \tif isAlreadyClosingOrClosed {",
            "@@ -2585,15 +2664,15 @@",
            " \tif err != nil {",
            " \t\tpc.log.Warnf(\"Failed to start manager: %s\", err)",
            " ",
            " \t\treturn",
            " \t}",
            " ",
            " \tpc.dtlsTransport.internalOnCloseHandler = func() {",
            "-\t\tif pc.isClosed.get() || pc.api.settingEngine.disableCloseByDTLS {",
            "+\t\tif pc.isClosed.Load() || pc.api.settingEngine.disableCloseByDTLS {",
            " \t\t\treturn",
            " \t\t}",
            " ",
            " \t\tpc.log.Info(\"Closing PeerConnection from DTLS CloseNotify\")",
            " \t\tgo func() {",
            " \t\t\tif pcClosErr := pc.Close(); pcClosErr != nil {",
            " \t\t\t\tpc.log.Warnf(\"Failed to close PeerConnection from DTLS CloseNotify: %s\", pcClosErr)",
            "@@ -2621,16 +2700,16 @@",
            " \tcurrentTransceivers []*RTPTransceiver,",
            " ) {",
            " \tif !isRenegotiation {",
            " \t\tpc.undeclaredMediaProcessor()",
            " \t}",
            " ",
            " \tpc.startRTPReceivers(remoteDesc, currentTransceivers)",
            "-\tif haveApplicationMediaSection(remoteDesc.parsed) {",
            "-\t\tpc.startSCTP()",
            "+\tif d := haveDataChannel(remoteDesc); d != nil {",
            "+\t\tpc.startSCTP(getMaxMessageSize(d))",
            " \t}",
            " }",
            " ",
            " // generateUnmatchedSDP generates an SDP that doesn't take remote state into account",
            " // This is used for the initial call for CreateOffer.",
            " //",
            " //nolint:cyclop",
            "@@ -2638,15 +2717,15 @@",
            " \ttransceivers []*RTPTransceiver,",
            " \tuseIdentity bool,",
            " ) (*sdp.SessionDescription, error) {",
            " \tdesc, err := sdp.NewJSEPSessionDescription(useIdentity)",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            "-\tdesc.Attributes = append(desc.Attributes, sdp.Attribute{Key: sdp.AttrKeyMsidSemantic, Value: \"WMS*\"})",
            "+\tdesc.Attributes = append(desc.Attributes, sdp.Attribute{Key: sdp.AttrKeyMsidSemantic, Value: \"WMS *\"})",
            " ",
            " \ticeParams, err := pc.iceGatherer.GetLocalParameters()",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " ",
            " \tcandidates, err := pc.iceGatherer.GetLocalCandidates()",
            "@@ -2714,14 +2793,15 @@",
            " \t\tpc.api.mediaEngine,",
            " \t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\tcandidates,",
            " \t\ticeParams,",
            " \t\tmediaSections,",
            " \t\tpc.ICEGatheringState(),",
            " \t\tnil,",
            "+\t\tpc.api.settingEngine.getSCTPMaxMessageSize(),",
            " \t)",
            " }",
            " ",
            " // generateMatchedSDP generates a SDP and takes the remote state into account",
            " // this is used everytime we have a RemoteDescription",
            " //",
            " //nolint:gocognit,gocyclo,cyclop",
            "@@ -2730,15 +2810,15 @@",
            " \tuseIdentity, includeUnmatched bool,",
            " \tconnectionRole sdp.ConnectionRole,",
            " ) (*sdp.SessionDescription, error) {",
            " \tdesc, err := sdp.NewJSEPSessionDescription(useIdentity)",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            "-\tdesc.Attributes = append(desc.Attributes, sdp.Attribute{Key: sdp.AttrKeyMsidSemantic, Value: \"WMS*\"})",
            "+\tdesc.Attributes = append(desc.Attributes, sdp.Attribute{Key: sdp.AttrKeyMsidSemantic, Value: \"WMS *\"})",
            " ",
            " \ticeParams, err := pc.iceGatherer.GetLocalParameters()",
            " \tif err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " ",
            " \tcandidates, err := pc.iceGatherer.GetLocalCandidates()",
            "@@ -2832,14 +2912,17 @@",
            " \t\t\tmediaSections = append(",
            " \t\t\t\tmediaSections,",
            " \t\t\t\tmediaSection{id: midValue, transceivers: mediaTransceivers, matchExtensions: extensions, rids: getRids(media)},",
            " \t\t\t)",
            " \t\t}",
            " \t}",
            " ",
            "+\tpc.sctpTransport.lock.Lock()",
            "+\tdefer pc.sctpTransport.lock.Unlock()",
            "+",
            " \tvar bundleGroup *string",
            " \t// If we are offering also include unmatched local transceivers",
            " \tif includeUnmatched { //nolint:nestif",
            " \t\tif !detectedPlanB {",
            " \t\t\tfor _, t := range localTransceivers {",
            " \t\t\t\tif sender := t.Sender(); sender != nil {",
            " \t\t\t\t\tsender.setNegotiated()",
            "@@ -2880,14 +2963,15 @@",
            " \t\tpc.api.mediaEngine,",
            " \t\tconnectionRole,",
            " \t\tcandidates,",
            " \t\ticeParams,",
            " \t\tmediaSections,",
            " \t\tpc.ICEGatheringState(),",
            " \t\tbundleGroup,",
            "+\t\tpc.api.settingEngine.getSCTPMaxMessageSize(),",
            " \t)",
            " }",
            " ",
            " func (pc *PeerConnection) setGatherCompleteHandler(handler func()) {",
            " \tpc.iceGatherer.onGatheringCompleteHandler.Store(handler)",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_close_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_close_test.go",
            "+++ /home/webrtc-4.1.3/peerconnection_close_test.go",
            "@@ -21,17 +21,15 @@",
            " \tlim := test.TimeOut(time.Second * 20)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tawaitSetup := make(chan struct{})",
            " \tpcAnswer.OnDataChannel(func(d *DataChannel) {",
            " \t\t// Make sure this is the data channel we were looking for. (Not the one",
            " \t\t// created in signalPair).",
            " \t\tif d.Label() != \"data\" {",
            " \t\t\treturn",
            "@@ -43,22 +41,17 @@",
            " \tpcAnswer.OnICEConnectionStateChange(func(i ICEConnectionState) {",
            " \t\tif i == ICEConnectionStateClosed {",
            " \t\t\tclose(awaitICEClosed)",
            " \t\t}",
            " \t})",
            " ",
            " \t_, err = pcOffer.CreateDataChannel(\"data\", nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\terr = signalPair(pcOffer, pcAnswer)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \t<-awaitSetup",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " ",
            " \t<-awaitICEClosed",
            " }",
            "@@ -69,33 +62,25 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t_, err = pcOffer.CreateDataChannel(\"test-channel\", nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tanswer, err := pcOffer.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tassert.NoError(t, pcOffer.Close())",
            " ",
            "-\tif err = pcAnswer.SetRemoteDescription(answer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcAnswer.SetRemoteDescription(answer))",
            " ",
            " \tfor {",
            " \t\tif pcAnswer.iceTransport.State() == ICETransportStateChecking {",
            " \t\t\tbreak",
            " \t\t}",
            " \t\ttime.Sleep(time.Second / 4)",
            " \t}",
            "@@ -116,17 +101,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \tclosedOffer := make(chan struct{})",
            " \tclosedAnswer := make(chan struct{})",
            " \tpcAnswer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {",
            " \t\tif iceState == ICEConnectionStateConnected {",
            " \t\t\tgo func() {",
            " \t\t\t\tassert.NoError(t, pcAnswer.Close())",
            " \t\t\t\tclose(closedAnswer)",
            "@@ -134,196 +117,149 @@",
            " \t\t\t\tassert.NoError(t, pcOffer.Close())",
            " \t\t\t\tclose(closedOffer)",
            " \t\t\t}()",
            " \t\t}",
            " \t})",
            " ",
            " \t_, err = pcOffer.CreateDataChannel(\"test-channel\", nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \toffer, err := pcOffer.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tofferGatheringComplete := GatheringCompletePromise(pcOffer)",
            "-\tif err = pcOffer.SetLocalDescription(offer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            " \t<-offerGatheringComplete",
            " ",
            "-\tif err = pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))",
            " ",
            " \tanswer, err := pcAnswer.CreateAnswer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)",
            "-\tif err = pcAnswer.SetLocalDescription(answer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))",
            " \t<-answerGatheringComplete",
            "-\tif err = pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))",
            " ",
            " \tselect {",
            " \tcase <-closedAnswer:",
            " \tcase <-time.After(5 * time.Second):",
            "-\t\tt.Error(\"pcAnswer.Close() Timeout\")",
            "+\t\tassert.Fail(t, \"pcAnswer.Close() Timeout\")",
            " \t}",
            " \tselect {",
            " \tcase <-closedOffer:",
            " \tcase <-time.After(5 * time.Second):",
            "-\t\tt.Error(\"pcOffer.Close() Timeout\")",
            "+\t\tassert.Fail(t, \"pcOffer.Close() Timeout\")",
            " \t}",
            " }",
            " ",
            " func TestPeerConnection_GracefulCloseWithIncomingMessages(t *testing.T) {",
            " \t// Limit runtime in case of deadlocks",
            " \tlim := test.TimeOut(time.Second * 20)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutinesStrict(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvar dcAnswer *DataChannel",
            " \tanswerDataChannelOpened := make(chan struct{})",
            " \tpcAnswer.OnDataChannel(func(d *DataChannel) {",
            " \t\t// Make sure this is the data channel we were looking for. (Not the one",
            " \t\t// created in signalPair).",
            " \t\tif d.Label() != \"data\" {",
            " \t\t\treturn",
            " \t\t}",
            " \t\tdcAnswer = d",
            " \t\tclose(answerDataChannelOpened)",
            " \t})",
            " ",
            " \tdcOffer, err := pcOffer.CreateDataChannel(\"data\", nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tofferDataChannelOpened := make(chan struct{})",
            " \tdcOffer.OnOpen(func() {",
            " \t\tclose(offerDataChannelOpened)",
            " \t})",
            " ",
            "-\terr = signalPair(pcOffer, pcAnswer)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \t<-offerDataChannelOpened",
            " \t<-answerDataChannelOpened",
            " ",
            " \tmsgNum := 0",
            " \tdcOffer.OnMessage(func(_ DataChannelMessage) {",
            " \t\tt.Log(\"msg\", msgNum)",
            " \t\tmsgNum++",
            " \t})",
            " ",
            " \t// send 50 messages, then close pcOffer, and then send another 50",
            " \tfor i := 0; i < 100; i++ {",
            " \t\tif i == 50 {",
            "-\t\t\terr = pcOffer.GracefulClose()",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Fatal(err)",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, pcOffer.GracefulClose())",
            " \t\t}",
            " \t\t_ = dcAnswer.Send([]byte(\"hello!\"))",
            " \t}",
            " ",
            "-\terr = pcAnswer.GracefulClose()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcAnswer.GracefulClose())",
            " }",
            " ",
            " func TestPeerConnection_GracefulCloseWhileOpening(t *testing.T) {",
            " \t// Limit runtime in case of deadlocks",
            " \tlim := test.TimeOut(time.Second * 5)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutinesStrict(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif _, err = pcOffer.CreateDataChannel(\"initial_data_channel\", nil); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\t_, err = pcOffer.CreateDataChannel(\"initial_data_channel\", nil)",
            "+\tassert.NoError(t, err)",
            " ",
            " \toffer, err := pcOffer.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \tofferGatheringComplete := GatheringCompletePromise(pcOffer)",
            "-\tif err = pcOffer.SetLocalDescription(offer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            " \t<-offerGatheringComplete",
            " ",
            "-\terr = pcOffer.GracefulClose()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcOffer.GracefulClose())",
            " ",
            "-\tif err = pcAnswer.SetRemoteDescription(offer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))",
            " ",
            " \terr = pcAnswer.GracefulClose()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " }",
            " ",
            " func TestPeerConnection_GracefulCloseConcurrent(t *testing.T) {",
            " \t// Limit runtime in case of deadlocks",
            " \tlim := test.TimeOut(time.Second * 10)",
            " \tdefer lim.Stop()",
            " ",
            " \tfor _, mixed := range []bool{false, true} {",
            " \t\tt.Run(fmt.Sprintf(\"mixed_graceful=%t\", mixed), func(t *testing.T) {",
            " \t\t\treport := test.CheckRoutinesStrict(t)",
            " \t\t\tdefer report()",
            " ",
            " \t\t\tpc, err := NewPeerConnection(Configuration{})",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Fatal(err)",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, err)",
            " ",
            " \t\t\tconst gracefulCloseConcurrency = 50",
            " \t\t\tvar wg sync.WaitGroup",
            " \t\t\twg.Add(gracefulCloseConcurrency)",
            " \t\t\tfor i := 0; i < gracefulCloseConcurrency; i++ {",
            " \t\t\t\tgo func() {",
            " \t\t\t\t\tdefer wg.Done()",
            " \t\t\t\t\tassert.NoError(t, pc.GracefulClose())",
            " \t\t\t\t}()",
            " \t\t\t}",
            " \t\t\tif !mixed {",
            "-\t\t\t\tif err := pc.Close(); err != nil {",
            "-\t\t\t\t\tt.Fatal(err)",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, pc.Close())",
            " \t\t\t} else {",
            "-\t\t\t\tif err := pc.GracefulClose(); err != nil {",
            "-\t\t\t\t\tt.Fatal(err)",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, pc.GracefulClose())",
            " \t\t\t}",
            " \t\t\twg.Wait()",
            " \t\t})",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_go_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_go_test.go",
            "+++ /home/webrtc-4.1.3/peerconnection_go_test.go",
            "@@ -11,23 +11,25 @@",
            " \t\"context\"",
            " \t\"crypto/ecdsa\"",
            " \t\"crypto/elliptic\"",
            " \t\"crypto/rand\"",
            " \t\"crypto/x509\"",
            " \t\"fmt\"",
            " \t\"math/big\"",
            "-\t\"reflect\"",
            "+\t\"net\"",
            " \t\"regexp\"",
            " \t\"strings\"",
            " \t\"sync\"",
            "+\t\"sync/atomic\"",
            " \t\"testing\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/dtls/v3\"",
            " \t\"github.com/pion/ice/v4\"",
            "+\t\"github.com/pion/logging\"",
            " \t\"github.com/pion/rtcp\"",
            " \t\"github.com/pion/rtp\"",
            " \t\"github.com/pion/transport/v3/test\"",
            " \t\"github.com/pion/transport/v3/vnet\"",
            " \t\"github.com/pion/webrtc/v4/internal/util\"",
            " \t\"github.com/pion/webrtc/v4/pkg/rtcerr\"",
            " \t\"github.com/stretchr/testify/assert\"",
            "@@ -269,22 +271,20 @@",
            " \t\t\t\t\t},",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t\twantErr: &rtcerr.InvalidAccessError{Err: ErrNoTurnCredentials},",
            " \t\t},",
            " \t} {",
            " \t\tpc, err := test.init()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"SetConfiguration %q: init failed: %v\", test.name, err)",
            "-\t\t}",
            "+\t\tassert.NoErrorf(t, err, \"SetConfiguration %q: init failed\", test.name)",
            " ",
            " \t\terr = pc.SetConfiguration(test.config)",
            "-\t\tif got, want := err, test.wantErr; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Errorf(\"SetConfiguration %q: err = %v, want %v\", test.name, got, want)",
            "-\t\t}",
            "+\t\t// This is supposed to be assert.Equal, and not assert.ErrorIs,",
            "+\t\t// The error is a pointer to a struct.",
            "+\t\tassert.Equal(t, test.wantErr, err, \"SetConfiguration %q\", test.name)",
            " ",
            " \t\tassert.NoError(t, pc.Close())",
            " \t}",
            " }",
            " ",
            " func TestPeerConnection_EventHandlers_Go(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 5)",
            "@@ -347,30 +347,26 @@",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tapi := NewAPI()",
            " \tofferPC, answerPC, err := api.newPair(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t// Drop all incoming DTLS traffic",
            " \tdropAllDTLS := func([]byte) bool {",
            " \t\treturn false",
            " \t}",
            " \tofferPC.dtlsTransport.dtlsMatcher = dropAllDTLS",
            " \tanswerPC.dtlsTransport.dtlsMatcher = dropAllDTLS",
            " ",
            "-\tif err = signalPair(offerPC, answerPC); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, signalPair(offerPC, answerPC))",
            " ",
            "-\ticeComplete := make(chan interface{})",
            "+\ticeComplete := make(chan any)",
            " \tanswerPC.OnICEConnectionStateChange(func(iceState ICEConnectionState) {",
            " \t\tif iceState == ICEConnectionStateConnected {",
            " \t\t\ttime.Sleep(time.Second) // Give time for DTLS to start",
            " ",
            " \t\t\tselect {",
            " \t\t\tcase <-iceComplete:",
            " \t\t\tdefault:",
            "@@ -404,21 +400,17 @@",
            " }",
            " ",
            " func TestPeerConnection_AnswerWithoutOffer(t *testing.T) {",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Errorf(\"New PeerConnection: got error: %v\", err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \t_, err = pc.CreateAnswer(nil)",
            "-\tif !reflect.DeepEqual(&rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}, err) {",
            "-\t\tt.Errorf(\"CreateAnswer without RemoteDescription: got error: %v\", err)",
            "-\t}",
            "+\tassert.Equal(t, &rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}, err)",
            " ",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestPeerConnection_AnswerWithClosedConnection(t *testing.T) {",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            "@@ -515,38 +507,24 @@",
            " ",
            " \t\t\t[]*RTPTransceiver{",
            " \t\t\t\tcreateTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly),",
            " \t\t\t\tcreateTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionSendrecv),",
            " \t\t\t},",
            " \t\t},",
            " \t} {",
            "-\t\tif len(test.kinds) != len(test.directions) {",
            "-\t\t\tt.Fatal(\"Kinds and Directions must be the same length\")",
            "-\t\t}",
            "-",
            "+\t\tassert.Len(t, test.kinds, len(test.directions), \"Kinds and Directions must be the same length\")",
            " \t\tgot := []*RTPTransceiver{}",
            " \t\tfor i := range test.kinds {",
            " \t\t\tres, filteredLocalTransceivers := satisfyTypeAndDirection(test.kinds[i], test.directions[i], test.localTransceivers)",
            " ",
            " \t\t\tgot = append(got, res)",
            " \t\t\ttest.localTransceivers = filteredLocalTransceivers",
            " \t\t}",
            " ",
            "-\t\tif !reflect.DeepEqual(got, test.want) {",
            "-\t\t\tgotStr := \"\"",
            "-\t\t\tfor _, t := range got {",
            "-\t\t\t\tgotStr += fmt.Sprintf(\"%+v\\n\", t)",
            "-\t\t\t}",
            "-",
            "-\t\t\twantStr := \"\"",
            "-\t\t\tfor _, t := range test.want {",
            "-\t\t\t\twantStr += fmt.Sprintf(\"%+v\\n\", t)",
            "-\t\t\t}",
            "-\t\t\tt.Errorf(\"satisfyTypeAndDirection %q: \\ngot\\n%s \\nwant\\n%s\", test.name, gotStr, wantStr)",
            "-\t\t}",
            "+\t\tassert.Equal(t, test.want, got, \"satisfyTypeAndDirection %q\", test.name)",
            " \t}",
            " }",
            " ",
            " func TestOneAttrKeyConnectionSetupPerMediaDescriptionInSDP(t *testing.T) {",
            " \tpc, err := NewPeerConnection(Configuration{})",
            " \tassert.NoError(t, err)",
            " ",
            "@@ -580,30 +558,23 @@",
            " \tlim := test.TimeOut(time.Second * 10)",
            " \tdefer lim.Stop()",
            " ",
            " \tconnectTwoAgents := func(offerIsLite, answerisLite bool) {",
            " \t\tofferSettingEngine := SettingEngine{}",
            " \t\tofferSettingEngine.SetLite(offerIsLite)",
            " \t\tofferPC, err := NewAPI(WithSettingEngine(offerSettingEngine)).NewPeerConnection(Configuration{})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tanswerSettingEngine := SettingEngine{}",
            " \t\tanswerSettingEngine.SetLite(answerisLite)",
            " \t\tanswerPC, err := NewAPI(WithSettingEngine(answerSettingEngine)).NewPeerConnection(Configuration{})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "-",
            "-\t\tif err = signalPair(offerPC, answerPC); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            "+\t\tassert.NoError(t, signalPair(offerPC, answerPC))",
            " ",
            "-\t\tdataChannelOpen := make(chan interface{})",
            "+\t\tdataChannelOpen := make(chan any)",
            " \t\tanswerPC.OnDataChannel(func(_ *DataChannel) {",
            " \t\t\tclose(dataChannelOpen)",
            " \t\t})",
            " ",
            " \t\t<-dataChannelOpen",
            " \t\tclosePairNow(t, offerPC, answerPC)",
            " \t}",
            "@@ -618,50 +589,48 @@",
            " ",
            " \tt.Run(\"Both\", func(*testing.T) {",
            " \t\tconnectTwoAgents(true, true)",
            " \t})",
            " }",
            " ",
            " func TestOnICEGatheringStateChange(t *testing.T) {",
            "-\tseenGathering := &atomicBool{}",
            "-\tseenComplete := &atomicBool{}",
            "+\tseenGathering := &atomic.Bool{}",
            "+\tseenComplete := &atomic.Bool{}",
            " ",
            "-\tseenGatheringAndComplete := make(chan interface{})",
            "+\tseenGatheringAndComplete := make(chan any)",
            " ",
            " \tpeerConn, err := NewPeerConnection(Configuration{})",
            " \tassert.NoError(t, err)",
            " ",
            " \tvar onStateChange func(s ICEGatheringState)",
            " \tonStateChange = func(s ICEGatheringState) {",
            " \t\t// Access to ICEGatherer in the callback must not cause dead lock.",
            " \t\tpeerConn.OnICEGatheringStateChange(onStateChange)",
            " ",
            " \t\tswitch s { // nolint:exhaustive",
            " \t\tcase ICEGatheringStateGathering:",
            "-\t\t\tif seenComplete.get() {",
            "-\t\t\t\tt.Error(\"Completed before gathering\")",
            "-\t\t\t}",
            "-\t\t\tseenGathering.set(true)",
            "+\t\t\tassert.False(t, seenGathering.Load(), \"Completed before gathering\")",
            "+\t\t\tseenGathering.Store(true)",
            " \t\tcase ICEGatheringStateComplete:",
            "-\t\t\tseenComplete.set(true)",
            "+\t\t\tseenComplete.Store(true)",
            " \t\t}",
            " ",
            "-\t\tif seenGathering.get() && seenComplete.get() {",
            "+\t\tif seenGathering.Load() && seenComplete.Load() {",
            " \t\t\tclose(seenGatheringAndComplete)",
            " \t\t}",
            " \t}",
            " \tpeerConn.OnICEGatheringStateChange(onStateChange)",
            " ",
            " \toffer, err := peerConn.CreateOffer(nil)",
            " \tassert.NoError(t, err)",
            " \tassert.NoError(t, peerConn.SetLocalDescription(offer))",
            " ",
            " \tselect {",
            " \tcase <-time.After(time.Second * 10):",
            "-\t\tt.Fatal(\"Gathering and Complete were never seen\")",
            "+\t\tassert.Fail(t, \"Gathering and Complete were never seen\")",
            " \tcase <-seenGatheringAndComplete:",
            " \t}",
            " ",
            " \tassert.NoError(t, peerConn.Close())",
            " }",
            " ",
            " // Assert Trickle ICE behaviors.",
            "@@ -691,32 +660,28 @@",
            " \t}",
            " ",
            " \tcandidateLock := sync.RWMutex{}",
            " \tvar offerCandidateDone, answerCandidateDone bool",
            " ",
            " \tcachedOfferCandidates := []ICECandidateInit{}",
            " \tofferPC.OnICECandidate(func(c *ICECandidate) {",
            "-\t\tif offerCandidateDone {",
            "-\t\t\tt.Error(\"Received OnICECandidate after finishing gathering\")",
            "-\t\t}",
            "+\t\tassert.False(t, offerCandidateDone, \"Received OnICECandidate after finishing gathering\")",
            " \t\tif c == nil {",
            " \t\t\tofferCandidateDone = true",
            " \t\t}",
            " ",
            " \t\tcandidateLock.Lock()",
            " \t\tdefer candidateLock.Unlock()",
            " ",
            " \t\tcachedOfferCandidates = addOrCacheCandidate(answerPC, c, cachedOfferCandidates)",
            " \t})",
            " ",
            " \tcachedAnswerCandidates := []ICECandidateInit{}",
            " \tanswerPC.OnICECandidate(func(c *ICECandidate) {",
            "-\t\tif answerCandidateDone {",
            "-\t\t\tt.Error(\"Received OnICECandidate after finishing gathering\")",
            "-\t\t}",
            "+\t\tassert.False(t, answerCandidateDone, \"Received OnICECandidate after finishing gathering\")",
            " \t\tif c == nil {",
            " \t\t\tanswerCandidateDone = true",
            " \t\t}",
            " ",
            " \t\tcandidateLock.Lock()",
            " \t\tdefer candidateLock.Unlock()",
            " ",
            "@@ -945,20 +910,20 @@",
            " ",
            " \tofferPeerConnection, answerPeerConnection, wan := createVNetPair(t, nil)",
            " ",
            " \tpushICEState := func(i ICEConnectionState) { iceStates <- i }",
            " \tofferPeerConnection.OnICEConnectionStateChange(pushICEState)",
            " \tanswerPeerConnection.OnICEConnectionStateChange(pushICEState)",
            " ",
            "-\tkeepPackets := &atomicBool{}",
            "-\tkeepPackets.set(true)",
            "+\tkeepPackets := &atomic.Bool{}",
            "+\tkeepPackets.Store(true)",
            " ",
            " \t// Add a filter that monitors the traffic on the router",
            " \twan.AddChunkFilter(func(vnet.Chunk) bool {",
            "-\t\treturn keepPackets.get()",
            "+\t\treturn keepPackets.Load()",
            " \t})",
            " ",
            " \tconst testMessage = \"testMessage\"",
            " ",
            " \td, err := answerPeerConnection.CreateDataChannel(\"foo\", nil)",
            " \tassert.NoError(t, err)",
            " ",
            "@@ -992,21 +957,21 @@",
            " ",
            " \tdataChannel := <-dataChannelAnswerer",
            " \tassert.NoError(t, dataChannel.SendText(testMessage))",
            " \tassert.Equal(t, testMessage, <-dataChannelMessages)",
            " ",
            " \t// Drop all packets, assert we have disconnected",
            " \t// and send a DataChannel message when disconnected",
            "-\tkeepPackets.set(false)",
            "+\tkeepPackets.Store(false)",
            " \tblockUntilICEState(ICEConnectionStateFailed)",
            " \tassert.NoError(t, dataChannel.SendText(testMessage))",
            " ",
            " \t// ICE Restart and assert we have reconnected",
            " \t// block until our DataChannel message is delivered",
            "-\tkeepPackets.set(true)",
            "+\tkeepPackets.Store(true)",
            " \tconnectWithICERestart(offerPeerConnection, answerPeerConnection)",
            " \tblockUntilICEState(ICEConnectionStateConnected)",
            " \tassert.Equal(t, testMessage, <-dataChannelMessages)",
            " ",
            " \tassert.NoError(t, wan.Stop())",
            " \tclosePairNow(t, offerPeerConnection, answerPeerConnection)",
            " }",
            "@@ -1116,15 +1081,15 @@",
            " \t\tif remains == 0 {",
            " \t\t\tbreak",
            " \t\t}",
            " \t\tt.Log(\"remain tracks\", remains)",
            " \t\ttime.Sleep(pingInterval)",
            " \t\tselect {",
            " \t\tcase <-tooLong:",
            "-\t\t\tt.Error(\"unable to receive all track events in time\")",
            "+\t\t\tassert.Fail(t, \"unable to receive all track events in time\")",
            " \t\tdefault:",
            " \t\t}",
            " \t}",
            " \tclose(stopped)",
            " \tclosePairNow(t, offerPC, answerPC)",
            " }",
            " ",
            "@@ -1142,22 +1107,18 @@",
            " \t\t\t\"1234567\",",
            " \t\t\tnil, nil, nil,",
            " \t\t}, true},",
            " \t}",
            " ",
            " \tfor i, testCase := range testCases {",
            " \t\tpeerConn, err := NewPeerConnection(Configuration{})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"Case %d: got error: %v\", i, err)",
            "-\t\t}",
            "+\t\tassert.NoErrorf(t, err, \"Case %d failed\", i)",
            " ",
            " \t\terr = peerConn.SetRemoteDescription(SessionDescription{Type: SDPTypeOffer, SDP: minimalOffer})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"Case %d: got error: %v\", i, err)",
            "-\t\t}",
            "+\t\tassert.NoErrorf(t, err, \"Case %d failed\", i)",
            " ",
            " \t\tif testCase.expectError {",
            " \t\t\tassert.Error(t, peerConn.AddICECandidate(testCase.ICECandidate))",
            " \t\t} else {",
            " \t\t\tassert.NoError(t, peerConn.AddICECandidate(testCase.ICECandidate))",
            " \t\t}",
            " ",
            "@@ -1339,71 +1300,63 @@",
            " \t\toffer := pcOffer.LocalDescription().parsed",
            " \t\tsessionID := offer.Origin.SessionID",
            " \t\tsessionVersion := offer.Origin.SessionVersion",
            " \t\tif offerSessionID == 0 {",
            " \t\t\tofferSessionID = sessionID",
            " \t\t\tofferSessionVersion = sessionVersion",
            " \t\t} else {",
            "-\t\t\tif offerSessionID != sessionID {",
            "-\t\t\t\tt.Errorf(\"offer[%v] session id mismatch: expected=%v, got=%v\", i, offerSessionID, sessionID)",
            "-\t\t\t}",
            "-\t\t\tif offerSessionVersion+1 != sessionVersion {",
            "-\t\t\t\tt.Errorf(\"offer[%v] session version mismatch: expected=%v, got=%v\", i, offerSessionVersion+1, sessionVersion)",
            "-\t\t\t}",
            "+\t\t\tassert.Equalf(t, offerSessionID, sessionID, \"offer[%v] session id mismatch\", i)",
            "+\t\t\tassert.Equalf(t, offerSessionVersion+1, sessionVersion, \"offer[%v] session version mismatch\", i)",
            " \t\t\tofferSessionVersion++",
            " \t\t}",
            " ",
            " \t\tanswer := pcAnswer.LocalDescription().parsed",
            " \t\tsessionID = answer.Origin.SessionID",
            " \t\tsessionVersion = answer.Origin.SessionVersion",
            " \t\tif answerSessionID == 0 {",
            " \t\t\tanswerSessionID = sessionID",
            " \t\t\tanswerSessionVersion = sessionVersion",
            " \t\t} else {",
            "-\t\t\tif answerSessionID != sessionID {",
            "-\t\t\t\tt.Errorf(\"answer[%v] session id mismatch: expected=%v, got=%v\", i, answerSessionID, sessionID)",
            "-\t\t\t}",
            "-\t\t\tif answerSessionVersion+1 != sessionVersion {",
            "-\t\t\t\tt.Errorf(\"answer[%v] session version mismatch: expected=%v, got=%v\", i, answerSessionVersion+1, sessionVersion)",
            "-\t\t\t}",
            "+\t\t\tassert.Equalf(t, answerSessionID, sessionID, \"answer[%v] session id mismatch\", i)",
            "+\t\t\tassert.Equalf(t, answerSessionVersion+1, sessionVersion, \"answer[%v] session version mismatch\", i)",
            " \t\t\tanswerSessionVersion++",
            " \t\t}",
            " \t}",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " func TestPeerConnectionNilCallback(t *testing.T) {",
            " \tpc, err := NewPeerConnection(Configuration{})",
            " \tassert.NoError(t, err)",
            " ",
            " \tpc.onSignalingStateChange(SignalingStateStable)",
            " \tpc.OnSignalingStateChange(func(SignalingState) {",
            "-\t\tt.Error(\"OnSignalingStateChange called\")",
            "+\t\tassert.Fail(t, \"OnSignalingStateChange called\")",
            " \t})",
            " \tpc.OnSignalingStateChange(nil)",
            " \tpc.onSignalingStateChange(SignalingStateStable)",
            " ",
            " \tpc.onConnectionStateChange(PeerConnectionStateNew)",
            " \tpc.OnConnectionStateChange(func(PeerConnectionState) {",
            "-\t\tt.Error(\"OnConnectionStateChange called\")",
            "+\t\tassert.Fail(t, \"OnConnectionStateChange called\")",
            " \t})",
            " \tpc.OnConnectionStateChange(nil)",
            " \tpc.onConnectionStateChange(PeerConnectionStateNew)",
            " ",
            " \tpc.onICEConnectionStateChange(ICEConnectionStateNew)",
            " \tpc.OnICEConnectionStateChange(func(ICEConnectionState) {",
            "-\t\tt.Error(\"OnConnectionStateChange called\")",
            "+\t\tassert.Fail(t, \"OnICEConnectionStateChange called\")",
            " \t})",
            " \tpc.OnICEConnectionStateChange(nil)",
            " \tpc.onICEConnectionStateChange(ICEConnectionStateNew)",
            " ",
            " \tpc.onNegotiationNeeded()",
            " \tpc.negotiationNeededOp()",
            " \tpc.OnNegotiationNeeded(func() {",
            "-\t\tt.Error(\"OnNegotiationNeeded called\")",
            "+\t\tassert.Fail(t, \"OnNegotiationNeeded called\")",
            " \t})",
            " \tpc.OnNegotiationNeeded(nil)",
            " \tpc.onNegotiationNeeded()",
            " \tpc.negotiationNeededOp()",
            " ",
            " \tassert.NoError(t, pc.Close())",
            " }",
            "@@ -1886,7 +1839,170 @@",
            " ",
            " \tassert.Error(t, peerConnection.WriteRTCP(",
            " \t\t[]rtcp.Packet{&rtcp.RapidResynchronizationRequest{SenderSSRC: 5, MediaSSRC: 10}}),",
            " \t)",
            " ",
            " \tassert.NoError(t, peerConnection.Close())",
            " }",
            "+",
            "+func Test_IPv6(t *testing.T) { //nolint: cyclop",
            "+\tinterfaces, err := net.Interfaces()",
            "+\tif err != nil {",
            "+\t\tt.Skip()",
            "+\t}",
            "+",
            "+\tIPv6Supported := false",
            "+\tfor _, iface := range interfaces {",
            "+\t\taddrs, netErr := iface.Addrs()",
            "+\t\tif netErr != nil {",
            "+\t\t\tcontinue",
            "+\t\t}",
            "+",
            "+\t\t// Loop over the addresses for the interface.",
            "+\t\tfor _, addr := range addrs {",
            "+\t\t\tvar ip net.IP",
            "+",
            "+\t\t\tswitch v := addr.(type) {",
            "+\t\t\tcase *net.IPNet:",
            "+\t\t\t\tip = v.IP",
            "+\t\t\tcase *net.IPAddr:",
            "+\t\t\t\tip = v.IP",
            "+\t\t\t}",
            "+",
            "+\t\t\tif ip == nil || ip.To4() != nil || ip.IsLinkLocalUnicast() || ip.IsLoopback() {",
            "+\t\t\t\tcontinue",
            "+\t\t\t}",
            "+",
            "+\t\t\tIPv6Supported = true",
            "+\t\t}",
            "+\t}",
            "+",
            "+\tif !IPv6Supported {",
            "+\t\tt.Skip()",
            "+\t}",
            "+",
            "+\tlim := test.TimeOut(time.Second * 5)",
            "+\tdefer lim.Stop()",
            "+",
            "+\treport := test.CheckRoutines(t)",
            "+\tdefer report()",
            "+",
            "+\tsettingEngine := SettingEngine{}",
            "+\tsettingEngine.SetNetworkTypes([]NetworkType{NetworkTypeUDP6})",
            "+",
            "+\tofferPC, answerPC, err := NewAPI(WithSettingEngine(settingEngine)).newPair(Configuration{})",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, offerPC, answerPC)",
            "+\tassert.NoError(t, signalPair(offerPC, answerPC))",
            "+",
            "+\tpeerConnectionConnected.Wait()",
            "+",
            "+\toffererSelectedPair, err := offerPC.SCTP().Transport().ICETransport().GetSelectedCandidatePair()",
            "+\tassert.NoError(t, err)",
            "+\tassert.NotNil(t, offererSelectedPair)",
            "+",
            "+\tanswererSelectedPair, err := answerPC.SCTP().Transport().ICETransport().GetSelectedCandidatePair()",
            "+\tassert.NoError(t, err)",
            "+\tassert.NotNil(t, answererSelectedPair)",
            "+",
            "+\tfor _, c := range []*ICECandidate{",
            "+\t\tanswererSelectedPair.Local,",
            "+\t\tanswererSelectedPair.Remote,",
            "+\t\toffererSelectedPair.Local,",
            "+\t\toffererSelectedPair.Remote,",
            "+\t} {",
            "+\t\ticeCandidate, err := c.ToICE()",
            "+\t\tassert.NoError(t, err)",
            "+\t\tassert.Equal(t, iceCandidate.NetworkType(), ice.NetworkTypeUDP6)",
            "+\t}",
            "+",
            "+\tclosePairNow(t, offerPC, answerPC)",
            "+}",
            "+",
            "+type testICELogger struct {",
            "+\tlastErrorMessage string",
            "+}",
            "+",
            "+func (t *testICELogger) Trace(string)          {}",
            "+func (t *testICELogger) Tracef(string, ...any) {}",
            "+func (t *testICELogger) Debug(string)          {}",
            "+func (t *testICELogger) Debugf(string, ...any) {}",
            "+func (t *testICELogger) Info(string)           {}",
            "+func (t *testICELogger) Infof(string, ...any)  {}",
            "+func (t *testICELogger) Warn(string)           {}",
            "+func (t *testICELogger) Warnf(string, ...any)  {}",
            "+func (t *testICELogger) Error(msg string)      { t.lastErrorMessage = msg }",
            "+func (t *testICELogger) Errorf(format string, args ...any) {",
            "+\tt.lastErrorMessage = fmt.Sprintf(format, args...)",
            "+}",
            "+",
            "+type testICELoggerFactory struct {",
            "+\tlogger *testICELogger",
            "+}",
            "+",
            "+func (t *testICELoggerFactory) NewLogger(string) logging.LeveledLogger {",
            "+\treturn t.logger",
            "+}",
            "+",
            "+func TestAddICECandidate__DroppingOldGenerationCandidates(t *testing.T) {",
            "+\tlim := test.TimeOut(time.Second * 30)",
            "+\tdefer lim.Stop()",
            "+",
            "+\treport := test.CheckRoutines(t)",
            "+\tdefer report()",
            "+",
            "+\ttestLogger := &testICELogger{}",
            "+\tloggerFactory := &testICELoggerFactory{logger: testLogger}",
            "+",
            "+\t// Create a new API with the custom logger",
            "+\tapi := NewAPI(WithSettingEngine(SettingEngine{",
            "+\t\tLoggerFactory: loggerFactory,",
            "+\t}))",
            "+",
            "+\tpc, err := api.NewPeerConnection(Configuration{})",
            "+\tassert.NoError(t, err)",
            "+",
            "+\t_, err = pc.CreateDataChannel(\"test\", nil)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\toffer, err := pc.CreateOffer(nil)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tofferGatheringComplete := GatheringCompletePromise(pc)",
            "+\tassert.NoError(t, pc.SetLocalDescription(offer))",
            "+\t<-offerGatheringComplete",
            "+",
            "+\tremotePC, err := api.NewPeerConnection(Configuration{})",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tassert.NoError(t, remotePC.SetRemoteDescription(offer))",
            "+",
            "+\tremoteDesc := remotePC.RemoteDescription()",
            "+\tassert.NotNil(t, remoteDesc)",
            "+",
            "+\tufrag, hasUfrag := remoteDesc.parsed.MediaDescriptions[0].Attribute(\"ice-ufrag\")",
            "+\tassert.True(t, hasUfrag)",
            "+",
            "+\temptyUfragCandidate := ICECandidateInit{",
            "+\t\tCandidate: \"candidate:1 1 UDP 2122252543 192.168.1.1 12345 typ host\",",
            "+\t}",
            "+\terr = remotePC.AddICECandidate(emptyUfragCandidate)",
            "+\tassert.NoError(t, err)",
            "+\tassert.Empty(t, testLogger.lastErrorMessage)",
            "+",
            "+\tvalidCandidate := ICECandidateInit{",
            "+\t\tCandidate: fmt.Sprintf(\"candidate:1 1 UDP 2122252543 192.168.1.1 12345 typ host ufrag %s\", ufrag),",
            "+\t}",
            "+\terr = remotePC.AddICECandidate(validCandidate)",
            "+\tassert.NoError(t, err)",
            "+\tassert.Empty(t, testLogger.lastErrorMessage)",
            "+",
            "+\tinvalidCandidate := ICECandidateInit{",
            "+\t\tCandidate: \"candidate:1 1 UDP 2122252543 192.168.1.1 12345 typ host ufrag invalid\",",
            "+\t}",
            "+\terr = remotePC.AddICECandidate(invalidCandidate)",
            "+\tassert.NoError(t, err)",
            "+\tassert.Contains(t, testLogger.lastErrorMessage, \"dropping candidate with ufrag\")",
            "+",
            "+\tclosePairNow(t, pc, remotePC)",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_js.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_js.go",
            "+++ /home/webrtc-4.1.3/peerconnection_js.go",
            "@@ -67,15 +67,15 @@",
            " // OnSignalingStateChange sets an event handler which is invoked when the",
            " // peer connection's signaling state changes",
            " func (pc *PeerConnection) OnSignalingStateChange(f func(SignalingState)) {",
            " \tif pc.onSignalingStateChangeHandler != nil {",
            " \t\toldHandler := pc.onSignalingStateChangeHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonSignalingStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonSignalingStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tstate := newSignalingState(args[0].String())",
            " \t\tgo f(state)",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tpc.onSignalingStateChangeHandler = &onSignalingStateChangeHandler",
            " \tpc.underlying.Set(\"onsignalingstatechange\", onSignalingStateChangeHandler)",
            " }",
            "@@ -83,15 +83,15 @@",
            " // OnDataChannel sets an event handler which is invoked when a data",
            " // channel message arrives from a remote peer.",
            " func (pc *PeerConnection) OnDataChannel(f func(*DataChannel)) {",
            " \tif pc.onDataChannelHandler != nil {",
            " \t\toldHandler := pc.onDataChannelHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonDataChannelHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonDataChannelHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\t// pion/webrtc/projects/15",
            " \t\t// This reference to the underlying DataChannel doesn't know",
            " \t\t// about any other references to the same DataChannel. This might result in",
            " \t\t// memory leaks where we don't clean up handler functions. Could possibly fix",
            " \t\t// by keeping a mutex-protected list of all DataChannel references as a",
            " \t\t// property of this PeerConnection, but at the cost of additional overhead.",
            " \t\tdataChannel := &DataChannel{",
            "@@ -108,30 +108,30 @@",
            " // OnNegotiationNeeded sets an event handler which is invoked when",
            " // a change has occurred which requires session negotiation",
            " func (pc *PeerConnection) OnNegotiationNeeded(f func()) {",
            " \tif pc.onNegotiationNeededHandler != nil {",
            " \t\toldHandler := pc.onNegotiationNeededHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonNegotiationNeededHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonNegotiationNeededHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo f()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tpc.onNegotiationNeededHandler = &onNegotiationNeededHandler",
            " \tpc.underlying.Set(\"onnegotiationneeded\", onNegotiationNeededHandler)",
            " }",
            " ",
            " // OnICEConnectionStateChange sets an event handler which is called",
            " // when an ICE connection state is changed.",
            " func (pc *PeerConnection) OnICEConnectionStateChange(f func(ICEConnectionState)) {",
            " \tif pc.onICEConnectionStateChangeHandler != nil {",
            " \t\toldHandler := pc.onICEConnectionStateChangeHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonICEConnectionStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonICEConnectionStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tconnectionState := NewICEConnectionState(pc.underlying.Get(\"iceConnectionState\").String())",
            " \t\tgo f(connectionState)",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tpc.onICEConnectionStateChangeHandler = &onICEConnectionStateChangeHandler",
            " \tpc.underlying.Set(\"oniceconnectionstatechange\", onICEConnectionStateChangeHandler)",
            " }",
            "@@ -139,15 +139,15 @@",
            " // OnConnectionStateChange sets an event handler which is called",
            " // when an PeerConnectionState is changed.",
            " func (pc *PeerConnection) OnConnectionStateChange(f func(PeerConnectionState)) {",
            " \tif pc.onConnectionStateChangeHandler != nil {",
            " \t\toldHandler := pc.onConnectionStateChangeHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonConnectionStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonConnectionStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tconnectionState := newPeerConnectionState(pc.underlying.Get(\"connectionState\").String())",
            " \t\tgo f(connectionState)",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tpc.onConnectionStateChangeHandler = &onConnectionStateChangeHandler",
            " \tpc.underlying.Set(\"onconnectionstatechange\", onConnectionStateChangeHandler)",
            " }",
            "@@ -331,15 +331,15 @@",
            " // OnICECandidate sets an event handler which is invoked when a new ICE",
            " // candidate is found.",
            " func (pc *PeerConnection) OnICECandidate(f func(candidate *ICECandidate)) {",
            " \tif pc.onICECandidateHandler != nil {",
            " \t\toldHandler := pc.onICECandidateHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonICECandidateHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonICECandidateHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tcandidate := valueToICECandidate(args[0].Get(\"candidate\"))",
            " \t\tif candidate == nil && pc.onGatherCompleteHandler != nil {",
            " \t\t\tgo pc.onGatherCompleteHandler()",
            " \t\t}",
            " ",
            " \t\tgo f(candidate)",
            " \t\treturn js.Undefined()",
            "@@ -351,15 +351,15 @@",
            " // OnICEGatheringStateChange sets an event handler which is invoked when the",
            " // ICE candidate gathering state has changed.",
            " func (pc *PeerConnection) OnICEGatheringStateChange(f func()) {",
            " \tif pc.onICEGatheringStateChangeHandler != nil {",
            " \t\toldHandler := pc.onICEGatheringStateChangeHandler",
            " \t\tdefer oldHandler.Release()",
            " \t}",
            "-\tonICEGatheringStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {",
            "+\tonICEGatheringStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) any {",
            " \t\tgo f()",
            " \t\treturn js.Undefined()",
            " \t})",
            " \tpc.onICEGatheringStateChangeHandler = &onICEGatheringStateChangeHandler",
            " \tpc.underlying.Set(\"onicegatheringstatechange\", onICEGatheringStateChangeHandler)",
            " }",
            " ",
            "@@ -541,15 +541,15 @@",
            " \t}",
            " }",
            " ",
            " // Converts a Configuration to js.Value so it can be passed",
            " // through to the JavaScript WebRTC API. Any zero values are converted to",
            " // js.Undefined(), which will result in the default value being used.",
            " func configurationToValue(configuration Configuration) js.Value {",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"iceServers\":           iceServersToValue(configuration.ICEServers),",
            " \t\t\"iceTransportPolicy\":   stringEnumToValueOrUndefined(configuration.ICETransportPolicy.String()),",
            " \t\t\"bundlePolicy\":         stringEnumToValueOrUndefined(configuration.BundlePolicy.String()),",
            " \t\t\"rtcpMuxPolicy\":        stringEnumToValueOrUndefined(configuration.RTCPMuxPolicy.String()),",
            " \t\t\"peerIdentity\":         stringToValueOrUndefined(configuration.PeerIdentity),",
            " \t\t\"iceCandidatePoolSize\": uint8ToValueOrUndefined(configuration.ICECandidatePoolSize),",
            " ",
            "@@ -558,31 +558,31 @@",
            " \t})",
            " }",
            " ",
            " func iceServersToValue(iceServers []ICEServer) js.Value {",
            " \tif len(iceServers) == 0 {",
            " \t\treturn js.Undefined()",
            " \t}",
            "-\tmaps := make([]interface{}, len(iceServers))",
            "+\tmaps := make([]any, len(iceServers))",
            " \tfor i, server := range iceServers {",
            " \t\tmaps[i] = iceServerToValue(server)",
            " \t}",
            " \treturn js.ValueOf(maps)",
            " }",
            " ",
            " func oauthCredentialToValue(o OAuthCredential) js.Value {",
            "-\tout := map[string]interface{}{",
            "+\tout := map[string]any{",
            " \t\t\"MACKey\":      o.MACKey,",
            " \t\t\"AccessToken\": o.AccessToken,",
            " \t}",
            " \treturn js.ValueOf(out)",
            " }",
            " ",
            " func iceServerToValue(server ICEServer) js.Value {",
            "-\tout := map[string]interface{}{",
            "+\tout := map[string]any{",
            " \t\t\"urls\": stringsToValue(server.URLs), // required",
            " \t}",
            " \tif server.Username != \"\" {",
            " \t\tout[\"username\"] = stringToValueOrUndefined(server.Username)",
            " \t}",
            " \tif server.Credential != nil {",
            " \t\tswitch t := server.Credential.(type) {",
            "@@ -620,15 +620,15 @@",
            " \ticeServers := make([]ICEServer, iceServersValue.Length())",
            " \tfor i := 0; i < iceServersValue.Length(); i++ {",
            " \t\ticeServers[i] = valueToICEServer(iceServersValue.Index(i))",
            " \t}",
            " \treturn iceServers",
            " }",
            " ",
            "-func valueToICECredential(iceCredentialValue js.Value) interface{} {",
            "+func valueToICECredential(iceCredentialValue js.Value) any {",
            " \tif iceCredentialValue.IsNull() || iceCredentialValue.IsUndefined() {",
            " \t\treturn nil",
            " \t}",
            " \tif iceCredentialValue.Type() == js.TypeString {",
            " \t\treturn iceCredentialValue.String()",
            " \t}",
            " \tif iceCredentialValue.Type() == js.TypeObject {",
            "@@ -700,15 +700,15 @@",
            " \treturn 0",
            " }",
            " ",
            " func sessionDescriptionToValue(desc *SessionDescription) js.Value {",
            " \tif desc == nil {",
            " \t\treturn js.Undefined()",
            " \t}",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"type\": desc.Type.String(),",
            " \t\t\"sdp\":  desc.SDP,",
            " \t})",
            " }",
            " ",
            " func valueToSessionDescription(descValue js.Value) *SessionDescription {",
            " \tif descValue.IsNull() || descValue.IsUndefined() {",
            "@@ -720,55 +720,55 @@",
            " \t}",
            " }",
            " ",
            " func offerOptionsToValue(offerOptions *OfferOptions) js.Value {",
            " \tif offerOptions == nil {",
            " \t\treturn js.Undefined()",
            " \t}",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"iceRestart\":             offerOptions.ICERestart,",
            " \t\t\"voiceActivityDetection\": offerOptions.VoiceActivityDetection,",
            " \t})",
            " }",
            " ",
            " func answerOptionsToValue(answerOptions *AnswerOptions) js.Value {",
            " \tif answerOptions == nil {",
            " \t\treturn js.Undefined()",
            " \t}",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"voiceActivityDetection\": answerOptions.VoiceActivityDetection,",
            " \t})",
            " }",
            " ",
            " func iceCandidateInitToValue(candidate ICECandidateInit) js.Value {",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"candidate\":        candidate.Candidate,",
            " \t\t\"sdpMid\":           stringPointerToValue(candidate.SDPMid),",
            " \t\t\"sdpMLineIndex\":    uint16PointerToValue(candidate.SDPMLineIndex),",
            " \t\t\"usernameFragment\": stringPointerToValue(candidate.UsernameFragment),",
            " \t})",
            " }",
            " ",
            " func dataChannelInitToValue(options *DataChannelInit) js.Value {",
            " \tif options == nil {",
            " \t\treturn js.Undefined()",
            " \t}",
            " ",
            " \tmaxPacketLifeTime := uint16PointerToValue(options.MaxPacketLifeTime)",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"ordered\":           boolPointerToValue(options.Ordered),",
            " \t\t\"maxPacketLifeTime\": maxPacketLifeTime,",
            " \t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=696681",
            " \t\t// Chrome calls this \"maxRetransmitTime\"",
            " \t\t\"maxRetransmitTime\": maxPacketLifeTime,",
            " \t\t\"maxRetransmits\":    uint16PointerToValue(options.MaxRetransmits),",
            " \t\t\"protocol\":          stringPointerToValue(options.Protocol),",
            " \t\t\"negotiated\":        boolPointerToValue(options.Negotiated),",
            " \t\t\"id\":                uint16PointerToValue(options.ID),",
            " \t})",
            " }",
            " ",
            " func rtpTransceiverInitInitToValue(init RTPTransceiverInit) js.Value {",
            "-\treturn js.ValueOf(map[string]interface{}{",
            "+\treturn js.ValueOf(map[string]any{",
            " \t\t\"direction\": init.Direction.String(),",
            " \t})",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_js_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_js_test.go",
            "+++ /home/webrtc-4.1.3/peerconnection_js_test.go",
            "@@ -58,15 +58,15 @@",
            " \t\t\t\tRelatedAddress: \"<null>\",",
            " \t\t\t\tRelatedPort:    0,",
            " \t\t\t},",
            " \t\t},",
            " \t}",
            " ",
            " \tfor i, testCase := range testCases {",
            "-\t\tv := map[string]interface{}{}",
            "+\t\tv := map[string]any{}",
            " \t\terr := json.Unmarshal([]byte(testCase.jsonCandidate), &v)",
            " \t\tif err != nil {",
            " \t\t\tt.Errorf(\"Case %d: bad test, got error: %v\", i, err)",
            " \t\t}",
            " \t\tval := *valueToICECandidate(js.ValueOf(v))",
            " \t\tval.statsID = \"\"",
            " \t\tassert.Equal(t, testCase.expect, val)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_media_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_media_test.go",
            "+++ /home/webrtc-4.1.3/peerconnection_media_test.go",
            "@@ -55,17 +55,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tawaitRTPRecv := make(chan bool)",
            " \tawaitRTPRecvClosed := make(chan bool)",
            " \tawaitRTPSend := make(chan bool)",
            " ",
            " \tawaitRTCPSenderRecv := make(chan bool)",
            " \tawaitRTCPSenderSend := make(chan error)",
            "@@ -136,29 +134,26 @@",
            " \t\t\t}",
            " \t\t}",
            " \t})",
            " ",
            " \tvp8Track, err := NewTrackLocalStaticSample(",
            " \t\tRTPCodecCapability{MimeType: MimeTypeVP8}, expectedTrackID, expectedStreamID,",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \tsender, err := pcOffer.AddTrack(vp8Track)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tgo func() {",
            " \t\tfor {",
            " \t\t\ttime.Sleep(time.Millisecond * 100)",
            " \t\t\tif pcOffer.ICEConnectionState() != ICEConnectionStateConnected {",
            " \t\t\t\tcontinue",
            " \t\t\t}",
            " \t\t\tif routineErr := vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}); routineErr != nil {",
            "+\t\t\t\t//nolint:forbidigo // not a test failure",
            " \t\t\t\tfmt.Println(routineErr)",
            " \t\t\t}",
            " ",
            " \t\t\tselect {",
            " \t\t\tcase <-awaitRTPRecv:",
            " \t\t\t\tclose(awaitRTPSend)",
            " ",
            "@@ -167,14 +162,15 @@",
            " \t\t\t}",
            " \t\t}",
            " \t}()",
            " ",
            " \tgo func() {",
            " \t\tparameters := sender.GetParameters()",
            " ",
            "+\t\t<-awaitRTPSend",
            " \t\tfor {",
            " \t\t\ttime.Sleep(time.Millisecond * 100)",
            " \t\t\tif routineErr := pcOffer.WriteRTCP([]rtcp.Packet{",
            " \t\t\t\t&rtcp.PictureLossIndication{",
            " \t\t\t\t\tSenderSSRC: uint32(parameters.Encodings[0].SSRC), MediaSSRC: uint32(parameters.Encodings[0].SSRC),",
            " \t\t\t\t},",
            " \t\t\t}); routineErr != nil {",
            "@@ -196,30 +192,29 @@",
            " \t\t\tclose(awaitRTCPSenderRecv)",
            " \t\t}",
            " \t}()",
            " ",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \terr, ok := <-trackMetadataValid",
            "-\tif ok {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.False(t, ok)",
            " ",
            " \t<-awaitRTPRecv",
            " \t<-awaitRTPSend",
            " ",
            " \t<-awaitRTCPSenderRecv",
            "-\tif err, ok = <-awaitRTCPSenderSend; ok {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\terr, ok = <-awaitRTCPSenderSend",
            "+\tassert.NoError(t, err)",
            "+\tassert.False(t, ok)",
            " ",
            " \t<-awaitRTCPReceiverRecv",
            "-\tif err, ok = <-awaitRTCPReceiverSend; ok {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\terr, ok = <-awaitRTCPReceiverSend",
            "+\tassert.NoError(t, err)",
            "+\tassert.False(t, ok)",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " \t<-awaitRTPRecvClosed",
            " }",
            " ",
            " // PeerConnection should be able to be torn down at anytime",
            " // This test adds an input track and asserts",
            "@@ -233,49 +228,38 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t_, err = pcOffer.AddTransceiverFromKind(",
            " \t\tRTPCodecTypeVideo,",
            " \t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t_, err = pcAnswer.AddTransceiverFromKind(",
            " \t\tRTPCodecTypeAudio,",
            " \t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \topusTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"audio\", \"pion1\")",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif _, err = pcOffer.AddTrack(opusTrack); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t} else if _, err = pcAnswer.AddTrack(vp8Track); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\t_, err = pcOffer.AddTrack(opusTrack)",
            "+\tassert.NoError(t, err)",
            "+\t_, err = pcAnswer.AddTrack(vp8Track)",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvar onTrackFiredLock sync.Mutex",
            " \tonTrackFired := false",
            " ",
            " \tpcAnswer.OnTrack(func(*TrackRemote, *RTPReceiver) {",
            " \t\tonTrackFiredLock.Lock()",
            " \t\tdefer onTrackFiredLock.Unlock()",
            "@@ -290,44 +274,34 @@",
            " \tpcOffer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {",
            " \t\tif iceState == ICEConnectionStateConnected {",
            " \t\t\tclose(iceCompleteOffer)",
            " \t\t}",
            " \t})",
            " ",
            " \terr = signalPair(pcOffer, pcAnswer)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " \t<-iceCompleteAnswer",
            " \t<-iceCompleteOffer",
            " ",
            " \t// Each PeerConnection should have one sender, one receiver and one transceiver",
            " \tfor _, pc := range []*PeerConnection{pcOffer, pcAnswer} {",
            " \t\tsenders := pc.GetSenders()",
            "-\t\tif len(senders) != 1 {",
            "-\t\t\tt.Errorf(\"Each PeerConnection should have one RTPSender, we have %d\", len(senders))",
            "-\t\t}",
            "+\t\tassert.Len(t, senders, 1, \"Each PeerConnection should have one RTPSender\")",
            " ",
            " \t\treceivers := pc.GetReceivers()",
            "-\t\tif len(receivers) != 2 {",
            "-\t\t\tt.Errorf(\"Each PeerConnection should have two RTPReceivers, we have %d\", len(receivers))",
            "-\t\t}",
            "+\t\tassert.Len(t, receivers, 2, \"Each PeerConnection should have two RTPReceivers\")",
            " ",
            " \t\ttransceivers := pc.GetTransceivers()",
            "-\t\tif len(transceivers) != 2 {",
            "-\t\t\tt.Errorf(\"Each PeerConnection should have two RTPTransceivers, we have %d\", len(transceivers))",
            "-\t\t}",
            "+\t\tassert.Len(t, transceivers, 2, \"Each PeerConnection should have two RTPTransceivers\")",
            " \t}",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " ",
            " \tonTrackFiredLock.Lock()",
            "-\tif onTrackFired {",
            "-\t\tt.Fatalf(\"PeerConnection OnTrack fired even though we got no packets\")",
            "-\t}",
            "+\tassert.False(t, onTrackFired, \"PeerConnection OnTrack fired even though we got no packets\")",
            " \tonTrackFiredLock.Unlock()",
            " }",
            " ",
            " // Integration test for behavior around media and disconnected peers",
            " // Sending RTP and RTCP to a disconnected Peer shouldn't return an error.",
            " ",
            " func TestPeerConnection_Media_Disconnected(t *testing.T) { //nolint:cyclop",
            "@@ -341,31 +315,27 @@",
            " \ts.SetICETimeouts(time.Second/2, time.Second/2, time.Second/8)",
            " ",
            " \tmediaEngine := &MediaEngine{}",
            " \tassert.NoError(t, mediaEngine.RegisterDefaultCodecs())",
            " ",
            " \tpcOffer, pcAnswer, wan := createVNetPair(t, nil)",
            " ",
            "-\tkeepPackets := &atomicBool{}",
            "-\tkeepPackets.set(true)",
            "+\tkeepPackets := &atomic.Bool{}",
            "+\tkeepPackets.Store(true)",
            " ",
            " \t// Add a filter that monitors the traffic on the router",
            " \twan.AddChunkFilter(func(vnet.Chunk) bool {",
            "-\t\treturn keepPackets.get()",
            "+\t\treturn keepPackets.Load()",
            " \t})",
            " ",
            " \tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvp8Sender, err := pcOffer.AddTrack(vp8Track)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \thaveDisconnected := make(chan error)",
            " \tpcOffer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {",
            " \t\tif iceState == ICEConnectionStateDisconnected {",
            " \t\t\tclose(haveDisconnected)",
            " \t\t} else if iceState == ICEConnectionStateConnected {",
            " \t\t\t// Assert that DTLS is done by pull remote certificate, don't tear down the PC early",
            "@@ -375,50 +345,46 @@",
            " \t\t\t\t\t\tbreak",
            " \t\t\t\t\t}",
            " \t\t\t\t}",
            " ",
            " \t\t\t\ttime.Sleep(time.Second)",
            " \t\t\t}",
            " ",
            "-\t\t\tkeepPackets.set(false)",
            "+\t\t\tkeepPackets.Store(false)",
            " \t\t}",
            " \t})",
            " ",
            "-\tif err = signalPair(pcOffer, pcAnswer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \terr, ok := <-haveDisconnected",
            "-\tif ok {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.False(t, ok)",
            "+\tassert.NoError(t, err)",
            " \tfor i := 0; i <= 5; i++ {",
            "-\t\tif rtpErr := vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}); rtpErr != nil {",
            "-\t\t\tt.Fatal(rtpErr)",
            "-\t\t} else if rtcpErr := pcOffer.WriteRTCP([]rtcp.Packet{&rtcp.PictureLossIndication{MediaSSRC: 0}}); rtcpErr != nil {",
            "-\t\t\tt.Fatal(rtcpErr)",
            "-\t\t}",
            "+\t\terr = vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second})",
            "+\t\tassert.NoError(t, err)",
            "+\t\terr = pcOffer.WriteRTCP([]rtcp.Packet{&rtcp.PictureLossIndication{MediaSSRC: 0}})",
            "+\t\tassert.NoError(t, err)",
            " \t}",
            " ",
            " \tassert.NoError(t, wan.Stop())",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " type undeclaredSsrcLogger struct{ unhandledSimulcastError chan struct{} }",
            " ",
            "-func (u *undeclaredSsrcLogger) Trace(string)                  {}",
            "-func (u *undeclaredSsrcLogger) Tracef(string, ...interface{}) {}",
            "-func (u *undeclaredSsrcLogger) Debug(string)                  {}",
            "-func (u *undeclaredSsrcLogger) Debugf(string, ...interface{}) {}",
            "-func (u *undeclaredSsrcLogger) Info(string)                   {}",
            "-func (u *undeclaredSsrcLogger) Infof(string, ...interface{})  {}",
            "-func (u *undeclaredSsrcLogger) Warn(string)                   {}",
            "-func (u *undeclaredSsrcLogger) Warnf(string, ...interface{})  {}",
            "-func (u *undeclaredSsrcLogger) Error(string)                  {}",
            "-func (u *undeclaredSsrcLogger) Errorf(format string, _ ...interface{}) {",
            "+func (u *undeclaredSsrcLogger) Trace(string)          {}",
            "+func (u *undeclaredSsrcLogger) Tracef(string, ...any) {}",
            "+func (u *undeclaredSsrcLogger) Debug(string)          {}",
            "+func (u *undeclaredSsrcLogger) Debugf(string, ...any) {}",
            "+func (u *undeclaredSsrcLogger) Info(string)           {}",
            "+func (u *undeclaredSsrcLogger) Infof(string, ...any)  {}",
            "+func (u *undeclaredSsrcLogger) Warn(string)           {}",
            "+func (u *undeclaredSsrcLogger) Warnf(string, ...any)  {}",
            "+func (u *undeclaredSsrcLogger) Error(string)          {}",
            "+func (u *undeclaredSsrcLogger) Errorf(format string, _ ...any) {",
            " \tif format == incomingUnhandledRTPSsrc {",
            " \t\tclose(u.unhandledSimulcastError)",
            " \t}",
            " }",
            " ",
            " type undeclaredSsrcLoggerFactory struct{ unhandledSimulcastError chan struct{} }",
            " ",
            "@@ -437,14 +403,28 @@",
            " ",
            " \t\tfilteredSDP += l + \"\\n\"",
            " \t}",
            " ",
            " \treturn",
            " }",
            " ",
            "+func filterSDPExtensions(offer string) (filteredSDP string) {",
            "+\tscanner := bufio.NewScanner(strings.NewReader(offer))",
            "+\tfor scanner.Scan() {",
            "+\t\tl := scanner.Text()",
            "+\t\tif strings.HasPrefix(l, \"a=extmap\") {",
            "+\t\t\tcontinue",
            "+\t\t}",
            "+",
            "+\t\tfilteredSDP += l + \"\\n\"",
            "+\t}",
            "+",
            "+\treturn",
            "+}",
            "+",
            " // If a SessionDescription has a single media section and no SSRC",
            " // assume that it is meant to handle all RTP packets.",
            " func TestUndeclaredSSRC(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            "@@ -526,120 +506,207 @@",
            " \t\t<-answerGatheringComplete",
            " ",
            " \t\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))",
            " ",
            " \t\tsendVideoUntilDone(t, unhandledSimulcastError, []*TrackLocalStaticSample{vp8Writer})",
            " \t\tclosePairNow(t, pcOffer, pcAnswer)",
            " \t})",
            "+",
            "+\tt.Run(\"multiple media sections, no sdp extensions\", func(t *testing.T) {",
            "+\t\tpcOffer, pcAnswer, err := newPair()",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\tvp8Writer, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\t_, err = pcOffer.CreateDataChannel(\"data\", nil)",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\t_, err = pcOffer.AddTrack(vp8Writer)",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\topusWriter, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"audio\", \"pion\")",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\t_, err = pcOffer.AddTrack(opusWriter)",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\tonVideoTrackFired := make(chan struct{})",
            "+\t\tonAudioTrackFired := make(chan struct{})",
            "+",
            "+\t\tgotVideo, gotAudio := false, false",
            "+\t\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, _ *RTPReceiver) {",
            "+\t\t\tswitch trackRemote.Kind() {",
            "+\t\t\tcase RTPCodecTypeVideo:",
            "+\t\t\t\tassert.False(t, gotVideo, \"already got video track\")",
            "+\t\t\t\tassert.Equal(t, trackRemote.StreamID(), vp8Writer.StreamID())",
            "+\t\t\t\tassert.Equal(t, trackRemote.ID(), vp8Writer.ID())",
            "+\t\t\t\tgotVideo = true",
            "+\t\t\t\tonVideoTrackFired <- struct{}{}",
            "+\t\t\tcase RTPCodecTypeAudio:",
            "+\t\t\t\tassert.False(t, gotAudio, \"already got audio track\")",
            "+\t\t\t\tassert.Equal(t, trackRemote.StreamID(), opusWriter.StreamID())",
            "+\t\t\t\tassert.Equal(t, trackRemote.ID(), opusWriter.ID())",
            "+\t\t\t\tgotAudio = true",
            "+\t\t\t\tonAudioTrackFired <- struct{}{}",
            "+\t\t\tdefault:",
            "+\t\t\t\tassert.Fail(t, \"unexpected track kind\", trackRemote.Kind())",
            "+\t\t\t}",
            "+\t\t})",
            "+",
            "+\t\toffer, err := pcOffer.CreateOffer(nil)",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)",
            "+\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            "+\t\t<-offerGatheringComplete",
            "+",
            "+\t\toffer.SDP = filterSDPExtensions(filterSsrc(pcOffer.LocalDescription().SDP))",
            "+\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))",
            "+",
            "+\t\tanswer, err := pcAnswer.CreateAnswer(nil)",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)",
            "+\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))",
            "+\t\t<-answerGatheringComplete",
            "+",
            "+\t\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))",
            "+",
            "+\t\twait := sync.WaitGroup{}",
            "+\t\twait.Add(2)",
            "+\t\tgo func() {",
            "+\t\t\tsendVideoUntilDone(t, onVideoTrackFired, []*TrackLocalStaticSample{vp8Writer})",
            "+\t\t\twait.Done()",
            "+\t\t}()",
            "+\t\tgo func() {",
            "+\t\t\tsendVideoUntilDone(t, onAudioTrackFired, []*TrackLocalStaticSample{opusWriter})",
            "+\t\t\twait.Done()",
            "+\t\t}()",
            "+",
            "+\t\twait.Wait()",
            "+\t\tclosePairNow(t, pcOffer, pcAnswer)",
            "+\t})",
            "+",
            "+\tt.Run(\"findMediaSectionByPayloadType test\", func(t *testing.T) {",
            "+\t\tparsed := &SessionDescription{",
            "+\t\t\tparsed: &sdp.SessionDescription{",
            "+\t\t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            "+\t\t\t\t\t{",
            "+\t\t\t\t\t\tMediaName: sdp.MediaName{",
            "+\t\t\t\t\t\t\tMedia:   \"video\",",
            "+\t\t\t\t\t\t\tProtos:  []string{\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"},",
            "+\t\t\t\t\t\t\tFormats: []string{\"96\", \"97\", \"98\", \"99\", \"BAD\", \"100\", \"101\", \"102\"},",
            "+\t\t\t\t\t\t},",
            "+\t\t\t\t\t},",
            "+\t\t\t\t\t{",
            "+\t\t\t\t\t\tMediaName: sdp.MediaName{",
            "+\t\t\t\t\t\t\tMedia:   \"audio\",",
            "+\t\t\t\t\t\t\tProtos:  []string{\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"},",
            "+\t\t\t\t\t\t\tFormats: []string{\"8\", \"9\", \"101\"},",
            "+\t\t\t\t\t\t},",
            "+\t\t\t\t\t},",
            "+\t\t\t\t\t{",
            "+\t\t\t\t\t\tMediaName: sdp.MediaName{",
            "+\t\t\t\t\t\t\tMedia:   \"application\",",
            "+\t\t\t\t\t\t\tProtos:  []string{\"UDP\", \"DTLS\", \"SCTP\"},",
            "+\t\t\t\t\t\t\tFormats: []string{\"webrtc-datachannel\"},",
            "+\t\t\t\t\t\t},",
            "+\t\t\t\t\t},",
            "+\t\t\t\t},",
            "+\t\t\t},",
            "+\t\t}",
            "+\t\tpeer := &PeerConnection{}",
            "+",
            "+\t\tvideo, ok := peer.findMediaSectionByPayloadType(96, parsed)",
            "+\t\tassert.True(t, ok)",
            "+\t\tassert.NotNil(t, video)",
            "+\t\tassert.Equal(t, \"video\", video.MediaName.Media)",
            "+",
            "+\t\taudio, ok := peer.findMediaSectionByPayloadType(8, parsed)",
            "+\t\tassert.True(t, ok)",
            "+\t\tassert.NotNil(t, audio)",
            "+\t\tassert.Equal(t, \"audio\", audio.MediaName.Media)",
            "+",
            "+\t\tmissing, ok := peer.findMediaSectionByPayloadType(42, parsed)",
            "+\t\tassert.False(t, ok)",
            "+\t\tassert.Nil(t, missing)",
            "+\t})",
            " }",
            " ",
            " func TestAddTransceiverFromTrackSendOnly(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttrack, err := NewTrackLocalStaticSample(",
            " \t\tRTPCodecCapability{MimeType: \"audio/Opus\"},",
            " \t\t\"track-id\",",
            " \t\t\"stream-id\",",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttransceiver, err := pc.AddTransceiverFromTrack(track, RTPTransceiverInit{",
            " \t\tDirection: RTPTransceiverDirectionSendonly,",
            " \t})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "-",
            "-\tif transceiver.Receiver() != nil {",
            "-\t\tt.Errorf(\"Transceiver shouldn't have a receiver\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif transceiver.Sender() == nil {",
            "-\t\tt.Errorf(\"Transceiver should have a sender\")",
            "-\t}",
            "-",
            "-\tif len(pc.GetTransceivers()) != 1 {",
            "-\t\tt.Errorf(\"PeerConnection should have one transceiver but has %d\", len(pc.GetTransceivers()))",
            "-\t}",
            "-",
            "-\tif len(pc.GetSenders()) != 1 {",
            "-\t\tt.Errorf(\"PeerConnection should have one sender but has %d\", len(pc.GetSenders()))",
            "-\t}",
            "+\tassert.Nil(t, transceiver.Receiver(), \"Transceiver shouldn't have a receiver\")",
            "+\tassert.NotNil(t, transceiver.Sender(), \"Transceiver should have a sender\")",
            "+\tassert.Len(t, pc.GetTransceivers(), 1, \"PeerConnection should have one transceiver\")",
            "+\tassert.Len(t, pc.GetSenders(), 1, \"PeerConnection should have one sender\")",
            " ",
            " \toffer, err := pc.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif !offerMediaHasDirection(offer, RTPCodecTypeAudio, RTPTransceiverDirectionSendonly) {",
            "-\t\tt.Errorf(\"Direction on SDP is not %s\", RTPTransceiverDirectionSendonly)",
            "-\t}",
            "+\tassert.Truef(",
            "+\t\tt, offerMediaHasDirection(offer, RTPCodecTypeAudio, RTPTransceiverDirectionSendonly),",
            "+\t\t\"Direction on SDP is not %s\", RTPTransceiverDirectionSendonly,",
            "+\t)",
            " ",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestAddTransceiverFromTrackSendRecv(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttrack, err := NewTrackLocalStaticSample(",
            " \t\tRTPCodecCapability{MimeType: \"audio/Opus\"},",
            " \t\t\"track-id\",",
            " \t\t\"stream-id\",",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttransceiver, err := pc.AddTransceiverFromTrack(track, RTPTransceiverInit{",
            " \t\tDirection: RTPTransceiverDirectionSendrecv,",
            " \t})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "-",
            "-\tif transceiver.Receiver() == nil {",
            "-\t\tt.Errorf(\"Transceiver should have a receiver\")",
            "-\t}",
            "-",
            "-\tif transceiver.Sender() == nil {",
            "-\t\tt.Errorf(\"Transceiver should have a sender\")",
            "-\t}",
            "-",
            "-\tif len(pc.GetTransceivers()) != 1 {",
            "-\t\tt.Errorf(\"PeerConnection should have one transceiver but has %d\", len(pc.GetTransceivers()))",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NotNil(t, transceiver.Receiver(), \"Transceiver should have a receiver\")",
            "+\tassert.NotNil(t, transceiver.Sender(), \"Transceiver should have a sender\")",
            "+\tassert.Len(t, pc.GetTransceivers(), 1, \"PeerConnection should have one transceiver\")",
            " ",
            " \toffer, err := pc.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif !offerMediaHasDirection(offer, RTPCodecTypeAudio, RTPTransceiverDirectionSendrecv) {",
            "-\t\tt.Errorf(\"Direction on SDP is not %s\", RTPTransceiverDirectionSendrecv)",
            "-\t}",
            "+\tassert.Truef(",
            "+\t\tt, offerMediaHasDirection(offer, RTPCodecTypeAudio, RTPTransceiverDirectionSendrecv),",
            "+\t\t\"Direction on SDP is not %s\", RTPTransceiverDirectionSendrecv,",
            "+\t)",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestAddTransceiverAddTrack_Reuse(t *testing.T) {",
            " \tpc, err := NewPeerConnection(Configuration{})",
            " \tassert.NoError(t, err)",
            " ",
            "@@ -729,75 +796,62 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttransceiver, err := pc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{",
            " \t\tDirection: RTPTransceiverDirectionRecvonly,",
            " \t})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "-",
            "-\tif transceiver.Receiver() == nil {",
            "-\t\tt.Errorf(\"Transceiver should have a receiver\")",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif transceiver.Sender() != nil {",
            "-\t\tt.Errorf(\"Transceiver shouldn't have a sender\")",
            "-\t}",
            "+\tassert.NotNil(t, transceiver.Receiver(), \"Transceiver should have a receiver\")",
            "+\tassert.Nil(t, transceiver.Sender(), \"Transceiver shouldn't have a sender\")",
            " ",
            " \toffer, err := pc.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif !offerMediaHasDirection(offer, RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly) {",
            "-\t\tt.Errorf(\"Direction on SDP is not %s\", RTPTransceiverDirectionRecvonly)",
            "-\t}",
            "+\tassert.Truef(",
            "+\t\tt, offerMediaHasDirection(offer, RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly),",
            "+\t\t\"Direction on SDP is not %s\", RTPTransceiverDirectionRecvonly,",
            "+\t)",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestAddTransceiverFromTrackFailsRecvOnly(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttrack, err := NewTrackLocalStaticSample(",
            " \t\tRTPCodecCapability{",
            " \t\t\tMimeType:    MimeTypeH264,",
            " \t\t\tSDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\",",
            " \t\t},",
            " \t\t\"track-id\",",
            " \t\t\"track-label\",",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttransceiver, err := pc.AddTransceiverFromTrack(track, RTPTransceiverInit{",
            " \t\tDirection: RTPTransceiverDirectionRecvonly,",
            " \t})",
            " ",
            "-\tif transceiver != nil {",
            "-\t\tt.Error(\"AddTransceiverFromTrack shouldn't succeed with Direction RTPTransceiverDirectionRecvonly\")",
            "-\t}",
            "+\tassert.Nil(",
            "+\t\tt, transceiver,",
            "+\t\t\"AddTransceiverFromTrack shouldn't succeed with Direction RTPTransceiverDirectionRecvonly\",",
            "+\t)",
            " ",
            " \tassert.NotNil(t, err)",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestPlanBMediaExchange(t *testing.T) {",
            " \trunTest := func(t *testing.T, trackCount int) {",
            "@@ -1245,17 +1299,15 @@",
            " \t\tfor _, t := range pc.GetTransceivers() {",
            " \t\t\tif t.Sender() != nil && t.Sender().Track() == track {",
            " \t\t\t\thave = true",
            " ",
            " \t\t\t\tbreak",
            " \t\t\t}",
            " \t\t}",
            "-\t\tif !have {",
            "-\t\t\tt.Errorf(\"track was added but not found on senders\")",
            "-\t\t}",
            "+\t\tassert.True(t, have, \"track was added but not found on senders\")",
            " \t}",
            " ",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestPeerConnection_Simulcast(t *testing.T) { //nolint:cyclop",
            " \tlim := test.TimeOut(time.Second * 30)",
            "@@ -1846,14 +1898,15 @@",
            " \t\t\tselect {",
            " \t\t\tcase <-trackFired:",
            " \t\t\t\treturn",
            " \t\t\tcase <-ticker.C:",
            " \t\t\t\tif routineErr := audioTrack.WriteSample(",
            " \t\t\t\t\tmedia.Sample{Data: []byte{0x00}, Duration: time.Second},",
            " \t\t\t\t); routineErr != nil {",
            "+\t\t\t\t\t//nolint:forbidigo // not a test failure",
            " \t\t\t\t\tfmt.Println(routineErr)",
            " \t\t\t\t}",
            " \t\t\t}",
            " \t\t}",
            " \t}()",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_renegotiation_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_renegotiation_test.go",
            "+++ /home/webrtc-4.1.3/peerconnection_renegotiation_test.go",
            "@@ -30,15 +30,15 @@",
            " func sendVideoUntilDone(t *testing.T, done <-chan struct{}, tracks []*TrackLocalStaticSample) {",
            " \tt.Helper()",
            " ",
            " \tfor {",
            " \t\tselect {",
            " \t\tcase <-time.After(20 * time.Millisecond):",
            " \t\t\tfor _, track := range tracks {",
            "-\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))",
            "+\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: 20 * time.Millisecond}))",
            " \t\t\t}",
            " \t\tcase <-done:",
            " \t\t\treturn",
            " \t\t}",
            " \t}",
            " }",
            " ",
            "@@ -97,17 +97,15 @@",
            " \t\t\tlim := test.TimeOut(time.Second * 30)",
            " \t\t\tdefer lim.Stop()",
            " ",
            " \t\t\treport := test.CheckRoutines(t)",
            " \t\t\tdefer report()",
            " ",
            " \t\t\tpcOffer, pcAnswer, err := newPair()",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Fatal(err)",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, err)",
            " ",
            " \t\t\t_, err = pcOffer.AddTransceiverFromKind(",
            " \t\t\t\tRTPCodecTypeVideo,",
            " \t\t\t\tRTPTransceiverInit{",
            " \t\t\t\t\tDirection: RTPTransceiverDirectionRecvonly,",
            " \t\t\t\t},",
            " \t\t\t)",
            "@@ -158,24 +156,20 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\thaveRenegotiated := &atomicBool{}",
            "+\thaveRenegotiated := &atomic.Bool{}",
            " \tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())",
            " \tpcAnswer.OnTrack(func(*TrackRemote, *RTPReceiver) {",
            "-\t\tif !haveRenegotiated.get() {",
            "-\t\t\tt.Fatal(\"OnTrack was called before renegotiation\")",
            "-\t\t}",
            "+\t\tassert.True(t, haveRenegotiated.Load(), \"OnTrack was called before renegotiation\")",
            " \t\tonTrackFiredFunc()",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \t_, err = pcAnswer.AddTransceiverFromKind(",
            " \t\tRTPCodecTypeVideo,",
            "@@ -191,15 +185,15 @@",
            " ",
            " \t// Send 10 packets, OnTrack MUST not be fired",
            " \tfor i := 0; i <= 10; i++ {",
            " \t\tassert.NoError(t, vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))",
            " \t\ttime.Sleep(20 * time.Millisecond)",
            " \t}",
            " ",
            "-\thaveRenegotiated.set(true)",
            "+\thaveRenegotiated.Store(true)",
            " \tassert.False(t, sender.isNegotiated())",
            " \toffer, err := pcOffer.CreateOffer(nil)",
            " \tassert.True(t, sender.isNegotiated())",
            " \tassert.NoError(t, err)",
            " \tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            " \tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))",
            " \tanswer, err := pcAnswer.CreateAnswer(nil)",
            "@@ -246,17 +240,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tpcAnswer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {",
            " \t\tonTrackCount[track.ID()]++",
            " \t\tonTrackChan <- struct{}{}",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            "@@ -285,25 +277,21 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\thaveRenegotiated := &atomicBool{}",
            "+\thaveRenegotiated := &atomic.Bool{}",
            " \tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())",
            " \tvar atomicRemoteTrack atomic.Value",
            " \tpcOffer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {",
            "-\t\tif !haveRenegotiated.get() {",
            "-\t\t\tt.Fatal(\"OnTrack was called before renegotiation\")",
            "-\t\t}",
            "+\t\tassert.True(t, haveRenegotiated.Load(), \"OnTrack was called before renegotiation\")",
            " \t\tonTrackFiredFunc()",
            " \t\tatomicRemoteTrack.Store(track)",
            " \t})",
            " ",
            " \t_, err = pcOffer.AddTransceiverFromKind(",
            " \t\tRTPCodecTypeVideo,",
            " \t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},",
            "@@ -315,15 +303,15 @@",
            " \tassert.NoError(t, err)",
            " ",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \tvp8Track.rtpTrack.id = \"foo2\"",
            " \tvp8Track.rtpTrack.streamID = \"bar2\"",
            " ",
            "-\thaveRenegotiated.set(true)",
            "+\thaveRenegotiated.Store(true)",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \tsendVideoUntilDone(t, onTrackFired.Done(), []*TrackLocalStaticSample{vp8Track})",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " ",
            " \tremoteTrack, ok := atomicRemoteTrack.Load().(*TrackRemote)",
            "@@ -556,17 +544,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t_, err = pcAnswer.AddTransceiverFromKind(",
            " \t\tRTPCodecTypeVideo,",
            " \t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},",
            " \t)",
            " \tassert.NoError(t, err)",
            " ",
            "@@ -605,17 +591,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcFirstOfferer, pcSecondOfferer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())",
            " \tpcFirstOfferer.OnTrack(func(*TrackRemote, *RTPReceiver) {",
            " \t\tonTrackFiredFunc()",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(pcFirstOfferer, pcSecondOfferer))",
            "@@ -659,17 +643,15 @@",
            " \tpcOffer, pcAnswer, err := api.newPair(Configuration{",
            " \t\tICEServers: []ICEServer{",
            " \t\t\t{",
            " \t\t\t\tURLs: []string{\"stun:127.0.0.1:5000\"},",
            " \t\t\t},",
            " \t\t},",
            " \t})",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t_, err = pcOffer.CreateDataChannel(\"test-channel\", nil)",
            " \tassert.NoError(t, err)",
            " ",
            " \tvar wg sync.WaitGroup",
            " \twg.Add(2)",
            " \tpcOffer.OnICECandidate(func(c *ICECandidate) {",
            "@@ -714,17 +696,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())",
            " \tpcOffer.OnTrack(func(*TrackRemote, *RTPReceiver) {",
            " \t\tonTrackFiredFunc()",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            "@@ -793,17 +773,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tpcOfferConnected, pcOfferConnectedCancel := context.WithCancel(context.Background())",
            " \tpcOffer.OnICEConnectionStateChange(func(i ICEConnectionState) {",
            " \t\tif i == ICEConnectionStateConnected {",
            " \t\t\tpcOfferConnectedCancel()",
            " \t\t}",
            " \t})",
            "@@ -924,17 +902,16 @@",
            " \tpc.OnNegotiationNeeded(func() {",
            " \t\tdefer func() {",
            " \t\t\twg.Done()",
            " \t\t}()",
            " \t})",
            " ",
            " \t// Create DataChannel, wait until OnNegotiationNeeded is fired",
            "-\tif _, err = pc.CreateDataChannel(\"testChannel\", nil); err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\t_, err = pc.CreateDataChannel(\"testChannel\", nil)",
            "+\tassert.NoError(t, err)",
            " ",
            " \t// Wait until OnNegotiationNeeded is fired",
            " \twg.Wait()",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestNegotiationNeededRemoveTrack(t *testing.T) {",
            "@@ -1220,17 +1197,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvp8Track, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")",
            " \tassert.NoError(t, err)",
            " \tsender, err := pcOffer.AddTrack(vp8Track)",
            " \tassert.NoError(t, err)",
            " \tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            "@@ -1356,17 +1331,15 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \ttracksCh := make(chan *TrackRemote)",
            " \tpcOffer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {",
            " \t\ttracksCh <- track",
            " \t\tfor {",
            " \t\t\tif _, _, readErr := track.ReadRTP(); errors.Is(readErr, io.EOF) {",
            " \t\t\t\treturn",
            "@@ -1408,33 +1381,26 @@",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpcOffer, pcAnswer, err := newPair()",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvar wg sync.WaitGroup",
            " \twg.Add(1)",
            " \tpcAnswer.OnNegotiationNeeded(wg.Done)",
            " ",
            " \t_, err = pcOffer.AddTransceiverFromKind(",
            " \t\tRTPCodecTypeVideo,",
            " \t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},",
            " \t)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "-",
            "-\tif err := signalPair(pcOffer, pcAnswer); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            " ",
            " \tonDataChannel, onDataChannelCancel := context.WithCancel(context.Background())",
            " \tpcAnswer.OnDataChannel(func(*DataChannel) {",
            " \t\tonDataChannelCancel()",
            " \t})",
            " \t<-onDataChannel.Done()",
            " \twg.Wait()"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/peerconnection_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/peerconnection_test.go",
            "+++ /home/webrtc-4.1.3/peerconnection_test.go",
            "@@ -1,14 +1,13 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package webrtc",
            " ",
            " import (",
            "-\t\"reflect\"",
            " \t\"sync\"",
            " \t\"sync/atomic\"",
            " \t\"testing\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/sdp/v3\"",
            " \t\"github.com/pion/transport/v3/test\"",
            "@@ -250,22 +249,19 @@",
            " \t\t\tconfig: Configuration{",
            " \t\t\t\tICECandidatePoolSize: 1,",
            " \t\t\t},",
            " \t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingICECandidatePoolSize},",
            " \t\t},",
            " \t} {",
            " \t\tpc, err := test.init()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"SetConfiguration %q: init failed: %v\", test.name, err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"SetConfiguration %q: init failed\", test.name)",
            " ",
            " \t\terr = pc.SetConfiguration(test.config)",
            "-\t\tif got, want := err, test.wantErr; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Errorf(\"SetConfiguration %q: err = %v, want %v\", test.name, got, want)",
            "-\t\t}",
            "+\t\t// We use Equal instead of ErrorIs because the error is a pointer to a struct.",
            "+\t\tassert.Equal(t, test.wantErr, err, \"SetConfiguration %q\", test.name)",
            " ",
            " \t\tassert.NoError(t, pc.Close())",
            " \t}",
            " }",
            " ",
            " func TestPeerConnection_GetConfiguration(t *testing.T) {",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "@@ -321,17 +317,15 @@",
            " \t}{",
            " \t\t{SessionDescription{Type: SDPTypeOffer, SDP: minimalOffer}, false},",
            " \t\t{SessionDescription{Type: 0, SDP: \"\"}, true},",
            " \t}",
            " ",
            " \tfor i, testCase := range testCases {",
            " \t\tpeerConn, err := NewPeerConnection(Configuration{})",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"Case %d: got error: %v\", i, err)",
            "-\t\t}",
            "+\t\tassert.NoErrorf(t, err, \"Case %d: got errror\", i)",
            " ",
            " \t\tif testCase.expectError {",
            " \t\t\tassert.Error(t, peerConn.SetRemoteDescription(testCase.desc))",
            " \t\t} else {",
            " \t\t\tassert.NoError(t, peerConn.SetRemoteDescription(testCase.desc))",
            " \t\t}",
            " ",
            "@@ -454,46 +448,38 @@",
            " \t\tdone <- struct{}{}",
            " \t}()",
            " \ttimeout := time.After(5 * time.Second)",
            " \tselect {",
            " \tcase <-done:",
            " \t\tbreak",
            " \tcase <-timeout:",
            "-\t\tt.Fatalf(\"timed out waiting for one or more events handlers to be called (these *were* called: %+v)\", wasCalled)",
            "+\t\tassert.Failf(t, \"timed out waitingfor one or more events handlers to be called\", \"%+v *were* called\", wasCalled)",
            " \t}",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " func TestMultipleOfferAnswer(t *testing.T) {",
            " \tfirstPeerConn, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Errorf(\"New PeerConnection: got error: %v\", err)",
            "-\t}",
            "+\tassert.NoError(t, err, \"New PeerConnection\")",
            " ",
            "-\tif _, err = firstPeerConn.CreateOffer(nil); err != nil {",
            "-\t\tt.Errorf(\"First Offer: got error: %v\", err)",
            "-\t}",
            "-\tif _, err = firstPeerConn.CreateOffer(nil); err != nil {",
            "-\t\tt.Errorf(\"Second Offer: got error: %v\", err)",
            "-\t}",
            "+\t_, err = firstPeerConn.CreateOffer(nil)",
            "+\tassert.NoError(t, err, \"First Offer\")",
            "+\t_, err = firstPeerConn.CreateOffer(nil)",
            "+\tassert.NoError(t, err, \"Second Offer\")",
            " ",
            " \tsecondPeerConn, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Errorf(\"New PeerConnection: got error: %v\", err)",
            "-\t}",
            "+\tassert.NoError(t, err, \"New PeerConnection\")",
            " \tsecondPeerConn.OnICECandidate(func(*ICECandidate) {",
            " \t})",
            " ",
            "-\tif _, err = secondPeerConn.CreateOffer(nil); err != nil {",
            "-\t\tt.Errorf(\"First Offer: got error: %v\", err)",
            "-\t}",
            "-\tif _, err = secondPeerConn.CreateOffer(nil); err != nil {",
            "-\t\tt.Errorf(\"Second Offer: got error: %v\", err)",
            "-\t}",
            "+\t_, err = secondPeerConn.CreateOffer(nil)",
            "+\tassert.NoError(t, err, \"First Offer\")",
            "+\t_, err = secondPeerConn.CreateOffer(nil)",
            "+\tassert.NoError(t, err, \"Second Offer\")",
            " ",
            " \tclosePairNow(t, firstPeerConn, secondPeerConn)",
            " }",
            " ",
            " func TestNoFingerprintInFirstMediaIfSetRemoteDescription(t *testing.T) {",
            " \tconst sdpNoFingerprintInFirstMedia = `v=0",
            " o=- 143087887 1561022767 IN IP4 192.168.84.254",
            "@@ -520,41 +506,35 @@",
            " a=end-of-candidates",
            " `",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tdesc := SessionDescription{",
            " \t\tType: SDPTypeOffer,",
            " \t\tSDP:  sdpNoFingerprintInFirstMedia,",
            " \t}",
            " ",
            "-\tif err = pc.SetRemoteDescription(desc); err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, pc.SetRemoteDescription(desc))",
            " ",
            " \tassert.NoError(t, pc.Close())",
            " }",
            " ",
            " func TestNegotiationNeeded(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tpc, err := NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tvar wg sync.WaitGroup",
            " \twg.Add(1)",
            " ",
            " \tpc.OnNegotiationNeeded(wg.Done)",
            " \t_, err = pc.CreateDataChannel(\"initial_data_channel\", nil)",
            " \tassert.NoError(t, err)",
            "@@ -582,44 +562,35 @@",
            " \t})",
            " ",
            " \tpcOffer.OnNegotiationNeeded(func() {",
            " \t\toffer, err := pcOffer.CreateOffer(nil)",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)",
            "-\t\tif err = pcOffer.SetLocalDescription(offer); err != nil {",
            "-\t\t\tt.Error(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            " \t\t<-offerGatheringComplete",
            "-\t\tif err = pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()); err != nil {",
            "-\t\t\tt.Error(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))",
            " ",
            " \t\tanswer, err := pcAnswer.CreateAnswer(nil)",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)",
            "-\t\tif err = pcAnswer.SetLocalDescription(answer); err != nil {",
            "-\t\t\tt.Error(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))",
            " \t\t<-answerGatheringComplete",
            "-\t\tif err = pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()); err != nil {",
            "-\t\t\tt.Error(err)",
            "-\t\t}",
            "+\t\terr = pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription())",
            "+\t\tassert.NoError(t, err)",
            "+",
            " \t\twg.Done()",
            " \t})",
            " ",
            "-\tif _, err := pcOffer.CreateDataChannel(\"initial_data_channel_0\", nil); err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "-",
            "-\tif _, err := pcOffer.CreateDataChannel(\"initial_data_channel_1\", nil); err != nil {",
            "-\t\tt.Error(err)",
            "-\t}",
            "+\t_, err := pcOffer.CreateDataChannel(\"initial_data_channel_0\", nil)",
            "+\tassert.NoError(t, err)",
            " ",
            "+\t_, err = pcOffer.CreateDataChannel(\"initial_data_channel_1\", nil)",
            "+\tassert.NoError(t, err)",
            " \twg.Wait()",
            " ",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " // Assert that candidates are gathered by calling SetLocalDescription, not SetRemoteDescription.",
            " func TestGatherOnSetLocalDescription(t *testing.T) { //nolint:cyclop",
            "@@ -632,66 +603,53 @@",
            " \tpcOfferGathered := make(chan SessionDescription)",
            " \tpcAnswerGathered := make(chan SessionDescription)",
            " ",
            " \ts := SettingEngine{}",
            " \tapi := NewAPI(WithSettingEngine(s))",
            " ",
            " \tpcOffer, err := api.NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \t// We need to create a data channel in order to trigger ICE",
            "-\tif _, err = pcOffer.CreateDataChannel(\"initial_data_channel\", nil); err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\t_, err = pcOffer.CreateDataChannel(\"initial_data_channel\", nil)",
            "+\tassert.NoError(t, err)",
            " ",
            " \tpcOffer.OnICECandidate(func(i *ICECandidate) {",
            " \t\tif i == nil {",
            " \t\t\tclose(pcOfferGathered)",
            " \t\t}",
            " \t})",
            " ",
            " \toffer, err := pcOffer.CreateOffer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t} else if err = pcOffer.SetLocalDescription(offer); err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NoError(t, pcOffer.SetLocalDescription(offer))",
            " ",
            " \t<-pcOfferGathered",
            " ",
            " \tpcAnswer, err := api.NewPeerConnection(Configuration{})",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tpcAnswer.OnICECandidate(func(i *ICECandidate) {",
            " \t\tif i == nil {",
            " \t\t\tclose(pcAnswerGathered)",
            " \t\t}",
            " \t})",
            " ",
            "-\tif err = pcAnswer.SetRemoteDescription(offer); err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))",
            " ",
            " \tselect {",
            " \tcase <-pcAnswerGathered:",
            "-\t\tt.Fatal(\"pcAnswer started gathering with no SetLocalDescription\")",
            "+\t\tassert.Fail(t, \"pcAnswer started gathering with no SetLocalDescription\")",
            " \t// Gathering is async, not sure of a better way to catch this currently",
            " \tcase <-time.After(3 * time.Second):",
            " \t}",
            " ",
            " \tanswer, err := pcAnswer.CreateAnswer(nil)",
            "-\tif err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t} else if err = pcAnswer.SetLocalDescription(answer); err != nil {",
            "-\t\tt.Error(err.Error())",
            "-\t}",
            "+\tassert.NoError(t, err)",
            "+\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))",
            " \t<-pcAnswerGathered",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " // Assert that SetRemoteDescription handles invalid states.",
            " func TestSetRemoteDescriptionInvalid(t *testing.T) {",
            " \tt.Run(\"local-offer+SetRemoteDescription(Offer)\", func(t *testing.T) {"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/ivfwriter/ivfwriter.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/ivfwriter/ivfwriter.go",
            "+++ /home/webrtc-4.1.3/pkg/media/ivfwriter/ivfwriter.go",
            "@@ -8,15 +8,15 @@",
            " \t\"encoding/binary\"",
            " \t\"errors\"",
            " \t\"io\"",
            " \t\"os\"",
            " ",
            " \t\"github.com/pion/rtp\"",
            " \t\"github.com/pion/rtp/codecs\"",
            "-\t\"github.com/pion/rtp/codecs/av1/frame\"",
            "+\t\"github.com/pion/rtp/codecs/av1/obu\"",
            " )",
            " ",
            " var (",
            " \terrFileNotOpened        = errors.New(\"file not opened\")",
            " \terrInvalidNilPacket     = errors.New(\"invalid nil packet\")",
            " \terrCodecUnset           = errors.New(\"codec is unset\")",
            " \terrCodecAlreadySet      = errors.New(\"codec is already set\")",
            "@@ -40,15 +40,15 @@",
            " \t\tfirstFrameTimestamp uint32",
            " \t\tclockRate           uint64",
            " ",
            " \t\t// VP8, VP9",
            " \t\tcurrentFrame []byte",
            " ",
            " \t\t// AV1",
            "-\t\tav1Frame frame.AV1",
            "+\t\tav1Depacketizer *codecs.AV1Depacketizer",
            " \t}",
            " )",
            " ",
            " const (",
            " \tcodecUnset codec = iota",
            " \tcodecVP8",
            " \tcodecVP9",
            "@@ -93,15 +93,14 @@",
            " \t\t\treturn nil, err",
            " \t\t}",
            " \t}",
            " ",
            " \tif writer.codec == codecUnset {",
            " \t\twriter.codec = codecVP8",
            " \t}",
            "-",
            " \tif err := writer.writeHeader(); err != nil {",
            " \t\treturn nil, err",
            " \t}",
            " ",
            " \tif writer.timebaseDenominator == 0 {",
            " \t\treturn nil, errInvalidMediaTimebase",
            " \t}",
            "@@ -155,101 +154,136 @@",
            " \t}",
            " \t_, err := i.ioWriter.Write(frame)",
            " ",
            " \treturn err",
            " }",
            " ",
            " // WriteRTP adds a new packet and writes the appropriate headers for it.",
            "-func (i *IVFWriter) WriteRTP(packet *rtp.Packet) error { //nolint:cyclop, gocognit",
            "+func (i *IVFWriter) WriteRTP(packet *rtp.Packet) error {",
            " \tif i.ioWriter == nil {",
            " \t\treturn errFileNotOpened",
            " \t} else if len(packet.Payload) == 0 {",
            " \t\treturn nil",
            " \t}",
            " ",
            " \tif i.count == 0 {",
            " \t\ti.firstFrameTimestamp = packet.Timestamp",
            " \t}",
            " \trelativeTstampMs := 1000 * uint64(packet.Timestamp-i.firstFrameTimestamp) / i.clockRate",
            " ",
            " \tswitch i.codec {",
            " \tcase codecVP8:",
            "-\t\tvp8Packet := codecs.VP8Packet{}",
            "-\t\tif _, err := vp8Packet.Unmarshal(packet.Payload); err != nil {",
            "-\t\t\treturn err",
            "-\t\t}",
            "+\t\treturn i.writeVP8(packet, relativeTstampMs)",
            "+\tcase codecVP9:",
            "+\t\treturn i.writeVP9(packet, relativeTstampMs)",
            "+\tcase codecAV1:",
            "+\t\treturn i.writeAV1(packet, relativeTstampMs)",
            "+\tdefault:",
            "+\t\treturn errCodecUnset",
            "+\t}",
            "+}",
            " ",
            "-\t\tisKeyFrame := (vp8Packet.Payload[0] & 0x01) == 0",
            "-\t\tswitch {",
            "-\t\tcase !i.seenKeyFrame && !isKeyFrame:",
            "-\t\t\treturn nil",
            "-\t\tcase i.currentFrame == nil && vp8Packet.S != 1:",
            "-\t\t\treturn nil",
            "-\t\t}",
            "+func (i *IVFWriter) writeVP8(packet *rtp.Packet, timestamp uint64) error {",
            "+\tvp8Packet := codecs.VP8Packet{}",
            "+\tif _, err := vp8Packet.Unmarshal(packet.Payload); err != nil {",
            "+\t\treturn err",
            "+\t}",
            " ",
            "-\t\ti.seenKeyFrame = true",
            "-\t\ti.currentFrame = append(i.currentFrame, vp8Packet.Payload[0:]...)",
            "+\tisKeyFrame := (vp8Packet.Payload[0] & 0x01) == 0",
            "+\tswitch {",
            "+\tcase !i.seenKeyFrame && !isKeyFrame:",
            "+\t\treturn nil",
            "+\tcase i.currentFrame == nil && vp8Packet.S != 1:",
            "+\t\treturn nil",
            "+\t}",
            " ",
            "-\t\tif !packet.Marker {",
            "-\t\t\treturn nil",
            "-\t\t} else if len(i.currentFrame) == 0 {",
            "-\t\t\treturn nil",
            "-\t\t}",
            "+\ti.seenKeyFrame = true",
            "+\ti.currentFrame = append(i.currentFrame, vp8Packet.Payload[0:]...)",
            " ",
            "-\t\tif err := i.writeFrame(i.currentFrame, relativeTstampMs); err != nil {",
            "-\t\t\treturn err",
            "-\t\t}",
            "-\t\ti.currentFrame = nil",
            "-\tcase codecVP9:",
            "-\t\tvp9Packet := codecs.VP9Packet{}",
            "-\t\tif _, err := vp9Packet.Unmarshal(packet.Payload); err != nil {",
            "-\t\t\treturn err",
            "-\t\t}",
            "+\tif !packet.Marker {",
            "+\t\treturn nil",
            "+\t} else if len(i.currentFrame) == 0 {",
            "+\t\treturn nil",
            "+\t}",
            " ",
            "-\t\tswitch {",
            "-\t\tcase !i.seenKeyFrame && vp9Packet.P:",
            "-\t\t\treturn nil",
            "-\t\tcase i.currentFrame == nil && !vp9Packet.B:",
            "-\t\t\treturn nil",
            "-\t\t}",
            "+\tif err := i.writeFrame(i.currentFrame, timestamp); err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+\ti.currentFrame = nil",
            " ",
            "-\t\ti.seenKeyFrame = true",
            "-\t\ti.currentFrame = append(i.currentFrame, vp9Packet.Payload[0:]...)",
            "+\treturn nil",
            "+}",
            " ",
            "-\t\tif !packet.Marker {",
            "-\t\t\treturn nil",
            "-\t\t} else if len(i.currentFrame) == 0 {",
            "+func (i *IVFWriter) writeVP9(packet *rtp.Packet, timestamp uint64) error {",
            "+\tvp9Packet := codecs.VP9Packet{}",
            "+\tif _, err := vp9Packet.Unmarshal(packet.Payload); err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\tswitch {",
            "+\tcase !i.seenKeyFrame && vp9Packet.P:",
            "+\t\treturn nil",
            "+\tcase i.currentFrame == nil && !vp9Packet.B:",
            "+\t\treturn nil",
            "+\t}",
            "+",
            "+\ti.seenKeyFrame = true",
            "+\ti.currentFrame = append(i.currentFrame, vp9Packet.Payload[0:]...)",
            "+",
            "+\tif !packet.Marker {",
            "+\t\treturn nil",
            "+\t} else if len(i.currentFrame) == 0 {",
            "+\t\treturn nil",
            "+\t}",
            "+",
            "+\t// the timestamp must be sequential. webrtc mandates a clock rate of 90000",
            "+\t// and we've assumed 30fps in the header.",
            "+\tif err := i.writeFrame(i.currentFrame, timestamp); err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+\ti.currentFrame = nil",
            "+",
            "+\treturn nil",
            "+}",
            "+",
            "+func (i *IVFWriter) writeAV1(packet *rtp.Packet, timestamp uint64) error {",
            "+\tif i.av1Depacketizer == nil {",
            "+\t\ti.av1Depacketizer = &codecs.AV1Depacketizer{}",
            "+\t}",
            "+",
            "+\tpayload, err := i.av1Depacketizer.Unmarshal(packet.Payload)",
            "+\tif err != nil {",
            "+\t\treturn err",
            "+\t}",
            "+",
            "+\tif !i.seenKeyFrame {",
            "+\t\tisKeyFrame := i.av1Depacketizer.N || (len(payload) > 0 && obu.Type((payload[0]&0x78)>>3) == obu.OBUSequenceHeader)",
            "+\t\tif !isKeyFrame {",
            " \t\t\treturn nil",
            " \t\t}",
            " ",
            "-\t\t// the timestamp must be sequential. webrtc mandates a clock rate of 90000",
            "-\t\t// and we've assumed 30fps in the header.",
            "-\t\tif err := i.writeFrame(i.currentFrame, relativeTstampMs); err != nil {",
            "-\t\t\treturn err",
            "-\t\t}",
            "-\t\ti.currentFrame = nil",
            "-\tcase codecAV1:",
            "-\t\tav1Packet := &codecs.AV1Packet{}",
            "-\t\tif _, err := av1Packet.Unmarshal(packet.Payload); err != nil {",
            "-\t\t\treturn err",
            "-\t\t}",
            "+\t\ti.seenKeyFrame = true",
            "+\t}",
            " ",
            "-\t\tobus, err := i.av1Frame.ReadFrames(av1Packet)",
            "-\t\tif err != nil {",
            "-\t\t\treturn err",
            "-\t\t}",
            "+\ti.currentFrame = append(i.currentFrame, payload...)",
            "+\tif !packet.Marker {",
            "+\t\treturn nil",
            "+\t}",
            " ",
            "-\t\tfor j := range obus {",
            "-\t\t\tif err := i.writeFrame(obus[j], relativeTstampMs); err != nil {",
            "-\t\t\t\treturn err",
            "-\t\t\t}",
            "-\t\t}",
            "-\tdefault:",
            "-\t\treturn errCodecUnset",
            "+\tdelimiter := obu.Header{",
            "+\t\tType:         obu.OBUTemporalDelimiter,",
            "+\t\tHasSizeField: true,",
            "+\t}",
            "+\tframe := append(delimiter.Marshal(), 0)",
            "+\tframe = append(frame, i.currentFrame...)",
            "+",
            "+\tif err := i.writeFrame(frame, timestamp); err != nil {",
            "+\t\treturn err",
            " \t}",
            "+\ti.currentFrame = nil",
            " ",
            " \treturn nil",
            " }",
            " ",
            " // Close stops the recording.",
            " func (i *IVFWriter) Close() error {",
            " \tif i.ioWriter == nil {"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/ivfwriter/ivfwriter_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/ivfwriter/ivfwriter_test.go",
            "+++ /home/webrtc-4.1.3/pkg/media/ivfwriter/ivfwriter_test.go",
            "@@ -259,52 +259,101 @@",
            " func TestIVFWriter_AV1(t *testing.T) {",
            " \tt.Run(\"Unfragmented\", func(t *testing.T) {",
            " \t\tbuffer := &bytes.Buffer{}",
            " ",
            " \t\twriter, err := NewWith(buffer, WithCodec(mimeTypeAV1))",
            " \t\tassert.NoError(t, err)",
            " ",
            "-\t\tassert.NoError(t, writer.WriteRTP(&rtp.Packet{Payload: []byte{0x00, 0x01, 0xFF}}))",
            "+\t\tassert.NoError(",
            "+\t\t\tt,",
            "+\t\t\twriter.WriteRTP(",
            "+\t\t\t\t&rtp.Packet{",
            "+\t\t\t\t\tHeader: rtp.Header{Marker: true},",
            "+\t\t\t\t\t// N = 1, Length = 1, OBU_TYPE = 4",
            "+\t\t\t\t\tPayload: []byte{0x08, 0x01, 0x20},",
            "+\t\t\t\t}),",
            "+\t\t)",
            "+",
            " \t\tassert.NoError(t, writer.Close())",
            " \t\tassert.Equal(t, buffer.Bytes(), []byte{",
            "-\t\t\t0x44, 0x4b, 0x49, 0x46, 0x0, 0x0, 0x20,",
            "-\t\t\t0x0, 0x41, 0x56, 0x30, 0x31, 0x80, 0x2,",
            "-\t\t\t0xe0, 0x1, 0x1e, 0x0, 0x0, 0x0, 0x1, 0x0,",
            "-\t\t\t0x0, 0x0, 0x84, 0x3, 0x0, 0x0, 0x0, 0x0,",
            "-\t\t\t0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,",
            "-\t\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0xff,",
            "+\t\t\t0x44, 0x4b, 0x49, 0x46, 0x0, 0x0, 0x20, 0x0, 0x41, 0x56, 0x30, 0x31,",
            "+\t\t\t0x80, 0x2, 0xe0, 0x1, 0x1e, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x84,",
            "+\t\t\t0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,",
            "+\t\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x22, 0x0,",
            " \t\t})",
            " \t})",
            " ",
            " \tt.Run(\"Fragmented\", func(t *testing.T) {",
            " \t\tbuffer := &bytes.Buffer{}",
            " ",
            " \t\twriter, err := NewWith(buffer, WithCodec(mimeTypeAV1))",
            " \t\tassert.NoError(t, err)",
            " ",
            "-\t\tfor _, p := range [][]byte{{0x40, 0x02, 0x00, 0x01}, {0xc0, 0x02, 0x02, 0x03}, {0xc0, 0x02, 0x04, 0x04}} {",
            "-\t\t\tassert.NoError(t, writer.WriteRTP(&rtp.Packet{Payload: p}))",
            "+\t\tfor _, p := range [][]byte{",
            "+\t\t\t{0x48, 0x02, 0x00, 0x01}, // Y=true",
            "+\t\t\t{0xc0, 0x02, 0x02, 0x03}, // Z=true, Y=true",
            "+\t\t\t{0xc0, 0x02, 0x04, 0x04}, // Z=true, Y=true",
            "+\t\t\t{0x80, 0x01, 0x05},       // Z=true, Y=false (But we still don't set Marker to true)",
            "+\t\t} {",
            "+\t\t\tassert.NoError(t, writer.WriteRTP(&rtp.Packet{Payload: p, Header: rtp.Header{Marker: false}}))",
            " \t\t\tassert.Equal(t, buffer.Bytes(), []byte{",
            " \t\t\t\t0x44, 0x4b, 0x49, 0x46, 0x0,",
            " \t\t\t\t0x0, 0x20, 0x0, 0x41, 0x56, 0x30,",
            " \t\t\t\t0x31, 0x80, 0x2, 0xe0, 0x1, 0x1e,",
            " \t\t\t\t0x0, 0x0, 0x0, 0x1, 0x0, 0x0,",
            " \t\t\t\t0x0, 0x84, 0x3, 0x0, 0x0, 0x0, 0x0,",
            " \t\t\t\t0x0, 0x0,",
            " \t\t\t})",
            " \t\t}",
            "-\t\tassert.NoError(t, writer.WriteRTP(&rtp.Packet{Payload: []byte{0x80, 0x01, 0x05}}))",
            "+\t\tassert.NoError(t, writer.WriteRTP(&rtp.Packet{Payload: []byte{0x08, 0x01, 0x20}, Header: rtp.Header{Marker: true}}))",
            " \t\tassert.Equal(t, buffer.Bytes(), []byte{",
            "-\t\t\t0x44, 0x4b, 0x49, 0x46, 0x0, 0x0, 0x20, 0x0, 0x41, 0x56, 0x30, 0x31, 0x80,",
            "-\t\t\t0x2, 0xe0, 0x1, 0x1e, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x84, 0x3, 0x0, 0x0,",
            "-\t\t\t0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,",
            "-\t\t\t0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x5,",
            "+\t\t\t0x44, 0x4b, 0x49, 0x46, 0x0, 0x0, 0x20, 0x0, 0x41, 0x56, 0x30, 0x31, 0x80, 0x2, 0xe0, 0x1, 0x1e,",
            "+\t\t\t0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x84, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0,",
            "+\t\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x2, 0x6, 0x1, 0x2, 0x3, 0x4, 0x4, 0x5, 0x22, 0x0,",
            " \t\t})",
            " \t\tassert.NoError(t, writer.Close())",
            " \t})",
            "+",
            "+\tt.Run(\"Invalid OBU\", func(t *testing.T) {",
            "+\t\tbuffer := &bytes.Buffer{}",
            "+",
            "+\t\twriter, err := NewWith(buffer, WithCodec(mimeTypeAV1))",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\tassert.Error(t, writer.WriteRTP(&rtp.Packet{Payload: []byte{0x08, 0x02, 0xff}}))",
            "+\t\tassert.Error(t, writer.WriteRTP(&rtp.Packet{Payload: []byte{0x08, 0x01, 0xff}}))",
            "+\t})",
            "+",
            "+\tt.Run(\"Skips middle sequence start\", func(t *testing.T) {",
            "+\t\tbuffer := &bytes.Buffer{}",
            "+",
            "+\t\twriter, err := NewWith(buffer, WithCodec(mimeTypeAV1))",
            "+\t\tassert.NoError(t, err)",
            "+",
            "+\t\tassert.NoError(t, writer.WriteRTP(&rtp.Packet{Header: rtp.Header{Marker: true}, Payload: []byte{0x00, 0x01, 0x20}}))",
            "+",
            "+\t\tassert.NoError(",
            "+\t\t\tt,",
            "+\t\t\twriter.WriteRTP(",
            "+\t\t\t\t&rtp.Packet{",
            "+\t\t\t\t\tHeader: rtp.Header{Marker: true},",
            "+\t\t\t\t\t// N = 1, Length = 1, OBU_TYPE = 4",
            "+\t\t\t\t\tPayload: []byte{0x08, 0x01, 0x20},",
            "+\t\t\t\t},",
            "+\t\t\t),",
            "+\t\t)",
            "+",
            "+\t\tassert.NoError(t, writer.Close())",
            "+\t\tassert.Equal(t, buffer.Bytes(), []byte{",
            "+\t\t\t0x44, 0x4b, 0x49, 0x46, 0x0, 0x0, 0x20, 0x0, 0x41, 0x56, 0x30, 0x31,",
            "+\t\t\t0x80, 0x2, 0xe0, 0x1, 0x1e, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x84,",
            "+\t\t\t0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,",
            "+\t\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x22, 0x0,",
            "+\t\t})",
            "+\t})",
            " }",
            " ",
            " func TestIVFWriter_VP9(t *testing.T) {",
            " \tbuffer := &bytes.Buffer{}",
            " \twriter, err := NewWith(buffer, WithCodec(mimeTypeVP9))",
            " \tassert.NoError(t, err)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/media.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/media.go",
            "+++ /home/webrtc-4.1.3/pkg/media/media.go",
            "@@ -13,15 +13,15 @@",
            " // A Sample contains encoded media and timing information.",
            " type Sample struct {",
            " \tData               []byte",
            " \tTimestamp          time.Time",
            " \tDuration           time.Duration",
            " \tPacketTimestamp    uint32",
            " \tPrevDroppedPackets uint16",
            "-\tMetadata           interface{}",
            "+\tMetadata           any",
            " ",
            " \t// RTP headers of RTP packets forming this Sample. (Optional)",
            " \t// Useful for accessing RTP extensions associated to the Sample.",
            " \tRTPHeaders []*rtp.Header",
            " }",
            " ",
            " // Writer defines an interface to handle"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/rtpdump/reader_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/rtpdump/reader_test.go",
            "+++ /home/webrtc-4.1.3/pkg/media/rtpdump/reader_test.go",
            "@@ -4,17 +4,18 @@",
            " package rtpdump",
            " ",
            " import (",
            " \t\"bytes\"",
            " \t\"errors\"",
            " \t\"io\"",
            " \t\"net\"",
            "-\t\"reflect\"",
            " \t\"testing\"",
            " \t\"time\"",
            "+",
            "+\t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestReader(t *testing.T) { //nolint:maintidx",
            " \tvalidPreamble := []byte(\"#!rtpplay1.0 224.2.0.1/3456\\n\")",
            " ",
            " \tfor _, test := range []struct {",
            " \t\tName        string",
            "@@ -246,25 +247,21 @@",
            " \t\t\t\t\t},",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t\tWantErr: nil,",
            " \t\t},",
            " \t} {",
            " \t\treader, hdr, err := NewReader(bytes.NewReader(test.Data))",
            "+\t\t// we validate the error again. at the end of the reading loop.",
            " \t\tif err != nil {",
            "-\t\t\tif got, want := err, test.WantErr; !errors.Is(got, want) {",
            "-\t\t\t\tt.Fatalf(\"NewReader(%s) err=%v want %v\", test.Name, got, want)",
            "-\t\t\t}",
            "+\t\t\tassert.ErrorIs(t, err, test.WantErr, test.Name)",
            " ",
            " \t\t\tcontinue",
            " \t\t}",
            "-",
            "-\t\tif got, want := hdr, test.WantHeader; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Fatalf(\"%q Header = %#v, want %#v\", test.Name, got, want)",
            "-\t\t}",
            "+\t\tassert.Equal(t, test.WantHeader, hdr, test.Name)",
            " ",
            " \t\tvar nextErr error",
            " \t\tvar packets []Packet",
            " \t\tfor {",
            " \t\t\tpkt, err := reader.Next()",
            " \t\t\tif errors.Is(err, io.EOF) {",
            " \t\t\t\tbreak",
            "@@ -274,15 +271,15 @@",
            " ",
            " \t\t\t\tbreak",
            " \t\t\t}",
            " ",
            " \t\t\tpackets = append(packets, pkt)",
            " \t\t}",
            " ",
            "-\t\tif got, want := nextErr, test.WantErr; !errors.Is(got, want) {",
            "-\t\t\tt.Fatalf(\"%s err=%v want %v\", test.Name, got, want)",
            "-\t\t}",
            "-\t\tif got, want := packets, test.WantPackets; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Fatalf(\"%q packets=%#v, want %#v\", test.Name, got, want)",
            "+\t\tif test.WantErr != nil {",
            "+\t\t\tassert.ErrorIs(t, nextErr, test.WantErr, test.Name)",
            "+\t\t} else {",
            "+\t\t\tassert.NoError(t, nextErr, test.Name)",
            " \t\t}",
            "+\t\tassert.Equal(t, test.WantPackets, packets, test.Name)",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/rtpdump/rtpdump_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/rtpdump/rtpdump_test.go",
            "+++ /home/webrtc-4.1.3/pkg/media/rtpdump/rtpdump_test.go",
            "@@ -1,18 +1,18 @@",
            " // SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>",
            " // SPDX-License-Identifier: MIT",
            " ",
            " package rtpdump",
            " ",
            " import (",
            "-\t\"errors\"",
            " \t\"net\"",
            "-\t\"reflect\"",
            " \t\"testing\"",
            " \t\"time\"",
            "+",
            "+\t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestHeaderRoundTrip(t *testing.T) {",
            " \tfor _, test := range []struct {",
            " \t\tHeader Header",
            " \t}{",
            " \t\t{",
            "@@ -27,26 +27,19 @@",
            " \t\t\t\tStart:  time.Date(2019, 3, 25, 1, 1, 1, 0, time.UTC),",
            " \t\t\t\tSource: net.IPv4(1, 2, 3, 4),",
            " \t\t\t\tPort:   8080,",
            " \t\t\t},",
            " \t\t},",
            " \t} {",
            " \t\td, err := test.Header.Marshal()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tvar hdr Header",
            "-\t\tif err := hdr.Unmarshal(d); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "-",
            "-\t\tif got, want := hdr, test.Header; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Fatalf(\"Unmarshal(%v.Marshal()) = %v, want identical\", got, want)",
            "-\t\t}",
            "+\t\tassert.NoError(t, hdr.Unmarshal(d))",
            "+\t\tassert.Equal(t, test.Header, hdr)",
            " \t}",
            " }",
            " ",
            " func TestMarshalHeader(t *testing.T) {",
            " \tfor _, test := range []struct {",
            " \t\tName    string",
            " \t\tHeader  Header",
            "@@ -65,21 +58,16 @@",
            " \t\t\t\t0x00, 0x00, 0x00, 0x00,",
            " \t\t\t\t0x00, 0x00, 0x00, 0x00,",
            " \t\t\t\t0x00, 0x00, 0x00, 0x00,",
            " \t\t\t},",
            " \t\t},",
            " \t} {",
            " \t\tdata, err := test.Header.Marshal()",
            "-\t\tif got, want := err, test.WantErr; !errors.Is(got, want) {",
            "-\t\t\tt.Fatalf(\"Marshal(%q) err=%v, want %v\", test.Name, got, want)",
            "-\t\t}",
            "-",
            "-\t\tif got, want := data, test.Want; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Fatalf(\"Marshal(%q) = %v, want %v\", test.Name, got, want)",
            "-\t\t}",
            "+\t\tassert.ErrorIs(t, err, test.WantErr)",
            "+\t\tassert.Equal(t, test.Want, data)",
            " \t}",
            " }",
            " ",
            " func TestPacketRoundTrip(t *testing.T) {",
            " \tfor _, test := range []struct {",
            " \t\tPacket Packet",
            " \t}{",
            "@@ -102,21 +90,15 @@",
            " \t\t\t\tOffset:  123 * time.Millisecond,",
            " \t\t\t\tIsRTCP:  false,",
            " \t\t\t\tPayload: []byte{1, 2, 3, 4},",
            " \t\t\t},",
            " \t\t},",
            " \t} {",
            " \t\tpacket, err := test.Packet.Marshal()",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err)",
            " ",
            " \t\tvar pkt Packet",
            "-\t\tif err := pkt.Unmarshal(packet); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "-",
            "-\t\tif got, want := pkt, test.Packet; !reflect.DeepEqual(got, want) {",
            "-\t\t\tt.Fatalf(\"Unmarshal(%v.Marshal()) = %v, want identical\", got, want)",
            "-\t\t}",
            "+\t\tassert.NoError(t, pkt.Unmarshal(packet))",
            "+",
            "+\t\tassert.Equal(t, test.Packet, pkt)",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/rtpdump/writer_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/rtpdump/writer_test.go",
            "+++ /home/webrtc-4.1.3/pkg/media/rtpdump/writer_test.go",
            "@@ -4,55 +4,50 @@",
            " package rtpdump",
            " ",
            " import (",
            " \t\"bytes\"",
            " \t\"errors\"",
            " \t\"io\"",
            " \t\"net\"",
            "-\t\"reflect\"",
            " \t\"testing\"",
            " \t\"time\"",
            "+",
            "+\t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestWriter(t *testing.T) {",
            " \tbuf := bytes.NewBuffer(nil)",
            " ",
            " \twriter, err := NewWriter(buf, Header{",
            " \t\tStart:  time.Unix(9, 0),",
            " \t\tSource: net.IPv4(2, 2, 2, 2),",
            " \t\tPort:   2222,",
            " \t})",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif err := writer.WritePacket(Packet{",
            "+\tassert.NoError(t, writer.WritePacket(Packet{",
            " \t\tOffset:  time.Millisecond,",
            " \t\tIsRTCP:  false,",
            " \t\tPayload: []byte{9},",
            "-\t}); err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\t}))",
            " ",
            " \texpected := append(",
            " \t\t[]byte(\"#!rtpplay1.0 2.2.2.2/2222\\n\"),",
            " \t\t// header",
            " \t\t0x00, 0x00, 0x00, 0x09,",
            " \t\t0x00, 0x00, 0x00, 0x00,",
            " \t\t0x02, 0x02, 0x02, 0x02,",
            " \t\t0x08, 0xae, 0x00, 0x00,",
            " \t\t// packet header",
            " \t\t0x00, 0x09, 0x00, 0x01,",
            " \t\t0x00, 0x00, 0x00, 0x01,",
            " \t\t0x09,",
            " \t)",
            " ",
            "-\tif got, want := buf.Bytes(), expected; !reflect.DeepEqual(got, want) {",
            "-\t\tt.Fatalf(\"wrote %v, want %v\", got, want)",
            "-\t}",
            "+\tassert.Equal(t, expected, buf.Bytes())",
            " }",
            " ",
            " func TestRoundTrip(t *testing.T) {",
            " \tbuf := bytes.NewBuffer(nil)",
            " ",
            " \tpackets := []Packet{",
            " \t\t{",
            "@@ -69,43 +64,30 @@",
            " \thdr := Header{",
            " \t\tStart:  time.Unix(9, 0).UTC(),",
            " \t\tSource: net.IPv4(2, 2, 2, 2),",
            " \t\tPort:   2222,",
            " \t}",
            " ",
            " \twriter, err := NewWriter(buf, hdr)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tfor _, pkt := range packets {",
            "-\t\tif err = writer.WritePacket(pkt); err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "+\t\tassert.NoError(t, writer.WritePacket(pkt))",
            " \t}",
            " ",
            " \treader, hdr2, err := NewReader(buf)",
            "-\tif err != nil {",
            "-\t\tt.Fatal(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            "-\tif got, want := hdr2, hdr; !reflect.DeepEqual(got, want) {",
            "-\t\tt.Fatalf(\"round trip: header=%v, want %v\", got, want)",
            "-\t}",
            "+\tassert.Equal(t, hdr, hdr2, \"round trip: header\")",
            " ",
            " \tvar packets2 []Packet",
            " \tfor {",
            " \t\tpkt, err := reader.Next()",
            " \t\tif errors.Is(err, io.EOF) {",
            " \t\t\tbreak",
            " \t\t}",
            "-\t\tif err != nil {",
            "-\t\t\tt.Fatal(err)",
            "-\t\t}",
            "-",
            "+\t\tassert.NoError(t, err)",
            " \t\tpackets2 = append(packets2, pkt)",
            " \t}",
            " ",
            "-\tif got, want := packets2, packets; !reflect.DeepEqual(got, want) {",
            "-\t\tt.Fatalf(\"round trip: packets=%v, want %v\", got, want)",
            "-\t}",
            "+\tassert.Equal(t, packets, packets2, \"round trip: packets\")",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/samplebuilder/samplebuilder.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/samplebuilder/samplebuilder.go",
            "+++ /home/webrtc-4.1.3/pkg/media/samplebuilder/samplebuilder.go",
            "@@ -43,15 +43,15 @@",
            " \t// number of packets forced to be dropped",
            " \tdroppedPackets uint16",
            " ",
            " \t// number of padding packets detected and dropped (this will be a subset of `droppedPackets`)",
            " \tpaddingPackets uint16",
            " ",
            " \t// allows inspecting head packets of each sample and then returns a custom metadata",
            "-\tpacketHeadHandler func(headPacket interface{}) interface{}",
            "+\tpacketHeadHandler func(headPacket any) any",
            " ",
            " \t// return array of RTP headers as Sample.RTPHeaders",
            " \treturnRTPHeaders bool",
            " }",
            " ",
            " // New constructs a new SampleBuilder.",
            " // maxLate is how long to wait until we can construct a completed media.Sample.",
            "@@ -285,15 +285,15 @@",
            " \t\ts.purgeConsumedBuffers()",
            " ",
            " \t\treturn nil",
            " \t}",
            " ",
            " \t// merge all the buffers into a sample",
            " \tdata := []byte{}",
            "-\tvar metadata interface{}",
            "+\tvar metadata any",
            " \tvar rtpHeaders []*rtp.Header",
            " \tfor i := consume.head; i != consume.tail; i++ {",
            " \t\tpayload, err := s.depacketizer.Unmarshal(s.buffer[i].Payload)",
            " \t\tif err != nil {",
            " \t\t\treturn nil",
            " \t\t}",
            " \t\tif i == consume.head && s.packetHeadHandler != nil {",
            "@@ -374,15 +374,15 @@",
            " \treturn func(o *SampleBuilder) {",
            " \t\to.packetReleaseHandler = h",
            " \t}",
            " }",
            " ",
            " // WithPacketHeadHandler set a head packet handler to allow inspecting",
            " // the packet to extract certain information and return as custom metadata.",
            "-func WithPacketHeadHandler(h func(headPacket interface{}) interface{}) Option {",
            "+func WithPacketHeadHandler(h func(headPacket any) any) Option {",
            " \treturn func(o *SampleBuilder) {",
            " \t\to.packetHeadHandler = h",
            " \t}",
            " }",
            " ",
            " // WithMaxTimeDelay ensures that packets that are too old in the buffer get",
            " // purged based on time rather than building up an extraordinarily long delay."
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/pkg/media/samplebuilder/samplebuilder_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/pkg/media/samplebuilder/samplebuilder_test.go",
            "+++ /home/webrtc-4.1.3/pkg/media/samplebuilder/samplebuilder_test.go",
            "@@ -400,18 +400,15 @@",
            " \t\t{0xFFF3, 0xFFF1, 0x0002},",
            " \t\t{0xFFF1, 0xFFF3, 0x0002},",
            " \t\t{0xFFFF, 0x0001, 0x0002},",
            " \t\t{0x0001, 0xFFFF, 0x0002},",
            " \t}",
            " ",
            " \tfor _, data := range testData {",
            "-\t\tif ret := seqnumDistance(data.x, data.y); ret != data.d {",
            "-\t\t\tt.Errorf(\"seqnumDistance(%d, %d) returned %d which must be %d\",",
            "-\t\t\t\tdata.x, data.y, ret, data.d)",
            "-\t\t}",
            "+\t\tassert.Equalf(t, data.d, seqnumDistance(data.x, data.y), \"seqnumDistance(%d, %d)\", data.x, data.y)",
            " \t}",
            " }",
            " ",
            " func TestSampleBuilderCleanReference(t *testing.T) {",
            " \tfor _, seqStart := range []uint16{",
            " \t\t0,",
            " \t\t0xFFF8, // check upper boundary",
            "@@ -426,24 +423,27 @@",
            " \t\t\tfd.Push(&rtp.Packet{Header: rtp.Header{SequenceNumber: 2 + seqStart, Timestamp: 0}, Payload: []byte{0x03}})",
            " \t\t\tpkt4 := &rtp.Packet{Header: rtp.Header{SequenceNumber: 14 + seqStart, Timestamp: 120}, Payload: []byte{0x04}}",
            " \t\t\tfd.Push(pkt4)",
            " \t\t\tpkt5 := &rtp.Packet{Header: rtp.Header{SequenceNumber: 12 + seqStart, Timestamp: 120}, Payload: []byte{0x05}}",
            " \t\t\tfd.Push(pkt5)",
            " ",
            " \t\t\tfor i := 0; i < 3; i++ {",
            "-\t\t\t\tif fd.buffer[(i+int(seqStart))%0x10000] != nil {",
            "-\t\t\t\t\tt.Errorf(\"Old packet (%d) is not unreferenced (maxLate: 10, pushed: 12)\", i)",
            "-\t\t\t\t}",
            "-\t\t\t}",
            "-\t\t\tif fd.buffer[(14+int(seqStart))%0x10000] != pkt4 {",
            "-\t\t\t\tt.Error(\"New packet must be referenced after jump\")",
            "-\t\t\t}",
            "-\t\t\tif fd.buffer[(12+int(seqStart))%0x10000] != pkt5 {",
            "-\t\t\t\tt.Error(\"New packet must be referenced after jump\")",
            "+\t\t\t\tassert.Nilf(",
            "+\t\t\t\t\tt, fd.buffer[(i+int(seqStart))%0x10000],",
            "+\t\t\t\t\t\"Old packet (%d) is not unreferenced (maxLate: 10, pushed: 12)\", i,",
            "+\t\t\t\t)",
            " \t\t\t}",
            "+\t\t\tassert.Equal(",
            "+\t\t\t\tt, pkt4, fd.buffer[(14+int(seqStart))%0x10000],",
            "+\t\t\t\t\"New packet must be referenced after jump\",",
            "+\t\t\t)",
            "+\t\t\tassert.Equal(",
            "+\t\t\t\tt, pkt5, fd.buffer[(12+int(seqStart))%0x10000],",
            "+\t\t\t\t\"New packet must be referenced after jump\",",
            "+\t\t\t)",
            " \t\t})",
            " \t}",
            " }",
            " ",
            " func TestSampleBuilderPushMaxZero(t *testing.T) {",
            " \t// Test packets released via 'maxLate' of zero.",
            " \tpkts := []rtp.Packet{",
            "@@ -452,17 +452,15 @@",
            " \td := &fakeDepacketizer{",
            " \t\theadChecker: true,",
            " \t\theadBytes:   []byte{0x01},",
            " \t}",
            " ",
            " \ts := New(0, d, 1)",
            " \ts.Push(&pkts[0])",
            "-\tif sample := s.Pop(); sample == nil {",
            "-\t\tt.Error(\"Should expect a popped sample\")",
            "-\t}",
            "+\tassert.NotNil(t, s.Pop(), \"Should expect a sample\")",
            " }",
            " ",
            " func TestSampleBuilderWithPacketReleaseHandler(t *testing.T) {",
            " \tvar released []*rtp.Packet",
            " \tfakePacketReleaseHandler := func(p *rtp.Packet) {",
            " \t\treleased = append(released, p)",
            " \t}",
            "@@ -474,46 +472,36 @@",
            " \t\t{Header: rtp.Header{SequenceNumber: 12, Timestamp: 121}, Payload: []byte{0x03}},",
            " \t\t{Header: rtp.Header{SequenceNumber: 13, Timestamp: 122}, Payload: []byte{0x04}},",
            " \t\t{Header: rtp.Header{SequenceNumber: 21, Timestamp: 200}, Payload: []byte{0x05}},",
            " \t}",
            " \tfd := New(10, &fakeDepacketizer{}, 1, WithPacketReleaseHandler(fakePacketReleaseHandler))",
            " \tfd.Push(&pkts[0])",
            " \tfd.Push(&pkts[1])",
            "-\tif len(released) == 0 {",
            "-\t\tt.Errorf(\"Old packet is not released\")",
            "-\t}",
            "-\tif len(released) > 0 && released[0].SequenceNumber != pkts[0].SequenceNumber {",
            "-\t\tt.Errorf(\"Unexpected packet released by maxLate\")",
            "-\t}",
            "+\tassert.NotEmpty(t, released, \"Old packet is not released\")",
            "+\tassert.Equal(t, pkts[0].SequenceNumber, released[0].SequenceNumber, \"Unexpected packet released by maxLate\")",
            " \t// Test packets released after samples built.",
            " \tfd.Push(&pkts[2])",
            " \tfd.Push(&pkts[3])",
            " \tfd.Push(&pkts[4])",
            "-\tif fd.Pop() == nil {",
            "-\t\tt.Errorf(\"Should have some sample here.\")",
            "-\t}",
            "-\tif len(released) < 3 {",
            "-\t\tt.Errorf(\"packet built with sample is not released\")",
            "-\t}",
            "-\tif len(released) >= 2 && released[2].SequenceNumber != pkts[2].SequenceNumber {",
            "-\t\tt.Errorf(\"Unexpected packet released by samples built\")",
            "-\t}",
            "+\tassert.NotNil(t, fd.Pop(), \"Should have some sample here.\")",
            "+\tassert.GreaterOrEqual(t, len(released), 3, \"packet built with sample is not released\")",
            "+\tassert.Equal(t, pkts[2].SequenceNumber, released[2].SequenceNumber, \"Unexpected packet released by samples built\")",
            " }",
            " ",
            " func TestSampleBuilderWithPacketHeadHandler(t *testing.T) {",
            " \tpackets := []*rtp.Packet{",
            " \t\t{Header: rtp.Header{SequenceNumber: 5000, Timestamp: 5}, Payload: []byte{0x01}},",
            " \t\t{Header: rtp.Header{SequenceNumber: 5001, Timestamp: 5}, Payload: []byte{0x02}},",
            " \t\t{Header: rtp.Header{SequenceNumber: 5002, Timestamp: 6}, Payload: []byte{0x01}},",
            " \t\t{Header: rtp.Header{SequenceNumber: 5003, Timestamp: 6}, Payload: []byte{0x02}},",
            " \t\t{Header: rtp.Header{SequenceNumber: 5004, Timestamp: 7}, Payload: []byte{0x01}},",
            " \t}",
            " ",
            " \theadCount := 0",
            "-\ts := New(10, &fakeDepacketizer{}, 1, WithPacketHeadHandler(func(interface{}) interface{} {",
            "+\ts := New(10, &fakeDepacketizer{}, 1, WithPacketHeadHandler(func(any) any {",
            " \t\theadCount++",
            " ",
            " \t\treturn true",
            " \t}))",
            " ",
            " \tfor _, pkt := range packets {",
            " \t\ts.Push(pkt)",
            "@@ -617,17 +605,15 @@",
            " \t\tPayload: []byte{0x01, 0x11},",
            " \t}) // Valid packet",
            " \tfd.Push(&rtp.Packet{",
            " \t\tHeader:  rtp.Header{SequenceNumber: 1011, Timestamp: 10, Marker: true},",
            " \t\tPayload: []byte{0x01, 0x12},",
            " \t}) // Valid packet",
            " ",
            "-\tif sample := fd.Pop(); sample != nil {",
            "-\t\tt.Fatal(\"Unexpected sample is returned. Test precondition may be broken\")",
            "-\t}",
            "+\tassert.Nil(t, fd.Pop(), \"Unexpected sample is returned. Test precondition may be broken\")",
            " ",
            " \tfd.Flush()",
            " ",
            " \tsamples := []*media.Sample{}",
            " \tfor sample := fd.Pop(); sample != nil; sample = fd.Pop() {",
            " \t\tsamples = append(samples, sample)",
            " \t}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/rtpcodec.go",
          "change": [
            "--- /home/webrtc-4.0.11/rtpcodec.go",
            "+++ /home/webrtc-4.1.3/rtpcodec.go",
            "@@ -151,14 +151,25 @@",
            " \t\t\treturn c.PayloadType",
            " \t\t}",
            " \t}",
            " ",
            " \treturn PayloadType(0)",
            " }",
            " ",
            "+// For now, only FlexFEC is supported.",
            "+func findFECPayloadType(haystack []RTPCodecParameters) PayloadType {",
            "+\tfor _, c := range haystack {",
            "+\t\tif strings.Contains(c.RTPCodecCapability.MimeType, MimeTypeFlexFEC) {",
            "+\t\t\treturn c.PayloadType",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn PayloadType(0)",
            "+}",
            "+",
            " func rtcpFeedbackIntersection(a, b []RTCPFeedback) (out []RTCPFeedback) {",
            " \tfor _, aFeedback := range a {",
            " \t\tfor _, bFeeback := range b {",
            " \t\t\tif aFeedback.Type == bFeeback.Type && aFeedback.Parameter == bFeeback.Parameter {",
            " \t\t\t\tout = append(out, aFeedback)",
            " ",
            " \t\t\t\tbreak"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/rtpreceiver.go",
          "change": [
            "--- /home/webrtc-4.0.11/rtpreceiver.go",
            "+++ /home/webrtc-4.1.3/rtpreceiver.go",
            "@@ -57,15 +57,15 @@",
            " // RTPReceiver allows an application to inspect the receipt of a TrackRemote.",
            " type RTPReceiver struct {",
            " \tkind      RTPCodecType",
            " \ttransport *DTLSTransport",
            " ",
            " \ttracks []trackStreams",
            " ",
            "-\tclosed, received chan interface{}",
            "+\tclosed, received chan any",
            " \tmu               sync.RWMutex",
            " ",
            " \ttr *RTPTransceiver",
            " ",
            " \t// A reference to the associated api object",
            " \tapi *API",
            " ",
            "@@ -78,18 +78,18 @@",
            " \t\treturn nil, errRTPReceiverDTLSTransportNil",
            " \t}",
            " ",
            " \tr := &RTPReceiver{",
            " \t\tkind:      kind,",
            " \t\ttransport: transport,",
            " \t\tapi:       api,",
            "-\t\tclosed:    make(chan interface{}),",
            "-\t\treceived:  make(chan interface{}),",
            "+\t\tclosed:    make(chan any),",
            "+\t\treceived:  make(chan any),",
            " \t\ttracks:    []trackStreams{},",
            "-\t\trtxPool: sync.Pool{New: func() interface{} {",
            "+\t\trtxPool: sync.Pool{New: func() any {",
            " \t\t\treturn make([]byte, api.settingEngine.getReceiveMTU())",
            " \t\t}},",
            " \t}",
            " ",
            " \treturn r, nil",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/rtpsender.go",
          "change": [
            "--- /home/webrtc-4.0.11/rtpsender.go",
            "+++ /home/webrtc-4.1.3/rtpsender.go",
            "@@ -351,15 +351,15 @@",
            " \t\ttrackEncoding.streamInfo = *createStreamInfo(",
            " \t\t\tr.id,",
            " \t\t\tparameters.Encodings[idx].SSRC,",
            " \t\t\tparameters.Encodings[idx].RTX.SSRC,",
            " \t\t\tparameters.Encodings[idx].FEC.SSRC,",
            " \t\t\tcodec.PayloadType,",
            " \t\t\tfindRTXPayloadType(codec.PayloadType, rtpParameters.Codecs),",
            "-\t\t\t0,",
            "+\t\t\tfindFECPayloadType(rtpParameters.Codecs),",
            " \t\t\tcodec.RTPCodecCapability,",
            " \t\t\tparameters.HeaderExtensions,",
            " \t\t)",
            " ",
            " \t\trtpInterceptor := r.api.interceptor.BindLocalStream(",
            " \t\t\t&trackEncoding.streamInfo,",
            " \t\t\tinterceptor.RTPWriterFunc(func(header *rtp.Header, payload []byte, _ interceptor.Attributes) (int, error) {",
            "@@ -433,19 +433,24 @@",
            " \treturn pkts, attributes, nil",
            " }",
            " ",
            " // ReadSimulcast reads incoming RTCP for this RTPSender for given rid.",
            " func (r *RTPSender) ReadSimulcast(b []byte, rid string) (n int, a interceptor.Attributes, err error) {",
            " \tselect {",
            " \tcase <-r.sendCalled:",
            "+\t\tr.mu.Lock()",
            " \t\tfor _, t := range r.trackEncodings {",
            " \t\t\tif t.track != nil && t.track.RID() == rid {",
            "-\t\t\t\treturn t.rtcpInterceptor.Read(b, a)",
            "+\t\t\t\treader := t.rtcpInterceptor",
            "+\t\t\t\tr.mu.Unlock()",
            "+",
            "+\t\t\t\treturn reader.Read(b, a)",
            " \t\t\t}",
            " \t\t}",
            "+\t\tr.mu.Unlock()",
            " ",
            " \t\treturn 0, nil, fmt.Errorf(\"%w: %s\", errRTPSenderNoTrackForRID, rid)",
            " \tcase <-r.stopCalled:",
            " \t\treturn 0, nil, io.ErrClosedPipe",
            " \t}",
            " }"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/rtpsender_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/rtpsender_test.go",
            "+++ /home/webrtc-4.1.3/rtpsender_test.go",
            "@@ -61,15 +61,15 @@",
            " \t\t\tcase pkt.Payload[len(pkt.Payload)-1] == 0xAA:",
            " \t\t\t\tassert.Equal(t, track.Codec().MimeType, MimeTypeVP8)",
            " \t\t\t\tseenPacketACancel()",
            " \t\t\tcase pkt.Payload[len(pkt.Payload)-1] == 0xBB:",
            " \t\t\t\tassert.Equal(t, track.Codec().MimeType, MimeTypeH264)",
            " \t\t\t\tseenPacketBCancel()",
            " \t\t\tdefault:",
            "-\t\t\t\tt.Fatalf(\"Unexpected RTP Data % 02x\", pkt.Payload[len(pkt.Payload)-1])",
            "+\t\t\t\tassert.Failf(t, \"Unexpected RTP\", \"Data % 02x\", pkt.Payload[len(pkt.Payload)-1])",
            " \t\t\t}",
            " \t\t}",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(sender, receiver))",
            " ",
            " \t// Block Until packet with 0xAA has been seen"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/rtptransceiver_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/rtptransceiver_test.go",
            "+++ /home/webrtc-4.1.3/rtptransceiver_test.go",
            "@@ -14,16 +14,16 @@",
            " )",
            " ",
            " func Test_RTPTransceiver_SetCodecPreferences(t *testing.T) {",
            " \tmediaEngine := &MediaEngine{}",
            " \tapi := NewAPI(WithMediaEngine(mediaEngine))",
            " \tassert.NoError(t, mediaEngine.RegisterDefaultCodecs())",
            " ",
            "-\tmediaEngine.pushCodecs(mediaEngine.videoCodecs, RTPCodecTypeVideo)",
            "-\tmediaEngine.pushCodecs(mediaEngine.audioCodecs, RTPCodecTypeAudio)",
            "+\tassert.NoError(t, mediaEngine.pushCodecs(mediaEngine.videoCodecs, RTPCodecTypeVideo))",
            "+\tassert.NoError(t, mediaEngine.pushCodecs(mediaEngine.audioCodecs, RTPCodecTypeAudio))",
            " ",
            " \ttr := RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: mediaEngine.videoCodecs}",
            " \tassert.EqualValues(t, mediaEngine.videoCodecs, tr.getCodecs())",
            " ",
            " \tfailTestCases := [][]RTPCodecParameters{",
            " \t\t{",
            " \t\t\t{"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/sctptransport.go",
          "change": [
            "--- /home/webrtc-4.0.11/sctptransport.go",
            "+++ /home/webrtc-4.1.3/sctptransport.go",
            "@@ -5,15 +5,14 @@",
            " // +build !js",
            " ",
            " package webrtc",
            " ",
            " import (",
            " \t\"errors\"",
            " \t\"io\"",
            "-\t\"math\"",
            " \t\"sync\"",
            " \t\"time\"",
            " ",
            " \t\"github.com/pion/datachannel\"",
            " \t\"github.com/pion/logging\"",
            " \t\"github.com/pion/sctp\"",
            " \t\"github.com/pion/webrtc/v4/pkg/rtcerr\"",
            "@@ -30,18 +29,14 @@",
            " \t// State represents the current state of the SCTP transport.",
            " \tstate SCTPTransportState",
            " ",
            " \t// SCTPTransportState doesn't have an enum to distinguish between New/Connecting",
            " \t// so we need a dedicated field",
            " \tisStarted bool",
            " ",
            "-\t// MaxMessageSize represents the maximum size of data that can be passed to",
            "-\t// DataChannel's send() method.",
            "-\tmaxMessageSize float64",
            "-",
            " \t// MaxChannels represents the maximum amount of DataChannel's that can",
            " \t// be used simultaneously.",
            " \tmaxChannels *uint16",
            " ",
            " \t// OnStateChange  func()",
            " ",
            " \tonErrorHandler func(error)",
            "@@ -70,15 +65,14 @@",
            " \t\tdtlsTransport:      dtls,",
            " \t\tstate:              SCTPTransportStateConnecting,",
            " \t\tapi:                api,",
            " \t\tlog:                api.settingEngine.LoggerFactory.NewLogger(\"ortc\"),",
            " \t\tdataChannelIDsUsed: make(map[uint16]struct{}),",
            " \t}",
            " ",
            "-\tres.updateMessageSize()",
            " \tres.updateMaxChannels()",
            " ",
            " \treturn res",
            " }",
            " ",
            " // Transport returns the DTLSTransport instance the SCTPTransport is sending over.",
            " func (r *SCTPTransport) Transport() *DTLSTransport {",
            "@@ -86,39 +80,54 @@",
            " \tdefer r.lock.RUnlock()",
            " ",
            " \treturn r.dtlsTransport",
            " }",
            " ",
            " // GetCapabilities returns the SCTPCapabilities of the SCTPTransport.",
            " func (r *SCTPTransport) GetCapabilities() SCTPCapabilities {",
            "+\tvar maxMessageSize uint32",
            "+\tif a := r.association(); a != nil {",
            "+\t\tmaxMessageSize = a.MaxMessageSize()",
            "+\t}",
            "+",
            " \treturn SCTPCapabilities{",
            "-\t\tMaxMessageSize: 0,",
            "+\t\tMaxMessageSize: maxMessageSize,",
            " \t}",
            " }",
            " ",
            " // Start the SCTPTransport. Since both local and remote parties must mutually",
            " // create an SCTPTransport, SCTP SO (Simultaneous Open) is used to establish",
            " // a connection over SCTP.",
            "-func (r *SCTPTransport) Start(_ SCTPCapabilities) error {",
            "+func (r *SCTPTransport) Start(capabilities SCTPCapabilities) error {",
            " \tif r.isStarted {",
            " \t\treturn nil",
            " \t}",
            " \tr.isStarted = true",
            " ",
            "+\tmaxMessageSize := capabilities.MaxMessageSize",
            "+\tif maxMessageSize == 0 {",
            "+\t\tmaxMessageSize = sctpMaxMessageSizeUnsetValue",
            "+\t}",
            "+",
            " \tdtlsTransport := r.Transport()",
            " \tif dtlsTransport == nil || dtlsTransport.conn == nil {",
            " \t\treturn errSCTPTransportDTLS",
            " \t}",
            " \tsctpAssociation, err := sctp.Client(sctp.Config{",
            " \t\tNetConn:              dtlsTransport.conn,",
            " \t\tMaxReceiveBufferSize: r.api.settingEngine.sctp.maxReceiveBufferSize,",
            " \t\tEnableZeroChecksum:   r.api.settingEngine.sctp.enableZeroChecksum,",
            " \t\tLoggerFactory:        r.api.settingEngine.LoggerFactory,",
            " \t\tRTOMax:               float64(r.api.settingEngine.sctp.rtoMax) / float64(time.Millisecond),",
            " \t\tBlockWrite:           r.api.settingEngine.detach.DataChannels && r.api.settingEngine.dataChannelBlockWrite,",
            "+\t\tMaxMessageSize:       maxMessageSize,",
            "+\t\tMTU:                  outboundMTU,",
            "+\t\tMinCwnd:              r.api.settingEngine.sctp.minCwnd,",
            "+\t\tFastRtxWnd:           r.api.settingEngine.sctp.fastRtxWnd,",
            "+\t\tCwndCAStep:           r.api.settingEngine.sctp.cwndCAStep,",
            " \t})",
            " \tif err != nil {",
            " \t\treturn err",
            " \t}",
            " ",
            " \tr.lock.Lock()",
            " \tr.sctpAssociation = sctpAssociation",
            "@@ -340,44 +349,14 @@",
            " \t\thandler(dc)",
            " \t\tclose(done)",
            " \t}()",
            " ",
            " \treturn",
            " }",
            " ",
            "-func (r *SCTPTransport) updateMessageSize() {",
            "-\tr.lock.Lock()",
            "-\tdefer r.lock.Unlock()",
            "-",
            "-\tvar remoteMaxMessageSize float64 = 65536 // pion/webrtc#758",
            "-\tvar canSendSize float64 = 65536          // pion/webrtc#758",
            "-",
            "-\tr.maxMessageSize = r.calcMessageSize(remoteMaxMessageSize, canSendSize)",
            "-}",
            "-",
            "-func (r *SCTPTransport) calcMessageSize(remoteMaxMessageSize, canSendSize float64) float64 {",
            "-\tswitch {",
            "-\tcase remoteMaxMessageSize == 0 &&",
            "-\t\tcanSendSize == 0:",
            "-\t\treturn math.Inf(1)",
            "-",
            "-\tcase remoteMaxMessageSize == 0:",
            "-\t\treturn canSendSize",
            "-",
            "-\tcase canSendSize == 0:",
            "-\t\treturn remoteMaxMessageSize",
            "-",
            "-\tcase canSendSize > remoteMaxMessageSize:",
            "-\t\treturn remoteMaxMessageSize",
            "-",
            "-\tdefault:",
            "-\t\treturn canSendSize",
            "-\t}",
            "-}",
            "-",
            " func (r *SCTPTransport) updateMaxChannels() {",
            " \tval := sctpMaxChannels",
            " \tr.maxChannels = &val",
            " }",
            " ",
            " // MaxChannels is the maximum number of RTCDataChannels that can be open simultaneously.",
            " func (r *SCTPTransport) MaxChannels() uint16 {",
            "@@ -451,7 +430,18 @@",
            " \t}",
            " \tr.lock.RLock()",
            " \tassociation := r.sctpAssociation",
            " \tr.lock.RUnlock()",
            " ",
            " \treturn association",
            " }",
            "+",
            "+// BufferedAmount returns total amount (in bytes) of currently buffered user data.",
            "+func (r *SCTPTransport) BufferedAmount() int {",
            "+\tr.lock.Lock()",
            "+\tdefer r.lock.Unlock()",
            "+\tif r.sctpAssociation == nil {",
            "+\t\treturn 0",
            "+\t}",
            "+",
            "+\treturn r.sctpAssociation.BufferedAmount()",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/sctptransport_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/sctptransport_test.go",
            "+++ /home/webrtc-4.1.3/sctptransport_test.go",
            "@@ -3,19 +3,22 @@",
            " ",
            " //go:build !js",
            " // +build !js",
            " ",
            " package webrtc",
            " ",
            " import (",
            "-\t\"bytes\"",
            "+\t\"bufio\"",
            "+\t\"context\"",
            "+\t\"strings\"",
            " \t\"sync\"",
            " \t\"testing\"",
            " \t\"time\"",
            " ",
            "+\t\"github.com/stretchr/testify/assert\"",
            " \t\"github.com/stretchr/testify/require\"",
            " )",
            " ",
            " func TestGenerateDataChannelID(t *testing.T) {",
            " \tsctpTransportWithChannels := func(ids []uint16) *SCTPTransport {",
            " \t\tret := &SCTPTransport{",
            " \t\t\tdataChannels:       []*DataChannel{},",
            "@@ -46,91 +49,79 @@",
            " \t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{1}), 3},",
            " \t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{1, 3}), 5},",
            " \t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{1, 5}), 3},",
            " \t}",
            " \tfor _, testCase := range testCases {",
            " \t\tidPtr := new(uint16)",
            " \t\terr := testCase.s.generateAndSetDataChannelID(testCase.role, &idPtr)",
            "-\t\tif err != nil {",
            "-\t\t\tt.Errorf(\"failed to generate id: %v\", err)",
            "-",
            "-\t\t\treturn",
            "-\t\t}",
            "-\t\tif *idPtr != testCase.result {",
            "-\t\t\tt.Errorf(\"Wrong id: %d expected %d\", *idPtr, testCase.result)",
            "-\t\t}",
            "-\t\tif _, ok := testCase.s.dataChannelIDsUsed[*idPtr]; !ok {",
            "-\t\t\tt.Errorf(\"expected new id to be added to the map: %d\", *idPtr)",
            "-\t\t}",
            "+\t\tassert.NoError(t, err, \"failed to generate data channel id\")",
            "+\t\tassert.Equal(t, testCase.result, *idPtr)",
            "+\t\tassert.Contains(",
            "+\t\t\tt, testCase.s.dataChannelIDsUsed, *idPtr,",
            "+\t\t\t\"expected new id to be added to the map\",",
            "+\t\t)",
            " \t}",
            " }",
            " ",
            " func TestSCTPTransportOnClose(t *testing.T) {",
            " \tofferPC, answerPC, err := newPair()",
            " \trequire.NoError(t, err)",
            " ",
            " \tdefer closePairNow(t, offerPC, answerPC)",
            " ",
            " \tanswerPC.OnDataChannel(func(dc *DataChannel) {",
            " \t\tdc.OnMessage(func(_ DataChannelMessage) {",
            "-\t\t\tif err1 := dc.Send([]byte(\"hello\")); err1 != nil {",
            "-\t\t\t\tt.Error(\"failed to send message\")",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, dc.Send([]byte(\"hello\")), \"failed to send message\")",
            " \t\t})",
            " \t})",
            " ",
            " \trecvMsg := make(chan struct{}, 1)",
            " \tofferPC.OnConnectionStateChange(func(state PeerConnectionState) {",
            " \t\tif state == PeerConnectionStateConnected {",
            " \t\t\tdefer func() {",
            " \t\t\t\tofferPC.OnConnectionStateChange(nil)",
            " \t\t\t}()",
            " ",
            " \t\t\tdc, createErr := offerPC.CreateDataChannel(expectedLabel, nil)",
            "-\t\t\tif createErr != nil {",
            "-\t\t\t\tt.Errorf(\"Failed to create a PC pair for testing\")",
            "-",
            "-\t\t\t\treturn",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, createErr, \"Failed to create a PC pair for testing\")",
            " \t\t\tdc.OnMessage(func(msg DataChannelMessage) {",
            "-\t\t\t\tif !bytes.Equal(msg.Data, []byte(\"hello\")) {",
            "-\t\t\t\t\tt.Error(\"invalid msg received\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.Equal(",
            "+\t\t\t\t\tt, []byte(\"hello\"), msg.Data,",
            "+\t\t\t\t\t\"invalid msg received\",",
            "+\t\t\t\t)",
            " \t\t\t\trecvMsg <- struct{}{}",
            " \t\t\t})",
            " \t\t\tdc.OnOpen(func() {",
            "-\t\t\t\tif err1 := dc.Send([]byte(\"hello\")); err1 != nil {",
            "-\t\t\t\t\tt.Error(\"failed to send initial msg\", err1)",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, dc.Send([]byte(\"hello\")), \"failed to send initial msg\")",
            " \t\t\t})",
            " \t\t}",
            " \t})",
            " ",
            " \terr = signalPair(offerPC, answerPC)",
            " \trequire.NoError(t, err)",
            " ",
            " \tselect {",
            " \tcase <-recvMsg:",
            " \tcase <-time.After(5 * time.Second):",
            "-\t\tt.Fatal(\"timed out\")",
            "+\t\tassert.Fail(t, \"timed out\")",
            " \t}",
            " ",
            " \t// setup SCTP OnClose callback",
            " \tch := make(chan error, 1)",
            " \tanswerPC.SCTP().OnClose(func(err error) {",
            " \t\tch <- err",
            " \t})",
            " ",
            " \terr = offerPC.Close() // This will trigger sctp onclose callback on remote",
            " \trequire.NoError(t, err)",
            " ",
            " \tselect {",
            " \tcase <-ch:",
            " \tcase <-time.After(5 * time.Second):",
            "-\t\tt.Fatal(\"timed out\")",
            "+\t\tassert.Fail(t, \"timed out\")",
            " \t}",
            " }",
            " ",
            " func TestSCTPTransportOutOfBandNegotiatedDataChannelDetach(t *testing.T) { //nolint:cyclop",
            " \t// nolint:varnamelen",
            " \tconst N = 10",
            " \tdone := make(chan struct{}, N)",
            "@@ -140,56 +131,42 @@",
            " \t\t\ts := SettingEngine{}",
            " \t\t\ts.DetachDataChannels()",
            " \t\t\tapi := NewAPI(WithSettingEngine(s))",
            " ",
            " \t\t\t// Set up two peer connections.",
            " \t\t\tconfig := Configuration{}",
            " \t\t\tofferPC, err := api.NewPeerConnection(config)",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Error(err)",
            "-",
            "-\t\t\t\treturn",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, err)",
            " \t\t\tanswerPC, err := api.NewPeerConnection(config)",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Error(err)",
            "-",
            "-\t\t\t\treturn",
            "-\t\t\t}",
            "+\t\t\tassert.NoError(t, err)",
            " ",
            " \t\t\tdefer closePairNow(t, offerPC, answerPC)",
            " \t\t\tdefer func() { done <- struct{}{} }()",
            " ",
            " \t\t\tnegotiated := true",
            " \t\t\tid := uint16(0)",
            " \t\t\treadDetach := make(chan struct{})",
            " \t\t\tdc1, err := offerPC.CreateDataChannel(\"\", &DataChannelInit{",
            " \t\t\t\tNegotiated: &negotiated,",
            " \t\t\t\tID:         &id,",
            " \t\t\t})",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Error(err)",
            "+\t\t\tassert.NoError(t, err)",
            " ",
            "-\t\t\t\treturn",
            "-\t\t\t}",
            " \t\t\tdc1.OnOpen(func() {",
            " \t\t\t\t_, _ = dc1.Detach()",
            " \t\t\t\tclose(readDetach)",
            " \t\t\t})",
            " ",
            " \t\t\twriteDetach := make(chan struct{})",
            " \t\t\tdc2, err := answerPC.CreateDataChannel(\"\", &DataChannelInit{",
            " \t\t\t\tNegotiated: &negotiated,",
            " \t\t\t\tID:         &id,",
            " \t\t\t})",
            "-\t\t\tif err != nil {",
            "-\t\t\t\tt.Error(err)",
            "+\t\t\tassert.NoError(t, err)",
            " ",
            "-\t\t\t\treturn",
            "-\t\t\t}",
            " \t\t\tdc2.OnOpen(func() {",
            " \t\t\t\t_, _ = dc2.Detach()",
            " \t\t\t\tclose(writeDetach)",
            " \t\t\t})",
            " ",
            " \t\t\tvar wg sync.WaitGroup",
            " \t\t\twg.Add(2)",
            "@@ -200,64 +177,147 @@",
            " \t\t\t\t\tif state == PeerConnectionStateConnected {",
            " \t\t\t\t\t\tconnestd <- struct{}{}",
            " \t\t\t\t\t}",
            " \t\t\t\t})",
            " \t\t\t\tselect {",
            " \t\t\t\tcase <-connestd:",
            " \t\t\t\tcase <-time.After(10 * time.Second):",
            "-\t\t\t\t\tt.Error(\"conn establishment timed out\")",
            "+\t\t\t\t\tassert.Fail(t, \"conn establishment timed out\")",
            " ",
            " \t\t\t\t\treturn",
            " \t\t\t\t}",
            " \t\t\t\t<-readDetach",
            " \t\t\t\terr1 := dc1.dataChannel.SetReadDeadline(time.Now().Add(10 * time.Second))",
            "-\t\t\t\tif err1 != nil {",
            "-\t\t\t\t\tt.Error(err)",
            "-",
            "-\t\t\t\t\treturn",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, err1)",
            " \t\t\t\tbuf := make([]byte, 10)",
            " \t\t\t\tn, err1 := dc1.dataChannel.Read(buf)",
            "-\t\t\t\tif err1 != nil {",
            "-\t\t\t\t\tt.Error(err)",
            "-",
            "-\t\t\t\t\treturn",
            "-\t\t\t\t}",
            "-\t\t\t\tif string(buf[:n]) != \"hello\" {",
            "-\t\t\t\t\tt.Error(\"invalid read\")",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, err1)",
            "+\t\t\t\tassert.Equal(t, \"hello\", string(buf[:n]), \"invalid read\")",
            " \t\t\t}()",
            " \t\t\tgo func() {",
            " \t\t\t\tdefer wg.Done()",
            " \t\t\t\tconnestd := make(chan struct{}, 1)",
            " \t\t\t\tanswerPC.OnConnectionStateChange(func(state PeerConnectionState) {",
            " \t\t\t\t\tif state == PeerConnectionStateConnected {",
            " \t\t\t\t\t\tconnestd <- struct{}{}",
            " \t\t\t\t\t}",
            " \t\t\t\t})",
            " \t\t\t\tselect {",
            " \t\t\t\tcase <-connestd:",
            " \t\t\t\tcase <-time.After(10 * time.Second):",
            "-\t\t\t\t\tt.Error(\"connection establishment timed out\")",
            "+\t\t\t\t\tassert.Fail(t, \"connection establishment timed out\")",
            " ",
            " \t\t\t\t\treturn",
            " \t\t\t\t}",
            " \t\t\t\t<-writeDetach",
            " \t\t\t\tn, err1 := dc2.dataChannel.Write([]byte(\"hello\"))",
            "-\t\t\t\tif err1 != nil || n != len(\"hello\") {",
            "-\t\t\t\t\tt.Error(err)",
            "-\t\t\t\t}",
            "+\t\t\t\tassert.NoError(t, err1)",
            "+\t\t\t\tassert.Equal(t, len(\"hello\"), n)",
            " \t\t\t}()",
            " \t\t\terr = signalPair(offerPC, answerPC)",
            " \t\t\trequire.NoError(t, err)",
            " \t\t\twg.Wait()",
            " \t\t}()",
            " \t}",
            " ",
            " \tfor i := 0; i < N; i++ {",
            " \t\tselect {",
            " \t\tcase <-done:",
            " \t\tcase <-time.After(20 * time.Second):",
            "-\t\t\tt.Fatal(\"timed out\")",
            "+\t\t\tassert.Fail(t, \"timed out\")",
            " \t\t}",
            " \t}",
            " }",
            "+",
            "+// Assert that max-message-size is signaled properly",
            "+// and able to be configured via SettingEngine.",
            "+func TestMaxMessageSizeSignaling(t *testing.T) {",
            "+\tt.Run(\"Local Offer\", func(t *testing.T) {",
            "+\t\tpeerConnection, err := NewPeerConnection(Configuration{})",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\t_, err = peerConnection.CreateDataChannel(\"\", nil)",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\toffer, err := peerConnection.CreateOffer(nil)",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\trequire.Contains(t, offer.SDP, \"a=max-message-size:1073741823\\r\\n\")",
            "+\t\trequire.NoError(t, peerConnection.Close())",
            "+\t})",
            "+",
            "+\tt.Run(\"Local SettingEngine\", func(t *testing.T) {",
            "+\t\tsettingEngine := SettingEngine{}",
            "+\t\tsettingEngine.SetSCTPMaxMessageSize(4321)",
            "+",
            "+\t\tpeerConnection, err := NewAPI(WithSettingEngine(settingEngine)).NewPeerConnection(Configuration{})",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\t_, err = peerConnection.CreateDataChannel(\"\", nil)",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\toffer, err := peerConnection.CreateOffer(nil)",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\trequire.Contains(t, offer.SDP, \"a=max-message-size:4321\\r\\n\")",
            "+\t\trequire.NoError(t, peerConnection.Close())",
            "+\t})",
            "+",
            "+\tt.Run(\"Remote\", func(t *testing.T) {",
            "+\t\tsettingEngine := SettingEngine{}",
            "+\t\tsettingEngine.SetSCTPMaxMessageSize(4321)",
            "+",
            "+\t\tofferPeerConnection, err := NewAPI(WithSettingEngine(settingEngine)).NewPeerConnection(Configuration{})",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\tanswerPeerConnection, err := NewPeerConnection(Configuration{})",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\tonDataChannelOpen, onDataChannelOpenCancel := context.WithCancel(context.Background())",
            "+\t\tanswerPeerConnection.OnDataChannel(func(d *DataChannel) {",
            "+\t\t\td.OnOpen(func() {",
            "+\t\t\t\tonDataChannelOpenCancel()",
            "+\t\t\t})",
            "+\t\t})",
            "+",
            "+\t\trequire.NoError(t, signalPair(offerPeerConnection, answerPeerConnection))",
            "+",
            "+\t\t<-onDataChannelOpen.Done()",
            "+\t\trequire.Equal(t, uint32(defaultMaxSCTPMessageSize), offerPeerConnection.SCTP().GetCapabilities().MaxMessageSize)",
            "+\t\trequire.Equal(t, uint32(4321), answerPeerConnection.SCTP().GetCapabilities().MaxMessageSize)",
            "+",
            "+\t\tclosePairNow(t, offerPeerConnection, answerPeerConnection)",
            "+\t})",
            "+",
            "+\tt.Run(\"Remote Unset\", func(t *testing.T) {",
            "+\t\tofferPeerConnection, answerPeerConnection, err := newPair()",
            "+\t\trequire.NoError(t, err)",
            "+",
            "+\t\trequire.NoError(t, signalPairWithModification(offerPeerConnection, answerPeerConnection, func(sessionDescription string) (filtered string) { // nolint",
            "+\t\t\tscanner := bufio.NewScanner(strings.NewReader(sessionDescription))",
            "+\t\t\tfor scanner.Scan() {",
            "+\t\t\t\tif strings.HasPrefix(scanner.Text(), \"a=max-message-size\") {",
            "+\t\t\t\t\tcontinue",
            "+\t\t\t\t}",
            "+",
            "+\t\t\t\tfiltered += scanner.Text() + \"\\r\\n\"",
            "+\t\t\t}",
            "+",
            "+\t\t\treturn",
            "+\t\t}))",
            "+",
            "+\t\tonDataChannelOpen, onDataChannelOpenCancel := context.WithCancel(context.Background())",
            "+\t\tanswerPeerConnection.OnDataChannel(func(d *DataChannel) {",
            "+\t\t\td.OnOpen(func() {",
            "+\t\t\t\tonDataChannelOpenCancel()",
            "+\t\t\t})",
            "+\t\t})",
            "+",
            "+\t\trequire.NoError(t, signalPair(offerPeerConnection, answerPeerConnection))",
            "+",
            "+\t\t<-onDataChannelOpen.Done()",
            "+\t\trequire.Equal(t, uint32(defaultMaxSCTPMessageSize), offerPeerConnection.SCTP().GetCapabilities().MaxMessageSize)",
            "+\t\trequire.Equal(t, uint32(sctpMaxMessageSizeUnsetValue), answerPeerConnection.SCTP().GetCapabilities().MaxMessageSize)",
            "+",
            "+\t\tclosePairNow(t, offerPeerConnection, answerPeerConnection)",
            "+\t})",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/sdp.go",
          "change": [
            "--- /home/webrtc-4.0.11/sdp.go",
            "+++ /home/webrtc-4.1.3/sdp.go",
            "@@ -19,21 +19,22 @@",
            " \t\"github.com/pion/logging\"",
            " \t\"github.com/pion/sdp/v3\"",
            " )",
            " ",
            " // trackDetails represents any media source that can be represented in a SDP",
            " // This isn't keyed by SSRC because it also needs to support rid based sources.",
            " type trackDetails struct {",
            "-\tmid        string",
            "-\tkind       RTPCodecType",
            "-\tstreamID   string",
            "-\tid         string",
            "-\tssrcs      []SSRC",
            "-\trepairSsrc *SSRC",
            "-\trids       []string",
            "+\tmid      string",
            "+\tkind     RTPCodecType",
            "+\tstreamID string",
            "+\tid       string",
            "+\tssrcs    []SSRC",
            "+\trtxSsrc  *SSRC",
            "+\tfecSsrc  *SSRC",
            "+\trids     []string",
            " }",
            " ",
            " func trackDetailsForSSRC(trackDetails []trackDetails, ssrc SSRC) *trackDetails {",
            " \tfor i := range trackDetails {",
            " \t\tfor j := range trackDetails[i].ssrcs {",
            " \t\t\tif trackDetails[i].ssrcs[j] == ssrc {",
            " \t\t\t\treturn &trackDetails[i]",
            "@@ -87,14 +88,15 @@",
            " func trackDetailsFromSDP(",
            " \tlog logging.LeveledLogger,",
            " \ts *sdp.SessionDescription,",
            " ) (incomingTracks []trackDetails) {",
            " \tfor _, media := range s.MediaDescriptions {",
            " \t\ttracksInMediaSection := []trackDetails{}",
            " \t\trtxRepairFlows := map[uint64]uint64{}",
            "+\t\tfecRepairFlows := map[uint64]uint64{}",
            " ",
            " \t\t// Plan B can have multiple tracks in a single media section",
            " \t\tstreamID := \"\"",
            " \t\ttrackID := \"\"",
            " ",
            " \t\t// If media section is recvonly or inactive skip",
            " \t\tif _, ok := media.Attribute(sdp.AttrKeyRecvOnly); ok {",
            "@@ -139,15 +141,43 @@",
            " \t\t\t\t\t\ttracksInMediaSection = filterTrackWithSSRC(",
            " \t\t\t\t\t\t\ttracksInMediaSection,",
            " \t\t\t\t\t\t\tSSRC(rtxRepairFlow),",
            " \t\t\t\t\t\t) // Remove if rtx was added as track before",
            " \t\t\t\t\t\tfor i := range tracksInMediaSection {",
            " \t\t\t\t\t\t\tif tracksInMediaSection[i].ssrcs[0] == SSRC(baseSsrc) {",
            " \t\t\t\t\t\t\t\trepairSsrc := SSRC(rtxRepairFlow)",
            "-\t\t\t\t\t\t\t\ttracksInMediaSection[i].repairSsrc = &repairSsrc",
            "+\t\t\t\t\t\t\t\ttracksInMediaSection[i].rtxSsrc = &repairSsrc",
            "+\t\t\t\t\t\t\t}",
            "+\t\t\t\t\t\t}",
            "+\t\t\t\t\t}",
            "+\t\t\t\t} else if split[0] == sdp.SemanticTokenForwardErrorCorrectionFramework {",
            "+\t\t\t\t\t// Similar to above, lines like `a=ssrc-group:FEC-FR aaaaa bbbbb`",
            "+\t\t\t\t\t// means for video ssrc aaaaa, there's a FEC track bbbbb",
            "+\t\t\t\t\tif len(split) == 3 {",
            "+\t\t\t\t\t\tbaseSsrc, err := strconv.ParseUint(split[1], 10, 32)",
            "+\t\t\t\t\t\tif err != nil {",
            "+\t\t\t\t\t\t\tlog.Warnf(\"Failed to parse SSRC: %v\", err)",
            "+",
            "+\t\t\t\t\t\t\tcontinue",
            "+\t\t\t\t\t\t}",
            "+\t\t\t\t\t\tfecRepairFlow, err := strconv.ParseUint(split[2], 10, 32)",
            "+\t\t\t\t\t\tif err != nil {",
            "+\t\t\t\t\t\t\tlog.Warnf(\"Failed to parse SSRC: %v\", err)",
            "+",
            "+\t\t\t\t\t\t\tcontinue",
            "+\t\t\t\t\t\t}",
            "+\t\t\t\t\t\tfecRepairFlows[fecRepairFlow] = baseSsrc",
            "+\t\t\t\t\t\ttracksInMediaSection = filterTrackWithSSRC(",
            "+\t\t\t\t\t\t\ttracksInMediaSection,",
            "+\t\t\t\t\t\t\tSSRC(fecRepairFlow),",
            "+\t\t\t\t\t\t) // Remove if fec was added as track before",
            "+\t\t\t\t\t\tfor i := range tracksInMediaSection {",
            "+\t\t\t\t\t\t\tif tracksInMediaSection[i].ssrcs[0] == SSRC(baseSsrc) {",
            "+\t\t\t\t\t\t\t\trepairSsrc := SSRC(fecRepairFlow)",
            "+\t\t\t\t\t\t\t\ttracksInMediaSection[i].fecSsrc = &repairSsrc",
            " \t\t\t\t\t\t\t}",
            " \t\t\t\t\t\t}",
            " \t\t\t\t\t}",
            " \t\t\t\t}",
            " ",
            " \t\t\t// Handle `a=msid:<stream_id> <track_label>` for Unified plan. The first value is the same as MediaStream.id",
            " \t\t\t// in the browser and can be used to figure out which tracks belong to the same stream. The browser should",
            "@@ -167,14 +197,17 @@",
            " ",
            " \t\t\t\t\tcontinue",
            " \t\t\t\t}",
            " ",
            " \t\t\t\tif _, ok := rtxRepairFlows[ssrc]; ok {",
            " \t\t\t\t\tcontinue // This ssrc is a RTX repair flow, ignore",
            " \t\t\t\t}",
            "+\t\t\t\tif _, ok := fecRepairFlows[ssrc]; ok {",
            "+\t\t\t\t\tcontinue // This ssrc is a FEC repair flow, ignore",
            "+\t\t\t\t}",
            " ",
            " \t\t\t\tif len(split) == 3 && strings.HasPrefix(split[1], \"msid:\") {",
            " \t\t\t\t\tstreamID = split[1][len(\"msid:\"):]",
            " \t\t\t\t\ttrackID = split[2]",
            " \t\t\t\t}",
            " ",
            " \t\t\t\tisNewTrack := true",
            "@@ -193,15 +226,21 @@",
            " \t\t\t\ttrackDetails.streamID = streamID",
            " \t\t\t\ttrackDetails.id = trackID",
            " \t\t\t\ttrackDetails.ssrcs = []SSRC{SSRC(ssrc)}",
            " ",
            " \t\t\t\tfor r, baseSsrc := range rtxRepairFlows {",
            " \t\t\t\t\tif baseSsrc == ssrc {",
            " \t\t\t\t\t\trepairSsrc := SSRC(r) //nolint:gosec // G115",
            "-\t\t\t\t\t\ttrackDetails.repairSsrc = &repairSsrc",
            "+\t\t\t\t\t\ttrackDetails.rtxSsrc = &repairSsrc",
            "+\t\t\t\t\t}",
            "+\t\t\t\t}",
            "+\t\t\t\tfor r, baseSsrc := range fecRepairFlows {",
            "+\t\t\t\t\tif baseSsrc == ssrc {",
            "+\t\t\t\t\t\tfecSsrc := SSRC(r) //nolint:gosec // G115",
            "+\t\t\t\t\t\ttrackDetails.fecSsrc = &fecSsrc",
            " \t\t\t\t\t}",
            " \t\t\t\t}",
            " ",
            " \t\t\t\tif isNewTrack {",
            " \t\t\t\t\ttracksInMediaSection = append(tracksInMediaSection, *trackDetails)",
            " \t\t\t\t}",
            " \t\t\t}",
            "@@ -239,16 +278,20 @@",
            " \t\tif len(trackDetails.rids) > i {",
            " \t\t\tencodings[i].RID = trackDetails.rids[i]",
            " \t\t}",
            " \t\tif len(trackDetails.ssrcs) > i {",
            " \t\t\tencodings[i].SSRC = trackDetails.ssrcs[i]",
            " \t\t}",
            " ",
            "-\t\tif trackDetails.repairSsrc != nil {",
            "-\t\t\tencodings[i].RTX.SSRC = *trackDetails.repairSsrc",
            "+\t\tif trackDetails.rtxSsrc != nil {",
            "+\t\t\tencodings[i].RTX.SSRC = *trackDetails.rtxSsrc",
            "+\t\t}",
            "+",
            "+\t\tif trackDetails.fecSsrc != nil {",
            "+\t\t\tencodings[i].FEC.SSRC = *trackDetails.fecSsrc",
            " \t\t}",
            " \t}",
            " ",
            " \treturn RTPReceiveParameters{Encodings: encodings}",
            " }",
            " ",
            " func getRids(media *sdp.MediaDescription) []*simulcastRid {",
            "@@ -298,15 +341,15 @@",
            " \t\t\t}",
            " \t\t}",
            " ",
            " \t\tmediaDescr.WithValueAttribute(\"candidate\", marshaled)",
            " \t}",
            " ",
            " \tfor _, c := range candidates {",
            "-\t\tcandidate, err := c.toICE()",
            "+\t\tcandidate, err := c.ToICE()",
            " \t\tif err != nil {",
            " \t\t\treturn err",
            " \t\t}",
            " ",
            " \t\tcandidate.SetComponent(1)",
            " \t\tappendCandidateIfNew(candidate, mediaDescr.Attributes)",
            " ",
            "@@ -333,14 +376,15 @@",
            " \tshouldAddCandidates bool,",
            " \tdtlsFingerprints []DTLSFingerprint,",
            " \tmidValue string,",
            " \ticeParams ICEParameters,",
            " \tcandidates []ICECandidate,",
            " \tdtlsRole sdp.ConnectionRole,",
            " \ticeGatheringState ICEGatheringState,",
            "+\tsctpMaxMessageSize uint32,",
            " ) error {",
            " \tmedia := (&sdp.MediaDescription{",
            " \t\tMediaName: sdp.MediaName{",
            " \t\t\tMedia:   mediaSectionApplication,",
            " \t\t\tPort:    sdp.RangedPort{Value: 9},",
            " \t\t\tProtos:  []string{\"UDP\", \"DTLS\", \"SCTP\"},",
            " \t\t\tFormats: []string{\"webrtc-datachannel\"},",
            "@@ -353,14 +397,15 @@",
            " \t\t\t},",
            " \t\t},",
            " \t}).",
            " \t\tWithValueAttribute(sdp.AttrKeyConnectionSetup, dtlsRole.String()).",
            " \t\tWithValueAttribute(sdp.AttrKeyMID, midValue).",
            " \t\tWithPropertyAttribute(RTPTransceiverDirectionSendrecv.String()).",
            " \t\tWithPropertyAttribute(\"sctp-port:5000\").",
            "+\t\tWithValueAttribute(\"max-message-size\", fmt.Sprintf(\"%d\", sctpMaxMessageSize)).",
            " \t\tWithICECredentials(iceParams.UsernameFragment, iceParams.Password)",
            " ",
            " \tfor _, f := range dtlsFingerprints {",
            " \t\tmedia = media.WithFingerprint(f.Algorithm, strings.ToUpper(f.Value))",
            " \t}",
            " ",
            " \tif shouldAddCandidates {",
            "@@ -424,18 +469,34 @@",
            " \t\tif track == nil {",
            " \t\t\tcontinue",
            " \t\t}",
            " ",
            " \t\tsendParameters := sender.GetParameters()",
            " \t\tfor _, encoding := range sendParameters.Encodings {",
            " \t\t\tif encoding.RTX.SSRC != 0 {",
            "-\t\t\t\tmedia = media.WithValueAttribute(\"ssrc-group\", fmt.Sprintf(\"FID %d %d\", encoding.SSRC, encoding.RTX.SSRC))",
            "+\t\t\t\tmedia = media.WithValueAttribute(",
            "+\t\t\t\t\t\"ssrc-group\",",
            "+\t\t\t\t\tfmt.Sprintf(",
            "+\t\t\t\t\t\t\"%s %d %d\",",
            "+\t\t\t\t\t\tsdp.SemanticTokenFlowIdentification,",
            "+\t\t\t\t\t\tencoding.SSRC,",
            "+\t\t\t\t\t\tencoding.RTX.SSRC,",
            "+\t\t\t\t\t),",
            "+\t\t\t\t)",
            " \t\t\t}",
            " \t\t\tif encoding.FEC.SSRC != 0 {",
            "-\t\t\t\tmedia = media.WithValueAttribute(\"ssrc-group\", fmt.Sprintf(\"FEC-FR %d %d\", encoding.SSRC, encoding.FEC.SSRC))",
            "+\t\t\t\tmedia = media.WithValueAttribute(",
            "+\t\t\t\t\t\"ssrc-group\",",
            "+\t\t\t\t\tfmt.Sprintf(",
            "+\t\t\t\t\t\t\"%s %d %d\",",
            "+\t\t\t\t\t\tsdp.SemanticTokenForwardErrorCorrectionFramework,",
            "+\t\t\t\t\t\tencoding.SSRC,",
            "+\t\t\t\t\t\tencoding.FEC.SSRC,",
            "+\t\t\t\t\t),",
            "+\t\t\t\t)",
            " \t\t\t}",
            " ",
            " \t\t\tmedia = media.WithMediaSource(",
            " \t\t\t\tuint32(encoding.SSRC),",
            " \t\t\t\ttrack.StreamID(), /* cname */",
            " \t\t\t\ttrack.StreamID(), /* streamLabel */",
            " \t\t\t\ttrack.ID(),",
            "@@ -651,14 +712,15 @@",
            " \tmediaEngine *MediaEngine,",
            " \tconnectionRole sdp.ConnectionRole,",
            " \tcandidates []ICECandidate,",
            " \ticeParams ICEParameters,",
            " \tmediaSections []mediaSection,",
            " \ticeGatheringState ICEGatheringState,",
            " \tmatchBundleGroup *string,",
            "+\tsctpMaxMessageSize uint32,",
            " ) (*sdp.SessionDescription, error) {",
            " \tvar err error",
            " \tmediaDtlsFingerprints := []DTLSFingerprint{}",
            " ",
            " \tif mediaDescriptionFingerprint {",
            " \t\tmediaDtlsFingerprints = dtlsFingerprints",
            " \t}",
            "@@ -687,14 +749,15 @@",
            " \t\t\t\tshouldAddCandidates,",
            " \t\t\t\tmediaDtlsFingerprints,",
            " \t\t\t\tsection.id,",
            " \t\t\t\ticeParams,",
            " \t\t\t\tcandidates,",
            " \t\t\t\tconnectionRole,",
            " \t\t\t\ticeGatheringState,",
            "+\t\t\t\tsctpMaxMessageSize,",
            " \t\t\t); err != nil {",
            " \t\t\t\treturn nil, err",
            " \t\t\t}",
            " \t\t} else {",
            " \t\t\tshouldAddID, err = addTransceiverSDP(",
            " \t\t\t\tdescr,",
            " \t\t\t\tisPlanB,",
            "@@ -987,24 +1050,14 @@",
            " \t\t\t}, true",
            " \t\t}",
            " \t}",
            " ",
            " \treturn nil, false",
            " }",
            " ",
            "-func haveApplicationMediaSection(desc *sdp.SessionDescription) bool {",
            "-\tfor _, mediaDescr := range desc.MediaDescriptions {",
            "-\t\tif mediaDescr.MediaName.Media == mediaSectionApplication {",
            "-\t\t\treturn true",
            "-\t\t}",
            "-\t}",
            "-",
            "-\treturn false",
            "-}",
            "-",
            " func getByMid(searchMid string, desc *SessionDescription) *sdp.MediaDescription {",
            " \tfor _, m := range desc.parsed.MediaDescriptions {",
            " \t\tif mid, ok := m.Attribute(sdp.AttrKeyMID); ok && mid == searchMid {",
            " \t\t\treturn m",
            " \t\t}",
            " \t}",
            " ",
            "@@ -1124,7 +1177,19 @@",
            " \t\tif strings.TrimSpace(a.Key) == sdp.AttrKeyExtMapAllowMixed {",
            " \t\t\treturn true",
            " \t\t}",
            " \t}",
            " ",
            " \treturn false",
            " }",
            "+",
            "+func getMaxMessageSize(desc *sdp.MediaDescription) uint32 {",
            "+\tfor _, a := range desc.Attributes {",
            "+\t\tif strings.TrimSpace(a.Key) == \"max-message-size\" {",
            "+\t\t\tif v, err := strconv.ParseUint(a.Value, 10, 32); err == nil {",
            "+\t\t\t\treturn uint32(v)",
            "+\t\t\t}",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn 0",
            "+}"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/sdp_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/sdp_test.go",
            "+++ /home/webrtc-4.1.3/sdp_test.go",
            "@@ -12,14 +12,15 @@",
            " \t\"crypto/rand\"",
            " \t\"strings\"",
            " \t\"testing\"",
            " ",
            " \t\"github.com/pion/sdp/v3\"",
            " \t\"github.com/pion/transport/v3/test\"",
            " \t\"github.com/stretchr/testify/assert\"",
            "+\t\"github.com/stretchr/testify/require\"",
            " )",
            " ",
            " func TestExtractFingerprint(t *testing.T) {",
            " \tt.Run(\"Good Session Fingerprint\", func(t *testing.T) {",
            " \t\ts := &sdp.SessionDescription{",
            " \t\t\tAttributes: []sdp.Attribute{{Key: \"fingerprint\", Value: \"foo bar\"}},",
            " \t\t}",
            "@@ -450,14 +451,46 @@",
            " \t\t\tassert.Equal(t, RTPCodecTypeVideo, track.kind)",
            " \t\t\tassert.Equal(t, SSRC(5000), track.ssrcs[0])",
            " \t\t\tassert.Equal(t, \"video_trk_id\", track.id)",
            " \t\t\tassert.Equal(t, \"video_stream_id\", track.streamID)",
            " \t\t}",
            " \t})",
            " ",
            "+\tt.Run(\"Tracks unknown, video with RTX and FEC\", func(t *testing.T) {",
            "+\t\tdescr := &sdp.SessionDescription{",
            "+\t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            "+\t\t\t\t{",
            "+\t\t\t\t\tMediaName: sdp.MediaName{",
            "+\t\t\t\t\t\tMedia: \"video\",",
            "+\t\t\t\t\t},",
            "+\t\t\t\t\tAttributes: []sdp.Attribute{",
            "+\t\t\t\t\t\t{Key: \"mid\", Value: \"0\"},",
            "+\t\t\t\t\t\t{Key: \"sendrecv\"},",
            "+\t\t\t\t\t\t{Key: \"ssrc-group\", Value: \"FID 3000 4000\"},",
            "+\t\t\t\t\t\t{Key: \"ssrc-group\", Value: \"FEC-FR 3000 5000\"},",
            "+\t\t\t\t\t\t{Key: \"ssrc\", Value: \"3000 msid:video_trk_label video_trk_guid\"},",
            "+\t\t\t\t\t\t{Key: \"ssrc\", Value: \"4000 msid:rtx_trk_label rtx_trk_guid\"},",
            "+\t\t\t\t\t\t{Key: \"ssrc\", Value: \"5000 msid:fec_trk_label fec_trk_guid\"},",
            "+\t\t\t\t\t},",
            "+\t\t\t\t},",
            "+\t\t\t},",
            "+\t\t}",
            "+",
            "+\t\ttracks := trackDetailsFromSDP(nil, descr)",
            "+\t\tassert.Equal(t, 1, len(tracks))",
            "+\t\ttrack := tracks[0]",
            "+\t\tassert.Equal(t, RTPCodecTypeVideo, track.kind)",
            "+\t\tassert.Equal(t, SSRC(3000), track.ssrcs[0])",
            "+\t\tassert.Equal(t, \"video_trk_label\", track.streamID)",
            "+\t\trequire.NotNil(t, track.rtxSsrc, \"missing RTX ssrc for video track\")",
            "+\t\tassert.Equal(t, SSRC(4000), *track.rtxSsrc)",
            "+\t\trequire.NotNil(t, track.fecSsrc, \"missing FEC ssrc for video track\")",
            "+\t\tassert.Equal(t, SSRC(5000), *track.fecSsrc)",
            "+\t})",
            "+",
            " \tt.Run(\"inactive and recvonly tracks ignored\", func(t *testing.T) {",
            " \t\tdescr := &sdp.SessionDescription{",
            " \t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            " \t\t\t\t{",
            " \t\t\t\t\tMediaName: sdp.MediaName{",
            " \t\t\t\t\t\tMedia: \"video\",",
            " \t\t\t\t\t},",
            "@@ -508,50 +541,54 @@",
            " \t\t\t\t\t},",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t}",
            " ",
            " \t\ttracks := trackDetailsFromSDP(nil, descr)",
            " \t\tassert.Equal(t, 2, len(tracks))",
            "-\t\tassert.Equal(t, SSRC(4000), *tracks[0].repairSsrc)",
            "-\t\tassert.Equal(t, SSRC(6000), *tracks[1].repairSsrc)",
            "+\t\tassert.Equal(t, SSRC(4000), *tracks[0].rtxSsrc)",
            "+\t\tassert.Equal(t, SSRC(6000), *tracks[1].rtxSsrc)",
            " \t})",
            " }",
            " ",
            " func TestHaveApplicationMediaSection(t *testing.T) {",
            " \tt.Run(\"Audio only\", func(t *testing.T) {",
            "-\t\tdescr := &sdp.SessionDescription{",
            "-\t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            "-\t\t\t\t{",
            "-\t\t\t\t\tMediaName: sdp.MediaName{",
            "-\t\t\t\t\t\tMedia: \"audio\",",
            "-\t\t\t\t\t},",
            "-\t\t\t\t\tAttributes: []sdp.Attribute{",
            "-\t\t\t\t\t\t{Key: \"sendrecv\"},",
            "-\t\t\t\t\t\t{Key: \"ssrc\", Value: \"2000\"},",
            "+\t\tdescr := &SessionDescription{",
            "+\t\t\tparsed: &sdp.SessionDescription{",
            "+\t\t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            "+\t\t\t\t\t{",
            "+\t\t\t\t\t\tMediaName: sdp.MediaName{",
            "+\t\t\t\t\t\t\tMedia: \"audio\",",
            "+\t\t\t\t\t\t},",
            "+\t\t\t\t\t\tAttributes: []sdp.Attribute{",
            "+\t\t\t\t\t\t\t{Key: \"sendrecv\"},",
            "+\t\t\t\t\t\t\t{Key: \"ssrc\", Value: \"2000\"},",
            "+\t\t\t\t\t\t},",
            " \t\t\t\t\t},",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t}",
            " ",
            "-\t\tassert.False(t, haveApplicationMediaSection(descr))",
            "+\t\tassert.Nil(t, haveDataChannel(descr))",
            " \t})",
            " ",
            " \tt.Run(\"Application\", func(t *testing.T) {",
            "-\t\ts := &sdp.SessionDescription{",
            "-\t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            "-\t\t\t\t{",
            "-\t\t\t\t\tMediaName: sdp.MediaName{",
            "-\t\t\t\t\t\tMedia: mediaSectionApplication,",
            "+\t\ts := SessionDescription{",
            "+\t\t\tparsed: &sdp.SessionDescription{",
            "+\t\t\t\tMediaDescriptions: []*sdp.MediaDescription{",
            "+\t\t\t\t\t{",
            "+\t\t\t\t\t\tMediaName: sdp.MediaName{",
            "+\t\t\t\t\t\t\tMedia: mediaSectionApplication,",
            "+\t\t\t\t\t\t},",
            " \t\t\t\t\t},",
            " \t\t\t\t},",
            " \t\t\t},",
            " \t\t}",
            " ",
            "-\t\tassert.True(t, haveApplicationMediaSection(s))",
            "+\t\tassert.NotNil(t, haveDataChannel(&s))",
            " \t})",
            " }",
            " ",
            " func TestMediaDescriptionFingerprints(t *testing.T) {",
            " \tengine := &MediaEngine{}",
            " \tassert.NoError(t, engine.RegisterDefaultCodecs())",
            " ",
            "@@ -591,26 +628,37 @@",
            " \t\tmedia[i].transceivers[0].setDirection(RTPTransceiverDirectionSendonly)",
            " \t}",
            " ",
            " \tfingerprintTest := func(SDPMediaDescriptionFingerprints bool, expectedFingerprintCount int) func(t *testing.T) {",
            " \t\treturn func(t *testing.T) {",
            " \t\t\tt.Helper()",
            " ",
            "-\t\t\ts := &sdp.SessionDescription{}",
            "+\t\t\ttestSdp := &sdp.SessionDescription{}",
            " ",
            " \t\t\tdtlsFingerprints, err := certificate.GetFingerprints()",
            " \t\t\tassert.NoError(t, err)",
            " ",
            "-\t\t\ts, err = populateSDP(s, false,",
            "+\t\t\ttestSdp, err = populateSDP(testSdp,",
            "+\t\t\t\tfalse,",
            " \t\t\t\tdtlsFingerprints,",
            " \t\t\t\tSDPMediaDescriptionFingerprints,",
            "-\t\t\t\tfalse, true, engine, sdp.ConnectionRoleActive, []ICECandidate{}, ICEParameters{}, media, ICEGatheringStateNew, nil)",
            "+\t\t\t\tfalse,",
            "+\t\t\t\ttrue,",
            "+\t\t\t\tengine,",
            "+\t\t\t\tsdp.ConnectionRoleActive,",
            "+\t\t\t\t[]ICECandidate{},",
            "+\t\t\t\tICEParameters{},",
            "+\t\t\t\tmedia,",
            "+\t\t\t\tICEGatheringStateNew,",
            "+\t\t\t\tnil,",
            "+\t\t\t\t0,",
            "+\t\t\t)",
            " \t\t\tassert.NoError(t, err)",
            " ",
            "-\t\t\tsdparray, err := s.Marshal()",
            "+\t\t\tsdparray, err := testSdp.Marshal()",
            " \t\t\tassert.NoError(t, err)",
            " ",
            " \t\t\tassert.Equal(t, strings.Count(string(sdparray), \"sha-256\"), expectedFingerprintCount)",
            " \t\t}",
            " \t}",
            " ",
            " \tt.Run(\"Per-Media Description Fingerprints\", fingerprintTest(true, 3))",
            "@@ -652,14 +700,15 @@",
            " \t\t\tme,",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\tmediaSections,",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\t// Test contains rid map keys",
            " \t\tvar ridFound int",
            " \t\tfor _, desc := range offerSdp.MediaDescriptions {",
            " \t\t\tif desc.MediaName.Media != \"video\" {",
            "@@ -679,16 +728,16 @@",
            " \t})",
            " \tt.Run(\"SetCodecPreferences\", func(t *testing.T) {",
            " \t\tse := SettingEngine{}",
            " ",
            " \t\tme := &MediaEngine{}",
            " \t\tassert.NoError(t, me.RegisterDefaultCodecs())",
            " \t\tapi := NewAPI(WithMediaEngine(me))",
            "-\t\tme.pushCodecs(me.videoCodecs, RTPCodecTypeVideo)",
            "-\t\tme.pushCodecs(me.audioCodecs, RTPCodecTypeAudio)",
            "+\t\tassert.NoError(t, me.pushCodecs(me.videoCodecs, RTPCodecTypeVideo))",
            "+\t\tassert.NoError(t, me.pushCodecs(me.audioCodecs, RTPCodecTypeAudio))",
            " ",
            " \t\ttr := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}",
            " \t\ttr.setDirection(RTPTransceiverDirectionRecvonly)",
            " \t\tcodecErr := tr.SetCodecPreferences([]RTPCodecParameters{",
            " \t\t\t{",
            " \t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},",
            " \t\t\t\tPayloadType:        96,",
            "@@ -710,28 +759,29 @@",
            " \t\t\tme,",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\tmediaSections,",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\t// Test codecs",
            " \t\tfoundVP8 := false",
            " \t\tfor _, desc := range offerSdp.MediaDescriptions {",
            " \t\t\tif desc.MediaName.Media != \"video\" {",
            " \t\t\t\tcontinue",
            " \t\t\t}",
            " \t\t\tfor _, a := range desc.Attributes {",
            " \t\t\t\tif strings.Contains(a.Key, \"rtpmap\") {",
            "-\t\t\t\t\tif a.Value == \"98 VP9/90000\" {",
            "-\t\t\t\t\t\tt.Fatal(\"vp9 should not be present in sdp\")",
            "-\t\t\t\t\t} else if a.Value == \"96 VP8/90000\" {",
            "+\t\t\t\t\tassert.NotEqual(t, a.Value, \"98 VP9/90000\", \"vp9 should not be present in sdp\")",
            "+",
            "+\t\t\t\t\tif a.Value == \"96 VP8/90000\" {",
            " \t\t\t\t\t\tfoundVP8 = true",
            " \t\t\t\t\t}",
            " \t\t\t\t}",
            " \t\t\t}",
            " \t\t}",
            " \t\tassert.Equal(t, true, foundVP8, \"vp8 should be present in sdp\")",
            " \t})",
            "@@ -749,14 +799,15 @@",
            " \t\t\t&MediaEngine{},",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\t[]mediaSection{},",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\tvar found bool",
            " \t\t// ice-lite is an session-level attribute",
            " \t\tfor _, a := range offerSdp.Attributes {",
            " \t\t\tif a.Key == sdp.AttrKeyICELite {",
            "@@ -806,14 +857,15 @@",
            " \t\t\tme,",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\tmediaSections,",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.NoError(t, err)",
            " ",
            " \t\t// Test codecs",
            " \t\tfoundRejectedTrack := false",
            " \t\tfor _, desc := range offerSdp.MediaDescriptions {",
            " \t\t\tif desc.MediaName.Media != \"audio\" {",
            "@@ -838,14 +890,15 @@",
            " \t\t\t&MediaEngine{},",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\t[]mediaSection{},",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\tvar found bool",
            " \t\t// session-level attribute",
            " \t\tfor _, a := range offerSdp.Attributes {",
            " \t\t\tif a.Key == sdp.AttrKeyExtMapAllowMixed {",
            "@@ -867,14 +920,15 @@",
            " \t\t\tfalse, &MediaEngine{},",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\t[]mediaSection{},",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\tfound = false",
            " \t\t// session-level attribute",
            " \t\tfor _, a := range offerSdp.Attributes {",
            " \t\t\tif a.Key == sdp.AttrKeyExtMapAllowMixed {",
            "@@ -910,14 +964,15 @@",
            " \t\t\tme,",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\tmediaSections,",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\tnil,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\tbundle, ok := offerSdp.Attribute(sdp.AttrKeyGroup)",
            " \t\tassert.True(t, ok)",
            " \t\tassert.Equal(t, \"BUNDLE video\", bundle)",
            " \t})",
            "@@ -949,14 +1004,15 @@",
            " \t\t\tme,",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\tmediaSections,",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\t&matchedBundle,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\tbundle, ok := offerSdp.Attribute(sdp.AttrKeyGroup)",
            " \t\tassert.True(t, ok)",
            " \t\tassert.Equal(t, \"BUNDLE audio\", bundle)",
            " ",
            "@@ -990,14 +1046,15 @@",
            " \t\t\tme,",
            " \t\t\tconnectionRoleFromDtlsRole(defaultDtlsRoleOffer),",
            " \t\t\t[]ICECandidate{},",
            " \t\t\tICEParameters{},",
            " \t\t\tmediaSections,",
            " \t\t\tICEGatheringStateComplete,",
            " \t\t\t&matchedBundle,",
            "+\t\t\tse.getSCTPMaxMessageSize(),",
            " \t\t)",
            " \t\tassert.Nil(t, err)",
            " ",
            " \t\t_, ok := offerSdp.Attribute(sdp.AttrKeyGroup)",
            " \t\tassert.False(t, ok)",
            " \t})",
            " }",
            "@@ -1207,21 +1264,21 @@",
            " \t\t{\"Answer\", true, true, offerWithRTX},",
            " \t\t{\"Answer No Local Groups\", false, false, offerWithRTX},",
            " \t\t{\"Answer No Remote Groups\", true, false, offerNoRTX},",
            " \t} {",
            " \t\tt.Run(testCase.name, func(t *testing.T) {",
            " \t\t\tcheckRTXSupport := func(s *sdp.SessionDescription) {",
            " \t\t\t\t// RTX is never enabled for audio",
            "-\t\t\t\tassert.Nil(t, trackDetailsFromSDP(nil, s)[0].repairSsrc)",
            "+\t\t\t\tassert.Nil(t, trackDetailsFromSDP(nil, s)[0].rtxSsrc)",
            " ",
            " \t\t\t\t// RTX is conditionally enabled for video",
            " \t\t\t\tif testCase.rtxExpected {",
            "-\t\t\t\t\tassert.NotNil(t, trackDetailsFromSDP(nil, s)[1].repairSsrc)",
            "+\t\t\t\t\tassert.NotNil(t, trackDetailsFromSDP(nil, s)[1].rtxSsrc)",
            " \t\t\t\t} else {",
            "-\t\t\t\t\tassert.Nil(t, trackDetailsFromSDP(nil, s)[1].repairSsrc)",
            "+\t\t\t\t\tassert.Nil(t, trackDetailsFromSDP(nil, s)[1].rtxSsrc)",
            " \t\t\t\t}",
            " \t\t\t}",
            " ",
            " \t\t\tme := &MediaEngine{}",
            " \t\t\tassert.NoError(t, me.RegisterCodec(RTPCodecParameters{",
            " \t\t\t\tRTPCodecCapability: RTPCodecCapability{",
            " \t\t\t\t\tMimeType:     MimeTypeOpus,"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/settingengine.go",
          "change": [
            "--- /home/webrtc-4.0.11/settingengine.go",
            "+++ /home/webrtc-4.1.3/settingengine.go",
            "@@ -79,14 +79,18 @@",
            " \t\tserverHelloMessageHook        func(handshake.MessageServerHello) handshake.Message",
            " \t\tcertificateRequestMessageHook func(handshake.MessageCertificateRequest) handshake.Message",
            " \t}",
            " \tsctp struct {",
            " \t\tmaxReceiveBufferSize uint32",
            " \t\tenableZeroChecksum   bool",
            " \t\trtoMax               time.Duration",
            "+\t\tmaxMessageSize       uint32",
            "+\t\tminCwnd              uint32",
            "+\t\tfastRtxWnd           uint32",
            "+\t\tcwndCAStep           uint32",
            " \t}",
            " \tsdpMediaLevelFingerprints                 bool",
            " \tansweringDTLSRole                         DTLSRole",
            " \tdisableCertificateFingerprintVerification bool",
            " \tdisableSRTPReplayProtection               bool",
            " \tdisableSRTCPReplayProtection              bool",
            " \tnet                                       transport.Net",
            "@@ -94,22 +98,31 @@",
            " \tLoggerFactory                             logging.LoggerFactory",
            " \ticeTCPMux                                 ice.TCPMux",
            " \ticeUDPMux                                 ice.UDPMux",
            " \ticeProxyDialer                            proxy.Dialer",
            " \ticeDisableActiveTCP                       bool",
            " \ticeBindingRequestHandler                  func(m *stun.Message, local, remote ice.Candidate, pair *ice.CandidatePair) bool //nolint:lll",
            " \tdisableMediaEngineCopy                    bool",
            "+\tdisableMediaEngineMultipleCodecs          bool",
            " \tsrtpProtectionProfiles                    []dtls.SRTPProtectionProfile",
            " \treceiveMTU                                uint",
            " \ticeMaxBindingRequests                     *uint16",
            " \tfireOnTrackBeforeFirstRTP                 bool",
            " \tdisableCloseByDTLS                        bool",
            " \tdataChannelBlockWrite                     bool",
            " }",
            " ",
            "+func (e *SettingEngine) getSCTPMaxMessageSize() uint32 {",
            "+\tif e.sctp.maxMessageSize != 0 {",
            "+\t\treturn e.sctp.maxMessageSize",
            "+\t}",
            "+",
            "+\treturn defaultMaxSCTPMessageSize",
            "+}",
            "+",
            " // getReceiveMTU returns the configured MTU. If SettingEngine's MTU is configured to 0 it returns the default.",
            " func (e *SettingEngine) getReceiveMTU() uint {",
            " \tif e.receiveMTU != 0 {",
            " \t\treturn e.receiveMTU",
            " \t}",
            " ",
            " \treturn receiveMTU",
            "@@ -383,14 +396,24 @@",
            " // DisableMediaEngineCopy stops the MediaEngine from being copied. This allows a user to modify",
            " // the MediaEngine after the PeerConnection has been constructed. This is useful if you wish to",
            " // modify codecs after signaling. Make sure not to share MediaEngines between PeerConnections.",
            " func (e *SettingEngine) DisableMediaEngineCopy(isDisabled bool) {",
            " \te.disableMediaEngineCopy = isDisabled",
            " }",
            " ",
            "+// DisableMediaEngineMultipleCodecs disables the MediaEngine negotiating different codecs.",
            "+// With the default value multiple media sections in the SDP can each negotiate different",
            "+// codecs. This is the new default behvior, because it makes Pion more spec compliant.",
            "+// The value of this setting will get copied to every copy of the MediaEngine generated",
            "+// for new PeerConnections (assuming DisableMediaEngineCopy is set to false).",
            "+// Note: this setting is targeted to be removed in release 4.2.0 (or later).",
            "+func (e *SettingEngine) DisableMediaEngineMultipleCodecs(isDisabled bool) {",
            "+\te.disableMediaEngineMultipleCodecs = isDisabled",
            "+}",
            "+",
            " // SetReceiveMTU sets the size of read buffer that copies incoming packets. This is optional.",
            " // Leave this 0 for the default receiveMTU.",
            " func (e *SettingEngine) SetReceiveMTU(receiveMTU uint) {",
            " \te.receiveMTU = receiveMTU",
            " }",
            " ",
            " // SetDTLSRetransmissionInterval sets the retranmission interval for DTLS.",
            "@@ -463,14 +486,20 @@",
            " // EnableSCTPZeroChecksum controls the zero checksum feature in SCTP.",
            " // This removes the need to checksum every incoming/outgoing packet and will reduce",
            " // latency and CPU usage. This feature is not backwards compatible so is disabled by default.",
            " func (e *SettingEngine) EnableSCTPZeroChecksum(isEnabled bool) {",
            " \te.sctp.enableZeroChecksum = isEnabled",
            " }",
            " ",
            "+// SetSCTPMaxMessageSize sets the largest message we are willing to accept.",
            "+// Leave this 0 for the default max message size.",
            "+func (e *SettingEngine) SetSCTPMaxMessageSize(maxMessageSize uint32) {",
            "+\te.sctp.maxMessageSize = maxMessageSize",
            "+}",
            "+",
            " // SetDTLSCustomerCipherSuites allows the user to specify a list of DTLS CipherSuites.",
            " // This allow usage of Ciphers that are reserved for private usage.",
            " func (e *SettingEngine) SetDTLSCustomerCipherSuites(customCipherSuites func() []dtls.CipherSuite) {",
            " \te.dtls.customCipherSuites = customCipherSuites",
            " }",
            " ",
            " // SetDTLSClientHelloMessageHook if not nil, is called when a DTLS Client Hello message is sent",
            "@@ -495,14 +524,30 @@",
            " ",
            " // SetSCTPRTOMax sets the maximum retransmission timeout.",
            " // Leave this 0 for the default timeout.",
            " func (e *SettingEngine) SetSCTPRTOMax(rtoMax time.Duration) {",
            " \te.sctp.rtoMax = rtoMax",
            " }",
            " ",
            "+// SetSCTPMinCwnd sets the minimum congestion window size. The congestion window",
            "+// will not be smaller than this value during congestion control.",
            "+func (e *SettingEngine) SetSCTPMinCwnd(minCwnd uint32) {",
            "+\te.sctp.minCwnd = minCwnd",
            "+}",
            "+",
            "+// SetSCTPFastRtxWnd sets the fast retransmission window size.",
            "+func (e *SettingEngine) SetSCTPFastRtxWnd(fastRtxWnd uint32) {",
            "+\te.sctp.fastRtxWnd = fastRtxWnd",
            "+}",
            "+",
            "+// SetSCTPCwndCAStep sets congestion window adjustment step size during congestion avoidance.",
            "+func (e *SettingEngine) SetSCTPCwndCAStep(cwndCAStep uint32) {",
            "+\te.sctp.cwndCAStep = cwndCAStep",
            "+}",
            "+",
            " // SetICEBindingRequestHandler sets a callback that is fired on a STUN BindingRequest",
            " // This allows users to do things like",
            " // - Log incoming Binding Requests for debugging",
            " // - Implement draft-thatcher-ice-renomination",
            " // - Implement custom CandidatePair switching logic.",
            " func (e *SettingEngine) SetICEBindingRequestHandler(",
            " \tbindingRequestHandler func(m *stun.Message, local, remote ice.Candidate, pair *ice.CandidatePair) bool,"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/settingengine_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/settingengine_test.go",
            "+++ /home/webrtc-4.1.3/settingengine_test.go",
            "@@ -19,33 +19,26 @@",
            " \t\"github.com/pion/stun/v3\"",
            " \t\"github.com/pion/transport/v3/test\"",
            " \t\"github.com/stretchr/testify/assert\"",
            " )",
            " ",
            " func TestSetEphemeralUDPPortRange(t *testing.T) {",
            " \tsettingEngine := SettingEngine{}",
            "-",
            "-\tif settingEngine.ephemeralUDP.PortMin != 0 ||",
            "-\t\tsettingEngine.ephemeralUDP.PortMax != 0 {",
            "-\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")",
            "-\t}",
            "+\tassert.Equal(t, uint16(0), settingEngine.ephemeralUDP.PortMin)",
            "+\tassert.Equal(t, uint16(0), settingEngine.ephemeralUDP.PortMax)",
            " ",
            " \t// set bad ephemeral ports",
            "-\tif err := settingEngine.SetEphemeralUDPPortRange(3000, 2999); err == nil {",
            "-\t\tt.Fatalf(\"Setting engine should fail bad ephemeral ports.\")",
            "-\t}",
            "-",
            "-\tif err := settingEngine.SetEphemeralUDPPortRange(3000, 4000); err != nil {",
            "-\t\tt.Fatalf(\"Setting engine failed valid port range: %s\", err)",
            "-\t}",
            "-",
            "-\tif settingEngine.ephemeralUDP.PortMin != 3000 ||",
            "-\t\tsettingEngine.ephemeralUDP.PortMax != 4000 {",
            "-\t\tt.Fatalf(\"Setting engine ports do not reflect expected range\")",
            "-\t}",
            "+\tassert.Error(",
            "+\t\tt, settingEngine.SetEphemeralUDPPortRange(3000, 2999),",
            "+\t\t\"Setting engine should fail bad ephemeral ports\",",
            "+\t)",
            "+",
            "+\tassert.NoError(t, settingEngine.SetEphemeralUDPPortRange(3000, 4000))",
            "+\tassert.Equal(t, uint16(3000), settingEngine.ephemeralUDP.PortMin)",
            "+\tassert.Equal(t, uint16(4000), settingEngine.ephemeralUDP.PortMax)",
            " }",
            " ",
            " func TestSetConnectionTimeout(t *testing.T) {",
            " \ts := SettingEngine{}",
            " ",
            " \tvar nilDuration *time.Duration",
            " \tassert.Equal(t, s.timeout.ICEDisconnectedTimeout, nilDuration)",
            "@@ -56,44 +49,30 @@",
            " \tassert.Equal(t, *s.timeout.ICEDisconnectedTimeout, 1*time.Second)",
            " \tassert.Equal(t, *s.timeout.ICEFailedTimeout, 2*time.Second)",
            " \tassert.Equal(t, *s.timeout.ICEKeepaliveInterval, 3*time.Second)",
            " }",
            " ",
            " func TestDetachDataChannels(t *testing.T) {",
            " \ts := SettingEngine{}",
            "-",
            "-\tif s.detach.DataChannels {",
            "-\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")",
            "-\t}",
            "+\tassert.False(t, s.detach.DataChannels)",
            " ",
            " \ts.DetachDataChannels()",
            "-",
            "-\tif !s.detach.DataChannels {",
            "-\t\tt.Fatalf(\"Failed to enable detached data channels.\")",
            "-\t}",
            "+\tassert.True(t, s.detach.DataChannels, \"Failed to enable detached data channels.\")",
            " }",
            " ",
            " func TestSetNAT1To1IPs(t *testing.T) {",
            " \tsettingEngine := SettingEngine{}",
            "-\tif settingEngine.candidates.NAT1To1IPs != nil {",
            "-\t\tt.Errorf(\"Invalid default value\")",
            "-\t}",
            "-\tif settingEngine.candidates.NAT1To1IPCandidateType != 0 {",
            "-\t\tt.Errorf(\"Invalid default value\")",
            "-\t}",
            "+\tassert.Nil(t, settingEngine.candidates.NAT1To1IPs)",
            "+\tassert.Equal(t, ICECandidateType(0), settingEngine.candidates.NAT1To1IPCandidateType)",
            " ",
            " \tips := []string{\"1.2.3.4\"}",
            " \ttyp := ICECandidateTypeHost",
            " \tsettingEngine.SetNAT1To1IPs(ips, typ)",
            "-\tif len(settingEngine.candidates.NAT1To1IPs) != 1 || settingEngine.candidates.NAT1To1IPs[0] != \"1.2.3.4\" {",
            "-\t\tt.Fatalf(\"Failed to set NAT1To1IPs\")",
            "-\t}",
            "-\tif settingEngine.candidates.NAT1To1IPCandidateType != typ {",
            "-\t\tt.Fatalf(\"Failed to set NAT1To1IPCandidateType\")",
            "-\t}",
            "+\tassert.Equal(t, ips, settingEngine.candidates.NAT1To1IPs, \"Failed to set NAT1To1IPs\")",
            "+\tassert.Equal(t, typ, settingEngine.candidates.NAT1To1IPCandidateType, \"Failed to set NAT1To1IPCandidateType\")",
            " }",
            " ",
            " func TestSetAnsweringDTLSRole(t *testing.T) {",
            " \ts := SettingEngine{}",
            " \tassert.Error(",
            " \t\tt,",
            " \t\ts.SetAnsweringDTLSRole(DTLSRoleAuto),",
            "@@ -105,46 +84,55 @@",
            " \t\t\"SetAnsweringDTLSRole can only be called with DTLSRoleClient or DTLSRoleServer\",",
            " \t)",
            " }",
            " ",
            " func TestSetReplayProtection(t *testing.T) {",
            " \tsettingEngine := SettingEngine{}",
            " ",
            "-\tif settingEngine.replayProtection.DTLS != nil ||",
            "-\t\tsettingEngine.replayProtection.SRTP != nil ||",
            "-\t\tsettingEngine.replayProtection.SRTCP != nil {",
            "-\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")",
            "-\t}",
            "+\tassert.Nil(t, settingEngine.replayProtection.DTLS)",
            "+\tassert.Nil(t, settingEngine.replayProtection.SRTP)",
            "+\tassert.Nil(t, settingEngine.replayProtection.SRTCP)",
            " ",
            " \tsettingEngine.SetDTLSReplayProtectionWindow(128)",
            " \tsettingEngine.SetSRTPReplayProtectionWindow(64)",
            " \tsettingEngine.SetSRTCPReplayProtectionWindow(32)",
            " ",
            "-\tif settingEngine.replayProtection.DTLS == nil ||",
            "-\t\t*settingEngine.replayProtection.DTLS != 128 {",
            "-\t\tt.Errorf(\"Failed to set DTLS replay protection window\")",
            "-\t}",
            "-\tif settingEngine.replayProtection.SRTP == nil ||",
            "-\t\t*settingEngine.replayProtection.SRTP != 64 {",
            "-\t\tt.Errorf(\"Failed to set SRTP replay protection window\")",
            "-\t}",
            "-\tif settingEngine.replayProtection.SRTCP == nil ||",
            "-\t\t*settingEngine.replayProtection.SRTCP != 32 {",
            "-\t\tt.Errorf(\"Failed to set SRTCP replay protection window\")",
            "-\t}",
            "+\tassert.NotNil(",
            "+\t\tt, settingEngine.replayProtection.DTLS,",
            "+\t\t\"DTLS replay protection window should not be nil\",",
            "+\t)",
            "+\tassert.Equal(",
            "+\t\tt, uint(128), *settingEngine.replayProtection.DTLS,",
            "+\t\t\"Failed to set DTLS replay protection window\",",
            "+\t)",
            "+",
            "+\tassert.NotNil(",
            "+\t\tt, settingEngine.replayProtection.SRTP,",
            "+\t\t\"SRTP replay protection window should not be nil\",",
            "+\t)",
            "+\tassert.Equal(",
            "+\t\tt, uint(64), *settingEngine.replayProtection.SRTP,",
            "+\t\t\"Failed to set SRTP replay protection window\",",
            "+\t)",
            "+\tassert.NotNil(",
            "+\t\tt, settingEngine.replayProtection.SRTCP,",
            "+\t\t\"SRTCP replay protection window should not be nil\",",
            "+\t)",
            "+\tassert.Equal(",
            "+\t\tt, uint(32), *settingEngine.replayProtection.SRTCP,",
            "+\t\t\"Failed to set SRTCP replay protection window\",",
            "+\t)",
            " }",
            " ",
            " func TestSettingEngine_SetICETCP(t *testing.T) {",
            " \treport := test.CheckRoutines(t)",
            " \tdefer report()",
            " ",
            " \tlistener, err := net.ListenTCP(\"tcp\", &net.TCPAddr{})",
            "-\tif err != nil {",
            "-\t\tpanic(err)",
            "-\t}",
            "+\tassert.NoError(t, err)",
            " ",
            " \tdefer func() {",
            " \t\t_ = listener.Close()",
            " \t}()",
            " ",
            " \ttcpMux := NewICETCPMux(nil, listener, 8)",
            " ",
            "@@ -230,43 +218,36 @@",
            " \t\tclosePairNow(t, offerer, answerer)",
            " \t})",
            " }",
            " ",
            " func TestSetDTLSRetransmissionInterval(t *testing.T) {",
            " \tsettingEngine := SettingEngine{}",
            " ",
            "-\tif settingEngine.dtls.retransmissionInterval != 0 {",
            "-\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")",
            "-\t}",
            "+\tassert.Equal(t, time.Duration(0), settingEngine.dtls.retransmissionInterval)",
            " ",
            " \tsettingEngine.SetDTLSRetransmissionInterval(100 * time.Millisecond)",
            "-\tif settingEngine.dtls.retransmissionInterval == 0 ||",
            "-\t\tsettingEngine.dtls.retransmissionInterval != 100*time.Millisecond {",
            "-\t\tt.Errorf(\"Failed to set DTLS retransmission interval\")",
            "-\t}",
            "+\tassert.Equal(",
            "+\t\tt, 100*time.Millisecond, settingEngine.dtls.retransmissionInterval,",
            "+\t\t\"Failed to set DTLS retransmission interval\",",
            "+\t)",
            " ",
            " \tsettingEngine.SetDTLSRetransmissionInterval(1 * time.Second)",
            "-\tif settingEngine.dtls.retransmissionInterval == 0 ||",
            "-\t\tsettingEngine.dtls.retransmissionInterval != 1*time.Second {",
            "-\t\tt.Errorf(\"Failed to set DTLS retransmission interval\")",
            "-\t}",
            "+\tassert.Equal(",
            "+\t\tt, 1*time.Second, settingEngine.dtls.retransmissionInterval,",
            "+\t\t\"Failed to set DTLS retransmission interval\",",
            "+\t)",
            " }",
            " ",
            " func TestSetDTLSEllipticCurves(t *testing.T) {",
            " \ts := SettingEngine{}",
            "-",
            "-\tif len(s.dtls.ellipticCurves) != 0 {",
            "-\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")",
            "-\t}",
            "+\tassert.Empty(t, s.dtls.ellipticCurves)",
            " ",
            " \ts.SetDTLSEllipticCurves(elliptic.P256)",
            "-\tif len(s.dtls.ellipticCurves) == 0 ||",
            "-\t\ts.dtls.ellipticCurves[0] != elliptic.P256 {",
            "-\t\tt.Errorf(\"Failed to set DTLS elliptic curves\")",
            "-\t}",
            "+\tassert.NotEmpty(t, s.dtls.ellipticCurves, \"Failed to set DTLS elliptic curves\")",
            "+\tassert.Equal(t, elliptic.P256, s.dtls.ellipticCurves[0])",
            " }",
            " ",
            " func TestSetDTLSHandShakeTimeout(*testing.T) {",
            " \ts := SettingEngine{}",
            " ",
            " \ts.SetDTLSConnectContextMaker(func() (context.Context, func()) {",
            " \t\treturn context.WithTimeout(context.Background(), 60*time.Second)",
            "@@ -319,39 +300,40 @@",
            " \t<-seenICEControlling.Done()",
            " \tclosePairNow(t, pcOffer, pcAnswer)",
            " }",
            " ",
            " func TestSetHooks(t *testing.T) {",
            " \tsettingEngine := SettingEngine{}",
            " ",
            "-\tif settingEngine.dtls.clientHelloMessageHook != nil ||",
            "-\t\tsettingEngine.dtls.serverHelloMessageHook != nil ||",
            "-\t\tsettingEngine.dtls.certificateRequestMessageHook != nil {",
            "-\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")",
            "-\t}",
            "+\tassert.Nil(t, settingEngine.dtls.clientHelloMessageHook)",
            "+\tassert.Nil(t, settingEngine.dtls.serverHelloMessageHook)",
            "+\tassert.Nil(t, settingEngine.dtls.certificateRequestMessageHook)",
            " ",
            " \tsettingEngine.SetDTLSClientHelloMessageHook(func(msg handshake.MessageClientHello) handshake.Message {",
            " \t\treturn &msg",
            " \t})",
            " \tsettingEngine.SetDTLSServerHelloMessageHook(func(msg handshake.MessageServerHello) handshake.Message {",
            " \t\treturn &msg",
            " \t})",
            " \tsettingEngine.SetDTLSCertificateRequestMessageHook(func(msg handshake.MessageCertificateRequest) handshake.Message {",
            " \t\treturn &msg",
            " \t})",
            " ",
            "-\tif settingEngine.dtls.clientHelloMessageHook == nil {",
            "-\t\tt.Errorf(\"Failed to set DTLS Client Hello Hook\")",
            "-\t}",
            "-\tif settingEngine.dtls.serverHelloMessageHook == nil {",
            "-\t\tt.Errorf(\"Failed to set DTLS Server Hello Hook\")",
            "-\t}",
            "-\tif settingEngine.dtls.certificateRequestMessageHook == nil {",
            "-\t\tt.Errorf(\"Failed to set DTLS Certificate Request Hook\")",
            "-\t}",
            "+\tassert.NotNil(",
            "+\t\tt, settingEngine.dtls.clientHelloMessageHook,",
            "+\t\t\"Failed to set DTLS Client Hello Hook\",",
            "+\t)",
            "+\tassert.NotNil(",
            "+\t\tt, settingEngine.dtls.serverHelloMessageHook,",
            "+\t\t\"Failed to set DTLS Server Hello Hook\",",
            "+\t)",
            "+\tassert.NotNil(",
            "+\t\tt, settingEngine.dtls.certificateRequestMessageHook,",
            "+\t\t\"Failed to set DTLS Certificate Request Hook\",",
            "+\t)",
            " }",
            " ",
            " func TestSetFireOnTrackBeforeFirstRTP(t *testing.T) {",
            " \tlim := test.TimeOut(time.Second * 30)",
            " \tdefer lim.Stop()",
            " ",
            " \treport := test.CheckRoutines(t)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/stats_go_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/stats_go_test.go",
            "+++ /home/webrtc-4.1.3/stats_go_test.go",
            "@@ -34,17 +34,15 @@",
            " \t\t\tWantTime:  time.Unix(0, 1e6),",
            " \t\t},",
            " \t\t{",
            " \t\t\tTimestamp: 0.001,",
            " \t\t\tWantTime:  time.Unix(0, 1e3),",
            " \t\t},",
            " \t} {",
            "-\t\tif got, want := test.Timestamp.Time(), test.WantTime.UTC(); got != want {",
            "-\t\t\tt.Fatalf(\"StatsTimestamp(%v).Time() = %v, want %v\", test.Timestamp, got, want)",
            "-\t\t}",
            "+\t\tassert.Equal(t, test.WantTime.UTC(), test.Timestamp.Time())",
            " \t}",
            " }",
            " ",
            " type statSample struct {",
            " \tname  string",
            " \tstats Stats",
            " \tjson  string",
            "@@ -1167,15 +1165,15 @@",
            " \t\tdone <- struct{}{}",
            " \t}()",
            " \ttimeout := time.After(5 * time.Second)",
            " \tselect {",
            " \tcase <-done:",
            " \t\tbreak",
            " \tcase <-timeout:",
            "-\t\tt.Fatal(\"timed out waiting for waitgroup\")",
            "+\t\tassert.Fail(t, \"timed out waiting for waitgroup\")",
            " \t}",
            " }",
            " ",
            " func getConnectionStats(t *testing.T, report StatsReport, pc *PeerConnection) PeerConnectionStats {",
            " \tt.Helper()",
            " ",
            " \tstats, ok := report.GetConnectionStats(pc)"
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/track_local_static.go",
          "change": [
            "--- /home/webrtc-4.0.11/track_local_static.go",
            "+++ /home/webrtc-4.1.3/track_local_static.go",
            "@@ -29,14 +29,15 @@",
            " // If you wish to send a media.Sample use TrackLocalStaticSample.",
            " type TrackLocalStaticRTP struct {",
            " \tmu                sync.RWMutex",
            " \tbindings          []trackBinding",
            " \tcodec             RTPCodecCapability",
            " \tpayloader         func(RTPCodecCapability) (rtp.Payloader, error)",
            " \tid, rid, streamID string",
            "+\trtpTimestamp      *uint32",
            " }",
            " ",
            " // NewTrackLocalStaticRTP returns a TrackLocalStaticRTP.",
            " func NewTrackLocalStaticRTP(",
            " \tc RTPCodecCapability,",
            " \tid, streamID string,",
            " \toptions ...func(*TrackLocalStaticRTP),",
            "@@ -65,14 +66,21 @@",
            " // WithPayloader allows the user to override the Payloader.",
            " func WithPayloader(h func(RTPCodecCapability) (rtp.Payloader, error)) func(*TrackLocalStaticRTP) {",
            " \treturn func(s *TrackLocalStaticRTP) {",
            " \t\ts.payloader = h",
            " \t}",
            " }",
            " ",
            "+// WithRTPTimestamp set the initial RTP timestamp for the track.",
            "+func WithRTPTimestamp(timestamp uint32) func(*TrackLocalStaticRTP) {",
            "+\treturn func(s *TrackLocalStaticRTP) {",
            "+\t\ts.rtpTimestamp = &timestamp",
            "+\t}",
            "+}",
            "+",
            " // Bind is called by the PeerConnection after negotiation is complete",
            " // This asserts that the code requested is supported by the remote peer.",
            " // If so it sets up all the state (SSRC and PayloadType) to have a call.",
            " func (s *TrackLocalStaticRTP) Bind(trackContext TrackLocalContext) (RTPCodecParameters, error) {",
            " \ts.mu.Lock()",
            " \tdefer s.mu.Unlock()",
            " ",
            "@@ -142,15 +150,15 @@",
            " func (s *TrackLocalStaticRTP) Codec() RTPCodecCapability {",
            " \treturn s.codec",
            " }",
            " ",
            " // packetPool is a pool of packets used by WriteRTP and Write below",
            " // nolint:gochecknoglobals",
            " var rtpPacketPool = sync.Pool{",
            "-\tNew: func() interface{} {",
            "+\tNew: func() any {",
            " \t\treturn &rtp.Packet{}",
            " \t},",
            " }",
            " ",
            " func resetPacketPoolAllocation(localPacket *rtp.Packet) {",
            " \t*localPacket = rtp.Packet{}",
            " \trtpPacketPool.Put(localPacket)",
            "@@ -182,14 +190,19 @@",
            " \tdefer s.mu.RUnlock()",
            " ",
            " \twriteErrs := []error{}",
            " ",
            " \tfor _, b := range s.bindings {",
            " \t\tpacket.Header.SSRC = uint32(b.ssrc)",
            " \t\tpacket.Header.PayloadType = uint8(b.payloadType)",
            "+\t\t// b.writeStream.WriteRTP below expects header and payload separately, so value of Packet.PaddingSize",
            "+\t\t// would be lost. Copy it to Packet.Header.PaddingSize to avoid that problem.",
            "+\t\tif packet.PaddingSize != 0 && packet.Header.PaddingSize == 0 {",
            "+\t\t\tpacket.Header.PaddingSize = packet.PaddingSize",
            "+\t\t}",
            " \t\tif _, err := b.writeStream.WriteRTP(&packet.Header, packet.Payload); err != nil {",
            " \t\t\twriteErrs = append(writeErrs, err)",
            " \t\t}",
            " \t}",
            " ",
            " \treturn util.FlattenErrs(writeErrs)",
            " }",
            "@@ -278,22 +291,29 @@",
            " ",
            " \tpayloader, err := payloadHandler(codec.RTPCodecCapability)",
            " \tif err != nil {",
            " \t\treturn codec, err",
            " \t}",
            " ",
            " \ts.sequencer = rtp.NewRandomSequencer()",
            "-\ts.packetizer = rtp.NewPacketizer(",
            "-\t\trtpOutboundMTU,",
            "-\t\t0, // Value is handled when writing",
            "-\t\t0, // Value is handled when writing",
            "+",
            "+\toptions := []rtp.PacketizerOption{}",
            "+",
            "+\tif s.rtpTrack.rtpTimestamp != nil {",
            "+\t\toptions = append(options, rtp.WithTimestamp(*s.rtpTrack.rtpTimestamp))",
            "+\t}",
            "+",
            "+\ts.packetizer = rtp.NewPacketizerWithOptions(",
            "+\t\toutboundMTU,",
            " \t\tpayloader,",
            " \t\ts.sequencer,",
            " \t\tcodec.ClockRate,",
            "+\t\toptions...,",
            " \t)",
            "+",
            " \ts.clockRate = float64(codec.RTPCodecCapability.ClockRate)",
            " ",
            " \treturn codec, nil",
            " }",
            " ",
            " // Unbind implements the teardown logic when the track is no longer needed. This happens",
            " // because a track has been stopped."
          ]
        },
        {
          "file": "/home/webrtc-4.1.3/track_local_static_test.go",
          "change": [
            "--- /home/webrtc-4.0.11/track_local_static_test.go",
            "+++ /home/webrtc-4.1.3/track_local_static_test.go",
            "@@ -267,14 +267,45 @@",
            " \tbuf := make([]byte, 1024)",
            " \tfor i := 0; i < b.N; i++ {",
            " \t\t_, err := track.Write(buf)",
            " \t\tassert.NoError(b, err)",
            " \t}",
            " }",
            " ",
            "+type TestPacketizer struct {",
            "+\trtp.Packetizer",
            "+\tchecked [3]bool",
            "+}",
            "+",
            "+func (p *TestPacketizer) GeneratePadding(samples uint32) []*rtp.Packet {",
            "+\tpackets := p.Packetizer.GeneratePadding(samples)",
            "+\tfor _, packet := range packets {",
            "+\t\t// Reset padding to ensure we control it",
            "+\t\tpacket.Header.PaddingSize = 0",
            "+\t\tpacket.PaddingSize = 0",
            "+\t\tpacket.Payload = nil",
            "+",
            "+\t\tp.checked[packet.SequenceNumber%3] = true",
            "+\t\tswitch packet.SequenceNumber % 3 {",
            "+\t\tcase 0:",
            "+\t\t\t// Recommended way to add padding",
            "+\t\t\tpacket.Header.PaddingSize = 255",
            "+\t\tcase 1:",
            "+\t\t\t// This was used as a workaround so has to be supported too",
            "+\t\t\tpacket.Payload = make([]byte, 255)",
            "+\t\t\tpacket.Payload[254] = 255",
            "+\t\tcase 2:",
            "+\t\t\t// This field is deprecated but still used by some clients",
            "+\t\t\tpacket.PaddingSize = 255",
            "+\t\t}",
            "+\t}",
            "+",
            "+\treturn packets",
            "+}",
            "+",
            " func Test_TrackLocalStatic_Padding(t *testing.T) {",
            " \tmediaEngineOne := &MediaEngine{}",
            " \tassert.NoError(t, mediaEngineOne.RegisterCodec(RTPCodecParameters{",
            " \t\tRTPCodecCapability: RTPCodecCapability{",
            " \t\t\tMimeType:     \"video/VP8\",",
            " \t\t\tClockRate:    90000,",
            " \t\t\tChannels:     0,",
            "@@ -319,33 +350,40 @@",
            " ",
            " \t\tfor i := 0; i < 20; i++ {",
            " \t\t\t// Padding payload",
            " \t\t\tp, _, e := track.ReadRTP()",
            " \t\t\tassert.NoError(t, e)",
            " \t\t\tassert.True(t, p.Padding)",
            " \t\t\tassert.Equal(t, p.PaddingSize, byte(255))",
            "+\t\t\tassert.Equal(t, p.Header.PaddingSize, byte(255))",
            " \t\t}",
            " ",
            " \t\tonTrackFiredFunc()",
            " \t})",
            " ",
            " \tassert.NoError(t, signalPair(offerer, answerer))",
            " ",
            " \texit := false",
            " ",
            "+\t// Use a custom packetizer that generates packets with padding in a few different ways",
            "+\tpacketizer := &TestPacketizer{Packetizer: track.packetizer}",
            "+\ttrack.packetizer = packetizer",
            "+",
            " \tfor !exit {",
            " \t\tselect {",
            " \t\tcase <-time.After(1 * time.Millisecond):",
            " \t\t\tassert.NoError(t, track.GeneratePadding(1))",
            " \t\tcase <-onTrackFired.Done():",
            " \t\t\texit = true",
            " \t\t}",
            " \t}",
            " ",
            " \tclosePairNow(t, offerer, answerer)",
            "+",
            "+\tassert.Equal(t, [3]bool{true, true, true}, packetizer.checked)",
            " }",
            " ",
            " func Test_TrackLocalStatic_RTX(t *testing.T) {",
            " \tdefer test.TimeOut(time.Second * 30).Stop()",
            " \tdefer test.CheckRoutines(t)()",
            " ",
            " \tofferer, answerer, err := newPair()",
            "@@ -421,7 +459,48 @@",
            " \t\tonTrackFiredFunc()",
            " \t})",
            " ",
            " \tsendVideoUntilDone(t, onTrackFired.Done(), []*TrackLocalStaticSample{track})",
            " ",
            " \tclosePairNow(t, offerer, answerer)",
            " }",
            "+",
            "+func Test_TrackLocalStatic_Timestamp(t *testing.T) {",
            "+\tlim := test.TimeOut(time.Second * 30)",
            "+\tdefer lim.Stop()",
            "+",
            "+\treport := test.CheckRoutines(t)",
            "+\tdefer report()",
            "+",
            "+\tinitialTimestamp := uint32(12345)",
            "+\ttrack, err := NewTrackLocalStaticSample(",
            "+\t\tRTPCodecCapability{MimeType: MimeTypeVP8},",
            "+\t\t\"video\",",
            "+\t\t\"pion\",",
            "+\t\tWithRTPTimestamp(initialTimestamp),",
            "+\t)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tpcOffer, pcAnswer, err := newPair()",
            "+\tassert.NoError(t, err)",
            "+",
            "+\t_, err = pcOffer.AddTrack(track)",
            "+\tassert.NoError(t, err)",
            "+",
            "+\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())",
            "+\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, _ *RTPReceiver) {",
            "+\t\tpkt, _, err := trackRemote.ReadRTP()",
            "+\t\tassert.NoError(t, err)",
            "+\t\tassert.GreaterOrEqual(t, pkt.Timestamp, initialTimestamp)",
            "+\t\t// not accurate, but some grace period for slow CI test runners.",
            "+\t\tassert.LessOrEqual(t, pkt.Timestamp, initialTimestamp+100000)",
            "+",
            "+\t\tonTrackFiredFunc()",
            "+\t})",
            "+",
            "+\tassert.NoError(t, signalPair(pcOffer, pcAnswer))",
            "+",
            "+\tsendVideoUntilDone(t, onTrackFired.Done(), []*TrackLocalStaticSample{track})",
            "+",
            "+\t<-onTrackFired.Done()",
            "+\tclosePairNow(t, pcOffer, pcAnswer)",
            "+}"
          ]
        }
      ]
    }
  }
}