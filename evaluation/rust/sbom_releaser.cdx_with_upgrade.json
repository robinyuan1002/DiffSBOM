{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:07f582d4-586c-4d57-aea1-65c6f494af82",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-13T21:57:55-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "93ae4c86bc3070df",
      "type": "file",
      "name": "releaser-0.14.0/"
    }
  },
  "components": [
    {
      "bom-ref": "pkg:github/actions-rs/audit-check@v1?package-id=3604d6933a791407",
      "type": "library",
      "name": "actions-rs/audit-check",
      "version": "v1",
      "cpe": "cpe:2.3:a:actions-rs\\/audit-check:actions-rs\\/audit-check:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions-rs/audit-check@v1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/audit-check:actions_rs\\/audit_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/audit_check:actions-rs\\/audit-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/audit_check:actions_rs\\/audit_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/audit:actions-rs\\/audit-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/audit:actions_rs\\/audit_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/audit:actions-rs\\/audit-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/audit:actions_rs\\/audit_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions:actions-rs\\/audit-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions:actions_rs\\/audit_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/rust.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions-rs/clippy-check@v1?package-id=ec8e600e655abf10",
      "type": "library",
      "name": "actions-rs/clippy-check",
      "version": "v1",
      "cpe": "cpe:2.3:a:actions-rs\\/clippy-check:actions-rs\\/clippy-check:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions-rs/clippy-check@v1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/clippy-check:actions_rs\\/clippy_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/clippy_check:actions-rs\\/clippy-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/clippy_check:actions_rs\\/clippy_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/clippy:actions-rs\\/clippy-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/clippy:actions_rs\\/clippy_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/clippy:actions-rs\\/clippy-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/clippy:actions_rs\\/clippy_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions:actions-rs\\/clippy-check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions:actions_rs\\/clippy_check:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/rust.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions-rs/tarpaulin@v0.1?package-id=2883c46fcf598834",
      "type": "library",
      "name": "actions-rs/tarpaulin",
      "version": "v0.1",
      "cpe": "cpe:2.3:a:actions-rs\\/tarpaulin:actions-rs\\/tarpaulin:v0.1:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions-rs/tarpaulin@v0.1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions-rs\\/tarpaulin:actions_rs\\/tarpaulin:v0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/tarpaulin:actions-rs\\/tarpaulin:v0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions_rs\\/tarpaulin:actions_rs\\/tarpaulin:v0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions:actions-rs\\/tarpaulin:v0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions:actions_rs\\/tarpaulin:v0.1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/rust.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=9eb4338500f07f9e",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=71df196de85d17d1",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/rust.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/create-release@v1?package-id=1213399770034dfa",
      "type": "library",
      "name": "actions/create-release",
      "version": "v1",
      "cpe": "cpe:2.3:a:actions\\/create-release:actions\\/create-release:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/create-release@v1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/create-release:actions\\/create_release:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/create_release:actions\\/create-release:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/create_release:actions\\/create_release:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/create:actions\\/create-release:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/create:actions\\/create_release:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/download-artifact@v4?package-id=0eccb2671b34b053",
      "type": "library",
      "name": "actions/download-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/download-artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/download-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download-artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download_artifact:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/download:actions\\/download_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-artifact@v4?package-id=796c2f5062424580",
      "type": "library",
      "name": "actions/upload-artifact",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-artifact@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_artifact:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_artifact:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-release-asset@v1?package-id=93dad94c3c780cff",
      "type": "library",
      "name": "actions/upload-release-asset",
      "version": "v1",
      "cpe": "cpe:2.3:a:actions\\/upload-release-asset:actions\\/upload-release-asset:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-release-asset@v1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-release-asset:actions\\/upload_release_asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_release_asset:actions\\/upload-release-asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_release_asset:actions\\/upload_release_asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-release:actions\\/upload-release-asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-release:actions\\/upload_release_asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_release:actions\\/upload-release-asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_release:actions\\/upload_release_asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-release-asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_release_asset:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/codecov/codecov-action@v4?package-id=b92717a5be59444a",
      "type": "library",
      "name": "codecov/codecov-action",
      "version": "v4",
      "cpe": "cpe:2.3:a:codecov\\/codecov-action:codecov\\/codecov-action:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/codecov/codecov-action@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:codecov\\/codecov-action:codecov\\/codecov_action:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:codecov\\/codecov_action:codecov\\/codecov-action:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:codecov\\/codecov_action:codecov\\/codecov_action:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:codecov\\/codecov:codecov\\/codecov-action:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:codecov\\/codecov:codecov\\/codecov_action:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/rust.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/houseabsolute/actions-rust-cross@v0?package-id=74f4058b780a963a",
      "type": "library",
      "name": "houseabsolute/actions-rust-cross",
      "version": "v0",
      "cpe": "cpe:2.3:a:houseabsolute\\/actions-rust-cross:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*",
      "purl": "pkg:github/houseabsolute/actions-rust-cross@v0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions-rust-cross:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust_cross:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust_cross:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions-rust:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions-rust:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/houseabsolute/actions-rust-cross@v0?package-id=40d006ea5c3a7ea1",
      "type": "library",
      "name": "houseabsolute/actions-rust-cross",
      "version": "v0",
      "cpe": "cpe:2.3:a:houseabsolute\\/actions-rust-cross:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*",
      "purl": "pkg:github/houseabsolute/actions-rust-cross@v0",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions-rust-cross:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust_cross:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust_cross:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions-rust:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions-rust:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions_rust:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions:houseabsolute\\/actions-rust-cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:houseabsolute\\/actions:houseabsolute\\/actions_rust_cross:v0:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/rust.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/orhun/git-cliff-action@main?package-id=1e7f286bc4893765",
      "type": "library",
      "name": "orhun/git-cliff-action",
      "version": "main",
      "cpe": "cpe:2.3:a:orhun\\/git-cliff-action:orhun\\/git-cliff-action:main:*:*:*:*:*:*:*",
      "purl": "pkg:github/orhun/git-cliff-action@main",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git-cliff-action:orhun\\/git_cliff_action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git_cliff_action:orhun\\/git-cliff-action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git_cliff_action:orhun\\/git_cliff_action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git-cliff:orhun\\/git-cliff-action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git-cliff:orhun\\/git_cliff_action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git_cliff:orhun\\/git-cliff-action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git_cliff:orhun\\/git_cliff_action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git:orhun\\/git-cliff-action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:orhun\\/git:orhun\\/git_cliff_action:main:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/release.yml"
        }
      ]
    },
    {
      "bom-ref": "cc210d8a1a5f5704",
      "type": "file",
      "name": "/home/releaser-0.14.0/.github/workflows/release.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "0ee340ec40f3405bb68dbcdb971d55ce36092696"
        },
        {
          "alg": "SHA-256",
          "content": "16559f3aa83809996aab5bc9176e4682eadfbe7369bc9e2b808883cd281ec7f5"
        }
      ]
    },
    {
      "bom-ref": "5218e54acecbaea1",
      "type": "file",
      "name": "/home/releaser-0.14.0/.github/workflows/rust.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "fe0d68f9b3995c1d9ecbf7daf4cf243902c0eec9"
        },
        {
          "alg": "SHA-256",
          "content": "dbdeb0b757e6dbaeb5282f3af2974aa453e0f1ec1e4032137d626cb863a22b36"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/releaser-0.11.1",
      "New file": [],
      "Deleted file": [],
      "Modified file": [
        {
          "file": "/home/releaser-0.14.0/src/brew.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/brew.rs",
            "+++ /home/releaser-0.14.0/src/brew.rs",
            "@@ -1,28 +1,34 @@",
            " use std::option::Option::Some;",
            " ",
            " use handlebars::Handlebars;",
            " use serde::Serialize;",
            " use vfs::VfsPath;",
            " ",
            "-use crate::packaging::Package;",
            " use crate::CrateConfig;",
            "+use crate::packaging::Package;",
            " use crate::{new_cargo_config_path, packaging};",
            " use color_eyre::eyre::Result;",
            " ",
            " #[derive(Serialize, Default)]",
            " pub struct Brew {",
            "     pub formula: String,",
            "     pub name: String,",
            "     pub description: String,",
            "     pub homepage: Option<String>,",
            "     pub version: String,",
            "     pub license: String,",
            "     pub linux: Option<Package>,",
            "-    pub macos: Option<Package>,",
            "+    pub macos: Option<Vec<BrewPackage>>,",
            "+}",
            "+",
            "+#[derive(Serialize, Default, Debug)]",
            "+pub struct BrewPackage {",
            "+    pub package: Package,",
            "+    pub cpu: String,",
            " }",
            " ",
            " const TEMPLATE: &str = r#\"# typed: false",
            " # frozen_string_literal: true",
            " # This file was generated by releaser. DO NOT EDIT.",
            " class {{ formula }} < Formula",
            "   desc \"{{ description }}\"",
            "@@ -30,20 +36,22 @@",
            "   version \"{{ version }}\"",
            "   {{#if license }}",
            "   license \"{{ license }}\"",
            "   {{/if}}",
            "   {{#if macos }}",
            " {{lines 1}}",
            "   on_macos do",
            "-    if Hardware::CPU.intel?",
            "-    {{#with macos}}",
            "+    {{#each macos}}",
            "+    if Hardware::CPU.{{ cpu }}?",
            "+    {{#with package}}",
            "       url \"{{ url }}\"",
            "       sha256 \"{{ hash }}\"",
            "-     {{/with}}",
            "+    {{/with}}",
            "     end",
            "+    {{/each}}",
            "   end",
            "   {{/if}}",
            "   {{#if linux }}",
            " {{lines 1}}",
            "   on_linux do",
            "     if Hardware::CPU.intel?",
            "     {{#with linux}}",
            "@@ -59,47 +67,66 @@",
            "     bin.install Dir[\"*\"]",
            "   end",
            " {{lines 1}}",
            " {{/if}}",
            " end",
            " \"#;",
            " ",
            "-pub fn new_brew(",
            "-    crate_path: &VfsPath,",
            "-    linux_path: &VfsPath,",
            "-    macos_path: &VfsPath,",
            "-    base_uri: &str,",
            "-) -> Result<String> {",
            "-    let crate_conf = new_cargo_config_path(crate_path)?;",
            "-    let config = CrateConfig::open(&crate_conf)?;",
            "-",
            "-    let name = config.package.name;",
            "-",
            "-    let brew = Brew {",
            "-        formula: uppercase_first_letter(&name),",
            "-        name,",
            "-        description: config.package.description.unwrap_or_default(),",
            "-        homepage: config.package.homepage,",
            "-        version: config.package.version,",
            "-        license: config.package.license.unwrap_or_default(),",
            "-        linux: packaging::new_binary_pkg(linux_path, base_uri).ok(),",
            "-        macos: packaging::new_binary_pkg(macos_path, base_uri).ok(),",
            "-    };",
            "+impl Brew {",
            "+    /// Creates Brew struct instance and serializes it into String",
            "+    pub fn serialize(",
            "+        crate_path: &VfsPath,",
            "+        linux_path: &VfsPath,",
            "+        macos_path: &VfsPath,",
            "+        macos_arm_path: &VfsPath,",
            "+        base_uri: &str,",
            "+    ) -> Result<String> {",
            "+        let crate_conf = new_cargo_config_path(crate_path)?;",
            "+        let config = CrateConfig::open(&crate_conf)?;",
            "+",
            "+        let name = config.package.name;",
            "+",
            "+        let mut macos = vec![];",
            "+        if let Ok(p) = packaging::new_binary_pkg(macos_path, base_uri) {",
            "+            macos.push(BrewPackage {",
            "+                package: p,",
            "+                cpu: \"intel\".to_string(),",
            "+            });",
            "+        }",
            "+        if let Ok(p) = packaging::new_binary_pkg(macos_arm_path, base_uri) {",
            "+            macos.push(BrewPackage {",
            "+                package: p,",
            "+                cpu: \"arm\".to_string(),",
            "+            });",
            "+        }",
            "+        let macos = if macos.is_empty() { None } else { Some(macos) };",
            " ",
            "-    if brew.linux.is_none() && brew.macos.is_none() {",
            "-        Ok(String::new())",
            "-    } else {",
            "-        serialize_brew(&brew)",
            "+        let brew = Brew {",
            "+            formula: uppercase_first_letter(&name),",
            "+            name,",
            "+            description: config.package.description.unwrap_or_default(),",
            "+            homepage: config.package.homepage,",
            "+            version: config.package.version,",
            "+            license: config.package.license.unwrap_or_default(),",
            "+            linux: packaging::new_binary_pkg(linux_path, base_uri).ok(),",
            "+            macos,",
            "+        };",
            "+",
            "+        if brew.linux.is_none() && brew.macos.is_none() {",
            "+            Ok(String::new())",
            "+        } else {",
            "+            serialize_brew(&brew)",
            "+        }",
            "     }",
            " }",
            " ",
            " fn uppercase_first_letter(s: &str) -> String {",
            "-    let mut c = s.chars();",
            "-    if let Some(f) = c.next() {",
            "-        f.to_uppercase().chain(c).collect()",
            "+    let mut chars_it = s.chars();",
            "+    if let Some(f) = chars_it.next() {",
            "+        f.to_uppercase().chain(chars_it).collect()",
            "     } else {",
            "         String::new()",
            "     }",
            " }",
            " ",
            " fn serialize_brew<T: Serialize>(data: &T) -> Result<String> {",
            "     handlebars_helper!(lines: |count: i32| {",
            "@@ -184,29 +211,33 @@",
            " end",
            " \"#,",
            "             result",
            "         )",
            "     }",
            " ",
            "     #[test]",
            "-    fn serialize_brew_macos_test() {",
            "+    fn serialize_brew_macos_intel_test() {",
            "         // Arrange",
            "         let macos = Package {",
            "             url: \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_darwin_amd64.tar.gz\".to_string(),",
            "             hash: \"9a6c8144ed77cd5e2b88031109ac4285ca08e8c644f3d022a389359470721a7b\".to_string(),",
            "         };",
            "+        let mac_pkg = BrewPackage {",
            "+            package: macos,",
            "+            cpu: \"intel\".to_string(),",
            "+        };",
            "         let brew = Brew {",
            "             formula: \"Solv\".to_string(),",
            "             name: \"solv\".to_string(),",
            "             description: \"desc\".to_string(),",
            "             homepage: None,",
            "             version: \"v0.4.0\".to_string(),",
            "             license: \"MIT\".to_string(),",
            "             linux: None,",
            "-            macos: Some(macos),",
            "+            macos: Some(vec![mac_pkg]),",
            "         };",
            " ",
            "         // Act",
            "         let result = serialize_brew(&brew).unwrap_or_default();",
            " ",
            "         // Assert",
            "         assert_eq!(",
            "@@ -233,14 +264,80 @@",
            " end",
            " \"#,",
            "             result",
            "         )",
            "     }",
            " ",
            "     #[test]",
            "+",
            "+    fn serialize_brew_macos_all_test() {",
            "+        // Arrange",
            "+        let macos_intel = Package {",
            "+            url: \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_darwin_amd64.tar.gz\".to_string(),",
            "+            hash: \"9a6c8144ed77cd5e2b88031109ac4285ca08e8c644f3d022a389359470721a7b\".to_string(),",
            "+        };",
            "+        let mac_pkg_intel = BrewPackage {",
            "+            package: macos_intel,",
            "+            cpu: \"intel\".to_string(),",
            "+        };",
            "+        let macos_arm = Package {",
            "+            url: \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_darwin_arm64.tar.gz\".to_string(),",
            "+            hash: \"fb5c2f5d41c7d3485898de9905736dc8c540a912dc95d3a55bd9360901689811\".to_string(),",
            "+        };",
            "+        let mac_pkg_arm = BrewPackage {",
            "+            package: macos_arm,",
            "+            cpu: \"arm\".to_string(),",
            "+        };",
            "+        let brew = Brew {",
            "+            formula: \"Solv\".to_string(),",
            "+            name: \"solv\".to_string(),",
            "+            description: \"desc\".to_string(),",
            "+            homepage: None,",
            "+            version: \"v0.4.0\".to_string(),",
            "+            license: \"MIT\".to_string(),",
            "+            linux: None,",
            "+            macos: Some(vec![mac_pkg_intel, mac_pkg_arm]),",
            "+        };",
            "+",
            "+        // Act",
            "+        let result = serialize_brew(&brew).unwrap_or_default();",
            "+",
            "+        // Assert",
            "+        assert_eq!(",
            "+            r#\"# typed: false",
            "+# frozen_string_literal: true",
            "+# This file was generated by releaser. DO NOT EDIT.",
            "+class Solv < Formula",
            "+  desc \"desc\"",
            "+  homepage \"\"",
            "+  version \"v0.4.0\"",
            "+  license \"MIT\"",
            "+",
            "+  on_macos do",
            "+    if Hardware::CPU.intel?",
            "+      url \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_darwin_amd64.tar.gz\"",
            "+      sha256 \"9a6c8144ed77cd5e2b88031109ac4285ca08e8c644f3d022a389359470721a7b\"",
            "+    end",
            "+    if Hardware::CPU.arm?",
            "+      url \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_darwin_arm64.tar.gz\"",
            "+      sha256 \"fb5c2f5d41c7d3485898de9905736dc8c540a912dc95d3a55bd9360901689811\"",
            "+    end",
            "+  end",
            "+",
            "+  def install",
            "+    bin.install Dir[\"*\"]",
            "+  end",
            "+",
            "+end",
            "+\"#,",
            "+            result",
            "+        )",
            "+    }",
            "+",
            "+    #[test]",
            "     fn serialize_brew_linux_test() {",
            "         // Arrange",
            "         let linux = Package {",
            "             url: \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_linux_amd64.tar.gz\".to_string(),",
            "             hash: \"fb5c2f5d41c7d3485898de9905736dc8c540a912dc95d3a55bd9360901689811\".to_string(),",
            "         };",
            "         let brew = Brew {",
            "@@ -292,23 +389,27 @@",
            "             url: \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_darwin_amd64.tar.gz\".to_string(),",
            "             hash: \"9a6c8144ed77cd5e2b88031109ac4285ca08e8c644f3d022a389359470721a7b\".to_string(),",
            "         };",
            "         let linux = Package {",
            "             url: \"https://github.com/aegoroff/solt/releases/download/v1.0.7/solt_1.0.7_linux_amd64.tar.gz\".to_string(),",
            "             hash: \"fb5c2f5d41c7d3485898de9905736dc8c540a912dc95d3a55bd9360901689811\".to_string(),",
            "         };",
            "+        let mac_pkg = BrewPackage {",
            "+            package: macos,",
            "+            cpu: \"intel\".to_string(),",
            "+        };",
            "         let brew = Brew {",
            "             formula: \"Solv\".to_string(),",
            "             name: \"solv\".to_string(),",
            "             description: \"desc\".to_string(),",
            "             homepage: None,",
            "             version: \"v0.4.0\".to_string(),",
            "             license: \"MIT\".to_string(),",
            "             linux: Some(linux),",
            "-            macos: Some(macos),",
            "+            macos: Some(vec![mac_pkg]),",
            "         };",
            " ",
            "         // Act",
            "         let result = serialize_brew(&brew).unwrap_or_default();",
            " ",
            "         // Assert",
            "         assert_eq!(",
            "@@ -346,33 +447,48 @@",
            "     }",
            " ",
            "     #[rstest]",
            "     fn new_brew_all_correct(root: VfsPath) {",
            "         // Arrange",
            "         let linux_path = root.join(\"linux\").unwrap();",
            "         let macos_path = root.join(\"macos\").unwrap();",
            "+        let macos_arm_path = root.join(\"macos_arm\").unwrap();",
            " ",
            "         // Act",
            "-        let result = new_brew(&root, &linux_path, &macos_path, \"http://localhost\");",
            "+        let result = Brew::serialize(",
            "+            &root,",
            "+            &linux_path,",
            "+            &macos_path,",
            "+            &macos_arm_path,",
            "+            \"http://localhost\",",
            "+        );",
            " ",
            "         // Assert",
            "         assert!(result.is_ok());",
            "         let r = result.unwrap();",
            "         assert!(r.contains(\"http://localhost/linux-solv.tar.gz\"));",
            "         assert!(r.contains(\"http://localhost/macos-solv.tar.gz\"));",
            "+        assert!(r.contains(\"http://localhost/macos-solv-arm.tar.gz\"));",
            "     }",
            " ",
            "     #[rstest]",
            "     fn new_brew_no_binaries(root: VfsPath) {",
            "         // Arrange",
            "         let linux_path = root.join(\"linux1\").unwrap();",
            "         let macos_path = root.join(\"macos1\").unwrap();",
            "+        let macos_arm_path = root.join(\"macos_arm_1\").unwrap();",
            " ",
            "         // Act",
            "-        let result = new_brew(&root, &linux_path, &macos_path, \"http://localhost\");",
            "+        let result = Brew::serialize(",
            "+            &root,",
            "+            &linux_path,",
            "+            &macos_path,",
            "+            &macos_arm_path,",
            "+            \"http://localhost\",",
            "+        );",
            " ",
            "         // Assert",
            "         assert!(result.is_ok());",
            "         assert!(result.unwrap().is_empty());",
            "     }",
            " ",
            "     #[rstest]",
            "@@ -386,28 +502,36 @@",
            "             .create_file()",
            "             .unwrap()",
            "             .write_all(\"test\".as_bytes())",
            "             .unwrap();",
            " ",
            "         let linux_path = root.join(\"linux\").unwrap();",
            "         let macos_path = root.join(\"macos\").unwrap();",
            "+        let macos_arm_path = root.join(\"macos_arm\").unwrap();",
            " ",
            "         // Act",
            "-        let result = new_brew(&root, &linux_path, &macos_path, \"http://localhost\");",
            "+        let result = Brew::serialize(",
            "+            &root,",
            "+            &linux_path,",
            "+            &macos_path,",
            "+            &macos_arm_path,",
            "+            \"http://localhost\",",
            "+        );",
            " ",
            "         // Assert",
            "         assert!(result.is_err());",
            "     }",
            " ",
            "     #[fixture]",
            "     fn root() -> VfsPath {",
            "         let root = VfsPath::new(MemoryFS::new());",
            " ",
            "         root.join(\"linux\").unwrap().create_dir().unwrap();",
            "         root.join(\"macos\").unwrap().create_dir().unwrap();",
            "+        root.join(\"macos_arm\").unwrap().create_dir().unwrap();",
            "         root.join(CARGO_CONFIG)",
            "             .unwrap()",
            "             .create_file()",
            "             .unwrap()",
            "             .write_all(CONFIG.as_bytes())",
            "             .unwrap();",
            " ",
            "@@ -425,14 +549,23 @@",
            "             .join(\"macos-solv.tar.gz\")",
            "             .unwrap()",
            "             .create_file()",
            "             .unwrap()",
            "             .write_all(\"321\".as_bytes())",
            "             .unwrap();",
            " ",
            "+        root.join(\"macos_arm\")",
            "+            .unwrap()",
            "+            .join(\"macos-solv-arm.tar.gz\")",
            "+            .unwrap()",
            "+            .create_file()",
            "+            .unwrap()",
            "+            .write_all(\"4321\".as_bytes())",
            "+            .unwrap();",
            "+",
            "         root",
            "     }",
            " ",
            "     const CONFIG: &str = r#\"",
            " [package]",
            " name = \"solv\"",
            " description = \"Microsoft Visual Studio solution validator\""
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/lib.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/lib.rs",
            "+++ /home/releaser-0.14.0/src/lib.rs",
            "@@ -10,32 +10,28 @@",
            " use clap::ValueEnum;",
            " #[cfg(test)]",
            " use mockall::{automock, predicate::str};",
            " use semver::{BuildMetadata, Prerelease, Version};",
            " use serde::Deserialize;",
            " ",
            " use color_eyre::eyre::Result;",
            "-use toml_edit::{value, Document};",
            "+use toml_edit::{DocumentMut, value};",
            " use vfs::VfsPath;",
            " ",
            " pub mod brew;",
            " pub mod cargo;",
            " pub mod git;",
            " pub mod hash;",
            " mod packaging;",
            " mod resource;",
            " pub mod scoop;",
            " mod version_iter;",
            " pub mod workflow;",
            " ",
            " #[cfg(test)] // <-- not needed in integration tests",
            "-#[macro_use]",
            "-extern crate mockall;",
            "-",
            "-#[cfg(test)] // <-- not needed in integration tests",
            " extern crate rstest;",
            " ",
            " const CARGO_CONFIG: &str = \"Cargo.toml\";",
            " const VERSION: &str = \"version\";",
            " const PACK: &str = \"package\";",
            " const DEPS: &str = \"dependencies\";",
            " ",
            "@@ -54,14 +50,29 @@",
            " #[cfg_attr(test, automock)]",
            " pub trait Vcs {",
            "     fn commit(&self, path: &str, message: &str) -> Result<()>;",
            "     fn create_tag(&self, path: &str, tag: &str) -> Result<()>;",
            "     fn push_tag(&self, path: &str, tag: &str) -> Result<()>;",
            " }",
            " ",
            "+/// Updates the configurations by aggregating the maximum version from an iterator of crate versions.",
            "+///",
            "+/// This function takes a `VfsPath` and an iterator over crate versions as input, and returns the maximum version found.",
            "+///",
            "+/// The `update_config` function is used to update each configuration in the iterator. The resulting versions are aggregated using the `max` method of the `Ord` trait.",
            "+///",
            "+/// # Arguments",
            "+///",
            "+/// * `path`: A `VfsPath` representing the path to the configurations.",
            "+/// * `iter`: An iterator over crate versions.",
            "+/// * `incr`: An increment value for versioning (currently unused).",
            "+///",
            "+/// # Returns",
            "+///",
            "+/// The maximum version found among the aggregated configurations.",
            " pub fn update_configs<I>(path: &VfsPath, iter: &mut I, incr: Increment) -> Result<Version>",
            " where",
            "     I: Iterator<Item = CrateVersion>,",
            " {",
            "     let result = Version::parse(\"0.0.0\")?;",
            " ",
            "     let result = iter",
            "@@ -69,14 +80,38 @@",
            "         .map(|config| update_config(path, &config, incr))",
            "         .filter_map(std::result::Result::ok)",
            "         .fold(result, std::cmp::Ord::max);",
            " ",
            "     Ok(result)",
            " }",
            " ",
            "+/// Updates the version configuration in the given `VfsPath` based on the provided `CrateVersion` and Increment.",
            "+///",
            "+/// # Arguments",
            "+///",
            "+/// * `path` - The root path where the configuration file is located.",
            "+/// * `version` - The `CrateVersion` instance which contains the path and places where the version needs to be updated.",
            "+/// * `incr` - The Increment enum value indicating the type of version increment (Major, Minor, Patch).",
            "+///",
            "+/// # Returns",
            "+///",
            "+/// * `Result<Version>` - The updated version after applying the increment.",
            "+///",
            "+/// # Errors",
            "+///",
            "+/// This function will return an error if:",
            "+/// * The path provided is invalid or cannot be accessed.",
            "+/// * The configuration file cannot be opened or read.",
            "+/// * The content of the configuration file cannot be parsed.",
            "+/// * The new version cannot be written back to the configuration file.",
            "+///",
            "+/// # Note",
            "+///",
            "+/// If the `version.path` is empty, the function will use the provided `path` as the working configuration path.",
            "+/// Otherwise, it will construct the path using the `version.path` and `CARGO_CONFIG`.",
            " pub fn update_config(path: &VfsPath, version: &CrateVersion, incr: Increment) -> Result<Version> {",
            "     let working_config_path: &VfsPath;",
            "     let member_config_path: VfsPath;",
            "     if version.path.is_empty() {",
            "         working_config_path = path;",
            "     } else {",
            "         let parent = path.parent();",
            "@@ -84,15 +119,15 @@",
            "         working_config_path = &member_config_path;",
            "     }",
            " ",
            "     let mut file = working_config_path.open_file()?;",
            "     let mut content = String::new();",
            "     file.read_to_string(&mut content)?;",
            " ",
            "-    let mut doc = content.parse::<Document>()?;",
            "+    let mut doc = content.parse::<DocumentMut>()?;",
            " ",
            "     let mut result = Version::parse(\"0.0.0\")?;",
            " ",
            "     for place in &version.places {",
            "         match place {",
            "             Place::Package(ver) => {",
            "                 let v = increment(ver, incr)?;",
            "@@ -123,27 +158,84 @@",
            "     Ok(v)",
            " }",
            " ",
            " fn new_cargo_config_path(root: &VfsPath) -> Result<VfsPath> {",
            "     Ok(root.join(CARGO_CONFIG)?)",
            " }",
            " ",
            "+/// Increments the patch version of the given `Version` instance.",
            "+///",
            "+/// This function increments the patch version component of the provided",
            "+/// `Version` instance by 1. Additionally, it resets the pre-release and",
            "+/// build metadata components to empty values.",
            "+///",
            "+/// # Arguments",
            "+///",
            "+/// * `v` - A mutable reference to a `Version` instance that will be modified.",
            "+///",
            "+/// # Note",
            "+///",
            "+/// This function assumes that the `Version` instance passed in is valid and",
            "+/// properly initialized. It does not perform any validation on the input.",
            "+///",
            "+/// # See Also",
            "+///",
            "+/// * `increment_minor` - For incrementing the minor version component.",
            "+/// * `increment_major` - For incrementing the major version component.",
            " fn increment_patch(v: &mut Version) {",
            "     v.patch += 1;",
            "     v.pre = Prerelease::EMPTY;",
            "     v.build = BuildMetadata::EMPTY;",
            " }",
            " ",
            "+/// Increments the minor version of the given `Version` instance.",
            "+///",
            "+/// This function increments the minor version component of the provided",
            "+/// `Version` instance by 1. Additionally, it resets the patch, pre-release,",
            "+/// and build metadata components to empty values.",
            "+///",
            "+/// # Arguments",
            "+///",
            "+/// * `v` - A mutable reference to a `Version` instance that will be modified.",
            "+///",
            "+/// # Note",
            "+///",
            "+/// This function assumes that the `Version` instance passed in is valid and",
            "+/// properly initialized. It does not perform any validation on the input.",
            "+///",
            "+/// # See Also",
            "+///",
            "+/// * `increment_patch` - For incrementing the patch version component.",
            "+/// * `increment_major` - For incrementing the major version component.",
            " fn increment_minor(v: &mut Version) {",
            "     v.minor += 1;",
            "     v.patch = 0;",
            "     v.pre = Prerelease::EMPTY;",
            "     v.build = BuildMetadata::EMPTY;",
            " }",
            " ",
            "+/// Increments the major version of the given `Version` instance.",
            "+///",
            "+/// This function increments the major version component of the provided",
            "+/// `Version` instance by 1. Additionally, it resets the minor, patch,",
            "+/// pre-release, and build metadata components to empty values.",
            "+///",
            "+/// # Arguments",
            "+///",
            "+/// * `v` - A mutable reference to a `Version` instance that will be modified.",
            "+///",
            "+/// # Note",
            "+///",
            "+/// This function assumes that the `Version` instance passed in is valid and",
            "+/// properly initialized. It does not perform any validation on the input.",
            "+///",
            "+/// # See Also",
            "+///",
            "+/// * `increment_minor` - For incrementing the minor version component.",
            "+/// * `increment_patch` - For incrementing the patch version component.",
            " fn increment_major(v: &mut Version) {",
            "     v.major += 1;",
            "     v.minor = 0;",
            "     v.patch = 0;",
            "     v.pre = Prerelease::EMPTY;",
            "     v.build = BuildMetadata::EMPTY;",
            " }",
            "@@ -189,16 +281,18 @@",
            "     homepage: Option<String>,",
            " }",
            " ",
            " #[derive(Deserialize, Debug)]",
            " #[serde(untagged)]",
            " enum Dependency {",
            "     Plain(String),",
            "+    #[allow(dead_code)]",
            "     Optional(bool),",
            "     Object(HashMap<String, Dependency>),",
            "+    #[allow(dead_code)]",
            "     List(Vec<Dependency>),",
            " }",
            " ",
            " #[derive(Debug, Default)]",
            " pub struct CrateVersion {",
            "     path: String,",
            "     places: Vec<Place>,"
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/main.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/main.rs",
            "+++ /home/releaser-0.14.0/src/main.rs",
            "@@ -1,38 +1,53 @@",
            " #[macro_use]",
            " extern crate clap;",
            " ",
            "-use clap::{command, ArgAction, ArgMatches, Command};",
            "-use clap_complete::{generate, Shell};",
            "-use color_eyre::eyre::{eyre, Result};",
            "+use bugreport::{",
            "+    bugreport,",
            "+    collector::{CompileTimeInformation, EnvironmentVariables, OperatingSystem, SoftwareVersion},",
            "+    format::Markdown,",
            "+};",
            "+",
            "+use clap::{Arg, ArgAction, ArgMatches, Command, command};",
            "+use clap_complete::{Shell, generate};",
            "+use color_eyre::eyre::{Result, eyre};",
            " use std::io;",
            " use std::option::Option::Some;",
            " use std::path::PathBuf;",
            " use vfs::{PhysicalFS, VfsPath};",
            " ",
            "+use releaser::Increment;",
            " use releaser::brew;",
            " use releaser::cargo::Cargo;",
            " use releaser::git::Git;",
            " use releaser::scoop;",
            " use releaser::workflow::{Crate, Release, VPath, Workspace};",
            "-use releaser::Increment;",
            " ",
            " const PATH: &str = \"PATH\";",
            "+const FILE: &str = \"FILE\";",
            "+const URI: &str = \"URI\";",
            "+const NUMBER: &str = \"NUMBER\";",
            " const INCR: &str = \"INCR\";",
            " const INCR_HELP: &str = \"Version increment. One of the following: major, minor or patch\";",
            " const ALL: &str = \"all\";",
            " const NO_VERIFY: &str = \"noverify\";",
            " const ALL_HELP: &str = \"Whether to add option --all-features to cargo publish command\";",
            " const NO_VERIFY_HELP: &str = \"Whether to add option --no-verify to cargo publish command\";",
            " const OUTPUT: &str = \"output\";",
            " const OUTPUT_HELP: &str =",
            "     \"File path to save result to. If not set result will be written into stdout\";",
            " const BASE: &str = \"base\";",
            " const CRATE: &str = \"crate\";",
            " const BASE_HELP: &str = \"Base URI of downloaded artifacts\";",
            "+const EXE: &str = \"exe\";",
            "+const BINARY: &str = \"binary\";",
            "+const DELAY: &str = \"delay\";",
            "+const LINUX: &str = \"linux\";",
            "+const MACOS: &str = \"macos\";",
            "+const MACOSARM: &str = \"macosarm\";",
            " ",
            " fn main() -> Result<()> {",
            "     color_eyre::install()?;",
            "     let app = build_cli();",
            "     let matches = app.get_matches();",
            " ",
            "     match matches.subcommand() {",
            "@@ -40,67 +55,88 @@",
            "         Some((\"c\", cmd)) => single_crate(cmd),",
            "         Some((\"b\", cmd)) => brew(cmd),",
            "         Some((\"s\", cmd)) => scoop(cmd),",
            "         Some((\"completion\", cmd)) => {",
            "             print_completions(cmd);",
            "             Ok(())",
            "         }",
            "+        Some((\"bugreport\", cmd)) => {",
            "+            print_bugreport(cmd);",
            "+            Ok(())",
            "+        }",
            "         _ => Ok(()),",
            "     }",
            " }",
            " ",
            " fn print_completions(matches: &ArgMatches) {",
            "     let mut cmd = build_cli();",
            "     let bin_name = cmd.get_name().to_string();",
            "     if let Some(generator) = matches.get_one::<Shell>(\"generator\") {",
            "         generate(*generator, &mut cmd, bin_name, &mut io::stdout());",
            "     }",
            " }",
            " ",
            "+fn print_bugreport(_matches: &ArgMatches) {",
            "+    bugreport!()",
            "+        .info(SoftwareVersion::default())",
            "+        .info(OperatingSystem::default())",
            "+        .info(EnvironmentVariables::list(&[\"SHELL\", \"TERM\"]))",
            "+        .info(CompileTimeInformation::default())",
            "+        .print::<Markdown>();",
            "+}",
            "+",
            " fn workspace(cmd: &ArgMatches) -> Result<()> {",
            "-    let delay_seconds = cmd.get_one::<u64>(\"delay\").unwrap_or(&20);",
            "+    let delay_seconds = cmd.get_one::<u64>(DELAY).unwrap_or(&20);",
            "     let r = Workspace::new(*delay_seconds, Cargo, Git);",
            "     release(cmd, &r)",
            " }",
            " ",
            " fn single_crate(cmd: &ArgMatches) -> Result<()> {",
            "     let r = Crate::new(Cargo, Git);",
            "     release(cmd, &r)",
            " }",
            " ",
            " fn brew(cmd: &ArgMatches) -> Result<()> {",
            "     let empty = String::default();",
            "-    let linux_path = cmd.get_one::<String>(\"linux\").unwrap_or(&empty);",
            "-    let macos_path = cmd.get_one::<String>(\"macos\").unwrap_or(&empty);",
            "+    let linux_path = cmd.get_one::<String>(LINUX).unwrap_or(&empty);",
            "+    let macos_path = cmd.get_one::<String>(MACOS).unwrap_or(&empty);",
            "+    let macos_arm_path = cmd.get_one::<String>(MACOSARM).unwrap_or(&empty);",
            " ",
            "     if linux_path.is_empty() && macos_path.is_empty() {",
            "         return Ok(());",
            "     }",
            " ",
            "     let crate_path = cmd.get_one::<String>(CRATE).unwrap_or(&empty);",
            "     let base_uri = cmd.get_one::<String>(BASE).unwrap_or(&empty);",
            " ",
            "     let crate_path: VfsPath = PhysicalFS::new(PathBuf::from(crate_path)).into();",
            "     let linux_path: VfsPath = PhysicalFS::new(PathBuf::from(linux_path)).into();",
            "     let macos_path: VfsPath = PhysicalFS::new(PathBuf::from(macos_path)).into();",
            "-    let b = brew::new_brew(&crate_path, &linux_path, &macos_path, base_uri)?;",
            "+    let macos_arm_path: VfsPath = PhysicalFS::new(PathBuf::from(macos_arm_path)).into();",
            "+    let b = brew::Brew::serialize(",
            "+        &crate_path,",
            "+        &linux_path,",
            "+        &macos_path,",
            "+        &macos_arm_path,",
            "+        base_uri,",
            "+    )?;",
            "     output_string(cmd, b)",
            " }",
            " ",
            " fn scoop(cmd: &ArgMatches) -> Result<()> {",
            "     let empty = String::default();",
            "-    let exe_name = cmd.get_one::<String>(\"exe\").unwrap_or(&empty);",
            "-    let binary_path = cmd.get_one::<String>(\"binary\").unwrap_or(&empty);",
            "+    let exe_name = cmd.get_one::<String>(EXE).unwrap_or(&empty);",
            "+    let binary_path = cmd.get_one::<String>(BINARY).unwrap_or(&empty);",
            "     let crate_path = cmd.get_one::<String>(CRATE).unwrap_or(&empty);",
            "     let base_uri = cmd.get_one::<String>(BASE).unwrap_or(&empty);",
            " ",
            "     let crate_path: VfsPath = PhysicalFS::new(PathBuf::from(crate_path)).into();",
            "     let binary_path: VfsPath = PhysicalFS::new(PathBuf::from(binary_path)).into();",
            " ",
            "-    let scoop = scoop::new_scoop(&crate_path, &binary_path, exe_name, base_uri)?;",
            "+    let scoop = scoop::Scoop::serialize(&crate_path, &binary_path, exe_name, base_uri)?;",
            "     output_string(cmd, scoop)",
            " }",
            " ",
            " /// Helper function that outputs string specified into",
            " /// console or file that set by command line option",
            " fn output_string(cmd: &ArgMatches, s: String) -> Result<()> {",
            "     if s.is_empty() {",
            "@@ -143,150 +179,177 @@",
            "         .author(crate_authors!(\"\\n\"))",
            "         .about(crate_description!())",
            "         .subcommand(workspace_cmd())",
            "         .subcommand(crate_cmd())",
            "         .subcommand(brew_cmd())",
            "         .subcommand(scoop_cmd())",
            "         .subcommand(completion_cmd())",
            "+        .subcommand(bugreport_cmd())",
            " }",
            " ",
            " fn workspace_cmd() -> Command {",
            "     Command::new(\"w\")",
            "         .aliases([\"workspace\"])",
            "         .about(\"Release workspace specified by path\")",
            "+        .arg(increment_arg())",
            "         .arg(",
            "-            arg!([INCR])",
            "-                .value_parser(value_parser!(Increment))",
            "-                .help(INCR_HELP)",
            "-                .required(true)",
            "-                .index(1),",
            "-        )",
            "-        .arg(",
            "-            arg!([PATH])",
            "+            Arg::new(PATH)",
            "                 .help(\"Sets workspace root path\")",
            "                 .required(true)",
            "                 .index(2),",
            "         )",
            "         .arg(",
            "-            arg!(-d --delay <NUMBER>)",
            "+            Arg::new(DELAY)",
            "+                .long(DELAY)",
            "+                .short('d')",
            "+                .value_name(NUMBER)",
            "                 .required(false)",
            "                 .value_parser(value_parser!(u64))",
            "                 .default_value(\"20\")",
            "                 .help(\"Delay in seconds between publish next workflow's crate\"),",
            "         )",
            "-        .arg(",
            "-            arg!(-a --all)",
            "-                .required(false)",
            "-                .action(ArgAction::SetTrue)",
            "-                .help(ALL_HELP),",
            "-        )",
            "-        .arg(",
            "-            arg!(-n --noverify)",
            "-                .required(false)",
            "-                .action(ArgAction::SetTrue)",
            "-                .help(NO_VERIFY_HELP),",
            "-        )",
            "+        .arg(all_arg())",
            "+        .arg(noverify_arg())",
            " }",
            " ",
            " fn crate_cmd() -> Command {",
            "     Command::new(\"c\")",
            "         .aliases([\"crate\"])",
            "         .about(\"Release single crate specified by path\")",
            "+        .arg(increment_arg())",
            "         .arg(",
            "-            arg!([INCR])",
            "-                .value_parser(value_parser!(Increment))",
            "-                .help(INCR_HELP)",
            "-                .required(true)",
            "-                .index(1),",
            "-        )",
            "-        .arg(",
            "-            arg!([PATH])",
            "+            Arg::new(PATH)",
            "                 .help(\"Sets crate's root path\")",
            "                 .required(true)",
            "                 .index(2),",
            "         )",
            "-        .arg(",
            "-            arg!(-a --all)",
            "-                .required(false)",
            "-                .action(ArgAction::SetTrue)",
            "-                .help(ALL_HELP),",
            "-        )",
            "-        .arg(",
            "-            arg!(-n --noverify)",
            "-                .required(false)",
            "-                .action(ArgAction::SetTrue)",
            "-                .help(NO_VERIFY_HELP),",
            "-        )",
            "+        .arg(all_arg())",
            "+        .arg(noverify_arg())",
            " }",
            " ",
            " fn brew_cmd() -> Command {",
            "     Command::new(\"b\")",
            "         .aliases([\"brew\"])",
            "         .about(\"Create brew package manager Formula (package definition file) to publish it into a tap (MacOS and Linux only)\")",
            "+        .arg(crate_arg())",
            "         .arg(",
            "-            arg!(-c --crate <PATH>)",
            "-                .required(true)",
            "-                .help(\"Sets crate's path where Cargo.toml located\"),",
            "-        )",
            "-        .arg(",
            "-            arg!(-l --linux <PATH>)",
            "+            Arg::new(LINUX)",
            "+                .long(LINUX)",
            "+                .short('l')",
            "+                .value_name(PATH)",
            "                 .required(false)",
            "                 .help(\"Sets Linux package directory path\"),",
            "         )",
            "         .arg(",
            "-            arg!(-m --macos <PATH>)",
            "+            Arg::new(MACOS)",
            "+                .long(MACOS)",
            "+                .short('m')",
            "+                .value_name(PATH)",
            "                 .required(false)",
            "-                .help(\"Sets Mac OS package directory path\"),",
            "+                .help(\"Sets Mac OS x64-86 package directory path\"),",
            "         )",
            "         .arg(",
            "-            arg!(-b --base <URI>)",
            "-                .required(true)",
            "-                .help(BASE_HELP),",
            "-        )",
            "-        .arg(",
            "-            arg!(-u --output [PATH])",
            "+            Arg::new(MACOSARM)",
            "+                .long(MACOSARM)",
            "+                .short('a')",
            "+                .value_name(PATH)",
            "                 .required(false)",
            "-                .help(OUTPUT_HELP),",
            "+                .help(\"Sets Mac OS ARM64 package directory path\"),",
            "         )",
            "+        .arg(base_arg())",
            "+        .arg(output_arg())",
            " }",
            " ",
            " fn scoop_cmd() -> Command {",
            "     Command::new(\"s\")",
            "         .aliases([\"scoop\"])",
            "         .about(\"Create scoop package manager JSON (package definition file) to publish it into bucket (Windows only)\")",
            "+        .arg(crate_arg())",
            "         .arg(",
            "-            arg!(-c --crate <PATH>)",
            "-                .required(true)",
            "-                .help(\"Sets crate's path where Cargo.toml located\"),",
            "-        )",
            "-        .arg(",
            "-            arg!(-i --binary <PATH>)",
            "+            Arg::new(BINARY)",
            "+                .long(BINARY)",
            "+                .short('i')",
            "+                .value_name(PATH)",
            "                 .required(true)",
            "                 .help(\"Sets 64-bit binary package directory path\"),",
            "         )",
            "         .arg(",
            "-            arg!(-e --exe <FILE>)",
            "+            Arg::new(EXE)",
            "+                .long(EXE)",
            "+                .short('e')",
            "+                .value_name(FILE)",
            "                 .required(true)",
            "                 .help(\"Sets Windows executable name\"),",
            "         )",
            "-        .arg(",
            "-            arg!(-b --base <URI>)",
            "-                .required(true)",
            "-                .help(BASE_HELP),",
            "-        )",
            "-        .arg(",
            "-            arg!(-u --output [PATH])",
            "-                .required(false)",
            "-                .help(OUTPUT_HELP),",
            "-        )",
            "+        .arg(base_arg())",
            "+        .arg(output_arg())",
            " }",
            " ",
            " fn completion_cmd() -> Command {",
            "     Command::new(\"completion\")",
            "         .about(\"Generate the autocompletion script for the specified shell\")",
            "         .arg(",
            "             arg!([generator])",
            "                 .value_parser(value_parser!(Shell))",
            "                 .required(true)",
            "                 .index(1),",
            "         )",
            " }",
            "+",
            "+fn bugreport_cmd() -> Command {",
            "+    Command::new(\"bugreport\")",
            "+        .about(\"Collect information about the system and the environment that users can send along with a bug report\")",
            "+}",
            "+",
            "+fn increment_arg() -> Arg {",
            "+    Arg::new(INCR)",
            "+        .value_parser(value_parser!(Increment))",
            "+        .help(INCR_HELP)",
            "+        .required(true)",
            "+        .index(1)",
            "+}",
            "+",
            "+fn base_arg() -> Arg {",
            "+    Arg::new(BASE)",
            "+        .long(BASE)",
            "+        .short('b')",
            "+        .value_name(URI)",
            "+        .required(true)",
            "+        .help(BASE_HELP)",
            "+}",
            "+",
            "+fn output_arg() -> Arg {",
            "+    Arg::new(OUTPUT)",
            "+        .long(OUTPUT)",
            "+        .short('u')",
            "+        .num_args(0..=1)",
            "+        .value_name(PATH)",
            "+        .required(false)",
            "+        .help(OUTPUT_HELP)",
            "+}",
            "+",
            "+fn crate_arg() -> Arg {",
            "+    Arg::new(CRATE)",
            "+        .long(CRATE)",
            "+        .short('c')",
            "+        .value_name(PATH)",
            "+        .required(true)",
            "+        .help(\"Sets crate's path where Cargo.toml located\")",
            "+}",
            "+",
            "+fn noverify_arg() -> Arg {",
            "+    Arg::new(NO_VERIFY)",
            "+        .long(NO_VERIFY)",
            "+        .short('n')",
            "+        .required(false)",
            "+        .action(ArgAction::SetTrue)",
            "+        .help(NO_VERIFY_HELP)",
            "+}",
            "+",
            "+fn all_arg() -> Arg {",
            "+    Arg::new(ALL)",
            "+        .long(ALL)",
            "+        .short('a')",
            "+        .required(false)",
            "+        .action(ArgAction::SetTrue)",
            "+        .help(ALL_HELP)",
            "+}"
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/packaging.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/packaging.rs",
            "+++ /home/releaser-0.14.0/src/packaging.rs",
            "@@ -1,10 +1,10 @@",
            " use crate::hash;",
            " use crate::resource::Resource;",
            "-use color_eyre::eyre::{eyre, Result};",
            "+use color_eyre::eyre::{OptionExt, Result};",
            " use serde::Serialize;",
            " use vfs::VfsPath;",
            " ",
            " const PKG_EXTENSION: &str = \"gz\";",
            " ",
            " #[derive(Serialize, Default, Debug)]",
            " pub struct Package {",
            "@@ -20,28 +20,20 @@",
            "         url: resource.to_string(),",
            "         hash,",
            "     })",
            " }",
            " ",
            " fn calculate_sha256(path: &VfsPath) -> Result<(String, String)> {",
            "     let mut it = path.read_dir()?;",
            "-    let file_name = it.find(|x| {",
            "-        if let Some(ext) = x.extension() {",
            "-            ext.eq(PKG_EXTENSION)",
            "-        } else {",
            "-            false",
            "-        }",
            "-    });",
            "-",
            "-    if let Some(file_name) = file_name {",
            "-        let hash = hash::calculate_sha256(&file_name)?;",
            "-        Ok((hash, file_name.filename()))",
            "-    } else {",
            "-        Err(eyre!(\"No file with extension {PKG_EXTENSION} found\"))",
            "-    }",
            "+    let file_name = it.find(|x| x.extension().is_some_and(|ext| ext.eq(PKG_EXTENSION)));",
            "+    let file_name =",
            "+        file_name.ok_or_eyre(format!(\"No file with extension {PKG_EXTENSION} found\"))?;",
            "+",
            "+    let hash = hash::calculate_sha256(&file_name)?;",
            "+    Ok((hash, file_name.filename()))",
            " }",
            " ",
            " #[cfg(test)]",
            " mod tests {",
            "     #![allow(clippy::unwrap_in_result)]",
            "     #![allow(clippy::unwrap_used)]",
            "     use super::*;"
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/resource.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/resource.rs",
            "+++ /home/releaser-0.14.0/src/resource.rs",
            "@@ -23,19 +23,20 @@",
            "                 .fold(String::new(), |mut s, x| {",
            "                     s.push_str(x);",
            "                     s.push(SEP);",
            "                     s",
            "                 });",
            " ",
            "             // If original ends with spearator char use as is or trim last (separator) char otherwise",
            "-            if path.chars().next_back().unwrap_or_default() == SEP {",
            "-                self.url.set_path(&p);",
            "+            let path_to_set = if path.chars().next_back().unwrap_or_default() == SEP {",
            "+                &p",
            "             } else {",
            "-                self.url.set_path(&p[..p.len() - 1]);",
            "-            }",
            "+                &p[..p.len() - 1]",
            "+            };",
            "+            self.url.set_path(path_to_set);",
            "         } else {",
            "             let r = self.url.join(path);",
            "             if let Ok(u) = r {",
            "                 self.url = u;",
            "             }",
            "         }",
            "         self",
            "@@ -94,16 +95,24 @@",
            "     #[case(\"http://localhost/x\", \"y\", \"http://localhost/x/y\")]",
            "     #[case(\"http://localhost/x\", \"y/\", \"http://localhost/x/y/\")]",
            "     #[case(\"http://localhost/x\", \"/y/\", \"http://localhost/x/y/\")]",
            "     #[case(\"http://localhost/x/\", \"y\", \"http://localhost/x/y\")]",
            "     #[case(\"http://localhost/x/\", \"/y\", \"http://localhost/x/y\")]",
            "     #[case(\"http://localhost/x/\", \"y/\", \"http://localhost/x/y/\")]",
            "     #[case(\"http://localhost/x/\", \"/y/\", \"http://localhost/x/y/\")]",
            "-    #[case::real_slashed_base(\"https://github.com/aegoroff/dirstat/releases/download/v1.0.7/\", \"dirstat_1.0.7_darwin_amd64.tar.gz\", \"https://github.com/aegoroff/dirstat/releases/download/v1.0.7/dirstat_1.0.7_darwin_amd64.tar.gz\")]",
            "-    #[case::real_slashless_base(\"https://github.com/aegoroff/dirstat/releases/download/v1.0.7\", \"dirstat_1.0.7_darwin_amd64.tar.gz\", \"https://github.com/aegoroff/dirstat/releases/download/v1.0.7/dirstat_1.0.7_darwin_amd64.tar.gz\")]",
            "+    #[case::real_slashed_base(",
            "+        \"https://github.com/aegoroff/dirstat/releases/download/v1.0.7/\",",
            "+        \"dirstat_1.0.7_darwin_amd64.tar.gz\",",
            "+        \"https://github.com/aegoroff/dirstat/releases/download/v1.0.7/dirstat_1.0.7_darwin_amd64.tar.gz\"",
            "+    )]",
            "+    #[case::real_slashless_base(",
            "+        \"https://github.com/aegoroff/dirstat/releases/download/v1.0.7\",",
            "+        \"dirstat_1.0.7_darwin_amd64.tar.gz\",",
            "+        \"https://github.com/aegoroff/dirstat/releases/download/v1.0.7/dirstat_1.0.7_darwin_amd64.tar.gz\"",
            "+    )]",
            "     #[case(\"http://localhost\", \"http://:/\", \"http://localhost/http:/:/\")]",
            "     #[trace]",
            "     fn append_path_tests(#[case] base: &str, #[case] path: &str, #[case] expected: &str) {",
            "         // Arrange",
            "         let mut r = Resource::new(base).unwrap();",
            " ",
            "         // Act"
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/scoop.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/scoop.rs",
            "+++ /home/releaser-0.14.0/src/scoop.rs",
            "@@ -1,8 +1,8 @@",
            "-use crate::{new_cargo_config_path, packaging, CrateConfig};",
            "+use crate::{CrateConfig, new_cargo_config_path, packaging};",
            " use color_eyre::eyre::Result;",
            " use serde::Serialize;",
            " use vfs::VfsPath;",
            " ",
            " #[derive(Serialize, Default)]",
            " pub struct Scoop {",
            "     pub description: String,",
            "@@ -22,37 +22,40 @@",
            " #[derive(Serialize, Default)]",
            " pub struct Binary {",
            "     pub url: String,",
            "     pub hash: Option<String>,",
            "     pub bin: Vec<String>,",
            " }",
            " ",
            "-pub fn new_scoop(",
            "-    crate_path: &VfsPath,",
            "-    binary_path: &VfsPath,",
            "-    executable_name: &str,",
            "-    base_uri: &str,",
            "-) -> Result<String> {",
            "-    let crate_conf = new_cargo_config_path(crate_path)?;",
            "-    let config = CrateConfig::open(&crate_conf)?;",
            "-    let binary = packaging::new_binary_pkg(binary_path, base_uri)?;",
            "-    let x64pkg = Binary {",
            "-        url: binary.url,",
            "-        hash: Some(binary.hash),",
            "-        bin: vec![executable_name.to_string()],",
            "-    };",
            "-",
            "-    let scoop = Scoop {",
            "-        description: config.package.description.unwrap_or_default(),",
            "-        homepage: config.package.homepage,",
            "-        version: config.package.version,",
            "-        license: config.package.license.unwrap_or_default(),",
            "-        architecture: Architecture { x64: x64pkg },",
            "-    };",
            "-    Ok(serde_json::to_string_pretty(&scoop)?)",
            "+impl Scoop {",
            "+    /// Creates Scoop struct instance and serializes it to String",
            "+    pub fn serialize(",
            "+        crate_path: &VfsPath,",
            "+        binary_path: &VfsPath,",
            "+        executable_name: &str,",
            "+        base_uri: &str,",
            "+    ) -> Result<String> {",
            "+        let crate_conf = new_cargo_config_path(crate_path)?;",
            "+        let config = CrateConfig::open(&crate_conf)?;",
            "+        let binary = packaging::new_binary_pkg(binary_path, base_uri)?;",
            "+        let x64pkg = Binary {",
            "+            url: binary.url,",
            "+            hash: Some(binary.hash),",
            "+            bin: vec![executable_name.to_string()],",
            "+        };",
            "+",
            "+        let scoop = Scoop {",
            "+            description: config.package.description.unwrap_or_default(),",
            "+            homepage: config.package.homepage,",
            "+            version: config.package.version,",
            "+            license: config.package.license.unwrap_or_default(),",
            "+            architecture: Architecture { x64: x64pkg },",
            "+        };",
            "+        Ok(serde_json::to_string_pretty(&scoop)?)",
            "+    }",
            " }",
            " ",
            " #[cfg(test)]",
            " mod tests {",
            "     #![allow(clippy::unwrap_in_result)]",
            "     #![allow(clippy::unwrap_used)]",
            "     use super::*;",
            "@@ -62,15 +65,15 @@",
            " ",
            "     #[rstest]",
            "     fn new_scoop_all_correct(root: VfsPath) {",
            "         // Arrange",
            "         let binary_path = root.join(\"x64\").unwrap();",
            " ",
            "         // Act",
            "-        let result = new_scoop(&root, &binary_path, \"solv.exe\", \"http://localhost\");",
            "+        let result = Scoop::serialize(&root, &binary_path, \"solv.exe\", \"http://localhost\");",
            " ",
            "         // Assert",
            "         assert!(result.is_ok());",
            "         assert_eq!(",
            "             result.unwrap().as_str(),",
            "             r#\"{",
            "   \"description\": \"Microsoft Visual Studio solution parsing library\",",
            "@@ -92,15 +95,15 @@",
            " ",
            "     #[rstest]",
            "     fn new_scoop_binary_path_not_exist(root: VfsPath) {",
            "         // Arrange",
            "         let binary_path = root.join(\"x86\").unwrap();",
            " ",
            "         // Act",
            "-        let result = new_scoop(&root, &binary_path, \"solv.exe\", \"http://localhost\");",
            "+        let result = Scoop::serialize(&root, &binary_path, \"solv.exe\", \"http://localhost\");",
            " ",
            "         // Assert",
            "         assert!(result.is_err());",
            "     }",
            " ",
            "     #[rstest]",
            "     fn new_scoop_invalid_cargo_toml() {",
            "@@ -122,15 +125,15 @@",
            "             .unwrap()",
            "             .create_file()",
            "             .unwrap()",
            "             .write_all(\"123\".as_bytes())",
            "             .unwrap();",
            " ",
            "         // Act",
            "-        let result = new_scoop(&root, &binary_path, \"solv.exe\", \"http://localhost\");",
            "+        let result = Scoop::serialize(&root, &binary_path, \"solv.exe\", \"http://localhost\");",
            " ",
            "         // Assert",
            "         assert!(result.is_err());",
            "     }",
            " ",
            "     #[fixture]",
            "     fn root() -> VfsPath {"
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/version_iter.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/version_iter.rs",
            "+++ /home/releaser-0.14.0/src/version_iter.rs",
            "@@ -1,21 +1,21 @@",
            "-use crate::{CrateConfig, CrateVersion, Dependency, Place, WorkspaceConfig, CARGO_CONFIG, VERSION};",
            "+use crate::{CARGO_CONFIG, CrateConfig, CrateVersion, Dependency, Place, VERSION, WorkspaceConfig};",
            " use color_eyre::eyre::Result;",
            " use petgraph::algo::DfsSpace;",
            " use petgraph::graphmap::DiGraphMap;",
            " use std::collections::HashMap;",
            " use std::io::Read;",
            " use std::ops::Deref;",
            " use vfs::VfsPath;",
            " ",
            " pub struct VersionIter<'a> {",
            "     search: HashMap<String, usize>,",
            "     members: Vec<String>,",
            "     workspace_config_path: &'a VfsPath,",
            "-    graph: DiGraphMap<usize, i32>,",
            "+    graph: DiGraphMap<usize, ()>,",
            " }",
            " ",
            " impl<'a> VersionIter<'a> {",
            "     pub fn open(path: &'a VfsPath) -> Result<Self> {",
            "         let mut wks_file = path.open_file()?;",
            "         let mut wc = String::new();",
            "         wks_file.read_to_string(&mut wc)?;",
            "@@ -56,15 +56,15 @@",
            "                 .collect()",
            "         } else {",
            "             vec![]",
            "         }",
            "     }",
            " }",
            " ",
            "-impl<'a> Iterator for VersionIter<'a> {",
            "+impl Iterator for VersionIter<'_> {",
            "     type Item = CrateVersion;",
            " ",
            "     fn next(&mut self) -> Option<Self::Item> {",
            "         let member = self.members.pop()?;",
            "         let root = self.workspace_config_path.parent();",
            "         let config_path = root.join(&member).ok()?;",
            "         let config_path = config_path.join(CARGO_CONFIG).ok()?;",
            "@@ -90,15 +90,15 @@",
            "         item.places.extend(deps);",
            " ",
            "         let to = self.search.get(&conf.package.name)?;",
            " ",
            "         for place in &item.places {",
            "             if let Place::Dependency(n, _) = place {",
            "                 let from = self.search.get(n)?;",
            "-                self.graph.add_edge(*from, *to, -1);",
            "+                self.graph.add_edge(*from, *to, ());",
            "             }",
            "         }",
            " ",
            "         Some(item)",
            "     }",
            " }",
            " ",
            "@@ -107,15 +107,15 @@",
            "     #![allow(clippy::unwrap_in_result)]",
            "     #![allow(clippy::unwrap_used)]",
            "     use std::path::PathBuf;",
            "     use vfs::{FileSystem, MemoryFS};",
            " ",
            "     use super::*;",
            "     use crate::version_iter::VersionIter;",
            "-    use crate::{update_configs, Increment};",
            "+    use crate::{Increment, update_configs};",
            "     use rstest::{fixture, rstest};",
            " ",
            "     #[test]",
            "     fn read_empty_workspace_test() {",
            "         // Arrange",
            "         let root_path = PathBuf::from(\"/\");",
            "         let fs = MemoryFS::new();"
          ]
        },
        {
          "file": "/home/releaser-0.14.0/src/workflow.rs",
          "change": [
            "--- /home/releaser-0.11.1/src/workflow.rs",
            "+++ /home/releaser-0.14.0/src/workflow.rs",
            "@@ -1,19 +1,19 @@",
            " use std::{thread, time};",
            " ",
            "-use ansi_term::Colour::Green;",
            "+use console::style;",
            " use semver::Version;",
            " use vfs::VfsPath;",
            " ",
            "-use crate::version_iter::VersionIter;",
            " use crate::CrateConfig;",
            " use crate::Increment;",
            " use crate::Publisher;",
            " use crate::Vcs;",
            "-use crate::{new_cargo_config_path, PublishOptions};",
            "+use crate::version_iter::VersionIter;",
            "+use crate::{PublishOptions, new_cargo_config_path};",
            " use color_eyre::eyre::Result;",
            " ",
            " /// Represents virtual path in a filesystem",
            " /// that keeps real fs path that is root of this",
            " /// virtual path",
            " pub struct VPath<'a> {",
            "     real_path: &'a str,",
            "@@ -87,16 +87,16 @@",
            "             };",
            "             self.publisher.publish(root.real_path, options)?;",
            "             // delay between crates needed to avoid publish failure",
            "             // because crates.io index aren't updated instantly",
            "             if i < crates_to_publish.len() - 1 {",
            "                 println!(",
            "                     \" Waiting {} seconds after publish {} ...\",",
            "-                    Green.bold().paint(&delay_str),",
            "-                    Green.bold().paint(publish)",
            "+                    style(&delay_str).green().bold(),",
            "+                    style(publish).green().bold()",
            "                 );",
            "                 thread::sleep(delay);",
            "             }",
            "         }",
            " ",
            "         self.vcs.create_tag(root.real_path, &ver)?;",
            "         self.vcs.push_tag(root.real_path, &ver)?;",
            "@@ -156,15 +156,15 @@",
            " ",
            " #[cfg(test)]",
            " mod tests {",
            "     #![allow(clippy::unwrap_in_result)]",
            "     #![allow(clippy::unwrap_used)]",
            "     use super::*;",
            "     use crate::MockVcs;",
            "-    use crate::{MockPublisher, CARGO_CONFIG};",
            "+    use crate::{CARGO_CONFIG, MockPublisher};",
            "     use mockall::predicate::{eq, str};",
            "     use rstest::{fixture, rstest};",
            "     use vfs::MemoryFS;",
            " ",
            "     #[rstest]",
            "     #[case::all_features(true)]",
            "     #[case::default_features(false)]"
          ]
        }
      ]
    }
  }
}