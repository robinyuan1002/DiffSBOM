{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:6e242eb2-d4de-4e6e-bf14-d26e386f0d18",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T13:31:36-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "8d57074c845ac021",
      "type": "file",
      "name": "rosrust-0.9.5/"
    }
  },
  "upgrade": {
    "file_changes": {
      "old_version": "/home/rosrust-0.8.0",
      "New file": [
        "/home/rosrust-0.9.5/examples/examples/camera_subscriber.rs",
        "/home/rosrust-0.9.5/examples/examples/client_node.rs",
        "/home/rosrust-0.9.5/examples/examples/old_client.rs",
        "/home/rosrust-0.9.5/examples/examples/old_service.rs",
        "/home/rosrust-0.9.5/examples/examples/parameters.rs",
        "/home/rosrust-0.9.5/examples/examples/publisher_latch_demo.rs",
        "/home/rosrust-0.9.5/examples/examples/publisher_node.rs",
        "/home/rosrust-0.9.5/examples/examples/pubsub_loopback.rs",
        "/home/rosrust-0.9.5/examples/examples/service_node.rs",
        "/home/rosrust-0.9.5/examples/examples/subscriber_node.rs",
        "/home/rosrust-0.9.5/examples/examples/subscriber_with_ids.rs",
        "/home/rosrust-0.9.5/examples/src/lib.rs",
        "/home/rosrust-0.9.5/rosrust/examples/client.rs",
        "/home/rosrust-0.9.5/rosrust/examples/publisher.rs",
        "/home/rosrust-0.9.5/rosrust/examples/raw_publisher.rs",
        "/home/rosrust-0.9.5/rosrust/examples/raw_subscriber.rs",
        "/home/rosrust-0.9.5/rosrust/examples/service.rs",
        "/home/rosrust-0.9.5/rosrust/examples/subscriber.rs",
        "/home/rosrust-0.9.5/rosrust/src/raw_message.rs",
        "/home/rosrust-0.9.5/rosrust/tests/derive_array_test.rs",
        "/home/rosrust-0.9.5/rosrust/tests/reserved_keywords_test.rs",
        "/home/rosrust-0.9.5/rosrust_actionlib/build.rs",
        "/home/rosrust-0.9.5/rosrust_actionlib/src/impls.rs",
        "/home/rosrust-0.9.5/rosrust_codegen/src/message_path.rs",
        "/home/rosrust-0.9.5/rosrust_msg/build.rs",
        "/home/rosrust-0.9.5/rosrust_msg/examples/access_image_message.rs",
        "/home/rosrust-0.9.5/rosrust_msg/src/lib.rs"
      ],
      "Deleted file": [
        "/home/rosrust-0.8.0/examples/camera/src/msg.rs",
        "/home/rosrust-0.8.0/examples/camera/src/subscriber.rs",
        "/home/rosrust-0.8.0/examples/oldedition/src/client.rs",
        "/home/rosrust-0.8.0/examples/oldedition/src/msg.rs",
        "/home/rosrust-0.8.0/examples/oldedition/src/service.rs",
        "/home/rosrust-0.8.0/examples/parameters/src/parameters.rs",
        "/home/rosrust-0.8.0/examples/pubsub/src/loopback.rs",
        "/home/rosrust-0.8.0/examples/pubsub/src/msg.rs",
        "/home/rosrust-0.8.0/examples/pubsub/src/publisher.rs",
        "/home/rosrust-0.8.0/examples/pubsub/src/publisher_latch_demo.rs",
        "/home/rosrust-0.8.0/examples/pubsub/src/subscriber.rs",
        "/home/rosrust-0.8.0/examples/pubsub/src/subscriber_with_ids.rs",
        "/home/rosrust-0.8.0/examples/reservedkeywords/src/main.rs",
        "/home/rosrust-0.8.0/examples/reservedkeywords/src/msg.rs",
        "/home/rosrust-0.8.0/examples/serviceclient/src/client.rs",
        "/home/rosrust-0.8.0/examples/serviceclient/src/msg.rs",
        "/home/rosrust-0.8.0/examples/serviceclient/src/service.rs",
        "/home/rosrust-0.8.0/rosrust_actionlib/src/msg.rs"
      ],
      "Modified file": [
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/clock.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/clock.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/clock.rs",
            "@@ -7,36 +7,36 @@",
            " use std::sync::{Arc, Mutex};",
            " use std::thread::sleep;",
            " use std::time::{Duration as StdDuration, SystemTime, UNIX_EPOCH};",
            " ",
            " static BEFORE_EPOCH: &'static str = \"Requested time is before UNIX epoch.\";",
            " ",
            " pub struct Delay {",
            "-    clock: Arc<Clock>,",
            "+    clock: Arc<dyn Clock>,",
            "     delay: Duration,",
            " }",
            " ",
            " impl Delay {",
            "-    pub fn new(clock: Arc<Clock>, delay: Duration) -> Self {",
            "+    pub fn new(clock: Arc<dyn Clock>, delay: Duration) -> Self {",
            "         Self { clock, delay }",
            "     }",
            " ",
            "     pub fn sleep(self) {",
            "         self.clock.sleep(self.delay);",
            "     }",
            " }",
            " ",
            " pub struct Rate {",
            "-    clock: Arc<Clock>,",
            "+    clock: Arc<dyn Clock>,",
            "     next: Cell<Time>,",
            "     delay: Duration,",
            " }",
            " ",
            " impl Rate {",
            "-    pub fn new(clock: Arc<Clock>, delay: Duration) -> Rate {",
            "+    pub fn new(clock: Arc<dyn Clock>, delay: Duration) -> Rate {",
            "         let start = clock.now();",
            "         Rate {",
            "             clock,",
            "             next: Cell::new(start),",
            "             delay,",
            "         }",
            "     }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/error.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/error.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/error.rs",
            "@@ -1,15 +1,13 @@",
            "-#![allow(deprecated)]",
            "-",
            " pub use crate::api::naming::error as naming;",
            " pub use crate::rosxmlrpc::error as rosxmlrpc;",
            " pub use crate::rosxmlrpc::ResponseError;",
            " pub use crate::tcpros::error as tcpros;",
            " ",
            "-error_chain! {",
            "+error_chain::error_chain! {",
            "     foreign_links {",
            "         Io(::std::io::Error);",
            "         Nix(::nix::Error);",
            "         FromUTF8(::std::string::FromUtf8Error);",
            "         Response(ResponseError);",
            "         SigintOverride(::ctrlc::Error);",
            "     }",
            "@@ -40,16 +38,15 @@",
            "             description(\"Failure in communication with ROS API\")",
            "             display(\"Failure in communication with ROS API: {}\", details)",
            "         }",
            "     }",
            " }",
            " ",
            " pub mod api {",
            "-    #![allow(deprecated)]",
            "-    error_chain! {",
            "+    error_chain::error_chain! {",
            "         errors {",
            "             SystemFail(message: String) {",
            "                 description(\"Failure to handle API call\")",
            "                 display(\"Failure to handle API call: {}\", message)",
            "             }",
            "             BadData(message: String) {",
            "                 description(\"Bad parameters provided in API call\")"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/naming/error.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/naming/error.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/naming/error.rs",
            "@@ -1,9 +1,8 @@",
            "-#![allow(deprecated)]",
            "-error_chain! {",
            "+error_chain::error_chain! {",
            "     errors {",
            "         IllegalCharacter(name: String) {",
            "             description(\"Illegal character\")",
            "             display(\"Illegal character in '{}' - limited to letters, numbers and underscores\", name)",
            "         }",
            "         IllegalFirstCharacter(name: String) {",
            "             description(\"Illegal first character\")"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/naming/path.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/naming/path.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/naming/path.rs",
            "@@ -1,8 +1,9 @@",
            " use super::error::{Error, ErrorKind};",
            "+use error_chain::bail;",
            " use std;",
            " use std::fmt;",
            " use std::ops::{Add, AddAssign};",
            " ",
            " pub trait Path {",
            "     fn get(&self) -> &[String];"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/raii.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/raii.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/raii.rs",
            "@@ -1,45 +1,51 @@",
            " use super::clock::Clock;",
            " use super::error::Result;",
            " use super::master::Master;",
            " use super::slave::Slave;",
            " use crate::rosxmlrpc::Response;",
            " use crate::tcpros::{Message, PublisherStream, ServicePair, ServiceResult};",
            "+use crate::RawMessageDescription;",
            " use log::error;",
            "+use std::collections::HashMap;",
            " use std::sync::atomic::AtomicUsize;",
            " use std::sync::Arc;",
            " ",
            " #[derive(Clone)]",
            " pub struct Publisher<T: Message> {",
            "-    clock: Arc<Clock>,",
            "+    clock: Arc<dyn Clock>,",
            "     seq: Arc<AtomicUsize>,",
            "     stream: PublisherStream<T>,",
            "     _raii: Arc<InteractorRaii<PublisherInfo>>,",
            " }",
            " ",
            " impl<T: Message> Publisher<T> {",
            "     pub(crate) fn new(",
            "         master: Arc<Master>,",
            "         slave: Arc<Slave>,",
            "-        clock: Arc<Clock>,",
            "+        clock: Arc<dyn Clock>,",
            "         hostname: &str,",
            "         name: &str,",
            "         queue_size: usize,",
            "+        message_description: Option<RawMessageDescription>,",
            "     ) -> Result<Self> {",
            "-        let stream = slave.add_publication::<T>(hostname, name, queue_size)?;",
            "+        let message_description =",
            "+            message_description.unwrap_or_else(RawMessageDescription::from_message::<T>);",
            "+        let stream =",
            "+            slave.add_publication::<T>(hostname, name, queue_size, message_description.clone())?;",
            " ",
            "         let raii = Arc::new(InteractorRaii::new(PublisherInfo {",
            "             master,",
            "             slave,",
            "             name: name.into(),",
            "         }));",
            " ",
            "         raii.interactor",
            "             .master",
            "-            .register_publisher(name, &T::msg_type())",
            "+            .register_publisher(name, &message_description.msg_type)",
            "             .map_err(|err| {",
            "                 error!(\"Failed to register publisher for topic '{}': {}\", name, err);",
            "                 err",
            "             })?;",
            " ",
            "         Ok(Self {",
            "             stream,",
            "@@ -91,22 +97,28 @@",
            " ",
            " #[derive(Clone)]",
            " pub struct Subscriber {",
            "     info: Arc<InteractorRaii<SubscriberInfo>>,",
            " }",
            " ",
            " impl Subscriber {",
            "-    pub(crate) fn new<T: Message, F: Fn(T, &str) + Send + 'static>(",
            "+    pub(crate) fn new<T, F, G>(",
            "         master: Arc<Master>,",
            "         slave: Arc<Slave>,",
            "         name: &str,",
            "         queue_size: usize,",
            "-        callback: F,",
            "-    ) -> Result<Self> {",
            "-        slave.add_subscription::<T, F>(name, queue_size, callback)?;",
            "+        on_message: F,",
            "+        on_connect: G,",
            "+    ) -> Result<Self>",
            "+    where",
            "+        T: Message,",
            "+        F: Fn(T, &str) + Send + 'static,",
            "+        G: Fn(HashMap<String, String>) + Send + 'static,",
            "+    {",
            "+        slave.add_subscription::<T, F, G>(name, queue_size, on_message, on_connect)?;",
            " ",
            "         let info = Arc::new(InteractorRaii::new(SubscriberInfo {",
            "             master,",
            "             slave,",
            "             name: name.into(),",
            "         }));"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/resolve.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/resolve.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/resolve.rs",
            "@@ -446,9 +446,8 @@",
            "         env::remove_var(\"ROS_IP\");",
            "         assert_eq!(String::from(\"myhostname\"), hostname());",
            "         env::set_var(\"ROS_HOSTNAME\", \"host\");",
            "         env::set_var(\"ROS_IP\", \"192.168.0.1\");",
            "         set_args(&vec![\"__hostname:=host2\", \"__ip:=127.0.0.1\"]);",
            "         assert_eq!(String::from(\"host2\"), hostname());",
            "     }",
            "-",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/ros.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/ros.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/ros.rs",
            "@@ -8,29 +8,32 @@",
            " use super::slave::Slave;",
            " use crate::api::clock::Delay;",
            " use crate::api::ShutdownManager;",
            " use crate::msg::rosgraph_msgs::{Clock as ClockMsg, Log};",
            " use crate::msg::std_msgs::Header;",
            " use crate::tcpros::{Client, Message, ServicePair, ServiceResult};",
            " use crate::time::{Duration, Time};",
            "+use crate::RawMessageDescription;",
            "+use error_chain::bail;",
            " use log::error;",
            " use serde::{Deserialize, Serialize};",
            "+use std::collections::HashMap;",
            " use std::sync::Arc;",
            " use std::thread::sleep;",
            " use xml_rpc;",
            " use yaml_rust::{Yaml, YamlLoader};",
            " ",
            " pub struct Ros {",
            "     master: Arc<Master>,",
            "     slave: Arc<Slave>,",
            "     hostname: String,",
            "     bind_address: String,",
            "     resolver: Resolver,",
            "     name: String,",
            "-    clock: Arc<Clock>,",
            "+    clock: Arc<dyn Clock>,",
            "     static_subs: Vec<Subscriber>,",
            "     logger: Option<Publisher<Log>>,",
            "     shutdown_manager: Arc<ShutdownManager>,",
            " }",
            " ",
            " impl Ros {",
            "     pub fn new(name: &str) -> Result<Ros> {",
            "@@ -263,49 +266,95 @@",
            "     {",
            "         self.subscribe_with_ids(topic, queue_size, move |data, _| callback(data))",
            "     }",
            " ",
            "     pub fn subscribe_with_ids<T, F>(",
            "         &self,",
            "         topic: &str,",
            "-        mut queue_size: usize,",
            "+        queue_size: usize,",
            "         callback: F,",
            "     ) -> Result<Subscriber>",
            "     where",
            "         T: Message,",
            "         F: Fn(T, &str) + Send + 'static,",
            "     {",
            "+        self.subscribe_with_ids_and_headers(",
            "+            topic,",
            "+            queue_size,",
            "+            callback,",
            "+            |_: HashMap<String, String>| (),",
            "+        )",
            "+    }",
            "+",
            "+    pub fn subscribe_with_ids_and_headers<T, F, G>(",
            "+        &self,",
            "+        topic: &str,",
            "+        mut queue_size: usize,",
            "+        on_message: F,",
            "+        on_connect: G,",
            "+    ) -> Result<Subscriber>",
            "+    where",
            "+        T: Message,",
            "+        F: Fn(T, &str) + Send + 'static,",
            "+        G: Fn(HashMap<String, String>) + Send + 'static,",
            "+    {",
            "         if queue_size == 0 {",
            "             queue_size = usize::max_value();",
            "         }",
            "         let name = self.resolver.translate(topic)?;",
            "-        Subscriber::new::<T, F>(",
            "+        Subscriber::new::<T, F, G>(",
            "             Arc::clone(&self.master),",
            "             Arc::clone(&self.slave),",
            "             &name,",
            "             queue_size,",
            "-            callback,",
            "+            on_message,",
            "+            on_connect,",
            "         )",
            "     }",
            " ",
            "-    pub fn publish<T>(&self, topic: &str, mut queue_size: usize) -> Result<Publisher<T>>",
            "+    pub fn publish<T>(&self, topic: &str, queue_size: usize) -> Result<Publisher<T>>",
            "+    where",
            "+        T: Message,",
            "+    {",
            "+        self.publish_common(topic, queue_size, None)",
            "+    }",
            "+",
            "+    pub fn publish_with_description<T>(",
            "+        &self,",
            "+        topic: &str,",
            "+        queue_size: usize,",
            "+        message_description: RawMessageDescription,",
            "+    ) -> Result<Publisher<T>>",
            "+    where",
            "+        T: Message,",
            "+    {",
            "+        self.publish_common(topic, queue_size, Some(message_description))",
            "+    }",
            "+",
            "+    fn publish_common<T>(",
            "+        &self,",
            "+        topic: &str,",
            "+        mut queue_size: usize,",
            "+        message_description: Option<RawMessageDescription>,",
            "+    ) -> Result<Publisher<T>>",
            "     where",
            "         T: Message,",
            "     {",
            "         if queue_size == 0 {",
            "             queue_size = usize::max_value();",
            "         }",
            "         let name = self.resolver.translate(topic)?;",
            "         Publisher::new(",
            "             Arc::clone(&self.master),",
            "             Arc::clone(&self.slave),",
            "             Arc::clone(&self.clock),",
            "             &self.bind_address,",
            "             &name,",
            "             queue_size,",
            "+            message_description,",
            "         )",
            "     }",
            " ",
            "     fn log_to_terminal(&self, level: i8, msg: &str, file: &str, line: u32) {",
            "         use colored::{Color, Colorize};",
            " ",
            "         let format_string ="
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/slave/mod.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/slave/mod.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/slave/mod.rs",
            "@@ -3,15 +3,17 @@",
            " mod subscriptions;",
            " ",
            " use self::handler::SlaveHandler;",
            " use super::error::{self, ErrorKind, Result};",
            " use crate::api::ShutdownManager;",
            " use crate::tcpros::{Message, PublisherStream, Service, ServicePair, ServiceResult};",
            " use crate::util::{kill, FAILED_TO_LOCK};",
            "+use crate::RawMessageDescription;",
            " use crossbeam::channel::TryRecvError;",
            "+use error_chain::bail;",
            " use log::error;",
            " use std::collections::HashMap;",
            " use std::sync::{Arc, Mutex};",
            " use std::thread;",
            " ",
            " pub struct Slave {",
            "     name: String,",
            "@@ -127,35 +129,43 @@",
            " ",
            "     #[inline]",
            "     pub fn add_publication<T>(",
            "         &self,",
            "         hostname: &str,",
            "         topic: &str,",
            "         queue_size: usize,",
            "+        message_description: RawMessageDescription,",
            "     ) -> error::tcpros::Result<PublisherStream<T>>",
            "     where",
            "         T: Message,",
            "     {",
            "         self.publications",
            "-            .add(hostname, topic, queue_size, &self.name)",
            "+            .add(hostname, topic, queue_size, &self.name, message_description)",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn remove_publication(&self, topic: &str) {",
            "         self.publications.remove(topic)",
            "     }",
            " ",
            "     #[inline]",
            "-    pub fn add_subscription<T, F>(&self, topic: &str, queue_size: usize, callback: F) -> Result<()>",
            "+    pub fn add_subscription<T, F, G>(",
            "+        &self,",
            "+        topic: &str,",
            "+        queue_size: usize,",
            "+        on_message: F,",
            "+        on_connect: G,",
            "+    ) -> Result<()>",
            "     where",
            "         T: Message,",
            "         F: Fn(T, &str) + Send + 'static,",
            "+        G: Fn(HashMap<String, String>) + Send + 'static,",
            "     {",
            "         self.subscriptions",
            "-            .add(&self.name, topic, queue_size, callback)",
            "+            .add(&self.name, topic, queue_size, on_message, on_connect)",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn remove_subscription(&self, topic: &str) {",
            "         self.subscriptions.remove(topic)",
            "     }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/slave/publications.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/slave/publications.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/slave/publications.rs",
            "@@ -1,11 +1,11 @@",
            " use crate::api::error;",
            " use crate::tcpros::{Publisher, PublisherStream, Topic};",
            " use crate::util::FAILED_TO_LOCK;",
            "-use crate::Message;",
            "+use crate::{Message, RawMessageDescription};",
            " use std::collections::HashMap;",
            " use std::iter::FromIterator;",
            " use std::sync::{Arc, Mutex};",
            " ",
            " #[derive(Clone, Default)]",
            " pub struct PublicationsTracker {",
            "     mapping: Arc<Mutex<HashMap<String, Publisher>>>,",
            "@@ -44,31 +44,37 @@",
            " ",
            "     pub fn add<T: Message>(",
            "         &self,",
            "         hostname: &str,",
            "         topic: &str,",
            "         queue_size: usize,",
            "         caller_id: &str,",
            "+        message_description: RawMessageDescription,",
            "     ) -> error::tcpros::Result<PublisherStream<T>> {",
            "         use std::collections::hash_map::Entry;",
            "         match self",
            "             .mapping",
            "             .lock()",
            "             .expect(FAILED_TO_LOCK)",
            "             .entry(String::from(topic))",
            "         {",
            "-            Entry::Occupied(publisher_entry) => publisher_entry.get().stream(queue_size),",
            "+            Entry::Occupied(publisher_entry) => publisher_entry",
            "+                .get()",
            "+                .stream(queue_size, message_description),",
            "             Entry::Vacant(entry) => {",
            "-                let publisher = Publisher::new::<T, _>(",
            "+                let publisher = Publisher::new(",
            "                     format!(\"{}:0\", hostname).as_str(),",
            "                     topic,",
            "                     queue_size,",
            "                     caller_id,",
            "+                    message_description.clone(),",
            "                 )?;",
            "-                entry.insert(publisher).stream(queue_size)",
            "+                entry",
            "+                    .insert(publisher)",
            "+                    .stream(queue_size, message_description)",
            "             }",
            "         }",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn remove(&self, topic: &str) {",
            "         self.mapping.lock().expect(FAILED_TO_LOCK).remove(topic);"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/api/slave/subscriptions.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/api/slave/subscriptions.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/api/slave/subscriptions.rs",
            "@@ -1,11 +1,12 @@",
            " use crate::api::error::{self, ErrorKind, Result};",
            " use crate::tcpros::{Subscriber, Topic};",
            " use crate::util::FAILED_TO_LOCK;",
            " use crate::Message;",
            "+use error_chain::bail;",
            " use log::error;",
            " use std::collections::{BTreeSet, HashMap};",
            " use std::iter::FromIterator;",
            " use std::sync::{Arc, Mutex};",
            " ",
            " #[derive(Clone, Default)]",
            " pub struct SubscriptionsTracker {",
            "@@ -13,61 +14,74 @@",
            " }",
            " ",
            " impl SubscriptionsTracker {",
            "     pub fn add_publishers<T>(&self, topic: &str, name: &str, publishers: T) -> Result<()>",
            "     where",
            "         T: Iterator<Item = String>,",
            "     {",
            "+        let mut last_error_message = None;",
            "         if let Some(mut subscription) = self.mapping.lock().expect(FAILED_TO_LOCK).get_mut(topic) {",
            "             let publisher_set: BTreeSet<String> = publishers.collect();",
            "             subscription.limit_publishers_to(&publisher_set);",
            "             for publisher in publisher_set {",
            "                 if let Err(err) = connect_to_publisher(&mut subscription, name, &publisher, topic) {",
            "                     let info = err",
            "                         .iter()",
            "                         .map(|v| format!(\"{}\", v))",
            "                         .collect::<Vec<_>>()",
            "                         .join(\"\\nCaused by:\");",
            "                     error!(\"Failed to connect to publisher '{}': {}\", publisher, info);",
            "-                    return Err(err);",
            "+                    last_error_message = Some(err);",
            "                 }",
            "             }",
            "         }",
            "-        Ok(())",
            "+        match last_error_message {",
            "+            None => Ok(()),",
            "+            Some(err) => Err(err),",
            "+        }",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn get_topics<T: FromIterator<Topic>>(&self) -> T {",
            "         self.mapping",
            "             .lock()",
            "             .expect(FAILED_TO_LOCK)",
            "             .values()",
            "             .map(Subscriber::get_topic)",
            "             .cloned()",
            "             .collect()",
            "     }",
            " ",
            "-    pub fn add<T, F>(&self, name: &str, topic: &str, queue_size: usize, callback: F) -> Result<()>",
            "+    pub fn add<T, F, G>(",
            "+        &self,",
            "+        name: &str,",
            "+        topic: &str,",
            "+        queue_size: usize,",
            "+        on_message: F,",
            "+        on_connect: G,",
            "+    ) -> Result<()>",
            "     where",
            "         T: Message,",
            "         F: Fn(T, &str) + Send + 'static,",
            "+        G: Fn(HashMap<String, String>) + Send + 'static,",
            "     {",
            "         use std::collections::hash_map::Entry;",
            "         match self",
            "             .mapping",
            "             .lock()",
            "             .expect(FAILED_TO_LOCK)",
            "             .entry(String::from(topic))",
            "         {",
            "             Entry::Occupied(..) => {",
            "                 error!(\"Duplicate subscription to topic '{}' attempted\", topic);",
            "                 Err(ErrorKind::Duplicate(\"subscription\".into()).into())",
            "             }",
            "             Entry::Vacant(entry) => {",
            "-                let subscriber = Subscriber::new::<T, F>(name, topic, queue_size, callback);",
            "+                let subscriber =",
            "+                    Subscriber::new::<T, F, G>(name, topic, queue_size, on_message, on_connect);",
            "                 entry.insert(subscriber);",
            "                 Ok(())",
            "             }",
            "         }",
            "     }",
            " ",
            "     #[inline]"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/lib.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/lib.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/lib.rs",
            "@@ -1,26 +1,25 @@",
            " #![recursion_limit = \"1024\"]",
            " ",
            "-#[macro_use]",
            "-extern crate error_chain;",
            "-",
            " pub use crate::api::raii::{Publisher, Service, Subscriber};",
            " pub use crate::api::{error, Clock, Parameter};",
            "+pub use crate::raw_message::{RawMessage, RawMessageDescription};",
            " #[doc(hidden)]",
            " pub use crate::rosmsg::RosMsg;",
            " pub use crate::singleton::*;",
            " pub use crate::tcpros::{Client, ClientResponse, Message, ServicePair};",
            " pub use crate::time::{Duration, Time};",
            " #[doc(hidden)]",
            " pub use rosrust_codegen::*;",
            " ",
            " pub mod api;",
            " mod log_macros;",
            " #[doc(hidden)]",
            " pub mod msg;",
            "+mod raw_message;",
            " #[doc(hidden)]",
            " pub mod rosmsg;",
            " mod rosxmlrpc;",
            " pub mod singleton;",
            " mod tcpros;",
            " mod time;",
            " mod util;"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/rosxmlrpc/error.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/rosxmlrpc/error.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/rosxmlrpc/error.rs",
            "@@ -1,9 +1,8 @@",
            "-#![allow(deprecated)]",
            "-error_chain! {",
            "+error_chain::error_chain! {",
            "     foreign_links {",
            "         Io(::std::io::Error);",
            "         Utf8(::std::string::FromUtf8Error);",
            "         ForeignXmlRpc(xml_rpc::error::Error);",
            "     }",
            " ",
            "     errors {"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/rosxmlrpc/mod.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/rosxmlrpc/mod.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/rosxmlrpc/mod.rs",
            "@@ -28,15 +28,15 @@",
            " impl std::error::Error for ResponseError {",
            "     fn description(&self) -> &str {",
            "         match *self {",
            "             ResponseError::Client(ref v) | ResponseError::Server(ref v) => v,",
            "         }",
            "     }",
            " ",
            "-    fn cause(&self) -> Option<&std::error::Error> {",
            "+    fn cause(&self) -> Option<&dyn std::error::Error> {",
            "         None",
            "     }",
            " }",
            " ",
            " const ERROR_CODE: i32 = -1;",
            " const FAILURE_CODE: i32 = 0;",
            " const SUCCESS_CODE: i32 = 1;"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/singleton.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/singleton.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/singleton.rs",
            "@@ -2,17 +2,20 @@",
            " use crate::api::resolve::get_unused_args;",
            " use crate::api::{Delay, Parameter, Rate, Ros, SystemState, Topic};",
            " use crate::error::{ErrorKind, Result};",
            " use crate::rosxmlrpc::Response;",
            " use crate::tcpros::{Client, Message, ServicePair, ServiceResult};",
            " use crate::time::{Duration, Time};",
            " use crate::util::FAILED_TO_LOCK;",
            "+use crate::RawMessageDescription;",
            " use crossbeam::sync::ShardedLock;",
            " use ctrlc;",
            "+use error_chain::bail;",
            " use lazy_static::lazy_static;",
            "+use std::collections::HashMap;",
            " use std::time;",
            " ",
            " lazy_static! {",
            "     static ref ROS: ShardedLock<Option<Ros>> = ShardedLock::new(None);",
            " }",
            " ",
            " #[inline]",
            "@@ -164,20 +167,47 @@",
            "     T: Message,",
            "     F: Fn(T, &str) + Send + 'static,",
            " {",
            "     ros!().subscribe_with_ids::<T, F>(topic, queue_size, callback)",
            " }",
            " ",
            " #[inline]",
            "+pub fn subscribe_with_ids_and_headers<T, F, G>(",
            "+    topic: &str,",
            "+    queue_size: usize,",
            "+    on_message: F,",
            "+    on_connect: G,",
            "+) -> Result<Subscriber>",
            "+where",
            "+    T: Message,",
            "+    F: Fn(T, &str) + Send + 'static,",
            "+    G: Fn(HashMap<String, String>) + Send + 'static,",
            "+{",
            "+    ros!().subscribe_with_ids_and_headers::<T, F, G>(topic, queue_size, on_message, on_connect)",
            "+}",
            "+",
            "+#[inline]",
            " pub fn publish<T>(topic: &str, queue_size: usize) -> Result<Publisher<T>>",
            " where",
            "     T: Message,",
            " {",
            "     ros!().publish::<T>(topic, queue_size)",
            " }",
            " ",
            " #[inline]",
            "+pub fn publish_with_description<T>(",
            "+    topic: &str,",
            "+    queue_size: usize,",
            "+    message_description: RawMessageDescription,",
            "+) -> Result<Publisher<T>>",
            "+where",
            "+    T: Message,",
            "+{",
            "+    ros!().publish_with_description::<T>(topic, queue_size, message_description)",
            "+}",
            "+",
            "+#[inline]",
            " pub fn log(level: i8, msg: String, file: &str, line: u32) {",
            "     ros!().log(level, msg, file, line)",
            " }",
            " ",
            " static UNINITIALIZED: &str = \"ROS uninitialized. Please run ros::init(name) first!\";"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/client.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/client.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/client.rs",
            "@@ -1,12 +1,13 @@",
            " use super::error::{ErrorKind, Result, ResultExt};",
            " use super::header::{decode, encode};",
            " use super::{ServicePair, ServiceResult};",
            " use crate::rosmsg::RosMsg;",
            " use byteorder::{LittleEndian, ReadBytesExt};",
            "+use error_chain::bail;",
            " use log::error;",
            " use net2::TcpStreamExt;",
            " use std;",
            " use std::collections::HashMap;",
            " use std::io;",
            " use std::io::{Read, Write};",
            " use std::net::TcpStream;"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/error.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/error.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/error.rs",
            "@@ -1,9 +1,8 @@",
            "-#![allow(deprecated)]",
            "-error_chain! {",
            "+error_chain::error_chain! {",
            "     foreign_links {",
            "         Io(::std::io::Error);",
            "     }",
            "     errors {",
            "         ServiceConnectionFail(service: String, uri: String) {",
            "             description(\"Failed to connect to service\")",
            "             display(\"Failed to connect with client to service {} at uri {}\", service, uri)"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/header.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/header.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/header.rs",
            "@@ -1,8 +1,9 @@",
            " use crate::rosmsg::RosMsg;",
            "+use error_chain::bail;",
            " use std;",
            " use std::collections::HashMap;",
            " use std::io::Error;",
            " ",
            " pub fn decode<R: std::io::Read>(data: &mut R) -> Result<HashMap<String, String>, Error> {",
            "     RosMsg::decode(data)",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/mod.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/mod.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/mod.rs",
            "@@ -20,15 +20,15 @@",
            " ",
            " pub type ServiceResult<T> = Result<T, String>;",
            " ",
            " pub trait Message: Clone + Debug + Default + PartialEq + RosMsg + Send + Sync + 'static {",
            "     fn msg_definition() -> String;",
            "     fn md5sum() -> String;",
            "     fn msg_type() -> String;",
            "-    fn set_header(&mut self, _clock: &Arc<Clock>, _seq: &Arc<AtomicUsize>) {}",
            "+    fn set_header(&mut self, _clock: &Arc<dyn Clock>, _seq: &Arc<AtomicUsize>) {}",
            " }",
            " ",
            " pub trait ServicePair: Clone + Debug + Default + PartialEq + Message {",
            "     type Request: RosMsg + Send + 'static;",
            "     type Response: RosMsg + Send + 'static;",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/publisher.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/publisher.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/publisher.rs",
            "@@ -1,13 +1,15 @@",
            " use super::error::{ErrorKind, Result, ResultExt};",
            " use super::header;",
            " use super::util::streamfork::{fork, DataStream, TargetList};",
            " use super::util::tcpconnection;",
            " use super::{Message, Topic};",
            " use crate::util::FAILED_TO_LOCK;",
            "+use crate::RawMessageDescription;",
            "+use error_chain::bail;",
            " use log::error;",
            " use std;",
            " use std::collections::HashMap;",
            " use std::net::{TcpListener, TcpStream, ToSocketAddrs};",
            " use std::sync::{atomic, Arc, Mutex};",
            " ",
            " pub struct Publisher {",
            "@@ -21,73 +23,83 @@",
            " ",
            " impl Drop for Publisher {",
            "     fn drop(&mut self) {",
            "         self.exists.store(false, atomic::Ordering::SeqCst);",
            "     }",
            " }",
            " ",
            "-fn match_concrete_headers<T: Message>(fields: &HashMap<String, String>, topic: &str) -> Result<()> {",
            "-    header::match_field(fields, \"md5sum\", &T::md5sum())?;",
            "-    header::match_field(fields, \"type\", &T::msg_type())?;",
            "-    header::match_field(fields, \"topic\", topic)?;",
            "-    Ok(())",
            "-}",
            "-",
            "-fn match_wildcard_headers(fields: &HashMap<String, String>, topic: &str) -> Result<()> {",
            "-    header::match_field(fields, \"md5sum\", \"*\")?;",
            "-    header::match_field(fields, \"type\", \"*\")?;",
            "+fn match_headers(",
            "+    fields: &HashMap<String, String>,",
            "+    topic: &str,",
            "+    message_description: &RawMessageDescription,",
            "+) -> Result<()> {",
            "+    header::match_field(fields, \"md5sum\", &message_description.md5sum)",
            "+        .or_else(|e| header::match_field(fields, \"md5sum\", \"*\").or(Err(e)))?;",
            "+    header::match_field(fields, \"type\", &message_description.msg_type)",
            "+        .or_else(|e| header::match_field(fields, \"type\", \"*\").or(Err(e)))?;",
            "     header::match_field(fields, \"topic\", topic)?;",
            "     Ok(())",
            " }",
            " ",
            "-fn read_request<T: Message, U: std::io::Read>(mut stream: &mut U, topic: &str) -> Result<String> {",
            "+fn read_request<U: std::io::Read>(",
            "+    mut stream: &mut U,",
            "+    topic: &str,",
            "+    message_description: &RawMessageDescription,",
            "+) -> Result<String> {",
            "     let fields = header::decode(&mut stream)?;",
            "-    if let Err(err) = match_concrete_headers::<T>(&fields, topic) {",
            "-        match_wildcard_headers(&fields, topic).map_err(|_| err)?;",
            "-    }",
            "+    match_headers(&fields, topic, message_description)?;",
            "     let caller_id = fields",
            "         .get(\"callerid\")",
            "         .ok_or_else(|| ErrorKind::HeaderMissingField(\"callerid\".into()))?;",
            "     Ok(caller_id.clone())",
            " }",
            " ",
            "-fn write_response<T: Message, U: std::io::Write>(",
            "+fn write_response<U: std::io::Write>(",
            "     mut stream: &mut U,",
            "     caller_id: &str,",
            "+    message_description: &RawMessageDescription,",
            " ) -> Result<()> {",
            "     let mut fields = HashMap::<String, String>::new();",
            "-    fields.insert(String::from(\"md5sum\"), T::md5sum());",
            "-    fields.insert(String::from(\"type\"), T::msg_type());",
            "+    fields.insert(String::from(\"md5sum\"), message_description.md5sum.clone());",
            "+    fields.insert(String::from(\"type\"), message_description.msg_type.clone());",
            "     fields.insert(String::from(\"callerid\"), caller_id.into());",
            "+    fields.insert(",
            "+        String::from(\"message_definition\"),",
            "+        message_description.msg_definition.clone(),",
            "+    );",
            "     header::encode(&mut stream, &fields)?;",
            "     Ok(())",
            " }",
            " ",
            "-fn exchange_headers<T, U>(mut stream: &mut U, topic: &str, pub_caller_id: &str) -> Result<String>",
            "+fn exchange_headers<U>(",
            "+    mut stream: &mut U,",
            "+    topic: &str,",
            "+    pub_caller_id: &str,",
            "+    message_description: &RawMessageDescription,",
            "+) -> Result<String>",
            " where",
            "-    T: Message,",
            "     U: std::io::Write + std::io::Read,",
            " {",
            "-    let caller_id = read_request::<T, U>(&mut stream, topic)?;",
            "-    write_response::<T, U>(&mut stream, pub_caller_id)?;",
            "+    let caller_id = read_request(&mut stream, topic, message_description)?;",
            "+    write_response(&mut stream, pub_caller_id, message_description)?;",
            "     Ok(caller_id)",
            " }",
            " ",
            "-fn process_subscriber<T, U>(",
            "+fn process_subscriber<U>(",
            "     topic: &str,",
            "     mut stream: U,",
            "     targets: &TargetList<U>,",
            "     last_message: &Mutex<Arc<Vec<u8>>>,",
            "     pub_caller_id: &str,",
            "+    message_description: &RawMessageDescription,",
            " ) -> tcpconnection::Feedback",
            " where",
            "-    T: Message,",
            "     U: std::io::Read + std::io::Write + Send,",
            " {",
            "-    let result = exchange_headers::<T, _>(&mut stream, topic, pub_caller_id)",
            "+    let result = exchange_headers(&mut stream, topic, pub_caller_id, message_description)",
            "         .chain_err(|| ErrorKind::TopicConnectionFail(topic.into()));",
            "     let caller_id = match result {",
            "         Ok(caller_id) => caller_id,",
            "         Err(err) => {",
            "             let info = err",
            "                 .iter()",
            "                 .map(|v| format!(\"{}\", v))",
            "@@ -110,22 +122,22 @@",
            "         return tcpconnection::Feedback::StopAccepting;",
            "     }",
            " ",
            "     tcpconnection::Feedback::AcceptNextStream",
            " }",
            " ",
            " impl Publisher {",
            "-    pub fn new<T, U>(",
            "+    pub fn new<U>(",
            "         address: U,",
            "         topic: &str,",
            "         queue_size: usize,",
            "         caller_id: &str,",
            "+        message_description: RawMessageDescription,",
            "     ) -> Result<Publisher>",
            "     where",
            "-        T: Message,",
            "         U: ToSocketAddrs,",
            "     {",
            "         let listener = TcpListener::bind(address)?;",
            "         let socket_address = listener.local_addr()?;",
            " ",
            "         let publisher_exists = Arc::new(atomic::AtomicBool::new(true));",
            " ",
            "@@ -134,42 +146,54 @@",
            "         let last_message = Arc::new(Mutex::new(Arc::new(Vec::new())));",
            " ",
            "         let iterate_handler = {",
            "             let publisher_exists = publisher_exists.clone();",
            "             let topic = String::from(topic);",
            "             let last_message = Arc::clone(&last_message);",
            "             let caller_id = String::from(caller_id);",
            "+            let message_description = message_description.clone();",
            " ",
            "             move |stream: TcpStream| {",
            "                 if !publisher_exists.load(atomic::Ordering::SeqCst) {",
            "                     return tcpconnection::Feedback::StopAccepting;",
            "                 }",
            "-                process_subscriber::<T, _>(&topic, stream, &targets, &last_message, &caller_id)",
            "+                process_subscriber(",
            "+                    &topic,",
            "+                    stream,",
            "+                    &targets,",
            "+                    &last_message,",
            "+                    &caller_id,",
            "+                    &message_description,",
            "+                )",
            "             }",
            "         };",
            " ",
            "         tcpconnection::iterate(listener, format!(\"topic '{}'\", topic), iterate_handler);",
            " ",
            "         let topic = Topic {",
            "             name: String::from(topic),",
            "-            msg_type: T::msg_type(),",
            "+            msg_type: message_description.msg_type,",
            "         };",
            " ",
            "         Ok(Publisher {",
            "             subscriptions: data,",
            "             port,",
            "             topic,",
            "             last_message,",
            "             queue_size,",
            "             exists: publisher_exists,",
            "         })",
            "     }",
            " ",
            "-    pub fn stream<T: Message>(&self, queue_size: usize) -> Result<PublisherStream<T>> {",
            "-        let mut stream = PublisherStream::new(self)?;",
            "+    pub fn stream<T: Message>(",
            "+        &self,",
            "+        queue_size: usize,",
            "+        message_description: RawMessageDescription,",
            "+    ) -> Result<PublisherStream<T>> {",
            "+        let mut stream = PublisherStream::new(self, message_description)?;",
            "         stream.set_queue_size_max(queue_size);",
            "         Ok(stream)",
            "     }",
            " ",
            "     pub fn get_topic(&self) -> &Topic {",
            "         &self.topic",
            "     }",
            "@@ -184,20 +208,22 @@",
            "     stream: DataStream,",
            "     last_message: Arc<Mutex<Arc<Vec<u8>>>>,",
            "     datatype: std::marker::PhantomData<T>,",
            "     latching: bool,",
            " }",
            " ",
            " impl<T: Message> PublisherStream<T> {",
            "-    fn new(publisher: &Publisher) -> Result<PublisherStream<T>> {",
            "-        let msg_type = T::msg_type();",
            "-        if publisher.topic.msg_type != msg_type {",
            "+    fn new(",
            "+        publisher: &Publisher,",
            "+        message_description: RawMessageDescription,",
            "+    ) -> Result<PublisherStream<T>> {",
            "+        if publisher.topic.msg_type != message_description.msg_type {",
            "             bail!(ErrorKind::MessageTypeMismatch(",
            "                 publisher.topic.msg_type.clone(),",
            "-                msg_type,",
            "+                message_description.msg_type,",
            "             ));",
            "         }",
            "         let mut stream = PublisherStream {",
            "             stream: publisher.subscriptions.clone(),",
            "             datatype: std::marker::PhantomData,",
            "             last_message: Arc::clone(&publisher.last_message),",
            "             latching: false,"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/service.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/service.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/service.rs",
            "@@ -1,13 +1,14 @@",
            " use super::error::{ErrorKind, Result};",
            " use super::header;",
            " use super::util::tcpconnection;",
            " use super::{ServicePair, ServiceResult};",
            " use crate::rosmsg::{encode_str, RosMsg};",
            " use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};",
            "+use error_chain::bail;",
            " use log::error;",
            " use std;",
            " use std::collections::HashMap;",
            " use std::io;",
            " use std::net::{TcpListener, TcpStream};",
            " use std::sync::{atomic, Arc};",
            " use std::thread;"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/src/tcpros/subscriber.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/src/tcpros/subscriber.rs",
            "+++ /home/rosrust-0.9.5/rosrust/src/tcpros/subscriber.rs",
            "@@ -16,27 +16,36 @@",
            "     data_stream: LossySender<MessageInfo>,",
            "     publishers_stream: Sender<SocketAddr>,",
            "     pub topic: Topic,",
            "     pub connected_publishers: BTreeSet<String>,",
            " }",
            " ",
            " impl Subscriber {",
            "-    pub fn new<T, F>(caller_id: &str, topic: &str, queue_size: usize, callback: F) -> Subscriber",
            "+    pub fn new<T, F, G>(",
            "+        caller_id: &str,",
            "+        topic: &str,",
            "+        queue_size: usize,",
            "+        on_message: F,",
            "+        on_connect: G,",
            "+    ) -> Subscriber",
            "     where",
            "         T: Message,",
            "         F: Fn(T, &str) + Send + 'static,",
            "+        G: Fn(HashMap<String, String>) + Send + 'static,",
            "     {",
            "         let (data_tx, data_rx) = lossy_channel(queue_size);",
            "         let publisher_connection_queue_size = 8;",
            "         let (pub_tx, pub_rx) = bounded(publisher_connection_queue_size);",
            "         let caller_id = String::from(caller_id);",
            "         let topic_name = String::from(topic);",
            "         let data_stream = data_tx.clone();",
            "-        thread::spawn(move || join_connections::<T>(&data_tx, pub_rx, &caller_id, &topic_name));",
            "-        thread::spawn(move || handle_data::<T, F>(data_rx, callback));",
            "+        thread::spawn(move || {",
            "+            join_connections::<T, G>(&data_tx, pub_rx, &caller_id, &topic_name, on_connect)",
            "+        });",
            "+        thread::spawn(move || handle_data::<T, F>(data_rx, on_message));",
            "         let topic = Topic {",
            "             name: String::from(topic),",
            "             msg_type: T::msg_type(),",
            "         };",
            "         Subscriber {",
            "             data_stream,",
            "             publishers_stream: pub_tx,",
            "@@ -114,62 +123,68 @@",
            "         match RosMsg::decode_slice(&buffer.data) {",
            "             Ok(value) => callback(value, &buffer.caller_id),",
            "             Err(err) => error!(\"Failed to decode message: {}\", err),",
            "         }",
            "     }",
            " }",
            " ",
            "-fn join_connections<T>(",
            "+fn join_connections<T, F>(",
            "     data_stream: &LossySender<MessageInfo>,",
            "     publishers: Receiver<SocketAddr>,",
            "     caller_id: &str,",
            "     topic: &str,",
            "+    on_connect: F,",
            " ) where",
            "     T: Message,",
            "+    F: Fn(HashMap<String, String>) + Send + 'static,",
            " {",
            "     // Ends when publisher sender is destroyed, which happens at Subscriber destruction",
            "     for publisher in publishers {",
            "         let result = join_connection::<T>(data_stream, &publisher, caller_id, topic)",
            "             .chain_err(|| ErrorKind::TopicConnectionFail(topic.into()));",
            "-        if let Err(err) = result {",
            "-            let info = err",
            "-                .iter()",
            "-                .map(|v| format!(\"{}\", v))",
            "-                .collect::<Vec<_>>()",
            "-                .join(\"\\nCaused by:\");",
            "-            error!(\"{}\", info);",
            "+        match result {",
            "+            Ok(headers) => on_connect(headers),",
            "+            Err(err) => {",
            "+                let info = err",
            "+                    .iter()",
            "+                    .map(|v| format!(\"{}\", v))",
            "+                    .collect::<Vec<_>>()",
            "+                    .join(\"\\nCaused by:\");",
            "+                error!(\"{}\", info);",
            "+            }",
            "         }",
            "     }",
            " }",
            " ",
            " fn join_connection<T>(",
            "     data_stream: &LossySender<MessageInfo>,",
            "     publisher: &SocketAddr,",
            "     caller_id: &str,",
            "     topic: &str,",
            "-) -> Result<()>",
            "+) -> Result<HashMap<String, String>>",
            " where",
            "     T: Message,",
            " {",
            "     let mut stream = TcpStream::connect(publisher)?;",
            "-    let pub_caller_id = exchange_headers::<T, _>(&mut stream, caller_id, topic)?;",
            "+    let headers = exchange_headers::<T, _>(&mut stream, caller_id, topic)?;",
            "+    let pub_caller_id = headers.get(\"callerid\").cloned();",
            "     let target = data_stream.clone();",
            "     thread::spawn(move || {",
            "         let pub_caller_id = Arc::new(pub_caller_id.unwrap_or_default());",
            "         while let Ok(buffer) = package_to_vector(&mut stream) {",
            "             if let Err(TrySendError::Disconnected(_)) =",
            "                 target.try_send(MessageInfo::new(Arc::clone(&pub_caller_id), buffer))",
            "             {",
            "                 // Data receiver has been destroyed after",
            "                 // Subscriber destructor's kill signal",
            "                 break;",
            "             }",
            "         }",
            "     });",
            "-    Ok(())",
            "+    Ok(headers)",
            " }",
            " ",
            " fn write_request<T: Message, U: std::io::Write>(",
            "     mut stream: &mut U,",
            "     caller_id: &str,",
            "     topic: &str,",
            " ) -> Result<()> {",
            "@@ -179,22 +194,34 @@",
            "     fields.insert(String::from(\"topic\"), String::from(topic));",
            "     fields.insert(String::from(\"md5sum\"), T::md5sum());",
            "     fields.insert(String::from(\"type\"), T::msg_type());",
            "     encode(&mut stream, &fields)?;",
            "     Ok(())",
            " }",
            " ",
            "-fn read_response<T: Message, U: std::io::Read>(mut stream: &mut U) -> Result<Option<String>> {",
            "+fn read_response<T: Message, U: std::io::Read>(",
            "+    mut stream: &mut U,",
            "+) -> Result<HashMap<String, String>> {",
            "     let fields = decode(&mut stream)?;",
            "-    match_field(&fields, \"md5sum\", &T::md5sum())?;",
            "-    match_field(&fields, \"type\", &T::msg_type())?;",
            "-    Ok(fields.get(\"callerid\").cloned())",
            "+    let md5sum = T::md5sum();",
            "+    let msg_type = T::msg_type();",
            "+    if md5sum != \"*\" {",
            "+        match_field(&fields, \"md5sum\", &md5sum)?;",
            "+    }",
            "+    if msg_type != \"*\" {",
            "+        match_field(&fields, \"type\", &msg_type)?;",
            "+    }",
            "+    Ok(fields)",
            " }",
            " ",
            "-fn exchange_headers<T, U>(stream: &mut U, caller_id: &str, topic: &str) -> Result<Option<String>>",
            "+fn exchange_headers<T, U>(",
            "+    stream: &mut U,",
            "+    caller_id: &str,",
            "+    topic: &str,",
            "+) -> Result<HashMap<String, String>>",
            " where",
            "     T: Message,",
            "     U: std::io::Write + std::io::Read,",
            " {",
            "     write_request::<T, U>(stream, caller_id, topic)?;",
            "     read_response::<T, U>(stream)",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/benchmarks.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/benchmarks.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/benchmarks.rs",
            "@@ -212,19 +212,18 @@",
            "             .arg(\"add_two_ints_server\")",
            "             .arg(format!(\"__ns:={}\", namespace))",
            "             .arg(\"__name:=rospy_service\")",
            "             .arg(\"add_two_ints:=add_two_ints_py\"),",
            "     );",
            " ",
            "     let _roscpp_service = util::ChildProcessTerminator::spawn_example_bench(",
            "-        \"../examples/serviceclient\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "             .arg(\"--release\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"service\")",
            "             .arg(format!(\"__ns:={}\", namespace))",
            "             .arg(\"__name:=rosrust_service\")",
            "             .arg(\"add_two_ints:=add_two_ints_rust\"),",
            "     );",
            " ",
            "     let service_name_inline = format!(\"service_at_line_{}\", line!());"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/can_read_log_from_rosout_for_multiple.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/can_read_log_from_rosout_for_multiple.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/can_read_log_from_rosout_for_multiple.rs",
            "@@ -21,18 +21,17 @@",
            "     let _publisher_py = util::ChildProcessTerminator::spawn(",
            "         Command::new(\"rosrun\")",
            "             .arg(\"rospy_tutorials\")",
            "             .arg(\"talker\")",
            "             .arg(\"__name:=talker_py\"),",
            "     );",
            "     let _publisher_rust = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/pubsub\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"publisher\")",
            "             .arg(\"__name:=talker_rust\"),",
            "     );",
            " ",
            "     rosrust::init(\"rosout_agg_listener\");",
            " ",
            "     let (tx, rx) = unbounded();"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/can_read_log_from_rosout_for_rosrust.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/can_read_log_from_rosout_for_rosrust.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/can_read_log_from_rosout_for_rosrust.rs",
            "@@ -8,18 +8,17 @@",
            "     rosrust::rosmsg_include!(rosgraph_msgs / Log);",
            " }",
            " ",
            " #[test]",
            " fn can_read_log_from_rosout_for_rosrust() {",
            "     let _roscore = util::run_roscore_for(util::Language::Rust, util::Feature::Log);",
            "     let _publisher = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/pubsub\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"publisher\"),",
            "     );",
            " ",
            "     rosrust::init(\"rosout_agg_listener\");",
            " ",
            "     let (tx, rx) = unbounded();"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/client_to_inline_service.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/client_to_inline_service.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/client_to_inline_service.rs",
            "@@ -17,16 +17,18 @@",
            "     assert_eq!(a + b, sum);",
            " }",
            " ",
            " #[test]",
            " fn client_to_inline_service() {",
            "     let _roscore = util::run_roscore_for(util::Language::None, util::Feature::Client);",
            "     let _service = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/serviceclient\",",
            "-        Command::new(\"cargo\").arg(\"run\").arg(\"--bin\").arg(\"service\"),",
            "+        Command::new(\"cargo\")",
            "+            .arg(\"run\")",
            "+            .arg(\"--example\")",
            "+            .arg(\"service\"),",
            "     );",
            " ",
            "     rosrust::init(\"add_two_ints_client_service\");",
            " ",
            "     let _service = rosrust::service::<msg::roscpp_tutorials::TwoInts, _>(\"add_two_ints\", |req| {",
            "         Ok(msg::roscpp_tutorials::TwoIntsRes { sum: req.a + req.b })",
            "     })"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/client_to_rosrust_service.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/client_to_rosrust_service.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/client_to_rosrust_service.rs",
            "@@ -17,16 +17,18 @@",
            "     assert_eq!(a + b, sum);",
            " }",
            " ",
            " #[test]",
            " fn client_to_rosrust_service() {",
            "     let _roscore = util::run_roscore_for(util::Language::Rust, util::Feature::Client);",
            "     let _service = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/serviceclient\",",
            "-        Command::new(\"cargo\").arg(\"run\").arg(\"--bin\").arg(\"service\"),",
            "+        Command::new(\"cargo\")",
            "+            .arg(\"run\")",
            "+            .arg(\"--example\")",
            "+            .arg(\"service\"),",
            "     );",
            " ",
            "     rosrust::init(\"add_two_ints_client\");",
            "     rosrust::wait_for_service(\"add_two_ints\", Some(time::Duration::from_secs(10))).unwrap();",
            "     let client = rosrust::client::<msg::roscpp_tutorials::TwoInts>(\"add_two_ints\").unwrap();",
            " ",
            "     test_request(&client, 0, 10);"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/publisher_to_multiple_subscribers.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/publisher_to_multiple_subscribers.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/publisher_to_multiple_subscribers.rs",
            "@@ -19,18 +19,17 @@",
            "     );",
            "     let _subscriber_py = util::ChildProcessTerminator::spawn(",
            "         Command::new(\"rosrun\")",
            "             .arg(\"rospy_tutorials\")",
            "             .arg(\"listener\"),",
            "     );",
            "     let _subscriber_rust = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/pubsub\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"subscriber\"),",
            "     );",
            " ",
            "     rosrust::init(\"hello_world_talker\");",
            " ",
            "     let (tx, rx) = unbounded();"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/publisher_to_rosrust_subscriber.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/publisher_to_rosrust_subscriber.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/publisher_to_rosrust_subscriber.rs",
            "@@ -8,18 +8,17 @@",
            "     rosrust::rosmsg_include!(std_msgs / String, rosgraph_msgs / Log);",
            " }",
            " ",
            " #[test]",
            " fn publisher_to_rosrust_subscriber() {",
            "     let _roscore = util::run_roscore_for(util::Language::Rust, util::Feature::Publisher);",
            "     let _subscriber = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/pubsub\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"subscriber\"),",
            "     );",
            " ",
            "     rosrust::init(\"hello_world_talker\");",
            " ",
            "     let (tx, rx) = unbounded();"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/service_to_rosrust_client.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/service_to_rosrust_client.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/service_to_rosrust_client.rs",
            "@@ -1,25 +1,23 @@",
            " use rosrust;",
            "-use std::fs::canonicalize;",
            " use std::process::Command;",
            " ",
            " mod util;",
            " ",
            " mod msg {",
            "     rosrust::rosmsg_include!(roscpp_tutorials / TwoInts);",
            " }",
            " ",
            " fn test_request(a: i64, b: i64) {",
            "     let client = Command::new(\"cargo\")",
            "         .arg(\"run\")",
            "-        .arg(\"--bin\")",
            "+        .arg(\"--example\")",
            "         .arg(\"client\")",
            "         .arg(format!(\"{}\", a))",
            "         .arg(format!(\"{}\", b))",
            "-        .current_dir(canonicalize(\"../examples/serviceclient\").unwrap())",
            "         .output()",
            "         .unwrap();",
            "     util::assert_success_and_output_containing(client, &format!(\"{} + {} = {}\", a, b, a + b));",
            " }",
            " ",
            " #[test]",
            " fn service_to_rosrust_client() {"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/subscriber_to_multiple_publishers.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/subscriber_to_multiple_publishers.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/subscriber_to_multiple_publishers.rs",
            "@@ -29,18 +29,17 @@",
            "     let _publisher_rospy = util::ChildProcessTerminator::spawn(",
            "         Command::new(\"rosrun\")",
            "             .arg(\"rospy_tutorials\")",
            "             .arg(\"talker\")",
            "             .arg(\"__name:=talker_py\"),",
            "     );",
            "     let _publisher = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/pubsub\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"publisher\")",
            "             .arg(\"__name:=talker_rust\"),",
            "     );",
            " ",
            "     let (tx, rx) = unbounded();",
            " ",
            "     rosrust::init(\"hello_world_listener\");"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/subscriber_to_rosrust_publisher.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/subscriber_to_rosrust_publisher.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/subscriber_to_rosrust_publisher.rs",
            "@@ -8,18 +8,17 @@",
            "     rosrust::rosmsg_include!(std_msgs / String);",
            " }",
            " ",
            " #[test]",
            " fn subscriber_to_rosrust_publisher() {",
            "     let _roscore = util::run_roscore_for(util::Language::Rust, util::Feature::Subscriber);",
            "     let _publisher = util::ChildProcessTerminator::spawn_example(",
            "-        \"../examples/pubsub\",",
            "         Command::new(\"cargo\")",
            "             .arg(\"run\")",
            "-            .arg(\"--bin\")",
            "+            .arg(\"--example\")",
            "             .arg(\"publisher\"),",
            "     );",
            " ",
            "     let (tx, rx) = unbounded();",
            " ",
            "     rosrust::init(\"hello_world_listener\");",
            "     let subscriber = rosrust::subscribe::<msg::std_msgs::String, _>(\"chatter\", 100, move |data| {"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust/tests/util/child_process_terminator.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust/tests/util/child_process_terminator.rs",
            "+++ /home/rosrust-0.9.5/rosrust/tests/util/child_process_terminator.rs",
            "@@ -1,10 +1,9 @@",
            " use nix::sys::signal::{kill, Signal};",
            " use nix::unistd::Pid;",
            "-use std::fs::canonicalize;",
            " use std::process::{Child, Command, Stdio};",
            " ",
            " #[must_use]",
            " pub struct ChildProcessTerminator(pub Child);",
            " ",
            " impl ChildProcessTerminator {",
            "     pub fn spawn(command: &mut Command) -> ChildProcessTerminator {",
            "@@ -12,40 +11,38 @@",
            "             .stdin(Stdio::null())",
            "             .stdout(Stdio::null())",
            "             .stderr(Stdio::null());",
            "         ChildProcessTerminator(command.spawn().unwrap())",
            "     }",
            " ",
            "     #[allow(dead_code)]",
            "-    pub fn spawn_example(path: &str, command: &mut Command) -> ChildProcessTerminator {",
            "-        let canonical_path = canonicalize(path).unwrap();",
            "+    pub fn spawn_example(command: &mut Command) -> ChildProcessTerminator {",
            "         assert!(Command::new(\"cargo\")",
            "             .arg(\"build\")",
            "-            .current_dir(&canonical_path)",
            "+            .arg(\"--all-targets\")",
            "             .output()",
            "             .unwrap()",
            "             .status",
            "             .success());",
            " ",
            "-        Self::spawn(command.current_dir(&canonical_path))",
            "+        Self::spawn(command)",
            "     }",
            " ",
            "     #[allow(dead_code)]",
            "-    pub fn spawn_example_bench(path: &str, command: &mut Command) -> ChildProcessTerminator {",
            "-        let canonical_path = canonicalize(path).unwrap();",
            "+    pub fn spawn_example_bench(command: &mut Command) -> ChildProcessTerminator {",
            "         assert!(Command::new(\"cargo\")",
            "             .arg(\"build\")",
            "+            .arg(\"--all-targets\")",
            "             .arg(\"--release\")",
            "-            .current_dir(&canonical_path)",
            "             .output()",
            "             .unwrap()",
            "             .status",
            "             .success());",
            " ",
            "-        Self::spawn(command.current_dir(&canonical_path))",
            "+        Self::spawn(command)",
            "     }",
            " }",
            " ",
            " impl Drop for ChildProcessTerminator {",
            "     fn drop(&mut self) {",
            "         let pid = Pid::from_raw(self.0.id() as i32);",
            "         kill(pid, Signal::SIGINT).unwrap();"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_cancelling_client.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/examples/fibonacci_cancelling_client.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_cancelling_client.rs",
            "@@ -1,16 +1,9 @@",
            " use rosrust_actionlib::SimpleActionClient;",
            "-",
            "-mod msg {",
            "-    rosrust::rosmsg_include!(actionlib_tutorials / FibonacciAction);",
            "-",
            "-    rosrust_actionlib::action!(self; actionlib_tutorials: Fibonacci);",
            "-}",
            "-",
            "-use msg::actionlib_tutorials as alt;",
            "+use rosrust_msg::actionlib_tutorials as alt;",
            " ",
            " fn fibonacci_client() -> Option<alt::FibonacciResult> {",
            "     let should_cancel = rosrust::param(\"~cancel\").unwrap().get().unwrap_or(false);",
            "     rosrust::ros_info!(\"Client will cancel? {:?}\", should_cancel);",
            "     let mut client = SimpleActionClient::<alt::FibonacciAction>::new(\"fibonacci\").unwrap();",
            "     client.wait_for_server(None);",
            "     let goal = alt::FibonacciGoal { order: 20 };"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_client.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/examples/fibonacci_client.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_client.rs",
            "@@ -1,16 +1,9 @@",
            " use rosrust_actionlib::SimpleActionClient;",
            "-",
            "-mod msg {",
            "-    rosrust::rosmsg_include!(actionlib_tutorials / FibonacciAction);",
            "-",
            "-    rosrust_actionlib::action!(self; actionlib_tutorials: Fibonacci);",
            "-}",
            "-",
            "-use msg::actionlib_tutorials as alt;",
            "+use rosrust_msg::actionlib_tutorials as alt;",
            " ",
            " fn fibonacci_client() -> alt::FibonacciResult {",
            "     let mut client = SimpleActionClient::<alt::FibonacciAction>::new(\"fibonacci\").unwrap();",
            "     client.wait_for_server(None);",
            "     let goal = alt::FibonacciGoal { order: 20 };",
            "     client.build_goal_sender(goal).send();",
            "     client.wait_for_result(None);"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_multi_call_client.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/examples/fibonacci_multi_call_client.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_multi_call_client.rs",
            "@@ -1,18 +1,11 @@",
            " use rosrust_actionlib::SimpleActionClient;",
            "+use rosrust_msg::actionlib_tutorials as alt;",
            " use std::sync::mpsc::channel;",
            " ",
            "-mod msg {",
            "-    rosrust::rosmsg_include!(actionlib_tutorials / FibonacciAction);",
            "-",
            "-    rosrust_actionlib::action!(self; actionlib_tutorials: Fibonacci);",
            "-}",
            "-",
            "-use msg::actionlib_tutorials as alt;",
            "-",
            " fn fibonacci_client() {",
            "     let mut client = SimpleActionClient::<alt::FibonacciAction>::new(\"fibonacci\").unwrap();",
            "     client.wait_for_server(None);",
            "     let (tx, rx) = channel();",
            "     let mut goal_handles = vec![];",
            "     for order in &[5, 10, 20] {",
            "         let order = *order;"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_server.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/examples/fibonacci_server.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/examples/fibonacci_server.rs",
            "@@ -1,17 +1,10 @@",
            " use rosrust_actionlib::action_server::ServerSimpleGoalHandle;",
            " use rosrust_actionlib::ActionServer;",
            "-",
            "-mod msg {",
            "-    rosrust::rosmsg_include!(actionlib_tutorials / FibonacciAction);",
            "-",
            "-    rosrust_actionlib::action!(self; actionlib_tutorials: Fibonacci);",
            "-}",
            "-",
            "-use msg::actionlib_tutorials as alt;",
            "+use rosrust_msg::actionlib_tutorials as alt;",
            " ",
            " fn handler(gh: ServerSimpleGoalHandle<alt::FibonacciAction>) {",
            "     let rate = rosrust::rate(1.0);",
            " ",
            "     let mut val1 = 0;",
            "     let mut val2 = 1;",
            "     let mut sequence = vec![val1, val2];"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/action_client/comm_state_machine.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/action_client/comm_state_machine.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/action_client/comm_state_machine.rs",
            "@@ -1,11 +1,11 @@",
            " use crate::action_client::{OnFeedback, OnTransition, SyncClientGoalHandle};",
            "-use crate::msg::actionlib_msgs::GoalStatusArray;",
            " use crate::{Action, FeedbackType, GoalType, ResultType};",
            " use crate::{GoalID, GoalState, GoalStatus};",
            "+use rosrust_msg::actionlib_msgs::GoalStatusArray;",
            " use std::cell::Cell;",
            " use std::sync::Arc;",
            " ",
            " pub type OnSendGoal<T> = Arc<dyn Fn(<T as Action>::Goal) + Send + Sync + 'static>;",
            " pub type OnSendCancel = Arc<dyn Fn(GoalID) + Send + Sync + 'static>;",
            " ",
            " pub struct CommStateMachine<T: Action> {"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/action_client/goal_manager.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/action_client/goal_manager.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/action_client/goal_manager.rs",
            "@@ -1,14 +1,14 @@",
            " use super::comm_state_machine::{CommStateMachine, OnSendCancel, OnSendGoal};",
            " use super::AsyncClientGoalHandle;",
            " use crate::action_client::{OnFeedback, OnTransition};",
            "-use crate::msg::actionlib_msgs::GoalStatusArray;",
            " use crate::static_messages::MUTEX_LOCK_FAIL;",
            " use crate::GoalID;",
            " use crate::{Action, FeedbackType, GoalBody, GoalType, ResultType};",
            "+use rosrust_msg::actionlib_msgs::GoalStatusArray;",
            " use std::sync::atomic::{AtomicUsize, Ordering};",
            " use std::sync::{Arc, Mutex, Weak};",
            " ",
            " pub struct GoalManager<T: Action> {",
            "     // TODO: This doesn't have to be a Vec. Consider alternatives.",
            "     statuses: Vec<Weak<Mutex<CommStateMachine<T>>>>,",
            "     on_send_goal: OnSendGoal<T>,"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/action_client/mod.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/action_client/mod.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/action_client/mod.rs",
            "@@ -1,14 +1,14 @@",
            " pub use self::client_goal_handle::{AsyncClientGoalHandle, ClientGoalHandle, SyncClientGoalHandle};",
            " pub use self::comm_state_machine::State;",
            " pub use self::simple_action_client::SimpleActionClient;",
            "-use crate::msg::actionlib_msgs;",
            " use crate::static_messages::{MUTEX_LOCK_FAIL, UNEXPECTED_FAILED_NAME_RESOLVE};",
            " use crate::{Action, ActionResponse, FeedbackBody, GoalBody, GoalID};",
            " use rosrust::error::Result;",
            "+use rosrust_msg::actionlib_msgs::GoalStatusArray;",
            " use std::sync::{Arc, Mutex};",
            " ",
            " mod client_goal_handle;",
            " mod comm_state_machine;",
            " mod goal_manager;",
            " mod simple_action_client;",
            " ",
            "@@ -50,15 +50,15 @@",
            "         )));",
            " ",
            "         let last_caller_id: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));",
            " ",
            "         let on_status = {",
            "             let manager = Arc::clone(&manager);",
            "             let last_caller_id = Arc::clone(&last_caller_id);",
            "-            move |message: actionlib_msgs::GoalStatusArray, caller_id: &str| {",
            "+            move |message: GoalStatusArray, caller_id: &str| {",
            "                 (*last_caller_id.lock().expect(MUTEX_LOCK_FAIL)) = Some(caller_id.into());",
            "                 manager",
            "                     .lock()",
            "                     .expect(MUTEX_LOCK_FAIL)",
            "                     .update_statuses(&message);",
            "             }",
            "         };"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/action_server/mod.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/action_server/mod.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/action_server/mod.rs",
            "@@ -254,15 +254,15 @@",
            "     }",
            " ",
            "     pub fn canceled(&self) -> bool {",
            "         self.canceled.load(Ordering::SeqCst)",
            "     }",
            " }",
            " ",
            "-pub type ActionServerOnRequest<T> = Box<Fn(ServerGoalHandle<T>) -> Result<()> + Send + Sync>;",
            "+pub type ActionServerOnRequest<T> = Box<dyn Fn(ServerGoalHandle<T>) -> Result<()> + Send + Sync>;",
            " ",
            " fn publish_response<T: ActionResponse>(",
            "     publisher: &rosrust::Publisher<T>,",
            "     status: GoalStatus,",
            "     body: T::Body,",
            " ) -> Result<()> {",
            "     let mut action_response = Response {"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/action_server/status_list.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/action_server/status_list.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/action_server/status_list.rs",
            "@@ -1,11 +1,11 @@",
            " use super::StatusTracker;",
            "-use crate::msg::actionlib_msgs::GoalStatusArray;",
            " use crate::static_messages::MUTEX_LOCK_FAIL;",
            " use crate::{Action, GoalBody};",
            "+use rosrust_msg::actionlib_msgs::GoalStatusArray;",
            " use std::collections::BTreeMap;",
            " use std::sync::{Arc, Mutex};",
            " ",
            " type Tracker<T> = Arc<Mutex<StatusTracker<GoalBody<T>>>>;",
            " ",
            " pub struct StatusList<T: Action> {",
            "     timeout: i64,"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/goal_status.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/goal_status.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/goal_status.rs",
            "@@ -1,8 +1,8 @@",
            "-use crate::msg::actionlib_msgs::{GoalID, GoalStatus as GoalStatusRaw};",
            "+use rosrust_msg::actionlib_msgs::{GoalID, GoalStatus as GoalStatusRaw};",
            " use std::convert::{TryFrom, TryInto};",
            " ",
            " // TODO: consider removing \"Lost\"",
            " #[repr(u8)]",
            " #[derive(Copy, Clone, Debug, PartialEq, Eq)]",
            " pub enum GoalState {",
            "     Pending = GoalStatusRaw::PENDING,"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_actionlib/src/lib.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_actionlib/src/lib.rs",
            "+++ /home/rosrust-0.9.5/rosrust_actionlib/src/lib.rs",
            "@@ -1,21 +1,21 @@",
            " pub use self::action_client::{ActionClient, ClientGoalHandle, SimpleActionClient};",
            " pub use self::action_server::ActionServer;",
            " pub use self::goal_status::{GoalState, GoalStatus};",
            "-pub use msg::actionlib_msgs::GoalID;",
            "-pub use msg::std_msgs::Header;",
            " #[doc(hidden)]",
            " pub use paste;",
            "+pub use rosrust_msg::actionlib_msgs::GoalID;",
            "+pub use rosrust_msg::std_msgs::Header;",
            " ",
            " pub mod action_client;",
            " pub mod action_server;",
            " mod goal_status;",
            "-mod msg;",
            " #[macro_use]",
            " mod macros;",
            "+mod impls;",
            " mod static_messages;",
            " ",
            " pub trait Action: rosrust::Message {",
            "     type Goal: ActionGoal;",
            "     type Result: ActionResponse;",
            "     type Feedback: ActionResponse;",
            " ",
            "@@ -28,29 +28,29 @@",
            " ",
            "     fn into_goal(self) -> Goal<Self::Body>;",
            "     fn from_goal(t: Goal<Self::Body>) -> Self;",
            " }",
            " ",
            " #[derive(Clone, Default)]",
            " pub struct Goal<T> {",
            "-    pub header: msg::std_msgs::Header,",
            "+    pub header: Header,",
            "     pub id: GoalID,",
            "     pub body: T,",
            " }",
            " ",
            " pub trait ActionResponse: rosrust::Message {",
            "     type Body: rosrust::Message;",
            " ",
            "     fn into_response(self) -> Response<Self::Body>;",
            "     fn from_response(t: Response<Self::Body>) -> Self;",
            " }",
            " ",
            " #[derive(Clone, Default)]",
            " pub struct Response<T> {",
            "-    pub header: msg::std_msgs::Header,",
            "+    pub header: Header,",
            "     pub status: GoalStatus,",
            "     pub body: T,",
            " }",
            " ",
            " type GoalBody<T> = <<T as Action>::Goal as ActionGoal>::Body;",
            " type GoalType<T> = Goal<GoalBody<T>>;",
            " type ResultBody<T> = <<T as Action>::Result as ActionResponse>::Body;"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/error.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/error.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/error.rs",
            "@@ -1,14 +1,16 @@",
            "-#![allow(deprecated)]",
            "-",
            "-error_chain! {",
            "+error_chain::error_chain! {",
            "     foreign_links {",
            "         Regex(::regex::Error);",
            "     }",
            " ",
            "     errors {",
            "         MessageNotFound(msg: String, folders: String) {",
            "             description(\"message not found in provided directories\")",
            "             display(\"message {} not found in provided directories\\nDirectories:\\n{}\", msg, folders)",
            "         }",
            "+        PackageNameInvalid(package: String) {",
            "+            description(\"referenced package does not have a valid name. Look at ROS REP 144 for more details.\")",
            "+            display(\"package '{}' does not have a valid name. Look at ROS REP 144 for more details.\", package)",
            "+        }",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/genmsg.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/genmsg.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/genmsg.rs",
            "@@ -1,47 +1,78 @@",
            " use crate::error::Result;",
            " use crate::helpers;",
            "+use crate::helpers::MessageMap;",
            "+use crate::message_path::MessagePath;",
            " use crate::output_layout;",
            "-use std::collections::HashSet;",
            "+use std::collections::{HashMap, HashSet};",
            "+use std::convert::TryInto;",
            " ",
            "-pub fn depend_on_messages(folders: &[&str], messages: &[&str]) -> Result<output_layout::Layout> {",
            "+pub fn depend_on_messages(",
            "+    ignore_bad_messages: bool,",
            "+    folders: &[&str],",
            "+    messages: &[&str],",
            "+) -> Result<output_layout::Layout> {",
            "+    let message_map = message_names_to_message_map(ignore_bad_messages, folders, messages)?;",
            "+    validate_message_paths(&message_map)?;",
            "+    message_map_to_layout(&message_map)",
            "+}",
            "+",
            "+fn message_names_to_message_map(",
            "+    ignore_bad_messages: bool,",
            "+    folders: &[&str],",
            "+    messages: &[&str],",
            "+) -> Result<MessageMap> {",
            "+    let message_pairs = messages",
            "+        .iter()",
            "+        .copied()",
            "+        .map(TryInto::try_into)",
            "+        .collect::<Result<Vec<MessagePath>>>()?;",
            "+    helpers::get_message_map(ignore_bad_messages, folders, &message_pairs)",
            "+}",
            "+",
            "+fn validate_message_paths(message_map: &MessageMap) -> Result<()> {",
            "+    for message in message_map.messages.keys() {",
            "+        message.validate()?;",
            "+    }",
            "+    for message in message_map.services.keys() {",
            "+        message.validate()?;",
            "+    }",
            "+    Ok(())",
            "+}",
            "+",
            "+fn message_map_to_layout(message_map: &MessageMap) -> Result<output_layout::Layout> {",
            "     let mut output = output_layout::Layout {",
            "         packages: Vec::new(),",
            "     };",
            "-    let mut message_pairs = Vec::<(&str, &str)>::new();",
            "-    for message in messages {",
            "-        message_pairs.push(string_into_pair(message)?);",
            "-    }",
            "-    let message_map = helpers::get_message_map(folders, &message_pairs)?;",
            "     let hashes = helpers::calculate_md5(&message_map)?;",
            "     let packages = message_map",
            "         .messages",
            "-        .iter()",
            "-        .map(|(&(ref pack, ref _name), _value)| pack.clone())",
            "+        .keys()",
            "+        .map(|message| message.package.clone())",
            "         .chain(",
            "             message_map",
            "                 .services",
            "-                .iter()",
            "-                .map(|&(ref pack, ref _name)| pack.clone()),",
            "+                .keys()",
            "+                .map(|message| message.package.clone()),",
            "         )",
            "         .collect::<HashSet<String>>();",
            "     for package in packages {",
            "         let mut package_data = output_layout::Package {",
            "             name: package.clone(),",
            "             messages: Vec::new(),",
            "             services: Vec::new(),",
            "         };",
            "         let names = message_map",
            "             .messages",
            "             .iter()",
            "-            .filter(|&(&(ref pack, ref _name), _value)| pack == &package)",
            "-            .map(|(&(ref _pack, ref name), _value)| name.clone())",
            "-            .collect::<HashSet<String>>();",
            "-        for name in &names {",
            "-            let key = (package.clone(), name.clone());",
            "+            .filter(|&(message, _value)| &message.package == &package)",
            "+            .map(|(message, value)| (message.name.clone(), value.source.clone()))",
            "+            .collect::<HashMap<String, String>>();",
            "+        for (name, source) in names {",
            "+            let key = MessagePath::new(&package, name);",
            "             let message = message_map",
            "                 .messages",
            "                 .get(&key)",
            "                 .expect(\"Internal implementation contains mismatch in map keys\")",
            "                 .clone();",
            "             let md5sum = hashes",
            "                 .get(&key)",
            "@@ -51,47 +82,33 @@",
            "                 helpers::generate_message_definition(&message_map.messages, &message)?;",
            "             let msg_type = message.get_type();",
            "             package_data.messages.push(output_layout::Message {",
            "                 message,",
            "                 msg_definition,",
            "                 msg_type,",
            "                 md5sum,",
            "+                source,",
            "             });",
            "         }",
            "         let names = message_map",
            "             .services",
            "             .iter()",
            "-            .filter(|&&(ref pack, ref _name)| pack == &package)",
            "-            .map(|&(ref _pack, ref name)| name.clone())",
            "-            .collect::<HashSet<String>>();",
            "-        for name in &names {",
            "+            .filter(|&(message, _value)| &message.package == &package)",
            "+            .map(|(message, value)| (message.name.clone(), value.source.clone()))",
            "+            .collect::<HashMap<String, String>>();",
            "+        for (name, source) in names {",
            "             let md5sum = hashes",
            "-                .get(&(package.clone(), name.clone()))",
            "+                .get(&MessagePath::new(&package, &name))",
            "                 .expect(\"Internal implementation contains mismatch in map keys\")",
            "                 .clone();",
            "             let msg_type = format!(\"{}/{}\", package, name);",
            "             package_data.services.push(output_layout::Service {",
            "-                name: name.clone(),",
            "+                name,",
            "                 md5sum,",
            "                 msg_type,",
            "+                source,",
            "             })",
            "         }",
            "         output.packages.push(package_data);",
            "     }",
            "     Ok(output)",
            " }",
            "-",
            "-fn string_into_pair(input: &str) -> Result<(&str, &str)> {",
            "-    let mut parts = input.splitn(2, '/');",
            "-    let package = match parts.next() {",
            "-        Some(v) => v,",
            "-        None => bail!(\"Package string constains no parts: {}\", input),",
            "-    };",
            "-    let name = match parts.next() {",
            "-        Some(v) => v,",
            "-        None => bail!(",
            "-            \"Package string needs to be in package/name format: {}\",",
            "-            input",
            "-        ),",
            "-    };",
            "-    Ok((package, name))",
            "-}"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/helpers.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/helpers.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/helpers.rs",
            "@@ -1,19 +1,21 @@",
            " use crate::error::{ErrorKind, Result, ResultExt};",
            "-use crate::msg::Msg;",
            "+use crate::message_path::MessagePath;",
            "+use crate::msg::{Msg, Srv};",
            "+use error_chain::bail;",
            " use lazy_static::lazy_static;",
            " use regex::RegexBuilder;",
            " use std;",
            " use std::collections::{HashMap, HashSet, LinkedList};",
            "-use std::fs::File;",
            "-use std::path::Path;",
            "+use std::fs::{read_dir, File};",
            "+use std::path::{Path, PathBuf};",
            " ",
            "-pub fn calculate_md5(message_map: &MessageMap) -> Result<HashMap<(String, String), String>> {",
            "-    let mut representations = HashMap::<(String, String), String>::new();",
            "-    let mut hashes = HashMap::<(String, String), String>::new();",
            "+pub fn calculate_md5(message_map: &MessageMap) -> Result<HashMap<MessagePath, String>> {",
            "+    let mut representations = HashMap::<MessagePath, String>::new();",
            "+    let mut hashes = HashMap::<MessagePath, String>::new();",
            "     while hashes.len() < message_map.messages.len() {",
            "         let mut changed = false;",
            "         for (key, value) in &message_map.messages {",
            "             if hashes.contains_key(key) {",
            "                 continue;",
            "             }",
            "             if let Ok(answer) = value.get_md5_representation(&hashes) {",
            "@@ -22,27 +24,27 @@",
            "                 changed = true;",
            "             }",
            "         }",
            "         if !changed {",
            "             break;",
            "         }",
            "     }",
            "-    for &(ref pack, ref name) in &message_map.services {",
            "-        let key_req = (pack.clone(), format!(\"{}Req\", name));",
            "-        let key_res = (pack.clone(), format!(\"{}Res\", name));",
            "+    for message in message_map.services.keys() {",
            "+        let key_req = MessagePath::new(&message.package, format!(\"{}Req\", message.name));",
            "+        let key_res = MessagePath::new(&message.package, format!(\"{}Res\", message.name));",
            "         let req = match representations.get(&key_req) {",
            "             Some(v) => v,",
            "             None => bail!(\"Message map does not contain all needed elements\"),",
            "         };",
            "         let res = match representations.get(&key_res) {",
            "             Some(v) => v,",
            "             None => bail!(\"Message map does not contain all needed elements\"),",
            "         };",
            "         hashes.insert(",
            "-            (pack.clone(), name.clone()),",
            "+            message.clone(),",
            "             calculate_md5_from_representation(&format!(\"{}{}\", req, res)),",
            "         );",
            "     }",
            "     if hashes.len() < message_map.messages.len() + message_map.services.len() {",
            "         bail!(\"Message map does not contain all needed elements\");",
            "     }",
            "     Ok(hashes)",
            "@@ -52,321 +54,424 @@",
            "     use md5::{Digest, Md5};",
            "     let mut hasher = Md5::new();",
            "     hasher.input(v);",
            "     hex::encode(hasher.result())",
            " }",
            " ",
            " pub fn generate_message_definition<S: std::hash::BuildHasher>(",
            "-    message_map: &HashMap<(String, String), Msg, S>,",
            "+    message_map: &HashMap<MessagePath, Msg, S>,",
            "     message: &Msg,",
            " ) -> Result<String> {",
            "-    let mut handled_messages = HashSet::<(String, String)>::new();",
            "+    let mut handled_messages = HashSet::<MessagePath>::new();",
            "     let mut result = message.source.clone();",
            "     let mut pending = message",
            "         .dependencies()",
            "         .into_iter()",
            "         .collect::<LinkedList<_>>();",
            "     while let Some(value) = pending.pop_front() {",
            "         if handled_messages.contains(&value) {",
            "             continue;",
            "         }",
            "         handled_messages.insert(value.clone());",
            "         result += \"\\n\\n========================================\";",
            "         result += \"========================================\";",
            "-        result += &format!(\"\\nMSG: {}/{}\\n\", value.0, value.1);",
            "+        result += &format!(\"\\nMSG: {}\\n\", value);",
            "         let message = match message_map.get(&value) {",
            "             Some(msg) => msg,",
            "             None => bail!(\"Message map does not contain all needed elements\"),",
            "         };",
            "         for dependency in message.dependencies() {",
            "             pending.push_back(dependency);",
            "         }",
            "         result += &message.source;",
            "     }",
            "     result += \"\\n\";",
            "     Ok(result)",
            " }",
            " ",
            " pub struct MessageMap {",
            "-    pub messages: HashMap<(String, String), Msg>,",
            "-    pub services: HashSet<(String, String)>,",
            "+    pub messages: HashMap<MessagePath, Msg>,",
            "+    pub services: HashMap<MessagePath, Srv>,",
            " }",
            " ",
            "-pub fn get_message_map(folders: &[&str], messages: &[(&str, &str)]) -> Result<MessageMap> {",
            "-    let mut msgs = HashMap::new();",
            "-    let mut srvs = HashSet::new();",
            "-    let mut pending = messages",
            "-        .iter()",
            "-        .map(|&(key, val)| (key.into(), val.into()))",
            "-        .collect::<Vec<(String, String)>>();",
            "-    while let Some(value) = pending.pop() {",
            "-        let package = value.0.clone();",
            "-        let name = value.1.clone();",
            "-        if !msgs.contains_key(&value) {",
            "-            match get_message(folders, &package, &name)? {",
            "-                MessageCase::Message(message) => {",
            "-                    for dependency in &message.dependencies() {",
            "-                        pending.push(dependency.clone());",
            "-                    }",
            "-                    msgs.insert(value, message);",
            "+pub fn get_message_map(",
            "+    ignore_bad_messages: bool,",
            "+    folders: &[&str],",
            "+    message_paths: &[MessagePath],",
            "+) -> Result<MessageMap> {",
            "+    let mut message_locations = HashMap::new();",
            "+    let mut service_locations = HashMap::new();",
            "+",
            "+    let mut messages_and_services = vec![];",
            "+    for folder in folders {",
            "+        messages_and_services.append(&mut find_all_messages_and_services(Path::new(folder)));",
            "+    }",
            "+",
            "+    for (message_path, file_path, message_type) in messages_and_services {",
            "+        match message_type {",
            "+            MessageType::Message => message_locations.insert(message_path, file_path),",
            "+            MessageType::Service => service_locations.insert(message_path, file_path),",
            "+        };",
            "+    }",
            "+",
            "+    let mut messages = HashMap::new();",
            "+    let mut services = HashMap::new();",
            "+    let mut pending = message_paths.to_vec();",
            "+    while let Some(message_path) = pending.pop() {",
            "+        if messages.contains_key(&message_path) {",
            "+            continue;",
            "+        }",
            "+        match get_message_or_service(",
            "+            ignore_bad_messages,",
            "+            folders,",
            "+            &message_locations,",
            "+            &service_locations,",
            "+            message_path,",
            "+        )? {",
            "+            MessageCase::Message(message) => {",
            "+                for dependency in &message.dependencies() {",
            "+                    pending.push(dependency.clone());",
            "+                }",
            "+                messages.insert(message.path.clone(), message);",
            "+            }",
            "+            MessageCase::Service(service, req, res) => {",
            "+                for dependency in &req.dependencies() {",
            "+                    pending.push(dependency.clone());",
            "                 }",
            "-                MessageCase::Service(service_name, req, res) => {",
            "-                    for dependency in &req.dependencies() {",
            "-                        pending.push(dependency.clone());",
            "-                    }",
            "-                    for dependency in &res.dependencies() {",
            "-                        pending.push(dependency.clone());",
            "-                    }",
            "-                    msgs.insert((package.clone(), req.name.clone()), req);",
            "-                    msgs.insert((package.clone(), res.name.clone()), res);",
            "-                    srvs.insert((package, service_name));",
            "+                for dependency in &res.dependencies() {",
            "+                    pending.push(dependency.clone());",
            "                 }",
            "-            };",
            "+                messages.insert(req.path.clone(), req);",
            "+                messages.insert(res.path.clone(), res);",
            "+                services.insert(service.path.clone(), service);",
            "+            }",
            "         }",
            "     }",
            "-    Ok(MessageMap {",
            "-        messages: msgs,",
            "-        services: srvs,",
            "-    })",
            "+    Ok(MessageMap { messages, services })",
            "+}",
            "+",
            "+enum MessageType {",
            "+    Message,",
            "+    Service,",
            "+}",
            "+",
            "+fn find_all_messages_and_services(root: &Path) -> Vec<(MessagePath, PathBuf, MessageType)> {",
            "+    if !root.is_dir() {",
            "+        return identify_message_or_service(root).into_iter().collect();",
            "+    }",
            "+    let mut items = vec![];",
            "+    if let Ok(children) = read_dir(root) {",
            "+        for child in children.filter_map(|v| v.ok()) {",
            "+            items.append(&mut find_all_messages_and_services(&child.path()));",
            "+        }",
            "+    }",
            "+    items",
            "+}",
            "+",
            "+fn identify_message_or_service(filename: &Path) -> Option<(MessagePath, PathBuf, MessageType)> {",
            "+    let extension = filename.extension()?;",
            "+    let message = filename.file_stem()?;",
            "+    let parent = filename.parent()?;",
            "+    let grandparent = parent.parent()?;",
            "+    let package = grandparent.file_name()?;",
            "+    if Some(extension) != parent.file_name() {",
            "+        return None;",
            "+    }",
            "+    let message_type = match extension.to_str() {",
            "+        Some(\"msg\") => MessageType::Message,",
            "+        Some(\"srv\") => MessageType::Service,",
            "+        _ => return None,",
            "+    };",
            "+    Some((",
            "+        MessagePath::new(package.to_str()?, message.to_str()?),",
            "+        filename.into(),",
            "+        message_type,",
            "+    ))",
            " }",
            " ",
            " enum MessageCase {",
            "     Message(Msg),",
            "-    Service(String, Msg, Msg),",
            "+    Service(Srv, Msg, Msg),",
            " }",
            " ",
            " lazy_static! {",
            "-    static ref IN_MEMORY_MESSAGES: HashMap<&'static str, &'static str> =",
            "+    static ref IN_MEMORY_MESSAGES: HashMap<MessagePath, &'static str> =",
            "         generate_in_memory_messages();",
            " }",
            " ",
            "-fn generate_in_memory_messages() -> HashMap<&'static str, &'static str> {",
            "+fn generate_in_memory_messages() -> HashMap<MessagePath, &'static str> {",
            "     let mut output = HashMap::new();",
            "     output.insert(",
            "-        \"rosgraph_msgs/Clock\",",
            "+        MessagePath::new(\"rosgraph_msgs\", \"Clock\"),",
            "         include_str!(\"msg_examples/rosgraph_msgs/msg/Clock.msg\"),",
            "     );",
            "     output.insert(",
            "-        \"rosgraph_msgs/Log\",",
            "+        MessagePath::new(\"rosgraph_msgs\", \"Log\"),",
            "         include_str!(\"msg_examples/rosgraph_msgs/msg/Log.msg\"),",
            "     );",
            "     output.insert(",
            "-        \"std_msgs/Header\",",
            "+        MessagePath::new(\"std_msgs\", \"Header\"),",
            "         include_str!(\"msg_examples/std_msgs/msg/Header.msg\"),",
            "     );",
            "     output",
            " }",
            " ",
            " #[allow(clippy::trivial_regex)]",
            "-fn get_message(folders: &[&str], package: &str, name: &str) -> Result<MessageCase> {",
            "+fn get_message_or_service(",
            "+    ignore_bad_messages: bool,",
            "+    folders: &[&str],",
            "+    message_locations: &HashMap<MessagePath, PathBuf>,",
            "+    service_locations: &HashMap<MessagePath, PathBuf>,",
            "+    message: MessagePath,",
            "+) -> Result<MessageCase> {",
            "     use std::io::Read;",
            "-    for folder in folders {",
            "-        let full_path = Path::new(&folder)",
            "-            .join(&package)",
            "-            .join(\"msg\")",
            "-            .join(&name)",
            "-            .with_extension(\"msg\");",
            "-        if let Ok(mut f) = File::open(&full_path) {",
            "+",
            "+    let package = &message.package;",
            "+    let name = &message.name;",
            "+",
            "+    if let Some(full_path) = message_locations.get(&message) {",
            "+        if let Ok(mut f) = File::open(full_path) {",
            "             let mut contents = String::new();",
            "             f.read_to_string(&mut contents)",
            "                 .chain_err(|| \"Failed to read file to string!\")?;",
            "-            return Msg::new(package, name, &contents).map(MessageCase::Message);",
            "+            return create_message(message, &contents, ignore_bad_messages)",
            "+                .map(MessageCase::Message);",
            "         }",
            "-        let full_path = Path::new(&folder)",
            "-            .join(&package)",
            "-            .join(\"srv\")",
            "-            .join(&name)",
            "-            .with_extension(\"srv\");",
            "-        if let Ok(mut f) = File::open(&full_path) {",
            "+    }",
            "+    if let Some(full_path) = service_locations.get(&message) {",
            "+        if let Ok(mut f) = File::open(full_path) {",
            "             let mut contents = String::new();",
            "             f.read_to_string(&mut contents)",
            "                 .chain_err(|| \"Failed to read file to string!\")?;",
            "             let re = RegexBuilder::new(\"^---$\").multi_line(true).build()?;",
            "-            let mut parts = re.split(&contents);",
            "-            let req = match parts.next() {",
            "-                Some(v) => v,",
            "-                None => bail!(\"Service needs to have content\"),",
            "+            let (req, res) = match re.split(&contents).collect::<Vec<_>>().as_slice() {",
            "+                &[req] => (req, \"\"),",
            "+                &[req, res] => (req, res),",
            "+                &[] => bail!(\"Service {} does not have any content\", message),",
            "+                v => bail!(\"Service {} is split into {} parts\", message, v.len()),",
            "             };",
            "-            let res = match parts.next() {",
            "-                Some(v) => v,",
            "-                None => \"\",",
            "+            let req = create_message(",
            "+                MessagePath::new(package, format!(\"{}Req\", name)),",
            "+                req,",
            "+                ignore_bad_messages,",
            "+            )?;",
            "+            let res = create_message(",
            "+                MessagePath::new(package, format!(\"{}Res\", name)),",
            "+                res,",
            "+                ignore_bad_messages,",
            "+            )?;",
            "+            let service = Srv {",
            "+                path: message,",
            "+                source: contents,",
            "             };",
            "-            if parts.next().is_some() {",
            "-                bail!(\"Too many splits in service\");",
            "-            }",
            "-            let req = Msg::new(package, &format!(\"{}Req\", name), req)?;",
            "-            let res = Msg::new(package, &format!(\"{}Res\", name), res)?;",
            "-            return Ok(MessageCase::Service(name.into(), req, res));",
            "+            return Ok(MessageCase::Service(service, req, res));",
            "         }",
            "     }",
            "-    if let Some(contents) = IN_MEMORY_MESSAGES.get(format!(\"{}/{}\", package, name).as_str()) {",
            "-        return Msg::new(package, name, contents).map(MessageCase::Message);",
            "+    if let Some(contents) = IN_MEMORY_MESSAGES.get(&message) {",
            "+        return Msg::new(message, contents).map(MessageCase::Message);",
            "+    }",
            "+    if ignore_bad_messages {",
            "+        return Msg::new(message, \"\").map(MessageCase::Message);",
            "     }",
            "     bail!(ErrorKind::MessageNotFound(",
            "-        format!(\"{}/{}\", package, name),",
            "-        folders.join(\"\\n\")",
            "-    ));",
            "+        message.to_string(),",
            "+        folders.join(\"\\n\"),",
            "+    ))",
            "+}",
            "+",
            "+fn create_message(message: MessagePath, contents: &str, ignore_bad_messages: bool) -> Result<Msg> {",
            "+    Msg::new(message.clone(), contents).or_else(|err| {",
            "+        if ignore_bad_messages {",
            "+            Msg::new(message, \"\")",
            "+        } else {",
            "+            Err(err)",
            "+        }",
            "+    })",
            " }",
            " ",
            " #[cfg(test)]",
            " mod tests {",
            "     use super::*;",
            " ",
            "     static FILEPATH: &'static str = \"src/msg_examples\";",
            " ",
            "     #[test]",
            "     fn get_message_map_fetches_leaf_message() {",
            "-        let message_map = get_message_map(&[FILEPATH], &[(\"geometry_msgs\", \"Point\")])",
            "-            .unwrap()",
            "-            .messages;",
            "+        let message_map = get_message_map(",
            "+            false,",
            "+            &[FILEPATH],",
            "+            &[MessagePath::new(\"geometry_msgs\", \"Point\")],",
            "+        )",
            "+        .unwrap()",
            "+        .messages;",
            "         assert_eq!(message_map.len(), 1);",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Point\".into()),));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Point\")));",
            "     }",
            " ",
            "     #[test]",
            "     fn get_message_map_fetches_message_and_dependencies() {",
            "-        let message_map = get_message_map(&[FILEPATH], &[(\"geometry_msgs\", \"Pose\")])",
            "-            .unwrap()",
            "-            .messages;",
            "+        let message_map = get_message_map(",
            "+            false,",
            "+            &[FILEPATH],",
            "+            &[MessagePath::new(\"geometry_msgs\", \"Pose\")],",
            "+        )",
            "+        .unwrap()",
            "+        .messages;",
            "         assert_eq!(message_map.len(), 3);",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Point\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Pose\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Quaternion\".into()),));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Point\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Pose\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Quaternion\")));",
            "     }",
            " ",
            "     #[test]",
            "     fn get_message_map_traverses_whole_dependency_tree() {",
            "-        let message_map = get_message_map(&[FILEPATH], &[(\"geometry_msgs\", \"PoseStamped\")])",
            "-            .unwrap()",
            "-            .messages;",
            "+        let message_map = get_message_map(",
            "+            false,",
            "+            &[FILEPATH],",
            "+            &[MessagePath::new(\"geometry_msgs\", \"PoseStamped\")],",
            "+        )",
            "+        .unwrap()",
            "+        .messages;",
            "         assert_eq!(message_map.len(), 5);",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Point\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Pose\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"PoseStamped\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Quaternion\".into()),));",
            "-        assert!(message_map.contains_key(&(\"std_msgs\".into(), \"Header\".into()),));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Point\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Pose\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"PoseStamped\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Quaternion\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"std_msgs\", \"Header\")));",
            "     }",
            " ",
            "     #[test]",
            "     fn get_message_map_traverses_all_passed_messages_dependency_tree() {",
            "         let message_map = get_message_map(",
            "+            false,",
            "             &[FILEPATH],",
            "             &[",
            "-                (\"geometry_msgs\", \"PoseStamped\"),",
            "-                (\"sensor_msgs\", \"Imu\"),",
            "-                (\"rosgraph_msgs\", \"Clock\"),",
            "-                (\"rosgraph_msgs\", \"Log\"),",
            "+                MessagePath::new(\"geometry_msgs\", \"PoseStamped\"),",
            "+                MessagePath::new(\"sensor_msgs\", \"Imu\"),",
            "+                MessagePath::new(\"rosgraph_msgs\", \"Clock\"),",
            "+                MessagePath::new(\"rosgraph_msgs\", \"Log\"),",
            "             ],",
            "         )",
            "         .unwrap()",
            "         .messages;",
            "         assert_eq!(message_map.len(), 9);",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Vector3\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Point\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Pose\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"PoseStamped\".into()),));",
            "-        assert!(message_map.contains_key(&(\"geometry_msgs\".into(), \"Quaternion\".into()),));",
            "-        assert!(message_map.contains_key(&(\"sensor_msgs\".into(), \"Imu\".into()),));",
            "-        assert!(message_map.contains_key(&(\"std_msgs\".into(), \"Header\".into()),));",
            "-        assert!(message_map.contains_key(&(\"rosgraph_msgs\".into(), \"Clock\".into()),));",
            "-        assert!(message_map.contains_key(&(\"rosgraph_msgs\".into(), \"Log\".into()),));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Vector3\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Point\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Pose\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"PoseStamped\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"geometry_msgs\", \"Quaternion\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"sensor_msgs\", \"Imu\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"std_msgs\", \"Header\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"rosgraph_msgs\", \"Clock\")));",
            "+        assert!(message_map.contains_key(&MessagePath::new(\"rosgraph_msgs\", \"Log\")));",
            "     }",
            " ",
            "     #[test]",
            "     fn calculate_md5_works() {",
            "         let message_map = get_message_map(",
            "+            false,",
            "             &[FILEPATH],",
            "             &[",
            "-                (\"geometry_msgs\", \"PoseStamped\"),",
            "-                (\"sensor_msgs\", \"Imu\"),",
            "-                (\"rosgraph_msgs\", \"Clock\"),",
            "-                (\"rosgraph_msgs\", \"Log\"),",
            "+                MessagePath::new(\"geometry_msgs\", \"PoseStamped\"),",
            "+                MessagePath::new(\"sensor_msgs\", \"Imu\"),",
            "+                MessagePath::new(\"rosgraph_msgs\", \"Clock\"),",
            "+                MessagePath::new(\"rosgraph_msgs\", \"Log\"),",
            "             ],",
            "         )",
            "         .unwrap();",
            "         let hashes = calculate_md5(&message_map).unwrap();",
            "         assert_eq!(hashes.len(), 9);",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"geometry_msgs\".into(), \"Vector3\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"Vector3\"))",
            "                 .unwrap(),",
            "             \"4a842b65f413084dc2b10fb484ea7f17\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"geometry_msgs\".into(), \"Point\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"Point\"))",
            "                 .unwrap(),",
            "             \"4a842b65f413084dc2b10fb484ea7f17\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"geometry_msgs\".into(), \"Quaternion\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"Quaternion\"))",
            "                 .unwrap(),",
            "             \"a779879fadf0160734f906b8c19c7004\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"geometry_msgs\".into(), \"Pose\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"Pose\"))",
            "                 .unwrap(),",
            "             \"e45d45a5a1ce597b249e23fb30fc871f\".to_owned()",
            "         );",
            "         assert_eq!(",
            "-            *hashes.get(&(\"std_msgs\".into(), \"Header\".into())).unwrap(),",
            "+            *hashes.get(&MessagePath::new(\"std_msgs\", \"Header\")).unwrap(),",
            "             \"2176decaecbce78abc3b96ef049fabed\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"geometry_msgs\".into(), \"PoseStamped\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"PoseStamped\"))",
            "                 .unwrap(),",
            "             \"d3812c3cbc69362b77dc0b19b345f8f5\".to_owned()",
            "         );",
            "         assert_eq!(",
            "-            *hashes.get(&(\"sensor_msgs\".into(), \"Imu\".into())).unwrap(),",
            "+            *hashes.get(&MessagePath::new(\"sensor_msgs\", \"Imu\")).unwrap(),",
            "             \"6a62c6daae103f4ff57a132d6f95cec2\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"rosgraph_msgs\".into(), \"Clock\".into()))",
            "+                .get(&MessagePath::new(\"rosgraph_msgs\", \"Clock\"))",
            "                 .unwrap(),",
            "             \"a9c97c1d230cfc112e270351a944ee47\".to_owned()",
            "         );",
            "         assert_eq!(",
            "-            *hashes.get(&(\"rosgraph_msgs\".into(), \"Log\".into())).unwrap(),",
            "+            *hashes",
            "+                .get(&MessagePath::new(\"rosgraph_msgs\", \"Log\"))",
            "+                .unwrap(),",
            "             \"acffd30cd6b6de30f120938c17c593fb\".to_owned()",
            "         );",
            "     }",
            " ",
            "     #[test]",
            "     fn generate_message_definition_works() {",
            "-        let message_map = get_message_map(&[FILEPATH], &[(\"geometry_msgs\", \"Vector3\")])",
            "-            .unwrap()",
            "-            .messages;",
            "+        let message_map = get_message_map(",
            "+            false,",
            "+            &[FILEPATH],",
            "+            &[MessagePath::new(\"geometry_msgs\", \"Vector3\")],",
            "+        )",
            "+        .unwrap()",
            "+        .messages;",
            "         let definition = generate_message_definition(",
            "             &message_map,",
            "             &message_map",
            "-                .get(&(\"geometry_msgs\".into(), \"Vector3\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"Vector3\"))",
            "                 .unwrap(),",
            "         )",
            "         .unwrap();",
            "         assert_eq!(",
            "             definition,",
            "             \"# This represents a vector in free space. \\n# It is only meant to represent \\",
            "              a direction. Therefore, it does not\\n# make sense to apply a translation to \\",
            "              it (e.g., when applying a \\n# generic rigid transformation to a Vector3, tf2 \\",
            "              will only apply the\\n# rotation). If you want your data to be translatable \\",
            "              too, use the\\n# geometry_msgs/Point message instead.\\n\\nfloat64 x\\nfloat64 \\",
            "              y\\nfloat64 z\\n\"",
            "         );",
            "-        let message_map = get_message_map(&[FILEPATH], &[(\"geometry_msgs\", \"PoseStamped\")])",
            "-            .unwrap()",
            "-            .messages;",
            "+        let message_map = get_message_map(",
            "+            false,",
            "+            &[FILEPATH],",
            "+            &[MessagePath::new(\"geometry_msgs\", \"PoseStamped\")],",
            "+        )",
            "+        .unwrap()",
            "+        .messages;",
            "         let definition = generate_message_definition(",
            "             &message_map,",
            "             &message_map",
            "-                .get(&(\"geometry_msgs\".into(), \"PoseStamped\".into()))",
            "+                .get(&MessagePath::new(\"geometry_msgs\", \"PoseStamped\"))",
            "                 .unwrap(),",
            "         )",
            "         .unwrap();",
            "         assert_eq!(",
            "             definition,",
            "             \"# A Pose with reference coordinate frame and timestamp\\n\\",
            " Header header\\n\\",
            "@@ -414,43 +519,45 @@",
            " \"",
            "         );",
            "     }",
            " ",
            "     #[test]",
            "     fn calculate_md5_works_for_services() {",
            "         let message_map = get_message_map(",
            "+            false,",
            "             &[FILEPATH],",
            "             &[",
            "-                (\"diagnostic_msgs\", \"AddDiagnostics\"),",
            "-                (\"simple_srv\", \"Something\"),",
            "+                MessagePath::new(\"diagnostic_msgs\", \"AddDiagnostics\"),",
            "+                MessagePath::new(\"simple_srv\", \"Something\"),",
            "             ],",
            "         )",
            "         .unwrap();",
            "         let hashes = calculate_md5(&message_map).unwrap();",
            "         assert_eq!(hashes.len(), 11);",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"diagnostic_msgs\".into(), \"AddDiagnostics\".into()))",
            "+                .get(&MessagePath::new(\"diagnostic_msgs\", \"AddDiagnostics\"))",
            "                 .unwrap(),",
            "             \"e6ac9bbde83d0d3186523c3687aecaee\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             *hashes",
            "-                .get(&(\"simple_srv\".into(), \"Something\".into()))",
            "+                .get(&MessagePath::new(\"simple_srv\", \"Something\"))",
            "                 .unwrap(),",
            "             \"63715c08716373d8624430cde1434192\".to_owned()",
            "         );",
            "     }",
            " ",
            "     #[test]",
            "     fn parse_tricky_srv_files() {",
            "         get_message_map(",
            "+            false,",
            "             &[FILEPATH],",
            "             &[",
            "-                (\"empty_srv\", \"Empty\"),",
            "-                (\"empty_req_srv\", \"EmptyRequest\"),",
            "-                (\"tricky_comment_srv\", \"TrickyComment\"),",
            "+                MessagePath::new(\"empty_srv\", \"Empty\"),",
            "+                MessagePath::new(\"empty_req_srv\", \"EmptyRequest\"),",
            "+                MessagePath::new(\"tricky_comment_srv\", \"TrickyComment\"),",
            "             ],",
            "         )",
            "         .unwrap();",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/lib.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/lib.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/lib.rs",
            "@@ -1,16 +1,15 @@",
            " #![recursion_limit = \"1024\"]",
            " ",
            " extern crate proc_macro;",
            "-#[macro_use]",
            "-extern crate error_chain;",
            " ",
            " mod error;",
            " mod genmsg;",
            " mod helpers;",
            "+mod message_path;",
            " mod msg;",
            " mod output_layout;",
            " mod rosmsg_include;",
            " ",
            " use proc_macro::TokenStream;",
            " ",
            " #[proc_macro]",
            "@@ -23,13 +22,14 @@",
            "                 messages.push(next_item);",
            "                 next_item = String::new();",
            "             }",
            "             s => next_item += s,",
            "         }",
            "     }",
            "     let is_internal = next_item == \"INTERNAL\";",
            "-    if !is_internal && next_item != \"\" {",
            "+    let ignore_bad = next_item == \"IGNORE_BAD\";",
            "+    if !is_internal && !ignore_bad && next_item != \"\" {",
            "         messages.push(next_item);",
            "     }",
            "     let message_refs = messages.iter().map(String::as_str).collect::<Vec<&str>>();",
            "-    rosmsg_include::depend_on_messages(&message_refs, is_internal)",
            "+    rosmsg_include::depend_on_messages(&message_refs, is_internal, ignore_bad)",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/msg.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/msg.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/msg.rs",
            "@@ -1,66 +1,98 @@",
            " use crate::error::{Result, ResultExt};",
            "+use crate::message_path::MessagePath;",
            " use lazy_static::lazy_static;",
            " use proc_macro2::{Literal, Span};",
            " use quote::{quote, ToTokens};",
            " use regex::Regex;",
            " use std::collections::{BTreeSet, HashMap};",
            " use syn::Ident;",
            " ",
            "-#[derive(Clone)]",
            "+#[derive(Clone, Debug)]",
            " pub struct Msg {",
            "-    pub package: String,",
            "-    pub name: String,",
            "+    pub path: MessagePath,",
            "     pub fields: Vec<FieldInfo>,",
            "     pub source: String,",
            " }",
            " ",
            "+#[derive(Clone, Debug)]",
            "+pub struct Srv {",
            "+    pub path: MessagePath,",
            "+    pub source: String,",
            "+}",
            "+",
            " impl Msg {",
            "-    pub fn new(package: &str, name: &str, source: &str) -> Result<Msg> {",
            "+    pub fn new(path: MessagePath, source: &str) -> Result<Msg> {",
            "         let fields = match_lines(source)?;",
            "         Ok(Msg {",
            "-            package: package.to_owned(),",
            "-            name: name.to_owned(),",
            "+            path,",
            "             fields,",
            "             source: source.trim().into(),",
            "         })",
            "     }",
            " ",
            "     pub fn name_ident(&self) -> Ident {",
            "-        Ident::new(&self.name, Span::call_site())",
            "+        Ident::new(&self.path.name, Span::call_site())",
            "     }",
            " ",
            "     pub fn token_stream<T: ToTokens>(&self, crate_prefix: &T) -> impl ToTokens {",
            "         let name = self.name_ident();",
            "         let fields = self",
            "             .fields",
            "             .iter()",
            "             .map(|v| v.field_token_stream(crate_prefix))",
            "             .collect::<Vec<_>>();",
            "         let field_defaults = self",
            "             .fields",
            "             .iter()",
            "             .map(|v| v.field_default_token_stream(crate_prefix))",
            "             .collect::<Vec<_>>();",
            "+        let fields_for_eq_and_debug = self",
            "+            .fields",
            "+            .iter()",
            "+            .filter_map(|v| v.field_name_eq_and_debug_token_stream())",
            "+            .collect::<Vec<_>>();",
            "+        let fields_partialeq = fields_for_eq_and_debug",
            "+            .iter()",
            "+            .map(|(_, peq, _)| quote! { self.#peq == other.#peq })",
            "+            .collect::<Vec<_>>();",
            "+        let fields_debug = fields_for_eq_and_debug",
            "+            .iter()",
            "+            .map(|(name, _, dbg)| quote! { .field(stringify!(#name), #dbg) })",
            "+            .collect::<Vec<_>>();",
            "         let const_fields = self",
            "             .fields",
            "             .iter()",
            "             .map(|v| v.const_token_stream(crate_prefix))",
            "             .collect::<Vec<_>>();",
            "         quote! {",
            "             #[allow(dead_code, non_camel_case_types, non_snake_case)]",
            "-            #[derive(Clone, Debug, PartialEq)]",
            "+            #[derive(Clone)]",
            "             pub struct #name {",
            "                 #(#fields)*",
            "             }",
            " ",
            "             impl #name {",
            "                 #(#const_fields)*",
            "             }",
            " ",
            "+            impl std::cmp::PartialEq<Self> for #name {",
            "+                fn eq(&self, other: &Self) -> bool {",
            "+                    true #(&& #fields_partialeq)*",
            "+                }",
            "+            }",
            "+",
            "+            impl std::fmt::Debug for #name {",
            "+                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
            "+                    f.debug_struct(stringify!(#name))",
            "+                        #(#fields_debug)*",
            "+                        .finish()",
            "+                }",
            "+            }",
            "+",
            "             impl Default for #name {",
            "                 fn default() -> Self {",
            "                     Self {",
            "                         #(#field_defaults)*",
            "                     }",
            "                 }",
            "             }",
            "@@ -89,55 +121,55 @@",
            "             Ok(Self {",
            "                 #(#fields)*",
            "             })",
            "         }",
            "     }",
            " ",
            "     pub fn get_type(&self) -> String {",
            "-        format!(\"{}/{}\", self.package, self.name)",
            "+        format!(\"{}/{}\", self.path.package, self.path.name)",
            "     }",
            " ",
            "-    pub fn dependencies(&self) -> Vec<(String, String)> {",
            "+    pub fn dependencies(&self) -> Vec<MessagePath> {",
            "         self.fields",
            "             .iter()",
            "             .filter_map(|field| match field.datatype {",
            "-                DataType::LocalStruct(ref name) => Some((self.package.clone(), name.clone())),",
            "-                DataType::RemoteStruct(ref pkg, ref name) => Some((pkg.clone(), name.clone())),",
            "+                DataType::LocalStruct(ref name) => Some(MessagePath::new(&self.path.package, name)),",
            "+                DataType::RemoteStruct(ref message) => Some(message.clone()),",
            "                 _ => None,",
            "             })",
            "             .collect()",
            "     }",
            " ",
            "     #[cfg(test)]",
            "     pub fn calculate_md5(",
            "         &self,",
            "-        hashes: &HashMap<(String, String), String>,",
            "+        hashes: &HashMap<MessagePath, String>,",
            "     ) -> ::std::result::Result<String, ()> {",
            "         use md5::{Digest, Md5};",
            " ",
            "         let mut hasher = Md5::new();",
            "         hasher.input(&self.get_md5_representation(hashes)?);",
            "         Ok(hex::encode(hasher.result().as_slice()))",
            "     }",
            " ",
            "     pub fn get_md5_representation(",
            "         &self,",
            "-        hashes: &HashMap<(String, String), String>,",
            "+        hashes: &HashMap<MessagePath, String>,",
            "     ) -> ::std::result::Result<String, ()> {",
            "         let constants = self",
            "             .fields",
            "             .iter()",
            "             .filter(|v| v.is_constant())",
            "-            .map(|v| v.md5_string(&self.package, hashes))",
            "+            .map(|v| v.md5_string(&self.path.package, hashes))",
            "             .collect::<::std::result::Result<Vec<String>, ()>>()?;",
            "         let fields = self",
            "             .fields",
            "             .iter()",
            "             .filter(|v| !v.is_constant())",
            "-            .map(|v| v.md5_string(&self.package, hashes))",
            "+            .map(|v| v.md5_string(&self.path.package, hashes))",
            "             .collect::<::std::result::Result<Vec<String>, ()>>()?;",
            "         let representation = constants",
            "             .into_iter()",
            "             .chain(fields)",
            "             .collect::<Vec<_>>()",
            "             .join(\"\\n\");",
            "         Ok(representation)",
            "@@ -264,15 +296,15 @@",
            "         captures.get(3).unwrap().as_str().into(),",
            "     ))",
            " }",
            " ",
            " fn match_const_numeric(data: &str) -> Option<(FieldLine, String)> {",
            "     lazy_static! {",
            "         static ref MATCHER: String = format!(",
            "-            r\"^{}{}{}{}={}(-?[0-9]+)$\",",
            "+            r\"^{}{}{}{}={}(-?[0-9\\.eE\\+\\-]+)$\",",
            "             FIELD_TYPE, ANY_WHITESPACE, FIELD_NAME, IGNORE_WHITESPACE, IGNORE_WHITESPACE",
            "         );",
            "         static ref RE: Regex = Regex::new(&MATCHER).unwrap();",
            "     }",
            "     let captures = match RE.captures(data) {",
            "         Some(v) => v,",
            "         None => return None,",
            "@@ -399,33 +431,53 @@",
            "             FieldCase::Unit => quote! { pub #name: #datatype, },",
            "             FieldCase::Vector => quote! { pub #name: Vec<#datatype>, },",
            "             FieldCase::Array(l) => quote! { pub #name: [#datatype; #l], },",
            "             FieldCase::Const(_) => quote! {},",
            "         }",
            "     }",
            " ",
            "+    pub fn field_name_eq_and_debug_token_stream(",
            "+        &self,",
            "+    ) -> Option<(impl ToTokens, impl ToTokens, impl ToTokens)> {",
            "+        let name = self.create_identifier(Span::call_site());",
            "+        match self.case {",
            "+            FieldCase::Unit | FieldCase::Vector => {",
            "+                Some((quote! { #name }, quote! { #name }, quote! { &self.#name }))",
            "+            }",
            "+            FieldCase::Array(_) => Some((",
            "+                quote! { #name },",
            "+                quote! { #name[..] },",
            "+                quote! { &self.#name.iter().collect::<Vec<_>>() },",
            "+            )),",
            "+            FieldCase::Const(_) => None,",
            "+        }",
            "+    }",
            "+",
            "     pub fn field_default_token_stream<T: ToTokens>(&self, _crate_prefix: &T) -> impl ToTokens {",
            "         let name = self.create_identifier(Span::call_site());",
            "         match self.case {",
            "             FieldCase::Unit | FieldCase::Vector => quote! { #name: Default::default(), },",
            "-            FieldCase::Array(l) => quote! { #name: [Default::default(); #l], },",
            "+            FieldCase::Array(l) => {",
            "+                let instances = (0..l).map(|_| quote! {Default::default()});",
            "+                quote! { #name: [#(#instances),*], }",
            "+            }",
            "             FieldCase::Const(_) => quote! {},",
            "         }",
            "     }",
            " ",
            "     pub fn field_token_stream_encode<T: ToTokens>(&self, crate_prefix: &T) -> impl ToTokens {",
            "         let name = self.create_identifier(Span::call_site());",
            "         match self.case {",
            "             FieldCase::Unit => quote! { self.#name.encode(w.by_ref())?; },",
            "             FieldCase::Vector => match self.datatype {",
            "                 DataType::String",
            "                 | DataType::Time",
            "                 | DataType::Duration",
            "                 | DataType::LocalStruct(_)",
            "-                | DataType::RemoteStruct(_, _) => {",
            "+                | DataType::RemoteStruct(_) => {",
            "                     quote! { #crate_prefix rosmsg::encode_variable_slice(&self.#name, w.by_ref())?; }",
            "                 }",
            "                 _ => {",
            "                     quote! { #crate_prefix rosmsg::encode_variable_primitive_slice(&self.#name, w.by_ref())?; }",
            "                 }",
            "             },",
            "             FieldCase::Array(_l) => {",
            "@@ -440,15 +492,15 @@",
            "         match self.case {",
            "             FieldCase::Unit => quote! { #name: #crate_prefix rosmsg::RosMsg::decode(r.by_ref())?, },",
            "             FieldCase::Vector => match self.datatype {",
            "                 DataType::String",
            "                 | DataType::Time",
            "                 | DataType::Duration",
            "                 | DataType::LocalStruct(_)",
            "-                | DataType::RemoteStruct(_, _) => {",
            "+                | DataType::RemoteStruct(_) => {",
            "                     quote! { #name: #crate_prefix rosmsg::decode_variable_vec(r.by_ref())?, }",
            "                 }",
            "                 _ => {",
            "                     quote! { #name: #crate_prefix rosmsg::decode_variable_primitive_vec(r.by_ref())?, }",
            "                 }",
            "             },",
            "             FieldCase::Array(l) => {",
            "@@ -527,29 +579,29 @@",
            "             pub const #insides;",
            "         }",
            "     }",
            " ",
            "     fn md5_string(",
            "         &self,",
            "         package: &str,",
            "-        hashes: &HashMap<(String, String), String>,",
            "+        hashes: &HashMap<MessagePath, String>,",
            "     ) -> ::std::result::Result<String, ()> {",
            "         let datatype = self.datatype.md5_string(package, hashes)?;",
            "         Ok(match (self.datatype.is_builtin(), &self.case) {",
            "             (_, &FieldCase::Const(ref v)) => format!(\"{} {}={}\", datatype, self.name, v),",
            "             (false, _) | (_, &FieldCase::Unit) => format!(\"{} {}\", datatype, self.name),",
            "             (true, &FieldCase::Vector) => format!(\"{}[] {}\", datatype, self.name),",
            "             (true, &FieldCase::Array(l)) => format!(\"{}[{}] {}\", datatype, l, self.name),",
            "         })",
            "     }",
            " ",
            "     fn is_header(&self) -> bool {",
            "         self.case == FieldCase::Unit",
            "             && self.name == \"header\"",
            "-            && self.datatype == DataType::RemoteStruct(\"std_msgs\".into(), \"Header\".into())",
            "+            && self.datatype == DataType::RemoteStruct(MessagePath::new(\"std_msgs\", \"Header\"))",
            "     }",
            " ",
            "     fn new(datatype: &str, name: &str, case: FieldCase) -> Result<FieldInfo> {",
            "         Ok(FieldInfo {",
            "             datatype: parse_datatype(datatype)",
            "                 .ok_or_else(|| format!(\"Unsupported datatype: {}\", datatype))?,",
            "             name: name.to_owned(),",
            "@@ -571,15 +623,15 @@",
            "     U64,",
            "     F32,",
            "     F64,",
            "     String,",
            "     Time,",
            "     Duration,",
            "     LocalStruct(String),",
            "-    RemoteStruct(String, String),",
            "+    RemoteStruct(MessagePath),",
            " }",
            " ",
            " impl DataType {",
            "     pub fn token_stream<T: ToTokens>(&self, crate_prefix: &T) -> impl ToTokens {",
            "         match *self {",
            "             DataType::Bool => quote! { bool },",
            "             DataType::I8(_) => quote! { i8 },",
            "@@ -595,17 +647,17 @@",
            "             DataType::String => quote! { ::std::string::String },",
            "             DataType::Time => quote! { #crate_prefix Time },",
            "             DataType::Duration => quote! { #crate_prefix Duration },",
            "             DataType::LocalStruct(ref name) => {",
            "                 let name = Ident::new(&name, Span::call_site());",
            "                 quote! { #name }",
            "             }",
            "-            DataType::RemoteStruct(ref pkg, ref name) => {",
            "-                let name = Ident::new(&name, Span::call_site());",
            "-                let pkg = Ident::new(&pkg, Span::call_site());",
            "+            DataType::RemoteStruct(ref message) => {",
            "+                let name = Ident::new(&message.name, Span::call_site());",
            "+                let pkg = Ident::new(&message.package, Span::call_site());",
            "                 quote! { super::#pkg::#name }",
            "             }",
            "         }",
            "     }",
            " ",
            "     fn is_builtin(&self) -> bool {",
            "         match *self {",
            "@@ -619,22 +671,22 @@",
            "             | DataType::U32",
            "             | DataType::U64",
            "             | DataType::F32",
            "             | DataType::F64",
            "             | DataType::String",
            "             | DataType::Time",
            "             | DataType::Duration => true,",
            "-            DataType::LocalStruct(_) | DataType::RemoteStruct(_, _) => false,",
            "+            DataType::LocalStruct(_) | DataType::RemoteStruct(_) => false,",
            "         }",
            "     }",
            " ",
            "     fn md5_string(",
            "         &self,",
            "         package: &str,",
            "-        hashes: &HashMap<(String, String), String>,",
            "+        hashes: &HashMap<MessagePath, String>,",
            "     ) -> ::std::result::Result<String, ()> {",
            "         Ok(match *self {",
            "             DataType::Bool => \"bool\",",
            "             DataType::I8(true) => \"int8\",",
            "             DataType::I8(false) => \"byte\",",
            "             DataType::I16 => \"int16\",",
            "             DataType::I32 => \"int32\",",
            "@@ -646,20 +698,18 @@",
            "             DataType::U64 => \"uint64\",",
            "             DataType::F32 => \"float32\",",
            "             DataType::F64 => \"float64\",",
            "             DataType::String => \"string\",",
            "             DataType::Time => \"time\",",
            "             DataType::Duration => \"duration\",",
            "             DataType::LocalStruct(ref name) => hashes",
            "-                .get(&(package.to_owned(), name.clone()))",
            "+                .get(&MessagePath::new(package, name))",
            "                 .ok_or(())?",
            "                 .as_str(),",
            "-            DataType::RemoteStruct(ref pkg, ref name) => {",
            "-                hashes.get(&(pkg.clone(), name.clone())).ok_or(())?.as_str()",
            "-            }",
            "+            DataType::RemoteStruct(ref message) => hashes.get(&message).ok_or(())?.as_str(),",
            "         }",
            "         .into())",
            "     }",
            " }",
            " ",
            " fn parse_datatype(datatype: &str) -> Option<DataType> {",
            "     match datatype {",
            "@@ -675,42 +725,42 @@",
            "         \"uint32\" => Some(DataType::U32),",
            "         \"uint64\" => Some(DataType::U64),",
            "         \"float32\" => Some(DataType::F32),",
            "         \"float64\" => Some(DataType::F64),",
            "         \"string\" => Some(DataType::String),",
            "         \"time\" => Some(DataType::Time),",
            "         \"duration\" => Some(DataType::Duration),",
            "-        \"Header\" => Some(DataType::RemoteStruct(\"std_msgs\".into(), \"Header\".into())),",
            "+        \"Header\" => Some(DataType::RemoteStruct(MessagePath::new(",
            "+            \"std_msgs\", \"Header\",",
            "+        ))),",
            "         _ => {",
            "             let parts = datatype.split('/').collect::<Vec<_>>();",
            "             if parts.iter().any(|v| v.is_empty()) {",
            "                 return None;",
            "             }",
            "-            match parts.len() {",
            "-                2 => Some(DataType::RemoteStruct(",
            "-                    parts[0].to_owned(),",
            "-                    parts[1].to_owned(),",
            "-                )),",
            "-                1 => Some(DataType::LocalStruct(parts[0].to_owned())),",
            "+            match parts.as_slice() {",
            "+                &[package, name] => Some(DataType::RemoteStruct(MessagePath::new(package, name))),",
            "+                &[name] => Some(DataType::LocalStruct(name.into())),",
            "                 _ => None,",
            "             }",
            "         }",
            "     }",
            " }",
            " ",
            " #[cfg(test)]",
            " mod tests {",
            "     use super::*;",
            "     use std::collections::HashSet;",
            "+    use std::convert::TryInto;",
            " ",
            "     #[test]",
            "     fn datatype_md5_string_correct() {",
            "         let mut hashes = HashMap::new();",
            "-        hashes.insert((\"p1\".into(), \"xx\".into()), \"ABCD\".into());",
            "-        hashes.insert((\"p2\".into(), \"xx\".into()), \"EFGH\".into());",
            "+        hashes.insert(MessagePath::new(\"p1\", \"xx\"), \"ABCD\".into());",
            "+        hashes.insert(MessagePath::new(\"p2\", \"xx\"), \"EFGH\".into());",
            "         assert_eq!(",
            "             DataType::I64.md5_string(\"\", &hashes).unwrap(),",
            "             \"int64\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             DataType::F32.md5_string(\"\", &hashes).unwrap(),",
            "             \"float32\".to_owned()",
            "@@ -728,26 +778,26 @@",
            "         assert_eq!(",
            "             DataType::LocalStruct(\"xx\".into())",
            "                 .md5_string(\"p2\", &hashes)",
            "                 .unwrap(),",
            "             \"EFGH\".to_owned()",
            "         );",
            "         assert_eq!(",
            "-            DataType::RemoteStruct(\"p1\".into(), \"xx\".into())",
            "+            DataType::RemoteStruct(MessagePath::new(\"p1\", \"xx\"))",
            "                 .md5_string(\"p2\", &hashes)",
            "                 .unwrap(),",
            "             \"ABCD\".to_owned()",
            "         );",
            "     }",
            " ",
            "     #[test]",
            "     fn fieldinfo_md5_string_correct() {",
            "         let mut hashes = HashMap::new();",
            "-        hashes.insert((\"p1\".into(), \"xx\".into()), \"ABCD\".into());",
            "-        hashes.insert((\"p2\".into(), \"xx\".into()), \"EFGH\".into());",
            "+        hashes.insert(MessagePath::new(\"p1\", \"xx\"), \"ABCD\".into());",
            "+        hashes.insert(MessagePath::new(\"p2\", \"xx\"), \"EFGH\".into());",
            "         assert_eq!(",
            "             FieldInfo::new(\"int64\", \"abc\", FieldCase::Unit)",
            "                 .unwrap()",
            "                 .md5_string(\"\", &hashes)",
            "                 .unwrap(),",
            "             \"int64 abc\".to_owned()",
            "         );",
            "@@ -794,79 +844,75 @@",
            "             \"EFGH abc\".to_owned()",
            "         );",
            "     }",
            " ",
            "     #[test]",
            "     fn message_md5_string_correct() {",
            "         assert_eq!(",
            "-            Msg::new(\"std_msgs\", \"String\", \"string data\")",
            "+            Msg::new(\"std_msgs/String\".try_into().unwrap(), \"string data\")",
            "                 .unwrap()",
            "                 .calculate_md5(&HashMap::new())",
            "                 .unwrap(),",
            "             \"992ce8a1687cec8c8bd883ec73ca41d1\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             Msg::new(",
            "-                \"geometry_msgs\",",
            "-                \"Point\",",
            "+                \"geometry_msgs/Point\".try_into().unwrap(),",
            "                 include_str!(\"msg_examples/geometry_msgs/msg/Point.msg\"),",
            "             )",
            "             .unwrap()",
            "             .calculate_md5(&HashMap::new())",
            "             .unwrap(),",
            "             \"4a842b65f413084dc2b10fb484ea7f17\".to_owned()",
            "         );",
            "         assert_eq!(",
            "             Msg::new(",
            "-                \"geometry_msgs\",",
            "-                \"Quaternion\",",
            "+                \"geometry_msgs/Quaternion\".try_into().unwrap(),",
            "                 include_str!(\"msg_examples/geometry_msgs/msg/Quaternion.msg\"),",
            "             )",
            "             .unwrap()",
            "             .calculate_md5(&HashMap::new())",
            "             .unwrap(),",
            "             \"a779879fadf0160734f906b8c19c7004\".to_owned()",
            "         );",
            "         let mut hashes = HashMap::new();",
            "         hashes.insert(",
            "-            (\"geometry_msgs\".into(), \"Point\".into()),",
            "+            MessagePath::new(\"geometry_msgs\", \"Point\"),",
            "             \"4a842b65f413084dc2b10fb484ea7f17\".into(),",
            "         );",
            "         hashes.insert(",
            "-            (\"geometry_msgs\".into(), \"Quaternion\".into()),",
            "+            MessagePath::new(\"geometry_msgs\", \"Quaternion\"),",
            "             \"a779879fadf0160734f906b8c19c7004\".into(),",
            "         );",
            "         assert_eq!(",
            "             Msg::new(",
            "-                \"geometry_msgs\",",
            "-                \"Pose\",",
            "+                \"geometry_msgs/Pose\".try_into().unwrap(),",
            "                 include_str!(\"msg_examples/geometry_msgs/msg/Pose.msg\"),",
            "             )",
            "             .unwrap()",
            "             .calculate_md5(&hashes)",
            "             .unwrap(),",
            "             \"e45d45a5a1ce597b249e23fb30fc871f\".to_owned()",
            "         );",
            "         let mut hashes = HashMap::new();",
            "         hashes.insert(",
            "-            (\"geometry_msgs\".into(), \"Point\".into()),",
            "+            MessagePath::new(\"geometry_msgs\", \"Point\"),",
            "             \"4a842b65f413084dc2b10fb484ea7f17\".into(),",
            "         );",
            "         hashes.insert(",
            "-            (\"std_msgs\".into(), \"ColorRGBA\".into()),",
            "+            MessagePath::new(\"std_msgs\", \"ColorRGBA\"),",
            "             \"a29a96539573343b1310c73607334b00\".into(),",
            "         );",
            "         hashes.insert(",
            "-            (\"std_msgs\".into(), \"Header\".into()),",
            "+            MessagePath::new(\"std_msgs\", \"Header\"),",
            "             \"2176decaecbce78abc3b96ef049fabed\".into(),",
            "         );",
            "         assert_eq!(",
            "             Msg::new(",
            "-                \"visualization_msgs\",",
            "-                \"ImageMarker\",",
            "+                \"visualization_msgs/ImageMarker\".try_into().unwrap(),",
            "                 include_str!(\"msg_examples/visualization_msgs/msg/ImageMarker.msg\"),",
            "             )",
            "             .unwrap()",
            "             .calculate_md5(&hashes)",
            "             .unwrap(),",
            "             \"1de93c67ec8858b831025a08fbf1b35c\".to_owned()",
            "         );",
            "@@ -940,26 +986,26 @@",
            "     fn match_line_works_on_legal_data() {",
            "         assert!(match_line(\"#just a comment\").is_none());",
            "         assert!(match_line(\"#  YOLO !   \").is_none());",
            "         assert!(match_line(\"      \").is_none());",
            " ",
            "         assert_eq!(",
            "             FieldInfo {",
            "-                datatype: DataType::RemoteStruct(\"geom_msgs\".into(), \"Twist\".into()),",
            "+                datatype: DataType::RemoteStruct(MessagePath::new(\"geom_msgs\", \"Twist\")),",
            "                 name: \"myname\".into(),",
            "                 case: FieldCase::Unit,",
            "             },",
            "-            match_line(\"  geom_msgs/Twist   myname    # this clearly should succeed\",)",
            "+            match_line(\"  geom_msgs/Twist   myname    # this clearly should succeed\")",
            "                 .unwrap()",
            "                 .unwrap()",
            "         );",
            " ",
            "         assert_eq!(",
            "             FieldInfo {",
            "-                datatype: DataType::RemoteStruct(\"geom_msgs\".into(), \"Twist\".into()),",
            "+                datatype: DataType::RemoteStruct(MessagePath::new(\"geom_msgs\", \"Twist\")),",
            "                 name: \"myname\".into(),",
            "                 case: FieldCase::Vector,",
            "             },",
            "             match_line(\"  geom_msgs/Twist [  ]   myname  # ...\")",
            "                 .unwrap()",
            "                 .unwrap()",
            "         );",
            "@@ -982,15 +1028,15 @@",
            "             },",
            "             match_line(\"  string  myname =   this is # data  \")",
            "                 .unwrap()",
            "                 .unwrap()",
            "         );",
            "         assert_eq!(",
            "             FieldInfo {",
            "-                datatype: DataType::RemoteStruct(\"geom_msgs\".into(), \"Twist\".into()),",
            "+                datatype: DataType::RemoteStruct(MessagePath::new(\"geom_msgs\", \"Twist\")),",
            "                 name: \"myname\".into(),",
            "                 case: FieldCase::Const(\"-444\".into()),",
            "             },",
            "             match_line(\"  geom_msgs/Twist  myname =   -444 # data  \")",
            "                 .unwrap()",
            "                 .unwrap()",
            "         );",
            "@@ -1022,42 +1068,41 @@",
            "         let data = match_lines(include_str!(",
            "             \"msg_examples/geometry_msgs/msg/PoseStamped.msg\"",
            "         ))",
            "         .unwrap();",
            "         assert_eq!(",
            "             vec![",
            "                 FieldInfo {",
            "-                    datatype: DataType::RemoteStruct(\"std_msgs\".into(), \"Header\".into()),",
            "+                    datatype: DataType::RemoteStruct(MessagePath::new(\"std_msgs\", \"Header\")),",
            "                     name: \"header\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "                 FieldInfo {",
            "                     datatype: DataType::LocalStruct(\"Pose\".into()),",
            "                     name: \"pose\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "             ],",
            "             data",
            "         );",
            "     }",
            " ",
            "-    fn get_dependency_set(message: &Msg) -> HashSet<(String, String)> {",
            "+    fn get_dependency_set(message: &Msg) -> HashSet<MessagePath> {",
            "         message.dependencies().into_iter().collect()",
            "     }",
            " ",
            "     #[test]",
            "     fn msg_constructor_parses_real_message() {",
            "         let data = Msg::new(",
            "-            \"geometry_msgs\",",
            "-            \"TwistWithCovariance\",",
            "+            \"geometry_msgs/TwistWithCovariance\".try_into().unwrap(),",
            "             include_str!(\"msg_examples/geometry_msgs/msg/TwistWithCovariance.msg\"),",
            "         )",
            "         .unwrap();",
            "-        assert_eq!(data.package, \"geometry_msgs\");",
            "-        assert_eq!(data.name, \"TwistWithCovariance\");",
            "+        assert_eq!(data.path.package, \"geometry_msgs\");",
            "+        assert_eq!(data.path.name, \"TwistWithCovariance\");",
            "         assert_eq!(",
            "             data.fields,",
            "             vec![",
            "                 FieldInfo {",
            "                     datatype: DataType::LocalStruct(\"Twist\".into()),",
            "                     name: \"twist\".into(),",
            "                     case: FieldCase::Unit,",
            "@@ -1067,92 +1112,93 @@",
            "                     name: \"covariance\".into(),",
            "                     case: FieldCase::Array(36),",
            "                 },",
            "             ]",
            "         );",
            "         let dependencies = get_dependency_set(&data);",
            "         assert_eq!(dependencies.len(), 1);",
            "-        assert!(dependencies.contains(&(\"geometry_msgs\".into(), \"Twist\".into()),));",
            "+        assert!(dependencies.contains(&MessagePath::new(\"geometry_msgs\", \"Twist\")));",
            " ",
            "         let data = Msg::new(",
            "-            \"geometry_msgs\",",
            "-            \"PoseStamped\",",
            "+            \"geometry_msgs/PoseStamped\".try_into().unwrap(),",
            "             include_str!(\"msg_examples/geometry_msgs/msg/PoseStamped.msg\"),",
            "         )",
            "         .unwrap();",
            "-        assert_eq!(data.package, \"geometry_msgs\");",
            "-        assert_eq!(data.name, \"PoseStamped\");",
            "+        assert_eq!(data.path.package, \"geometry_msgs\");",
            "+        assert_eq!(data.path.name, \"PoseStamped\");",
            "         assert_eq!(",
            "             data.fields,",
            "             vec![",
            "                 FieldInfo {",
            "-                    datatype: DataType::RemoteStruct(\"std_msgs\".into(), \"Header\".into()),",
            "+                    datatype: DataType::RemoteStruct(MessagePath::new(\"std_msgs\", \"Header\")),",
            "                     name: \"header\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "                 FieldInfo {",
            "                     datatype: DataType::LocalStruct(\"Pose\".into()),",
            "                     name: \"pose\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "             ]",
            "         );",
            "         let dependencies = get_dependency_set(&data);",
            "         assert_eq!(dependencies.len(), 2);",
            "-        assert!(dependencies.contains(&(\"geometry_msgs\".into(), \"Pose\".into()),));",
            "-        assert!(dependencies.contains(&(\"std_msgs\".into(), \"Header\".into())));",
            "+        assert!(dependencies.contains(&MessagePath::new(\"geometry_msgs\", \"Pose\")));",
            "+        assert!(dependencies.contains(&MessagePath::new(\"std_msgs\", \"Header\")));",
            " ",
            "         let data = Msg::new(",
            "-            \"sensor_msgs\",",
            "-            \"Imu\",",
            "+            \"sensor_msgs/Imu\".try_into().unwrap(),",
            "             include_str!(\"msg_examples/sensor_msgs/msg/Imu.msg\"),",
            "         )",
            "         .unwrap();",
            "-        assert_eq!(data.package, \"sensor_msgs\");",
            "-        assert_eq!(data.name, \"Imu\");",
            "+        assert_eq!(data.path.package, \"sensor_msgs\");",
            "+        assert_eq!(data.path.name, \"Imu\");",
            "         assert_eq!(",
            "             data.fields,",
            "             vec![",
            "                 FieldInfo {",
            "-                    datatype: DataType::RemoteStruct(\"std_msgs\".into(), \"Header\".into()),",
            "+                    datatype: DataType::RemoteStruct(MessagePath::new(\"std_msgs\", \"Header\")),",
            "                     name: \"header\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "                 FieldInfo {",
            "-                    datatype: DataType::RemoteStruct(\"geometry_msgs\".into(), \"Quaternion\".into()),",
            "+                    datatype: DataType::RemoteStruct(MessagePath::new(",
            "+                        \"geometry_msgs\",",
            "+                        \"Quaternion\"",
            "+                    )),",
            "                     name: \"orientation\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "                 FieldInfo {",
            "                     datatype: DataType::F64,",
            "                     name: \"orientation_covariance\".into(),",
            "                     case: FieldCase::Array(9),",
            "                 },",
            "                 FieldInfo {",
            "-                    datatype: DataType::RemoteStruct(\"geometry_msgs\".into(), \"Vector3\".into()),",
            "+                    datatype: DataType::RemoteStruct(MessagePath::new(\"geometry_msgs\", \"Vector3\")),",
            "                     name: \"angular_velocity\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "                 FieldInfo {",
            "                     datatype: DataType::F64,",
            "                     name: \"angular_velocity_covariance\".into(),",
            "                     case: FieldCase::Array(9),",
            "                 },",
            "                 FieldInfo {",
            "-                    datatype: DataType::RemoteStruct(\"geometry_msgs\".into(), \"Vector3\".into()),",
            "+                    datatype: DataType::RemoteStruct(MessagePath::new(\"geometry_msgs\", \"Vector3\")),",
            "                     name: \"linear_acceleration\".into(),",
            "                     case: FieldCase::Unit,",
            "                 },",
            "                 FieldInfo {",
            "                     datatype: DataType::F64,",
            "                     name: \"linear_acceleration_covariance\".into(),",
            "                     case: FieldCase::Array(9),",
            "                 },",
            "             ]",
            "         );",
            "         let dependencies = get_dependency_set(&data);",
            "         assert_eq!(dependencies.len(), 3);",
            "-        assert!(dependencies.contains(&(\"geometry_msgs\".into(), \"Vector3\".into()),));",
            "-        assert!(dependencies.contains(&(\"geometry_msgs\".into(), \"Quaternion\".into()),));",
            "-        assert!(dependencies.contains(&(\"std_msgs\".into(), \"Header\".into())));",
            "+        assert!(dependencies.contains(&MessagePath::new(\"geometry_msgs\", \"Vector3\")));",
            "+        assert!(dependencies.contains(&MessagePath::new(\"geometry_msgs\", \"Quaternion\")));",
            "+        assert!(dependencies.contains(&MessagePath::new(\"std_msgs\", \"Header\")));",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/output_layout.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/output_layout.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/output_layout.rs",
            "@@ -17,14 +17,15 @@",
            "             .collect::<Vec<_>>();",
            "         quote! {",
            "             #(#packages)*",
            "         }",
            "     }",
            " }",
            " ",
            "+#[derive(Debug)]",
            " pub struct Package {",
            "     pub name: String,",
            "     pub messages: Vec<Message>,",
            "     pub services: Vec<Service>,",
            " }",
            " ",
            " impl Package {",
            "@@ -45,28 +46,33 @@",
            "                 #(#messages)*",
            "                 #(#services)*",
            "             }",
            "         }",
            "     }",
            " }",
            " ",
            "+// TODO: Present source code of messages and services somehow",
            "+",
            "+#[derive(Debug)]",
            " pub struct Message {",
            "     pub message: Msg,",
            "     pub msg_definition: String,",
            "     pub md5sum: String,",
            "     pub msg_type: String,",
            "+    pub source: String,",
            " }",
            " ",
            " impl Message {",
            "     pub fn token_stream<T: ToTokens>(&self, crate_prefix: &T) -> impl ToTokens {",
            "         let Message {",
            "             message,",
            "             msg_definition,",
            "             md5sum,",
            "             msg_type,",
            "+            source: _,",
            "         } = self;",
            "         let base_message = message.token_stream(crate_prefix);",
            "         let encode_message = message.token_stream_encode(crate_prefix);",
            "         let decode_message = message.token_stream_decode(crate_prefix);",
            "         let name = message.name_ident();",
            "         let header_tokens = message.header_token_stream(crate_prefix);",
            "         quote! {",
            "@@ -100,26 +106,29 @@",
            "                     #decode_message",
            "                 }",
            "             }",
            "         }",
            "     }",
            " }",
            " ",
            "+#[derive(Debug)]",
            " pub struct Service {",
            "     pub name: String,",
            "     pub md5sum: String,",
            "     pub msg_type: String,",
            "+    pub source: String,",
            " }",
            " ",
            " impl Service {",
            "     pub fn token_stream<T: ToTokens>(&self, crate_prefix: &T) -> impl ToTokens {",
            "         let Service {",
            "             name,",
            "             md5sum,",
            "             msg_type,",
            "+            source: _,",
            "         } = self;",
            "         let name_ident = Ident::new(&name, Span::call_site());",
            "         let req_ident = Ident::new(&format!(\"{}Req\", name), Span::call_site());",
            "         let res_ident = Ident::new(&format!(\"{}Res\", name), Span::call_site());",
            " ",
            "         quote! {",
            "             #[allow(dead_code,non_camel_case_types,non_snake_case)]"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_codegen/src/rosmsg_include.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_codegen/src/rosmsg_include.rs",
            "+++ /home/rosrust-0.9.5/rosrust_codegen/src/rosmsg_include.rs",
            "@@ -1,14 +1,18 @@",
            " use crate::genmsg;",
            " use proc_macro::TokenStream;",
            " use quote::quote;",
            " use std::env;",
            " use std::path::Path;",
            " ",
            "-pub fn depend_on_messages(messages: &[&str], internal: bool) -> TokenStream {",
            "+pub fn depend_on_messages(",
            "+    messages: &[&str],",
            "+    internal: bool,",
            "+    ignore_bad_messages: bool,",
            "+) -> TokenStream {",
            "     let cmake_paths = env::var(\"CMAKE_PREFIX_PATH\")",
            "         .unwrap_or_default()",
            "         .split(':')",
            "         .filter_map(append_share_folder)",
            "         .collect::<Vec<String>>();",
            "     let cmake_alt_paths = env::var(\"CMAKE_PREFIX_PATH\")",
            "         .unwrap_or_default()",
            "@@ -22,15 +26,15 @@",
            "         .collect::<Vec<String>>();",
            "     let paths = cmake_paths",
            "         .iter()",
            "         .chain(cmake_alt_paths.iter())",
            "         .chain(extra_paths.iter())",
            "         .map(String::as_str)",
            "         .collect::<Vec<&str>>();",
            "-    let output = genmsg::depend_on_messages(paths.as_slice(), messages)",
            "+    let output = genmsg::depend_on_messages(ignore_bad_messages, paths.as_slice(), messages)",
            "         .unwrap_or_else(|r| panic!(\"{}\", r))",
            "         .token_stream(&if internal {",
            "             quote! { crate:: }",
            "         } else {",
            "             quote! { rosrust:: }",
            "         });",
            "     (quote! {#output}).into()"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/examples/example.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/examples/example.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/examples/example.rs",
            "@@ -80,16 +80,19 @@",
            " ",
            "     let dummy_task = DummyTask;",
            "     let dummy_task2 = DummyTask;",
            " ",
            "     updater.add_task(&dummy_task).unwrap();",
            " ",
            "     let mut bounds = CompositeTask::new(\"Bound check\");",
            "-    bounds.add_task(check_lower_bound.into_task(\"Lower-bound check\"));",
            "-    bounds.add_task(check_upper_bound.into_task(\"Upper-bound check\"));",
            "+",
            "+    let lower_task = check_lower_bound.into_task(\"Lower-bound check\");",
            "+    let upper_task = check_upper_bound.into_task(\"Upper-bound check\");",
            "+    bounds.add_task(&lower_task);",
            "+    bounds.add_task(&upper_task);",
            " ",
            "     updater.add_task(&bounds).unwrap();",
            " ",
            "     let rate = rosrust::rate(10.0);",
            " ",
            "     while rosrust::is_ok() {",
            "         updater.force_update_with_extra(&[&dummy_task2]).unwrap();"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/examples/frequency_status.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/examples/frequency_status.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/examples/frequency_status.rs",
            "@@ -13,20 +13,33 @@",
            "     let mut freq_statuses = vec![];",
            " ",
            "     freq_statuses.push(Arc::new(",
            "         FrequencyStatus::builder().name(\"No limits\").build(),",
            "     ));",
            "     freq_statuses.push(Arc::new(",
            "         FrequencyStatus::builder()",
            "+            .name(\"No limits allowing empty\")",
            "+            .allow_no_events(true)",
            "+            .build(),",
            "+    ));",
            "+    freq_statuses.push(Arc::new(",
            "+        FrequencyStatus::builder()",
            "             .name(\"Only max\")",
            "             .max_frequency(10.0)",
            "             .build(),",
            "     ));",
            "     freq_statuses.push(Arc::new(",
            "         FrequencyStatus::builder()",
            "+            .name(\"Only max allowing empty\")",
            "+            .max_frequency(10.0)",
            "+            .allow_no_events(true)",
            "+            .build(),",
            "+    ));",
            "+    freq_statuses.push(Arc::new(",
            "+        FrequencyStatus::builder()",
            "             .name(\"Only min\")",
            "             .min_frequency(5.0)",
            "             .build(),",
            "     ));",
            "     freq_statuses.push(Arc::new(",
            "         FrequencyStatus::builder()",
            "             .name(\"Both limits\")"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/composite_task.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/composite_task.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/composite_task.rs",
            "@@ -9,37 +9,37 @@",
            " /// For instance, this could be used to combine the calibration and offset data",
            " /// from an IMU driver.",
            " ///",
            " /// This is an easy way of combining task, but it performs heap allocations and",
            " /// takes ownership of tasks. To maintain ownership, and manage things optimally",
            " /// implement your own `Task`, by utilizing the `run_diagnostics!` macro for",
            " /// similar functionality.",
            "-pub struct CompositeTask {",
            "+pub struct CompositeTask<'a> {",
            "     name: String,",
            "-    tasks: Vec<Box<dyn Task>>,",
            "+    tasks: Vec<&'a dyn Task>,",
            " }",
            " ",
            "-impl CompositeTask {",
            "+impl<'a> CompositeTask<'a> {",
            "     /// Creates a new composite task with the given name.",
            "     pub fn new(name: impl std::string::ToString) -> Self {",
            "         Self {",
            "             name: name.to_string(),",
            "             tasks: vec![],",
            "         }",
            "     }",
            " ",
            "     /// Adds a child to the composite task.",
            "     ///",
            "     /// This child will be called every time the composit task is called.",
            "-    pub fn add_task(&mut self, task: impl Task + 'static) {",
            "-        self.tasks.push(Box::new(task))",
            "+    pub fn add_task(&mut self, task: &'a dyn Task) {",
            "+        self.tasks.push(task)",
            "     }",
            " }",
            " ",
            "-impl Task for CompositeTask {",
            "+impl<'a> Task for CompositeTask<'a> {",
            "     #[inline]",
            "     fn name(&self) -> &str {",
            "         &self.name",
            "     }",
            " ",
            "     fn run(&self, status: &mut Status) {",
            "         let mut runner = CompositeTaskRunner::new(status);"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/function_task.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/function_task.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/function_task.rs",
            "@@ -11,56 +11,56 @@",
            " /// This is the simplest method of creating tasks.",
            " ///",
            " /// You can call `.into_task(name)` from `FunctionExt` on any function with the correct signature",
            " /// to create a function task easily.",
            " #[derive(Clone)]",
            " pub struct FunctionTask<F>",
            " where",
            "-    F: Fn(&mut Status),",
            "+    F: Fn(&mut Status) + Sync,",
            " {",
            "     name: String,",
            "     function: F,",
            " }",
            " ",
            " impl<F> FunctionTask<F>",
            " where",
            "-    F: Fn(&mut Status),",
            "+    F: Fn(&mut Status) + Sync,",
            " {",
            "     /// Create a function task with the given name and function.",
            "     #[inline]",
            "     pub fn new(name: &str, function: F) -> Self {",
            "         Self {",
            "             name: name.into(),",
            "             function,",
            "         }",
            "     }",
            " }",
            " ",
            " impl<F> Task for FunctionTask<F>",
            " where",
            "-    F: Fn(&mut Status),",
            "+    F: Fn(&mut Status) + Sync,",
            " {",
            "     #[inline]",
            "     fn name(&self) -> &str {",
            "         &self.name",
            "     }",
            " ",
            "     #[inline]",
            "     fn run(&self, status: &mut Status) {",
            "         (self.function)(status)",
            "     }",
            " }",
            " ",
            " /// Extension trait for functions that allows easy creation of function tasks.",
            "-pub trait FunctionExt: Sized + Fn(&mut Status) {",
            "+pub trait FunctionExt: Sized + Fn(&mut Status) + Sync {",
            "     /// Converts the function into a task, and gives it the provided name.",
            "     fn into_task(self, name: &str) -> FunctionTask<Self>;",
            " }",
            " ",
            " impl<F> FunctionExt for F",
            " where",
            "-    F: Fn(&mut Status),",
            "+    F: Fn(&mut Status) + Sync,",
            " {",
            "     fn into_task(self, name: &str) -> FunctionTask<Self> {",
            "         FunctionTask::new(name, self)",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/lib.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/lib.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/lib.rs",
            "@@ -6,34 +6,34 @@",
            " ",
            " [diagnostic updater]: http://wiki.ros.org/diagnostic_updater",
            " */",
            " #![deny(missing_docs)]",
            " ",
            " pub use composite_task::{CompositeTask, CompositeTaskRunner};",
            " pub use function_task::{FunctionExt, FunctionTask};",
            "-pub use msg::diagnostic_msgs::KeyValue;",
            "+pub use rosrust_msg::diagnostic_msgs::{DiagnosticArray, DiagnosticStatus, KeyValue};",
            "+pub use rosrust_msg::std_msgs::Header;",
            " pub use status::Status;",
            " pub use task::Task;",
            " pub use tasks::{FrequencyStatus, Heartbeat, TimestampStatus};",
            " pub use updater::{Updater, UpdaterLowLevelExt};",
            " ",
            " mod composite_task;",
            " mod function_task;",
            " #[macro_use]",
            " mod macros;",
            "-pub mod msg;",
            " mod status;",
            " mod task;",
            " pub mod tasks;",
            " mod updater;",
            " ",
            " /// Possible levels of operations in a diagnostic status.",
            " #[repr(i8)]",
            " #[derive(Copy, Clone, Debug, PartialEq, Eq)]",
            " pub enum Level {",
            "     /// The diagnostic concluded that all checks passed.",
            "-    Ok = msg::diagnostic_msgs::DiagnosticStatus::OK,",
            "+    Ok = DiagnosticStatus::OK,",
            "     /// Checks resulted in a warning.",
            "-    Warn = msg::diagnostic_msgs::DiagnosticStatus::WARN,",
            "+    Warn = DiagnosticStatus::WARN,",
            "     /// Checks determined an error happened.",
            "-    Error = msg::diagnostic_msgs::DiagnosticStatus::ERROR,",
            "+    Error = DiagnosticStatus::ERROR,",
            " }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/status.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/status.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/status.rs",
            "@@ -1,9 +1,9 @@",
            "-use crate::msg::diagnostic_msgs::{DiagnosticStatus, KeyValue};",
            " use crate::Level;",
            "+use rosrust_msg::diagnostic_msgs::{DiagnosticStatus, KeyValue};",
            " ",
            " /// Higher level description of an individual diagnostic status.",
            " #[derive(Clone)]",
            " pub struct Status {",
            "     /// Level of the operation.",
            "     pub level: Level,",
            "     /// A description of the test/component that is being reporting."
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/task.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/task.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/task.rs",
            "@@ -1,11 +1,11 @@",
            " use crate::Status;",
            " ",
            " /// Trait that describes any diagnostic task.",
            "-pub trait Task {",
            "+pub trait Task: Sync {",
            "     /// Name of the diagnostic task.",
            "     ///",
            "     /// This name will appear in the diagnostic status generated by the `Updater`.",
            "     fn name(&self) -> &str {",
            "         \"\"",
            "     }"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/tasks/frequency_status.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/tasks/frequency_status.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/tasks/frequency_status.rs",
            "@@ -8,25 +8,27 @@",
            " /// Use `FrequencyStatus::builder()` to create an instance of this structure.",
            " pub struct FrequencyStatusBuilder<'a> {",
            "     min_frequency: f64,",
            "     max_frequency: f64,",
            "     tolerance: f64,",
            "     window_size: usize,",
            "     name: &'a str,",
            "+    allow_no_events: bool,",
            " }",
            " ",
            " impl<'a> FrequencyStatusBuilder<'a> {",
            "     #[inline]",
            "     fn new() -> Self {",
            "         Self {",
            "             min_frequency: 0.0,",
            "             max_frequency: std::f64::INFINITY,",
            "             tolerance: 0.1,",
            "             window_size: 5,",
            "             name: \"Frequency Status\",",
            "+            allow_no_events: false,",
            "         }",
            "     }",
            " ",
            "     /// Sets the minimum frequency that is expected.",
            "     ///",
            "     /// Defaults to zero.",
            "     #[inline]",
            "@@ -75,23 +77,42 @@",
            "     /// Defaults to \"Frequency Status\".",
            "     #[inline]",
            "     pub fn name(&mut self, name: &'a str) -> &mut Self {",
            "         self.name = name;",
            "         self",
            "     }",
            " ",
            "+    /// Sets whether or not a lack of events within the window is an error.",
            "+    ///",
            "+    /// While frequencies outside of the desired range cause warnings,",
            "+    /// getting no events triggered at all causes an error condition.",
            "+    ///",
            "+    /// Setting this flag allows you to ignore that error condition, and just emmit warnings",
            "+    /// when the rates aren't within the frequency window.",
            "+    ///",
            "+    /// A special case where this is very significant is when the minimum frequency is zero.",
            "+    /// Without this flag set, actually having zero events would cause an error condition.",
            "+    ///",
            "+    /// Defaults to `false`.",
            "+    #[inline]",
            "+    pub fn allow_no_events(&mut self, allow_no_events: bool) -> &mut Self {",
            "+        self.allow_no_events = allow_no_events;",
            "+        self",
            "+    }",
            "+",
            "     /// Builds the frequency status with the provided parameters.",
            "     #[inline]",
            "     pub fn build(&self) -> FrequencyStatus {",
            "         FrequencyStatus::new(",
            "             self.min_frequency,",
            "             self.max_frequency,",
            "             self.tolerance,",
            "             self.window_size,",
            "             self.name.into(),",
            "+            self.allow_no_events,",
            "         )",
            "     }",
            " }",
            " ",
            " /// Diagnostic task that monitors the frequency of an event.",
            " ///",
            " /// This diagnostic task monitors the frequency of calls to its tick method,",
            "@@ -100,14 +121,15 @@",
            " /// been no events in the latest window.",
            " pub struct FrequencyStatus {",
            "     min_frequency: f64,",
            "     max_frequency: f64,",
            "     min_tolerated_frequency: f64,",
            "     max_tolerated_frequency: f64,",
            "     name: String,",
            "+    allow_no_events: bool,",
            "     tracker: Mutex<Tracker>,",
            " }",
            " ",
            " struct Tracker {",
            "     count: usize,",
            "     history: VecDeque<HistoryEntry>,",
            "     window_size: usize,",
            "@@ -152,21 +174,23 @@",
            "     #[inline]",
            "     pub fn new(",
            "         min_frequency: f64,",
            "         max_frequency: f64,",
            "         tolerance: f64,",
            "         window_size: usize,",
            "         name: String,",
            "+        allow_no_events: bool,",
            "     ) -> Self {",
            "         Self {",
            "             min_frequency,",
            "             max_frequency,",
            "             min_tolerated_frequency: min_frequency * (1.0 - tolerance),",
            "             max_tolerated_frequency: max_frequency * (1.0 + tolerance),",
            "             name,",
            "+            allow_no_events,",
            "             tracker: Mutex::new(Tracker::new(window_size)),",
            "         }",
            "     }",
            " ",
            "     /// Signals that an event has occurred.",
            "     #[inline]",
            "     pub fn tick(&self) {",
            "@@ -180,15 +204,15 @@",
            "     #[inline]",
            "     pub fn clear(&self) {",
            "         self.tracker.lock().expect(FAILED_TO_LOCK).clear();",
            "     }",
            " ",
            "     fn frequency_to_summary(&self, frequency: f64) -> (Level, &str) {",
            "         match frequency {",
            "-            v if v == 0.0 => (Level::Error, \"No events recorded.\"),",
            "+            v if v == 0.0 && !self.allow_no_events => (Level::Error, \"No events recorded.\"),",
            "             v if v < self.min_tolerated_frequency => (Level::Warn, \"Frequency too low.\"),",
            "             v if v > self.max_tolerated_frequency => (Level::Warn, \"Frequency too high.\"),",
            "             _ => (Level::Ok, \"Desired frequency met\"),",
            "         }",
            "     }",
            " ",
            "     #[allow(clippy::float_cmp)]"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/tasks/timestamp_status.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/tasks/timestamp_status.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/tasks/timestamp_status.rs",
            "@@ -317,15 +317,15 @@",
            "     }",
            " ",
            "     impl Arbitrary for SortedTriplet {",
            "         fn arbitrary<G: Gen>(g: &mut G) -> Self {",
            "             <(f64, f64, f64)>::arbitrary(g).into()",
            "         }",
            " ",
            "-        fn shrink(&self) -> Box<Iterator<Item = Self>> {",
            "+        fn shrink(&self) -> Box<dyn Iterator<Item = Self>> {",
            "             Box::new(Arbitrary::shrink(&(self.low, self.mid, self.high)).map(Into::into))",
            "         }",
            "     }",
            " ",
            "     #[quickcheck]",
            "     fn range_combination_with_higher_increases_max(triplet: SortedTriplet) {",
            "         let mut range = Range::range(triplet.low, triplet.mid);"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/src/updater.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/src/updater.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/src/updater.rs",
            "@@ -1,11 +1,11 @@",
            "-use crate::msg::diagnostic_msgs::{DiagnosticArray, DiagnosticStatus};",
            "-use crate::msg::std_msgs::Header;",
            " use crate::{Level, Status, Task};",
            " use rosrust::{error::Result, Publisher};",
            "+use rosrust_msg::diagnostic_msgs::{DiagnosticArray, DiagnosticStatus};",
            "+use rosrust_msg::std_msgs::Header;",
            " use std::sync::Mutex;",
            " ",
            " /// Manages a list of diagnostic tasks, and calls them in a rate-limited manner.",
            " ///",
            " /// This class manages a list of diagnostic tasks. Its `update` function",
            " /// should be called frequently. At some predetermined rate, the `update`",
            " /// function will cause all the diagnostic tasks to run, and will collate"
          ]
        },
        {
          "file": "/home/rosrust-0.9.5/rosrust_diagnostics/tests/composite_task.rs",
          "change": [
            "--- /home/rosrust-0.8.0/rosrust_diagnostics/tests/composite_task.rs",
            "+++ /home/rosrust-0.9.5/rosrust_diagnostics/tests/composite_task.rs",
            "@@ -22,19 +22,19 @@",
            "     })",
            "     .into_task(\"my_task3\");",
            " ",
            "     let mut target = Status::default();",
            "     target.set_summary(Level::Ok, \"start\");",
            " ",
            "     let mut task = CompositeTask::new(\"composite_task\");",
            "-    task.add_task(task_noop.clone());",
            "-    task.add_task(task1);",
            "-    task.add_task(task2);",
            "-    task.add_task(task3);",
            "-    task.add_task(task_noop);",
            "+    task.add_task(&task_noop);",
            "+    task.add_task(&task1);",
            "+    task.add_task(&task2);",
            "+    task.add_task(&task3);",
            "+    task.add_task(&task_noop);",
            " ",
            "     task.run(&mut target);",
            " ",
            "     assert_eq!(&target.message, \"foo; bar\");",
            "     assert_eq!(target.level, Level::Error);",
            "     assert_eq!(target.values.len(), 3);",
            "     assert_eq!(target.values[0].key, \"one\");",
            "@@ -67,19 +67,19 @@",
            "     })",
            "     .into_task(\"my_task3\");",
            " ",
            "     let mut target = Status::default();",
            "     target.set_summary(Level::Ok, \"start\");",
            " ",
            "     let mut task = CompositeTask::new(\"composite_task\");",
            "-    task.add_task(task_noop.clone());",
            "-    task.add_task(task1);",
            "-    task.add_task(task2);",
            "-    task.add_task(task3);",
            "-    task.add_task(task_noop);",
            "+    task.add_task(&task_noop);",
            "+    task.add_task(&task1);",
            "+    task.add_task(&task2);",
            "+    task.add_task(&task3);",
            "+    task.add_task(&task_noop);",
            " ",
            "     task.run(&mut target);",
            " ",
            "     assert_eq!(&target.message, \"start; foo; bar; baz; start\");",
            "     assert_eq!(target.level, Level::Ok);",
            "     assert_eq!(target.values.len(), 3);",
            "     assert_eq!(target.values[0].key, \"one\");"
          ]
        }
      ]
    }
  }
}