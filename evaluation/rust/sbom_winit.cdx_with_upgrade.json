{
  "$schema": "http://cyclonedx.org/schema/bom-1.6.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.6",
  "serialNumber": "urn:uuid:0b3b6feb-5c35-48e1-9817-bf9452b47d3d",
  "version": 1,
  "metadata": {
    "timestamp": "2025-07-14T13:34:43-04:00",
    "tools": {
      "components": [
        {
          "type": "application",
          "author": "anchore",
          "name": "syft",
          "version": "1.28.0"
        }
      ]
    },
    "component": {
      "bom-ref": "b05c4ddf31c9bc8f",
      "type": "file",
      "name": "winit-0.30.11/"
    }
  },
  "components": [
    {
      "bom-ref": "pkg:github/embarkstudios/cargo-deny-action@v2?package-id=122e80af7c81d47c",
      "type": "library",
      "name": "EmbarkStudios/cargo-deny-action",
      "version": "v2",
      "cpe": "cpe:2.3:a:EmbarkStudios\\/cargo-deny-action:EmbarkStudios\\/cargo-deny-action:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/EmbarkStudios/cargo-deny-action@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo-deny-action:EmbarkStudios\\/cargo_deny_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo_deny_action:EmbarkStudios\\/cargo-deny-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo_deny_action:EmbarkStudios\\/cargo_deny_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo-deny:EmbarkStudios\\/cargo-deny-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo-deny:EmbarkStudios\\/cargo_deny_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo_deny:EmbarkStudios\\/cargo-deny-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo_deny:EmbarkStudios\\/cargo_deny_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo:EmbarkStudios\\/cargo-deny-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:EmbarkStudios\\/cargo:EmbarkStudios\\/cargo_deny_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/cache@v3?package-id=a20b5488397b59d8",
      "type": "library",
      "name": "actions/cache",
      "version": "v3",
      "cpe": "cpe:2.3:a:actions\\/cache:actions\\/cache:v3:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/cache@v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/cache@v3?package-id=e3cbbba96561e23a#restore",
      "type": "library",
      "name": "actions/cache/restore",
      "version": "v3",
      "cpe": "cpe:2.3:a:actions\\/cache\\/restore:actions\\/cache\\/restore:v3:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/cache@v3#restore",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/cache@v3?package-id=66b1cba000d514ff#save",
      "type": "library",
      "name": "actions/cache/save",
      "version": "v3",
      "cpe": "cpe:2.3:a:actions\\/cache\\/save:actions\\/cache\\/save:v3:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/cache@v3#save",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/checkout@v4?package-id=08014e0742182224",
      "type": "library",
      "name": "actions/checkout",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/checkout:actions\\/checkout:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/checkout@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/docs.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/configure-pages@v4?package-id=02d281a45ddcb2b9",
      "type": "library",
      "name": "actions/configure-pages",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/configure-pages:actions\\/configure-pages:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/configure-pages@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/configure-pages:actions\\/configure_pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/configure_pages:actions\\/configure-pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/configure_pages:actions\\/configure_pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/configure:actions\\/configure-pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/configure:actions\\/configure_pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/docs.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/deploy-pages@v4?package-id=57cec341402c490e",
      "type": "library",
      "name": "actions/deploy-pages",
      "version": "v4",
      "cpe": "cpe:2.3:a:actions\\/deploy-pages:actions\\/deploy-pages:v4:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/deploy-pages@v4",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/deploy-pages:actions\\/deploy_pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/deploy_pages:actions\\/deploy-pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/deploy_pages:actions\\/deploy_pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/deploy:actions\\/deploy-pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/deploy:actions\\/deploy_pages:v4:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/docs.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/actions/upload-pages-artifact@v3?package-id=271aad2aa4d6f46b",
      "type": "library",
      "name": "actions/upload-pages-artifact",
      "version": "v3",
      "cpe": "cpe:2.3:a:actions\\/upload-pages-artifact:actions\\/upload-pages-artifact:v3:*:*:*:*:*:*:*",
      "purl": "pkg:github/actions/upload-pages-artifact@v3",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-pages-artifact:actions\\/upload_pages_artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_pages_artifact:actions\\/upload-pages-artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_pages_artifact:actions\\/upload_pages_artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-pages:actions\\/upload-pages-artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload-pages:actions\\/upload_pages_artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_pages:actions\\/upload-pages-artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload_pages:actions\\/upload_pages_artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload-pages-artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:actions\\/upload:actions\\/upload_pages_artifact:v3:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/docs.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/dtolnay/rust-toolchain@master?package-id=f32aef63f78ee59d",
      "type": "library",
      "name": "dtolnay/rust-toolchain",
      "version": "master",
      "cpe": "cpe:2.3:a:dtolnay\\/rust-toolchain:dtolnay\\/rust-toolchain:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/dtolnay/rust-toolchain@master",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust-toolchain:dtolnay\\/rust_toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust_toolchain:dtolnay\\/rust-toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust_toolchain:dtolnay\\/rust_toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust:dtolnay\\/rust-toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust:dtolnay\\/rust_toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/dtolnay/rust-toolchain@master?package-id=3d488a1935256fbd",
      "type": "library",
      "name": "dtolnay/rust-toolchain",
      "version": "master",
      "cpe": "cpe:2.3:a:dtolnay\\/rust-toolchain:dtolnay\\/rust-toolchain:master:*:*:*:*:*:*:*",
      "purl": "pkg:github/dtolnay/rust-toolchain@master",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust-toolchain:dtolnay\\/rust_toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust_toolchain:dtolnay\\/rust-toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust_toolchain:dtolnay\\/rust_toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust:dtolnay\\/rust-toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust:dtolnay\\/rust_toolchain:master:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/docs.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/dtolnay/rust-toolchain@nightly?package-id=d269fcf0efab58fb",
      "type": "library",
      "name": "dtolnay/rust-toolchain",
      "version": "nightly",
      "cpe": "cpe:2.3:a:dtolnay\\/rust-toolchain:dtolnay\\/rust-toolchain:nightly:*:*:*:*:*:*:*",
      "purl": "pkg:github/dtolnay/rust-toolchain@nightly",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust-toolchain:dtolnay\\/rust_toolchain:nightly:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust_toolchain:dtolnay\\/rust-toolchain:nightly:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust_toolchain:dtolnay\\/rust_toolchain:nightly:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust:dtolnay\\/rust-toolchain:nightly:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:dtolnay\\/rust:dtolnay\\/rust_toolchain:nightly:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/taiki-e/checkout-action@v1?package-id=05600e4b9a566154",
      "type": "library",
      "name": "taiki-e/checkout-action",
      "version": "v1",
      "cpe": "cpe:2.3:a:taiki-e\\/checkout-action:taiki-e\\/checkout-action:v1:*:*:*:*:*:*:*",
      "purl": "pkg:github/taiki-e/checkout-action@v1",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki-e\\/checkout-action:taiki_e\\/checkout_action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/checkout_action:taiki-e\\/checkout-action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/checkout_action:taiki_e\\/checkout_action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki-e\\/checkout:taiki-e\\/checkout-action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki-e\\/checkout:taiki_e\\/checkout_action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/checkout:taiki-e\\/checkout-action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/checkout:taiki_e\\/checkout_action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki:taiki-e\\/checkout-action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki:taiki_e\\/checkout_action:v1:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "pkg:github/taiki-e/install-action@v2?package-id=a2a9f765ec53da6a",
      "type": "library",
      "name": "taiki-e/install-action",
      "version": "v2",
      "cpe": "cpe:2.3:a:taiki-e\\/install-action:taiki-e\\/install-action:v2:*:*:*:*:*:*:*",
      "purl": "pkg:github/taiki-e/install-action@v2",
      "properties": [
        {
          "name": "syft:package:foundBy",
          "value": "github-actions-usage-cataloger"
        },
        {
          "name": "syft:package:type",
          "value": "github-action"
        },
        {
          "name": "syft:package:metadataType",
          "value": "github-actions-use-statement"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki-e\\/install-action:taiki_e\\/install_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/install_action:taiki-e\\/install-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/install_action:taiki_e\\/install_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki-e\\/install:taiki-e\\/install-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki-e\\/install:taiki_e\\/install_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/install:taiki-e\\/install-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki_e\\/install:taiki_e\\/install_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki:taiki-e\\/install-action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:cpe23",
          "value": "cpe:2.3:a:taiki:taiki_e\\/install_action:v2:*:*:*:*:*:*:*"
        },
        {
          "name": "syft:location:0:path",
          "value": "/.github/workflows/ci.yml"
        }
      ]
    },
    {
      "bom-ref": "7561d461b00ff11d",
      "type": "file",
      "name": "/home/winit-0.30.11/.github/workflows/ci.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "2e8d5dbc7cb8bad92afd9854c9b7e8c6deed7cc6"
        },
        {
          "alg": "SHA-256",
          "content": "0d4137f0f91b88ce1ab1f6c04ccd44fa3509fe8ce05a1b26671e32cf0ef7d558"
        }
      ]
    },
    {
      "bom-ref": "63d1046ff1e32645",
      "type": "file",
      "name": "/home/winit-0.30.11/.github/workflows/docs.yml",
      "hashes": [
        {
          "alg": "SHA-1",
          "content": "edf6b6dfe09734fdd908ccbc29bd89a78bf25883"
        },
        {
          "alg": "SHA-256",
          "content": "4682db2790c88211ec89ec1038baf55a7b6e8f24db58ed2a54a030da6d748ba9"
        }
      ]
    }
  ],
  "upgrade": {
    "file_changes": {
      "old_version": "/home/winit-0.30.7",
      "New file": [
        "/home/winit-0.30.11/src/platform_impl/ios/notification_center.rs"
      ],
      "Deleted file": [
        "/home/winit-0.30.7/src/platform_impl/apple/appkit/window.rs",
        "/home/winit-0.30.7/src/platform_impl/ios/app_delegate.rs"
      ],
      "Modified file": [
        {
          "file": "/home/winit-0.30.11/src/event.rs",
          "change": [
            "--- /home/winit-0.30.7/src/event.rs",
            "+++ /home/winit-0.30.11/src/event.rs",
            "@@ -1148,15 +1148,15 @@",
            "         assert_eq!(force3.normalized(), 2.0);",
            "     }",
            " ",
            "     #[allow(clippy::clone_on_copy)]",
            "     #[test]",
            "     fn ensure_attrs_do_not_panic() {",
            "         foreach_event!(|event: event::Event<()>| {",
            "-            let _ = format!(\"{:?}\", event);",
            "+            let _ = format!(\"{event:?}\");",
            "         });",
            "         let _ = event::StartCause::Init.clone();",
            " ",
            "         let did = crate::event::DeviceId::dummy().clone();",
            "         HashSet::new().insert(did);",
            "         let mut set = [did, did, did];",
            "         set.sort_unstable();"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/keyboard.rs",
          "change": [
            "--- /home/winit-0.30.7/src/keyboard.rs",
            "+++ /home/winit-0.30.11/src/keyboard.rs",
            "@@ -1228,15 +1228,15 @@",
            "     ColorF5Brown,",
            "     /// Toggle the display of Closed Captions. (`VK_CC`, `KEYCODE_CAPTIONS`)",
            "     ClosedCaptionToggle,",
            "     /// Adjust brightness of device, by toggling between or cycling through states. (`VK_DIMMER`)",
            "     Dimmer,",
            "     /// Swap video sources. (`VK_DISPLAY_SWAP`)",
            "     DisplaySwap,",
            "-    /// Select Digital Video Rrecorder. (`KEYCODE_DVR`)",
            "+    /// Select Digital Video Recorder. (`KEYCODE_DVR`)",
            "     DVR,",
            "     /// Exit the current application. (`VK_EXIT`)",
            "     Exit,",
            "     /// Clear program or content stored as favorite 0. (`VK_CLEAR_FAVORITE_0`)",
            "     FavoriteClear0,",
            "     /// Clear program or content stored as favorite 1. (`VK_CLEAR_FAVORITE_1`)",
            "     FavoriteClear1,"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/lib.rs",
          "change": [
            "--- /home/winit-0.30.7/src/lib.rs",
            "+++ /home/winit-0.30.11/src/lib.rs",
            "@@ -161,15 +161,14 @@",
            " //! [`EventLoop`]: event_loop::EventLoop",
            " //! [`EventLoop::new()`]: event_loop::EventLoop::new",
            " //! [`EventLoop::run_app()`]: event_loop::EventLoop::run_app",
            " //! [`exit()`]: event_loop::ActiveEventLoop::exit",
            " //! [`Window`]: window::Window",
            " //! [`WindowId`]: window::WindowId",
            " //! [`WindowAttributes`]: window::WindowAttributes",
            "-//! [window_new]: window::Window::new",
            " //! [`create_window`]: event_loop::ActiveEventLoop::create_window",
            " //! [`Window::id()`]: window::Window::id",
            " //! [`WindowEvent`]: event::WindowEvent",
            " //! [`DeviceEvent`]: event::DeviceEvent",
            " //! [`Event::UserEvent`]: event::Event::UserEvent",
            " //! [`Event::LoopExiting`]: event::Event::LoopExiting",
            " //! [`raw_window_handle`]: ./window/struct.Window.html#method.raw_window_handle",
            "@@ -181,14 +180,17 @@",
            " #![deny(clippy::all)]",
            " #![deny(unsafe_op_in_unsafe_fn)]",
            " #![cfg_attr(clippy, deny(warnings))]",
            " // Doc feature labels can be tested locally by running RUSTDOCFLAGS=\"--cfg=docsrs\" cargo +nightly",
            " // doc",
            " #![cfg_attr(docsrs, feature(doc_auto_cfg, doc_cfg_hide), doc(cfg_hide(doc, docsrs)))]",
            " #![allow(clippy::missing_safety_doc)]",
            "+#![warn(clippy::uninlined_format_args)]",
            "+// TODO: wasm-binding needs to be updated for that to be resolved, for now just silence it.",
            "+#![cfg_attr(web_platform, allow(unknown_lints, wasm_c_abi))]",
            " ",
            " #[cfg(feature = \"rwh_04\")]",
            " pub use rwh_04 as raw_window_handle_04;",
            " #[cfg(feature = \"rwh_05\")]",
            " pub use rwh_05 as raw_window_handle_05;",
            " #[cfg(feature = \"rwh_06\")]",
            " pub use rwh_06 as raw_window_handle;"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/android.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/android.rs",
            "+++ /home/winit-0.30.11/src/platform/android.rs",
            "@@ -58,15 +58,15 @@",
            " //! For more details, refer to these `android-activity` [example applications](https://github.com/rust-mobile/android-activity/tree/main/examples).",
            " //!",
            " //! ## Converting from `ndk-glue` to `android-activity`",
            " //!",
            " //! If your application is currently based on `NativeActivity` via the `ndk-glue` crate and building",
            " //! with `cargo apk`, then the minimal changes would be:",
            " //! 1. Remove `ndk-glue` from your `Cargo.toml`",
            "-//! 2. Enable the `\"android-native-activity\"` feature for Winit: `winit = { version = \"0.30.7\",",
            "+//! 2. Enable the `\"android-native-activity\"` feature for Winit: `winit = { version = \"0.30.11\",",
            " //!    features = [ \"android-native-activity\" ] }`",
            " //! 3. Add an `android_main` entrypoint (as above), instead of using the '`[ndk_glue::main]` proc",
            " //!    macro from `ndk-macros` (optionally add a dependency on `android_logger` and initialize",
            " //!    logging as above).",
            " //! 4. Pass a clone of the `AndroidApp` that your application receives to Winit when building your",
            " //!    event loop (as shown above)."
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/ios.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/ios.rs",
            "+++ /home/winit-0.30.11/src/platform/ios.rs",
            "@@ -1,17 +1,20 @@",
            " //! # iOS / UIKit",
            " //!",
            " //! Winit has an OS requirement of iOS 8 or higher, and is regularly tested on",
            " //! iOS 9.3.",
            " //!",
            "+//! ## Window initialization",
            "+//!",
            " //! iOS's main `UIApplicationMain` does some init work that's required by all",
            " //! UI-related code (see issue [#1705]). It is best to create your windows",
            "-//! inside `Event::Resumed`.",
            "+//! inside [`ApplicationHandler::resumed`].",
            " //!",
            " //! [#1705]: https://github.com/rust-windowing/winit/issues/1705",
            "+//! [`ApplicationHandler::resumed`]: crate::application::ApplicationHandler::resumed",
            " //!",
            " //! ## Building app",
            " //!",
            " //! To build ios app you will need rustc built for this targets:",
            " //!",
            " //!  - armv7-apple-ios",
            " //!  - armv7s-apple-ios",
            "@@ -59,14 +62,24 @@",
            " //!  - applicationWillResignActive is Suspended",
            " //!  - applicationWillTerminate is LoopExiting",
            " //!",
            " //! Keep in mind that after LoopExiting event is received every attempt to draw with",
            " //! opengl will result in segfault.",
            " //!",
            " //! Also note that app may not receive the LoopExiting event if suspended; it might be SIGKILL'ed.",
            "+//!",
            "+//! ## Custom `UIApplicationDelegate`",
            "+//!",
            "+//! Winit usually handles everything related to the lifecycle events of the application. Sometimes,",
            "+//! though, you might want to access some of the more niche stuff that [the application",
            "+//! delegate][app-delegate] provides. This functionality is not exposed directly in Winit, since it",
            "+//! would increase the API surface by quite a lot. Instead, Winit guarantees that it will not",
            "+//! register an application delegate, so you can set up a custom one in a nib file instead.",
            "+//!",
            "+//! [app-delegate]: https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc",
            " ",
            " use std::os::raw::c_void;",
            " ",
            " use crate::event_loop::EventLoop;",
            " use crate::monitor::{MonitorHandle, VideoModeHandle};",
            " use crate::window::{Window, WindowAttributes};"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/macos.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/macos.rs",
            "+++ /home/winit-0.30.11/src/platform/macos.rs",
            "@@ -1,22 +1,90 @@",
            " //! # macOS / AppKit",
            " //!",
            " //! Winit has an OS requirement of macOS 10.11 or higher (same as Rust",
            " //! itself), and is regularly tested on macOS 10.14.",
            " //!",
            "+//! ## Window initialization",
            "+//!",
            " //! A lot of functionality expects the application to be ready before you",
            " //! start doing anything; this includes creating windows, fetching monitors,",
            " //! drawing, and so on, see issues [#2238], [#2051] and [#2087].",
            " //!",
            " //! If you encounter problems, you should try doing your initialization inside",
            "-//! `Event::Resumed`.",
            "+//! [`ApplicationHandler::resumed`].",
            " //!",
            " //! [#2238]: https://github.com/rust-windowing/winit/issues/2238",
            " //! [#2051]: https://github.com/rust-windowing/winit/issues/2051",
            " //! [#2087]: https://github.com/rust-windowing/winit/issues/2087",
            "+//! [`ApplicationHandler::resumed`]: crate::application::ApplicationHandler::resumed",
            "+//!",
            "+//! ## Custom `NSApplicationDelegate`",
            "+//!",
            "+//! Winit usually handles everything related to the lifecycle events of the application. Sometimes,",
            "+//! though, you might want to do more niche stuff, such as [handle when the user re-activates the",
            "+//! application][reopen]. Such functionality is not exposed directly in Winit, since it would",
            "+//! increase the API surface by quite a lot.",
            "+//!",
            "+//! [reopen]: https://developer.apple.com/documentation/appkit/nsapplicationdelegate/1428638-applicationshouldhandlereopen?language=objc",
            "+//!",
            "+//! Instead, Winit guarantees that it will not register an application delegate, so the solution is",
            "+//! to register your own application delegate, as outlined in the following example (see",
            "+//! `objc2-app-kit` for more detailed information).",
            "+#![cfg_attr(target_os = \"macos\", doc = \"```\")]",
            "+#![cfg_attr(not(target_os = \"macos\"), doc = \"```ignore\")]",
            "+//! use objc2::rc::Retained;",
            "+//! use objc2::runtime::ProtocolObject;",
            "+//! use objc2::{declare_class, msg_send_id, mutability, ClassType, DeclaredClass};",
            "+//! use objc2_app_kit::{NSApplication, NSApplicationDelegate};",
            "+//! use objc2_foundation::{NSArray, NSURL, MainThreadMarker, NSObject, NSObjectProtocol};",
            "+//! use winit::event_loop::EventLoop;",
            "+//!",
            "+//! declare_class!(",
            "+//!     struct AppDelegate;",
            "+//!",
            "+//!     unsafe impl ClassType for AppDelegate {",
            "+//!         type Super = NSObject;",
            "+//!         type Mutability = mutability::MainThreadOnly;",
            "+//!         const NAME: &'static str = \"MyAppDelegate\";",
            "+//!     }",
            "+//!",
            "+//!     impl DeclaredClass for AppDelegate {}",
            "+//!",
            "+//!     unsafe impl NSObjectProtocol for AppDelegate {}",
            "+//!",
            "+//!     unsafe impl NSApplicationDelegate for AppDelegate {",
            "+//!         #[method(application:openURLs:)]",
            "+//!         fn application_openURLs(&self, application: &NSApplication, urls: &NSArray<NSURL>) {",
            "+//!             // Note: To specifically get `application:openURLs:` to work, you _might_",
            "+//!             // have to bundle your application. This is not done in this example.",
            "+//!             println!(\"open urls: {application:?}, {urls:?}\");",
            "+//!         }",
            "+//!     }",
            "+//! );",
            "+//!",
            "+//! impl AppDelegate {",
            "+//!     fn new(mtm: MainThreadMarker) -> Retained<Self> {",
            "+//!         unsafe { msg_send_id![super(mtm.alloc().set_ivars(())), init] }",
            "+//!     }",
            "+//! }",
            "+//!",
            "+//! fn main() -> Result<(), Box<dyn std::error::Error>> {",
            "+//!     let event_loop = EventLoop::new()?;",
            "+//!",
            "+//!     let mtm = MainThreadMarker::new().unwrap();",
            "+//!     let delegate = AppDelegate::new(mtm);",
            "+//!     // Important: Call `sharedApplication` after `EventLoop::new`,",
            "+//!     // doing it before is not yet supported.",
            "+//!     let app = NSApplication::sharedApplication(mtm);",
            "+//!     app.setDelegate(Some(ProtocolObject::from_ref(&*delegate)));",
            "+//!",
            "+//!     // event_loop.run_app(&mut my_app);",
            "+//!     Ok(())",
            "+//! }",
            "+//! ```",
            " ",
            " use std::os::raw::c_void;",
            " ",
            " #[cfg(feature = \"serde\")]",
            " use serde::{Deserialize, Serialize};",
            " ",
            " use crate::event_loop::{ActiveEventLoop, EventLoopBuilder};",
            "@@ -91,15 +159,17 @@",
            "     /// device's raw character will be placed in event queues with the",
            "     /// Alt modifier set.",
            "     fn set_option_as_alt(&self, option_as_alt: OptionAsAlt);",
            " ",
            "     /// Getter for the [`WindowExtMacOS::set_option_as_alt`].",
            "     fn option_as_alt(&self) -> OptionAsAlt;",
            " ",
            "-    /// Disable the Menu Bar and Dock in Borderless Fullscreen mode. Useful for games.",
            "+    /// Disable the Menu Bar and Dock in Simple or Borderless Fullscreen mode. Useful for games.",
            "+    /// The effect is applied when [`WindowExtMacOS::set_simple_fullscreen`] or",
            "+    /// [`Window::set_fullscreen`] is called.",
            "     fn set_borderless_game(&self, borderless_game: bool);",
            " ",
            "     /// Getter for the [`WindowExtMacOS::set_borderless_game`].",
            "     fn is_borderless_game(&self) -> bool;",
            " }",
            " ",
            " impl WindowExtMacOS for Window {"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/pump_events.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/pump_events.rs",
            "+++ /home/winit-0.30.11/src/platform/pump_events.rs",
            "@@ -47,27 +47,27 @@",
            "     /// provide guarantees about which events are safe to buffer across all",
            "     /// operating systems.",
            "     ///",
            "     /// Notable events that will certainly create portability problems if",
            "     /// buffered and handled outside of Winit include:",
            "     /// - `RedrawRequested` events, used to schedule rendering.",
            "     ///",
            "-    ///     macOS for example uses a `drawRect` callback to drive rendering",
            "-    ///     within applications and expects rendering to be finished before",
            "-    ///     the `drawRect` callback returns.",
            "+    ///   macOS for example uses a `drawRect` callback to drive rendering",
            "+    ///   within applications and expects rendering to be finished before",
            "+    ///   the `drawRect` callback returns.",
            "     ///",
            "-    ///     For portability it's strongly recommended that applications should",
            "-    ///     keep their rendering inside the closure provided to Winit.",
            "+    ///   For portability it's strongly recommended that applications should",
            "+    ///   keep their rendering inside the closure provided to Winit.",
            "     /// - Any lifecycle events, such as `Suspended` / `Resumed`.",
            "     ///",
            "-    ///     The handling of these events needs to be synchronized with the",
            "-    ///     operating system and it would never be appropriate to buffer a",
            "-    ///     notification that your application has been suspended or resumed and",
            "-    ///     then handled that later since there would always be a chance that",
            "-    ///     other lifecycle events occur while the event is buffered.",
            "+    ///   The handling of these events needs to be synchronized with the",
            "+    ///   operating system and it would never be appropriate to buffer a",
            "+    ///   notification that your application has been suspended or resumed and",
            "+    ///   then handled that later since there would always be a chance that",
            "+    ///   other lifecycle events occur while the event is buffered.",
            "     ///",
            "     /// ## Supported Platforms",
            "     ///",
            "     /// - Windows",
            "     /// - Linux",
            "     /// - MacOS",
            "     /// - Android"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/run_on_demand.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/run_on_demand.rs",
            "+++ /home/winit-0.30.11/src/platform/run_on_demand.rs",
            "│┄ Ordering differences only",
            "@@ -59,16 +59,16 @@",
            "     /// # Unsupported Platforms",
            "     /// - **Web:**  This API is fundamentally incompatible with the event-based way in which Web",
            "     ///   browsers work because it's not possible to have a long-running external loop that would",
            "     ///   block the browser and there is nothing that can be polled to ask for new events. Events",
            "     ///   are delivered via callbacks based on an event loop that is internal to the browser itself.",
            "     /// - **iOS:** It's not possible to stop and start an `UIApplication` repeatedly on iOS.",
            "     #[cfg_attr(not(web_platform), doc = \"[^1]: `spawn()` is only available on `wasm` platforms.\")]",
            "-    #[rustfmt::skip]",
            "     ///",
            "+    #[rustfmt::skip]",
            "     /// [`exit()`]: ActiveEventLoop::exit()",
            "     /// [`set_control_flow()`]: ActiveEventLoop::set_control_flow()",
            "     fn run_app_on_demand<A: ApplicationHandler<Self::UserEvent>>(",
            "         &mut self,",
            "         app: &mut A,",
            "     ) -> Result<(), EventLoopError> {",
            "         #[allow(deprecated)]"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/startup_notify.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/startup_notify.rs",
            "+++ /home/winit-0.30.11/src/platform/startup_notify.rs",
            "@@ -60,15 +60,15 @@",
            "         match self.p {",
            "             #[cfg(wayland_platform)]",
            "             crate::platform_impl::ActiveEventLoop::Wayland(_) => env::var(WAYLAND_VAR),",
            "             #[cfg(x11_platform)]",
            "             crate::platform_impl::ActiveEventLoop::X(_) => env::var(X11_VAR),",
            "         }",
            "         .ok()",
            "-        .map(ActivationToken::_new)",
            "+        .map(ActivationToken::from_raw)",
            "     }",
            " }",
            " ",
            " impl WindowExtStartupNotify for Window {",
            "     fn request_activation_token(&self) -> Result<AsyncRequestSerial, NotSupportedError> {",
            "         self.window.request_activation_token()",
            "     }",
            "@@ -90,10 +90,10 @@",
            "     env::remove_var(WAYLAND_VAR);",
            " }",
            " ",
            " /// Set environment variables responsible for activation token.",
            " ///",
            " /// This could be used before running daemon processes.",
            " pub fn set_activation_token_env(token: ActivationToken) {",
            "-    env::set_var(X11_VAR, &token._token);",
            "-    env::set_var(WAYLAND_VAR, token._token);",
            "+    env::set_var(X11_VAR, &token.token);",
            "+    env::set_var(WAYLAND_VAR, token.token);",
            " }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/wayland.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/wayland.rs",
            "+++ /home/winit-0.30.11/src/platform/wayland.rs",
            "@@ -9,14 +9,18 @@",
            " //!",
            " //! Winit provides client-side decorations by default, but the behaviour can",
            " //! be controlled with the following feature flags:",
            " //!",
            " //! * `wayland-csd-adwaita` (default).",
            " //! * `wayland-csd-adwaita-crossfont`.",
            " //! * `wayland-csd-adwaita-notitle`.",
            "+",
            "+use std::ffi::c_void;",
            "+use std::ptr::NonNull;",
            "+",
            " use crate::event_loop::{ActiveEventLoop, EventLoop, EventLoopBuilder};",
            " use crate::monitor::MonitorHandle;",
            " use crate::window::{Window, WindowAttributes};",
            " ",
            " pub use crate::window::Theme;",
            " ",
            " /// Additional methods on [`ActiveEventLoop`] that are specific to Wayland.",
            "@@ -68,17 +72,33 @@",
            "     fn with_any_thread(&mut self, any_thread: bool) -> &mut Self {",
            "         self.platform_specific.any_thread = any_thread;",
            "         self",
            "     }",
            " }",
            " ",
            " /// Additional methods on [`Window`] that are specific to Wayland.",
            "-pub trait WindowExtWayland {}",
            "+///",
            "+/// [`Window`]: crate::window::Window",
            "+pub trait WindowExtWayland {",
            "+    /// Returns `xdg_toplevel` of the window or [`None`] if the window is X11 window.",
            "+    fn xdg_toplevel(&self) -> Option<NonNull<c_void>>;",
            "+}",
            " ",
            "-impl WindowExtWayland for Window {}",
            "+impl WindowExtWayland for Window {",
            "+    #[inline]",
            "+    fn xdg_toplevel(&self) -> Option<NonNull<c_void>> {",
            "+        #[allow(clippy::single_match)]",
            "+        match &self.window {",
            "+            #[cfg(x11_platform)]",
            "+            crate::platform_impl::Window::X(_) => None,",
            "+            #[cfg(wayland_platform)]",
            "+            crate::platform_impl::Window::Wayland(window) => window.xdg_toplevel(),",
            "+        }",
            "+    }",
            "+}",
            " ",
            " /// Additional methods on [`WindowAttributes`] that are specific to Wayland.",
            " pub trait WindowAttributesExtWayland {",
            "     /// Build window with the given name.",
            "     ///",
            "     /// The `general` name sets an application ID, which should match the `.desktop`",
            "     /// file distributed with your program. The `instance` is a `no-op`."
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform/windows.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform/windows.rs",
            "+++ /home/winit-0.30.11/src/platform/windows.rs",
            "@@ -656,33 +656,98 @@",
            "     #[inline]",
            "     fn persistent_identifier(&self) -> Option<String> {",
            "         self.0.persistent_identifier()",
            "     }",
            " }",
            " ",
            " /// Additional methods on `Icon` that are specific to Windows.",
            "+///",
            "+/// Windows icons can be created from files, or from the [`embedded resources`](https://learn.microsoft.com/en-us/windows/win32/menurc/about-resource-files).",
            "+///",
            "+/// The `ICON` resource definition statement use the following syntax:",
            "+/// ```rc",
            "+/// nameID ICON filename",
            "+/// ```",
            "+/// `nameID` is a unique name or a 16-bit unsigned integer value identifying the resource,",
            "+/// `filename` is the name of the file that contains the resource.",
            "+///",
            "+/// More information about the `ICON` resource can be found at [`Microsoft Learn`](https://learn.microsoft.com/en-us/windows/win32/menurc/icon-resource) portal.",
            " pub trait IconExtWindows: Sized {",
            "     /// Create an icon from a file path.",
            "     ///",
            "     /// Specify `size` to load a specific icon size from the file, or `None` to load the default",
            "     /// icon size from the file.",
            "     ///",
            "     /// In cases where the specified size does not exist in the file, Windows may perform scaling",
            "     /// to get an icon of the desired size.",
            "     fn from_path<P: AsRef<Path>>(path: P, size: Option<PhysicalSize<u32>>)",
            "         -> Result<Self, BadIcon>;",
            " ",
            "-    /// Create an icon from a resource embedded in this executable or library.",
            "+    /// Create an icon from a resource embedded in this executable or library by its ordinal id.",
            "+    ///",
            "+    /// The valid `ordinal` values range from 1 to [`u16::MAX`] (inclusive). The value `0` is an",
            "+    /// invalid ordinal id, but it can be used with [`from_resource_name`] as `\"0\"`.",
            "+    ///",
            "+    /// [`from_resource_name`]: IconExtWindows::from_resource_name",
            "     ///",
            "     /// Specify `size` to load a specific icon size from the file, or `None` to load the default",
            "     /// icon size from the file.",
            "     ///",
            "     /// In cases where the specified size does not exist in the file, Windows may perform scaling",
            "     /// to get an icon of the desired size.",
            "     fn from_resource(ordinal: u16, size: Option<PhysicalSize<u32>>) -> Result<Self, BadIcon>;",
            "+",
            "+    /// Create an icon from a resource embedded in this executable or library by its name.",
            "+    ///",
            "+    /// Specify `size` to load a specific icon size from the file, or `None` to load the default",
            "+    /// icon size from the file.",
            "+    ///",
            "+    /// In cases where the specified size does not exist in the file, Windows may perform scaling",
            "+    /// to get an icon of the desired size.",
            "+    ///",
            "+    /// # Notes",
            "+    ///",
            "+    /// Consider the following resource definition statements:",
            "+    /// ```rc",
            "+    /// app     ICON \"app.ico\"",
            "+    /// 1       ICON \"a.ico\"",
            "+    /// 0027    ICON \"custom.ico\"",
            "+    /// 0       ICON \"alt.ico\"",
            "+    /// ```",
            "+    ///",
            "+    /// Due to some internal implementation details of the resource embedding/loading process on",
            "+    /// Windows platform, strings that can be interpreted as 16-bit unsigned integers (`\"1\"`,",
            "+    /// `\"002\"`, etc.) cannot be used as valid resource names, and instead should be passed into",
            "+    /// [`from_resource`]:",
            "+    ///",
            "+    /// [`from_resource`]: IconExtWindows::from_resource",
            "+    ///",
            "+    /// ```rust,no_run",
            "+    /// use winit::platform::windows::IconExtWindows;",
            "+    /// use winit::window::Icon;",
            "+    ///",
            "+    /// assert!(Icon::from_resource_name(\"app\", None).is_ok());",
            "+    /// assert!(Icon::from_resource(1, None).is_ok());",
            "+    /// assert!(Icon::from_resource(27, None).is_ok());",
            "+    /// assert!(Icon::from_resource_name(\"27\", None).is_err());",
            "+    /// assert!(Icon::from_resource_name(\"0027\", None).is_err());",
            "+    /// ```",
            "+    ///",
            "+    /// While `0` cannot be used as an ordinal id (see [`from_resource`]), it can be used as a",
            "+    /// name:",
            "+    ///",
            "+    /// [`from_resource`]: IconExtWindows::from_resource",
            "+    ///",
            "+    /// ```rust,no_run",
            "+    /// # use winit::platform::windows::IconExtWindows;",
            "+    /// # use winit::window::Icon;",
            "+    /// assert!(Icon::from_resource_name(\"0\", None).is_ok());",
            "+    /// assert!(Icon::from_resource(0, None).is_err());",
            "+    /// ```",
            "+    fn from_resource_name(name: &str, size: Option<PhysicalSize<u32>>) -> Result<Self, BadIcon>;",
            " }",
            " ",
            " impl IconExtWindows for Icon {",
            "     fn from_path<P: AsRef<Path>>(",
            "         path: P,",
            "         size: Option<PhysicalSize<u32>>,",
            "     ) -> Result<Self, BadIcon> {",
            "@@ -690,8 +755,13 @@",
            "         Ok(Icon { inner: win_icon })",
            "     }",
            " ",
            "     fn from_resource(ordinal: u16, size: Option<PhysicalSize<u32>>) -> Result<Self, BadIcon> {",
            "         let win_icon = crate::platform_impl::WinIcon::from_resource(ordinal, size)?;",
            "         Ok(Icon { inner: win_icon })",
            "     }",
            "+",
            "+    fn from_resource_name(name: &str, size: Option<PhysicalSize<u32>>) -> Result<Self, BadIcon> {",
            "+        let win_icon = crate::platform_impl::WinIcon::from_resource_name(name, size)?;",
            "+        Ok(Icon { inner: win_icon })",
            "+    }",
            " }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/ios/app_state.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/ios/app_state.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/ios/app_state.rs",
            "@@ -371,14 +371,15 @@",
            "         };",
            " ",
            "         let new = self.control_flow;",
            "         match (old, new) {",
            "             (ControlFlow::Wait, ControlFlow::Wait) => {",
            "                 let start = Instant::now();",
            "                 self.set_state(AppStateImpl::Waiting { waiting_handler, start });",
            "+                self.waker.stop()",
            "             },",
            "             (ControlFlow::WaitUntil(old_instant), ControlFlow::WaitUntil(new_instant))",
            "                 if old_instant == new_instant =>",
            "             {",
            "                 let start = Instant::now();",
            "                 self.set_state(AppStateImpl::Waiting { waiting_handler, start });",
            "             },"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/ios/event_loop.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/ios/event_loop.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/ios/event_loop.rs",
            "@@ -9,28 +9,34 @@",
            "     kCFRunLoopAfterWaiting, kCFRunLoopBeforeWaiting, kCFRunLoopCommonModes, kCFRunLoopDefaultMode,",
            "     kCFRunLoopExit, CFRunLoopActivity, CFRunLoopAddObserver, CFRunLoopAddSource, CFRunLoopGetMain,",
            "     CFRunLoopObserverCreate, CFRunLoopObserverRef, CFRunLoopSourceContext, CFRunLoopSourceCreate,",
            "     CFRunLoopSourceInvalidate, CFRunLoopSourceRef, CFRunLoopSourceSignal, CFRunLoopWakeUp,",
            " };",
            " use objc2::rc::Retained;",
            " use objc2::{msg_send_id, ClassType};",
            "-use objc2_foundation::{MainThreadMarker, NSString};",
            "-use objc2_ui_kit::{UIApplication, UIApplicationMain, UIDevice, UIScreen, UIUserInterfaceIdiom};",
            "+use objc2_foundation::{MainThreadMarker, NSNotificationCenter, NSObject};",
            "+use objc2_ui_kit::{",
            "+    UIApplication, UIApplicationDidBecomeActiveNotification,",
            "+    UIApplicationDidEnterBackgroundNotification, UIApplicationDidFinishLaunchingNotification,",
            "+    UIApplicationDidReceiveMemoryWarningNotification, UIApplicationMain,",
            "+    UIApplicationWillEnterForegroundNotification, UIApplicationWillResignActiveNotification,",
            "+    UIApplicationWillTerminateNotification, UIDevice, UIScreen, UIUserInterfaceIdiom,",
            "+};",
            " ",
            " use crate::error::EventLoopError;",
            " use crate::event::Event;",
            " use crate::event_loop::{",
            "     ActiveEventLoop as RootActiveEventLoop, ControlFlow, DeviceEvents, EventLoopClosed,",
            " };",
            " use crate::platform::ios::Idiom;",
            " use crate::platform_impl::ios::app_state::{EventLoopHandler, HandlePendingUserEvents};",
            " use crate::window::{CustomCursor, CustomCursorSource, Theme};",
            " ",
            "-use super::app_delegate::AppDelegate;",
            "-use super::app_state::AppState;",
            "+use super::app_state::{send_occluded_event_for_all_windows, AppState, EventWrapper};",
            "+use super::notification_center::create_observer;",
            " use super::{app_state, monitor, MonitorHandle};",
            " ",
            " #[derive(Debug)]",
            " pub struct ActiveEventLoop {",
            "     pub(super) mtm: MainThreadMarker,",
            " }",
            " ",
            "@@ -128,14 +134,26 @@",
            " }",
            " ",
            " pub struct EventLoop<T: 'static> {",
            "     mtm: MainThreadMarker,",
            "     sender: Sender<T>,",
            "     receiver: Receiver<T>,",
            "     window_target: RootActiveEventLoop,",
            "+",
            "+    // Since iOS 9.0, we no longer need to remove the observers before they are deallocated; the",
            "+    // system instead cleans it up next time it would have posted a notification to it.",
            "+    //",
            "+    // Though we do still need to keep the observers around to prevent them from being deallocated.",
            "+    _did_finish_launching_observer: Retained<NSObject>,",
            "+    _did_become_active_observer: Retained<NSObject>,",
            "+    _will_resign_active_observer: Retained<NSObject>,",
            "+    _will_enter_foreground_observer: Retained<NSObject>,",
            "+    _did_enter_background_observer: Retained<NSObject>,",
            "+    _will_terminate_observer: Retained<NSObject>,",
            "+    _did_receive_memory_warning_observer: Retained<NSObject>,",
            " }",
            " ",
            " #[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash)]",
            " pub(crate) struct PlatformSpecificEventLoopAttributes {}",
            " ",
            " impl<T: 'static> EventLoop<T> {",
            "     pub(crate) fn new(",
            "@@ -154,19 +172,105 @@",
            "         }",
            " ",
            "         let (sender, receiver) = mpsc::channel();",
            " ",
            "         // this line sets up the main run loop before `UIApplicationMain`",
            "         setup_control_flow_observers();",
            " ",
            "+        let center = unsafe { NSNotificationCenter::defaultCenter() };",
            "+",
            "+        let _did_finish_launching_observer = create_observer(",
            "+            &center,",
            "+            // `application:didFinishLaunchingWithOptions:`",
            "+            unsafe { UIApplicationDidFinishLaunchingNotification },",
            "+            move |_| {",
            "+                app_state::did_finish_launching(mtm);",
            "+            },",
            "+        );",
            "+        let _did_become_active_observer = create_observer(",
            "+            &center,",
            "+            // `applicationDidBecomeActive:`",
            "+            unsafe { UIApplicationDidBecomeActiveNotification },",
            "+            move |_| {",
            "+                app_state::handle_nonuser_event(mtm, EventWrapper::StaticEvent(Event::Resumed));",
            "+            },",
            "+        );",
            "+        let _will_resign_active_observer = create_observer(",
            "+            &center,",
            "+            // `applicationWillResignActive:`",
            "+            unsafe { UIApplicationWillResignActiveNotification },",
            "+            move |_| {",
            "+                app_state::handle_nonuser_event(mtm, EventWrapper::StaticEvent(Event::Suspended));",
            "+            },",
            "+        );",
            "+        let _will_enter_foreground_observer = create_observer(",
            "+            &center,",
            "+            // `applicationWillEnterForeground:`",
            "+            unsafe { UIApplicationWillEnterForegroundNotification },",
            "+            move |notification| {",
            "+                let app = unsafe { notification.object() }.expect(",
            "+                    \"UIApplicationWillEnterForegroundNotification to have application object\",",
            "+                );",
            "+                // SAFETY: The `object` in `UIApplicationWillEnterForegroundNotification` is",
            "+                // documented to be `UIApplication`.",
            "+                let app: Retained<UIApplication> = unsafe { Retained::cast(app) };",
            "+                send_occluded_event_for_all_windows(&app, false);",
            "+            },",
            "+        );",
            "+        let _did_enter_background_observer = create_observer(",
            "+            &center,",
            "+            // `applicationDidEnterBackground:`",
            "+            unsafe { UIApplicationDidEnterBackgroundNotification },",
            "+            move |notification| {",
            "+                let app = unsafe { notification.object() }.expect(",
            "+                    \"UIApplicationDidEnterBackgroundNotification to have application object\",",
            "+                );",
            "+                // SAFETY: The `object` in `UIApplicationDidEnterBackgroundNotification` is",
            "+                // documented to be `UIApplication`.",
            "+                let app: Retained<UIApplication> = unsafe { Retained::cast(app) };",
            "+                send_occluded_event_for_all_windows(&app, true);",
            "+            },",
            "+        );",
            "+        let _will_terminate_observer = create_observer(",
            "+            &center,",
            "+            // `applicationWillTerminate:`",
            "+            unsafe { UIApplicationWillTerminateNotification },",
            "+            move |notification| {",
            "+                let app = unsafe { notification.object() }",
            "+                    .expect(\"UIApplicationWillTerminateNotification to have application object\");",
            "+                // SAFETY: The `object` in `UIApplicationWillTerminateNotification` is",
            "+                // (somewhat) documented to be `UIApplication`.",
            "+                let app: Retained<UIApplication> = unsafe { Retained::cast(app) };",
            "+                app_state::terminated(&app);",
            "+            },",
            "+        );",
            "+        let _did_receive_memory_warning_observer = create_observer(",
            "+            &center,",
            "+            // `applicationDidReceiveMemoryWarning:`",
            "+            unsafe { UIApplicationDidReceiveMemoryWarningNotification },",
            "+            move |_| {",
            "+                app_state::handle_nonuser_event(",
            "+                    mtm,",
            "+                    EventWrapper::StaticEvent(Event::MemoryWarning),",
            "+                );",
            "+            },",
            "+        );",
            "+",
            "         Ok(EventLoop {",
            "             mtm,",
            "             sender,",
            "             receiver,",
            "             window_target: RootActiveEventLoop { p: ActiveEventLoop { mtm }, _marker: PhantomData },",
            "+            _did_finish_launching_observer,",
            "+            _did_become_active_observer,",
            "+            _will_resign_active_observer,",
            "+            _will_enter_foreground_observer,",
            "+            _did_enter_background_observer,",
            "+            _will_terminate_observer,",
            "+            _did_receive_memory_warning_observer,",
            "         })",
            "     }",
            " ",
            "     pub fn run<F>(self, handler: F) -> !",
            "     where",
            "         F: FnMut(Event<T>, &RootActiveEventLoop),",
            "     {",
            "@@ -188,29 +292,28 @@",
            "             >(Box::new(handler))",
            "         };",
            " ",
            "         let handler = EventLoopHandler { handler, event_loop: self.window_target };",
            " ",
            "         app_state::will_launch(self.mtm, handler);",
            " ",
            "-        // Ensure application delegate is initialized",
            "-        let _ = AppDelegate::class();",
            "-",
            "         extern \"C\" {",
            "             // These functions are in crt_externs.h.",
            "             fn _NSGetArgc() -> *mut c_int;",
            "             fn _NSGetArgv() -> *mut *mut *mut c_char;",
            "         }",
            " ",
            "         unsafe {",
            "             UIApplicationMain(",
            "                 *_NSGetArgc(),",
            "                 NonNull::new(*_NSGetArgv()).unwrap(),",
            "+                // We intentionally override neither the application nor the delegate, to allow the",
            "+                // user to do so themselves!",
            "+                None,",
            "                 None,",
            "-                Some(&NSString::from_str(AppDelegate::NAME)),",
            "             )",
            "         };",
            "         unreachable!()",
            "     }",
            " ",
            "     pub fn create_proxy(&self) -> EventLoopProxy<T> {",
            "         EventLoopProxy::new(self.sender.clone())"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/ios/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/ios/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/ios/mod.rs",
            "@@ -1,13 +1,13 @@",
            " #![allow(clippy::let_unit_value)]",
            " ",
            "-mod app_delegate;",
            " mod app_state;",
            " mod event_loop;",
            " mod monitor;",
            "+mod notification_center;",
            " mod view;",
            " mod view_controller;",
            " mod window;",
            " ",
            " use std::fmt;",
            " ",
            " use crate::event::DeviceId as RootDeviceId;"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/ios/view.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/ios/view.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/ios/view.rs",
            "@@ -186,15 +186,15 @@",
            "                     (TouchPhase::Moved, recognizer.scale() - last_scale)",
            "                 }",
            "                 UIGestureRecognizerState::Cancelled | UIGestureRecognizerState::Failed => {",
            "                     self.ivars().rotation_last_delta.set(0.0);",
            "                     // Pass -delta so that action is reversed",
            "                     (TouchPhase::Cancelled, -recognizer.scale())",
            "                 }",
            "-                state => panic!(\"unexpected recognizer state: {:?}\", state),",
            "+                state => panic!(\"unexpected recognizer state: {state:?}\"),",
            "             };",
            " ",
            "             let gesture_event = EventWrapper::StaticEvent(Event::WindowEvent {",
            "                 window_id: RootWindowId(window.id()),",
            "                 event: WindowEvent::PinchGesture {",
            "                     device_id: DEVICE_ID,",
            "                     delta: delta as f64,",
            "@@ -245,15 +245,15 @@",
            "                 }",
            "                 UIGestureRecognizerState::Cancelled | UIGestureRecognizerState::Failed => {",
            "                     self.ivars().rotation_last_delta.set(0.0);",
            " ",
            "                     // Pass -delta so that action is reversed",
            "                     (TouchPhase::Cancelled, -recognizer.rotation())",
            "                 }",
            "-                state => panic!(\"unexpected recognizer state: {:?}\", state),",
            "+                state => panic!(\"unexpected recognizer state: {state:?}\"),",
            "             };",
            " ",
            "             // Make delta negative to match macos, convert to degrees",
            "             let gesture_event = EventWrapper::StaticEvent(Event::WindowEvent {",
            "                 window_id: RootWindowId(window.id()),",
            "                 event: WindowEvent::RotationGesture {",
            "                     device_id: DEVICE_ID,",
            "@@ -296,15 +296,15 @@",
            "                 }",
            "                 UIGestureRecognizerState::Cancelled | UIGestureRecognizerState::Failed => {",
            "                     let last_pan: CGPoint = self.ivars().pan_last_delta.replace(CGPoint{x:0.0, y:0.0});",
            " ",
            "                     // Pass -delta so that action is reversed",
            "                     (TouchPhase::Cancelled, -last_pan.x, -last_pan.y)",
            "                 }",
            "-                state => panic!(\"unexpected recognizer state: {:?}\", state),",
            "+                state => panic!(\"unexpected recognizer state: {state:?}\"),",
            "             };",
            " ",
            " ",
            "             let gesture_event = EventWrapper::StaticEvent(Event::WindowEvent {",
            "                 window_id: RootWindowId(window.id()),",
            "                 event: WindowEvent::PanGesture {",
            "                     device_id: DEVICE_ID,"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/common/xkb/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/common/xkb/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/common/xkb/mod.rs",
            "@@ -316,15 +316,15 @@",
            " ",
            "     pub fn text(&mut self) -> Option<SmolStr> {",
            "         self.composed_text().unwrap_or_else(|_| self.context.keysym_to_utf8_raw(self.keysym))",
            "     }",
            " ",
            "     // The current behaviour makes it so composing a character overrides attempts to input a",
            "     // control character with the `Ctrl` key. We can potentially add a configuration option",
            "-    // if someone specifically wants the oppsite behaviour.",
            "+    // if someone specifically wants the opposite behaviour.",
            "     pub fn text_with_all_modifiers(&mut self) -> Option<SmolStr> {",
            "         match self.composed_text() {",
            "             Ok(text) => text,",
            "             Err(_) => self.context.state.get_utf8_raw(self.keycode, self.context.scratch_buffer),",
            "         }",
            "     }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/mod.rs",
            "@@ -692,14 +692,15 @@",
            "             *xconn.latest_error.lock().unwrap() = Some(error);",
            "         }",
            "     }",
            "     // Fun fact: this return value is completely ignored.",
            "     0",
            " }",
            " ",
            "+#[allow(clippy::large_enum_variant)]",
            " pub enum EventLoop<T: 'static> {",
            "     #[cfg(wayland_platform)]",
            "     Wayland(Box<wayland::EventLoop<T>>),",
            "     #[cfg(x11_platform)]",
            "     X(x11::EventLoop<T>),",
            " }",
            " ",
            "@@ -764,17 +765,17 @@",
            "                 return Err(EventLoopError::Os(os_error!(OsError::Misc(msg))));",
            "             },",
            "         };",
            " ",
            "         // Create the display based on the backend.",
            "         match backend {",
            "             #[cfg(wayland_platform)]",
            "-            Backend::Wayland => EventLoop::new_wayland_any_thread().map_err(Into::into),",
            "+            Backend::Wayland => EventLoop::new_wayland_any_thread(),",
            "             #[cfg(x11_platform)]",
            "-            Backend::X => EventLoop::new_x11_any_thread().map_err(Into::into),",
            "+            Backend::X => EventLoop::new_x11_any_thread(),",
            "         }",
            "     }",
            " ",
            "     #[cfg(wayland_platform)]",
            "     fn new_wayland_any_thread() -> Result<EventLoop<T>, EventLoopError> {",
            "         wayland::EventLoop::new().map(|evlp| EventLoop::Wayland(Box::new(evlp)))",
            "     }",
            "@@ -845,14 +846,15 @@",
            " ",
            " impl<T: 'static> EventLoopProxy<T> {",
            "     pub fn send_event(&self, event: T) -> Result<(), EventLoopClosed<T>> {",
            "         x11_or_wayland!(match self; EventLoopProxy(proxy) => proxy.send_event(event))",
            "     }",
            " }",
            " ",
            "+#[allow(clippy::large_enum_variant)]",
            " pub enum ActiveEventLoop {",
            "     #[cfg(wayland_platform)]",
            "     Wayland(wayland::ActiveEventLoop),",
            "     #[cfg(x11_platform)]",
            "     X(x11::ActiveEventLoop),",
            " }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/event_loop/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/event_loop/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/event_loop/mod.rs",
            "@@ -1,22 +1,28 @@",
            " //! The event-loop routines.",
            " ",
            " use std::cell::{Cell, RefCell};",
            " use std::io::Result as IOResult;",
            " use std::marker::PhantomData;",
            " use std::mem;",
            "+use std::os::fd::OwnedFd;",
            " use std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, RawFd};",
            " use std::rc::Rc;",
            " use std::sync::atomic::Ordering;",
            "-use std::sync::{Arc, Mutex};",
            "+use std::sync::{Arc, Condvar, Mutex};",
            "+use std::thread::JoinHandle;",
            " use std::time::{Duration, Instant};",
            " ",
            "+use calloop::ping::Ping;",
            "+use rustix::event::{PollFd, PollFlags};",
            "+use rustix::pipe::{self, PipeFlags};",
            " use sctk::reexports::calloop::Error as CalloopError;",
            " use sctk::reexports::calloop_wayland_source::WaylandSource;",
            " use sctk::reexports::client::{globals, Connection, QueueHandle};",
            "+use tracing::warn;",
            " ",
            " use crate::cursor::OnlyCursorImage;",
            " use crate::dpi::LogicalSize;",
            " use crate::error::{EventLoopError, OsError as RootOsError};",
            " use crate::event::{Event, InnerSizeWriter, StartCause, WindowEvent};",
            " use crate::event_loop::{ActiveEventLoop as RootActiveEventLoop, ControlFlow, DeviceEvents};",
            " use crate::platform::pump_events::PumpStatus;",
            "@@ -64,14 +70,16 @@",
            " ",
            "     /// Event loop window target.",
            "     window_target: RootActiveEventLoop,",
            " ",
            "     // XXX drop after everything else, just to be safe.",
            "     /// Calloop's event loop.",
            "     event_loop: calloop::EventLoop<'static, WinitState>,",
            "+",
            "+    pump_event_notifier: Option<PumpEventNotifier>,",
            " }",
            " ",
            " impl<T: 'static> EventLoop<T> {",
            "     pub fn new() -> Result<EventLoop<T>, EventLoopError> {",
            "         macro_rules! map_err {",
            "             ($e:expr, $err:expr) => {",
            "                 $e.map_err(|error| os_error!($err(error).into()))",
            "@@ -164,14 +172,15 @@",
            "             user_events_sender,",
            "             pending_user_events,",
            "             event_loop,",
            "             window_target: RootActiveEventLoop {",
            "                 p: PlatformActiveEventLoop::Wayland(window_target),",
            "                 _marker: PhantomData,",
            "             },",
            "+            pump_event_notifier: None,",
            "         };",
            " ",
            "         Ok(event_loop)",
            "     }",
            " ",
            "     pub fn run_on_demand<F>(&mut self, mut event_handler: F) -> Result<(), EventLoopError>",
            "     where",
            "@@ -219,14 +228,35 @@",
            "         if let Some(code) = self.exit_code() {",
            "             self.loop_running = false;",
            " ",
            "             callback(Event::LoopExiting, self.window_target());",
            " ",
            "             PumpStatus::Exit(code)",
            "         } else {",
            "+            // NOTE: spawn a wake-up thread, thus if we have code reading the wayland connection",
            "+            // in parallel to winit, we ensure that the loop itself is marked as having events.",
            "+            if timeout.is_some() && self.pump_event_notifier.is_none() {",
            "+                let awakener = match &self.window_target.p {",
            "+                    PlatformActiveEventLoop::Wayland(window_target) => {",
            "+                        window_target.event_loop_awakener.clone()",
            "+                    },",
            "+                    #[cfg(x11_platform)]",
            "+                    PlatformActiveEventLoop::X(_) => unreachable!(),",
            "+                };",
            "+",
            "+                self.pump_event_notifier =",
            "+                    Some(PumpEventNotifier::spawn(self.connection.clone(), awakener));",
            "+            }",
            "+",
            "+            if let Some(pump_event_notifier) = self.pump_event_notifier.as_ref() {",
            "+                // Notify that we don't have to wait, since we're out of winit.",
            "+                *pump_event_notifier.control.0.lock().unwrap() = PumpEventNotifierAction::Monitor;",
            "+                pump_event_notifier.control.1.notify_one();",
            "+            }",
            "+",
            "             PumpStatus::Continue",
            "         }",
            "     }",
            " ",
            "     pub fn poll_events_with_timeout<F>(&mut self, mut timeout: Option<Duration>, mut callback: F)",
            "     where",
            "         F: FnMut(Event<T>, &RootActiveEventLoop),",
            "@@ -281,15 +311,18 @@",
            "                         StartCause::ResumeTimeReached { start, requested_resume: deadline }",
            "                     }",
            "                 },",
            "             };",
            " ",
            "             // Reduce spurious wake-ups.",
            "             let dispatched_events = self.with_state(|state| state.dispatched_events);",
            "-            if matches!(cause, StartCause::WaitCancelled { .. }) && !dispatched_events {",
            "+            if matches!(cause, StartCause::WaitCancelled { .. })",
            "+                && !dispatched_events",
            "+                && timeout.is_none()",
            "+            {",
            "                 continue;",
            "             }",
            " ",
            "             break cause;",
            "         };",
            " ",
            "         self.single_iteration(&mut callback, cause);",
            "@@ -596,15 +629,15 @@",
            "     fn as_raw_fd(&self) -> RawFd {",
            "         self.event_loop.as_raw_fd()",
            "     }",
            " }",
            " ",
            " pub struct ActiveEventLoop {",
            "     /// The event loop wakeup source.",
            "-    pub event_loop_awakener: calloop::ping::Ping,",
            "+    pub event_loop_awakener: Ping,",
            " ",
            "     /// The main queue used by the event loop.",
            "     pub queue_handle: QueueHandle<WinitState>,",
            " ",
            "     /// The application's latest control_flow state",
            "     pub(crate) control_flow: Cell<ControlFlow>,",
            " ",
            "@@ -680,7 +713,98 @@",
            "         Ok(rwh_06::WaylandDisplayHandle::new({",
            "             let ptr = self.connection.display().id().as_ptr();",
            "             std::ptr::NonNull::new(ptr as *mut _).expect(\"wl_display should never be null\")",
            "         })",
            "         .into())",
            "     }",
            " }",
            "+",
            "+#[derive(Debug)]",
            "+struct PumpEventNotifier {",
            "+    /// Whether we're in winit or not.",
            "+    control: Arc<(Mutex<PumpEventNotifierAction>, Condvar)>,",
            "+    /// Waker handle for the working thread.",
            "+    worker_waker: Option<OwnedFd>,",
            "+    /// Thread handle.",
            "+    handle: Option<JoinHandle<()>>,",
            "+}",
            "+",
            "+impl Drop for PumpEventNotifier {",
            "+    fn drop(&mut self) {",
            "+        // Wake-up the thread.",
            "+        if let Some(worker_waker) = self.worker_waker.as_ref() {",
            "+            let _ = rustix::io::write(worker_waker.as_fd(), &[0u8]);",
            "+        }",
            "+        *self.control.0.lock().unwrap() = PumpEventNotifierAction::Shutdown;",
            "+        self.control.1.notify_one();",
            "+",
            "+        if let Some(handle) = self.handle.take() {",
            "+            let _ = handle.join();",
            "+        }",
            "+    }",
            "+}",
            "+",
            "+impl PumpEventNotifier {",
            "+    fn spawn(connection: Connection, awakener: Ping) -> Self {",
            "+        // Start from the waiting state.",
            "+        let control = Arc::new((Mutex::new(PumpEventNotifierAction::Pause), Condvar::new()));",
            "+        let control_thread = Arc::clone(&control);",
            "+",
            "+        let (read, write) = match pipe::pipe_with(PipeFlags::CLOEXEC | PipeFlags::NONBLOCK) {",
            "+            Ok((read, write)) => (read, write),",
            "+            Err(_) => return Self { control, handle: None, worker_waker: None },",
            "+        };",
            "+",
            "+        let handle =",
            "+            std::thread::Builder::new().name(String::from(\"pump_events mon\")).spawn(move || {",
            "+                let (lock, cvar) = &*control_thread;",
            "+                'outer: loop {",
            "+                    let mut wait = lock.lock().unwrap();",
            "+                    while *wait == PumpEventNotifierAction::Pause {",
            "+                        wait = cvar.wait(wait).unwrap();",
            "+                    }",
            "+",
            "+                    // Exit the loop when we're asked to. Given that we poll",
            "+                    // only once we can take the `prepare_read`, but in some cases",
            "+                    // it could be not possible, we may block on `join`.",
            "+                    if *wait == PumpEventNotifierAction::Shutdown {",
            "+                        break 'outer;",
            "+                    }",
            "+",
            "+                    // Wake-up the main loop and put this one back to sleep.",
            "+                    *wait = PumpEventNotifierAction::Pause;",
            "+                    drop(wait);",
            "+",
            "+                    while let Some(read_guard) = connection.prepare_read() {",
            "+                        let _ = connection.flush();",
            "+                        let poll_fd = PollFd::from_borrowed_fd(connection.as_fd(), PollFlags::IN);",
            "+                        let pipe_poll_fd = PollFd::from_borrowed_fd(read.as_fd(), PollFlags::IN);",
            "+                        // Read from the `fd` before going back to poll.",
            "+                        if Ok(1) == rustix::io::read(read.as_fd(), &mut [0u8; 1]) {",
            "+                            break 'outer;",
            "+                        }",
            "+                        let _ = rustix::event::poll(&mut [poll_fd, pipe_poll_fd], -1);",
            "+                        // Non-blocking read the connection.",
            "+                        let _ = read_guard.read_without_dispatch();",
            "+                    }",
            "+",
            "+                    awakener.ping();",
            "+                }",
            "+            });",
            "+",
            "+        if let Some(err) = handle.as_ref().err() {",
            "+            warn!(\"failed to spawn pump_events wake-up thread: {err}\");",
            "+        }",
            "+",
            "+        PumpEventNotifier { control, handle: handle.ok(), worker_waker: Some(write) }",
            "+    }",
            "+}",
            "+",
            "+#[derive(Debug, PartialEq, Eq)]",
            "+enum PumpEventNotifierAction {",
            "+    /// Monitor the wayland queue.",
            "+    Monitor,",
            "+    /// Pause monitoring.",
            "+    Pause,",
            "+    /// Shutdown the thread.",
            "+    Shutdown,",
            "+}"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/seat/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/seat/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/seat/mod.rs",
            "@@ -92,16 +92,20 @@",
            "             SeatCapability::Keyboard if seat_state.keyboard_state.is_none() => {",
            "                 let keyboard = seat.get_keyboard(queue_handle, KeyboardData::new(seat.clone()));",
            "                 seat_state.keyboard_state =",
            "                     Some(KeyboardState::new(keyboard, self.loop_handle.clone()));",
            "             },",
            "             SeatCapability::Pointer if seat_state.pointer.is_none() => {",
            "                 let surface = self.compositor_state.create_surface(queue_handle);",
            "+                let viewport = self",
            "+                    .viewporter_state",
            "+                    .as_ref()",
            "+                    .map(|state| state.get_viewport(&surface, queue_handle));",
            "                 let surface_id = surface.id();",
            "-                let pointer_data = WinitPointerData::new(seat.clone());",
            "+                let pointer_data = WinitPointerData::new(seat.clone(), viewport);",
            "                 let themed_pointer = self",
            "                     .seat_state",
            "                     .get_pointer_with_theme_and_data(",
            "                         queue_handle,",
            "                         &seat,",
            "                         self.shm.wl_shm(),",
            "                         surface,"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/seat/pointer/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/seat/pointer/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/seat/pointer/mod.rs",
            "@@ -14,14 +14,15 @@",
            " use sctk::reexports::protocols::wp::pointer_constraints::zv1::client::zwp_confined_pointer_v1::ZwpConfinedPointerV1;",
            " use sctk::reexports::protocols::wp::pointer_constraints::zv1::client::zwp_locked_pointer_v1::ZwpLockedPointerV1;",
            " use sctk::reexports::protocols::wp::cursor_shape::v1::client::wp_cursor_shape_device_v1::WpCursorShapeDeviceV1;",
            " use sctk::reexports::protocols::wp::cursor_shape::v1::client::wp_cursor_shape_manager_v1::WpCursorShapeManagerV1;",
            " use sctk::reexports::protocols::wp::pointer_constraints::zv1::client::zwp_pointer_constraints_v1::{Lifetime, ZwpPointerConstraintsV1};",
            " use sctk::reexports::client::globals::{BindError, GlobalList};",
            " use sctk::reexports::csd_frame::FrameClick;",
            "+use sctk::reexports::protocols::wp::viewporter::client::wp_viewport::WpViewport;",
            " ",
            " use sctk::compositor::SurfaceData;",
            " use sctk::globals::GlobalData;",
            " use sctk::seat::pointer::{",
            "     PointerData, PointerDataExt, PointerEvent, PointerEventKind, PointerHandler,",
            " };",
            " use sctk::seat::SeatState;",
            "@@ -189,15 +190,15 @@",
            "                         }",
            "                     };",
            " ",
            "                     // Update the phase.",
            "                     pointer_data.phase = phase;",
            " ",
            "                     // Mice events have both pixel and discrete delta's at the same time. So prefer",
            "-                    // the descrite values if they are present.",
            "+                    // the discrete values if they are present.",
            "                     let delta = if has_discrete_scroll {",
            "                         // NOTE: Wayland sign convention is the inverse of winit.",
            "                         MouseScrollDelta::LineDelta(",
            "                             (-horizontal.discrete) as f32,",
            "                             (-vertical.discrete) as f32,",
            "                         )",
            "                     } else {",
            "@@ -221,21 +222,25 @@",
            " #[derive(Debug)]",
            " pub struct WinitPointerData {",
            "     /// The inner winit data associated with the pointer.",
            "     inner: Mutex<WinitPointerDataInner>,",
            " ",
            "     /// The data required by the sctk.",
            "     sctk_data: PointerData,",
            "+",
            "+    /// Viewport for fractional cursor.",
            "+    viewport: Option<WpViewport>,",
            " }",
            " ",
            " impl WinitPointerData {",
            "-    pub fn new(seat: WlSeat) -> Self {",
            "+    pub fn new(seat: WlSeat, viewport: Option<WpViewport>) -> Self {",
            "         Self {",
            "             inner: Mutex::new(WinitPointerDataInner::default()),",
            "             sctk_data: PointerData::new(seat),",
            "+            viewport,",
            "         }",
            "     }",
            " ",
            "     pub fn lock_pointer(",
            "         &self,",
            "         pointer_constraints: &PointerConstraintsState,",
            "         surface: &WlSurface,",
            "@@ -308,14 +313,26 @@",
            " ",
            "     pub fn set_locked_cursor_position(&self, surface_x: f64, surface_y: f64) {",
            "         let inner = self.inner.lock().unwrap();",
            "         if let Some(locked_pointer) = inner.locked_pointer.as_ref() {",
            "             locked_pointer.set_cursor_position_hint(surface_x, surface_y);",
            "         }",
            "     }",
            "+",
            "+    pub fn viewport(&self) -> Option<&WpViewport> {",
            "+        self.viewport.as_ref()",
            "+    }",
            "+}",
            "+",
            "+impl Drop for WinitPointerData {",
            "+    fn drop(&mut self) {",
            "+        if let Some(viewport) = self.viewport.take() {",
            "+            viewport.destroy();",
            "+        }",
            "+    }",
            " }",
            " ",
            " impl PointerDataExt for WinitPointerData {",
            "     fn pointer_data(&self) -> &PointerData {",
            "         &self.sctk_data",
            "     }",
            " }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/seat/text_input/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/seat/text_input/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/seat/text_input/mod.rs",
            "@@ -117,19 +117,23 @@",
            "             },",
            "             TextInputEvent::Done { .. } => {",
            "                 let window_id = match text_input_data.surface.as_ref() {",
            "                     Some(surface) => wayland::make_wid(surface),",
            "                     None => return,",
            "                 };",
            " ",
            "-                // Clear preedit at the start of `Done`.",
            "-                state.events_sink.push_window_event(",
            "-                    WindowEvent::Ime(Ime::Preedit(String::new(), None)),",
            "-                    window_id,",
            "-                );",
            "+                // Clear preedit, unless all we'll be doing next is sending a new preedit.",
            "+                if text_input_data.pending_commit.is_some()",
            "+                    || text_input_data.pending_preedit.is_none()",
            "+                {",
            "+                    state.events_sink.push_window_event(",
            "+                        WindowEvent::Ime(Ime::Preedit(String::new(), None)),",
            "+                        window_id,",
            "+                    );",
            "+                }",
            " ",
            "                 // Send `Commit`.",
            "                 if let Some(text) = text_input_data.pending_commit.take() {",
            "                     state",
            "                         .events_sink",
            "                         .push_window_event(WindowEvent::Ime(Ime::Commit(text)), window_id);",
            "                 }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/types/xdg_activation.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/types/xdg_activation.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/types/xdg_activation.rs",
            "@@ -76,15 +76,15 @@",
            "                     attention_requested.store(false, std::sync::atomic::Ordering::Relaxed);",
            "                 }",
            "             },",
            "             XdgActivationTokenData::Obtain((window_id, serial)) => {",
            "                 state.events_sink.push_window_event(",
            "                     crate::event::WindowEvent::ActivationTokenDone {",
            "                         serial: *serial,",
            "-                        token: ActivationToken::_new(token),",
            "+                        token: ActivationToken::from_raw(token),",
            "                     },",
            "                     *window_id,",
            "                 );",
            "             },",
            "         }",
            " ",
            "         proxy.destroy();"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/window/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/window/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/window/mod.rs",
            "@@ -1,9 +1,11 @@",
            " //! The Wayland window.",
            " ",
            "+use std::ffi::c_void;",
            "+use std::ptr::NonNull;",
            " use std::sync::atomic::{AtomicBool, Ordering};",
            " use std::sync::{Arc, Mutex};",
            " ",
            " use sctk::reexports::client::protocol::wl_display::WlDisplay;",
            " use sctk::reexports::client::protocol::wl_surface::WlSurface;",
            " use sctk::reexports::client::{Proxy, QueueHandle};",
            " ",
            "@@ -164,15 +166,15 @@",
            "             Cursor::Custom(cursor) => window_state.set_custom_cursor(cursor),",
            "         }",
            " ",
            "         // Activate the window when the token is passed.",
            "         if let (Some(xdg_activation), Some(token)) =",
            "             (xdg_activation.as_ref(), attributes.platform_specific.activation_token)",
            "         {",
            "-            xdg_activation.activate(token._token, &surface);",
            "+            xdg_activation.activate(token.token, &surface);",
            "         }",
            " ",
            "         // XXX Do initial commit.",
            "         window.commit();",
            " ",
            "         // Add the window and window requests into the state.",
            "         let window_state = Arc::new(Mutex::new(window_state));",
            "@@ -219,14 +221,18 @@",
            "             xdg_activation,",
            "             attention_requested: Arc::new(AtomicBool::new(false)),",
            "             event_loop_awakener,",
            "             window_requests,",
            "             window_events_sink,",
            "         })",
            "     }",
            "+",
            "+    pub(crate) fn xdg_toplevel(&self) -> Option<NonNull<c_void>> {",
            "+        NonNull::new(self.window.xdg_toplevel().id().as_ptr().cast())",
            "+    }",
            " }",
            " ",
            " impl Window {",
            "     #[inline]",
            "     pub fn id(&self) -> WindowId {",
            "         self.window_id",
            "     }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/wayland/window/state.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/wayland/window/state.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/wayland/window/state.rs",
            "@@ -27,15 +27,15 @@",
            " use sctk::shell::WaylandSurface;",
            " use sctk::shm::slot::SlotPool;",
            " use sctk::shm::Shm;",
            " use sctk::subcompositor::SubcompositorState;",
            " use wayland_protocols_plasma::blur::client::org_kde_kwin_blur::OrgKdeKwinBlur;",
            " ",
            " use crate::cursor::CustomCursor as RootCustomCursor;",
            "-use crate::dpi::{LogicalPosition, LogicalSize, PhysicalSize, Size};",
            "+use crate::dpi::{LogicalPosition, LogicalSize, PhysicalPosition, PhysicalSize, Size};",
            " use crate::error::{ExternalError, NotSupportedError};",
            " use crate::platform_impl::wayland::logical_to_physical_rounded;",
            " use crate::platform_impl::wayland::types::cursor::{CustomCursor, SelectedCursor};",
            " use crate::platform_impl::wayland::types::kwin_blur::KWinBlurManager;",
            " use crate::platform_impl::{PlatformCustomCursor, WindowId};",
            " use crate::window::{CursorGrabMode, CursorIcon, ImePurpose, ResizeDirection, Theme};",
            " ",
            "@@ -218,17 +218,17 @@",
            "             transparent: false,",
            "             viewport,",
            "             window,",
            "         }",
            "     }",
            " ",
            "     /// Apply closure on the given pointer.",
            "-    fn apply_on_pointer<F: Fn(&ThemedPointer<WinitPointerData>, &WinitPointerData)>(",
            "+    fn apply_on_pointer<F: FnMut(&ThemedPointer<WinitPointerData>, &WinitPointerData)>(",
            "         &self,",
            "-        callback: F,",
            "+        mut callback: F,",
            "     ) {",
            "         self.pointers.iter().filter_map(Weak::upgrade).for_each(|pointer| {",
            "             let data = pointer.pointer().winit_data();",
            "             callback(pointer.as_ref(), data);",
            "         })",
            "     }",
            " ",
            "@@ -722,40 +722,46 @@",
            "             self.apply_custom_cursor(&cursor);",
            "         }",
            " ",
            "         self.selected_cursor = SelectedCursor::Custom(cursor);",
            "     }",
            " ",
            "     fn apply_custom_cursor(&self, cursor: &CustomCursor) {",
            "-        self.apply_on_pointer(|pointer, _| {",
            "+        self.apply_on_pointer(|pointer, data| {",
            "             let surface = pointer.surface();",
            " ",
            "-            let scale = surface.data::<SurfaceData>().unwrap().surface_data().scale_factor();",
            "+            let scale = if let Some(viewport) = data.viewport() {",
            "+                let scale = self.scale_factor();",
            "+                let size = PhysicalSize::new(cursor.w, cursor.h).to_logical(scale);",
            "+                viewport.set_destination(size.width, size.height);",
            "+                scale",
            "+            } else {",
            "+                let scale = surface.data::<SurfaceData>().unwrap().surface_data().scale_factor();",
            "+                surface.set_buffer_scale(scale);",
            "+                scale as f64",
            "+            };",
            " ",
            "-            surface.set_buffer_scale(scale);",
            "             surface.attach(Some(cursor.buffer.wl_buffer()), 0, 0);",
            "             if surface.version() >= 4 {",
            "                 surface.damage_buffer(0, 0, cursor.w, cursor.h);",
            "             } else {",
            "-                surface.damage(0, 0, cursor.w / scale, cursor.h / scale);",
            "+                let size = PhysicalSize::new(cursor.w, cursor.h).to_logical(scale);",
            "+                surface.damage(0, 0, size.width, size.height);",
            "             }",
            "             surface.commit();",
            " ",
            "             let serial = pointer",
            "                 .pointer()",
            "                 .data::<WinitPointerData>()",
            "                 .and_then(|data| data.pointer_data().latest_enter_serial())",
            "                 .unwrap();",
            " ",
            "-            pointer.pointer().set_cursor(",
            "-                serial,",
            "-                Some(surface),",
            "-                cursor.hotspot_x / scale,",
            "-                cursor.hotspot_y / scale,",
            "-            );",
            "+            let hotspot =",
            "+                PhysicalPosition::new(cursor.hotspot_x, cursor.hotspot_y).to_logical(scale);",
            "+            pointer.pointer().set_cursor(serial, Some(surface), hotspot.x, hotspot.y);",
            "         });",
            "     }",
            " ",
            "     /// Set maximum inner window size.",
            "     pub fn set_min_inner_size(&mut self, size: Option<LogicalSize<u32>>) {",
            "         // Ensure that the window has the right minimum size.",
            "         let mut size = size.unwrap_or(MIN_WINDOW_SIZE);",
            "@@ -823,42 +829,59 @@",
            "     fn set_cursor_grab_inner(&mut self, mode: CursorGrabMode) -> Result<(), ExternalError> {",
            "         let pointer_constraints = match self.pointer_constraints.as_ref() {",
            "             Some(pointer_constraints) => pointer_constraints,",
            "             None if mode == CursorGrabMode::None => return Ok(()),",
            "             None => return Err(ExternalError::NotSupported(NotSupportedError::new())),",
            "         };",
            " ",
            "-        // Replace the current mode.",
            "-        let old_mode = std::mem::replace(&mut self.cursor_grab_mode.current_grab_mode, mode);",
            "-",
            "-        match old_mode {",
            "-            CursorGrabMode::None => (),",
            "+        let mut unset_old = false;",
            "+        match self.cursor_grab_mode.current_grab_mode {",
            "+            CursorGrabMode::None => unset_old = true,",
            "             CursorGrabMode::Confined => self.apply_on_pointer(|_, data| {",
            "                 data.unconfine_pointer();",
            "+                unset_old = true;",
            "             }),",
            "             CursorGrabMode::Locked => {",
            "-                self.apply_on_pointer(|_, data| data.unlock_pointer());",
            "+                self.apply_on_pointer(|_, data| {",
            "+                    data.unlock_pointer();",
            "+                    unset_old = true;",
            "+                });",
            "             },",
            "         }",
            " ",
            "+        // In case we haven't unset the old mode, it means that we don't have a cursor above",
            "+        // the window, thus just wait for it to re-appear.",
            "+        if !unset_old {",
            "+            return Ok(());",
            "+        }",
            "+",
            "+        let mut set_mode = false;",
            "         let surface = self.window.wl_surface();",
            "         match mode {",
            "             CursorGrabMode::Locked => self.apply_on_pointer(|pointer, data| {",
            "                 let pointer = pointer.pointer();",
            "-                data.lock_pointer(pointer_constraints, surface, pointer, &self.queue_handle)",
            "+                data.lock_pointer(pointer_constraints, surface, pointer, &self.queue_handle);",
            "+                set_mode = true;",
            "             }),",
            "             CursorGrabMode::Confined => self.apply_on_pointer(|pointer, data| {",
            "                 let pointer = pointer.pointer();",
            "-                data.confine_pointer(pointer_constraints, surface, pointer, &self.queue_handle)",
            "+                data.confine_pointer(pointer_constraints, surface, pointer, &self.queue_handle);",
            "+                set_mode = true;",
            "             }),",
            "             CursorGrabMode::None => {",
            "                 // Current lock/confine was already removed.",
            "+                set_mode = true;",
            "             },",
            "         }",
            " ",
            "+        // Replace the current grab mode after we've ensure that it got updated.",
            "+        if set_mode {",
            "+            self.cursor_grab_mode.current_grab_mode = mode;",
            "+        }",
            "+",
            "         Ok(())",
            "     }",
            " ",
            "     pub fn show_window_menu(&self, position: LogicalPosition<u32>) {",
            "         // TODO(kchibisov) handle touch serials.",
            "         self.apply_on_pointer(|_, data| {",
            "             let serial = data.latest_button_serial();"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/activation.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/activation.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/activation.rs",
            "@@ -168,15 +168,15 @@",
            "     impl std::fmt::Write for Writer<'_> {",
            "         fn write_str(&mut self, s: &str) -> std::fmt::Result {",
            "             self.buffer.extend_from_slice(s.as_bytes());",
            "             Ok(())",
            "         }",
            "     }",
            " ",
            "-    write!(Writer { buffer }, \"{}\", display).unwrap();",
            "+    write!(Writer { buffer }, \"{display}\").unwrap();",
            " }",
            " ",
            " #[cfg(test)]",
            " mod tests {",
            "     use super::*;",
            " ",
            "     #[test]"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/event_processor.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/event_processor.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/event_processor.rs",
            "@@ -62,15 +62,18 @@",
            "     // Used to detect key repeats.",
            "     pub held_key_press: Option<u32>,",
            "     pub first_touch: Option<u64>,",
            "     // Currently focused window belonging to this process",
            "     pub active_window: Option<xproto::Window>,",
            "     /// Latest modifiers we've sent for the user to trigger change in event.",
            "     pub modifiers: Cell<ModifiersState>,",
            "-    pub xfiltered_modifiers: VecDeque<c_ulong>,",
            "+    // Track modifiers based on keycodes. NOTE: that serials generally don't work for tracking",
            "+    // since they are not unique and could be duplicated in case of sequence of key events is",
            "+    // delivered at near the same time.",
            "+    pub xfiltered_modifiers: VecDeque<u8>,",
            "     pub xmodmap: util::ModifierKeymap,",
            "     pub is_composing: bool,",
            " }",
            " ",
            " impl EventProcessor {",
            "     pub fn process_event<T: 'static, F>(&mut self, xev: &mut XEvent, mut callback: F)",
            "     where",
            "@@ -159,21 +162,19 @@",
            "                 .unwrap_or(false);",
            " ",
            "             let filtered = forward_to_ime && self.filter_event(xev);",
            "             if filtered {",
            "                 let xev: &XKeyEvent = xev.as_ref();",
            "                 if self.xmodmap.is_modifier(xev.keycode as u8) {",
            "                     // Don't grow the buffer past the `MAX_MOD_REPLAY_LEN`. This could happen",
            "-                    // when the modifiers are consumed entirely or serials are altered.",
            "-                    //",
            "-                    // Both cases shouldn't happen in well behaving clients.",
            "+                    // when the modifiers are consumed entirely.",
            "                     if self.xfiltered_modifiers.len() == MAX_MOD_REPLAY_LEN {",
            "                         self.xfiltered_modifiers.pop_back();",
            "                     }",
            "-                    self.xfiltered_modifiers.push_front(xev.serial);",
            "+                    self.xfiltered_modifiers.push_front(xev.keycode as u8);",
            "                 }",
            "             }",
            " ",
            "             filtered",
            "         } else {",
            "             self.filter_event(xev)",
            "         };",
            "@@ -946,15 +947,15 @@",
            "             false",
            "         };",
            " ",
            "         // NOTE: When the modifier was captured by the XFilterEvents the modifiers for the modifier",
            "         // itself are out of sync due to XkbState being delivered before XKeyEvent, since it's",
            "         // being replayed by the XIM, thus we should replay ourselves.",
            "         let replay = if let Some(position) =",
            "-            self.xfiltered_modifiers.iter().rev().position(|&s| s == xev.serial)",
            "+            self.xfiltered_modifiers.iter().rev().position(|&s| s == xev.keycode as u8)",
            "         {",
            "             // We don't have to replay modifiers pressed before the current event if some events",
            "             // were not forwarded to us, since their state is irrelevant.",
            "             self.xfiltered_modifiers.resize(self.xfiltered_modifiers.len() - 1 - position, 0);",
            "             true",
            "         } else {",
            "             false"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/ime/callbacks.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/ime/callbacks.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/ime/callbacks.rs",
            "@@ -119,27 +119,23 @@",
            "     for (window, old_context) in unsafe { (*inner).contexts.iter() } {",
            "         let spot = old_context.as_ref().map(|old_context| old_context.ic_spot);",
            " ",
            "         // Check if the IME was allowed on that context.",
            "         let is_allowed =",
            "             old_context.as_ref().map(|old_context| old_context.is_allowed()).unwrap_or_default();",
            " ",
            "-        // We can't use the style from the old context here, since it may change on reload, so",
            "-        // pick style from the new XIM based on the old state.",
            "-        let style = if is_allowed { new_im.preedit_style } else { new_im.none_style };",
            "-",
            "         let new_context = {",
            "             let result = unsafe {",
            "                 ImeContext::new(",
            "                     xconn,",
            "-                    new_im.im,",
            "-                    style,",
            "+                    &new_im,",
            "                     *window,",
            "                     spot,",
            "                     (*inner).event_sender.clone(),",
            "+                    is_allowed,",
            "                 )",
            "             };",
            "             if result.is_err() {",
            "                 let _ = unsafe { close_im(xconn, new_im.im) };",
            "             }",
            "             result.map_err(ReplaceImError::ContextCreationFailed)?",
            "         };"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/ime/context.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/ime/context.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/ime/context.rs",
            "@@ -1,18 +1,17 @@",
            " use std::ffi::CStr;",
            " use std::os::raw::c_short;",
            " use std::sync::Arc;",
            " use std::{mem, ptr};",
            " ",
            " use x11_dl::xlib::{XIMCallback, XIMPreeditCaretCallbackStruct, XIMPreeditDrawCallbackStruct};",
            " ",
            "-use crate::platform_impl::platform::x11::ime::input_method::{Style, XIMStyle};",
            "-use crate::platform_impl::platform::x11::ime::{ImeEvent, ImeEventSender};",
            "-",
            " use super::{ffi, util, XConnection, XError};",
            "+use crate::platform_impl::platform::x11::ime::input_method::{InputMethod, Style, XIMStyle};",
            "+use crate::platform_impl::platform::x11::ime::{ImeEvent, ImeEventSender};",
            " ",
            " /// IME creation error.",
            " #[derive(Debug)]",
            " pub enum ImeContextCreationError {",
            "     /// Got the error from Xlib.",
            "     XError(XError),",
            " ",
            "@@ -180,59 +179,63 @@",
            " // XXX: this struct doesn't destroy its XIC resource when dropped.",
            " // This is intentional, as it doesn't have enough information to know whether or not the context",
            " // still exists on the server. Since `ImeInner` has that awareness, destruction must be handled",
            " // through `ImeInner`.",
            " pub struct ImeContext {",
            "     pub(crate) ic: ffi::XIC,",
            "     pub(crate) ic_spot: ffi::XPoint,",
            "-    pub(crate) style: Style,",
            "+    pub(crate) allowed: bool,",
            "     // Since the data is passed shared between X11 XIM callbacks, but couldn't be directly free",
            "     // from there we keep the pointer to automatically deallocate it.",
            "     _client_data: Box<ImeContextClientData>,",
            " }",
            " ",
            " impl ImeContext {",
            "     pub(crate) unsafe fn new(",
            "         xconn: &Arc<XConnection>,",
            "-        im: ffi::XIM,",
            "-        style: Style,",
            "+        im: &InputMethod,",
            "         window: ffi::Window,",
            "         ic_spot: Option<ffi::XPoint>,",
            "         event_sender: ImeEventSender,",
            "+        allowed: bool,",
            "     ) -> Result<Self, ImeContextCreationError> {",
            "         let client_data = Box::into_raw(Box::new(ImeContextClientData {",
            "             window,",
            "             event_sender,",
            "             text: Vec::new(),",
            "             cursor_pos: 0,",
            "         }));",
            " ",
            "+        let style = if allowed { im.preedit_style } else { im.none_style };",
            "+",
            "         let ic = match style as _ {",
            "             Style::Preedit(style) => unsafe {",
            "                 ImeContext::create_preedit_ic(",
            "                     xconn,",
            "-                    im,",
            "+                    im.im,",
            "                     style,",
            "                     window,",
            "                     client_data as ffi::XPointer,",
            "                 )",
            "             },",
            "             Style::Nothing(style) => unsafe {",
            "-                ImeContext::create_nothing_ic(xconn, im, style, window)",
            "+                ImeContext::create_nothing_ic(xconn, im.im, style, window)",
            "+            },",
            "+            Style::None(style) => unsafe {",
            "+                ImeContext::create_none_ic(xconn, im.im, style, window)",
            "             },",
            "-            Style::None(style) => unsafe { ImeContext::create_none_ic(xconn, im, style, window) },",
            "         }",
            "         .ok_or(ImeContextCreationError::Null)?;",
            " ",
            "         xconn.check_errors().map_err(ImeContextCreationError::XError)?;",
            " ",
            "         let mut context = ImeContext {",
            "             ic,",
            "             ic_spot: ffi::XPoint { x: 0, y: 0 },",
            "-            style,",
            "+            allowed,",
            "             _client_data: unsafe { Box::from_raw(client_data) },",
            "         };",
            " ",
            "         // Set the spot location, if it's present.",
            "         if let Some(ic_spot) = ic_spot {",
            "             context.set_spot(xconn, ic_spot.x, ic_spot.y)",
            "         }",
            "@@ -331,15 +334,15 @@",
            "         unsafe {",
            "             (xconn.xlib.XUnsetICFocus)(self.ic);",
            "         }",
            "         xconn.check_errors()",
            "     }",
            " ",
            "     pub fn is_allowed(&self) -> bool {",
            "-        !matches!(self.style, Style::None(_))",
            "+        self.allowed",
            "     }",
            " ",
            "     // Set the spot for preedit text. Setting spot isn't working with libX11 when preedit callbacks",
            "     // are being used. Certain IMEs do show selection window, but it's placed in bottom left of the",
            "     // window and couldn't be changed.",
            "     //",
            "     // For me see: https://bugs.freedesktop.org/show_bug.cgi?id=1580."
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/ime/input_method.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/ime/input_method.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/ime/input_method.rs",
            "@@ -172,15 +172,15 @@",
            "         .get_property::<xproto::Atom>(",
            "             root as xproto::Window,",
            "             servers_atom,",
            "             xproto::Atom::from(xproto::AtomEnum::ATOM),",
            "         )",
            "         .map_err(GetXimServersError::GetPropertyError)?",
            "         .into_iter()",
            "-        .map(ffi::Atom::from)",
            "+        .map(|atom| atom as _)",
            "         .collect::<Vec<_>>();",
            " ",
            "     let mut names: Vec<*const c_char> = Vec::with_capacity(atoms.len());",
            "     unsafe {",
            "         (xconn.xlib.XGetAtomNames)(",
            "             xconn.display,",
            "             atoms.as_mut_ptr(),"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/ime/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/ime/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/ime/mod.rs",
            "@@ -6,23 +6,21 @@",
            " mod input_method;",
            " ",
            " use std::sync::mpsc::{Receiver, Sender};",
            " use std::sync::Arc;",
            " ",
            " #[cfg(feature = \"serde\")]",
            " use serde::{Deserialize, Serialize};",
            "-use tracing::debug;",
            "-",
            "-use super::{ffi, util, XConnection, XError};",
            " ",
            " use self::callbacks::*;",
            " use self::context::ImeContext;",
            " pub use self::context::ImeContextCreationError;",
            " use self::inner::{close_im, ImeInner};",
            "-use self::input_method::{PotentialInputMethods, Style};",
            "+use self::input_method::PotentialInputMethods;",
            "+use super::{ffi, util, XConnection, XError};",
            " ",
            " #[derive(Debug, Clone, PartialEq, Eq, Hash)]",
            " #[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]",
            " pub enum ImeEvent {",
            "     Enabled,",
            "     Start,",
            "     Update(String, usize),",
            "@@ -110,47 +108,34 @@",
            "     // This pattern is used for various methods here:",
            "     // Ok(_) indicates that nothing went wrong internally",
            "     // Ok(true) indicates that the action was actually performed",
            "     // Ok(false) indicates that the action is not presently applicable",
            "     pub fn create_context(",
            "         &mut self,",
            "         window: ffi::Window,",
            "-        with_preedit: bool,",
            "+        with_ime: bool,",
            "     ) -> Result<bool, ImeContextCreationError> {",
            "         let context = if self.is_destroyed() {",
            "             // Create empty entry in map, so that when IME is rebuilt, this window has a context.",
            "             None",
            "         } else {",
            "             let im = self.inner.im.as_ref().unwrap();",
            "-            let style = if with_preedit { im.preedit_style } else { im.none_style };",
            " ",
            "             let context = unsafe {",
            "                 ImeContext::new(",
            "                     &self.inner.xconn,",
            "-                    im.im,",
            "-                    style,",
            "+                    im,",
            "                     window,",
            "                     None,",
            "                     self.inner.event_sender.clone(),",
            "+                    with_ime,",
            "                 )?",
            "             };",
            " ",
            "-            // Check the state on the context, since it could fail to enable or disable preedit.",
            "-            let event = if matches!(style, Style::None(_)) {",
            "-                if with_preedit {",
            "-                    debug!(\"failed to create IME context with preedit support.\")",
            "-                }",
            "-                ImeEvent::Disabled",
            "-            } else {",
            "-                if !with_preedit {",
            "-                    debug!(\"failed to create IME context without preedit support.\")",
            "-                }",
            "-                ImeEvent::Enabled",
            "-            };",
            "-",
            "+            let event = if context.is_allowed() { ImeEvent::Enabled } else { ImeEvent::Disabled };",
            "             self.inner.event_sender.send((window, event)).expect(\"Failed to send enabled event\");",
            " ",
            "             Some(context)",
            "         };",
            " ",
            "         self.inner.contexts.insert(window, context);",
            "         Ok(!self.is_destroyed())"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/mod.rs",
            "@@ -493,14 +493,15 @@",
            "         //",
            "         // If there's no readable event source then we just double check if we",
            "         // have any pending `_receiver` events and if not we return without",
            "         // running a loop iteration.",
            "         // If we don't have any pending `_receiver`",
            "         if !self.has_pending()",
            "             && !matches!(&cause, StartCause::ResumeTimeReached { .. } | StartCause::Poll)",
            "+            && timeout.is_none()",
            "         {",
            "             return;",
            "         }",
            " ",
            "         self.single_iteration(&mut callback, cause);",
            "     }",
            " ",
            "@@ -527,15 +528,15 @@",
            " ",
            "             match token {",
            "                 Some(Ok(token)) => {",
            "                     let event = Event::WindowEvent {",
            "                         window_id: crate::window::WindowId(window_id),",
            "                         event: WindowEvent::ActivationTokenDone {",
            "                             serial,",
            "-                            token: crate::window::ActivationToken::_new(token),",
            "+                            token: crate::window::ActivationToken::from_raw(token),",
            "                         },",
            "                     };",
            "                     callback(event, &self.event_processor.target)",
            "                 },",
            "                 Some(Err(e)) => {",
            "                     tracing::error!(\"Failed to get activation token: {}\", e);",
            "                 },",
            "@@ -845,32 +846,32 @@",
            "     /// Failed to get property.",
            "     GetProperty(util::GetPropertyError),",
            " }",
            " ",
            " impl fmt::Display for X11Error {",
            "     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
            "         match self {",
            "-            X11Error::Xlib(e) => write!(f, \"Xlib error: {}\", e),",
            "-            X11Error::Connect(e) => write!(f, \"X11 connection error: {}\", e),",
            "-            X11Error::Connection(e) => write!(f, \"X11 connection error: {}\", e),",
            "-            X11Error::XidsExhausted(e) => write!(f, \"XID range exhausted: {}\", e),",
            "-            X11Error::GetProperty(e) => write!(f, \"Failed to get X property {}\", e),",
            "-            X11Error::X11(e) => write!(f, \"X11 error: {:?}\", e),",
            "-            X11Error::UnexpectedNull(s) => write!(f, \"Xlib function returned null: {}\", s),",
            "+            X11Error::Xlib(e) => write!(f, \"Xlib error: {e}\"),",
            "+            X11Error::Connect(e) => write!(f, \"X11 connection error: {e}\"),",
            "+            X11Error::Connection(e) => write!(f, \"X11 connection error: {e}\"),",
            "+            X11Error::XidsExhausted(e) => write!(f, \"XID range exhausted: {e}\"),",
            "+            X11Error::GetProperty(e) => write!(f, \"Failed to get X property {e}\"),",
            "+            X11Error::X11(e) => write!(f, \"X11 error: {e:?}\"),",
            "+            X11Error::UnexpectedNull(s) => write!(f, \"Xlib function returned null: {s}\"),",
            "             X11Error::InvalidActivationToken(s) => write!(",
            "                 f,",
            "                 \"Invalid activation token: {}\",",
            "                 std::str::from_utf8(s).unwrap_or(\"<invalid utf8>\")",
            "             ),",
            "-            X11Error::MissingExtension(s) => write!(f, \"Missing X11 extension: {}\", s),",
            "+            X11Error::MissingExtension(s) => write!(f, \"Missing X11 extension: {s}\"),",
            "             X11Error::NoSuchVisual(visualid) => {",
            "-                write!(f, \"Could not find a matching X11 visual for ID `{:x}`\", visualid)",
            "+                write!(f, \"Could not find a matching X11 visual for ID `{visualid:x}`\")",
            "             },",
            "             X11Error::XsettingsParse(err) => {",
            "-                write!(f, \"Failed to parse xsettings: {:?}\", err)",
            "+                write!(f, \"Failed to parse xsettings: {err:?}\")",
            "             },",
            "         }",
            "     }",
            " }",
            " ",
            " impl std::error::Error for X11Error {",
            "     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/util/mod.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/util/mod.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/util/mod.rs",
            "@@ -47,15 +47,15 @@",
            " where",
            "     T: Copy + PartialEq + BitAnd<T, Output = T>,",
            " {",
            "     bitset & flag == flag",
            " }",
            " ",
            " impl XConnection {",
            "-    // This is impoartant, so pay attention!",
            "+    // This is important, so pay attention!",
            "     // Xlib has an output buffer, and tries to hide the async nature of X from you.",
            "     // This buffer contains the requests you make, and is flushed under various circumstances:",
            "     // 1. `XPending`, `XNextEvent`, and `XWindowEvent` flush \"as needed\"",
            "     // 2. `XFlush` explicitly flushes",
            "     // 3. `XSync` flushes and blocks until all requests are responded to",
            "     // 4. Calls that have a return dependent on a response (i.e. `XGetWindowProperty`) sync",
            "     //    internally. When in doubt, check the X11 source; if a function calls `_XReply`, it flushes"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/util/randr.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/util/randr.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/util/randr.rs",
            "@@ -75,15 +75,15 @@",
            "         let output_modes = &output_info.modes;",
            "         let resource_modes = resources.modes();",
            " ",
            "         let modes = resource_modes",
            "             .iter()",
            "             // XRROutputInfo contains an array of mode ids that correspond to",
            "             // modes in the array in XRRScreenResources",
            "-            .filter(|x| output_modes.iter().any(|id| x.id == *id))",
            "+            .filter(|x| output_modes.contains(&x.id))",
            "             .map(|mode| {",
            "                 VideoModeHandle {",
            "                     size: (mode.width.into(), mode.height.into()),",
            "                     refresh_rate_millihertz: monitor::mode_refresh_rate_millihertz(mode)",
            "                         .unwrap_or(0),",
            "                     bit_depth: bit_depth as u16,",
            "                     native_mode: mode.id,"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/window.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/window.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/window.rs",
            "@@ -555,15 +555,15 @@",
            "             leap!(window.set_window_level_inner(window_attrs.window_level)).ignore_error();",
            "         }",
            " ",
            "         window.set_cursor(window_attrs.cursor);",
            " ",
            "         // Remove the startup notification if we have one.",
            "         if let Some(startup) = window_attrs.platform_specific.activation_token.as_ref() {",
            "-            leap!(xconn.remove_activation_token(xwindow, &startup._token));",
            "+            leap!(xconn.remove_activation_token(xwindow, &startup.token));",
            "         }",
            " ",
            "         // We never want to give the user a broken window, since by then, it's too late to handle.",
            "         let window = leap!(xconn.sync_with_server().map(|_| window));",
            " ",
            "         Ok(window)",
            "     }",
            "@@ -972,16 +972,16 @@",
            "             state_atom,",
            "             xproto::Atom::from(xproto::AtomEnum::ATOM),",
            "         );",
            "         let horz_atom = atoms[_NET_WM_STATE_MAXIMIZED_HORZ];",
            "         let vert_atom = atoms[_NET_WM_STATE_MAXIMIZED_VERT];",
            "         match state {",
            "             Ok(atoms) => {",
            "-                let horz_maximized = atoms.iter().any(|atom: &xproto::Atom| *atom == horz_atom);",
            "-                let vert_maximized = atoms.iter().any(|atom: &xproto::Atom| *atom == vert_atom);",
            "+                let horz_maximized = atoms.contains(&horz_atom);",
            "+                let vert_maximized = atoms.contains(&vert_atom);",
            "                 horz_maximized && vert_maximized",
            "             },",
            "             _ => false,",
            "         }",
            "     }",
            " ",
            "     fn set_maximized_inner(&self, maximized: bool) -> Result<VoidCookie<'_>, X11Error> {",
            "@@ -1488,59 +1488,64 @@",
            "                 tracing::error!(\"passed a Wayland cursor to X11 backend\")",
            "             },",
            "         }",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn set_cursor_grab(&self, mode: CursorGrabMode) -> Result<(), ExternalError> {",
            "+        // We don't support the locked cursor yet, so ignore it early on.",
            "+        if mode == CursorGrabMode::Locked {",
            "+            return Err(ExternalError::NotSupported(NotSupportedError::new()));",
            "+        }",
            "+",
            "         let mut grabbed_lock = self.cursor_grabbed_mode.lock().unwrap();",
            "         if mode == *grabbed_lock {",
            "             return Ok(());",
            "         }",
            " ",
            "         // We ungrab before grabbing to prevent passive grabs from causing `AlreadyGrabbed`.",
            "         // Therefore, this is common to both codepaths.",
            "         self.xconn",
            "             .xcb_connection()",
            "             .ungrab_pointer(x11rb::CURRENT_TIME)",
            "             .expect_then_ignore_error(\"Failed to call `xcb_ungrab_pointer`\");",
            "+        *grabbed_lock = CursorGrabMode::None;",
            " ",
            "         let result = match mode {",
            "             CursorGrabMode::None => self.xconn.flush_requests().map_err(|err| {",
            "                 ExternalError::Os(os_error!(OsError::XError(X11Error::Xlib(err).into())))",
            "             }),",
            "             CursorGrabMode::Confined => {",
            "-                let result = {",
            "-                    self.xconn",
            "-                        .xcb_connection()",
            "-                        .grab_pointer(",
            "-                            true as _,",
            "-                            self.xwindow,",
            "-                            xproto::EventMask::BUTTON_PRESS",
            "-                                | xproto::EventMask::BUTTON_RELEASE",
            "-                                | xproto::EventMask::ENTER_WINDOW",
            "-                                | xproto::EventMask::LEAVE_WINDOW",
            "-                                | xproto::EventMask::POINTER_MOTION",
            "-                                | xproto::EventMask::POINTER_MOTION_HINT",
            "-                                | xproto::EventMask::BUTTON1_MOTION",
            "-                                | xproto::EventMask::BUTTON2_MOTION",
            "-                                | xproto::EventMask::BUTTON3_MOTION",
            "-                                | xproto::EventMask::BUTTON4_MOTION",
            "-                                | xproto::EventMask::BUTTON5_MOTION",
            "-                                | xproto::EventMask::KEYMAP_STATE,",
            "-                            xproto::GrabMode::ASYNC,",
            "-                            xproto::GrabMode::ASYNC,",
            "-                            self.xwindow,",
            "-                            0u32,",
            "-                            x11rb::CURRENT_TIME,",
            "-                        )",
            "-                        .expect(\"Failed to call `grab_pointer`\")",
            "-                        .reply()",
            "-                        .expect(\"Failed to receive reply from `grab_pointer`\")",
            "-                };",
            "+                let result = self",
            "+                    .xconn",
            "+                    .xcb_connection()",
            "+                    .grab_pointer(",
            "+                        true as _,",
            "+                        self.xwindow,",
            "+                        xproto::EventMask::BUTTON_PRESS",
            "+                            | xproto::EventMask::BUTTON_RELEASE",
            "+                            | xproto::EventMask::ENTER_WINDOW",
            "+                            | xproto::EventMask::LEAVE_WINDOW",
            "+                            | xproto::EventMask::POINTER_MOTION",
            "+                            | xproto::EventMask::POINTER_MOTION_HINT",
            "+                            | xproto::EventMask::BUTTON1_MOTION",
            "+                            | xproto::EventMask::BUTTON2_MOTION",
            "+                            | xproto::EventMask::BUTTON3_MOTION",
            "+                            | xproto::EventMask::BUTTON4_MOTION",
            "+                            | xproto::EventMask::BUTTON5_MOTION",
            "+                            | xproto::EventMask::KEYMAP_STATE,",
            "+                        xproto::GrabMode::ASYNC,",
            "+                        xproto::GrabMode::ASYNC,",
            "+                        self.xwindow,",
            "+                        0u32,",
            "+                        x11rb::CURRENT_TIME,",
            "+                    )",
            "+                    .expect(\"Failed to call `grab_pointer`\")",
            "+                    .reply()",
            "+                    .expect(\"Failed to receive reply from `grab_pointer`\");",
            " ",
            "                 match result.status {",
            "                     xproto::GrabStatus::SUCCESS => Ok(()),",
            "                     xproto::GrabStatus::ALREADY_GRABBED => {",
            "                         Err(\"Cursor could not be confined: already confined by another client\")",
            "                     },",
            "                     xproto::GrabStatus::INVALID_TIME => {",
            "@@ -1552,17 +1557,15 @@",
            "                     xproto::GrabStatus::FROZEN => {",
            "                         Err(\"Cursor could not be confined: frozen by another client\")",
            "                     },",
            "                     _ => unreachable!(),",
            "                 }",
            "                 .map_err(|err| ExternalError::Os(os_error!(OsError::Misc(err))))",
            "             },",
            "-            CursorGrabMode::Locked => {",
            "-                return Err(ExternalError::NotSupported(NotSupportedError::new()));",
            "-            },",
            "+            CursorGrabMode::Locked => return Ok(()),",
            "         };",
            " ",
            "         if result.is_ok() {",
            "             *grabbed_lock = mode;",
            "         }",
            " ",
            "         result"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/linux/x11/xdisplay.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/linux/x11/xdisplay.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/linux/x11/xdisplay.rs",
            "@@ -141,15 +141,15 @@",
            "             xsettings_screen,",
            "         })",
            "     }",
            " ",
            "     fn new_xsettings_screen(xcb: &XCBConnection, default_screen: usize) -> Option<xproto::Atom> {",
            "         // Fetch the _XSETTINGS_S[screen number] atom.",
            "         let xsettings_screen = xcb",
            "-            .intern_atom(false, format!(\"_XSETTINGS_S{}\", default_screen).as_bytes())",
            "+            .intern_atom(false, format!(\"_XSETTINGS_S{default_screen}\").as_bytes())",
            "             .ok()?",
            "             .reply()",
            "             .ok()?",
            "             .atom;",
            " ",
            "         // Get PropertyNotify events from the XSETTINGS window.",
            "         // TODO: The XSETTINGS window here can change. In the future, listen for DestroyNotify on"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/macos/app.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/macos/app.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/macos/app.rs",
            "@@ -1,53 +1,108 @@",
            " #![allow(clippy::unnecessary_cast)]",
            "+#![allow(unknown_lints)] // New lint below",
            "+#![allow(static_mut_refs)] // Uses `MainThreadBound` in new version.",
            " ",
            "-use objc2::{declare_class, msg_send, mutability, ClassType, DeclaredClass};",
            "-use objc2_app_kit::{NSApplication, NSEvent, NSEventModifierFlags, NSEventType, NSResponder};",
            "-use objc2_foundation::{MainThreadMarker, NSObject};",
            "+use std::cell::Cell;",
            "+use std::mem;",
            "+",
            "+use objc2::runtime::{Imp, Sel};",
            "+use objc2::sel;",
            "+use objc2_app_kit::{NSApplication, NSEvent, NSEventModifierFlags, NSEventType};",
            "+use objc2_foundation::MainThreadMarker;",
            " ",
            " use super::app_state::ApplicationDelegate;",
            " use crate::event::{DeviceEvent, ElementState};",
            " ",
            "-declare_class!(",
            "-    pub(super) struct WinitApplication;",
            "+type SendEvent = extern \"C\" fn(&NSApplication, Sel, &NSEvent);",
            " ",
            "-    unsafe impl ClassType for WinitApplication {",
            "-        #[inherits(NSResponder, NSObject)]",
            "-        type Super = NSApplication;",
            "-        type Mutability = mutability::MainThreadOnly;",
            "-        const NAME: &'static str = \"WinitApplication\";",
            "+// NOTE: Only used on the main thread. Ideally, we'd use `MainThreadBound`, but that isn't",
            "+// constructible from `const` with this `objc2` version.",
            "+static mut ORIGINAL: Cell<Option<SendEvent>> = Cell::new(None);",
            "+",
            "+extern \"C\" fn send_event(app: &NSApplication, sel: Sel, event: &NSEvent) {",
            "+    let mtm = MainThreadMarker::from(app);",
            "+",
            "+    // Normally, holding Cmd + any key never sends us a `keyUp` event for that key.",
            "+    // Overriding `sendEvent:` fixes that. (https://stackoverflow.com/a/15294196)",
            "+    // Fun fact: Firefox still has this bug! (https://bugzilla.mozilla.org/show_bug.cgi?id=1299553)",
            "+    //",
            "+    // For posterity, there are some undocumented event types",
            "+    // (https://github.com/servo/cocoa-rs/issues/155)",
            "+    // but that doesn't really matter here.",
            "+    let event_type = unsafe { event.r#type() };",
            "+    let modifier_flags = unsafe { event.modifierFlags() };",
            "+    if event_type == NSEventType::KeyUp",
            "+        && modifier_flags.contains(NSEventModifierFlags::NSEventModifierFlagCommand)",
            "+    {",
            "+        if let Some(key_window) = app.keyWindow() {",
            "+            key_window.sendEvent(event);",
            "+        }",
            "+        return;",
            "     }",
            " ",
            "-    impl DeclaredClass for WinitApplication {}",
            "+    // Events are generally scoped to the window level, so the best way",
            "+    // to get device events is to listen for them on NSApplication.",
            "+    let delegate = ApplicationDelegate::get(mtm);",
            "+    maybe_dispatch_device_event(&delegate, event);",
            "+",
            "+    let _ = mtm;",
            "+    let original = unsafe { ORIGINAL.get().expect(\"no existing sendEvent: handler set\") };",
            "+    original(app, sel, event)",
            "+}",
            " ",
            "-    unsafe impl WinitApplication {",
            "-        // Normally, holding Cmd + any key never sends us a `keyUp` event for that key.",
            "-        // Overriding `sendEvent:` like this fixes that. (https://stackoverflow.com/a/15294196)",
            "-        // Fun fact: Firefox still has this bug! (https://bugzilla.mozilla.org/show_bug.cgi?id=1299553)",
            "-        #[method(sendEvent:)]",
            "-        fn send_event(&self, event: &NSEvent) {",
            "-            // For posterity, there are some undocumented event types",
            "-            // (https://github.com/servo/cocoa-rs/issues/155)",
            "-            // but that doesn't really matter here.",
            "-            let event_type = unsafe { event.r#type() };",
            "-            let modifier_flags = unsafe { event.modifierFlags() };",
            "-            if event_type == NSEventType::KeyUp",
            "-                && modifier_flags.contains(NSEventModifierFlags::NSEventModifierFlagCommand)",
            "-            {",
            "-                if let Some(key_window) = self.keyWindow() {",
            "-                    key_window.sendEvent(event);",
            "-                }",
            "-            } else {",
            "-                let delegate = ApplicationDelegate::get(MainThreadMarker::from(self));",
            "-                maybe_dispatch_device_event(&delegate, event);",
            "-                unsafe { msg_send![super(self), sendEvent: event] }",
            "-            }",
            "-        }",
            "+/// Override the [`sendEvent:`][NSApplication::sendEvent] method on the given application class.",
            "+///",
            "+/// The previous implementation created a subclass of [`NSApplication`], however we would like to",
            "+/// give the user full control over their `NSApplication`, so we override the method here using",
            "+/// method swizzling instead.",
            "+///",
            "+/// This _should_ also allow two versions of Winit to exist in the same application.",
            "+///",
            "+/// See the following links for more info on method swizzling:",
            "+/// - <https://nshipster.com/method-swizzling/>",
            "+/// - <https://spin.atomicobject.com/method-swizzling-objective-c/>",
            "+/// - <https://web.archive.org/web/20130308110627/http://cocoadev.com/wiki/MethodSwizzling>",
            "+///",
            "+/// NOTE: This function assumes that the passed in application object is the one returned from",
            "+/// [`NSApplication::sharedApplication`], i.e. the one and only global shared application object.",
            "+/// For testing though, we allow it to be a different object.",
            "+pub(crate) fn override_send_event(global_app: &NSApplication) {",
            "+    let mtm = MainThreadMarker::from(global_app);",
            "+    let class = global_app.class();",
            "+",
            "+    let method =",
            "+        class.instance_method(sel!(sendEvent:)).expect(\"NSApplication must have sendEvent: method\");",
            "+",
            "+    // SAFETY: Converting our `sendEvent:` implementation to an IMP.",
            "+    let overridden = unsafe { mem::transmute::<SendEvent, Imp>(send_event) };",
            "+",
            "+    // If we've already overridden the method, don't do anything.",
            "+    // FIXME(madsmtm): Use `std::ptr::fn_addr_eq` (Rust 1.85) once available in MSRV.",
            "+    #[allow(unknown_lints, unpredictable_function_pointer_comparisons)]",
            "+    if overridden == method.implementation() {",
            "+        return;",
            "     }",
            "-);",
            "+",
            "+    // SAFETY: Our implementation has:",
            "+    // 1. The same signature as `sendEvent:`.",
            "+    // 2. Does not impose extra safety requirements on callers.",
            "+    let original = unsafe { method.set_implementation(overridden) };",
            "+",
            "+    // SAFETY: This is the actual signature of `sendEvent:`.",
            "+    let original = unsafe { mem::transmute::<Imp, SendEvent>(original) };",
            "+",
            "+    // NOTE: If NSApplication was safe to use from multiple threads, then this would potentially be",
            "+    // a (checked) race-condition, since one could call `sendEvent:` before the original had been",
            "+    // stored here.",
            "+    //",
            "+    // It is only usable from the main thread, however, so we're good!",
            "+    let _ = mtm;",
            "+    unsafe { ORIGINAL.set(Some(original)) };",
            "+}",
            " ",
            " fn maybe_dispatch_device_event(delegate: &ApplicationDelegate, event: &NSEvent) {",
            "     let event_type = unsafe { event.r#type() };",
            "     #[allow(non_upper_case_globals)]",
            "     match event_type {",
            "         NSEventType::MouseMoved",
            "         | NSEventType::LeftMouseDragged",
            "@@ -81,7 +136,60 @@",
            "                 button: unsafe { event.buttonNumber() } as u32,",
            "                 state: ElementState::Released,",
            "             });",
            "         },",
            "         _ => (),",
            "     }",
            " }",
            "+",
            "+#[cfg(test)]",
            "+mod tests {",
            "+    use objc2::rc::Retained;",
            "+    use objc2::{declare_class, msg_send_id, mutability, ClassType, DeclaredClass};",
            "+",
            "+    use super::*;",
            "+",
            "+    #[test]",
            "+    fn test_override() {",
            "+        // FIXME(madsmtm): Ensure this always runs (maybe use cargo-nextest or `--test-threads=1`?)",
            "+        let Some(mtm) = MainThreadMarker::new() else { return };",
            "+",
            "+        // Create a new application, without making it the shared application.",
            "+        let app = unsafe { NSApplication::new(mtm) };",
            "+        override_send_event(&app);",
            "+        // Test calling twice works.",
            "+        override_send_event(&app);",
            "+",
            "+        // FIXME(madsmtm): Can't test this yet, need some way to mock AppState.",
            "+        // unsafe {",
            "+        //     let event = super::super::event::dummy_event().unwrap();",
            "+        //     app.sendEvent(&event)",
            "+        // }",
            "+    }",
            "+",
            "+    #[test]",
            "+    fn test_custom_class() {",
            "+        let Some(_mtm) = MainThreadMarker::new() else { return };",
            "+",
            "+        declare_class!(",
            "+            struct TestApplication;",
            "+",
            "+            unsafe impl ClassType for TestApplication {",
            "+                type Super = NSApplication;",
            "+                type Mutability = mutability::MainThreadOnly;",
            "+                const NAME: &'static str = \"TestApplication\";",
            "+            }",
            "+",
            "+            impl DeclaredClass for TestApplication {}",
            "+",
            "+            unsafe impl TestApplication {",
            "+                #[method(sendEvent:)]",
            "+                fn send_event(&self, _event: &NSEvent) {",
            "+                    todo!()",
            "+                }",
            "+            }",
            "+        );",
            "+",
            "+        let app: Retained<TestApplication> = unsafe { msg_send_id![TestApplication::class(), new] };",
            "+        override_send_event(&app);",
            "+    }",
            "+}"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/macos/app_state.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/macos/app_state.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/macos/app_state.rs",
            "@@ -7,15 +7,15 @@",
            " use objc2::{declare_class, msg_send_id, mutability, ClassType, DeclaredClass};",
            " use objc2_app_kit::{",
            "     NSApplication, NSApplicationActivationPolicy, NSApplicationDelegate, NSRunningApplication,",
            " };",
            " use objc2_foundation::{MainThreadMarker, NSNotification, NSObject, NSObjectProtocol};",
            " ",
            " use super::event_handler::EventHandler;",
            "-use super::event_loop::{stop_app_immediately, ActiveEventLoop, PanicInfo};",
            "+use super::event_loop::{notify_windows_of_exit, stop_app_immediately, ActiveEventLoop, PanicInfo};",
            " use super::observer::{EventLoopWaker, RunLoop};",
            " use super::{menu, WindowId, DEVICE_ID};",
            " use crate::event::{DeviceEvent, Event, StartCause, WindowEvent};",
            " use crate::event_loop::{ActiveEventLoop as RootActiveEventLoop, ControlFlow};",
            " use crate::window::WindowId as RootWindowId;",
            " ",
            " #[derive(Debug)]",
            "@@ -161,15 +161,17 @@",
            "             let app = NSApplication::sharedApplication(mtm);",
            "             stop_app_immediately(&app);",
            "         }",
            "     }",
            " ",
            "     fn will_terminate(&self, _notification: &NSNotification) {",
            "         trace_scope!(\"applicationWillTerminate:\");",
            "-        // TODO: Notify every window that it will be destroyed, like done in iOS?",
            "+        let mtm = MainThreadMarker::from(self);",
            "+        let app = NSApplication::sharedApplication(mtm);",
            "+        notify_windows_of_exit(&app);",
            "         self.internal_exit();",
            "     }",
            " ",
            "     pub fn get(mtm: MainThreadMarker) -> Retained<Self> {",
            "         let app = NSApplication::sharedApplication(mtm);",
            "         let delegate =",
            "             unsafe { app.delegate() }.expect(\"a delegate was not configured on the application\");",
            "@@ -388,14 +390,15 @@",
            "         }",
            " ",
            "         self.handle_event(Event::AboutToWait);",
            " ",
            "         if self.exiting() {",
            "             let app = NSApplication::sharedApplication(mtm);",
            "             stop_app_immediately(&app);",
            "+            notify_windows_of_exit(&app);",
            "         }",
            " ",
            "         if self.ivars().stop_before_wait.get() {",
            "             let app = NSApplication::sharedApplication(mtm);",
            "             stop_app_immediately(&app);",
            "         }",
            "         self.ivars().start_time.set(Some(Instant::now()));"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/macos/event_loop.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/macos/event_loop.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/macos/event_loop.rs",
            "@@ -12,19 +12,19 @@",
            " use core_foundation::base::{CFIndex, CFRelease};",
            " use core_foundation::runloop::{",
            "     kCFRunLoopCommonModes, CFRunLoopAddSource, CFRunLoopGetMain, CFRunLoopSourceContext,",
            "     CFRunLoopSourceCreate, CFRunLoopSourceRef, CFRunLoopSourceSignal, CFRunLoopWakeUp,",
            " };",
            " use objc2::rc::{autoreleasepool, Retained};",
            " use objc2::runtime::ProtocolObject;",
            "-use objc2::{msg_send_id, sel, ClassType};",
            "+use objc2::sel;",
            " use objc2_app_kit::{NSApplication, NSApplicationActivationPolicy, NSWindow};",
            " use objc2_foundation::{MainThreadMarker, NSObjectProtocol};",
            " ",
            "-use super::app::WinitApplication;",
            "+use super::app::override_send_event;",
            " use super::app_state::{ApplicationDelegate, HandlePendingUserEvents};",
            " use super::event::dummy_event;",
            " use super::monitor::{self, MonitorHandle};",
            " use super::observer::setup_control_flow_observers;",
            " use crate::error::EventLoopError;",
            " use crate::event::Event;",
            " use crate::event_loop::{",
            "@@ -216,23 +216,16 @@",
            " impl<T> EventLoop<T> {",
            "     pub(crate) fn new(",
            "         attributes: &PlatformSpecificEventLoopAttributes,",
            "     ) -> Result<Self, EventLoopError> {",
            "         let mtm = MainThreadMarker::new()",
            "             .expect(\"on macOS, `EventLoop` must be created on the main thread!\");",
            " ",
            "-        let app: Retained<NSApplication> =",
            "-            unsafe { msg_send_id![WinitApplication::class(), sharedApplication] };",
            "-",
            "-        if !app.is_kind_of::<WinitApplication>() {",
            "-            panic!(",
            "-                \"`winit` requires control over the principal class. You must create the event \\",
            "-                 loop before other parts of your application initialize NSApplication\"",
            "-            );",
            "-        }",
            "+        // Initialize the application (if it has not already been).",
            "+        let app = NSApplication::sharedApplication(mtm);",
            " ",
            "         let activation_policy = match attributes.activation_policy {",
            "             None => None,",
            "             Some(ActivationPolicy::Regular) => Some(NSApplicationActivationPolicy::Regular),",
            "             Some(ActivationPolicy::Accessory) => Some(NSApplicationActivationPolicy::Accessory),",
            "             Some(ActivationPolicy::Prohibited) => Some(NSApplicationActivationPolicy::Prohibited),",
            "         };",
            "@@ -243,14 +236,17 @@",
            "             attributes.activate_ignoring_other_apps,",
            "         );",
            " ",
            "         autoreleasepool(|_| {",
            "             app.setDelegate(Some(ProtocolObject::from_ref(&*delegate)));",
            "         });",
            " ",
            "+        // Override `sendEvent:` on the application to forward to our application state.",
            "+        override_send_event(&app);",
            "+",
            "         let panic_info: Rc<PanicInfo> = Default::default();",
            "         setup_control_flow_observers(mtm, Rc::downgrade(&panic_info));",
            " ",
            "         let (sender, receiver) = mpsc::channel();",
            "         Ok(EventLoop {",
            "             app,",
            "             delegate: delegate.clone(),",
            "@@ -417,14 +413,30 @@",
            "         app.stop(None);",
            "         // To stop event loop immediately, we need to post some event here.",
            "         // See: https://stackoverflow.com/questions/48041279/stopping-the-nsapplication-main-event-loop/48064752#48064752",
            "         app.postEvent_atStart(&dummy_event().unwrap(), true);",
            "     });",
            " }",
            " ",
            "+/// Tell all windows to close.",
            "+///",
            "+/// This will synchronously trigger `WindowEvent::Destroyed` within",
            "+/// `windowWillClose:`, giving the application one last chance to handle",
            "+/// those events. It doesn't matter if the user also ends up closing the",
            "+/// windows in `Window`'s `Drop` impl, once a window has been closed once, it",
            "+/// stays closed.",
            "+///",
            "+/// This ensures that no windows linger on after the event loop has exited,",
            "+/// see <https://github.com/rust-windowing/winit/issues/4135>.",
            "+pub(super) fn notify_windows_of_exit(app: &NSApplication) {",
            "+    for window in app.windows() {",
            "+        window.close();",
            "+    }",
            "+}",
            "+",
            " /// Catches panics that happen inside `f` and when a panic",
            " /// happens, stops the `sharedApplication`",
            " #[inline]",
            " pub fn stop_app_on_panic<F: FnOnce() -> R + UnwindSafe, R>(",
            "     mtm: MainThreadMarker,",
            "     panic_info: Weak<PanicInfo>,",
            "     f: F,"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/macos/ffi.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/macos/ffi.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/macos/ffi.rs",
            "@@ -64,14 +64,16 @@",
            " // Since we want to support older versions, we can't link to `ColorSync`",
            " // directly. Fortunately, it has always been available as a subframework of",
            " // `ApplicationServices`, see:",
            " // https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/OSX_Technology_Overview/SystemFrameworks/SystemFrameworks.html#//apple_ref/doc/uid/TP40001067-CH210-BBCFFIEG",
            " #[link(name = \"ApplicationServices\", kind = \"framework\")]",
            " extern \"C\" {",
            "     pub fn CGDisplayCreateUUIDFromDisplayID(display: CGDirectDisplayID) -> CFUUIDRef;",
            "+",
            "+    pub fn CGDisplayGetDisplayIDFromUUID(uuid: CFUUIDRef) -> CGDirectDisplayID;",
            " }",
            " ",
            " #[link(name = \"CoreGraphics\", kind = \"framework\")]",
            " extern \"C\" {",
            "     pub fn CGRestorePermanentDisplayConfiguration();",
            "     pub fn CGDisplayCapture(display: CGDirectDisplayID) -> CGError;",
            "     pub fn CGDisplayRelease(display: CGDirectDisplayID) -> CGError;"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/macos/monitor.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/macos/monitor.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/macos/monitor.rs",
            "@@ -2,21 +2,23 @@",
            " ",
            " use std::collections::VecDeque;",
            " use std::fmt;",
            " ",
            " use core_foundation::array::{CFArrayGetCount, CFArrayGetValueAtIndex};",
            " use core_foundation::base::{CFRelease, TCFType};",
            " use core_foundation::string::CFString;",
            "+use core_foundation::uuid::{CFUUIDGetUUIDBytes, CFUUID};",
            " use core_graphics::display::{",
            "     CGDirectDisplayID, CGDisplay, CGDisplayBounds, CGDisplayCopyDisplayMode,",
            " };",
            " use objc2::rc::Retained;",
            " use objc2::runtime::AnyObject;",
            " use objc2_app_kit::NSScreen;",
            " use objc2_foundation::{ns_string, run_on_main, MainThreadMarker, NSNumber, NSPoint, NSRect};",
            "+use tracing::warn;",
            " ",
            " use super::ffi;",
            " use crate::dpi::{LogicalPosition, PhysicalPosition, PhysicalSize};",
            " ",
            " #[derive(Clone)]",
            " pub struct VideoModeHandle {",
            "     size: PhysicalSize<u32>,",
            "@@ -93,68 +95,118 @@",
            "     }",
            " ",
            "     pub fn monitor(&self) -> MonitorHandle {",
            "         self.monitor.clone()",
            "     }",
            " }",
            " ",
            "+/// `CGDirectDisplayID` is documented as:",
            "+/// > a framebuffer, a color correction (gamma) table, and possibly an attached monitor.",
            "+///",
            "+/// That is, it doesn't actually represent the monitor itself. Instead, we use the UUID of the",
            "+/// monitor, as retrieved from `CGDisplayCreateUUIDFromDisplayID` (this makes the monitor ID stable,",
            "+/// even across reboots and video mode changes).",
            "+///",
            "+/// NOTE: I'd be perfectly valid to store `[u8; 16]` in here instead, we only store `CFUUID` to",
            "+/// avoid having to re-create it when we want to fetch the display ID.",
            " #[derive(Clone)]",
            "-pub struct MonitorHandle(CGDirectDisplayID);",
            "+pub struct MonitorHandle(CFUUID);",
            "+",
            "+// SAFETY: CFUUID is immutable.",
            "+// FIXME(madsmtm): Upstream this into `objc2-core-foundation`.",
            "+unsafe impl Send for MonitorHandle {}",
            "+unsafe impl Sync for MonitorHandle {}",
            "+",
            "+type MonitorUuid = [u8; 16];",
            "+",
            "+impl MonitorHandle {",
            "+    /// Internal comparisons of [`MonitorHandle`]s are done first requesting a UUID for the handle.",
            "+    fn uuid(&self) -> MonitorUuid {",
            "+        let uuid = unsafe { CFUUIDGetUUIDBytes(self.0.as_concrete_TypeRef()) };",
            "+        MonitorUuid::from([",
            "+            uuid.byte0,",
            "+            uuid.byte1,",
            "+            uuid.byte2,",
            "+            uuid.byte3,",
            "+            uuid.byte4,",
            "+            uuid.byte5,",
            "+            uuid.byte6,",
            "+            uuid.byte7,",
            "+            uuid.byte8,",
            "+            uuid.byte9,",
            "+            uuid.byte10,",
            "+            uuid.byte11,",
            "+            uuid.byte12,",
            "+            uuid.byte13,",
            "+            uuid.byte14,",
            "+            uuid.byte15,",
            "+        ])",
            "+    }",
            "+",
            "+    fn display_id(&self) -> CGDirectDisplayID {",
            "+        unsafe { ffi::CGDisplayGetDisplayIDFromUUID(self.0.as_concrete_TypeRef()) }",
            "+    }",
            "+",
            "+    #[track_caller]",
            "+    pub(crate) fn new(display_id: CGDirectDisplayID) -> Option<Self> {",
            "+        // kCGNullDirectDisplay",
            "+        if display_id == 0 {",
            "+            // `CGDisplayCreateUUIDFromDisplayID` checks kCGNullDirectDisplay internally.",
            "+            warn!(\"constructing monitor from invalid display ID 0; falling back to main monitor\");",
            "+        }",
            "+        let ptr = unsafe { ffi::CGDisplayCreateUUIDFromDisplayID(display_id) };",
            "+        if ptr.is_null() {",
            "+            return None;",
            "+        }",
            "+        Some(Self(unsafe { CFUUID::wrap_under_create_rule(ptr) }))",
            "+    }",
            "+}",
            " ",
            "-// `CGDirectDisplayID` changes on video mode change, so we cannot rely on that",
            "-// for comparisons, but we can use `CGDisplayCreateUUIDFromDisplayID` to get an",
            "-// unique identifier that persists even across system reboots",
            " impl PartialEq for MonitorHandle {",
            "     fn eq(&self, other: &Self) -> bool {",
            "-        unsafe {",
            "-            ffi::CGDisplayCreateUUIDFromDisplayID(self.0)",
            "-                == ffi::CGDisplayCreateUUIDFromDisplayID(other.0)",
            "-        }",
            "+        self.uuid() == other.uuid()",
            "     }",
            " }",
            " ",
            " impl Eq for MonitorHandle {}",
            " ",
            " impl PartialOrd for MonitorHandle {",
            "     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
            "         Some(self.cmp(other))",
            "     }",
            " }",
            " ",
            " impl Ord for MonitorHandle {",
            "     fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
            "-        unsafe {",
            "-            ffi::CGDisplayCreateUUIDFromDisplayID(self.0)",
            "-                .cmp(&ffi::CGDisplayCreateUUIDFromDisplayID(other.0))",
            "-        }",
            "+        self.uuid().cmp(&other.uuid())",
            "     }",
            " }",
            " ",
            " impl std::hash::Hash for MonitorHandle {",
            "     fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
            "-        unsafe {",
            "-            ffi::CGDisplayCreateUUIDFromDisplayID(self.0).hash(state);",
            "-        }",
            "+        self.uuid().hash(state);",
            "     }",
            " }",
            " ",
            " pub fn available_monitors() -> VecDeque<MonitorHandle> {",
            "     if let Ok(displays) = CGDisplay::active_displays() {",
            "         let mut monitors = VecDeque::with_capacity(displays.len());",
            "         for display in displays {",
            "-            monitors.push_back(MonitorHandle(display));",
            "+            // Display ID just fetched from `CGGetActiveDisplayList`, should be fine to unwrap.",
            "+            monitors.push_back(MonitorHandle::new(display).expect(\"invalid display ID\"));",
            "         }",
            "         monitors",
            "     } else {",
            "         VecDeque::with_capacity(0)",
            "     }",
            " }",
            " ",
            " pub fn primary_monitor() -> MonitorHandle {",
            "-    MonitorHandle(CGDisplay::main().id)",
            "+    // Display ID just fetched from `CGMainDisplayID`, should be fine to unwrap.",
            "+    MonitorHandle::new(CGDisplay::main().id).expect(\"invalid display ID\")",
            " }",
            " ",
            " impl fmt::Debug for MonitorHandle {",
            "     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
            "         f.debug_struct(\"MonitorHandle\")",
            "             .field(\"name\", &self.name())",
            "             .field(\"native_identifier\", &self.native_identifier())",
            "@@ -163,34 +215,28 @@",
            "             .field(\"scale_factor\", &self.scale_factor())",
            "             .field(\"refresh_rate_millihertz\", &self.refresh_rate_millihertz())",
            "             .finish_non_exhaustive()",
            "     }",
            " }",
            " ",
            " impl MonitorHandle {",
            "-    pub fn new(id: CGDirectDisplayID) -> Self {",
            "-        MonitorHandle(id)",
            "-    }",
            "-",
            "     // TODO: Be smarter about this:",
            "     // <https://github.com/glfw/glfw/blob/57cbded0760a50b9039ee0cb3f3c14f60145567c/src/cocoa_monitor.m#L44-L126>",
            "     pub fn name(&self) -> Option<String> {",
            "-        let MonitorHandle(display_id) = *self;",
            "-        let screen_num = CGDisplay::new(display_id).model_number();",
            "+        let screen_num = CGDisplay::new(self.display_id()).model_number();",
            "         Some(format!(\"Monitor #{screen_num}\"))",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn native_identifier(&self) -> u32 {",
            "-        self.0",
            "+        self.display_id()",
            "     }",
            " ",
            "     pub fn size(&self) -> PhysicalSize<u32> {",
            "-        let MonitorHandle(display_id) = *self;",
            "-        let display = CGDisplay::new(display_id);",
            "+        let display = CGDisplay::new(self.display_id());",
            "         let height = display.pixels_high();",
            "         let width = display.pixels_wide();",
            "         PhysicalSize::from_logical::<_, f64>((width as f64, height as f64), self.scale_factor())",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn position(&self) -> PhysicalPosition<i32> {",
            "@@ -209,22 +255,23 @@",
            "                 None => 1.0, // default to 1.0 when we can't find the screen",
            "             }",
            "         })",
            "     }",
            " ",
            "     pub fn refresh_rate_millihertz(&self) -> Option<u32> {",
            "         unsafe {",
            "-            let current_display_mode = NativeDisplayMode(CGDisplayCopyDisplayMode(self.0) as _);",
            "+            let current_display_mode =",
            "+                NativeDisplayMode(CGDisplayCopyDisplayMode(self.display_id()) as _);",
            "             let refresh_rate = ffi::CGDisplayModeGetRefreshRate(current_display_mode.0);",
            "             if refresh_rate > 0.0 {",
            "                 return Some((refresh_rate * 1000.0).round() as u32);",
            "             }",
            " ",
            "             let mut display_link = std::ptr::null_mut();",
            "-            if ffi::CVDisplayLinkCreateWithCGDisplay(self.0, &mut display_link)",
            "+            if ffi::CVDisplayLinkCreateWithCGDisplay(self.display_id(), &mut display_link)",
            "                 != ffi::kCVReturnSuccess",
            "             {",
            "                 return None;",
            "             }",
            "             let time = ffi::CVDisplayLinkGetNominalOutputVideoRefreshPeriod(display_link);",
            "             ffi::CVDisplayLinkRelease(display_link);",
            " ",
            "@@ -239,35 +286,42 @@",
            " ",
            "     pub fn video_modes(&self) -> impl Iterator<Item = VideoModeHandle> {",
            "         let refresh_rate_millihertz = self.refresh_rate_millihertz().unwrap_or(0);",
            "         let monitor = self.clone();",
            " ",
            "         unsafe {",
            "             let modes = {",
            "-                let array = ffi::CGDisplayCopyAllDisplayModes(self.0, std::ptr::null());",
            "-                assert!(!array.is_null(), \"failed to get list of display modes\");",
            "-                let array_count = CFArrayGetCount(array);",
            "-                let modes: Vec<_> = (0..array_count)",
            "-                    .map(move |i| {",
            "-                        let mode = CFArrayGetValueAtIndex(array, i) as *mut _;",
            "-                        ffi::CGDisplayModeRetain(mode);",
            "-                        mode",
            "-                    })",
            "-                    .collect();",
            "-                CFRelease(array as *const _);",
            "-                modes",
            "+                let array = ffi::CGDisplayCopyAllDisplayModes(self.display_id(), std::ptr::null());",
            "+                if array.is_null() {",
            "+                    // Occasionally, certain CalDigit Thunderbolt Hubs report a spurious monitor",
            "+                    // during sleep/wake/cycling monitors. It tends to have null",
            "+                    // or 1 video mode only. See <https://github.com/bevyengine/bevy/issues/17827>.",
            "+                    warn!(monitor = ?self, \"failed to get a list of display modes\");",
            "+                    Vec::new()",
            "+                } else {",
            "+                    let array_count = CFArrayGetCount(array);",
            "+                    let modes: Vec<_> = (0..array_count)",
            "+                        .map(move |i| {",
            "+                            let mode = CFArrayGetValueAtIndex(array, i) as *mut _;",
            "+                            ffi::CGDisplayModeRetain(mode);",
            "+                            mode",
            "+                        })",
            "+                        .collect();",
            "+                    CFRelease(array as *const _);",
            "+                    modes",
            "+                }",
            "             };",
            " ",
            "             modes.into_iter().map(move |mode| {",
            "-                let cg_refresh_rate_hertz = ffi::CGDisplayModeGetRefreshRate(mode).round() as i64;",
            "+                let cg_refresh_rate_hertz = ffi::CGDisplayModeGetRefreshRate(mode);",
            " ",
            "                 // CGDisplayModeGetRefreshRate returns 0.0 for any display that",
            "                 // isn't a CRT",
            "-                let refresh_rate_millihertz = if cg_refresh_rate_hertz > 0 {",
            "-                    (cg_refresh_rate_hertz * 1000) as u32",
            "+                let refresh_rate_millihertz = if cg_refresh_rate_hertz > 0.0 {",
            "+                    (cg_refresh_rate_hertz * 1000.0).round() as u32",
            "                 } else {",
            "                     refresh_rate_millihertz",
            "                 };",
            " ",
            "                 let pixel_encoding =",
            "                     CFString::wrap_under_create_rule(ffi::CGDisplayModeCopyPixelEncoding(mode))",
            "                         .to_string();",
            "@@ -292,21 +346,25 @@",
            "                     native_mode: NativeDisplayMode(mode),",
            "                 }",
            "             })",
            "         }",
            "     }",
            " ",
            "     pub(crate) fn ns_screen(&self, mtm: MainThreadMarker) -> Option<Retained<NSScreen>> {",
            "-        let uuid = unsafe { ffi::CGDisplayCreateUUIDFromDisplayID(self.0) };",
            "+        let uuid = self.uuid();",
            "         NSScreen::screens(mtm).into_iter().find(|screen| {",
            "             let other_native_id = get_display_id(screen);",
            "-            let other_uuid = unsafe {",
            "-                ffi::CGDisplayCreateUUIDFromDisplayID(other_native_id as CGDirectDisplayID)",
            "-            };",
            "-            uuid == other_uuid",
            "+            if let Some(other) = MonitorHandle::new(other_native_id) {",
            "+                uuid == other.uuid()",
            "+            } else {",
            "+                // Display ID was just fetched from live NSScreen, but can still result in `None`",
            "+                // with certain Thunderbolt docked monitors.",
            "+                warn!(other_native_id, \"comparing against screen with invalid display ID\");",
            "+                false",
            "+            }",
            "         })",
            "     }",
            " }",
            " ",
            " pub(crate) fn get_display_id(screen: &NSScreen) -> u32 {",
            "     let key = ns_string!(\"NSScreenNumber\");"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/macos/window_delegate.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/macos/window_delegate.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/macos/window_delegate.rs",
            "@@ -1588,15 +1588,22 @@",
            "         }",
            "     }",
            " ",
            "     #[inline]",
            "     // Allow directly accessing the current monitor internally without unwrapping.",
            "     pub(crate) fn current_monitor_inner(&self) -> Option<MonitorHandle> {",
            "         let display_id = get_display_id(&*self.window().screen()?);",
            "-        Some(MonitorHandle::new(display_id))",
            "+        if let Some(monitor) = MonitorHandle::new(display_id) {",
            "+            Some(monitor)",
            "+        } else {",
            "+            // NOTE: Display ID was just fetched from live NSScreen, but can still result in `None`",
            "+            // with certain Thunderbolt docked monitors.",
            "+            warn!(display_id, \"got screen with invalid display ID\");",
            "+            None",
            "+        }",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn current_monitor(&self) -> Option<MonitorHandle> {",
            "         self.current_monitor_inner()",
            "     }",
            " ",
            "@@ -1742,49 +1749,51 @@",
            "             self.ivars().saved_style.set(Some(self.window().styleMask()));",
            "             self.ivars().save_presentation_opts.set(Some(app.presentationOptions()));",
            " ",
            "             // Tell our window's state that we're in fullscreen",
            "             self.ivars().is_simple_fullscreen.set(true);",
            " ",
            "             // Simulate pre-Lion fullscreen by hiding the dock and menu bar",
            "-            let presentation_options =",
            "+            let presentation_options = if self.is_borderless_game() {",
            "+                NSApplicationPresentationOptions::NSApplicationPresentationHideDock",
            "+                    | NSApplicationPresentationOptions::NSApplicationPresentationHideMenuBar",
            "+            } else {",
            "                 NSApplicationPresentationOptions::NSApplicationPresentationAutoHideDock",
            "-                    | NSApplicationPresentationOptions::NSApplicationPresentationAutoHideMenuBar;",
            "+                    | NSApplicationPresentationOptions::NSApplicationPresentationAutoHideMenuBar",
            "+            };",
            "             app.setPresentationOptions(presentation_options);",
            " ",
            "             // Hide the titlebar",
            "             self.toggle_style_mask(NSWindowStyleMask::Titled, false);",
            " ",
            "             // Set the window frame to the screen frame size",
            "             let screen = self.window().screen().expect(\"expected screen to be available\");",
            "             self.window().setFrame_display(screen.frame(), true);",
            " ",
            "             // Fullscreen windows can't be resized, minimized, or moved",
            "             self.toggle_style_mask(NSWindowStyleMask::Miniaturizable, false);",
            "             self.toggle_style_mask(NSWindowStyleMask::Resizable, false);",
            "             self.window().setMovable(false);",
            "-",
            "-            true",
            "         } else {",
            "             let new_mask = self.saved_style();",
            "-            self.set_style_mask(new_mask);",
            "             self.ivars().is_simple_fullscreen.set(false);",
            " ",
            "             let save_presentation_opts = self.ivars().save_presentation_opts.get();",
            "             let frame = self.ivars().standard_frame.get().unwrap_or(DEFAULT_STANDARD_FRAME);",
            " ",
            "             if let Some(presentation_opts) = save_presentation_opts {",
            "                 app.setPresentationOptions(presentation_opts);",
            "             }",
            " ",
            "             self.window().setFrame_display(frame, true);",
            "             self.window().setMovable(true);",
            "-",
            "-            true",
            "+            self.set_style_mask(new_mask);",
            "         }",
            "+",
            "+        true",
            "     }",
            " ",
            "     #[inline]",
            "     fn has_shadow(&self) -> bool {",
            "         self.window().hasShadow()",
            "     }"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/orbital/window.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/orbital/window.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/orbital/window.rs",
            "@@ -416,15 +416,15 @@",
            "             window::ResizeDirection::NorthWest => \"T,L\",",
            "             window::ResizeDirection::South => \"B\",",
            "             window::ResizeDirection::SouthEast => \"B,R\",",
            "             window::ResizeDirection::SouthWest => \"B,L\",",
            "             window::ResizeDirection::West => \"L\",",
            "         };",
            "         self.window_socket",
            "-            .write(format!(\"D,{}\", arg).as_bytes())",
            "+            .write(format!(\"D,{arg}\").as_bytes())",
            "             .map_err(|err| error::ExternalError::Os(os_error!(OsError::new(err))))?;",
            "         Ok(())",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn show_window_menu(&self, _position: Position) {}"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/dark_mode.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/dark_mode.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/dark_mode.rs",
            "@@ -128,15 +128,21 @@",
            " }",
            " ",
            " fn should_apps_use_dark_mode() -> bool {",
            "     type ShouldAppsUseDarkMode = unsafe extern \"system\" fn() -> bool;",
            "     static SHOULD_APPS_USE_DARK_MODE: Lazy<Option<ShouldAppsUseDarkMode>> = Lazy::new(|| unsafe {",
            "         const UXTHEME_SHOULDAPPSUSEDARKMODE_ORDINAL: PCSTR = 132 as PCSTR;",
            " ",
            "-        let module = LoadLibraryA(\"uxtheme.dll\\0\".as_ptr());",
            "+        // We won't try to do anything for windows versions < 17763",
            "+        // (Windows 10 October 2018 update)",
            "+        if !*DARK_MODE_SUPPORTED {",
            "+            return None;",
            "+        }",
            "+",
            "+        let module = LoadLibraryA(\"uxtheme.dll\\0\".as_ptr().cast());",
            " ",
            "         if module == 0 {",
            "             return None;",
            "         }",
            " ",
            "         let handle = GetProcAddress(module, UXTHEME_SHOULDAPPSUSEDARKMODE_ORDINAL);"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/event_loop.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/event_loop.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/event_loop.rs",
            "@@ -44,15 +44,15 @@",
            " use windows_sys::Win32::UI::Input::{RAWINPUT, RIM_TYPEKEYBOARD, RIM_TYPEMOUSE};",
            " use windows_sys::Win32::UI::WindowsAndMessaging::{",
            "     CreateWindowExW, DefWindowProcW, DestroyWindow, DispatchMessageW, GetClientRect, GetCursorPos,",
            "     GetMenu, LoadCursorW, MsgWaitForMultipleObjectsEx, PeekMessageW, PostMessageW,",
            "     RegisterClassExW, RegisterWindowMessageA, SetCursor, SetWindowPos, TranslateMessage,",
            "     CREATESTRUCTW, GIDC_ARRIVAL, GIDC_REMOVAL, GWL_STYLE, GWL_USERDATA, HTCAPTION, HTCLIENT,",
            "     MINMAXINFO, MNC_CLOSE, MSG, MWMO_INPUTAVAILABLE, NCCALCSIZE_PARAMS, PM_REMOVE, PT_PEN,",
            "-    PT_TOUCH, QS_ALLEVENTS, RI_MOUSE_HWHEEL, RI_MOUSE_WHEEL, SC_MINIMIZE, SC_RESTORE,",
            "+    PT_TOUCH, QS_ALLINPUT, RI_MOUSE_HWHEEL, RI_MOUSE_WHEEL, SC_MINIMIZE, SC_RESTORE,",
            "     SIZE_MAXIMIZED, SWP_NOACTIVATE, SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, WHEEL_DELTA, WINDOWPOS,",
            "     WMSZ_BOTTOM, WMSZ_BOTTOMLEFT, WMSZ_BOTTOMRIGHT, WMSZ_LEFT, WMSZ_RIGHT, WMSZ_TOP, WMSZ_TOPLEFT,",
            "     WMSZ_TOPRIGHT, WM_CAPTURECHANGED, WM_CLOSE, WM_CREATE, WM_DESTROY, WM_DPICHANGED,",
            "     WM_ENTERSIZEMOVE, WM_EXITSIZEMOVE, WM_GETMINMAXINFO, WM_IME_COMPOSITION, WM_IME_ENDCOMPOSITION,",
            "     WM_IME_SETCONTEXT, WM_IME_STARTCOMPOSITION, WM_INPUT, WM_INPUT_DEVICE_CHANGE, WM_KEYDOWN,",
            "     WM_KEYUP, WM_KILLFOCUS, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MBUTTONDOWN, WM_MBUTTONUP,",
            "     WM_MENUCHAR, WM_MOUSEHWHEEL, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_NCACTIVATE, WM_NCCALCSIZE,",
            "@@ -741,19 +741,20 @@",
            "         //  1. User wants to wait indefinely if timeout is not set.",
            "         //  2. We failed to get and set high resolution timer and we need something instead of it.",
            "         let wait_duration_ms = timeout.map(dur2timeout).unwrap_or(INFINITE);",
            " ",
            "         let (num_handles, raw_handles) =",
            "             if use_timer { (1, [high_resolution_timer.unwrap()]) } else { (0, [ptr::null_mut()]) };",
            " ",
            "+        // We must use `QS_ALLINPUT` to wake on accessibility messages.",
            "         let result = MsgWaitForMultipleObjectsEx(",
            "             num_handles,",
            "             raw_handles.as_ptr() as *const _,",
            "             wait_duration_ms,",
            "-            QS_ALLEVENTS,",
            "+            QS_ALLINPUT,",
            "             MWMO_INPUTAVAILABLE,",
            "         );",
            "         if result == WAIT_FAILED {",
            "             // Well, nothing smart to do in such case.",
            "             // Treat it as spurious wake up.",
            "             tracing::warn!(\"Failed to MsgWaitForMultipleObjectsEx: error code {}\", GetLastError(),);",
            "         }",
            "@@ -1211,14 +1212,39 @@",
            " ",
            "             state.set_window_flags_in_place(|f| f.remove(WindowFlags::MARKER_IN_SIZE_MOVE));",
            "             result = ProcResult::Value(0);",
            "         },",
            " ",
            "         WM_NCLBUTTONDOWN => {",
            "             if wparam == HTCAPTION as _ {",
            "+                // Prevent the user event loop from pausing when left clicking the title bar.",
            "+                //",
            "+                // When the user interacts with the title bar, Windows enters the modal event",
            "+                // loop. Currently, a left click causes a pause for about 500ms. Sending a dummy",
            "+                // mouse-move event seems to cancel the modal loop early, preventing the pause.",
            "+                // The application will never see this dummy event.",
            "+                //",
            "+                // The mouse coordinates are encoded into the lparam value, however the WM_MOUSEMOVE",
            "+                // event is not using the same coordinate system of the WM_NCLBUTTONDOWN event.",
            "+                // One uses client-area coordinates and the other is screen-coordinates. In any",
            "+                // case, passing the lparam as-is with the dummy event does not seem the cancel",
            "+                // the modal loop.",
            "+                //",
            "+                // However, passing in a value of 0 has been observed to always cancel the pause.",
            "+                //",
            "+                // Other notes:",
            "+                //",
            "+                // For some unknown reason, the cursor will blink when clicking the title bar.",
            "+                // Cancelling the modal loop early causes the blink to happen *immediately*.",
            "+                // Otherwise, the blank happens *after* the pause.",
            "+                //",
            "+                // When right-click the title bar, the system window menu is presented to the user,",
            "+                // and the modal event loop begins. This dummy event does *not* prevent the freeze",
            "+                // in the main event loop caused by that popup menu.",
            "+                let lparam = 0;",
            "                 unsafe { PostMessageW(window, WM_MOUSEMOVE, 0, lparam) };",
            "             }",
            "             result = ProcResult::DefWindowProc(wparam);",
            "         },",
            " ",
            "         WM_CLOSE => {",
            "             use crate::event::WindowEvent::CloseRequested;"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/icon.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/icon.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/icon.rs",
            "@@ -106,20 +106,35 @@",
            "         }",
            "     }",
            " ",
            "     pub fn from_resource(",
            "         resource_id: u16,",
            "         size: Option<PhysicalSize<u32>>,",
            "     ) -> Result<Self, BadIcon> {",
            "+        Self::from_resource_ptr(resource_id as PCWSTR, size)",
            "+    }",
            "+",
            "+    pub fn from_resource_name(",
            "+        resource_name: &str,",
            "+        size: Option<PhysicalSize<u32>>,",
            "+    ) -> Result<Self, BadIcon> {",
            "+        let wide_name = util::encode_wide(resource_name);",
            "+        Self::from_resource_ptr(wide_name.as_ptr(), size)",
            "+    }",
            "+",
            "+    fn from_resource_ptr(",
            "+        resource: PCWSTR,",
            "+        size: Option<PhysicalSize<u32>>,",
            "+    ) -> Result<Self, BadIcon> {",
            "         // width / height of 0 along with LR_DEFAULTSIZE tells windows to load the default icon size",
            "         let (width, height) = size.map(Into::into).unwrap_or((0, 0));",
            "         let handle = unsafe {",
            "             LoadImageW(",
            "                 util::get_instance_handle(),",
            "-                resource_id as PCWSTR,",
            "+                resource,",
            "                 IMAGE_ICON,",
            "                 width,",
            "                 height,",
            "                 LR_DEFAULTSIZE,",
            "             )",
            "         };",
            "         if handle != 0 {"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/ime.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/ime.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/ime.rs",
            "@@ -31,26 +31,32 @@",
            "     ) -> Option<(String, Option<usize>, Option<usize>)> {",
            "         let text = unsafe { self.get_composition_string(GCS_COMPSTR) }?;",
            "         let attrs = unsafe { self.get_composition_data(GCS_COMPATTR) }.unwrap_or_default();",
            " ",
            "         let mut first = None;",
            "         let mut last = None;",
            "         let mut boundary_before_char = 0;",
            "+        let mut attr_idx = 0;",
            "+",
            "+        for chr in text.chars() {",
            "+            let Some(attr) = attrs.get(attr_idx).copied() else {",
            "+                break;",
            "+            };",
            " ",
            "-        for (attr, chr) in attrs.into_iter().zip(text.chars()) {",
            "             let char_is_targeted =",
            "                 attr as u32 == ATTR_TARGET_CONVERTED || attr as u32 == ATTR_TARGET_NOTCONVERTED;",
            " ",
            "             if first.is_none() && char_is_targeted {",
            "                 first = Some(boundary_before_char);",
            "             } else if first.is_some() && last.is_none() && !char_is_targeted {",
            "                 last = Some(boundary_before_char);",
            "             }",
            " ",
            "             boundary_before_char += chr.len_utf8();",
            "+            attr_idx += chr.len_utf16();",
            "         }",
            " ",
            "         if first.is_some() && last.is_none() {",
            "             last = Some(text.len());",
            "         } else if first.is_none() {",
            "             // IME haven't split words and select any clause yet, so trying to retrieve normal",
            "             // cursor."
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/keyboard.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/keyboard.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/keyboard.rs",
            "@@ -209,16 +209,15 @@",
            "                     std::mem::drop(event_info);",
            "                     let next_msg = next_kbd_msg(hwnd);",
            "                     let more_char_coming = next_msg",
            "                         .map(|m| matches!(m.message, WM_CHAR | WM_SYSCHAR))",
            "                         .unwrap_or(false);",
            "                     if more_char_coming {",
            "                         // No need to produce an event just yet, because there are still more",
            "-                        // characters that need to appended to this keyobard",
            "-                        // event",
            "+                        // characters that need to be appended to this keyboard event",
            "                         MatchResult::TokenToRemove(pending_token)",
            "                     } else {",
            "                         let mut event_info = self.event_info.lock().unwrap();",
            "                         let mut event_info = match event_info.take() {",
            "                             Some(ev_info) => ev_info,",
            "                             None => {",
            "                                 warn!(\"The event_info was None when it was expected to be some\");",
            "@@ -331,16 +330,16 @@",
            "         let caps_lock_on = kbd_state[VK_CAPITAL as usize] & 1 != 0;",
            "         let num_lock_on = kbd_state[VK_NUMLOCK as usize] & 1 != 0;",
            " ",
            "         // We are synthesizing the press event for caps-lock first for the following reasons:",
            "         // 1. If caps-lock is *not* held down but *is* active, then we have to synthesize all",
            "         //    printable keys, respecting the caps-lock state.",
            "         // 2. If caps-lock is held down, we could choose to synthesize its keypress after every",
            "-        //    other key, in which case all other keys *must* be sythesized as if the caps-lock state",
            "-        //    was be the opposite of what it currently is.",
            "+        //    other key, in which case all other keys *must* be synthesized as if the caps-lock",
            "+        //    state was be the opposite of what it currently is.",
            "         // --",
            "         // For the sake of simplicity we are choosing to always synthesize",
            "         // caps-lock first, and always use the current caps-lock state",
            "         // to determine the produced text",
            "         if is_key_pressed!(VK_CAPITAL) {",
            "             let event = Self::create_synthetic(",
            "                 VK_CAPITAL,"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/raw_input.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/raw_input.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/raw_input.rs",
            "@@ -221,24 +221,24 @@",
            "         unsafe { MapVirtualKeyW(keyboard.VKey as u32, MAPVK_VK_TO_VSC_EX) as u16 }",
            "     } else {",
            "         keyboard.MakeCode | extension",
            "     };",
            "     if scancode == 0xe11d || scancode == 0xe02a {",
            "         // At the hardware (or driver?) level, pressing the Pause key is equivalent to pressing",
            "         // Ctrl+NumLock.",
            "-        // This equvalence means that if the user presses Pause, the keyboard will emit two",
            "+        // This equivalence means that if the user presses Pause, the keyboard will emit two",
            "         // subsequent keypresses:",
            "         // 1, 0xE11D - Which is a left Ctrl (0x1D) with an extension flag (0xE100)",
            "         // 2, 0x0045 - Which on its own can be interpreted as Pause",
            "         //",
            "         // There's another combination which isn't quite an equivalence:",
            "-        // PrtSc used to be Shift+Asterisk. This means that on some keyboards, presssing",
            "+        // PrtSc used to be Shift+Asterisk. This means that on some keyboards, pressing",
            "         // PrtSc (print screen) produces the following sequence:",
            "         // 1, 0xE02A - Which is a left shift (0x2A) with an extension flag (0xE000)",
            "-        // 2, 0xE037 - Which is a numpad multiply (0x37) with an exteion flag (0xE000). This on",
            "+        // 2, 0xE037 - Which is a numpad multiply (0x37) with an extension flag (0xE000). This on",
            "         //             its own it can be interpreted as PrtSc",
            "         //",
            "         // For this reason, if we encounter the first keypress, we simply ignore it, trusting",
            "         // that there's going to be another event coming, from which we can extract the",
            "         // appropriate key.",
            "         // For more on this, read the article by Raymond Chen, titled:",
            "         // \"Why does Ctrl+ScrollLock cancel dialogs?\""
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/util.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/util.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/util.rs",
            "@@ -3,27 +3,27 @@",
            " use std::ops::BitAnd;",
            " use std::os::windows::prelude::{OsStrExt, OsStringExt};",
            " use std::sync::atomic::{AtomicBool, Ordering};",
            " use std::{io, mem, ptr};",
            " ",
            " use crate::utils::Lazy;",
            " use windows_sys::core::{HRESULT, PCWSTR};",
            "-use windows_sys::Win32::Foundation::{BOOL, HANDLE, HMODULE, HWND, RECT};",
            "+use windows_sys::Win32::Foundation::{BOOL, HANDLE, HMODULE, HWND, POINT, RECT};",
            " use windows_sys::Win32::Graphics::Gdi::{ClientToScreen, HMONITOR};",
            " use windows_sys::Win32::System::LibraryLoader::{GetProcAddress, LoadLibraryA};",
            " use windows_sys::Win32::System::SystemServices::IMAGE_DOS_HEADER;",
            " use windows_sys::Win32::UI::HiDpi::{",
            "     DPI_AWARENESS_CONTEXT, MONITOR_DPI_TYPE, PROCESS_DPI_AWARENESS,",
            " };",
            " use windows_sys::Win32::UI::Input::KeyboardAndMouse::GetActiveWindow;",
            " use windows_sys::Win32::UI::Input::Pointer::{POINTER_INFO, POINTER_PEN_INFO, POINTER_TOUCH_INFO};",
            " use windows_sys::Win32::UI::WindowsAndMessaging::{",
            "-    ClipCursor, GetClientRect, GetClipCursor, GetSystemMetrics, GetWindowPlacement, GetWindowRect,",
            "-    IsIconic, ShowCursor, IDC_APPSTARTING, IDC_ARROW, IDC_CROSS, IDC_HAND, IDC_HELP, IDC_IBEAM,",
            "-    IDC_NO, IDC_SIZEALL, IDC_SIZENESW, IDC_SIZENS, IDC_SIZENWSE, IDC_SIZEWE, IDC_WAIT,",
            "+    ClipCursor, GetClientRect, GetClipCursor, GetCursorPos, GetSystemMetrics, GetWindowPlacement,",
            "+    GetWindowRect, IsIconic, ShowCursor, IDC_APPSTARTING, IDC_ARROW, IDC_CROSS, IDC_HAND, IDC_HELP,",
            "+    IDC_IBEAM, IDC_NO, IDC_SIZEALL, IDC_SIZENESW, IDC_SIZENS, IDC_SIZENWSE, IDC_SIZEWE, IDC_WAIT,",
            "     SM_CXVIRTUALSCREEN, SM_CYVIRTUALSCREEN, SM_XVIRTUALSCREEN, SM_YVIRTUALSCREEN, SW_MAXIMIZE,",
            "     WINDOWPLACEMENT,",
            " };",
            " ",
            " use crate::window::CursorIcon;",
            " ",
            " pub fn encode_wide(string: impl AsRef<OsStr>) -> Vec<u16> {",
            "@@ -95,14 +95,21 @@",
            "     static HIDDEN: AtomicBool = AtomicBool::new(false);",
            "     let changed = HIDDEN.swap(hidden, Ordering::SeqCst) ^ hidden;",
            "     if changed {",
            "         unsafe { ShowCursor(BOOL::from(!hidden)) };",
            "     }",
            " }",
            " ",
            "+pub fn get_cursor_position() -> Result<POINT, io::Error> {",
            "+    unsafe {",
            "+        let mut point: POINT = mem::zeroed();",
            "+        win_to_err(GetCursorPos(&mut point)).map(|_| point)",
            "+    }",
            "+}",
            "+",
            " pub fn get_cursor_clip() -> Result<RECT, io::Error> {",
            "     unsafe {",
            "         let mut rect: RECT = mem::zeroed();",
            "         win_to_err(GetClipCursor(&mut rect)).map(|_| rect)",
            "     }",
            " }",
            " ",
            "@@ -217,39 +224,39 @@",
            "     dpi_type: MONITOR_DPI_TYPE,",
            "     dpi_x: *mut u32,",
            "     dpi_y: *mut u32,",
            " ) -> HRESULT;",
            " pub type EnableNonClientDpiScaling = unsafe extern \"system\" fn(hwnd: HWND) -> BOOL;",
            " pub type AdjustWindowRectExForDpi = unsafe extern \"system\" fn(",
            "     rect: *mut RECT,",
            "-    dwStyle: u32,",
            "-    bMenu: BOOL,",
            "-    dwExStyle: u32,",
            "+    dw_style: u32,",
            "+    b_menu: BOOL,",
            "+    dw_ex_style: u32,",
            "     dpi: u32,",
            " ) -> BOOL;",
            " ",
            " pub type GetPointerFrameInfoHistory = unsafe extern \"system\" fn(",
            "-    pointerId: u32,",
            "-    entriesCount: *mut u32,",
            "-    pointerCount: *mut u32,",
            "-    pointerInfo: *mut POINTER_INFO,",
            "+    pointer_id: u32,",
            "+    entries_count: *mut u32,",
            "+    pointer_count: *mut u32,",
            "+    pointer_info: *mut POINTER_INFO,",
            " ) -> BOOL;",
            " ",
            "-pub type SkipPointerFrameMessages = unsafe extern \"system\" fn(pointerId: u32) -> BOOL;",
            "+pub type SkipPointerFrameMessages = unsafe extern \"system\" fn(pointer_id: u32) -> BOOL;",
            " pub type GetPointerDeviceRects = unsafe extern \"system\" fn(",
            "     device: HANDLE,",
            "-    pointerDeviceRect: *mut RECT,",
            "-    displayRect: *mut RECT,",
            "+    pointer_device_rect: *mut RECT,",
            "+    display_rect: *mut RECT,",
            " ) -> BOOL;",
            " ",
            " pub type GetPointerTouchInfo =",
            "-    unsafe extern \"system\" fn(pointerId: u32, touchInfo: *mut POINTER_TOUCH_INFO) -> BOOL;",
            "+    unsafe extern \"system\" fn(pointer_id: u32, touch_info: *mut POINTER_TOUCH_INFO) -> BOOL;",
            " ",
            " pub type GetPointerPenInfo =",
            "-    unsafe extern \"system\" fn(pointId: u32, penInfo: *mut POINTER_PEN_INFO) -> BOOL;",
            "+    unsafe extern \"system\" fn(point_id: u32, pen_info: *mut POINTER_PEN_INFO) -> BOOL;",
            " ",
            " pub(crate) static GET_DPI_FOR_WINDOW: Lazy<Option<GetDpiForWindow>> =",
            "     Lazy::new(|| get_function!(\"user32.dll\", GetDpiForWindow));",
            " pub(crate) static ADJUST_WINDOW_RECT_EX_FOR_DPI: Lazy<Option<AdjustWindowRectExForDpi>> =",
            "     Lazy::new(|| get_function!(\"user32.dll\", AdjustWindowRectExForDpi));",
            " pub(crate) static GET_DPI_FOR_MONITOR: Lazy<Option<GetDpiForMonitor>> =",
            "     Lazy::new(|| get_function!(\"shcore.dll\", GetDpiForMonitor));"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/window.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/window.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/window.rs",
            "@@ -424,33 +424,28 @@",
            "                 });",
            "             },",
            "         }",
            "     }",
            " ",
            "     #[inline]",
            "     pub fn set_cursor_grab(&self, mode: CursorGrabMode) -> Result<(), ExternalError> {",
            "-        let confine = match mode {",
            "-            CursorGrabMode::None => false,",
            "-            CursorGrabMode::Confined => true,",
            "-            CursorGrabMode::Locked => {",
            "-                return Err(ExternalError::NotSupported(NotSupportedError::new()))",
            "-            },",
            "-        };",
            "-",
            "         let window = self.window;",
            "         let window_state = Arc::clone(&self.window_state);",
            "         let (tx, rx) = channel();",
            " ",
            "         self.thread_executor.execute_in_thread(move || {",
            "             let _ = &window;",
            "             let result = window_state",
            "                 .lock()",
            "                 .unwrap()",
            "                 .mouse",
            "-                .set_cursor_flags(window, |f| f.set(CursorFlags::GRABBED, confine))",
            "+                .set_cursor_flags(window, |f| {",
            "+                    f.set(CursorFlags::GRABBED, mode != CursorGrabMode::None);",
            "+                    f.set(CursorFlags::LOCKED, mode == CursorGrabMode::Locked);",
            "+                })",
            "                 .map_err(|e| ExternalError::Os(os_error!(e)));",
            "             let _ = tx.send(result);",
            "         });",
            "         rx.recv().unwrap()",
            "     }",
            " ",
            "     #[inline]"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/platform_impl/windows/window_state.rs",
          "change": [
            "--- /home/winit-0.30.7/src/platform_impl/windows/window_state.rs",
            "+++ /home/winit-0.30.11/src/platform_impl/windows/window_state.rs",
            "@@ -73,14 +73,15 @@",
            " ",
            " bitflags! {",
            "     #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
            "     pub struct CursorFlags: u8 {",
            "         const GRABBED   = 1 << 0;",
            "         const HIDDEN    = 1 << 1;",
            "         const IN_WINDOW = 1 << 2;",
            "+        const LOCKED    = 1 << 3;",
            "     }",
            " }",
            " bitflags! {",
            "     #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
            "     pub struct WindowFlags: u32 {",
            "         const RESIZABLE         = 1 << 0;",
            "         const MINIMIZABLE       = 1 << 1;",
            "@@ -481,15 +482,30 @@",
            " impl CursorFlags {",
            "     fn refresh_os_cursor(self, window: HWND) -> Result<(), io::Error> {",
            "         let client_rect = util::WindowArea::Inner.get_rect(window)?;",
            " ",
            "         if util::is_focused(window) {",
            "             let cursor_clip = match self.contains(CursorFlags::GRABBED) {",
            "                 true => {",
            "-                    if self.contains(CursorFlags::HIDDEN) {",
            "+                    if self.contains(CursorFlags::LOCKED) {",
            "+                        if let Ok(pos) = util::get_cursor_position() {",
            "+                            Some(RECT {",
            "+                                left: pos.x,",
            "+                                right: pos.x + 1,",
            "+                                top: pos.y,",
            "+                                bottom: pos.y + 1,",
            "+                            })",
            "+                        } else {",
            "+                            // If lock is applied while the cursor is not available, lock it to the",
            "+                            // middle of the window.",
            "+                            let cx = (client_rect.left + client_rect.right) / 2;",
            "+                            let cy = (client_rect.top + client_rect.bottom) / 2;",
            "+                            Some(RECT { left: cx, right: cx + 1, top: cy, bottom: cy + 1 })",
            "+                        }",
            "+                    } else if self.contains(CursorFlags::HIDDEN) {",
            "                         // Confine the cursor to the center of the window if the cursor is hidden.",
            "                         // This avoids problems with the cursor activating",
            "                         // the taskbar if the window borders or overlaps that.",
            "                         let cx = (client_rect.left + client_rect.right) / 2;",
            "                         let cy = (client_rect.top + client_rect.bottom) / 2;",
            "                         Some(RECT { left: cx, right: cx + 1, top: cy, bottom: cy + 1 })",
            "                     } else {"
          ]
        },
        {
          "file": "/home/winit-0.30.11/src/window.rs",
          "change": [
            "--- /home/winit-0.30.7/src/window.rs",
            "+++ /home/winit-0.30.11/src/window.rs",
            "@@ -1703,16 +1703,15 @@",
            "     /// The cursor is locked inside the window area to the certain position.",
            "     ///",
            "     /// There's no guarantee that the cursor will be hidden. You should hide it by yourself if you",
            "     /// want to do so.",
            "     ///",
            "     /// ## Platform-specific",
            "     ///",
            "-    /// - **X11 / Windows:** Not implemented. Always returns [`ExternalError::NotSupported`] for",
            "-    ///   now.",
            "+    /// - **X11:** Not implemented. Always returns [`ExternalError::NotSupported`] for now.",
            "     /// - **iOS / Android:** Always returns an [`ExternalError::NotSupported`].",
            "     Locked,",
            " }",
            " ",
            " /// Defines the orientation that a window resize will be performed.",
            " #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]",
            " pub enum ResizeDirection {",
            "@@ -1846,15 +1845,38 @@",
            " }",
            " ",
            " /// An opaque token used to activate the [`Window`].",
            " ///",
            " /// [`Window`]: crate::window::Window",
            " #[derive(Debug, PartialEq, Eq, Clone)]",
            " pub struct ActivationToken {",
            "-    pub(crate) _token: String,",
            "+    pub(crate) token: String,",
            " }",
            " ",
            " impl ActivationToken {",
            "-    pub(crate) fn _new(_token: String) -> Self {",
            "-        Self { _token }",
            "+    /// Make an [`ActivationToken`] from a string.",
            "+    ///",
            "+    /// This method should be used to wrap tokens passed by side channels to your application, like",
            "+    /// dbus.",
            "+    ///",
            "+    /// The validity of the token is ensured by the windowing system. Using the invalid token will",
            "+    /// only result in the side effect of the operation involving it being ignored (e.g. window",
            "+    /// won't get focused automatically), but won't yield any errors.",
            "+    ///",
            "+    /// To obtain a valid token, use",
            "+    #[cfg_attr(",
            "+        any(x11_platform, wayland_platform, docsrs),",
            "+        doc = \" [`request_activation_token`](crate::platform::startup_notify::WindowExtStartupNotify::request_activation_token).\"",
            "+    )]",
            "+    #[cfg_attr(",
            "+        not(any(x11_platform, wayland_platform, docsrs)),",
            "+        doc = \" `request_activation_token`.\"",
            "+    )]",
            "+    pub fn from_raw(token: String) -> Self {",
            "+        Self { token }",
            "+    }",
            "+",
            "+    /// Convert the token to its string representation to later pass via IPC.",
            "+    pub fn into_raw(self) -> String {",
            "+        self.token",
            "     }",
            " }"
          ]
        }
      ]
    }
  }
}